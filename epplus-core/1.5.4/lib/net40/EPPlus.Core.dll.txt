internal class CellsStoreEnumerator`1 : object {
    private CellStore`1<T> _cellStore;
    private int row;
    private int colPos;
    private Int32[] pagePos;
    private Int32[] cellPos;
    private int _startRow;
    private int _startCol;
    private int _endRow;
    private int _endCol;
    private int minRow;
    private int minColPos;
    private int maxRow;
    private int maxColPos;
    internal int Row { get; }
    internal int Column { get; }
    internal T Value { get; internal set; }
    public string CellAddress { get; }
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public CellsStoreEnumerator`1(CellStore`1<T> cellStore);
    public CellsStoreEnumerator`1(CellStore`1<T> cellStore, int StartRow, int StartCol, int EndRow, int EndCol);
    internal void Init();
    internal int get_Row();
    internal int get_Column();
    internal T get_Value();
    internal void set_Value(T value);
    internal bool Next();
    internal bool Previous();
    public string get_CellAddress();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual T get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class CellStore`1 : object {
    internal static int pageBits;
    internal static int PageSize;
    internal static int PageSizeMin;
    internal static int PageSizeMax;
    internal static int ColSizeMin;
    internal static int PagesPerColumnMin;
    private List`1<T> _values;
    internal ColumnIndex[] _columnIndex;
    internal IndexBase _searchIx;
    internal IndexItem _searchItem;
    internal int ColumnCount;
    private int _colPos;
    private int _row;
    internal int Count { get; }
    public ulong Current { get; }
    protected virtual override void Finalize();
    internal int GetPosition(int Column);
    internal CellStore`1<T> Clone();
    internal int get_Count();
    internal bool GetDimension(Int32& fromRow, Int32& fromCol, Int32& toRow, Int32& toCol);
    internal int FindNext(int Column);
    internal T GetValue(int Row, int Column);
    private int GetPointer(int Row, int Column);
    internal bool Exists(int Row, int Column);
    internal bool Exists(int Row, int Column, T& value);
    internal void SetValue(int Row, int Column, T Value);
    internal void SetRangeValueSpecial(int fromRow, int fromColumn, int toRow, int toColumn, SetRangeValueDelegate<T> Updater, object Value);
    internal void SetValueSpecial(int Row, int Column, SetValueDelegate<T> Updater, object Value);
    internal void Insert(int fromRow, int fromCol, int rows, int columns);
    internal void Clear(int fromRow, int fromCol, int rows, int columns);
    internal void Delete(int fromRow, int fromCol, int rows, int columns);
    internal void Delete(int fromRow, int fromCol, int rows, int columns, bool shift);
    private void UpdatePageOffset(ColumnIndex column, int pagePos, int rows);
    private int ResetPageOffset(ColumnIndex column, int pagePos, int rows);
    private int DeletePage(int fromRow, int rows, ColumnIndex column, int pagePos, bool shift);
    private int DeleteCells(PageIndex page, int fromRow, int toRow, bool shift);
    private static void UpdateRowIndex(PageIndex page, int toPos, int rows);
    private void DeleteColumns(int fromCol, int columns, bool shift);
    private void UpdateIndexOffset(ColumnIndex column, int pagePos, int rowPos, int row, int rows);
    private void SplitPageInsert(ColumnIndex column, int pagePos, int rowPos, int rows, int size, int addPages);
    private void CopyMergePage(PageIndex page, int rowPos, int rows, int size, PageIndex ToPage);
    private void MergePage(ColumnIndex column, int pagePos);
    private PageIndex CopyNew(PageIndex pageFrom, int rowPos, int size);
    internal static int GetSize(int size);
    private void AddCell(ColumnIndex columnIndex, int pagePos, int pos, short ix, T value);
    private int SplitPage(ColumnIndex columnIndex, int pagePos);
    private PageIndex AdjustIndex(ColumnIndex columnIndex, int pagePos);
    private void AddPageRowOffset(PageIndex page, short offset);
    private void AddPage(ColumnIndex column, int pos, short index);
    private void AddPage(ColumnIndex column, int pos, PageIndex page);
    private void AddPage(ColumnIndex column, int pos);
    private void AddColumn(int pos, int Column);
    public ulong get_Current();
    public sealed virtual void Dispose();
    public bool MoveNext();
    internal bool NextCell(Int32& row, Int32& col);
    internal bool NextCell(Int32& row, Int32& col, int minRow, int minColPos, int maxRow, int maxColPos);
    internal bool GetNextCell(Int32& row, Int32& colPos, int startColPos, int endRow, int endColPos);
    internal bool GetNextCell(Int32& row, Int32& colPos, int startColPos, int endRow, int endColPos, Int32[]& pagePos, Int32[]& cellPos);
    internal bool PrevCell(Int32& row, Int32& col);
    internal bool PrevCell(Int32& row, Int32& col, int minRow, int minColPos, int maxRow, int maxColPos);
    internal bool GetPrevCell(Int32& row, Int32& colPos, int startRow, int startColPos, int endColPos);
    public void Reset();
}
internal class ColumnIndex : IndexBase {
    internal IndexBase _searchIx;
    internal PageIndex[] _pages;
    internal int PageCount;
    protected virtual override void Finalize();
    internal int GetPosition(int Row);
    private bool GetPage(int Row, Int32& res);
    internal int GetNextRow(int row);
    internal int FindNext(int Page);
    public sealed virtual void Dispose();
}
public enum eEndSize : Enum {
    public int value__;
    public static eEndSize Small;
    public static eEndSize Medium;
    public static eEndSize Large;
}
public enum eEndStyle : Enum {
    public int value__;
    public static eEndStyle None;
    public static eEndStyle Triangle;
    public static eEndStyle Stealth;
    public static eEndStyle Diamond;
    public static eEndStyle Oval;
    public static eEndStyle Arrow;
}
public enum eFillStyle : Enum {
    public int value__;
    public static eFillStyle NoFill;
    public static eFillStyle SolidFill;
    public static eFillStyle GradientFill;
    public static eFillStyle PatternFill;
    public static eFillStyle BlipFill;
    public static eFillStyle GroupFill;
}
public enum eShapeStyle : Enum {
    public int value__;
    public static eShapeStyle AccentBorderCallout1;
    public static eShapeStyle AccentBorderCallout2;
    public static eShapeStyle AccentBorderCallout3;
    public static eShapeStyle AccentCallout1;
    public static eShapeStyle AccentCallout2;
    public static eShapeStyle AccentCallout3;
    public static eShapeStyle ActionButtonBackPrevious;
    public static eShapeStyle ActionButtonBeginning;
    public static eShapeStyle ActionButtonBlank;
    public static eShapeStyle ActionButtonDocument;
    public static eShapeStyle ActionButtonEnd;
    public static eShapeStyle ActionButtonForwardNext;
    public static eShapeStyle ActionButtonHelp;
    public static eShapeStyle ActionButtonHome;
    public static eShapeStyle ActionButtonInformation;
    public static eShapeStyle ActionButtonMovie;
    public static eShapeStyle ActionButtonReturn;
    public static eShapeStyle ActionButtonSound;
    public static eShapeStyle Arc;
    public static eShapeStyle BentArrow;
    public static eShapeStyle BentConnector2;
    public static eShapeStyle BentConnector3;
    public static eShapeStyle BentConnector4;
    public static eShapeStyle BentConnector5;
    public static eShapeStyle BentUpArrow;
    public static eShapeStyle Bevel;
    public static eShapeStyle BlockArc;
    public static eShapeStyle BorderCallout1;
    public static eShapeStyle BorderCallout2;
    public static eShapeStyle BorderCallout3;
    public static eShapeStyle BracePair;
    public static eShapeStyle BracketPair;
    public static eShapeStyle Callout1;
    public static eShapeStyle Callout2;
    public static eShapeStyle Callout3;
    public static eShapeStyle Can;
    public static eShapeStyle ChartPlus;
    public static eShapeStyle ChartStar;
    public static eShapeStyle ChartX;
    public static eShapeStyle Chevron;
    public static eShapeStyle Chord;
    public static eShapeStyle CircularArrow;
    public static eShapeStyle Cloud;
    public static eShapeStyle CloudCallout;
    public static eShapeStyle Corner;
    public static eShapeStyle CornerTabs;
    public static eShapeStyle Cube;
    public static eShapeStyle CurvedConnector2;
    public static eShapeStyle CurvedConnector3;
    public static eShapeStyle CurvedConnector4;
    public static eShapeStyle CurvedConnector5;
    public static eShapeStyle CurvedDownArrow;
    public static eShapeStyle CurvedLeftArrow;
    public static eShapeStyle CurvedRightArrow;
    public static eShapeStyle CurvedUpArrow;
    public static eShapeStyle Decagon;
    public static eShapeStyle DiagStripe;
    public static eShapeStyle Diamond;
    public static eShapeStyle Dodecagon;
    public static eShapeStyle Donut;
    public static eShapeStyle DoubleWave;
    public static eShapeStyle DownArrow;
    public static eShapeStyle DownArrowCallout;
    public static eShapeStyle Ellipse;
    public static eShapeStyle EllipseRibbon;
    public static eShapeStyle EllipseRibbon2;
    public static eShapeStyle FlowChartAlternateProcess;
    public static eShapeStyle FlowChartCollate;
    public static eShapeStyle FlowChartConnector;
    public static eShapeStyle FlowChartDecision;
    public static eShapeStyle FlowChartDelay;
    public static eShapeStyle FlowChartDisplay;
    public static eShapeStyle FlowChartDocument;
    public static eShapeStyle FlowChartExtract;
    public static eShapeStyle FlowChartInputOutput;
    public static eShapeStyle FlowChartInternalStorage;
    public static eShapeStyle FlowChartMagneticDisk;
    public static eShapeStyle FlowChartMagneticDrum;
    public static eShapeStyle FlowChartMagneticTape;
    public static eShapeStyle FlowChartManualInput;
    public static eShapeStyle FlowChartManualOperation;
    public static eShapeStyle FlowChartMerge;
    public static eShapeStyle FlowChartMultidocument;
    public static eShapeStyle FlowChartOfflineStorage;
    public static eShapeStyle FlowChartOffpageConnector;
    public static eShapeStyle FlowChartOnlineStorage;
    public static eShapeStyle FlowChartOr;
    public static eShapeStyle FlowChartPredefinedProcess;
    public static eShapeStyle FlowChartPreparation;
    public static eShapeStyle FlowChartProcess;
    public static eShapeStyle FlowChartPunchedCard;
    public static eShapeStyle FlowChartPunchedTape;
    public static eShapeStyle FlowChartSort;
    public static eShapeStyle FlowChartSummingJunction;
    public static eShapeStyle FlowChartTerminator;
    public static eShapeStyle FoldedCorner;
    public static eShapeStyle Frame;
    public static eShapeStyle Funnel;
    public static eShapeStyle Gear6;
    public static eShapeStyle Gear9;
    public static eShapeStyle HalfFrame;
    public static eShapeStyle Heart;
    public static eShapeStyle Heptagon;
    public static eShapeStyle Hexagon;
    public static eShapeStyle HomePlate;
    public static eShapeStyle HorizontalScroll;
    public static eShapeStyle IrregularSeal1;
    public static eShapeStyle IrregularSeal2;
    public static eShapeStyle LeftArrow;
    public static eShapeStyle LeftArrowCallout;
    public static eShapeStyle LeftBrace;
    public static eShapeStyle LeftBracket;
    public static eShapeStyle LeftCircularArrow;
    public static eShapeStyle LeftRightArrow;
    public static eShapeStyle LeftRightArrowCallout;
    public static eShapeStyle LeftRightCircularArrow;
    public static eShapeStyle LeftRightRibbon;
    public static eShapeStyle LeftRightUpArrow;
    public static eShapeStyle LeftUpArrow;
    public static eShapeStyle LightningBolt;
    public static eShapeStyle Line;
    public static eShapeStyle LineInv;
    public static eShapeStyle MathDivide;
    public static eShapeStyle MathEqual;
    public static eShapeStyle MathMinus;
    public static eShapeStyle MathMultiply;
    public static eShapeStyle MathNotEqual;
    public static eShapeStyle MathPlus;
    public static eShapeStyle Moon;
    public static eShapeStyle NonIsoscelesTrapezoid;
    public static eShapeStyle NoSmoking;
    public static eShapeStyle NotchedRightArrow;
    public static eShapeStyle Octagon;
    public static eShapeStyle Parallelogram;
    public static eShapeStyle Pentagon;
    public static eShapeStyle Pie;
    public static eShapeStyle PieWedge;
    public static eShapeStyle Plaque;
    public static eShapeStyle PlaqueTabs;
    public static eShapeStyle Plus;
    public static eShapeStyle QuadArrow;
    public static eShapeStyle QuadArrowCallout;
    public static eShapeStyle Rect;
    public static eShapeStyle Ribbon;
    public static eShapeStyle Ribbon2;
    public static eShapeStyle RightArrow;
    public static eShapeStyle RightArrowCallout;
    public static eShapeStyle RightBrace;
    public static eShapeStyle RightBracket;
    public static eShapeStyle Round1Rect;
    public static eShapeStyle Round2DiagRect;
    public static eShapeStyle Round2SameRect;
    public static eShapeStyle RoundRect;
    public static eShapeStyle RtTriangle;
    public static eShapeStyle SmileyFace;
    public static eShapeStyle Snip1Rect;
    public static eShapeStyle Snip2DiagRect;
    public static eShapeStyle Snip2SameRect;
    public static eShapeStyle SnipRoundRect;
    public static eShapeStyle SquareTabs;
    public static eShapeStyle Star10;
    public static eShapeStyle Star12;
    public static eShapeStyle Star16;
    public static eShapeStyle Star24;
    public static eShapeStyle Star32;
    public static eShapeStyle Star4;
    public static eShapeStyle Star5;
    public static eShapeStyle Star6;
    public static eShapeStyle Star7;
    public static eShapeStyle Star8;
    public static eShapeStyle StraightConnector1;
    public static eShapeStyle StripedRightArrow;
    public static eShapeStyle Sun;
    public static eShapeStyle SwooshArrow;
    public static eShapeStyle Teardrop;
    public static eShapeStyle Trapezoid;
    public static eShapeStyle Triangle;
    public static eShapeStyle UpArrow;
    public static eShapeStyle UpArrowCallout;
    public static eShapeStyle UpDownArrow;
    public static eShapeStyle UpDownArrowCallout;
    public static eShapeStyle UturnArrow;
    public static eShapeStyle Wave;
    public static eShapeStyle WedgeEllipseCallout;
    public static eShapeStyle WedgeRectCallout;
    public static eShapeStyle WedgeRoundRectCallout;
    public static eShapeStyle VerticalScroll;
}
public enum eTextAlignment : Enum {
    public int value__;
    public static eTextAlignment Left;
    public static eTextAlignment Center;
    public static eTextAlignment Right;
    public static eTextAlignment Distributed;
    public static eTextAlignment Justified;
    public static eTextAlignment JustifiedLow;
    public static eTextAlignment ThaiDistributed;
}
internal class FlagCellStore : CellStore`1<byte> {
    internal void SetFlagValue(int Row, int Col, bool value, CellFlags cellFlags);
    internal bool GetFlagValue(int Row, int Col, CellFlags cellFlags);
}
internal class IndexBase : object {
    internal short Index;
    public sealed virtual int CompareTo(IndexBase other);
}
internal class IndexItem : ValueType {
    [CompilerGeneratedAttribute]
private int <IndexPointer>k__BackingField;
    internal short Index;
    internal int IndexPointer { get; internal set; }
    [CompilerGeneratedAttribute]
internal int get_IndexPointer();
    [CompilerGeneratedAttribute]
internal void set_IndexPointer(int value);
    public sealed virtual int CompareTo(IndexItem other);
}
internal class Ionic.Zip.ZipInputStream : Stream {
    [CompilerGeneratedAttribute]
private int <CodecBufferSize>k__BackingField;
    private Stream _inputStream;
    private Encoding _provisionalAlternateEncoding;
    private ZipEntry _currentEntry;
    private bool _firstEntry;
    private bool _needSetup;
    private ZipContainer _container;
    private CrcCalculatorStream _crcStream;
    private long _LeftToRead;
    internal string _Password;
    private long _endOfEntry;
    private string _name;
    private bool _leaveUnderlyingStreamOpen;
    private bool _closed;
    private bool _findRequired;
    private bool _exceptionPending;
    public Encoding ProvisionalAlternateEncoding { get; public set; }
    public int CodecBufferSize { get; public set; }
    unknown string Password {public set; }
    internal Stream ReadStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZipInputStream(Stream stream);
    public ZipInputStream(string fileName);
    public ZipInputStream(Stream stream, bool leaveOpen);
    private void _Init(Stream stream, bool leaveOpen, string name);
    public virtual string ToString();
    public Encoding get_ProvisionalAlternateEncoding();
    public void set_ProvisionalAlternateEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public int get_CodecBufferSize();
    [CompilerGeneratedAttribute]
public void set_CodecBufferSize(int value);
    public void set_Password(string value);
    private void SetupStream();
    internal Stream get_ReadStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public ZipEntry GetNextEntry();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
[ExtensionAttribute]
public static class OfficeOpenXml.CalculationExtension : object {
    [ExtensionAttribute]
public static void Calculate(ExcelWorkbook workbook);
    [ExtensionAttribute]
public static void Calculate(ExcelWorkbook workbook, ExcelCalculationOption options);
    [ExtensionAttribute]
public static void Calculate(ExcelWorksheet worksheet);
    [ExtensionAttribute]
public static void Calculate(ExcelWorksheet worksheet, ExcelCalculationOption options);
    [ExtensionAttribute]
public static void Calculate(ExcelRangeBase range);
    [ExtensionAttribute]
public static void Calculate(ExcelRangeBase range, ExcelCalculationOption options);
    [ExtensionAttribute]
public static object Calculate(ExcelWorksheet worksheet, string Formula);
    [ExtensionAttribute]
public static object Calculate(ExcelWorksheet worksheet, string Formula, ExcelCalculationOption options);
    private static void CalcChain(ExcelWorkbook wb, FormulaParser parser, DependencyChain dc);
    private static void Init(ExcelWorkbook workbook);
    private static void SetValue(ExcelWorkbook workbook, FormulaCell item, object v);
}
[FlagsAttribute]
internal enum OfficeOpenXml.CellFlags : Enum {
    public int value__;
    public static CellFlags RichText;
    public static CellFlags SharedFormula;
    public static CellFlags ArrayFormula;
}
public enum OfficeOpenXml.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel Level0;
    public static CompressionLevel None;
    public static CompressionLevel Level1;
    public static CompressionLevel BestSpeed;
    public static CompressionLevel Level2;
    public static CompressionLevel Level3;
    public static CompressionLevel Level4;
    public static CompressionLevel Level5;
    public static CompressionLevel Level6;
    public static CompressionLevel Default;
    public static CompressionLevel Level7;
    public static CompressionLevel Level8;
    public static CompressionLevel BestCompression;
    public static CompressionLevel Level9;
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingAverageGroup {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingBeginsWith {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingBetween {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingColorScaleGroup {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingContainsBlanks {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingContainsErrors {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingContainsText {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingDataBarGroup {
    public bool ShowValue { get; public set; }
    public ExcelConditionalFormattingIconDataBarValue LowValue { get; }
    public ExcelConditionalFormattingIconDataBarValue HighValue { get; }
    public Color Color { get; public set; }
    public abstract virtual bool get_ShowValue();
    public abstract virtual void set_ShowValue(bool value);
    public abstract virtual ExcelConditionalFormattingIconDataBarValue get_LowValue();
    public abstract virtual ExcelConditionalFormattingIconDataBarValue get_HighValue();
    public abstract virtual Color get_Color();
    public abstract virtual void set_Color(Color value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingDuplicateValues {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingEndsWith {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingEqual {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingExpression {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingFiveIconSet {
    public ExcelConditionalFormattingIconDataBarValue Icon5 { get; }
    public abstract virtual ExcelConditionalFormattingIconDataBarValue get_Icon5();
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingFourIconSet`1 {
    public ExcelConditionalFormattingIconDataBarValue Icon4 { get; }
    public abstract virtual ExcelConditionalFormattingIconDataBarValue get_Icon4();
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingGreaterThan {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingGreaterThanOrEqual {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingIconSetGroup`1 {
    public bool Reverse { get; public set; }
    public bool ShowValue { get; public set; }
    public T IconSet { get; public set; }
    public abstract virtual bool get_Reverse();
    public abstract virtual void set_Reverse(bool value);
    public abstract virtual bool get_ShowValue();
    public abstract virtual void set_ShowValue(bool value);
    public abstract virtual T get_IconSet();
    public abstract virtual void set_IconSet(T value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingLessThan {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingLessThanOrEqual {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotBetween {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotContainsBlanks {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotContainsErrors {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotContainsText {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingNotEqual {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule {
    public XmlNode Node { get; }
    public eExcelConditionalFormattingRuleType Type { get; }
    public ExcelAddress Address { get; public set; }
    public int Priority { get; public set; }
    public bool StopIfTrue { get; public set; }
    public ExcelDxfStyleConditionalFormatting Style { get; }
    public abstract virtual XmlNode get_Node();
    public abstract virtual eExcelConditionalFormattingRuleType get_Type();
    public abstract virtual ExcelAddress get_Address();
    public abstract virtual void set_Address(ExcelAddress value);
    public abstract virtual int get_Priority();
    public abstract virtual void set_Priority(int value);
    public abstract virtual bool get_StopIfTrue();
    public abstract virtual void set_StopIfTrue(bool value);
    public abstract virtual ExcelDxfStyleConditionalFormatting get_Style();
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingStdDevGroup {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingThreeColorScale {
    public ExcelConditionalFormattingColorScaleValue MiddleValue { get; public set; }
    public abstract virtual ExcelConditionalFormattingColorScaleValue get_MiddleValue();
    public abstract virtual void set_MiddleValue(ExcelConditionalFormattingColorScaleValue value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingThreeIconSet`1 {
    public ExcelConditionalFormattingIconDataBarValue Icon1 { get; }
    public ExcelConditionalFormattingIconDataBarValue Icon2 { get; }
    public ExcelConditionalFormattingIconDataBarValue Icon3 { get; }
    public abstract virtual ExcelConditionalFormattingIconDataBarValue get_Icon1();
    public abstract virtual ExcelConditionalFormattingIconDataBarValue get_Icon2();
    public abstract virtual ExcelConditionalFormattingIconDataBarValue get_Icon3();
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingTimePeriodGroup {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingTopBottomGroup {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingTwoColorScale {
    public ExcelConditionalFormattingColorScaleValue LowValue { get; public set; }
    public ExcelConditionalFormattingColorScaleValue HighValue { get; public set; }
    public abstract virtual ExcelConditionalFormattingColorScaleValue get_LowValue();
    public abstract virtual void set_LowValue(ExcelConditionalFormattingColorScaleValue value);
    public abstract virtual ExcelConditionalFormattingColorScaleValue get_HighValue();
    public abstract virtual void set_HighValue(ExcelConditionalFormattingColorScaleValue value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingUniqueValues {
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithFormula {
    public string Formula { get; public set; }
    public abstract virtual string get_Formula();
    public abstract virtual void set_Formula(string value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithFormula2 {
    public string Formula2 { get; public set; }
    public abstract virtual string get_Formula2();
    public abstract virtual void set_Formula2(string value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithRank {
    public ushort Rank { get; public set; }
    public abstract virtual ushort get_Rank();
    public abstract virtual void set_Rank(ushort value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithReverse {
    public bool Reverse { get; public set; }
    public abstract virtual bool get_Reverse();
    public abstract virtual void set_Reverse(bool value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithShowValue {
    public bool ShowValue { get; public set; }
    public abstract virtual bool get_ShowValue();
    public abstract virtual void set_ShowValue(bool value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithStdDev {
    public ushort StdDev { get; public set; }
    public abstract virtual ushort get_StdDev();
    public abstract virtual void set_StdDev(ushort value);
}
public interface OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingWithText {
    public string Text { get; public set; }
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting3IconsSetType : Enum {
    public int value__;
    public static eExcelconditionalFormatting3IconsSetType Arrows;
    public static eExcelconditionalFormatting3IconsSetType ArrowsGray;
    public static eExcelconditionalFormatting3IconsSetType Flags;
    public static eExcelconditionalFormatting3IconsSetType Signs;
    public static eExcelconditionalFormatting3IconsSetType Symbols;
    public static eExcelconditionalFormatting3IconsSetType Symbols2;
    public static eExcelconditionalFormatting3IconsSetType TrafficLights1;
    public static eExcelconditionalFormatting3IconsSetType TrafficLights2;
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting4IconsSetType : Enum {
    public int value__;
    public static eExcelconditionalFormatting4IconsSetType Arrows;
    public static eExcelconditionalFormatting4IconsSetType ArrowsGray;
    public static eExcelconditionalFormatting4IconsSetType Rating;
    public static eExcelconditionalFormatting4IconsSetType RedToBlack;
    public static eExcelconditionalFormatting4IconsSetType TrafficLights;
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormatting5IconsSetType : Enum {
    public int value__;
    public static eExcelconditionalFormatting5IconsSetType Arrows;
    public static eExcelconditionalFormatting5IconsSetType ArrowsGray;
    public static eExcelconditionalFormatting5IconsSetType Quarters;
    public static eExcelconditionalFormatting5IconsSetType Rating;
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelconditionalFormattingIconsSetType : Enum {
    public int value__;
    public static eExcelconditionalFormattingIconsSetType ThreeArrows;
    public static eExcelconditionalFormattingIconsSetType ThreeArrowsGray;
    public static eExcelconditionalFormattingIconsSetType ThreeFlags;
    public static eExcelconditionalFormattingIconsSetType ThreeSigns;
    public static eExcelconditionalFormattingIconsSetType ThreeSymbols;
    public static eExcelconditionalFormattingIconsSetType ThreeSymbols2;
    public static eExcelconditionalFormattingIconsSetType ThreeTrafficLights1;
    public static eExcelconditionalFormattingIconsSetType ThreeTrafficLights2;
    public static eExcelconditionalFormattingIconsSetType FourArrows;
    public static eExcelconditionalFormattingIconsSetType FourArrowsGray;
    public static eExcelconditionalFormattingIconsSetType FourRating;
    public static eExcelconditionalFormattingIconsSetType FourRedToBlack;
    public static eExcelconditionalFormattingIconsSetType FourTrafficLights;
    public static eExcelconditionalFormattingIconsSetType FiveArrows;
    public static eExcelconditionalFormattingIconsSetType FiveArrowsGray;
    public static eExcelconditionalFormattingIconsSetType FiveQuarters;
    public static eExcelconditionalFormattingIconsSetType FiveRating;
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingOperatorType : Enum {
    public int value__;
    public static eExcelConditionalFormattingOperatorType BeginsWith;
    public static eExcelConditionalFormattingOperatorType Between;
    public static eExcelConditionalFormattingOperatorType ContainsText;
    public static eExcelConditionalFormattingOperatorType EndsWith;
    public static eExcelConditionalFormattingOperatorType Equal;
    public static eExcelConditionalFormattingOperatorType GreaterThan;
    public static eExcelConditionalFormattingOperatorType GreaterThanOrEqual;
    public static eExcelConditionalFormattingOperatorType LessThan;
    public static eExcelConditionalFormattingOperatorType LessThanOrEqual;
    public static eExcelConditionalFormattingOperatorType NotBetween;
    public static eExcelConditionalFormattingOperatorType NotContains;
    public static eExcelConditionalFormattingOperatorType NotEqual;
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingRuleType : Enum {
    public int value__;
    public static eExcelConditionalFormattingRuleType AboveAverage;
    public static eExcelConditionalFormattingRuleType AboveOrEqualAverage;
    public static eExcelConditionalFormattingRuleType BelowAverage;
    public static eExcelConditionalFormattingRuleType BelowOrEqualAverage;
    public static eExcelConditionalFormattingRuleType AboveStdDev;
    public static eExcelConditionalFormattingRuleType BelowStdDev;
    public static eExcelConditionalFormattingRuleType Bottom;
    public static eExcelConditionalFormattingRuleType BottomPercent;
    public static eExcelConditionalFormattingRuleType Top;
    public static eExcelConditionalFormattingRuleType TopPercent;
    public static eExcelConditionalFormattingRuleType Last7Days;
    public static eExcelConditionalFormattingRuleType LastMonth;
    public static eExcelConditionalFormattingRuleType LastWeek;
    public static eExcelConditionalFormattingRuleType NextMonth;
    public static eExcelConditionalFormattingRuleType NextWeek;
    public static eExcelConditionalFormattingRuleType ThisMonth;
    public static eExcelConditionalFormattingRuleType ThisWeek;
    public static eExcelConditionalFormattingRuleType Today;
    public static eExcelConditionalFormattingRuleType Tomorrow;
    public static eExcelConditionalFormattingRuleType Yesterday;
    public static eExcelConditionalFormattingRuleType BeginsWith;
    public static eExcelConditionalFormattingRuleType Between;
    public static eExcelConditionalFormattingRuleType ContainsBlanks;
    public static eExcelConditionalFormattingRuleType ContainsErrors;
    public static eExcelConditionalFormattingRuleType ContainsText;
    public static eExcelConditionalFormattingRuleType DuplicateValues;
    public static eExcelConditionalFormattingRuleType EndsWith;
    public static eExcelConditionalFormattingRuleType Equal;
    public static eExcelConditionalFormattingRuleType Expression;
    public static eExcelConditionalFormattingRuleType GreaterThan;
    public static eExcelConditionalFormattingRuleType GreaterThanOrEqual;
    public static eExcelConditionalFormattingRuleType LessThan;
    public static eExcelConditionalFormattingRuleType LessThanOrEqual;
    public static eExcelConditionalFormattingRuleType NotBetween;
    public static eExcelConditionalFormattingRuleType NotContains;
    public static eExcelConditionalFormattingRuleType NotContainsBlanks;
    public static eExcelConditionalFormattingRuleType NotContainsErrors;
    public static eExcelConditionalFormattingRuleType NotContainsText;
    public static eExcelConditionalFormattingRuleType NotEqual;
    public static eExcelConditionalFormattingRuleType UniqueValues;
    public static eExcelConditionalFormattingRuleType ThreeColorScale;
    public static eExcelConditionalFormattingRuleType TwoColorScale;
    public static eExcelConditionalFormattingRuleType ThreeIconSet;
    public static eExcelConditionalFormattingRuleType FourIconSet;
    public static eExcelConditionalFormattingRuleType FiveIconSet;
    public static eExcelConditionalFormattingRuleType DataBar;
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingTimePeriodType : Enum {
    public int value__;
    public static eExcelConditionalFormattingTimePeriodType Last7Days;
    public static eExcelConditionalFormattingTimePeriodType LastMonth;
    public static eExcelConditionalFormattingTimePeriodType LastWeek;
    public static eExcelConditionalFormattingTimePeriodType NextMonth;
    public static eExcelConditionalFormattingTimePeriodType NextWeek;
    public static eExcelConditionalFormattingTimePeriodType ThisMonth;
    public static eExcelConditionalFormattingTimePeriodType ThisWeek;
    public static eExcelConditionalFormattingTimePeriodType Today;
    public static eExcelConditionalFormattingTimePeriodType Tomorrow;
    public static eExcelConditionalFormattingTimePeriodType Yesterday;
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectNodeType : Enum {
    public int value__;
    public static eExcelConditionalFormattingValueObjectNodeType Cfvo;
    public static eExcelConditionalFormattingValueObjectNodeType Color;
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectPosition : Enum {
    public int value__;
    public static eExcelConditionalFormattingValueObjectPosition Low;
    public static eExcelConditionalFormattingValueObjectPosition Middle;
    public static eExcelConditionalFormattingValueObjectPosition High;
}
public enum OfficeOpenXml.ConditionalFormatting.eExcelConditionalFormattingValueObjectType : Enum {
    public int value__;
    public static eExcelConditionalFormattingValueObjectType Formula;
    public static eExcelConditionalFormattingValueObjectType Max;
    public static eExcelConditionalFormattingValueObjectType Min;
    public static eExcelConditionalFormattingValueObjectType Num;
    public static eExcelConditionalFormattingValueObjectType Percent;
    public static eExcelConditionalFormattingValueObjectType Percentile;
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveAverage : ExcelConditionalFormattingAverageGroup {
    internal ExcelConditionalFormattingAboveAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingAboveAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingAboveAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveOrEqualAverage : ExcelConditionalFormattingAverageGroup {
    internal ExcelConditionalFormattingAboveOrEqualAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingAboveOrEqualAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingAboveOrEqualAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAboveStdDev : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingAboveStdDev(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingAboveStdDev(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingAboveStdDev(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingAverageGroup : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingAverageGroup(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingAverageGroup(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingAverageGroup(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBeginsWith : ExcelConditionalFormattingRule {
    public string Text { get; public set; }
    internal ExcelConditionalFormattingBeginsWith(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingBeginsWith(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingBeginsWith(ExcelAddress address, int priority, ExcelWorksheet worksheet);
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowAverage : ExcelConditionalFormattingAverageGroup {
    internal ExcelConditionalFormattingBelowAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingBelowAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingBelowAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowOrEqualAverage : ExcelConditionalFormattingAverageGroup {
    internal ExcelConditionalFormattingBelowOrEqualAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingBelowOrEqualAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingBelowOrEqualAverage(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBelowStdDev : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingBelowStdDev(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingBelowStdDev(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingBelowStdDev(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBetween : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingBetween(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingBetween(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingBetween(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottom : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingBottom(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingBottom(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingBottom(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingBottomPercent : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingBottomPercent(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingBottomPercent(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingBottomPercent(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingCollection : XmlHelper {
    private List`1<IExcelConditionalFormattingRule> _rules;
    private ExcelWorksheet _worksheet;
    public int Count { get; }
    public IExcelConditionalFormattingRule Item { get; public set; }
    internal ExcelConditionalFormattingCollection(ExcelWorksheet worksheet);
    private void EnsureRootElementExists();
    private XmlNode GetRootNode();
    private ExcelAddress ValidateAddress(ExcelAddress address);
    private int GetNextPriority();
    public int get_Count();
    public IExcelConditionalFormattingRule get_Item(int index);
    public void set_Item(int index, IExcelConditionalFormattingRule value);
    private sealed virtual override IEnumerator`1<IExcelConditionalFormattingRule> System.Collections.Generic.IEnumerable<OfficeOpenXml.ConditionalFormatting.Contracts.IExcelConditionalFormattingRule>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void RemoveAll();
    public void Remove(IExcelConditionalFormattingRule item);
    public void RemoveAt(int index);
    public void RemoveByPriority(int priority);
    public IExcelConditionalFormattingRule RulesByPriority(int priority);
    internal IExcelConditionalFormattingRule AddRule(eExcelConditionalFormattingRuleType type, ExcelAddress address);
    public IExcelConditionalFormattingAverageGroup AddAboveAverage(ExcelAddress address);
    public IExcelConditionalFormattingAverageGroup AddAboveOrEqualAverage(ExcelAddress address);
    public IExcelConditionalFormattingAverageGroup AddBelowAverage(ExcelAddress address);
    public IExcelConditionalFormattingAverageGroup AddBelowOrEqualAverage(ExcelAddress address);
    public IExcelConditionalFormattingStdDevGroup AddAboveStdDev(ExcelAddress address);
    public IExcelConditionalFormattingStdDevGroup AddBelowStdDev(ExcelAddress address);
    public IExcelConditionalFormattingTopBottomGroup AddBottom(ExcelAddress address);
    public IExcelConditionalFormattingTopBottomGroup AddBottomPercent(ExcelAddress address);
    public IExcelConditionalFormattingTopBottomGroup AddTop(ExcelAddress address);
    public IExcelConditionalFormattingTopBottomGroup AddTopPercent(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddLast7Days(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddLastMonth(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddLastWeek(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddNextMonth(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddNextWeek(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddThisMonth(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddThisWeek(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddToday(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddTomorrow(ExcelAddress address);
    public IExcelConditionalFormattingTimePeriodGroup AddYesterday(ExcelAddress address);
    public IExcelConditionalFormattingBeginsWith AddBeginsWith(ExcelAddress address);
    public IExcelConditionalFormattingBetween AddBetween(ExcelAddress address);
    public IExcelConditionalFormattingContainsBlanks AddContainsBlanks(ExcelAddress address);
    public IExcelConditionalFormattingContainsErrors AddContainsErrors(ExcelAddress address);
    public IExcelConditionalFormattingContainsText AddContainsText(ExcelAddress address);
    public IExcelConditionalFormattingDuplicateValues AddDuplicateValues(ExcelAddress address);
    public IExcelConditionalFormattingEndsWith AddEndsWith(ExcelAddress address);
    public IExcelConditionalFormattingEqual AddEqual(ExcelAddress address);
    public IExcelConditionalFormattingExpression AddExpression(ExcelAddress address);
    public IExcelConditionalFormattingGreaterThan AddGreaterThan(ExcelAddress address);
    public IExcelConditionalFormattingGreaterThanOrEqual AddGreaterThanOrEqual(ExcelAddress address);
    public IExcelConditionalFormattingLessThan AddLessThan(ExcelAddress address);
    public IExcelConditionalFormattingLessThanOrEqual AddLessThanOrEqual(ExcelAddress address);
    public IExcelConditionalFormattingNotBetween AddNotBetween(ExcelAddress address);
    public IExcelConditionalFormattingNotContainsBlanks AddNotContainsBlanks(ExcelAddress address);
    public IExcelConditionalFormattingNotContainsErrors AddNotContainsErrors(ExcelAddress address);
    public IExcelConditionalFormattingNotContainsText AddNotContainsText(ExcelAddress address);
    public IExcelConditionalFormattingNotEqual AddNotEqual(ExcelAddress address);
    public IExcelConditionalFormattingUniqueValues AddUniqueValues(ExcelAddress address);
    public IExcelConditionalFormattingThreeColorScale AddThreeColorScale(ExcelAddress address);
    public IExcelConditionalFormattingTwoColorScale AddTwoColorScale(ExcelAddress address);
    public IExcelConditionalFormattingThreeIconSet`1<eExcelconditionalFormatting3IconsSetType> AddThreeIconSet(ExcelAddress Address, eExcelconditionalFormatting3IconsSetType IconSet);
    public IExcelConditionalFormattingFourIconSet`1<eExcelconditionalFormatting4IconsSetType> AddFourIconSet(ExcelAddress Address, eExcelconditionalFormatting4IconsSetType IconSet);
    public IExcelConditionalFormattingFiveIconSet AddFiveIconSet(ExcelAddress Address, eExcelconditionalFormatting5IconsSetType IconSet);
    public IExcelConditionalFormattingDataBarGroup AddDatabar(ExcelAddress Address, Color color);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingColorScaleValue : XmlHelper {
    private eExcelConditionalFormattingValueObjectPosition _position;
    private eExcelConditionalFormattingRuleType _ruleType;
    private ExcelWorksheet _worksheet;
    internal eExcelConditionalFormattingValueObjectPosition Position { get; internal set; }
    internal eExcelConditionalFormattingRuleType RuleType { get; internal set; }
    public eExcelConditionalFormattingValueObjectType Type { get; public set; }
    public Color Color { get; public set; }
    public double Value { get; public set; }
    public string Formula { get; public set; }
    internal ExcelConditionalFormattingColorScaleValue(eExcelConditionalFormattingValueObjectPosition position, eExcelConditionalFormattingValueObjectType type, Color color, double value, string formula, eExcelConditionalFormattingRuleType ruleType, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingColorScaleValue(eExcelConditionalFormattingValueObjectPosition position, eExcelConditionalFormattingValueObjectType type, Color color, double value, string formula, eExcelConditionalFormattingRuleType ruleType, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingColorScaleValue(eExcelConditionalFormattingValueObjectPosition position, eExcelConditionalFormattingValueObjectType type, Color color, eExcelConditionalFormattingRuleType ruleType, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNamespaceManager namespaceManager);
    private int GetNodeOrder();
    private void CreateNodeByOrdem(eExcelConditionalFormattingValueObjectNodeType nodeType, string attributePath, string attributeValue);
    internal eExcelConditionalFormattingValueObjectPosition get_Position();
    internal void set_Position(eExcelConditionalFormattingValueObjectPosition value);
    internal eExcelConditionalFormattingRuleType get_RuleType();
    internal void set_RuleType(eExcelConditionalFormattingRuleType value);
    public eExcelConditionalFormattingValueObjectType get_Type();
    public void set_Type(eExcelConditionalFormattingValueObjectType value);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Value();
    public void set_Value(double value);
    public string get_Formula();
    public void set_Formula(string value);
}
internal static class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingConstants : object {
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsBlanks : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingContainsBlanks(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingContainsBlanks(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingContainsBlanks(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsErrors : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingContainsErrors(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingContainsErrors(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingContainsErrors(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingContainsText : ExcelConditionalFormattingRule {
    public string Text { get; public set; }
    internal ExcelConditionalFormattingContainsText(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingContainsText(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingContainsText(ExcelAddress address, int priority, ExcelWorksheet worksheet);
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDataBar : ExcelConditionalFormattingRule {
    private static string _showValuePath;
    [CompilerGeneratedAttribute]
private ExcelConditionalFormattingIconDataBarValue <LowValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelConditionalFormattingIconDataBarValue <HighValue>k__BackingField;
    private static string _colorPath;
    public bool ShowValue { get; public set; }
    public ExcelConditionalFormattingIconDataBarValue LowValue { get; internal set; }
    public ExcelConditionalFormattingIconDataBarValue HighValue { get; internal set; }
    public Color Color { get; public set; }
    internal ExcelConditionalFormattingDataBar(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingDataBar(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingDataBar(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet);
    public sealed virtual bool get_ShowValue();
    public sealed virtual void set_ShowValue(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ExcelConditionalFormattingIconDataBarValue get_LowValue();
    [CompilerGeneratedAttribute]
internal void set_LowValue(ExcelConditionalFormattingIconDataBarValue value);
    [CompilerGeneratedAttribute]
public sealed virtual ExcelConditionalFormattingIconDataBarValue get_HighValue();
    [CompilerGeneratedAttribute]
internal void set_HighValue(ExcelConditionalFormattingIconDataBarValue value);
    public sealed virtual Color get_Color();
    public sealed virtual void set_Color(Color value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingDuplicateValues : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingDuplicateValues(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingDuplicateValues(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingDuplicateValues(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEndsWith : ExcelConditionalFormattingRule {
    public string Text { get; public set; }
    internal ExcelConditionalFormattingEndsWith(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingEndsWith(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingEndsWith(ExcelAddress address, int priority, ExcelWorksheet worksheet);
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingEqual : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingExpression : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingExpression(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingExpression(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingExpression(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFiveIconSet : ExcelConditionalFormattingIconSetBase`1<eExcelconditionalFormatting5IconsSetType> {
    [CompilerGeneratedAttribute]
private ExcelConditionalFormattingIconDataBarValue <Icon5>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelConditionalFormattingIconDataBarValue <Icon4>k__BackingField;
    public ExcelConditionalFormattingIconDataBarValue Icon5 { get; internal set; }
    public ExcelConditionalFormattingIconDataBarValue Icon4 { get; internal set; }
    internal ExcelConditionalFormattingFiveIconSet(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingFiveIconSet(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingFiveIconSet(ExcelAddress address, int priority, ExcelWorksheet worksheet);
    [CompilerGeneratedAttribute]
public sealed virtual ExcelConditionalFormattingIconDataBarValue get_Icon5();
    [CompilerGeneratedAttribute]
internal void set_Icon5(ExcelConditionalFormattingIconDataBarValue value);
    [CompilerGeneratedAttribute]
public sealed virtual ExcelConditionalFormattingIconDataBarValue get_Icon4();
    [CompilerGeneratedAttribute]
internal void set_Icon4(ExcelConditionalFormattingIconDataBarValue value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingFourIconSet : ExcelConditionalFormattingIconSetBase`1<eExcelconditionalFormatting4IconsSetType> {
    [CompilerGeneratedAttribute]
private ExcelConditionalFormattingIconDataBarValue <Icon4>k__BackingField;
    public ExcelConditionalFormattingIconDataBarValue Icon4 { get; internal set; }
    internal ExcelConditionalFormattingFourIconSet(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingFourIconSet(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingFourIconSet(ExcelAddress address, int priority, ExcelWorksheet worksheet);
    [CompilerGeneratedAttribute]
public sealed virtual ExcelConditionalFormattingIconDataBarValue get_Icon4();
    [CompilerGeneratedAttribute]
internal void set_Icon4(ExcelConditionalFormattingIconDataBarValue value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThan : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingGreaterThan(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingGreaterThan(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingGreaterThan(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingGreaterThanOrEqual : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingGreaterThanOrEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingGreaterThanOrEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingGreaterThanOrEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
[ExtensionAttribute]
internal static class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingHelper : object {
    public static string CheckAndFixRangeAddress(string address);
    public static Color ConvertFromColorCode(string colorCode);
    public static string GetAttributeString(XmlNode node, string attribute);
    public static int GetAttributeInt(XmlNode node, string attribute);
    public static Nullable`1<int> GetAttributeIntNullable(XmlNode node, string attribute);
    public static bool GetAttributeBool(XmlNode node, string attribute);
    public static Nullable`1<bool> GetAttributeBoolNullable(XmlNode node, string attribute);
    public static double GetAttributeDouble(XmlNode node, string attribute);
    public static decimal GetAttributeDecimal(XmlNode node, string attribute);
    [ExtensionAttribute]
public static string EncodeXML(string s);
    [ExtensionAttribute]
public static string DecodeXML(string s);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconDataBarValue : XmlHelper {
    private eExcelConditionalFormattingRuleType _ruleType;
    private ExcelWorksheet _worksheet;
    internal eExcelConditionalFormattingRuleType RuleType { get; internal set; }
    public eExcelConditionalFormattingValueObjectType Type { get; public set; }
    public double Value { get; public set; }
    public string Formula { get; public set; }
    internal ExcelConditionalFormattingIconDataBarValue(eExcelConditionalFormattingValueObjectType type, double value, string formula, eExcelConditionalFormattingRuleType ruleType, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingIconDataBarValue(eExcelConditionalFormattingRuleType ruleType, ExcelAddress address, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingIconDataBarValue(eExcelConditionalFormattingValueObjectType type, double value, string formula, eExcelConditionalFormattingRuleType ruleType, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingIconDataBarValue(eExcelConditionalFormattingValueObjectType type, Color color, eExcelConditionalFormattingRuleType ruleType, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNamespaceManager namespaceManager);
    internal eExcelConditionalFormattingRuleType get_RuleType();
    internal void set_RuleType(eExcelConditionalFormattingRuleType value);
    public eExcelConditionalFormattingValueObjectType get_Type();
    public void set_Type(eExcelConditionalFormattingValueObjectType value);
    public double get_Value();
    public void set_Value(double value);
    public string get_Formula();
    public void set_Formula(string value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingIconSetBase`1 : ExcelConditionalFormattingRule {
    [CompilerGeneratedAttribute]
private ExcelConditionalFormattingIconDataBarValue <Icon1>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelConditionalFormattingIconDataBarValue <Icon2>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelConditionalFormattingIconDataBarValue <Icon3>k__BackingField;
    private static string _reversePath;
    private static string _showValuePath;
    private static string _iconSetPath;
    public ExcelConditionalFormattingIconDataBarValue Icon1 { get; internal set; }
    public ExcelConditionalFormattingIconDataBarValue Icon2 { get; internal set; }
    public ExcelConditionalFormattingIconDataBarValue Icon3 { get; internal set; }
    public bool Reverse { get; public set; }
    public bool ShowValue { get; public set; }
    public T IconSet { get; public set; }
    internal ExcelConditionalFormattingIconSetBase`1(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingIconSetBase`1(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingIconSetBase`1(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet);
    [CompilerGeneratedAttribute]
public sealed virtual ExcelConditionalFormattingIconDataBarValue get_Icon1();
    [CompilerGeneratedAttribute]
internal void set_Icon1(ExcelConditionalFormattingIconDataBarValue value);
    [CompilerGeneratedAttribute]
public sealed virtual ExcelConditionalFormattingIconDataBarValue get_Icon2();
    [CompilerGeneratedAttribute]
internal void set_Icon2(ExcelConditionalFormattingIconDataBarValue value);
    [CompilerGeneratedAttribute]
public sealed virtual ExcelConditionalFormattingIconDataBarValue get_Icon3();
    [CompilerGeneratedAttribute]
internal void set_Icon3(ExcelConditionalFormattingIconDataBarValue value);
    public sealed virtual bool get_Reverse();
    public sealed virtual void set_Reverse(bool value);
    public sealed virtual bool get_ShowValue();
    public sealed virtual void set_ShowValue(bool value);
    public sealed virtual T get_IconSet();
    public sealed virtual void set_IconSet(T value);
    private string GetIconSetString(T value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLast7Days : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingLast7Days(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingLast7Days(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingLast7Days(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastMonth : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingLastMonth(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingLastMonth(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingLastMonth(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLastWeek : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingLastWeek(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingLastWeek(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingLastWeek(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThan : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingLessThan(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingLessThan(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingLessThan(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingLessThanOrEqual : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingLessThanOrEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingLessThanOrEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingLessThanOrEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextMonth : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingNextMonth(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingNextMonth(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingNextMonth(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNextWeek : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingNextWeek(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingNextWeek(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingNextWeek(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotBetween : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingNotBetween(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingNotBetween(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingNotBetween(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsBlanks : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingNotContainsBlanks(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingNotContainsBlanks(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingNotContainsBlanks(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsErrors : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingNotContainsErrors(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingNotContainsErrors(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingNotContainsErrors(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotContainsText : ExcelConditionalFormattingRule {
    public string Text { get; public set; }
    internal ExcelConditionalFormattingNotContainsText(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingNotContainsText(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingNotContainsText(ExcelAddress address, int priority, ExcelWorksheet worksheet);
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingNotEqual : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingNotEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingNotEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingNotEqual(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
internal static class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingOperatorType : object {
    internal static string GetAttributeByType(eExcelConditionalFormattingOperatorType type);
    internal static eExcelConditionalFormattingOperatorType GetTypeByAttribute(string attribute);
}
public abstract class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRule : XmlHelper {
    private Nullable`1<eExcelConditionalFormattingRuleType> _type;
    private ExcelWorksheet _worksheet;
    private static bool _changingPriority;
    internal ExcelDxfStyleConditionalFormatting _style;
    public XmlNode Node { get; }
    public ExcelAddress Address { get; public set; }
    public eExcelConditionalFormattingRuleType Type { get; internal set; }
    public int Priority { get; public set; }
    public bool StopIfTrue { get; public set; }
    internal int DxfId { get; internal set; }
    public ExcelDxfStyleConditionalFormatting Style { get; }
    public ushort StdDev { get; public set; }
    public ushort Rank { get; public set; }
    protected internal Nullable`1<bool> AboveAverage { get; protected internal set; }
    protected internal Nullable`1<bool> EqualAverage { get; protected internal set; }
    protected internal Nullable`1<bool> Bottom { get; protected internal set; }
    protected internal Nullable`1<bool> Percent { get; protected internal set; }
    protected internal eExcelConditionalFormattingTimePeriodType TimePeriod { get; protected internal set; }
    protected internal eExcelConditionalFormattingOperatorType Operator { get; protected internal set; }
    public string Formula { get; public set; }
    public string Formula2 { get; public set; }
    internal ExcelConditionalFormattingRule(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingRule(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNamespaceManager namespaceManager);
    private static ExcelConditionalFormattingRule();
    public sealed virtual XmlNode get_Node();
    public sealed virtual ExcelAddress get_Address();
    public sealed virtual void set_Address(ExcelAddress value);
    public sealed virtual eExcelConditionalFormattingRuleType get_Type();
    internal void set_Type(eExcelConditionalFormattingRuleType value);
    public sealed virtual int get_Priority();
    public sealed virtual void set_Priority(int value);
    public sealed virtual bool get_StopIfTrue();
    public sealed virtual void set_StopIfTrue(bool value);
    internal int get_DxfId();
    internal void set_DxfId(int value);
    public sealed virtual ExcelDxfStyleConditionalFormatting get_Style();
    public sealed virtual ushort get_StdDev();
    public sealed virtual void set_StdDev(ushort value);
    public sealed virtual ushort get_Rank();
    public sealed virtual void set_Rank(ushort value);
    protected internal Nullable`1<bool> get_AboveAverage();
    protected internal void set_AboveAverage(Nullable`1<bool> value);
    protected internal Nullable`1<bool> get_EqualAverage();
    protected internal void set_EqualAverage(Nullable`1<bool> value);
    protected internal Nullable`1<bool> get_Bottom();
    protected internal void set_Bottom(Nullable`1<bool> value);
    protected internal Nullable`1<bool> get_Percent();
    protected internal void set_Percent(Nullable`1<bool> value);
    protected internal eExcelConditionalFormattingTimePeriodType get_TimePeriod();
    protected internal void set_TimePeriod(eExcelConditionalFormattingTimePeriodType value);
    protected internal eExcelConditionalFormattingOperatorType get_Operator();
    protected internal void set_Operator(eExcelConditionalFormattingOperatorType value);
    public sealed virtual string get_Formula();
    public sealed virtual void set_Formula(string value);
    public sealed virtual string get_Formula2();
    public sealed virtual void set_Formula2(string value);
}
internal static class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleFactory : object {
    public static ExcelConditionalFormattingRule Create(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
}
internal static class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingRuleType : object {
    internal static eExcelConditionalFormattingRuleType GetTypeByAttrbiute(string attribute, XmlNode topNode, XmlNamespaceManager nameSpaceManager);
    private static eExcelConditionalFormattingRuleType GetCellIs(XmlElement node);
    private static eExcelConditionalFormattingRuleType GetIconSetType(XmlNode topNode, XmlNamespaceManager nameSpaceManager);
    internal static eExcelConditionalFormattingRuleType GetColorScaleType(XmlNode topNode, XmlNamespaceManager nameSpaceManager);
    internal static eExcelConditionalFormattingRuleType GetAboveAverageType(XmlNode topNode, XmlNamespaceManager nameSpaceManager);
    public static eExcelConditionalFormattingRuleType GetTop10Type(XmlNode topNode, XmlNamespaceManager nameSpaceManager);
    public static eExcelConditionalFormattingRuleType GetTimePeriodType(XmlNode topNode, XmlNamespaceManager nameSpaceManager);
    public static string GetAttributeByType(eExcelConditionalFormattingRuleType type);
    public static string GetCfvoParentPathByType(eExcelConditionalFormattingRuleType type);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisMonth : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingThisMonth(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingThisMonth(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingThisMonth(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThisWeek : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingThisWeek(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingThisWeek(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingThisWeek(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeColorScale : ExcelConditionalFormattingRule {
    private ExcelConditionalFormattingColorScaleValue _lowValue;
    private ExcelConditionalFormattingColorScaleValue _middleValue;
    private ExcelConditionalFormattingColorScaleValue _highValue;
    public ExcelConditionalFormattingColorScaleValue LowValue { get; public set; }
    public ExcelConditionalFormattingColorScaleValue MiddleValue { get; public set; }
    public ExcelConditionalFormattingColorScaleValue HighValue { get; public set; }
    internal ExcelConditionalFormattingThreeColorScale(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingThreeColorScale(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingThreeColorScale(ExcelAddress address, int priority, ExcelWorksheet worksheet);
    public sealed virtual ExcelConditionalFormattingColorScaleValue get_LowValue();
    public sealed virtual void set_LowValue(ExcelConditionalFormattingColorScaleValue value);
    public sealed virtual ExcelConditionalFormattingColorScaleValue get_MiddleValue();
    public sealed virtual void set_MiddleValue(ExcelConditionalFormattingColorScaleValue value);
    public sealed virtual ExcelConditionalFormattingColorScaleValue get_HighValue();
    public sealed virtual void set_HighValue(ExcelConditionalFormattingColorScaleValue value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingThreeIconSet : ExcelConditionalFormattingIconSetBase`1<eExcelconditionalFormatting3IconsSetType> {
    internal ExcelConditionalFormattingThreeIconSet(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodGroup : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingTimePeriodGroup(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingTimePeriodGroup(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingTimePeriodGroup(eExcelConditionalFormattingRuleType type, ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
internal static class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTimePeriodType : object {
    public static string GetAttributeByType(eExcelConditionalFormattingTimePeriodType type);
    public static eExcelConditionalFormattingTimePeriodType GetTypeByAttribute(string attribute);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingToday : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingToday(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingToday(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingToday(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTomorrow : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingTomorrow(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingTomorrow(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingTomorrow(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTop : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingTop(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingTop(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingTop(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTopPercent : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingTopPercent(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingTopPercent(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingTopPercent(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingTwoColorScale : ExcelConditionalFormattingRule {
    private ExcelConditionalFormattingColorScaleValue _lowValue;
    private ExcelConditionalFormattingColorScaleValue _highValue;
    public ExcelConditionalFormattingColorScaleValue LowValue { get; public set; }
    public ExcelConditionalFormattingColorScaleValue HighValue { get; public set; }
    internal ExcelConditionalFormattingTwoColorScale(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingTwoColorScale(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingTwoColorScale(ExcelAddress address, int priority, ExcelWorksheet worksheet);
    public sealed virtual ExcelConditionalFormattingColorScaleValue get_LowValue();
    public sealed virtual void set_LowValue(ExcelConditionalFormattingColorScaleValue value);
    public sealed virtual ExcelConditionalFormattingColorScaleValue get_HighValue();
    public sealed virtual void set_HighValue(ExcelConditionalFormattingColorScaleValue value);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingUniqueValues : ExcelConditionalFormattingRule {
    internal ExcelConditionalFormattingUniqueValues(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingUniqueValues(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingUniqueValues(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
internal static class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingValueObjectType : object {
    internal static int GetOrderByPosition(eExcelConditionalFormattingValueObjectPosition position, eExcelConditionalFormattingRuleType ruleType);
    public static eExcelConditionalFormattingValueObjectType GetTypeByAttrbiute(string attribute);
    public static XmlNode GetCfvoNodeByPosition(eExcelConditionalFormattingValueObjectPosition position, eExcelConditionalFormattingRuleType ruleType, XmlNode topNode, XmlNamespaceManager nameSpaceManager);
    public static string GetAttributeByType(eExcelConditionalFormattingValueObjectType type);
    public static string GetParentPathByRuleType(eExcelConditionalFormattingRuleType ruleType);
    public static string GetNodePathByNodeType(eExcelConditionalFormattingValueObjectNodeType nodeType);
}
public class OfficeOpenXml.ConditionalFormatting.ExcelConditionalFormattingYesterday : ExcelConditionalFormattingTimePeriodGroup {
    internal ExcelConditionalFormattingYesterday(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    internal ExcelConditionalFormattingYesterday(ExcelAddress address, int priority, ExcelWorksheet worksheet, XmlNode itemElementNode);
    internal ExcelConditionalFormattingYesterday(ExcelAddress address, int priority, ExcelWorksheet worksheet);
}
public interface OfficeOpenXml.ConditionalFormatting.IRangeConditionalFormatting {
    public abstract virtual IExcelConditionalFormattingAverageGroup AddAboveAverage();
    public abstract virtual IExcelConditionalFormattingAverageGroup AddAboveOrEqualAverage();
    public abstract virtual IExcelConditionalFormattingAverageGroup AddBelowAverage();
    public abstract virtual IExcelConditionalFormattingAverageGroup AddBelowOrEqualAverage();
    public abstract virtual IExcelConditionalFormattingStdDevGroup AddAboveStdDev();
    public abstract virtual IExcelConditionalFormattingStdDevGroup AddBelowStdDev();
    public abstract virtual IExcelConditionalFormattingTopBottomGroup AddBottom();
    public abstract virtual IExcelConditionalFormattingTopBottomGroup AddBottomPercent();
    public abstract virtual IExcelConditionalFormattingTopBottomGroup AddTop();
    public abstract virtual IExcelConditionalFormattingTopBottomGroup AddTopPercent();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddLast7Days();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddLastMonth();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddLastWeek();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddNextMonth();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddNextWeek();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddThisMonth();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddThisWeek();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddToday();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddTomorrow();
    public abstract virtual IExcelConditionalFormattingTimePeriodGroup AddYesterday();
    public abstract virtual IExcelConditionalFormattingBeginsWith AddBeginsWith();
    public abstract virtual IExcelConditionalFormattingBetween AddBetween();
    public abstract virtual IExcelConditionalFormattingContainsBlanks AddContainsBlanks();
    public abstract virtual IExcelConditionalFormattingContainsErrors AddContainsErrors();
    public abstract virtual IExcelConditionalFormattingContainsText AddContainsText();
    public abstract virtual IExcelConditionalFormattingDuplicateValues AddDuplicateValues();
    public abstract virtual IExcelConditionalFormattingEndsWith AddEndsWith();
    public abstract virtual IExcelConditionalFormattingEqual AddEqual();
    public abstract virtual IExcelConditionalFormattingExpression AddExpression();
    public abstract virtual IExcelConditionalFormattingGreaterThan AddGreaterThan();
    public abstract virtual IExcelConditionalFormattingGreaterThanOrEqual AddGreaterThanOrEqual();
    public abstract virtual IExcelConditionalFormattingLessThan AddLessThan();
    public abstract virtual IExcelConditionalFormattingLessThanOrEqual AddLessThanOrEqual();
    public abstract virtual IExcelConditionalFormattingNotBetween AddNotBetween();
    public abstract virtual IExcelConditionalFormattingNotContainsBlanks AddNotContainsBlanks();
    public abstract virtual IExcelConditionalFormattingNotContainsErrors AddNotContainsErrors();
    public abstract virtual IExcelConditionalFormattingNotContainsText AddNotContainsText();
    public abstract virtual IExcelConditionalFormattingNotEqual AddNotEqual();
    public abstract virtual IExcelConditionalFormattingUniqueValues AddUniqueValues();
    public abstract virtual IExcelConditionalFormattingThreeColorScale AddThreeColorScale();
    public abstract virtual IExcelConditionalFormattingTwoColorScale AddTwoColorScale();
    public abstract virtual IExcelConditionalFormattingThreeIconSet`1<eExcelconditionalFormatting3IconsSetType> AddThreeIconSet(eExcelconditionalFormatting3IconsSetType IconSet);
    public abstract virtual IExcelConditionalFormattingFourIconSet`1<eExcelconditionalFormatting4IconsSetType> AddFourIconSet(eExcelconditionalFormatting4IconsSetType IconSet);
    public abstract virtual IExcelConditionalFormattingFiveIconSet AddFiveIconSet(eExcelconditionalFormatting5IconsSetType IconSet);
    public abstract virtual IExcelConditionalFormattingDataBarGroup AddDatabar(Color color);
}
internal class OfficeOpenXml.ConditionalFormatting.RangeConditionalFormatting : object {
    public ExcelWorksheet _worksheet;
    public ExcelAddress _address;
    public RangeConditionalFormatting(ExcelWorksheet worksheet, ExcelAddress address);
    public sealed virtual IExcelConditionalFormattingAverageGroup AddAboveAverage();
    public sealed virtual IExcelConditionalFormattingAverageGroup AddAboveOrEqualAverage();
    public sealed virtual IExcelConditionalFormattingAverageGroup AddBelowAverage();
    public sealed virtual IExcelConditionalFormattingAverageGroup AddBelowOrEqualAverage();
    public sealed virtual IExcelConditionalFormattingStdDevGroup AddAboveStdDev();
    public sealed virtual IExcelConditionalFormattingStdDevGroup AddBelowStdDev();
    public sealed virtual IExcelConditionalFormattingTopBottomGroup AddBottom();
    public sealed virtual IExcelConditionalFormattingTopBottomGroup AddBottomPercent();
    public sealed virtual IExcelConditionalFormattingTopBottomGroup AddTop();
    public sealed virtual IExcelConditionalFormattingTopBottomGroup AddTopPercent();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddLast7Days();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddLastMonth();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddLastWeek();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddNextMonth();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddNextWeek();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddThisMonth();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddThisWeek();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddToday();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddTomorrow();
    public sealed virtual IExcelConditionalFormattingTimePeriodGroup AddYesterday();
    public sealed virtual IExcelConditionalFormattingBeginsWith AddBeginsWith();
    public sealed virtual IExcelConditionalFormattingBetween AddBetween();
    public sealed virtual IExcelConditionalFormattingContainsBlanks AddContainsBlanks();
    public sealed virtual IExcelConditionalFormattingContainsErrors AddContainsErrors();
    public sealed virtual IExcelConditionalFormattingContainsText AddContainsText();
    public sealed virtual IExcelConditionalFormattingDuplicateValues AddDuplicateValues();
    public sealed virtual IExcelConditionalFormattingEndsWith AddEndsWith();
    public sealed virtual IExcelConditionalFormattingEqual AddEqual();
    public sealed virtual IExcelConditionalFormattingExpression AddExpression();
    public sealed virtual IExcelConditionalFormattingGreaterThan AddGreaterThan();
    public sealed virtual IExcelConditionalFormattingGreaterThanOrEqual AddGreaterThanOrEqual();
    public sealed virtual IExcelConditionalFormattingLessThan AddLessThan();
    public sealed virtual IExcelConditionalFormattingLessThanOrEqual AddLessThanOrEqual();
    public sealed virtual IExcelConditionalFormattingNotBetween AddNotBetween();
    public sealed virtual IExcelConditionalFormattingNotContainsBlanks AddNotContainsBlanks();
    public sealed virtual IExcelConditionalFormattingNotContainsErrors AddNotContainsErrors();
    public sealed virtual IExcelConditionalFormattingNotContainsText AddNotContainsText();
    public sealed virtual IExcelConditionalFormattingNotEqual AddNotEqual();
    public sealed virtual IExcelConditionalFormattingUniqueValues AddUniqueValues();
    public sealed virtual IExcelConditionalFormattingThreeColorScale AddThreeColorScale();
    public sealed virtual IExcelConditionalFormattingTwoColorScale AddTwoColorScale();
    public sealed virtual IExcelConditionalFormattingThreeIconSet`1<eExcelconditionalFormatting3IconsSetType> AddThreeIconSet(eExcelconditionalFormatting3IconsSetType IconSet);
    public sealed virtual IExcelConditionalFormattingFourIconSet`1<eExcelconditionalFormatting4IconsSetType> AddFourIconSet(eExcelconditionalFormatting4IconsSetType IconSet);
    public sealed virtual IExcelConditionalFormattingFiveIconSet AddFiveIconSet(eExcelconditionalFormatting5IconsSetType IconSet);
    public sealed virtual IExcelConditionalFormattingDataBarGroup AddDatabar(Color Color);
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation {
    public ExcelAddress Address { get; }
    public ExcelDataValidationType ValidationType { get; }
    public ExcelDataValidationWarningStyle ErrorStyle { get; public set; }
    public Nullable`1<bool> AllowBlank { get; public set; }
    public Nullable`1<bool> ShowInputMessage { get; public set; }
    public Nullable`1<bool> ShowErrorMessage { get; public set; }
    public string ErrorTitle { get; public set; }
    public string Error { get; public set; }
    public string PromptTitle { get; public set; }
    public string Prompt { get; public set; }
    public bool AllowsOperator { get; }
    public abstract virtual ExcelAddress get_Address();
    public abstract virtual ExcelDataValidationType get_ValidationType();
    public abstract virtual ExcelDataValidationWarningStyle get_ErrorStyle();
    public abstract virtual void set_ErrorStyle(ExcelDataValidationWarningStyle value);
    public abstract virtual Nullable`1<bool> get_AllowBlank();
    public abstract virtual void set_AllowBlank(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_ShowInputMessage();
    public abstract virtual void set_ShowInputMessage(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_ShowErrorMessage();
    public abstract virtual void set_ShowErrorMessage(Nullable`1<bool> value);
    public abstract virtual string get_ErrorTitle();
    public abstract virtual void set_ErrorTitle(string value);
    public abstract virtual string get_Error();
    public abstract virtual void set_Error(string value);
    public abstract virtual string get_PromptTitle();
    public abstract virtual void set_PromptTitle(string value);
    public abstract virtual string get_Prompt();
    public abstract virtual void set_Prompt(string value);
    public abstract virtual bool get_AllowsOperator();
    public abstract virtual void Validate();
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationAny {
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationCustom {
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationDateTime {
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationDecimal {
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationInt {
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationList {
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationTime {
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationWithFormula`1 {
    public T Formula { get; }
    public abstract virtual T get_Formula();
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationWithFormula2`1 {
    public T Formula2 { get; }
    public abstract virtual T get_Formula2();
}
public interface OfficeOpenXml.DataValidation.Contracts.IExcelDataValidationWithOperator {
    public ExcelDataValidationOperator Operator { get; public set; }
    public abstract virtual ExcelDataValidationOperator get_Operator();
    public abstract virtual void set_Operator(ExcelDataValidationOperator value);
}
internal static class OfficeOpenXml.DataValidation.DataValidationSchemaNames : object {
    public static string Any;
    public static string Whole;
    public static string Decimal;
    public static string List;
    public static string TextLength;
    public static string Date;
    public static string Time;
    public static string Custom;
}
public enum OfficeOpenXml.DataValidation.eDataValidationType : Enum {
    public int value__;
    public static eDataValidationType Any;
    public static eDataValidationType Whole;
    public static eDataValidationType Decimal;
    public static eDataValidationType List;
    public static eDataValidationType TextLength;
    public static eDataValidationType DateTime;
    public static eDataValidationType Time;
    public static eDataValidationType Custom;
}
public abstract class OfficeOpenXml.DataValidation.ExcelDataValidation : XmlHelper {
    private static string _itemElementNodeName;
    private string _errorStylePath;
    private string _errorTitlePath;
    private string _errorPath;
    private string _promptTitlePath;
    private string _promptPath;
    private string _operatorPath;
    private string _showErrorMessagePath;
    private string _showInputMessagePath;
    private string _typeMessagePath;
    private string _sqrefPath;
    private string _allowBlankPath;
    protected string _formula1Path;
    protected string _formula2Path;
    public bool AllowsOperator { get; }
    public ExcelAddress Address { get; private set; }
    public ExcelDataValidationType ValidationType { get; private set; }
    public ExcelDataValidationOperator Operator { get; public set; }
    public ExcelDataValidationWarningStyle ErrorStyle { get; public set; }
    public Nullable`1<bool> AllowBlank { get; public set; }
    public Nullable`1<bool> ShowInputMessage { get; public set; }
    public Nullable`1<bool> ShowErrorMessage { get; public set; }
    public string ErrorTitle { get; public set; }
    public string Error { get; public set; }
    public string PromptTitle { get; public set; }
    public string Prompt { get; public set; }
    protected string Formula1Internal { get; }
    protected string Formula2Internal { get; }
    internal ExcelDataValidation(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidation(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidation(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    private void Init();
    private string CheckAndFixRangeAddress(string address);
    private void SetNullableBoolValue(string path, Nullable`1<bool> val);
    public virtual void Validate();
    public sealed virtual bool get_AllowsOperator();
    public sealed virtual ExcelAddress get_Address();
    private void set_Address(ExcelAddress value);
    public sealed virtual ExcelDataValidationType get_ValidationType();
    private void set_ValidationType(ExcelDataValidationType value);
    public sealed virtual ExcelDataValidationOperator get_Operator();
    public sealed virtual void set_Operator(ExcelDataValidationOperator value);
    public sealed virtual ExcelDataValidationWarningStyle get_ErrorStyle();
    public sealed virtual void set_ErrorStyle(ExcelDataValidationWarningStyle value);
    public sealed virtual Nullable`1<bool> get_AllowBlank();
    public sealed virtual void set_AllowBlank(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_ShowInputMessage();
    public sealed virtual void set_ShowInputMessage(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_ShowErrorMessage();
    public sealed virtual void set_ShowErrorMessage(Nullable`1<bool> value);
    public sealed virtual string get_ErrorTitle();
    public sealed virtual void set_ErrorTitle(string value);
    public sealed virtual string get_Error();
    public sealed virtual void set_Error(string value);
    public sealed virtual string get_PromptTitle();
    public sealed virtual void set_PromptTitle(string value);
    public sealed virtual string get_Prompt();
    public sealed virtual void set_Prompt(string value);
    protected string get_Formula1Internal();
    protected string get_Formula2Internal();
    protected void SetValue(Nullable`1<T> val, string path);
    internal void SetAddress(string address);
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationAny : ExcelDataValidation {
    internal ExcelDataValidationAny(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidationAny(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidationAny(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    public virtual void Validate();
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.DataValidation.ExcelDataValidationCollection : XmlHelper {
    private List`1<IExcelDataValidation> _validations;
    private ExcelWorksheet _worksheet;
    private static string DataValidationPath;
    private string DataValidationItemsPath;
    public int Count { get; }
    public IExcelDataValidation Item { get; public set; }
    public IExcelDataValidation Item { get; }
    internal ExcelDataValidationCollection(ExcelWorksheet worksheet);
    private void EnsureRootElementExists();
    private void OnValidationCountChanged();
    private XmlNode GetRootNode();
    private void ValidateAddress(string address, IExcelDataValidation validatingValidation);
    private void ValidateAddress(string address);
    internal void ValidateAll();
    public IExcelDataValidationAny AddAnyValidation(string address);
    public IExcelDataValidationInt AddIntegerValidation(string address);
    public IExcelDataValidationDecimal AddDecimalValidation(string address);
    public IExcelDataValidationList AddListValidation(string address);
    public IExcelDataValidationInt AddTextLengthValidation(string address);
    public IExcelDataValidationDateTime AddDateTimeValidation(string address);
    public IExcelDataValidationTime AddTimeValidation(string address);
    public IExcelDataValidationCustom AddCustomValidation(string address);
    public bool Remove(IExcelDataValidation item);
    public int get_Count();
    public IExcelDataValidation get_Item(int index);
    public void set_Item(int index, IExcelDataValidation value);
    public IExcelDataValidation get_Item(string address);
    public IEnumerable`1<IExcelDataValidation> FindAll(Predicate`1<IExcelDataValidation> match);
    public IExcelDataValidation Find(Predicate`1<IExcelDataValidation> match);
    public void Clear();
    public void RemoveAll(Predicate`1<IExcelDataValidation> match);
    private sealed virtual override IEnumerator`1<IExcelDataValidation> System.Collections.Generic.IEnumerable<OfficeOpenXml.DataValidation.Contracts.IExcelDataValidation>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationCustom : ExcelDataValidationWithFormula`1<IExcelDataValidationFormula> {
    internal ExcelDataValidationCustom(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidationCustom(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidationCustom(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationDateTime : ExcelDataValidationWithFormula2`1<IExcelDataValidationFormulaDateTime> {
    internal ExcelDataValidationDateTime(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidationDateTime(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidationDateTime(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationDecimal : ExcelDataValidationWithFormula2`1<IExcelDataValidationFormulaDecimal> {
    internal ExcelDataValidationDecimal(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidationDecimal(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidationDecimal(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
}
internal static class OfficeOpenXml.DataValidation.ExcelDataValidationFactory : object {
    public static ExcelDataValidation Create(ExcelDataValidationType type, ExcelWorksheet worksheet, string address, XmlNode itemElementNode);
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationInt : ExcelDataValidationWithFormula2`1<IExcelDataValidationFormulaInt> {
    internal ExcelDataValidationInt(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidationInt(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidationInt(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationList : ExcelDataValidationWithFormula`1<IExcelDataValidationFormulaList> {
    internal ExcelDataValidationList(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidationList(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidationList(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
}
public enum OfficeOpenXml.DataValidation.ExcelDataValidationOperator : Enum {
    public int value__;
    public static ExcelDataValidationOperator any;
    public static ExcelDataValidationOperator equal;
    public static ExcelDataValidationOperator notEqual;
    public static ExcelDataValidationOperator lessThan;
    public static ExcelDataValidationOperator lessThanOrEqual;
    public static ExcelDataValidationOperator greaterThan;
    public static ExcelDataValidationOperator greaterThanOrEqual;
    public static ExcelDataValidationOperator between;
    public static ExcelDataValidationOperator notBetween;
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationTime : ExcelDataValidationWithFormula2`1<IExcelDataValidationFormulaTime> {
    internal ExcelDataValidationTime(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidationTime(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidationTime(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationType : object {
    [CompilerGeneratedAttribute]
private eDataValidationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchemaName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowOperator>k__BackingField;
    private static ExcelDataValidationType _any;
    private static ExcelDataValidationType _whole;
    private static ExcelDataValidationType _list;
    private static ExcelDataValidationType _decimal;
    private static ExcelDataValidationType _textLength;
    private static ExcelDataValidationType _dateTime;
    private static ExcelDataValidationType _time;
    private static ExcelDataValidationType _custom;
    public eDataValidationType Type { get; private set; }
    internal string SchemaName { get; private set; }
    internal bool AllowOperator { get; private set; }
    public static ExcelDataValidationType Any { get; }
    public static ExcelDataValidationType Whole { get; }
    public static ExcelDataValidationType List { get; }
    public static ExcelDataValidationType Decimal { get; }
    public static ExcelDataValidationType TextLength { get; }
    public static ExcelDataValidationType DateTime { get; }
    public static ExcelDataValidationType Time { get; }
    public static ExcelDataValidationType Custom { get; }
    private ExcelDataValidationType(eDataValidationType validationType, bool allowOperator, string schemaName);
    [CompilerGeneratedAttribute]
public eDataValidationType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(eDataValidationType value);
    [CompilerGeneratedAttribute]
internal string get_SchemaName();
    [CompilerGeneratedAttribute]
private void set_SchemaName(string value);
    [CompilerGeneratedAttribute]
internal bool get_AllowOperator();
    [CompilerGeneratedAttribute]
private void set_AllowOperator(bool value);
    internal static ExcelDataValidationType GetByValidationType(eDataValidationType type);
    internal static ExcelDataValidationType GetBySchemaName(string schemaName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ExcelDataValidationType get_Any();
    public static ExcelDataValidationType get_Whole();
    public static ExcelDataValidationType get_List();
    public static ExcelDataValidationType get_Decimal();
    public static ExcelDataValidationType get_TextLength();
    public static ExcelDataValidationType get_DateTime();
    public static ExcelDataValidationType get_Time();
    public static ExcelDataValidationType get_Custom();
}
public enum OfficeOpenXml.DataValidation.ExcelDataValidationWarningStyle : Enum {
    public int value__;
    public static ExcelDataValidationWarningStyle undefined;
    public static ExcelDataValidationWarningStyle stop;
    public static ExcelDataValidationWarningStyle warning;
    public static ExcelDataValidationWarningStyle information;
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula`1 : ExcelDataValidation {
    [CompilerGeneratedAttribute]
private T <Formula>k__BackingField;
    public T Formula { get; protected set; }
    internal ExcelDataValidationWithFormula`1(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidationWithFormula`1(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidationWithFormula`1(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Formula();
    [CompilerGeneratedAttribute]
protected void set_Formula(T value);
    public virtual void Validate();
}
public class OfficeOpenXml.DataValidation.ExcelDataValidationWithFormula2`1 : ExcelDataValidationWithFormula`1<T> {
    [CompilerGeneratedAttribute]
private T <Formula2>k__BackingField;
    public T Formula2 { get; protected set; }
    internal ExcelDataValidationWithFormula2`1(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType);
    internal ExcelDataValidationWithFormula2`1(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode);
    internal ExcelDataValidationWithFormula2`1(ExcelWorksheet worksheet, string address, ExcelDataValidationType validationType, XmlNode itemElementNode, XmlNamespaceManager namespaceManager);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Formula2();
    [CompilerGeneratedAttribute]
protected void set_Formula2(T value);
}
public class OfficeOpenXml.DataValidation.ExcelTime : object {
    [CompilerGeneratedAttribute]
private EventHandler _timeChanged;
    private decimal SecondsPerDay;
    private decimal SecondsPerHour;
    private decimal SecondsPerMinute;
    public static int NumberOfDecimals;
    private int _hour;
    private int _minute;
    private Nullable`1<int> _second;
    public int Hour { get; public set; }
    public int Minute { get; public set; }
    public Nullable`1<int> Second { get; public set; }
    public ExcelTime(decimal value);
    [CompilerGeneratedAttribute]
private void add__timeChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove__timeChanged(EventHandler value);
    private void Init(decimal value);
    private void SetSecond(int value);
    private void SetMinute(int value);
    private void SetHour(int value);
    internal void add_TimeChanged(EventHandler value);
    internal void remove_TimeChanged(EventHandler value);
    private void OnTimeChanged();
    public int get_Hour();
    public void set_Hour(int value);
    public int get_Minute();
    public void set_Minute(int value);
    public Nullable`1<int> get_Second();
    public void set_Second(Nullable`1<int> value);
    private decimal Round(decimal value);
    private decimal ToSeconds();
    public decimal ToExcelTime();
    public string ToExcelString();
    public virtual string ToString();
}
public interface OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormula {
    public string ExcelFormula { get; public set; }
    public abstract virtual string get_ExcelFormula();
    public abstract virtual void set_ExcelFormula(string value);
}
public interface OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaDateTime {
}
public interface OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaDecimal {
}
public interface OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaInt {
}
public interface OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaList {
    public IList`1<string> Values { get; }
    public abstract virtual IList`1<string> get_Values();
}
public interface OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaTime {
}
public interface OfficeOpenXml.DataValidation.Formulas.Contracts.IExcelDataValidationFormulaWithValue`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
internal abstract class OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormula : XmlHelper {
    private string _formula;
    [CompilerGeneratedAttribute]
private string <FormulaPath>k__BackingField;
    [CompilerGeneratedAttribute]
private FormulaState <State>k__BackingField;
    protected string FormulaPath { get; private set; }
    protected FormulaState State { get; protected set; }
    public string ExcelFormula { get; public set; }
    public ExcelDataValidationFormula(XmlNamespaceManager namespaceManager, XmlNode topNode, string formulaPath);
    [CompilerGeneratedAttribute]
protected string get_FormulaPath();
    [CompilerGeneratedAttribute]
private void set_FormulaPath(string value);
    [CompilerGeneratedAttribute]
protected FormulaState get_State();
    [CompilerGeneratedAttribute]
protected void set_State(FormulaState value);
    public sealed virtual string get_ExcelFormula();
    public sealed virtual void set_ExcelFormula(string value);
    internal abstract virtual void ResetValue();
    internal virtual string GetXmlValue();
    protected abstract virtual string GetValueAsString();
}
internal class OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaCustom : ExcelDataValidationFormula {
    public ExcelDataValidationFormulaCustom(XmlNamespaceManager namespaceManager, XmlNode topNode, string formulaPath);
    internal virtual string GetXmlValue();
    protected virtual string GetValueAsString();
    internal virtual void ResetValue();
}
internal class OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaDateTime : ExcelDataValidationFormulaValue`1<Nullable`1<DateTime>> {
    public ExcelDataValidationFormulaDateTime(XmlNamespaceManager namespaceManager, XmlNode topNode, string formulaPath);
    protected virtual string GetValueAsString();
}
internal class OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaDecimal : ExcelDataValidationFormulaValue`1<Nullable`1<double>> {
    public ExcelDataValidationFormulaDecimal(XmlNamespaceManager namespaceManager, XmlNode topNode, string formulaPath);
    protected virtual string GetValueAsString();
}
internal class OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaInt : ExcelDataValidationFormulaValue`1<Nullable`1<int>> {
    public ExcelDataValidationFormulaInt(XmlNamespaceManager namespaceManager, XmlNode topNode, string formulaPath);
    protected virtual string GetValueAsString();
}
internal class OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaList : ExcelDataValidationFormula {
    private string _formulaPath;
    [CompilerGeneratedAttribute]
private IList`1<string> <Values>k__BackingField;
    public IList`1<string> Values { get; private set; }
    public ExcelDataValidationFormulaList(XmlNamespaceManager namespaceManager, XmlNode itemNode, string formulaPath);
    private void SetInitialValues();
    private void values_ListChanged(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(IList`1<string> value);
    protected virtual string GetValueAsString();
    internal virtual void ResetValue();
}
internal class OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaTime : ExcelDataValidationFormulaValue`1<ExcelTime> {
    public ExcelDataValidationFormulaTime(XmlNamespaceManager namespaceManager, XmlNode topNode, string formulaPath);
    private void Value_TimeChanged(object sender, EventArgs e);
    protected virtual string GetValueAsString();
    internal virtual void ResetValue();
}
internal abstract class OfficeOpenXml.DataValidation.Formulas.ExcelDataValidationFormulaValue`1 : ExcelDataValidationFormula {
    private T _value;
    public T Value { get; public set; }
    public ExcelDataValidationFormulaValue`1(XmlNamespaceManager namespaceManager, XmlNode topNode, string formulaPath);
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
    internal virtual void ResetValue();
}
internal enum OfficeOpenXml.DataValidation.Formulas.FormulaState : Enum {
    public int value__;
    public static FormulaState Value;
    public static FormulaState Formula;
}
public interface OfficeOpenXml.DataValidation.IRangeDataValidation {
    public abstract virtual IExcelDataValidationAny AddAnyDataValidation();
    public abstract virtual IExcelDataValidationInt AddIntegerDataValidation();
    public abstract virtual IExcelDataValidationDecimal AddDecimalDataValidation();
    public abstract virtual IExcelDataValidationDateTime AddDateTimeDataValidation();
    public abstract virtual IExcelDataValidationList AddListDataValidation();
    public abstract virtual IExcelDataValidationInt AddTextLengthDataValidation();
    public abstract virtual IExcelDataValidationTime AddTimeDataValidation();
    public abstract virtual IExcelDataValidationCustom AddCustomDataValidation();
}
internal class OfficeOpenXml.DataValidation.RangeDataValidation : object {
    private ExcelWorksheet _worksheet;
    private string _address;
    public RangeDataValidation(ExcelWorksheet worksheet, string address);
    public sealed virtual IExcelDataValidationAny AddAnyDataValidation();
    public sealed virtual IExcelDataValidationInt AddIntegerDataValidation();
    public sealed virtual IExcelDataValidationDecimal AddDecimalDataValidation();
    public sealed virtual IExcelDataValidationDateTime AddDateTimeDataValidation();
    public sealed virtual IExcelDataValidationList AddListDataValidation();
    public sealed virtual IExcelDataValidationInt AddTextLengthDataValidation();
    public sealed virtual IExcelDataValidationTime AddTimeDataValidation();
    public sealed virtual IExcelDataValidationCustom AddCustomDataValidation();
}
public enum OfficeOpenXml.Drawing.Chart.eAxisOrientation : Enum {
    public int value__;
    public static eAxisOrientation MaxMin;
    public static eAxisOrientation MinMax;
}
public enum OfficeOpenXml.Drawing.Chart.eAxisPosition : Enum {
    public int value__;
    public static eAxisPosition Left;
    public static eAxisPosition Bottom;
    public static eAxisPosition Right;
    public static eAxisPosition Top;
}
public enum OfficeOpenXml.Drawing.Chart.eAxisTickMark : Enum {
    public int value__;
    public static eAxisTickMark Cross;
    public static eAxisTickMark In;
    public static eAxisTickMark None;
    public static eAxisTickMark Out;
}
public enum OfficeOpenXml.Drawing.Chart.eBuildInUnits : Enum {
    public long value__;
    public static eBuildInUnits hundreds;
    public static eBuildInUnits thousands;
    public static eBuildInUnits tenThousands;
    public static eBuildInUnits hundredThousands;
    public static eBuildInUnits millions;
    public static eBuildInUnits tenMillions;
    public static eBuildInUnits hundredMillions;
    public static eBuildInUnits billions;
    public static eBuildInUnits trillions;
}
public enum OfficeOpenXml.Drawing.Chart.eChartStyle : Enum {
    public int value__;
    public static eChartStyle None;
    public static eChartStyle Style1;
    public static eChartStyle Style2;
    public static eChartStyle Style3;
    public static eChartStyle Style4;
    public static eChartStyle Style5;
    public static eChartStyle Style6;
    public static eChartStyle Style7;
    public static eChartStyle Style8;
    public static eChartStyle Style9;
    public static eChartStyle Style10;
    public static eChartStyle Style11;
    public static eChartStyle Style12;
    public static eChartStyle Style13;
    public static eChartStyle Style14;
    public static eChartStyle Style15;
    public static eChartStyle Style16;
    public static eChartStyle Style17;
    public static eChartStyle Style18;
    public static eChartStyle Style19;
    public static eChartStyle Style20;
    public static eChartStyle Style21;
    public static eChartStyle Style22;
    public static eChartStyle Style23;
    public static eChartStyle Style24;
    public static eChartStyle Style25;
    public static eChartStyle Style26;
    public static eChartStyle Style27;
    public static eChartStyle Style28;
    public static eChartStyle Style29;
    public static eChartStyle Style30;
    public static eChartStyle Style31;
    public static eChartStyle Style32;
    public static eChartStyle Style33;
    public static eChartStyle Style34;
    public static eChartStyle Style35;
    public static eChartStyle Style36;
    public static eChartStyle Style37;
    public static eChartStyle Style38;
    public static eChartStyle Style39;
    public static eChartStyle Style40;
    public static eChartStyle Style41;
    public static eChartStyle Style42;
    public static eChartStyle Style43;
    public static eChartStyle Style44;
    public static eChartStyle Style45;
    public static eChartStyle Style46;
    public static eChartStyle Style47;
    public static eChartStyle Style48;
}
public enum OfficeOpenXml.Drawing.Chart.eChartType : Enum {
    public int value__;
    public static eChartType Area3D;
    public static eChartType AreaStacked3D;
    public static eChartType AreaStacked1003D;
    public static eChartType BarClustered3D;
    public static eChartType BarStacked3D;
    public static eChartType BarStacked1003D;
    public static eChartType Column3D;
    public static eChartType ColumnClustered3D;
    public static eChartType ColumnStacked3D;
    public static eChartType ColumnStacked1003D;
    public static eChartType Line3D;
    public static eChartType Pie3D;
    public static eChartType PieExploded3D;
    public static eChartType Area;
    public static eChartType AreaStacked;
    public static eChartType AreaStacked100;
    public static eChartType BarClustered;
    public static eChartType BarOfPie;
    public static eChartType BarStacked;
    public static eChartType BarStacked100;
    public static eChartType Bubble;
    public static eChartType Bubble3DEffect;
    public static eChartType ColumnClustered;
    public static eChartType ColumnStacked;
    public static eChartType ColumnStacked100;
    public static eChartType ConeBarClustered;
    public static eChartType ConeBarStacked;
    public static eChartType ConeBarStacked100;
    public static eChartType ConeCol;
    public static eChartType ConeColClustered;
    public static eChartType ConeColStacked;
    public static eChartType ConeColStacked100;
    public static eChartType CylinderBarClustered;
    public static eChartType CylinderBarStacked;
    public static eChartType CylinderBarStacked100;
    public static eChartType CylinderCol;
    public static eChartType CylinderColClustered;
    public static eChartType CylinderColStacked;
    public static eChartType CylinderColStacked100;
    public static eChartType Doughnut;
    public static eChartType DoughnutExploded;
    public static eChartType Line;
    public static eChartType LineMarkers;
    public static eChartType LineMarkersStacked;
    public static eChartType LineMarkersStacked100;
    public static eChartType LineStacked;
    public static eChartType LineStacked100;
    public static eChartType Pie;
    public static eChartType PieExploded;
    public static eChartType PieOfPie;
    public static eChartType PyramidBarClustered;
    public static eChartType PyramidBarStacked;
    public static eChartType PyramidBarStacked100;
    public static eChartType PyramidCol;
    public static eChartType PyramidColClustered;
    public static eChartType PyramidColStacked;
    public static eChartType PyramidColStacked100;
    public static eChartType Radar;
    public static eChartType RadarFilled;
    public static eChartType RadarMarkers;
    public static eChartType StockHLC;
    public static eChartType StockOHLC;
    public static eChartType StockVHLC;
    public static eChartType StockVOHLC;
    public static eChartType Surface;
    public static eChartType SurfaceTopView;
    public static eChartType SurfaceTopViewWireframe;
    public static eChartType SurfaceWireframe;
    public static eChartType XYScatter;
    public static eChartType XYScatterLines;
    public static eChartType XYScatterLinesNoMarkers;
    public static eChartType XYScatterSmooth;
    public static eChartType XYScatterSmoothNoMarkers;
}
public enum OfficeOpenXml.Drawing.Chart.eCrossBetween : Enum {
    public int value__;
    public static eCrossBetween Between;
    public static eCrossBetween MidCat;
}
public enum OfficeOpenXml.Drawing.Chart.eCrosses : Enum {
    public int value__;
    public static eCrosses AutoZero;
    public static eCrosses Max;
    public static eCrosses Min;
}
public enum OfficeOpenXml.Drawing.Chart.eDirection : Enum {
    public int value__;
    public static eDirection Column;
    public static eDirection Bar;
}
public enum OfficeOpenXml.Drawing.Chart.eDisplayBlanksAs : Enum {
    public int value__;
    public static eDisplayBlanksAs Gap;
    public static eDisplayBlanksAs Span;
    public static eDisplayBlanksAs Zero;
}
public enum OfficeOpenXml.Drawing.Chart.eGrouping : Enum {
    public int value__;
    public static eGrouping Standard;
    public static eGrouping Clustered;
    public static eGrouping Stacked;
    public static eGrouping PercentStacked;
}
public enum OfficeOpenXml.Drawing.Chart.eLabelPosition : Enum {
    public int value__;
    public static eLabelPosition BestFit;
    public static eLabelPosition Left;
    public static eLabelPosition Right;
    public static eLabelPosition Center;
    public static eLabelPosition Top;
    public static eLabelPosition Bottom;
    public static eLabelPosition InBase;
    public static eLabelPosition InEnd;
    public static eLabelPosition OutEnd;
}
public enum OfficeOpenXml.Drawing.Chart.eLegendPosition : Enum {
    public int value__;
    public static eLegendPosition Top;
    public static eLegendPosition Left;
    public static eLegendPosition Right;
    public static eLegendPosition Bottom;
    public static eLegendPosition TopRight;
}
public enum OfficeOpenXml.Drawing.Chart.eMarkerStyle : Enum {
    public int value__;
    public static eMarkerStyle Circle;
    public static eMarkerStyle Dash;
    public static eMarkerStyle Diamond;
    public static eMarkerStyle Dot;
    public static eMarkerStyle None;
    public static eMarkerStyle Picture;
    public static eMarkerStyle Plus;
    public static eMarkerStyle Square;
    public static eMarkerStyle Star;
    public static eMarkerStyle Triangle;
    public static eMarkerStyle X;
}
public enum OfficeOpenXml.Drawing.Chart.ePieType : Enum {
    public int value__;
    public static ePieType Bar;
    public static ePieType Pie;
}
public enum OfficeOpenXml.Drawing.Chart.eRadarStyle : Enum {
    public int value__;
    public static eRadarStyle Filled;
    public static eRadarStyle Marker;
    public static eRadarStyle Standard;
}
public enum OfficeOpenXml.Drawing.Chart.eScatterStyle : Enum {
    public int value__;
    public static eScatterStyle LineMarker;
    public static eScatterStyle SmoothMarker;
}
public enum OfficeOpenXml.Drawing.Chart.eShape : Enum {
    public int value__;
    public static eShape Box;
    public static eShape Cone;
    public static eShape ConeToMax;
    public static eShape Cylinder;
    public static eShape Pyramid;
    public static eShape PyramidToMax;
}
public enum OfficeOpenXml.Drawing.Chart.eSizeRepresents : Enum {
    public int value__;
    public static eSizeRepresents Area;
    public static eSizeRepresents Width;
}
public enum OfficeOpenXml.Drawing.Chart.eTickLabelPosition : Enum {
    public int value__;
    public static eTickLabelPosition High;
    public static eTickLabelPosition Low;
    public static eTickLabelPosition NextTo;
    public static eTickLabelPosition None;
}
public enum OfficeOpenXml.Drawing.Chart.eTimeUnit : Enum {
    public int value__;
    public static eTimeUnit Years;
    public static eTimeUnit Months;
    public static eTimeUnit Days;
}
public enum OfficeOpenXml.Drawing.Chart.eTrendLine : Enum {
    public int value__;
    public static eTrendLine Exponential;
    public static eTrendLine Linear;
    public static eTrendLine Logarithmic;
    public static eTrendLine MovingAvgerage;
    public static eTrendLine Polynomial;
    public static eTrendLine Power;
}
public enum OfficeOpenXml.Drawing.Chart.eXAxisPosition : Enum {
    public int value__;
    public static eXAxisPosition Bottom;
    public static eXAxisPosition Top;
}
public class OfficeOpenXml.Drawing.Chart.ExcelBarChart : ExcelChart {
    private string _directionPath;
    private string _shapePath;
    private ExcelChartDataLabel _DataLabel;
    private string _gapWidthPath;
    public eDirection Direction { get; internal set; }
    public eShape Shape { get; internal set; }
    public ExcelChartDataLabel DataLabel { get; }
    public int GapWidth { get; public set; }
    internal ExcelBarChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    internal ExcelBarChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    internal ExcelBarChart(ExcelChart topChart, XmlNode chartNode);
    private void SetChartNodeText(string chartNodeText);
    private void SetTypeProperties(ExcelDrawings drawings, eChartType type);
    public eDirection get_Direction();
    internal void set_Direction(eDirection value);
    public eShape get_Shape();
    internal void set_Shape(eShape value);
    public ExcelChartDataLabel get_DataLabel();
    public int get_GapWidth();
    public void set_GapWidth(int value);
    private string GetDirectionText(eDirection direction);
    private eDirection GetDirectionEnum(string direction);
    private string GetShapeText(eShape Shape);
    private eShape GetShapeEnum(string text);
    internal virtual eChartType GetChartType(string name);
}
public class OfficeOpenXml.Drawing.Chart.ExcelBarChartSerie : ExcelChartSerie {
    private ExcelChartSerieDataLabel _DataLabel;
    private static string INVERTIFNEGATIVE_PATH;
    public ExcelChartSerieDataLabel DataLabel { get; }
    internal bool InvertIfNegative { get; internal set; }
    internal ExcelBarChartSerie(ExcelChartSeries chartSeries, XmlNamespaceManager ns, XmlNode node, bool isPivot);
    public ExcelChartSerieDataLabel get_DataLabel();
    internal bool get_InvertIfNegative();
    internal void set_InvertIfNegative(bool value);
}
public class OfficeOpenXml.Drawing.Chart.ExcelBubbleChart : ExcelChart {
    private string BUBBLESCALE_PATH;
    private string SHOWNEGBUBBLES_PATH;
    private string BUBBLE3D_PATH;
    private string SIZEREPRESENTS_PATH;
    public int BubbleScale { get; public set; }
    public bool ShowNegativeBubbles { get; public set; }
    public bool Bubble3D { get; public set; }
    public eSizeRepresents SizeRepresents { get; public set; }
    public ExcelBubbleChartSeries Series { get; }
    internal ExcelBubbleChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    internal ExcelBubbleChart(ExcelDrawings drawings, XmlNode node, eChartType type, bool isPivot);
    internal ExcelBubbleChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    internal ExcelBubbleChart(ExcelChart topChart, XmlNode chartNode);
    public int get_BubbleScale();
    public void set_BubbleScale(int value);
    public bool get_ShowNegativeBubbles();
    public void set_ShowNegativeBubbles(bool value);
    public bool get_Bubble3D();
    public void set_Bubble3D(bool value);
    public eSizeRepresents get_SizeRepresents();
    public void set_SizeRepresents(eSizeRepresents value);
    public ExcelBubbleChartSeries get_Series();
    internal virtual eChartType GetChartType(string name);
}
public class OfficeOpenXml.Drawing.Chart.ExcelBubbleChartSerie : ExcelChartSerie {
    private ExcelChartSerieDataLabel _DataLabel;
    private static string BUBBLE3D_PATH;
    private static string INVERTIFNEGATIVE_PATH;
    private static string BUBBLESIZE_TOPPATH;
    private static string BUBBLESIZE_PATH;
    public ExcelChartSerieDataLabel DataLabel { get; }
    internal bool Bubble3D { get; internal set; }
    internal bool InvertIfNegative { get; internal set; }
    public string Series { get; public set; }
    public string BubbleSize { get; public set; }
    internal ExcelBubbleChartSerie(ExcelChartSeries chartSeries, XmlNamespaceManager ns, XmlNode node, bool isPivot);
    public ExcelChartSerieDataLabel get_DataLabel();
    internal bool get_Bubble3D();
    internal void set_Bubble3D(bool value);
    internal bool get_InvertIfNegative();
    internal void set_InvertIfNegative(bool value);
    public virtual string get_Series();
    public virtual void set_Series(string value);
    public string get_BubbleSize();
    public void set_BubbleSize(string value);
    internal void GenerateLit();
}
public class OfficeOpenXml.Drawing.Chart.ExcelBubbleChartSeries : ExcelChartSeries {
    internal ExcelBubbleChartSeries(ExcelChart chart, XmlNamespaceManager ns, XmlNode node, bool isPivot);
    public ExcelChartSerie Add(ExcelRangeBase Serie, ExcelRangeBase XSerie, ExcelRangeBase BubbleSize);
    public ExcelChartSerie Add(string SerieAddress, string XSerieAddress, string BubbleSizeAddress);
}
public class OfficeOpenXml.Drawing.Chart.ExcelChart : ExcelDrawing {
    private static string rootPath;
    protected internal ExcelChartSeries _chartSeries;
    internal ExcelChartAxis[] _axis;
    protected XmlHelper _chartXmlHelper;
    [CompilerGeneratedAttribute]
private ExcelWorksheet <WorkSheet>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocument <ChartXml>k__BackingField;
    [CompilerGeneratedAttribute]
private eChartType <ChartType>k__BackingField;
    protected internal XmlNode _chartNode;
    [CompilerGeneratedAttribute]
private ExcelChartAxis <XAxis>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelChartAxis <YAxis>k__BackingField;
    private bool _secondaryAxis;
    private static string _plotVisibleOnlyPath;
    private static string _displayBlanksAsPath;
    private static string _showDLblsOverMax;
    private ExcelChartPlotArea _plotArea;
    private ExcelChartLegend _legend;
    private ExcelDrawingBorder _border;
    private ExcelDrawingFill _fill;
    private string _groupingPath;
    private string _varyColorsPath;
    [CompilerGeneratedAttribute]
private ZipPackagePart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <UriChart>k__BackingField;
    private ExcelChartTitle _title;
    [CompilerGeneratedAttribute]
private ExcelPivotTable <PivotTableSource>k__BackingField;
    public ExcelWorksheet WorkSheet { get; internal set; }
    public XmlDocument ChartXml { get; internal set; }
    public eChartType ChartType { get; internal set; }
    internal XmlNode ChartNode { get; }
    public ExcelChartTitle Title { get; }
    public ExcelChartSeries Series { get; }
    public ExcelChartAxis[] Axis { get; }
    public ExcelChartAxis XAxis { get; private set; }
    public ExcelChartAxis YAxis { get; private set; }
    public bool UseSecondaryAxis { get; public set; }
    public eChartStyle Style { get; public set; }
    public bool ShowHiddenData { get; public set; }
    public eDisplayBlanksAs DisplayBlanksAs { get; public set; }
    public bool ShowDataLabelsOverMaximum { get; public set; }
    public ExcelChartPlotArea PlotArea { get; }
    public ExcelChartLegend Legend { get; }
    public ExcelDrawingBorder Border { get; }
    public ExcelDrawingFill Fill { get; }
    public ExcelView3D View3D { get; }
    public eGrouping Grouping { get; internal set; }
    public bool VaryColors { get; public set; }
    internal ZipPackagePart Part { get; internal set; }
    internal Uri UriChart { get; internal set; }
    internal string Id { get; }
    public ExcelPivotTable PivotTableSource { get; private set; }
    internal ExcelChart(ExcelDrawings drawings, XmlNode node, eChartType type, bool isPivot);
    internal ExcelChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    internal ExcelChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    internal ExcelChart(ExcelChart topChart, XmlNode chartNode);
    private void InitChartLoad(ExcelDrawings drawings, XmlNode chartNode);
    private void Init(ExcelDrawings drawings, XmlNode chartNode);
    private void SetTypeProperties();
    private void CreateNewChart(ExcelDrawings drawings, eChartType type, ExcelChart topChart);
    private void LoadAxis();
    internal virtual eChartType GetChartType(string name);
    private string ChartStartXml(eChartType type);
    private string GetChartSerieStartXml(eChartType type, int axID, int xAxID, int serAxID);
    private string AddAxisId(int axID, int xAxID, int serAxID);
    private string AddAxType();
    private string AddScatterType(eChartType type);
    private string AddRadarType(eChartType type);
    private string AddGrouping();
    private string AddHoleSize(eChartType type);
    private string AddFirstSliceAng(eChartType type);
    private string AddVaryColors();
    private string AddHasMarker(eChartType type);
    private string AddShape(eChartType type);
    private string AddBarDir(eChartType type);
    private string AddPerspectiveXml(eChartType type);
    private string AddSurfaceXml(eChartType type);
    private string AddSurfacePart(string name);
    internal static bool IsType3D(eChartType chartType);
    protected internal bool IsType3D();
    protected bool IsTypeLine();
    protected bool IsTypeScatterBubble();
    protected bool IsTypeSurface();
    protected bool IsTypeShape();
    protected internal bool IsTypePercentStacked();
    protected internal bool IsTypeStacked();
    protected bool IsTypeClustered();
    protected internal bool IsTypePieDoughnut();
    protected string GetChartNodeText();
    internal void AddAxis();
    internal void RemoveSecondaryAxis();
    [CompilerGeneratedAttribute]
public ExcelWorksheet get_WorkSheet();
    [CompilerGeneratedAttribute]
internal void set_WorkSheet(ExcelWorksheet value);
    [CompilerGeneratedAttribute]
public XmlDocument get_ChartXml();
    [CompilerGeneratedAttribute]
internal void set_ChartXml(XmlDocument value);
    [CompilerGeneratedAttribute]
public eChartType get_ChartType();
    [CompilerGeneratedAttribute]
internal void set_ChartType(eChartType value);
    internal XmlNode get_ChartNode();
    public ExcelChartTitle get_Title();
    public virtual ExcelChartSeries get_Series();
    public ExcelChartAxis[] get_Axis();
    [CompilerGeneratedAttribute]
public ExcelChartAxis get_XAxis();
    [CompilerGeneratedAttribute]
private void set_XAxis(ExcelChartAxis value);
    [CompilerGeneratedAttribute]
public ExcelChartAxis get_YAxis();
    [CompilerGeneratedAttribute]
private void set_YAxis(ExcelChartAxis value);
    public bool get_UseSecondaryAxis();
    public void set_UseSecondaryAxis(bool value);
    public eChartStyle get_Style();
    public void set_Style(eChartStyle value);
    public bool get_ShowHiddenData();
    public void set_ShowHiddenData(bool value);
    public eDisplayBlanksAs get_DisplayBlanksAs();
    public void set_DisplayBlanksAs(eDisplayBlanksAs value);
    public bool get_ShowDataLabelsOverMaximum();
    public void set_ShowDataLabelsOverMaximum(bool value);
    private bool HasPrimaryAxis();
    private void CheckRemoveAxis(ExcelChartAxis excelChartAxis);
    private bool ExistsAxis(ExcelChartAxis excelChartAxis);
    public ExcelChartPlotArea get_PlotArea();
    public ExcelChartLegend get_Legend();
    public ExcelDrawingBorder get_Border();
    public ExcelDrawingFill get_Fill();
    public ExcelView3D get_View3D();
    public eGrouping get_Grouping();
    internal void set_Grouping(eGrouping value);
    public bool get_VaryColors();
    public void set_VaryColors(bool value);
    [CompilerGeneratedAttribute]
internal ZipPackagePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(ZipPackagePart value);
    [CompilerGeneratedAttribute]
internal Uri get_UriChart();
    [CompilerGeneratedAttribute]
internal void set_UriChart(Uri value);
    internal string get_Id();
    private string GetGroupingText(eGrouping grouping);
    private eGrouping GetGroupingEnum(string grouping);
    internal static ExcelChart GetChart(ExcelDrawings drawings, XmlNode node);
    internal static ExcelChart GetChart(XmlElement chartNode, ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, ExcelChart topChart);
    internal static ExcelChart GetNewChart(ExcelDrawings drawings, XmlNode drawNode, eChartType chartType, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    [CompilerGeneratedAttribute]
public ExcelPivotTable get_PivotTableSource();
    [CompilerGeneratedAttribute]
private void set_PivotTableSource(ExcelPivotTable value);
    internal void SetPivotSource(ExcelPivotTable pivotTableSource);
    internal virtual void DeleteMe();
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartAxis : XmlHelper {
    private static string _majorTickMark;
    private static string _minorTickMark;
    private string AXIS_POSITION_PATH;
    private static string _crossesPath;
    private static string _crossBetweenPath;
    private static string _crossesAtPath;
    private static string _formatPath;
    private static string _sourceLinkedPath;
    private static string _lblPos;
    private ExcelDrawingFill _fill;
    private ExcelDrawingBorder _border;
    private ExcelTextFont _font;
    private static string _ticLblPos_Path;
    private static string _displayUnitPath;
    private static string _custUnitPath;
    private ExcelChartTitle _title;
    private static string _minValuePath;
    private static string _maxValuePath;
    private static string _majorUnitPath;
    private static string _majorUnitCatPath;
    private static string _majorTimeUnitPath;
    private static string _minorUnitPath;
    private static string _minorUnitCatPath;
    private static string _minorTimeUnitPath;
    private static string _logbasePath;
    private static string _orientationPath;
    internal string Id { get; }
    public eAxisTickMark MajorTickMark { get; public set; }
    public eAxisTickMark MinorTickMark { get; public set; }
    internal eAxisType AxisType { get; }
    public eAxisPosition AxisPosition { get; internal set; }
    public eCrosses Crosses { get; public set; }
    public eCrossBetween CrossBetween { get; public set; }
    public Nullable`1<double> CrossesAt { get; public set; }
    public string Format { get; public set; }
    public bool SourceLinked { get; public set; }
    public eTickLabelPosition LabelPosition { get; public set; }
    public ExcelDrawingFill Fill { get; }
    public ExcelDrawingBorder Border { get; }
    public ExcelTextFont Font { get; }
    public bool Deleted { get; public set; }
    public eTickLabelPosition TickLabelPosition { get; public set; }
    public double DisplayUnit { get; public set; }
    public ExcelChartTitle Title { get; }
    public Nullable`1<double> MinValue { get; public set; }
    public Nullable`1<double> MaxValue { get; public set; }
    public Nullable`1<double> MajorUnit { get; public set; }
    public Nullable`1<eTimeUnit> MajorTimeUnit { get; public set; }
    public Nullable`1<double> MinorUnit { get; public set; }
    public Nullable`1<eTimeUnit> MinorTimeUnit { get; public set; }
    public Nullable`1<double> LogBase { get; public set; }
    public eAxisOrientation Orientation { get; public set; }
    internal ExcelChartAxis(XmlNamespaceManager nameSpaceManager, XmlNode topNode);
    internal string get_Id();
    public eAxisTickMark get_MajorTickMark();
    public void set_MajorTickMark(eAxisTickMark value);
    public eAxisTickMark get_MinorTickMark();
    public void set_MinorTickMark(eAxisTickMark value);
    internal eAxisType get_AxisType();
    public eAxisPosition get_AxisPosition();
    internal void set_AxisPosition(eAxisPosition value);
    public eCrosses get_Crosses();
    public void set_Crosses(eCrosses value);
    public eCrossBetween get_CrossBetween();
    public void set_CrossBetween(eCrossBetween value);
    public Nullable`1<double> get_CrossesAt();
    public void set_CrossesAt(Nullable`1<double> value);
    public string get_Format();
    public void set_Format(string value);
    public bool get_SourceLinked();
    public void set_SourceLinked(bool value);
    public eTickLabelPosition get_LabelPosition();
    public void set_LabelPosition(eTickLabelPosition value);
    public ExcelDrawingFill get_Fill();
    public ExcelDrawingBorder get_Border();
    public ExcelTextFont get_Font();
    public bool get_Deleted();
    public void set_Deleted(bool value);
    public eTickLabelPosition get_TickLabelPosition();
    public void set_TickLabelPosition(eTickLabelPosition value);
    public double get_DisplayUnit();
    public void set_DisplayUnit(double value);
    public ExcelChartTitle get_Title();
    public Nullable`1<double> get_MinValue();
    public void set_MinValue(Nullable`1<double> value);
    public Nullable`1<double> get_MaxValue();
    public void set_MaxValue(Nullable`1<double> value);
    public Nullable`1<double> get_MajorUnit();
    public void set_MajorUnit(Nullable`1<double> value);
    public Nullable`1<eTimeUnit> get_MajorTimeUnit();
    public void set_MajorTimeUnit(Nullable`1<eTimeUnit> value);
    public Nullable`1<double> get_MinorUnit();
    public void set_MinorUnit(Nullable`1<double> value);
    public Nullable`1<eTimeUnit> get_MinorTimeUnit();
    public void set_MinorTimeUnit(Nullable`1<eTimeUnit> value);
    public Nullable`1<double> get_LogBase();
    public void set_LogBase(Nullable`1<double> value);
    public eAxisOrientation get_Orientation();
    public void set_Orientation(eAxisOrientation value);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Drawing.Chart.ExcelChartCollection : object {
    private List`1<ExcelChart> _list;
    private ExcelChart _topChart;
    public int Count { get; }
    public ExcelChart Item { get; }
    internal ExcelChartCollection(ExcelChart chart);
    internal void Add(ExcelChart chart);
    public ExcelChart Add(eChartType chartType);
    public int get_Count();
    private sealed virtual override IEnumerator`1<ExcelChart> System.Collections.Generic.IEnumerable<OfficeOpenXml.Drawing.Chart.ExcelChart>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ExcelChart get_Item(int PositionID);
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartDataLabel : XmlHelper {
    private static string showValPath;
    private static string showCatPath;
    private static string showSerPath;
    private static string showPerentPath;
    private static string showLeaderLinesPath;
    private static string showBubbleSizePath;
    private static string showLegendKeyPath;
    private static string separatorPath;
    private ExcelDrawingFill _fill;
    private ExcelDrawingBorder _border;
    private String[] _paragraphSchemaOrder;
    private ExcelTextFont _font;
    public bool ShowValue { get; public set; }
    public bool ShowCategory { get; public set; }
    public bool ShowSeriesName { get; public set; }
    public bool ShowPercent { get; public set; }
    public bool ShowLeaderLines { get; public set; }
    public bool ShowBubbleSize { get; public set; }
    public bool ShowLegendKey { get; public set; }
    public string Separator { get; public set; }
    public ExcelDrawingFill Fill { get; }
    public ExcelDrawingBorder Border { get; }
    public ExcelTextFont Font { get; }
    internal ExcelChartDataLabel(XmlNamespaceManager ns, XmlNode node);
    public bool get_ShowValue();
    public void set_ShowValue(bool value);
    public bool get_ShowCategory();
    public void set_ShowCategory(bool value);
    public bool get_ShowSeriesName();
    public void set_ShowSeriesName(bool value);
    public bool get_ShowPercent();
    public void set_ShowPercent(bool value);
    public bool get_ShowLeaderLines();
    public void set_ShowLeaderLines(bool value);
    public bool get_ShowBubbleSize();
    public void set_ShowBubbleSize(bool value);
    public bool get_ShowLegendKey();
    public void set_ShowLegendKey(bool value);
    public string get_Separator();
    public void set_Separator(string value);
    public ExcelDrawingFill get_Fill();
    public ExcelDrawingBorder get_Border();
    public ExcelTextFont get_Font();
    protected string GetPosText(eLabelPosition pos);
    protected eLabelPosition GetPosEnum(string pos);
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartLegend : XmlHelper {
    private ExcelChart _chart;
    private static string POSITION_PATH;
    private static string OVERLAY_PATH;
    private ExcelDrawingFill _fill;
    private ExcelDrawingBorder _border;
    private ExcelTextFont _font;
    public eLegendPosition Position { get; public set; }
    public bool Overlay { get; public set; }
    public ExcelDrawingFill Fill { get; }
    public ExcelDrawingBorder Border { get; }
    public ExcelTextFont Font { get; }
    internal ExcelChartLegend(XmlNamespaceManager ns, XmlNode node, ExcelChart chart);
    public eLegendPosition get_Position();
    public void set_Position(eLegendPosition value);
    public bool get_Overlay();
    public void set_Overlay(bool value);
    public ExcelDrawingFill get_Fill();
    public ExcelDrawingBorder get_Border();
    public ExcelTextFont get_Font();
    public void Remove();
    public void Add();
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartPlotArea : XmlHelper {
    private ExcelChart _firstChart;
    private ExcelChartCollection _chartTypes;
    private ExcelDrawingFill _fill;
    private ExcelDrawingBorder _border;
    public ExcelChartCollection ChartTypes { get; }
    public ExcelDrawingFill Fill { get; }
    public ExcelDrawingBorder Border { get; }
    internal ExcelChartPlotArea(XmlNamespaceManager ns, XmlNode node, ExcelChart firstChart);
    public ExcelChartCollection get_ChartTypes();
    public ExcelDrawingFill get_Fill();
    public ExcelDrawingBorder get_Border();
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartSerie : XmlHelper {
    internal ExcelChartSeries _chartSeries;
    protected XmlNode _node;
    protected XmlNamespaceManager _ns;
    private static string headerPath;
    private static string headerAddressPath;
    private string _seriesTopPath;
    private string _seriesPath;
    private string _xSeriesTopPath;
    private string _xSeriesPath;
    private ExcelChartTrendlineCollection _trendLines;
    private ExcelDrawingFill _fill;
    private ExcelDrawingBorder _border;
    public string Header { get; public set; }
    public ExcelAddressBase HeaderAddress { get; public set; }
    public string Series { get; public set; }
    public string XSeries { get; public set; }
    public ExcelChartTrendlineCollection TrendLines { get; }
    public ExcelDrawingFill Fill { get; }
    public ExcelDrawingBorder Border { get; }
    internal ExcelChartSerie(ExcelChartSeries chartSeries, XmlNamespaceManager ns, XmlNode node, bool isPivot);
    internal void SetID(string id);
    public string get_Header();
    public void set_Header(string value);
    private void Cleartx();
    public ExcelAddressBase get_HeaderAddress();
    public void set_HeaderAddress(ExcelAddressBase value);
    public virtual string get_Series();
    public virtual void set_Series(string value);
    public virtual string get_XSeries();
    public virtual void set_XSeries(string value);
    public ExcelChartTrendlineCollection get_TrendLines();
    public ExcelDrawingFill get_Fill();
    public ExcelDrawingBorder get_Border();
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartSerieDataLabel : ExcelChartDataLabel {
    private static string positionPath;
    private ExcelDrawingFill _fill;
    private ExcelDrawingBorder _border;
    private ExcelTextFont _font;
    public eLabelPosition Position { get; public set; }
    public ExcelDrawingFill Fill { get; }
    public ExcelDrawingBorder Border { get; }
    public ExcelTextFont Font { get; }
    internal ExcelChartSerieDataLabel(XmlNamespaceManager ns, XmlNode node);
    public eLabelPosition get_Position();
    public void set_Position(eLabelPosition value);
    public ExcelDrawingFill get_Fill();
    public ExcelDrawingBorder get_Border();
    public ExcelTextFont get_Font();
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Drawing.Chart.ExcelChartSeries : XmlHelper {
    private List`1<ExcelChartSerie> _list;
    internal ExcelChart _chart;
    private XmlNode _node;
    private XmlNamespaceManager _ns;
    private bool _isPivot;
    public ExcelChartSerie Item { get; }
    public int Count { get; }
    public ExcelChart Chart { get; }
    internal ExcelChartSeries(ExcelChart chart, XmlNamespaceManager ns, XmlNode node, bool isPivot);
    public sealed virtual IEnumerator GetEnumerator();
    public ExcelChartSerie get_Item(int PositionID);
    public int get_Count();
    public void Delete(int PositionID);
    public ExcelChart get_Chart();
    public virtual ExcelChartSerie Add(ExcelRangeBase Serie, ExcelRangeBase XSerie);
    public virtual ExcelChartSerie Add(string SerieAddress, string XSerieAddress);
    protected internal ExcelChartSerie AddSeries(string SeriesAddress, string XSeriesAddress, string bubbleSizeAddress);
    internal void AddPivotSerie(ExcelPivotTable pivotTableSource);
    private int FindIndex();
    private string AddMarker(eChartType chartType);
    private string AddScatterPoint(eChartType chartType);
    private string AddAxisNodes(eChartType chartType);
    private string AddExplosion(eChartType chartType);
    private string AddSmooth(eChartType chartType);
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartSurface : XmlHelper {
    private static string THICKNESS_PATH;
    private ExcelDrawingFill _fill;
    private ExcelDrawingBorder _border;
    public int Thickness { get; public set; }
    public ExcelDrawingFill Fill { get; }
    public ExcelDrawingBorder Border { get; }
    internal ExcelChartSurface(XmlNamespaceManager ns, XmlNode node);
    public int get_Thickness();
    public void set_Thickness(int value);
    public ExcelDrawingFill get_Fill();
    public ExcelDrawingBorder get_Border();
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartTitle : XmlHelper {
    private static string titlePath;
    private ExcelDrawingBorder _border;
    private ExcelDrawingFill _fill;
    private String[] paragraphNodeOrder;
    private ExcelParagraphCollection _richText;
    private static string TextVerticalPath;
    public string Text { get; public set; }
    public ExcelDrawingBorder Border { get; }
    public ExcelDrawingFill Fill { get; }
    public ExcelTextFont Font { get; }
    public ExcelParagraphCollection RichText { get; }
    public bool Overlay { get; public set; }
    public bool AnchorCtr { get; public set; }
    public eTextAnchoringType Anchor { get; public set; }
    public eTextVerticalType TextVertical { get; public set; }
    public double Rotation { get; public set; }
    internal ExcelChartTitle(XmlNamespaceManager nameSpaceManager, XmlNode node);
    public string get_Text();
    public void set_Text(string value);
    public ExcelDrawingBorder get_Border();
    public ExcelDrawingFill get_Fill();
    public ExcelTextFont get_Font();
    public ExcelParagraphCollection get_RichText();
    public bool get_Overlay();
    public void set_Overlay(bool value);
    public bool get_AnchorCtr();
    public void set_AnchorCtr(bool value);
    public eTextAnchoringType get_Anchor();
    public void set_Anchor(eTextAnchoringType value);
    public eTextVerticalType get_TextVertical();
    public void set_TextVertical(eTextVerticalType value);
    public double get_Rotation();
    public void set_Rotation(double value);
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartTrendline : XmlHelper {
    private static string TRENDLINEPATH;
    private static string NAMEPATH;
    private static string ORDERPATH;
    private static string PERIODPATH;
    private static string FORWARDPATH;
    private static string BACKWARDPATH;
    private static string INTERCEPTPATH;
    private static string DISPLAYRSQUAREDVALUEPATH;
    private static string DISPLAYEQUATIONPATH;
    public eTrendLine Type { get; public set; }
    public string Name { get; public set; }
    public decimal Order { get; public set; }
    public decimal Period { get; public set; }
    public decimal Forward { get; public set; }
    public decimal Backward { get; public set; }
    public decimal Intercept { get; public set; }
    public bool DisplayRSquaredValue { get; public set; }
    public bool DisplayEquation { get; public set; }
    internal ExcelChartTrendline(XmlNamespaceManager namespaceManager, XmlNode topNode);
    public eTrendLine get_Type();
    public void set_Type(eTrendLine value);
    public string get_Name();
    public void set_Name(string value);
    public decimal get_Order();
    public void set_Order(decimal value);
    public decimal get_Period();
    public void set_Period(decimal value);
    public decimal get_Forward();
    public void set_Forward(decimal value);
    public decimal get_Backward();
    public void set_Backward(decimal value);
    public decimal get_Intercept();
    public void set_Intercept(decimal value);
    public bool get_DisplayRSquaredValue();
    public void set_DisplayRSquaredValue(bool value);
    public bool get_DisplayEquation();
    public void set_DisplayEquation(bool value);
}
public class OfficeOpenXml.Drawing.Chart.ExcelChartTrendlineCollection : object {
    private List`1<ExcelChartTrendline> _list;
    private ExcelChartSerie _serie;
    internal ExcelChartTrendlineCollection(ExcelChartSerie serie);
    public ExcelChartTrendline Add(eTrendLine Type);
    private sealed virtual override IEnumerator`1<ExcelChartTrendline> System.Collections.Generic.IEnumerable<OfficeOpenXml.Drawing.Chart.ExcelChartTrendline>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class OfficeOpenXml.Drawing.Chart.ExcelDoughnutChart : ExcelPieChart {
    private string _firstSliceAngPath;
    private string _holeSizePath;
    public decimal FirstSliceAngle { get; internal set; }
    public decimal HoleSize { get; internal set; }
    internal ExcelDoughnutChart(ExcelDrawings drawings, XmlNode node, eChartType type, bool isPivot);
    internal ExcelDoughnutChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    internal ExcelDoughnutChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    internal ExcelDoughnutChart(ExcelChart topChart, XmlNode chartNode);
    public decimal get_FirstSliceAngle();
    internal void set_FirstSliceAngle(decimal value);
    public decimal get_HoleSize();
    internal void set_HoleSize(decimal value);
    internal virtual eChartType GetChartType(string name);
}
public class OfficeOpenXml.Drawing.Chart.ExcelLineChart : ExcelChart {
    private string MARKER_PATH;
    private string SMOOTH_PATH;
    private ExcelChartDataLabel _DataLabel;
    public bool Marker { get; public set; }
    public bool Smooth { get; public set; }
    public ExcelChartDataLabel DataLabel { get; }
    internal ExcelLineChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    internal ExcelLineChart(ExcelChart topChart, XmlNode chartNode);
    internal ExcelLineChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    public bool get_Marker();
    public void set_Marker(bool value);
    public bool get_Smooth();
    public void set_Smooth(bool value);
    public ExcelChartDataLabel get_DataLabel();
    internal virtual eChartType GetChartType(string name);
}
public class OfficeOpenXml.Drawing.Chart.ExcelLineChartSerie : ExcelChartSerie {
    private ExcelChartSerieDataLabel _DataLabel;
    private static string markerPath;
    private static string smoothPath;
    private string LINECOLOR_PATH;
    private string MARKERSIZE_PATH;
    private string LINEWIDTH_PATH;
    private string MARKERLINECOLOR_PATH;
    public ExcelChartSerieDataLabel DataLabel { get; }
    public eMarkerStyle Marker { get; public set; }
    public bool Smooth { get; public set; }
    public Color LineColor { get; public set; }
    public int MarkerSize { get; public set; }
    public double LineWidth { get; public set; }
    public Color MarkerLineColor { get; public set; }
    internal ExcelLineChartSerie(ExcelChartSeries chartSeries, XmlNamespaceManager ns, XmlNode node, bool isPivot);
    public ExcelChartSerieDataLabel get_DataLabel();
    public eMarkerStyle get_Marker();
    public void set_Marker(eMarkerStyle value);
    public bool get_Smooth();
    public void set_Smooth(bool value);
    public Color get_LineColor();
    public void set_LineColor(Color value);
    public int get_MarkerSize();
    public void set_MarkerSize(int value);
    public double get_LineWidth();
    public void set_LineWidth(double value);
    public Color get_MarkerLineColor();
    public void set_MarkerLineColor(Color value);
}
public class OfficeOpenXml.Drawing.Chart.ExcelOfPieChart : ExcelPieChart {
    private static string pieTypePath;
    private string _gapWidthPath;
    public ePieType OfPieType { get; internal set; }
    public int GapWidth { get; public set; }
    internal ExcelOfPieChart(ExcelDrawings drawings, XmlNode node, eChartType type, bool isPivot);
    internal ExcelOfPieChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    internal ExcelOfPieChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    private void SetTypeProperties();
    public ePieType get_OfPieType();
    internal void set_OfPieType(ePieType value);
    public int get_GapWidth();
    public void set_GapWidth(int value);
    internal virtual eChartType GetChartType(string name);
}
public class OfficeOpenXml.Drawing.Chart.ExcelPieChart : ExcelChart {
    private ExcelChartDataLabel _DataLabel;
    public ExcelChartDataLabel DataLabel { get; }
    internal ExcelPieChart(ExcelDrawings drawings, XmlNode node, eChartType type, bool isPivot);
    internal ExcelPieChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    internal ExcelPieChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    internal ExcelPieChart(ExcelChart topChart, XmlNode chartNode);
    public ExcelChartDataLabel get_DataLabel();
    internal virtual eChartType GetChartType(string name);
}
public class OfficeOpenXml.Drawing.Chart.ExcelPieChartSerie : ExcelChartSerie {
    private static string explosionPath;
    private ExcelChartSerieDataLabel _DataLabel;
    public int Explosion { get; public set; }
    public ExcelChartSerieDataLabel DataLabel { get; }
    internal ExcelPieChartSerie(ExcelChartSeries chartSeries, XmlNamespaceManager ns, XmlNode node, bool isPivot);
    public int get_Explosion();
    public void set_Explosion(int value);
    public ExcelChartSerieDataLabel get_DataLabel();
}
public class OfficeOpenXml.Drawing.Chart.ExcelRadarChart : ExcelChart {
    private string STYLE_PATH;
    private ExcelChartDataLabel _DataLabel;
    public eRadarStyle RadarStyle { get; public set; }
    public ExcelChartDataLabel DataLabel { get; }
    internal ExcelRadarChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    internal ExcelRadarChart(ExcelChart topChart, XmlNode chartNode);
    internal ExcelRadarChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    private void SetTypeProperties();
    public eRadarStyle get_RadarStyle();
    public void set_RadarStyle(eRadarStyle value);
    public ExcelChartDataLabel get_DataLabel();
    internal virtual eChartType GetChartType(string name);
}
public class OfficeOpenXml.Drawing.Chart.ExcelRadarChartSerie : ExcelChartSerie {
    private ExcelChartSerieDataLabel _DataLabel;
    private static string markerPath;
    private static string MARKERSIZE_PATH;
    public ExcelChartSerieDataLabel DataLabel { get; }
    public eMarkerStyle Marker { get; internal set; }
    public int MarkerSize { get; public set; }
    internal ExcelRadarChartSerie(ExcelChartSeries chartSeries, XmlNamespaceManager ns, XmlNode node, bool isPivot);
    public ExcelChartSerieDataLabel get_DataLabel();
    public eMarkerStyle get_Marker();
    internal void set_Marker(eMarkerStyle value);
    public int get_MarkerSize();
    public void set_MarkerSize(int value);
}
public class OfficeOpenXml.Drawing.Chart.ExcelScatterChart : ExcelChart {
    private string _scatterTypePath;
    private string MARKER_PATH;
    public eScatterStyle ScatterStyle { get; internal set; }
    public bool Marker { get; public set; }
    internal ExcelScatterChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    internal ExcelScatterChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    internal ExcelScatterChart(ExcelChart topChart, XmlNode chartNode);
    private void SetTypeProperties();
    private eScatterStyle GetScatterEnum(string text);
    private string GetScatterText(eScatterStyle shatterStyle);
    public eScatterStyle get_ScatterStyle();
    internal void set_ScatterStyle(eScatterStyle value);
    public bool get_Marker();
    public void set_Marker(bool value);
    internal virtual eChartType GetChartType(string name);
}
public class OfficeOpenXml.Drawing.Chart.ExcelScatterChartSerie : ExcelChartSerie {
    private ExcelChartSerieDataLabel _DataLabel;
    private static string smoothPath;
    private static string markerPath;
    private string LINECOLOR_PATH;
    private string MARKERSIZE_PATH;
    private string MARKERCOLOR_PATH;
    private string LINEWIDTH_PATH;
    private string MARKERLINECOLOR_PATH;
    public ExcelChartSerieDataLabel DataLabel { get; }
    public int Smooth { get; internal set; }
    public eMarkerStyle Marker { get; public set; }
    public Color LineColor { get; public set; }
    public int MarkerSize { get; public set; }
    public Color MarkerColor { get; public set; }
    public double LineWidth { get; public set; }
    public Color MarkerLineColor { get; public set; }
    internal ExcelScatterChartSerie(ExcelChartSeries chartSeries, XmlNamespaceManager ns, XmlNode node, bool isPivot);
    public ExcelChartSerieDataLabel get_DataLabel();
    public int get_Smooth();
    internal void set_Smooth(int value);
    public eMarkerStyle get_Marker();
    public void set_Marker(eMarkerStyle value);
    public Color get_LineColor();
    public void set_LineColor(Color value);
    public int get_MarkerSize();
    public void set_MarkerSize(int value);
    public Color get_MarkerColor();
    public void set_MarkerColor(Color value);
    public double get_LineWidth();
    public void set_LineWidth(double value);
    public Color get_MarkerLineColor();
    public void set_MarkerLineColor(Color value);
    private void setAlphaChannel(Color c, string xPath);
    private int getAlphaChannel(string xPath);
    private string xPath4Alpha(string xPath);
}
public class OfficeOpenXml.Drawing.Chart.ExcelSurfaceChart : ExcelChart {
    private ExcelChartSurface _floor;
    private ExcelChartSurface _sideWall;
    private ExcelChartSurface _backWall;
    private static string WIREFRAME_PATH;
    public ExcelChartSurface Floor { get; }
    public ExcelChartSurface SideWall { get; }
    public ExcelChartSurface BackWall { get; }
    public bool Wireframe { get; public set; }
    internal ExcelSurfaceChart(ExcelDrawings drawings, XmlNode node, eChartType type, ExcelChart topChart, ExcelPivotTable PivotTableSource);
    internal ExcelSurfaceChart(ExcelDrawings drawings, XmlNode node, Uri uriChart, ZipPackagePart part, XmlDocument chartXml, XmlNode chartNode);
    internal ExcelSurfaceChart(ExcelChart topChart, XmlNode chartNode);
    private void Init();
    public ExcelChartSurface get_Floor();
    public ExcelChartSurface get_SideWall();
    public ExcelChartSurface get_BackWall();
    public bool get_Wireframe();
    public void set_Wireframe(bool value);
    internal void SetTypeProperties();
    internal virtual eChartType GetChartType(string name);
}
public class OfficeOpenXml.Drawing.Chart.ExcelSurfaceChartSerie : ExcelChartSerie {
    internal ExcelSurfaceChartSerie(ExcelChartSeries chartSeries, XmlNamespaceManager ns, XmlNode node, bool isPivot);
}
public enum OfficeOpenXml.Drawing.Chart.eYAxisPosition : Enum {
    public int value__;
    public static eYAxisPosition Left;
    public static eYAxisPosition Right;
}
public enum OfficeOpenXml.Drawing.eEditAs : Enum {
    public int value__;
    public static eEditAs Absolute;
    public static eEditAs OneCell;
    public static eEditAs TwoCell;
}
public enum OfficeOpenXml.Drawing.eLineCap : Enum {
    public int value__;
    public static eLineCap Flat;
    public static eLineCap Round;
    public static eLineCap Square;
}
public enum OfficeOpenXml.Drawing.eLineStyle : Enum {
    public int value__;
    public static eLineStyle Dash;
    public static eLineStyle DashDot;
    public static eLineStyle Dot;
    public static eLineStyle LongDash;
    public static eLineStyle LongDashDot;
    public static eLineStyle LongDashDotDot;
    public static eLineStyle Solid;
    public static eLineStyle SystemDash;
    public static eLineStyle SystemDashDot;
    public static eLineStyle SystemDashDotDot;
    public static eLineStyle SystemDot;
}
public enum OfficeOpenXml.Drawing.eTextAnchoringType : Enum {
    public int value__;
    public static eTextAnchoringType Bottom;
    public static eTextAnchoringType Center;
    public static eTextAnchoringType Distributed;
    public static eTextAnchoringType Justify;
    public static eTextAnchoringType Top;
}
public enum OfficeOpenXml.Drawing.eTextVerticalType : Enum {
    public int value__;
    public static eTextVerticalType EastAsianVertical;
    public static eTextVerticalType Horizontal;
    public static eTextVerticalType MongolianVertical;
    public static eTextVerticalType Vertical;
    public static eTextVerticalType Vertical270;
    public static eTextVerticalType WordArtVertical;
    public static eTextVerticalType WordArtVerticalRightToLeft;
}
public class OfficeOpenXml.Drawing.ExcelDrawing : XmlHelper {
    protected ExcelDrawings _drawings;
    protected XmlNode _topNode;
    private string _nameXPath;
    protected internal int _id;
    private static float STANDARD_DPI;
    public static int EMU_PER_PIXEL;
    protected internal int _width;
    protected internal int _height;
    protected internal int _top;
    protected internal int _left;
    private bool _doNotAdjust;
    private static string lockedPath;
    private static string printPath;
    [CompilerGeneratedAttribute]
private ExcelPosition <From>k__BackingField;
    private ExcelPosition _to;
    public string Name { get; public set; }
    public eEditAs EditAs { get; public set; }
    public bool Locked { get; public set; }
    public bool Print { get; public set; }
    public ExcelPosition From { get; private set; }
    public ExcelPosition To { get; private set; }
    internal string Id { get; }
    internal ExcelDrawing(ExcelDrawings drawings, XmlNode node, string nameXPath);
    public string get_Name();
    public void set_Name(string value);
    public eEditAs get_EditAs();
    public void set_EditAs(eEditAs value);
    public bool get_Locked();
    public void set_Locked(bool value);
    public bool get_Print();
    public void set_Print(bool value);
    [CompilerGeneratedAttribute]
public ExcelPosition get_From();
    [CompilerGeneratedAttribute]
private void set_From(ExcelPosition value);
    public ExcelPosition get_To();
    private void set_To(ExcelPosition value);
    internal void ReSetWidthHeight();
    internal static ExcelDrawing GetDrawing(ExcelDrawings drawings, XmlNode node);
    internal string get_Id();
    internal static string GetTextAchoringText(eTextAnchoringType value);
    internal static eTextAnchoringType GetTextAchoringEnum(string text);
    internal static string GetTextVerticalText(eTextVerticalType value);
    internal static eTextVerticalType GetTextVerticalEnum(string text);
    internal int GetPixelLeft();
    internal int GetPixelTop();
    internal int GetPixelWidth();
    internal int GetPixelHeight();
    private decimal GetColumnWidth(int col);
    private double GetRowHeight(int row);
    private double GetRowHeightFromCellFonts(int row, ExcelWorksheet ws);
    internal void SetPixelTop(int pixels);
    internal void SetPixelLeft(int pixels);
    internal void SetPixelHeight(int pixels);
    internal void SetPixelHeight(int pixels, float dpi);
    internal void SetPixelWidth(int pixels);
    internal void SetPixelWidth(int pixels, float dpi);
    public void SetPosition(int PixelTop, int PixelLeft);
    public void SetPosition(int Row, int RowOffsetPixels, int Column, int ColumnOffsetPixels);
    public virtual void SetSize(int Percent);
    public void SetSize(int PixelWidth, int PixelHeight);
    internal virtual void DeleteMe();
    public virtual void Dispose();
    internal void GetPositionSize();
    public void AdjustPositionAndSize();
}
public class OfficeOpenXml.Drawing.ExcelDrawingBorder : XmlHelper {
    private string _linePath;
    private ExcelDrawingFill _fill;
    private string _lineStylePath;
    private string _lineCapPath;
    private string _lineWidth;
    public ExcelDrawingFill Fill { get; }
    public eLineStyle LineStyle { get; public set; }
    public eLineCap LineCap { get; public set; }
    public int Width { get; public set; }
    internal ExcelDrawingBorder(XmlNamespaceManager nameSpaceManager, XmlNode topNode, string linePath);
    public ExcelDrawingFill get_Fill();
    public eLineStyle get_LineStyle();
    public void set_LineStyle(eLineStyle value);
    public eLineCap get_LineCap();
    public void set_LineCap(eLineCap value);
    public int get_Width();
    public void set_Width(int value);
    private string TranslateLineStyleText(eLineStyle value);
    private eLineStyle TranslateLineStyle(string text);
    private string TranslateLineCapText(eLineCap value);
    private eLineCap TranslateLineCap(string text);
}
public class OfficeOpenXml.Drawing.ExcelDrawingFill : XmlHelper {
    private string _fillPath;
    private XmlNode _fillNode;
    private eFillStyle _style;
    private XmlNode _fillTypeNode;
    private static string ColorPath;
    private static string alphaPath;
    public eFillStyle Style { get; public set; }
    public Color Color { get; public set; }
    public int Transparancy { get; public set; }
    internal ExcelDrawingFill(XmlNamespaceManager nameSpaceManager, XmlNode topNode, string fillPath);
    public eFillStyle get_Style();
    public void set_Style(eFillStyle value);
    private void CreateFillTopNode(eFillStyle value);
    private eFillStyle GetStyleEnum(string name);
    private string GetStyleText(eFillStyle style);
    public Color get_Color();
    public void set_Color(Color value);
    public int get_Transparancy();
    public void set_Transparancy(int value);
}
public class OfficeOpenXml.Drawing.ExcelDrawingLineEnd : XmlHelper {
    private string _linePath;
    private string _headEndStylePath;
    private string _tailEndStylePath;
    private string _tailEndSizeWidthPath;
    private string _tailEndSizeHeightPath;
    private string _headEndSizeWidthPath;
    private string _headEndSizeHeightPath;
    public eEndStyle HeadEnd { get; public set; }
    public eEndStyle TailEnd { get; public set; }
    public eEndSize TailEndSizeWidth { get; public set; }
    public eEndSize TailEndSizeHeight { get; public set; }
    public eEndSize HeadEndSizeWidth { get; public set; }
    public eEndSize HeadEndSizeHeight { get; public set; }
    internal ExcelDrawingLineEnd(XmlNamespaceManager nameSpaceManager, XmlNode topNode, string linePath);
    public eEndStyle get_HeadEnd();
    public void set_HeadEnd(eEndStyle value);
    public eEndStyle get_TailEnd();
    public void set_TailEnd(eEndStyle value);
    public eEndSize get_TailEndSizeWidth();
    public void set_TailEndSizeWidth(eEndSize value);
    public eEndSize get_TailEndSizeHeight();
    public void set_TailEndSizeHeight(eEndSize value);
    public eEndSize get_HeadEndSizeWidth();
    public void set_HeadEndSizeWidth(eEndSize value);
    public eEndSize get_HeadEndSizeHeight();
    public void set_HeadEndSizeHeight(eEndSize value);
    private string TranslateEndStyleText(eEndStyle value);
    private eEndStyle TranslateEndStyle(string text);
    private string TranslateEndSizeText(eEndSize value);
    private eEndSize TranslateEndSize(string text);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Drawing.ExcelDrawings : object {
    private XmlDocument _drawingsXml;
    private Dictionary`2<string, int> _drawingNames;
    private List`1<ExcelDrawing> _drawings;
    internal Dictionary`2<string, string> _hashes;
    internal ExcelPackage _package;
    internal ZipPackageRelationship _drawingRelation;
    [CompilerGeneratedAttribute]
private ExcelWorksheet <Worksheet>k__BackingField;
    private XmlNamespaceManager _nsManager;
    private ZipPackagePart _part;
    private Uri _uriDrawing;
    internal ExcelWorksheet Worksheet { get; internal set; }
    public XmlDocument DrawingXml { get; }
    public XmlNamespaceManager NameSpaceManager { get; }
    public ExcelDrawing Item { get; }
    public ExcelDrawing Item { get; }
    public int Count { get; }
    internal ZipPackagePart Part { get; }
    public Uri UriDrawing { get; }
    internal ExcelDrawings(ExcelPackage xlPackage, ExcelWorksheet sheet);
    [CompilerGeneratedAttribute]
internal ExcelWorksheet get_Worksheet();
    [CompilerGeneratedAttribute]
internal void set_Worksheet(ExcelWorksheet value);
    public XmlDocument get_DrawingXml();
    private void AddDrawings();
    private void CreateNSM();
    public XmlNamespaceManager get_NameSpaceManager();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ExcelDrawing> System.Collections.Generic.IEnumerable<OfficeOpenXml.Drawing.ExcelDrawing>.GetEnumerator();
    public ExcelDrawing get_Item(int PositionID);
    public ExcelDrawing get_Item(string Name);
    public int get_Count();
    internal ZipPackagePart get_Part();
    public Uri get_UriDrawing();
    public ExcelChart AddChart(string Name, eChartType ChartType, ExcelPivotTable PivotTableSource);
    public ExcelChart AddChart(string Name, eChartType ChartType);
    public ExcelPicture AddPicture(string Name, Image image);
    public ExcelPicture AddPicture(string Name, Image image, Uri Hyperlink);
    public ExcelPicture AddPicture(string Name, FileInfo ImageFile);
    public ExcelPicture AddPicture(string Name, FileInfo ImageFile, Uri Hyperlink);
    public ExcelShape AddShape(string Name, eShapeStyle Style);
    public ExcelShape AddShape(string Name, ExcelShape Source);
    private XmlElement CreateDrawingXml();
    public void Remove(int Index);
    internal void RemoveDrawing(int Index);
    public void Remove(ExcelDrawing Drawing);
    public void Remove(string Name);
    public void Clear();
    internal void ClearDrawings();
    internal void AdjustWidth(Int32[0...,0...] pos);
    internal void AdjustHeight(Int32[0...,0...] pos);
    internal Int32[0...,0...] GetDrawingWidths();
    internal Int32[0...,0...] GetDrawingHeight();
    public sealed virtual void Dispose();
}
public class OfficeOpenXml.Drawing.ExcelPicture : ExcelDrawing {
    [CompilerGeneratedAttribute]
private string <ImageHash>k__BackingField;
    private Image _image;
    private ImageFormat _imageFormat;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <UriPic>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackageRelationship <RelPic>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackageRelationship <HypRel>k__BackingField;
    internal ZipPackagePart Part;
    private ExcelDrawingFill _fill;
    private ExcelDrawingBorder _border;
    private Uri _hyperlink;
    internal string ImageHash { get; internal set; }
    public Image Image { get; public set; }
    public ImageFormat ImageFormat { get; internal set; }
    internal string ContentType { get; internal set; }
    internal Uri UriPic { get; internal set; }
    internal ZipPackageRelationship RelPic { get; internal set; }
    internal ZipPackageRelationship HypRel { get; internal set; }
    internal string Id { get; }
    public ExcelDrawingFill Fill { get; }
    public ExcelDrawingBorder Border { get; }
    public Uri Hyperlink { get; }
    internal ExcelPicture(ExcelDrawings drawings, XmlNode node);
    internal ExcelPicture(ExcelDrawings drawings, XmlNode node, Image image, Uri hyperlink);
    internal ExcelPicture(ExcelDrawings drawings, XmlNode node, FileInfo imageFile, Uri hyperlink);
    internal static string GetContentType(string extension);
    internal static ImageFormat GetImageFormat(string contentType);
    private void AddNewPicture(Byte[] img, string relID);
    private string SavePicture(Image image);
    private void SetPosDefaults(Image image);
    private string PicStartXml();
    [CompilerGeneratedAttribute]
internal string get_ImageHash();
    [CompilerGeneratedAttribute]
internal void set_ImageHash(string value);
    public Image get_Image();
    public void set_Image(Image value);
    public ImageFormat get_ImageFormat();
    internal void set_ImageFormat(ImageFormat value);
    [CompilerGeneratedAttribute]
internal string get_ContentType();
    [CompilerGeneratedAttribute]
internal void set_ContentType(string value);
    public virtual void SetSize(int Percent);
    [CompilerGeneratedAttribute]
internal Uri get_UriPic();
    [CompilerGeneratedAttribute]
internal void set_UriPic(Uri value);
    [CompilerGeneratedAttribute]
internal ZipPackageRelationship get_RelPic();
    [CompilerGeneratedAttribute]
internal void set_RelPic(ZipPackageRelationship value);
    [CompilerGeneratedAttribute]
internal ZipPackageRelationship get_HypRel();
    [CompilerGeneratedAttribute]
internal void set_HypRel(ZipPackageRelationship value);
    internal string get_Id();
    public ExcelDrawingFill get_Fill();
    public ExcelDrawingBorder get_Border();
    public Uri get_Hyperlink();
    internal virtual void DeleteMe();
    public virtual void Dispose();
}
public class OfficeOpenXml.Drawing.ExcelShape : ExcelDrawing {
    private static string ShapeStylePath;
    private ExcelDrawingFill _fill;
    private ExcelDrawingBorder _border;
    private ExcelDrawingLineEnd _ends;
    private String[] paragraphNodeOrder;
    private static string PARAGRAPH_PATH;
    private ExcelTextFont _font;
    private static string TextPath;
    private string lockTextPath;
    private ExcelParagraphCollection _richText;
    private static string TextAnchoringPath;
    private static string TextAnchoringCtlPath;
    private static string TEXT_ALIGN_PATH;
    private static string INDENT_ALIGN_PATH;
    private static string TextVerticalPath;
    public eShapeStyle Style { get; public set; }
    public ExcelDrawingFill Fill { get; }
    public ExcelDrawingBorder Border { get; }
    public ExcelDrawingLineEnd LineEnds { get; }
    public ExcelTextFont Font { get; }
    public string Text { get; public set; }
    public bool LockText { get; public set; }
    public ExcelParagraphCollection RichText { get; }
    public eTextAnchoringType TextAnchoring { get; public set; }
    public bool TextAnchoringControl { get; public set; }
    public eTextAlignment TextAlignment { get; public set; }
    public int Indent { get; public set; }
    public eTextVerticalType TextVertical { get; public set; }
    internal string Id { get; }
    internal ExcelShape(ExcelDrawings drawings, XmlNode node);
    internal ExcelShape(ExcelDrawings drawings, XmlNode node, eShapeStyle style);
    private void init();
    public eShapeStyle get_Style();
    public void set_Style(eShapeStyle value);
    public ExcelDrawingFill get_Fill();
    public ExcelDrawingBorder get_Border();
    public ExcelDrawingLineEnd get_LineEnds();
    public ExcelTextFont get_Font();
    public string get_Text();
    public void set_Text(string value);
    public bool get_LockText();
    public void set_LockText(bool value);
    public ExcelParagraphCollection get_RichText();
    public eTextAnchoringType get_TextAnchoring();
    public void set_TextAnchoring(eTextAnchoringType value);
    public bool get_TextAnchoringControl();
    public void set_TextAnchoringControl(bool value);
    public eTextAlignment get_TextAlignment();
    public void set_TextAlignment(eTextAlignment value);
    public int get_Indent();
    public void set_Indent(int value);
    public eTextVerticalType get_TextVertical();
    public void set_TextVertical(eTextVerticalType value);
    private string ShapeStartXml();
    internal string get_Id();
}
public class OfficeOpenXml.Drawing.ExcelView3D : XmlHelper {
    private static string perspectivePath;
    private static string rotXPath;
    private static string rotYPath;
    private static string rAngAxPath;
    private static string depthPercentPath;
    private static string heightPercentPath;
    public decimal Perspective { get; public set; }
    public decimal RotX { get; public set; }
    public decimal RotY { get; public set; }
    public bool RightAngleAxes { get; public set; }
    public int DepthPercent { get; public set; }
    public int HeightPercent { get; public set; }
    internal ExcelView3D(XmlNamespaceManager ns, XmlNode node);
    public decimal get_Perspective();
    public void set_Perspective(decimal value);
    public decimal get_RotX();
    public void set_RotX(decimal value);
    public decimal get_RotY();
    public void set_RotY(decimal value);
    public bool get_RightAngleAxes();
    public void set_RightAngleAxes(bool value);
    public int get_DepthPercent();
    public void set_DepthPercent(int value);
    public int get_HeightPercent();
    public void set_HeightPercent(int value);
}
public enum OfficeOpenXml.Drawing.Vml.eLineStyleVml : Enum {
    public int value__;
    public static eLineStyleVml Solid;
    public static eLineStyleVml Round;
    public static eLineStyleVml Square;
    public static eLineStyleVml Dash;
    public static eLineStyleVml DashDot;
    public static eLineStyleVml LongDash;
    public static eLineStyleVml LongDashDot;
    public static eLineStyleVml LongDashDotDot;
}
public enum OfficeOpenXml.Drawing.Vml.eTextAlignHorizontalVml : Enum {
    public int value__;
    public static eTextAlignHorizontalVml Left;
    public static eTextAlignHorizontalVml Center;
    public static eTextAlignHorizontalVml Right;
}
public enum OfficeOpenXml.Drawing.Vml.eTextAlignVerticalVml : Enum {
    public int value__;
    public static eTextAlignVerticalVml Top;
    public static eTextAlignVerticalVml Center;
    public static eTextAlignVerticalVml Bottom;
}
public class OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingBase : XmlHelper {
    public string Id { get; public set; }
    public string AlternativeText { get; public set; }
    internal ExcelVmlDrawingBase(XmlNode topNode, XmlNamespaceManager ns);
    public string get_Id();
    public void set_Id(string value);
    public string get_AlternativeText();
    public void set_AlternativeText(string value);
    protected bool GetStyle(string style, string key, String& value);
    protected string SetStyle(string style, string key, string value);
}
public class OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingBaseCollection : object {
    [CompilerGeneratedAttribute]
private XmlDocument <VmlDrawingXml>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelId>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackagePart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlNamespaceManager <NameSpaceManager>k__BackingField;
    internal XmlDocument VmlDrawingXml { get; internal set; }
    internal Uri Uri { get; internal set; }
    internal string RelId { get; internal set; }
    internal ZipPackagePart Part { get; internal set; }
    internal XmlNamespaceManager NameSpaceManager { get; internal set; }
    internal ExcelVmlDrawingBaseCollection(ExcelPackage pck, ExcelWorksheet ws, Uri uri);
    [CompilerGeneratedAttribute]
internal XmlDocument get_VmlDrawingXml();
    [CompilerGeneratedAttribute]
internal void set_VmlDrawingXml(XmlDocument value);
    [CompilerGeneratedAttribute]
internal Uri get_Uri();
    [CompilerGeneratedAttribute]
internal void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
internal string get_RelId();
    [CompilerGeneratedAttribute]
internal void set_RelId(string value);
    [CompilerGeneratedAttribute]
internal ZipPackagePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(ZipPackagePart value);
    [CompilerGeneratedAttribute]
internal XmlNamespaceManager get_NameSpaceManager();
    [CompilerGeneratedAttribute]
internal void set_NameSpaceManager(XmlNamespaceManager value);
}
public class OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingComment : ExcelVmlDrawingBase {
    [CompilerGeneratedAttribute]
private ExcelRangeBase <Range>k__BackingField;
    private static string VERTICAL_ALIGNMENT_PATH;
    private static string HORIZONTAL_ALIGNMENT_PATH;
    private static string VISIBLE_PATH;
    private static string BACKGROUNDCOLOR_PATH;
    private static string BACKGROUNDCOLOR2_PATH;
    private static string LINESTYLE_PATH;
    private static string ENDCAP_PATH;
    private static string LINECOLOR_PATH;
    private static string LINEWIDTH_PATH;
    private static string TEXTBOX_STYLE_PATH;
    private static string LOCKED_PATH;
    private static string LOCK_TEXT_PATH;
    private ExcelVmlDrawingPosition _from;
    private ExcelVmlDrawingPosition _to;
    private static string ROW_PATH;
    private static string COLUMN_PATH;
    private static string STYLE_PATH;
    internal ExcelRangeBase Range { get; internal set; }
    public string Address { get; internal set; }
    public eTextAlignVerticalVml VerticalAlignment { get; public set; }
    public eTextAlignHorizontalVml HorizontalAlignment { get; public set; }
    public bool Visible { get; public set; }
    public Color BackgroundColor { get; public set; }
    public eLineStyleVml LineStyle { get; public set; }
    public Color LineColor { get; public set; }
    public float LineWidth { get; public set; }
    public bool AutoFit { get; public set; }
    public bool Locked { get; public set; }
    public bool LockText { get; public set; }
    public ExcelVmlDrawingPosition From { get; }
    public ExcelVmlDrawingPosition To { get; }
    internal int Row { get; internal set; }
    internal int Column { get; internal set; }
    internal string Style { get; internal set; }
    private ulong OfficeOpenXml.IRangeID.RangeID { get; private set; }
    internal ExcelVmlDrawingComment(XmlNode topNode, ExcelRangeBase range, XmlNamespaceManager ns);
    [CompilerGeneratedAttribute]
internal ExcelRangeBase get_Range();
    [CompilerGeneratedAttribute]
internal void set_Range(ExcelRangeBase value);
    public string get_Address();
    internal void set_Address(string value);
    public eTextAlignVerticalVml get_VerticalAlignment();
    public void set_VerticalAlignment(eTextAlignVerticalVml value);
    public eTextAlignHorizontalVml get_HorizontalAlignment();
    public void set_HorizontalAlignment(eTextAlignHorizontalVml value);
    public bool get_Visible();
    public void set_Visible(bool value);
    public Color get_BackgroundColor();
    public void set_BackgroundColor(Color value);
    public eLineStyleVml get_LineStyle();
    public void set_LineStyle(eLineStyleVml value);
    public Color get_LineColor();
    public void set_LineColor(Color value);
    public float get_LineWidth();
    public void set_LineWidth(float value);
    public bool get_AutoFit();
    public void set_AutoFit(bool value);
    public bool get_Locked();
    public void set_Locked(bool value);
    public bool get_LockText();
    public void set_LockText(bool value);
    public ExcelVmlDrawingPosition get_From();
    public ExcelVmlDrawingPosition get_To();
    internal int get_Row();
    internal void set_Row(int value);
    internal int get_Column();
    internal void set_Column(int value);
    internal string get_Style();
    internal void set_Style(string value);
    private sealed virtual override ulong OfficeOpenXml.IRangeID.get_RangeID();
    private sealed virtual override void OfficeOpenXml.IRangeID.set_RangeID(ulong value);
}
[DefaultMemberAttribute("Item")]
internal class OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingCommentCollection : ExcelVmlDrawingBaseCollection {
    internal RangeCollection _drawings;
    private int _nextID;
    internal ExcelVmlDrawingBase Item { get; }
    internal int Count { get; }
    internal ExcelVmlDrawingCommentCollection(ExcelPackage pck, ExcelWorksheet ws, Uri uri);
    protected void AddDrawingsFromXml(ExcelWorksheet ws);
    private string CreateVmlDrawings();
    internal ExcelVmlDrawingComment Add(ExcelRangeBase cell);
    private XmlNode AddDrawing(ExcelRangeBase cell);
    internal string GetNewId();
    internal ExcelVmlDrawingBase get_Item(ulong rangeID);
    internal bool ContainsKey(ulong rangeID);
    internal int get_Count();
    public IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPicture : ExcelVmlDrawingBase {
    private ExcelWorksheet _worksheet;
    [CompilerGeneratedAttribute]
private Uri <ImageUri>k__BackingField;
    public string Position { get; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; public set; }
    public double Top { get; public set; }
    public string Title { get; public set; }
    public Image Image { get; }
    internal Uri ImageUri { get; internal set; }
    internal string RelId { get; internal set; }
    public bool BiLevel { get; public set; }
    public bool GrayScale { get; public set; }
    public double Gain { get; public set; }
    public double Gamma { get; public set; }
    public double BlackLevel { get; public set; }
    internal ExcelVmlDrawingPicture(XmlNode topNode, XmlNamespaceManager ns, ExcelWorksheet ws);
    public string get_Position();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public void set_Left(double value);
    public double get_Top();
    public void set_Top(double value);
    public string get_Title();
    public void set_Title(string value);
    public Image get_Image();
    [CompilerGeneratedAttribute]
internal Uri get_ImageUri();
    [CompilerGeneratedAttribute]
internal void set_ImageUri(Uri value);
    internal string get_RelId();
    internal void set_RelId(string value);
    public bool get_BiLevel();
    public void set_BiLevel(bool value);
    public bool get_GrayScale();
    public void set_GrayScale(bool value);
    public double get_Gain();
    public void set_Gain(double value);
    public double get_Gamma();
    public void set_Gamma(double value);
    public double get_BlackLevel();
    public void set_BlackLevel(double value);
    private double GetFracDT(string v, double def);
    private void SetStyleProp(string propertyName, string value);
    private double GetStyleProp(string propertyName);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPictureCollection : ExcelVmlDrawingBaseCollection {
    internal List`1<ExcelVmlDrawingPicture> _images;
    private ExcelPackage _pck;
    private ExcelWorksheet _ws;
    private int _nextID;
    public ExcelVmlDrawingPicture Item { get; }
    public int Count { get; }
    internal ExcelVmlDrawingPictureCollection(ExcelPackage pck, ExcelWorksheet ws, Uri uri);
    private void AddDrawingsFromXml();
    private string CreateVmlDrawings();
    internal ExcelVmlDrawingPicture Add(string id, Uri uri, string name, double width, double height);
    private XmlNode AddImage(string id, Uri targeUri, string Name, double width, double height);
    public ExcelVmlDrawingPicture get_Item(int Index);
    public int get_Count();
    internal string GetNewId();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class OfficeOpenXml.Drawing.Vml.ExcelVmlDrawingPosition : XmlHelper {
    private int _startPos;
    public int Row { get; public set; }
    public int RowOffset { get; public set; }
    public int Column { get; public set; }
    public int ColumnOffset { get; public set; }
    internal ExcelVmlDrawingPosition(XmlNamespaceManager ns, XmlNode topNode, int startPos);
    public int get_Row();
    public void set_Row(int value);
    public int get_RowOffset();
    public void set_RowOffset(int value);
    public int get_Column();
    public void set_Column(int value);
    public int get_ColumnOffset();
    public void set_ColumnOffset(int value);
    private void SetNumber(int pos, int value);
    private int GetNumber(int pos);
}
public enum OfficeOpenXml.eDataTypes : Enum {
    public int value__;
    public static eDataTypes Unknown;
    public static eDataTypes String;
    public static eDataTypes Number;
    public static eDataTypes DateTime;
    public static eDataTypes Percent;
}
public enum OfficeOpenXml.eErrorType : Enum {
    public int value__;
    public static eErrorType Div0;
    public static eErrorType NA;
    public static eErrorType Name;
    public static eErrorType Null;
    public static eErrorType Num;
    public static eErrorType Ref;
    public static eErrorType Value;
}
internal enum OfficeOpenXml.Encryption.AlgorithmHashID : Enum {
    public int value__;
    public static AlgorithmHashID App;
    public static AlgorithmHashID SHA1;
}
internal enum OfficeOpenXml.Encryption.AlgorithmID : Enum {
    public int value__;
    public static AlgorithmID Flags;
    public static AlgorithmID RC4;
    public static AlgorithmID AES128;
    public static AlgorithmID AES192;
    public static AlgorithmID AES256;
}
internal enum OfficeOpenXml.Encryption.eChainingMode : Enum {
    public int value__;
    public static eChainingMode ChainingModeCBC;
    public static eChainingMode ChainingModeCFB;
}
internal enum OfficeOpenXml.Encryption.eCipherAlgorithm : Enum {
    public int value__;
    public static eCipherAlgorithm AES;
    public static eCipherAlgorithm RC2;
    public static eCipherAlgorithm RC4;
    public static eCipherAlgorithm DES;
    public static eCipherAlgorithm DESX;
    public static eCipherAlgorithm TRIPLE_DES;
    public static eCipherAlgorithm TRIPLE_DES_112;
}
internal enum OfficeOpenXml.Encryption.eHashAlogorithm : Enum {
    public int value__;
    public static eHashAlogorithm SHA1;
    public static eHashAlogorithm SHA256;
    public static eHashAlogorithm SHA384;
    public static eHashAlogorithm SHA512;
    public static eHashAlogorithm MD5;
    public static eHashAlogorithm MD4;
    public static eHashAlogorithm MD2;
    public static eHashAlogorithm RIPEMD128;
    public static eHashAlogorithm RIPEMD160;
    public static eHashAlogorithm WHIRLPOOL;
}
internal class OfficeOpenXml.Encryption.EncryptedPackageHandler : object {
    private Byte[] BlockKey_HashInput;
    private Byte[] BlockKey_HashValue;
    private Byte[] BlockKey_KeyValue;
    private Byte[] BlockKey_HmacKey;
    private Byte[] BlockKey_HmacValue;
    internal MemoryStream DecryptPackage(FileInfo fi, ExcelEncryption encryption);
    [SecuritySafeCriticalAttribute]
internal MemoryStream DecryptPackage(MemoryStream stream, ExcelEncryption encryption);
    internal MemoryStream EncryptPackage(Byte[] package, ExcelEncryption encryption);
    private MemoryStream EncryptPackageAgile(Byte[] package, ExcelEncryption encryption);
    private Byte[] EncryptDataAgile(Byte[] data, EncryptionInfoAgile encryptionInfo, HashAlgorithm hashProvider);
    private void SetHMAC(EncryptionInfoAgile ei, HashAlgorithm hashProvider, Byte[] salt, Byte[] data);
    private HMAC GetHmacProvider(EncryptionKeyEncryptor ei, Byte[] salt);
    private MemoryStream EncryptPackageBinary(Byte[] package, ExcelEncryption encryption);
    private void CreateDataSpaces(CompoundDocument doc);
    private Byte[] CreateStrongEncryptionDataSpaceStream();
    private Byte[] CreateVersionStream();
    private Byte[] CreateDataSpaceMap();
    private Byte[] CreateTransformInfoPrimary();
    private EncryptionInfoBinary CreateEncryptionInfo(string password, AlgorithmID algID, Byte[]& key);
    private Byte[] EncryptData(Byte[] key, Byte[] data, bool useDataSize);
    private MemoryStream GetStreamFromPackage(CompoundDocument doc, ExcelEncryption encryption);
    private MemoryStream DecryptDocument(Byte[] data, EncryptionInfo encryptionInfo, string password);
    private MemoryStream DecryptAgile(EncryptionInfoAgile encryptionInfo, string password, long size, Byte[] encryptedData, Byte[] data);
    private HashAlgorithm GetHashProvider(EncryptionKeyEncryptor encr);
    private MemoryStream DecryptBinary(EncryptionInfoBinary encryptionInfo, string password, long size, Byte[] encryptedData);
    private bool IsPasswordValid(Byte[] key, EncryptionInfoBinary encryptionInfo);
    private bool IsPasswordValid(HashAlgorithm sha, EncryptionKeyEncryptor encr);
    private Byte[] DecryptAgileFromKey(EncryptionKeyEncryptor encr, Byte[] key, Byte[] encryptedData, long size, Byte[] iv);
    private SymmetricAlgorithm GetEncryptionAlgorithm(EncryptionKeyEncryptor encr);
    private void EncryptAgileFromKey(EncryptionKeyEncryptor encr, Byte[] key, Byte[] data, long pos, long size, Byte[] iv, MemoryStream ms);
    private Byte[] GetPasswordHashBinary(string password, EncryptionInfoBinary encryptionInfo);
    private Byte[] GetPasswordHashAgile(string password, EncryptionKeyEncryptor encr, Byte[] blockKey);
    private Byte[] GetFinalHash(HashAlgorithm hashProvider, EncryptionKeyEncryptor encr, Byte[] blockKey, Byte[] hash);
    private Byte[] GetPasswordHash(HashAlgorithm hashProvider, Byte[] salt, string password, int spinCount, int hashSize);
    private Byte[] FixHashSize(Byte[] hash, int size, byte fill);
    private Byte[] CombinePassword(Byte[] salt, string password);
    internal static ushort CalculatePasswordHash(string Password);
}
internal class OfficeOpenXml.Encryption.EncryptionHeader : object {
    internal Flags Flags;
    internal int SizeExtra;
    internal AlgorithmID AlgID;
    internal AlgorithmHashID AlgIDHash;
    internal int KeySize;
    internal ProviderType ProviderType;
    internal int Reserved1;
    internal int Reserved2;
    internal string CSPName;
    internal Byte[] WriteBinary();
}
internal abstract class OfficeOpenXml.Encryption.EncryptionInfo : object {
    internal short MajorVersion;
    internal short MinorVersion;
    internal abstract virtual void Read(Byte[] data);
    internal static EncryptionInfo ReadBinary(Byte[] data);
}
internal class OfficeOpenXml.Encryption.EncryptionInfoAgile : EncryptionInfo {
    private XmlNamespaceManager _nsm;
    [CompilerGeneratedAttribute]
private EncryptionDataIntegrity <DataIntegrity>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionKeyData <KeyData>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<EncryptionKeyEncryptor> <KeyEncryptors>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocument <Xml>k__BackingField;
    internal EncryptionDataIntegrity DataIntegrity { get; internal set; }
    internal EncryptionKeyData KeyData { get; internal set; }
    internal List`1<EncryptionKeyEncryptor> KeyEncryptors { get; private set; }
    internal XmlDocument Xml { get; internal set; }
    [CompilerGeneratedAttribute]
internal EncryptionDataIntegrity get_DataIntegrity();
    [CompilerGeneratedAttribute]
internal void set_DataIntegrity(EncryptionDataIntegrity value);
    [CompilerGeneratedAttribute]
internal EncryptionKeyData get_KeyData();
    [CompilerGeneratedAttribute]
internal void set_KeyData(EncryptionKeyData value);
    [CompilerGeneratedAttribute]
internal List`1<EncryptionKeyEncryptor> get_KeyEncryptors();
    [CompilerGeneratedAttribute]
private void set_KeyEncryptors(List`1<EncryptionKeyEncryptor> value);
    [CompilerGeneratedAttribute]
internal XmlDocument get_Xml();
    [CompilerGeneratedAttribute]
internal void set_Xml(XmlDocument value);
    internal virtual void Read(Byte[] data);
    internal void ReadFromXml(string xml);
}
internal class OfficeOpenXml.Encryption.EncryptionInfoBinary : EncryptionInfo {
    internal Flags Flags;
    internal UInt32 HeaderSize;
    internal EncryptionHeader Header;
    internal EncryptionVerifier Verifier;
    internal virtual void Read(Byte[] data);
    internal Byte[] WriteBinary();
}
internal class OfficeOpenXml.Encryption.EncryptionVerifier : object {
    internal UInt32 SaltSize;
    internal Byte[] Salt;
    internal Byte[] EncryptedVerifier;
    internal UInt32 VerifierHashSize;
    internal Byte[] EncryptedVerifierHash;
    internal Byte[] WriteBinary();
}
[FlagsAttribute]
internal enum OfficeOpenXml.Encryption.Flags : Enum {
    public int value__;
    public static Flags Reserved1;
    public static Flags Reserved2;
    public static Flags fCryptoAPI;
    public static Flags fDocProps;
    public static Flags fExternal;
    public static Flags fAES;
}
internal enum OfficeOpenXml.Encryption.ProviderType : Enum {
    public int value__;
    public static ProviderType Flags;
    public static ProviderType RC4;
    public static ProviderType AES;
}
public enum OfficeOpenXml.EncryptionAlgorithm : Enum {
    public int value__;
    public static EncryptionAlgorithm AES128;
    public static EncryptionAlgorithm AES192;
    public static EncryptionAlgorithm AES256;
}
public enum OfficeOpenXml.EncryptionVersion : Enum {
    public int value__;
    public static EncryptionVersion Standard;
    public static EncryptionVersion Agile;
}
public enum OfficeOpenXml.eOrientation : Enum {
    public int value__;
    public static eOrientation Portrait;
    public static eOrientation Landscape;
}
public enum OfficeOpenXml.ePageOrder : Enum {
    public int value__;
    public static ePageOrder DownThenOver;
    public static ePageOrder OverThenDown;
}
public enum OfficeOpenXml.ePaperSize : Enum {
    public int value__;
    public static ePaperSize Letter;
    public static ePaperSize LetterSmall;
    public static ePaperSize Tabloid;
    public static ePaperSize Ledger;
    public static ePaperSize Legal;
    public static ePaperSize Statement;
    public static ePaperSize Executive;
    public static ePaperSize A3;
    public static ePaperSize A4;
    public static ePaperSize A4Small;
    public static ePaperSize A5;
    public static ePaperSize B4;
    public static ePaperSize B5;
    public static ePaperSize Folio;
    public static ePaperSize Quarto;
    public static ePaperSize Standard10_14;
    public static ePaperSize Standard11_17;
    public static ePaperSize Note;
    public static ePaperSize Envelope9;
    public static ePaperSize Envelope10;
    public static ePaperSize Envelope11;
    public static ePaperSize Envelope12;
    public static ePaperSize Envelope14;
    public static ePaperSize C;
    public static ePaperSize D;
    public static ePaperSize E;
    public static ePaperSize DLEnvelope;
    public static ePaperSize C5Envelope;
    public static ePaperSize C3Envelope;
    public static ePaperSize C4Envelope;
    public static ePaperSize C6Envelope;
    public static ePaperSize C65Envelope;
    public static ePaperSize B4Envelope;
    public static ePaperSize B5Envelope;
    public static ePaperSize B6Envelope;
    public static ePaperSize ItalyEnvelope;
    public static ePaperSize MonarchEnvelope;
    public static ePaperSize Six3_4Envelope;
    public static ePaperSize USStandard;
    public static ePaperSize GermanStandard;
    public static ePaperSize GermanLegal;
    public static ePaperSize ISOB4;
    public static ePaperSize JapaneseDoublePostcard;
    public static ePaperSize Standard9;
    public static ePaperSize Standard10;
    public static ePaperSize Standard15;
    public static ePaperSize InviteEnvelope;
    public static ePaperSize LetterExtra;
    public static ePaperSize LegalExtra;
    public static ePaperSize TabloidExtra;
    public static ePaperSize A4Extra;
    public static ePaperSize LetterTransverse;
    public static ePaperSize A4Transverse;
    public static ePaperSize LetterExtraTransverse;
    public static ePaperSize SuperA;
    public static ePaperSize SuperB;
    public static ePaperSize LetterPlus;
    public static ePaperSize A4Plus;
    public static ePaperSize A5Transverse;
    public static ePaperSize JISB5Transverse;
    public static ePaperSize A3Extra;
    public static ePaperSize A5Extra;
    public static ePaperSize ISOB5;
    public static ePaperSize A2;
    public static ePaperSize A3Transverse;
    public static ePaperSize A3ExtraTransverse;
}
internal enum OfficeOpenXml.eProtectedRangeAlgorithm : Enum {
    public int value__;
    public static eProtectedRangeAlgorithm MD2;
    public static eProtectedRangeAlgorithm MD4;
    public static eProtectedRangeAlgorithm MD5;
    public static eProtectedRangeAlgorithm RIPEMD128;
    public static eProtectedRangeAlgorithm RIPEMD160;
    public static eProtectedRangeAlgorithm SHA1;
    public static eProtectedRangeAlgorithm SHA256;
    public static eProtectedRangeAlgorithm SHA384;
    public static eProtectedRangeAlgorithm SHA512;
    public static eProtectedRangeAlgorithm WHIRLPOOL;
}
public enum OfficeOpenXml.eWorkSheetHidden : Enum {
    public int value__;
    public static eWorkSheetHidden Visible;
    public static eWorkSheetHidden Hidden;
    public static eWorkSheetHidden VeryHidden;
}
public class OfficeOpenXml.ExcelAddress : ExcelAddressBase {
    public string Address { get; public set; }
    public ExcelAddress(int fromRow, int fromCol, int toRow, int toColumn);
    public ExcelAddress(string address);
    internal ExcelAddress(string ws, string address);
    internal ExcelAddress(string ws, string address, bool isName);
    public ExcelAddress(string Address, ExcelPackage package, ExcelAddressBase referenceAddress);
    public string get_Address();
    public void set_Address(string value);
}
public class OfficeOpenXml.ExcelAddressBase : ExcelCellBase {
    protected internal int _fromRow;
    protected internal int _toRow;
    protected internal int _fromCol;
    protected internal int _toCol;
    protected internal bool _fromRowFixed;
    protected internal bool _fromColFixed;
    protected internal bool _toRowFixed;
    protected internal bool _toColFixed;
    protected internal string _wb;
    protected internal string _ws;
    protected internal string _address;
    protected ExcelCellAddress _start;
    protected ExcelCellAddress _end;
    protected ExcelTableAddress _table;
    private string _firstAddress;
    protected internal List`1<ExcelAddress> _addresses;
    private static HashSet`1<char> FormulaCharacters;
    public ExcelCellAddress Start { get; }
    public ExcelCellAddress End { get; }
    public ExcelTableAddress Table { get; }
    public string Address { get; }
    internal string FullAddress { get; }
    public bool IsName { get; }
    internal string FirstAddress { get; }
    internal string AddressSpaceSeparated { get; }
    internal string WorkSheet { get; }
    internal List`1<ExcelAddress> Addresses { get; }
    public int Rows { get; }
    public int Columns { get; }
    internal bool IsSingleCell { get; }
    public ExcelAddressBase(int fromRow, int fromCol, int toRow, int toColumn);
    public ExcelAddressBase(int fromRow, int fromCol, int toRow, int toColumn, bool fromRowFixed, bool fromColFixed, bool toRowFixed, bool toColFixed);
    public ExcelAddressBase(string address);
    public ExcelAddressBase(string address, ExcelPackage pck, ExcelAddressBase referenceAddress);
    internal ExcelAddressBase(string address, bool isName);
    private static ExcelAddressBase();
    internal void SetRCFromTable(ExcelPackage pck, ExcelAddressBase referenceAddress);
    protected internal void SetAddress(string address);
    protected internal virtual void ChangeAddress();
    private void SetWbWs(string address);
    internal void ChangeWorksheet(string wsName, string newWs);
    private string GetAddress();
    public ExcelCellAddress get_Start();
    public ExcelCellAddress get_End();
    public ExcelTableAddress get_Table();
    public virtual string get_Address();
    internal string get_FullAddress();
    public bool get_IsName();
    public virtual string ToString();
    internal string get_FirstAddress();
    internal string get_AddressSpaceSeparated();
    protected void Validate();
    internal string get_WorkSheet();
    internal virtual List`1<ExcelAddress> get_Addresses();
    private bool ExtractAddress(string fullAddress);
    private void HandleBrackets(string first, string second, List`1<string> bracketParts);
    internal eAddressCollition Collide(ExcelAddressBase address, bool ignoreWs);
    internal ExcelAddressBase AddRow(int row, int rows, bool setFixed);
    internal ExcelAddressBase DeleteRow(int row, int rows, bool setFixed);
    internal ExcelAddressBase AddColumn(int col, int cols, bool setFixed);
    internal ExcelAddressBase DeleteColumn(int col, int cols, bool setFixed);
    internal ExcelAddressBase Insert(ExcelAddressBase address, eShiftType Shift);
    private void SetAddress(String& first, String& second, Boolean& hasSheet, bool isMulti);
    internal static AddressType IsValid(string Address);
    private static bool IsAddress(string intAddress);
    private static bool SplitAddress(string Address, String& wb, String& ws, String& intAddress);
    private static bool IsFormula(string address);
    private static bool IsValidName(string address);
    public int get_Rows();
    public int get_Columns();
    internal bool get_IsSingleCell();
    internal static string GetWorkbookPart(string address);
    internal static string GetWorksheetPart(string address, string defaultWorkSheet);
    internal static string GetWorksheetPart(string address, string defaultWorkSheet, Int32& endIx);
    internal static string GetAddressPart(string address);
    internal static void SplitAddress(string fullAddress, String& wb, String& ws, String& address, string defaultWorksheet);
    private static string GetString(string address, int ix, Int32& endIx);
    internal bool IsValidRowCol();
}
public class OfficeOpenXml.ExcelBackgroundImage : XmlHelper {
    private ExcelWorksheet _workSheet;
    private static string BACKGROUNDPIC_PATH;
    public Image Image { get; public set; }
    internal ExcelBackgroundImage(XmlNamespaceManager nsm, XmlNode topNode, ExcelWorksheet workSheet);
    public Image get_Image();
    public void set_Image(Image value);
    public void SetFromFile(FileInfo PictureFile);
    private void DeletePrevImage();
}
public enum OfficeOpenXml.ExcelCalcMode : Enum {
    public int value__;
    public static ExcelCalcMode Automatic;
    public static ExcelCalcMode AutomaticNoTable;
    public static ExcelCalcMode Manual;
}
public class OfficeOpenXml.ExcelCellAddress : object {
    private int _row;
    private int _column;
    private string _address;
    public int Row { get; private set; }
    public int Column { get; private set; }
    public string Address { get; internal set; }
    public bool IsRef { get; }
    public ExcelCellAddress(int row, int column);
    public ExcelCellAddress(string address);
    public int get_Row();
    private void set_Row(int value);
    public int get_Column();
    private void set_Column(int value);
    public string get_Address();
    internal void set_Address(string value);
    public bool get_IsRef();
    public static string GetColumnLetter(int column);
}
public abstract class OfficeOpenXml.ExcelCellBase : object {
    internal static void SplitCellID(ulong cellID, Int32& sheet, Int32& row, Int32& col);
    internal static ulong GetCellID(int SheetID, int row, int col);
    public static string TranslateFromR1C1(string value, int row, int col);
    public static string TranslateToR1C1(string value, int row, int col);
    private static string Translate(string value, dlgTransl addressTranslator, int row, int col, int rowIncr, int colIncr);
    private static string ToR1C1(string part, int row, int col, int rowIncr, int colIncr);
    private static string ToAbs(string part, int row, int col, int rowIncr, int colIncr);
    private static string AddToRowColumnTranslator(string Address, int row, int col, int rowIncr, int colIncr);
    private static string GetRCFmt(int v);
    private static int GetRC(string value, int OffsetValue, Boolean& fixedAddr);
    protected internal static string GetColumnLetter(int iColumnNumber);
    protected internal static string GetColumnLetter(int iColumnNumber, bool fixedCol);
    internal static bool GetRowColFromAddress(string CellAddress, Int32& FromRow, Int32& FromColumn, Int32& ToRow, Int32& ToColumn);
    internal static bool GetRowColFromAddress(string CellAddress, Int32& FromRow, Int32& FromColumn, Int32& ToRow, Int32& ToColumn, Boolean& fixedFromRow, Boolean& fixedFromColumn, Boolean& fixedToRow, Boolean& fixedToColumn);
    internal static bool GetRowColFromAddress(string CellAddress, Int32& Row, Int32& Column);
    internal static bool GetRowColFromAddress(string CellAddress, Int32& row, Int32& col, Boolean& fixedRow, Boolean& fixedCol);
    internal static bool GetRowCol(string address, Int32& row, Int32& col, bool throwException);
    internal static bool GetRowCol(string address, Int32& row, Int32& col, bool throwException, Boolean& fixedRow, Boolean& fixedCol);
    private static int GetColumn(string sCol);
    public static string GetAddress(int Row, int Column);
    public static string GetAddress(int Row, bool AbsoluteRow, int Column, bool AbsoluteCol);
    public static string GetAddress(int Row, int Column, bool Absolute);
    public static string GetAddress(int FromRow, int FromColumn, int ToRow, int ToColumn);
    public static string GetAddress(int FromRow, int FromColumn, int ToRow, int ToColumn, bool Absolute);
    public static string GetAddress(int FromRow, int FromColumn, int ToRow, int ToColumn, bool FixedFromRow, bool FixedFromColumn, bool FixedToRow, bool FixedToColumn);
    public static string GetFullAddress(string worksheetName, string address);
    internal static string GetFullAddress(string worksheetName, string address, bool fullRowCol);
    public static bool IsValidAddress(string address);
    public static bool IsValidCellAddress(string cellAddress);
    internal static string UpdateFormulaReferences(string formula, int rowIncrement, int colIncrement, int afterRow, int afterColumn, string currentSheet, string modifiedSheet, bool setFixed);
    internal static string UpdateFormulaSheetReferences(string formula, string oldSheetName, string newSheetName);
}
public class OfficeOpenXml.ExcelChartsheet : ExcelWorksheet {
    public ExcelChart Chart { get; }
    public ExcelChartsheet(XmlNamespaceManager ns, ExcelPackage pck, string relID, Uri uriWorksheet, string sheetName, int sheetID, int positionID, eWorkSheetHidden hidden, eChartType chartType);
    public ExcelChartsheet(XmlNamespaceManager ns, ExcelPackage pck, string relID, Uri uriWorksheet, string sheetName, int sheetID, int positionID, eWorkSheetHidden hidden);
    public ExcelChart get_Chart();
}
public class OfficeOpenXml.ExcelColumn : object {
    private ExcelWorksheet _worksheet;
    private XmlElement _colElement;
    internal int _columnMin;
    internal int _columnMax;
    internal bool _hidden;
    internal double _width;
    [CompilerGeneratedAttribute]
private bool <BestFit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Collapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OutlineLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Phonetic>k__BackingField;
    internal string _styleName;
    [CompilerGeneratedAttribute]
private bool <PageBreak>k__BackingField;
    public int ColumnMin { get; }
    public int ColumnMax { get; public set; }
    internal ulong ColumnID { get; }
    public bool Hidden { get; public set; }
    internal double VisualWidth { get; }
    public double Width { get; public set; }
    public bool BestFit { get; public set; }
    public bool Collapsed { get; public set; }
    public int OutlineLevel { get; public set; }
    public bool Phonetic { get; public set; }
    public ExcelStyle Style { get; }
    public string StyleName { get; public set; }
    public int StyleID { get; public set; }
    public bool PageBreak { get; public set; }
    public bool Merged { get; public set; }
    private ulong OfficeOpenXml.IRangeID.RangeID { get; private set; }
    protected internal ExcelColumn(ExcelWorksheet Worksheet, int col);
    public int get_ColumnMin();
    public int get_ColumnMax();
    public void set_ColumnMax(int value);
    internal ulong get_ColumnID();
    public bool get_Hidden();
    public void set_Hidden(bool value);
    internal double get_VisualWidth();
    public double get_Width();
    public void set_Width(double value);
    [CompilerGeneratedAttribute]
public bool get_BestFit();
    [CompilerGeneratedAttribute]
public void set_BestFit(bool value);
    [CompilerGeneratedAttribute]
public bool get_Collapsed();
    [CompilerGeneratedAttribute]
public void set_Collapsed(bool value);
    [CompilerGeneratedAttribute]
public int get_OutlineLevel();
    [CompilerGeneratedAttribute]
public void set_OutlineLevel(int value);
    [CompilerGeneratedAttribute]
public bool get_Phonetic();
    [CompilerGeneratedAttribute]
public void set_Phonetic(bool value);
    public ExcelStyle get_Style();
    public string get_StyleName();
    public void set_StyleName(string value);
    public int get_StyleID();
    public void set_StyleID(int value);
    [CompilerGeneratedAttribute]
public bool get_PageBreak();
    [CompilerGeneratedAttribute]
public void set_PageBreak(bool value);
    public bool get_Merged();
    public void set_Merged(bool value);
    public virtual string ToString();
    public void AutoFit();
    public void AutoFit(double MinimumWidth);
    public void AutoFit(double MinimumWidth, double MaximumWidth);
    internal static ulong GetColumnID(int sheetID, int column);
    private sealed virtual override ulong OfficeOpenXml.IRangeID.get_RangeID();
    private sealed virtual override void OfficeOpenXml.IRangeID.set_RangeID(ulong value);
    internal ExcelColumn Clone(ExcelWorksheet added);
    internal ExcelColumn Clone(ExcelWorksheet added, int col);
}
public class OfficeOpenXml.ExcelComment : ExcelVmlDrawingComment {
    internal XmlHelper _commentHelper;
    private string _text;
    private static string AUTHORS_PATH;
    private static string AUTHOR_PATH;
    [CompilerGeneratedAttribute]
private ExcelRichTextCollection <RichText>k__BackingField;
    public string Author { get; public set; }
    public string Text { get; public set; }
    public ExcelRichText Font { get; }
    public ExcelRichTextCollection RichText { get; public set; }
    internal string Reference { get; internal set; }
    internal ExcelComment(XmlNamespaceManager ns, XmlNode commentTopNode, ExcelRangeBase cell);
    public string get_Author();
    public void set_Author(string value);
    private int GetAuthor(string value);
    public string get_Text();
    public void set_Text(string value);
    public ExcelRichText get_Font();
    [CompilerGeneratedAttribute]
public ExcelRichTextCollection get_RichText();
    [CompilerGeneratedAttribute]
public void set_RichText(ExcelRichTextCollection value);
    internal string get_Reference();
    internal void set_Reference(string value);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.ExcelCommentCollection : object {
    private List`1<ExcelComment> _list;
    [CompilerGeneratedAttribute]
private XmlDocument <CommentXml>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelId>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlNamespaceManager <NameSpaceManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackagePart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelWorksheet <Worksheet>k__BackingField;
    public XmlDocument CommentXml { get; public set; }
    internal Uri Uri { get; internal set; }
    internal string RelId { get; internal set; }
    internal XmlNamespaceManager NameSpaceManager { get; internal set; }
    internal ZipPackagePart Part { get; internal set; }
    public ExcelWorksheet Worksheet { get; public set; }
    public int Count { get; }
    public ExcelComment Item { get; }
    public ExcelComment Item { get; }
    internal ExcelCommentCollection(ExcelPackage pck, ExcelWorksheet ws, XmlNamespaceManager ns);
    private void CreateXml(ExcelPackage pck);
    private void AddCommentsFromXml();
    [CompilerGeneratedAttribute]
public XmlDocument get_CommentXml();
    [CompilerGeneratedAttribute]
public void set_CommentXml(XmlDocument value);
    [CompilerGeneratedAttribute]
internal Uri get_Uri();
    [CompilerGeneratedAttribute]
internal void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
internal string get_RelId();
    [CompilerGeneratedAttribute]
internal void set_RelId(string value);
    [CompilerGeneratedAttribute]
internal XmlNamespaceManager get_NameSpaceManager();
    [CompilerGeneratedAttribute]
internal void set_NameSpaceManager(XmlNamespaceManager value);
    [CompilerGeneratedAttribute]
internal ZipPackagePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(ZipPackagePart value);
    [CompilerGeneratedAttribute]
public ExcelWorksheet get_Worksheet();
    [CompilerGeneratedAttribute]
public void set_Worksheet(ExcelWorksheet value);
    public int get_Count();
    public ExcelComment get_Item(int Index);
    public ExcelComment get_Item(ExcelCellAddress cell);
    public ExcelComment Add(ExcelRangeBase cell, string Text, string author);
    public void Remove(ExcelComment comment);
    internal void Delete(int fromRow, int fromCol, int rows, int columns);
    public void Insert(int fromRow, int fromCol, int rows, int columns);
    private sealed virtual override void System.IDisposable.Dispose();
    public void RemoveAt(int Index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Clear();
}
public class OfficeOpenXml.ExcelCoreValue : ValueType {
    internal object _value;
    internal int _styleId;
}
public class OfficeOpenXml.ExcelEncryption : object {
    private bool _isEncrypted;
    private string _password;
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm <Algorithm>k__BackingField;
    private EncryptionVersion _version;
    public bool IsEncrypted { get; public set; }
    public string Password { get; public set; }
    public EncryptionAlgorithm Algorithm { get; public set; }
    public EncryptionVersion Version { get; public set; }
    internal ExcelEncryption(EncryptionAlgorithm encryptionAlgorithm);
    public bool get_IsEncrypted();
    public void set_IsEncrypted(bool value);
    public string get_Password();
    public void set_Password(string value);
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(EncryptionAlgorithm value);
    public EncryptionVersion get_Version();
    public void set_Version(EncryptionVersion value);
}
public class OfficeOpenXml.ExcelErrorValue : object {
    [CompilerGeneratedAttribute]
private eErrorType <Type>k__BackingField;
    public eErrorType Type { get; private set; }
    private ExcelErrorValue(eErrorType type);
    internal static ExcelErrorValue Create(eErrorType errorType);
    internal static ExcelErrorValue Parse(string val);
    [CompilerGeneratedAttribute]
public eErrorType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(eErrorType value);
    public virtual string ToString();
    public static ExcelErrorValue op_Addition(object v1, ExcelErrorValue v2);
    public static ExcelErrorValue op_Addition(ExcelErrorValue v1, ExcelErrorValue v2);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class OfficeOpenXml.ExcelFormulaAddress : ExcelAddressBase {
    internal List`1<ExcelFormulaAddress> _addresses;
    public string Address { get; public set; }
    public List`1<ExcelFormulaAddress> Addresses { get; }
    public ExcelFormulaAddress(int fromRow, int fromCol, int toRow, int toColumn);
    public ExcelFormulaAddress(string address);
    internal ExcelFormulaAddress(string ws, string address);
    internal ExcelFormulaAddress(string ws, string address, bool isName);
    private void SetFixed();
    private void GetFixed(string address, Boolean& rowFixed, Boolean& colFixed);
    public string get_Address();
    public void set_Address(string value);
    public List`1<ExcelFormulaAddress> get_Addresses();
    internal string GetOffset(int row, int column);
}
public class OfficeOpenXml.ExcelHeaderFooter : XmlHelper {
    public static string PageNumber;
    public static string NumberOfPages;
    public static string FontColor;
    public static string SheetName;
    public static string FilePath;
    public static string FileName;
    public static string CurrentDate;
    public static string CurrentTime;
    public static string Image;
    public static string OutlineStyle;
    public static string ShadowStyle;
    internal ExcelHeaderFooterText _oddHeader;
    internal ExcelHeaderFooterText _oddFooter;
    internal ExcelHeaderFooterText _evenHeader;
    internal ExcelHeaderFooterText _evenFooter;
    internal ExcelHeaderFooterText _firstHeader;
    internal ExcelHeaderFooterText _firstFooter;
    private ExcelWorksheet _ws;
    private static string alignWithMarginsPath;
    private static string differentOddEvenPath;
    private static string differentFirstPath;
    private ExcelVmlDrawingPictureCollection _vmlDrawingsHF;
    public bool AlignWithMargins { get; public set; }
    public bool differentOddEven { get; public set; }
    public bool differentFirst { get; public set; }
    public ExcelHeaderFooterText OddHeader { get; }
    public ExcelHeaderFooterText OddFooter { get; }
    public ExcelHeaderFooterText EvenHeader { get; }
    public ExcelHeaderFooterText EvenFooter { get; }
    public ExcelHeaderFooterText FirstHeader { get; }
    public ExcelHeaderFooterText FirstFooter { get; }
    public ExcelVmlDrawingPictureCollection Pictures { get; }
    internal ExcelHeaderFooter(XmlNamespaceManager nameSpaceManager, XmlNode topNode, ExcelWorksheet ws);
    public bool get_AlignWithMargins();
    public void set_AlignWithMargins(bool value);
    public bool get_differentOddEven();
    public void set_differentOddEven(bool value);
    public bool get_differentFirst();
    public void set_differentFirst(bool value);
    public ExcelHeaderFooterText get_OddHeader();
    public ExcelHeaderFooterText get_OddFooter();
    public ExcelHeaderFooterText get_EvenHeader();
    public ExcelHeaderFooterText get_EvenFooter();
    public ExcelHeaderFooterText get_FirstHeader();
    public ExcelHeaderFooterText get_FirstFooter();
    public ExcelVmlDrawingPictureCollection get_Pictures();
    internal void Save();
    internal void SaveHeaderFooterImages();
    private string GetText(ExcelHeaderFooterText headerFooter);
}
public class OfficeOpenXml.ExcelHeaderFooterText : object {
    private ExcelWorksheet _ws;
    private string _hf;
    public string LeftAlignedText;
    public string CenteredText;
    public string RightAlignedText;
    internal ExcelHeaderFooterText(XmlNode TextNode, ExcelWorksheet ws, string hf);
    private void SetText(string code, string text);
    public ExcelVmlDrawingPicture InsertPicture(Image Picture, PictureAlignment Alignment);
    public ExcelVmlDrawingPicture InsertPicture(FileInfo PictureFile, PictureAlignment Alignment);
    private ExcelVmlDrawingPicture AddImage(Image Picture, string id, ImageInfo ii);
    private string ValidateImage(PictureAlignment Alignment);
}
public class OfficeOpenXml.ExcelHyperLink : Uri {
    private string _referenceAddress;
    private string _display;
    [CompilerGeneratedAttribute]
private string <ToolTip>k__BackingField;
    private int _colSpann;
    private int _rowSpann;
    [CompilerGeneratedAttribute]
private Uri <OriginalUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RId>k__BackingField;
    public string ReferenceAddress { get; public set; }
    public string Display { get; public set; }
    public string ToolTip { get; public set; }
    public int ColSpann { get; public set; }
    public int RowSpann { get; public set; }
    public Uri OriginalUri { get; internal set; }
    internal string RId { get; internal set; }
    public ExcelHyperLink(string uriString);
    public ExcelHyperLink(string uriString, UriKind uriKind);
    public ExcelHyperLink(string referenceAddress, string display);
    public string get_ReferenceAddress();
    public void set_ReferenceAddress(string value);
    public string get_Display();
    public void set_Display(string value);
    [CompilerGeneratedAttribute]
public string get_ToolTip();
    [CompilerGeneratedAttribute]
public void set_ToolTip(string value);
    public int get_ColSpann();
    public void set_ColSpann(int value);
    public int get_RowSpann();
    public void set_RowSpann(int value);
    [CompilerGeneratedAttribute]
public Uri get_OriginalUri();
    [CompilerGeneratedAttribute]
internal void set_OriginalUri(Uri value);
    [CompilerGeneratedAttribute]
internal string get_RId();
    [CompilerGeneratedAttribute]
internal void set_RId(string value);
}
public class OfficeOpenXml.ExcelNamedRange : ExcelRangeBase {
    private ExcelWorksheet _sheet;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNameHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameComment>k__BackingField;
    [CompilerGeneratedAttribute]
private object <NameValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameFormula>k__BackingField;
    public string Name { get; internal set; }
    public int LocalSheetId { get; }
    internal ExcelWorksheet LocalSheet { get; }
    internal int Index { get; internal set; }
    public bool IsNameHidden { get; public set; }
    public string NameComment { get; public set; }
    internal object NameValue { get; internal set; }
    internal string NameFormula { get; internal set; }
    public ExcelNamedRange(string name, ExcelWorksheet nameSheet, ExcelWorksheet sheet, string address, int index);
    internal ExcelNamedRange(string name, ExcelWorkbook wb, ExcelWorksheet nameSheet, int index);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    public int get_LocalSheetId();
    internal ExcelWorksheet get_LocalSheet();
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [CompilerGeneratedAttribute]
public bool get_IsNameHidden();
    [CompilerGeneratedAttribute]
public void set_IsNameHidden(bool value);
    [CompilerGeneratedAttribute]
public string get_NameComment();
    [CompilerGeneratedAttribute]
public void set_NameComment(string value);
    [CompilerGeneratedAttribute]
internal object get_NameValue();
    [CompilerGeneratedAttribute]
internal void set_NameValue(object value);
    [CompilerGeneratedAttribute]
internal string get_NameFormula();
    [CompilerGeneratedAttribute]
internal void set_NameFormula(string value);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.ExcelNamedRangeCollection : object {
    internal ExcelWorksheet _ws;
    internal ExcelWorkbook _wb;
    private List`1<ExcelNamedRange> _list;
    private Dictionary`2<string, int> _dic;
    public int Count { get; }
    public ExcelNamedRange Item { get; }
    public ExcelNamedRange Item { get; }
    internal ExcelNamedRangeCollection(ExcelWorkbook wb);
    internal ExcelNamedRangeCollection(ExcelWorkbook wb, ExcelWorksheet ws);
    public ExcelNamedRange Add(string Name, ExcelRangeBase Range);
    private void AddName(string Name, ExcelNamedRange item);
    public ExcelNamedRange AddValue(string Name, object value);
    [ObsoleteAttribute("Call AddFormula() instead.  See Issue Tracker Id #14687")]
public ExcelNamedRange AddFormla(string Name, string Formula);
    public ExcelNamedRange AddFormula(string Name, string Formula);
    internal void Insert(int rowFrom, int colFrom, int rows, int cols);
    internal void Insert(int rowFrom, int colFrom, int rows, int cols, Func`2<ExcelNamedRange, bool> filter);
    internal void Delete(int rowFrom, int colFrom, int rows, int cols);
    internal void Delete(int rowFrom, int colFrom, int rows, int cols, Func`2<ExcelNamedRange, bool> filter);
    private void InsertColumns(int colFrom, int cols, ExcelNamedRange namedRange);
    private static string BuildNewAddress(ExcelNamedRange namedRange, string newAddress);
    private void InsertRows(int rowFrom, int rows, ExcelNamedRange namedRange);
    public void Remove(string Name);
    public bool ContainsKey(string key);
    public int get_Count();
    public ExcelNamedRange get_Item(string Name);
    public ExcelNamedRange get_Item(int Index);
    public sealed virtual IEnumerator`1<ExcelNamedRange> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Clear();
}
public class OfficeOpenXml.ExcelPackage : object {
    internal static bool preserveWhitespace;
    private Stream _stream;
    private bool _isExternalStream;
    internal Dictionary`2<string, ImageInfo> _images;
    internal static string schemaXmlExtension;
    internal static string schemaRelsExtension;
    internal static string schemaMain;
    internal static string schemaRelationships;
    internal static string schemaDrawings;
    internal static string schemaSheetDrawings;
    internal static string schemaMarkupCompatibility;
    internal static string schemaMicrosoftVml;
    internal static string schemaMicrosoftOffice;
    internal static string schemaMicrosoftExcel;
    internal static string schemaChart;
    internal static string schemaHyperlink;
    internal static string schemaComment;
    internal static string schemaImage;
    internal static string schemaCore;
    internal static string schemaExtended;
    internal static string schemaCustom;
    internal static string schemaDc;
    internal static string schemaDcTerms;
    internal static string schemaDcmiType;
    internal static string schemaXsi;
    internal static string schemaVt;
    internal static string schemaPivotTable;
    internal static string schemaPivotCacheDefinition;
    internal static string schemaPivotCacheRecords;
    internal static string schemaVBA;
    internal static string schemaVBASignature;
    internal static string contentTypeWorkbookDefault;
    internal static string contentTypeWorkbookMacroEnabled;
    internal static string contentTypeSharedString;
    private ZipPackage _package;
    internal ExcelWorkbook _workbook;
    public static int MaxColumns;
    public static int MaxRows;
    private ExcelEncryption _encryption;
    [CompilerGeneratedAttribute]
private bool <DoAdjustDrawings>k__BackingField;
    private FileInfo _file;
    private static object _lock;
    public ZipPackage Package { get; }
    public ExcelEncryption Encryption { get; }
    public ExcelWorkbook Workbook { get; }
    public bool DoAdjustDrawings { get; public set; }
    public FileInfo File { get; public set; }
    public Stream Stream { get; }
    public CompressionLevel Compression { get; public set; }
    public ExcelPackage(FileInfo newFile);
    public ExcelPackage(FileInfo newFile, string password);
    public ExcelPackage(FileInfo newFile, FileInfo template);
    public ExcelPackage(FileInfo newFile, FileInfo template, string password);
    public ExcelPackage(FileInfo template, bool useStream);
    public ExcelPackage(FileInfo template, bool useStream, string password);
    public ExcelPackage(Stream newStream);
    public ExcelPackage(Stream newStream, string Password);
    public ExcelPackage(Stream newStream, Stream templateStream);
    public ExcelPackage(Stream newStream, Stream templateStream, string Password);
    private static ExcelPackage();
    internal ImageInfo AddImage(Byte[] image);
    internal ImageInfo AddImage(Byte[] image, Uri uri, string contentType);
    internal ImageInfo LoadImage(Byte[] image, Uri uri, ZipPackagePart imagePart);
    internal void RemoveImage(string hash);
    internal ImageInfo GetImageInfo(Byte[] image);
    private Uri GetNewUri(ZipPackage package, string sUri);
    private void Init();
    private void CreateFromTemplate(FileInfo template, string password);
    private void ConstructNewFile(string password);
    private void CreateBlankWb();
    public ZipPackage get_Package();
    public ExcelEncryption get_Encryption();
    public ExcelWorkbook get_Workbook();
    [CompilerGeneratedAttribute]
public bool get_DoAdjustDrawings();
    [CompilerGeneratedAttribute]
public void set_DoAdjustDrawings(bool value);
    private XmlNamespaceManager CreateDefaultNSM();
    internal void SavePart(Uri uri, XmlDocument xmlDoc);
    internal void SaveWorkbook(Uri uri, XmlDocument xmlDoc);
    public sealed virtual void Dispose();
    public void Save();
    public void Save(string password);
    public void SaveAs(FileInfo file);
    public void SaveAs(FileInfo file, string password);
    public void SaveAs(Stream OutputStream);
    public void SaveAs(Stream OutputStream, string password);
    public FileInfo get_File();
    public void set_File(FileInfo value);
    internal void CloseStream();
    public Stream get_Stream();
    public CompressionLevel get_Compression();
    public void set_Compression(CompressionLevel value);
    internal XmlDocument GetXmlFromUri(Uri uri);
    public Byte[] GetAsByteArray();
    public Byte[] GetAsByteArray(string password);
    internal Byte[] GetAsByteArray(bool save);
    public void Load(Stream input);
    public void Load(Stream input, string Password);
    private void Load(Stream input, Stream output, string Password);
    internal static void CopyStream(Stream inputStream, Stream& outputStream);
}
public class OfficeOpenXml.ExcelPrinterSettings : XmlHelper {
    private ExcelWorksheet _ws;
    private bool _marginsCreated;
    private static string _leftMarginPath;
    private static string _rightMarginPath;
    private static string _topMarginPath;
    private static string _bottomMarginPath;
    private static string _headerMarginPath;
    private static string _footerMarginPath;
    private static string _orientationPath;
    private static string _fitToWidthPath;
    private static string _fitToHeightPath;
    private static string _scalePath;
    private static string _fitToPagePath;
    private static string _headersPath;
    private static string _gridLinesPath;
    private static string _horizontalCenteredPath;
    private static string _verticalCenteredPath;
    private static string _pageOrderPath;
    private static string _blackAndWhitePath;
    private static string _draftPath;
    private static string _paperSizePath;
    public decimal LeftMargin { get; public set; }
    public decimal RightMargin { get; public set; }
    public decimal TopMargin { get; public set; }
    public decimal BottomMargin { get; public set; }
    public decimal HeaderMargin { get; public set; }
    public decimal FooterMargin { get; public set; }
    public eOrientation Orientation { get; public set; }
    public int FitToWidth { get; public set; }
    public int FitToHeight { get; public set; }
    public int Scale { get; public set; }
    public bool FitToPage { get; public set; }
    public bool ShowHeaders { get; public set; }
    public ExcelAddress RepeatRows { get; public set; }
    public ExcelAddress RepeatColumns { get; public set; }
    public ExcelRangeBase PrintArea { get; public set; }
    public bool ShowGridLines { get; public set; }
    public bool HorizontalCentered { get; public set; }
    public bool VerticalCentered { get; public set; }
    public ePageOrder PageOrder { get; public set; }
    public bool BlackAndWhite { get; public set; }
    public bool Draft { get; public set; }
    public ePaperSize PaperSize { get; public set; }
    internal ExcelPrinterSettings(XmlNamespaceManager ns, XmlNode topNode, ExcelWorksheet ws);
    public decimal get_LeftMargin();
    public void set_LeftMargin(decimal value);
    public decimal get_RightMargin();
    public void set_RightMargin(decimal value);
    public decimal get_TopMargin();
    public void set_TopMargin(decimal value);
    public decimal get_BottomMargin();
    public void set_BottomMargin(decimal value);
    public decimal get_HeaderMargin();
    public void set_HeaderMargin(decimal value);
    public decimal get_FooterMargin();
    public void set_FooterMargin(decimal value);
    public eOrientation get_Orientation();
    public void set_Orientation(eOrientation value);
    public int get_FitToWidth();
    public void set_FitToWidth(int value);
    public int get_FitToHeight();
    public void set_FitToHeight(int value);
    public int get_Scale();
    public void set_Scale(int value);
    public bool get_FitToPage();
    public void set_FitToPage(bool value);
    public bool get_ShowHeaders();
    public void set_ShowHeaders(bool value);
    public ExcelAddress get_RepeatRows();
    public void set_RepeatRows(ExcelAddress value);
    public ExcelAddress get_RepeatColumns();
    public void set_RepeatColumns(ExcelAddress value);
    public ExcelRangeBase get_PrintArea();
    public void set_PrintArea(ExcelRangeBase value);
    public bool get_ShowGridLines();
    public void set_ShowGridLines(bool value);
    public bool get_HorizontalCentered();
    public void set_HorizontalCentered(bool value);
    public bool get_VerticalCentered();
    public void set_VerticalCentered(bool value);
    public ePageOrder get_PageOrder();
    public void set_PageOrder(ePageOrder value);
    public bool get_BlackAndWhite();
    public void set_BlackAndWhite(bool value);
    public bool get_Draft();
    public void set_Draft(bool value);
    public ePaperSize get_PaperSize();
    public void set_PaperSize(ePaperSize value);
    private void CreateMargins();
}
public class OfficeOpenXml.ExcelProtectedRange : XmlHelper {
    private ExcelAddress _address;
    public string Name { get; public set; }
    public ExcelAddress Address { get; public set; }
    public string SecurityDescriptor { get; public set; }
    internal int SpinCount { get; internal set; }
    internal string Salt { get; internal set; }
    internal string Hash { get; internal set; }
    internal eProtectedRangeAlgorithm Algorithm { get; internal set; }
    internal ExcelProtectedRange(string name, ExcelAddress address, XmlNamespaceManager ns, XmlNode topNode);
    public string get_Name();
    public void set_Name(string value);
    public ExcelAddress get_Address();
    public void set_Address(ExcelAddress value);
    public void SetPassword(string password);
    public string get_SecurityDescriptor();
    public void set_SecurityDescriptor(string value);
    internal int get_SpinCount();
    internal void set_SpinCount(int value);
    internal string get_Salt();
    internal void set_Salt(string value);
    internal string get_Hash();
    internal void set_Hash(string value);
    internal eProtectedRangeAlgorithm get_Algorithm();
    internal void set_Algorithm(eProtectedRangeAlgorithm value);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.ExcelProtectedRangeCollection : XmlHelper {
    private List`1<ExcelProtectedRange> _baseList;
    public int Count { get; }
    public ExcelProtectedRange Item { get; }
    internal ExcelProtectedRangeCollection(XmlNamespaceManager nsm, XmlNode topNode, ExcelWorksheet ws);
    public ExcelProtectedRange Add(string name, ExcelAddress address);
    public void Clear();
    public bool Contains(ExcelProtectedRange item);
    public void CopyTo(ExcelProtectedRange[] array, int arrayIndex);
    public int get_Count();
    public bool Remove(ExcelProtectedRange item);
    public int IndexOf(ExcelProtectedRange item);
    public void RemoveAt(int index);
    public ExcelProtectedRange get_Item(int index);
    private sealed virtual override IEnumerator`1<ExcelProtectedRange> System.Collections.Generic.IEnumerable<OfficeOpenXml.ExcelProtectedRange>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class OfficeOpenXml.ExcelProtection : XmlHelper {
    private static string workbookPasswordPath;
    private static string lockStructurePath;
    private static string lockWindowsPath;
    private static string lockRevisionPath;
    public bool LockStructure { get; public set; }
    public bool LockWindows { get; public set; }
    public bool LockRevision { get; public set; }
    internal ExcelProtection(XmlNamespaceManager ns, XmlNode topNode, ExcelWorkbook wb);
    public void SetPassword(string Password);
    public bool get_LockStructure();
    public void set_LockStructure(bool value);
    public bool get_LockWindows();
    public void set_LockWindows(bool value);
    public bool get_LockRevision();
    public void set_LockRevision(bool value);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.ExcelRange : ExcelRangeBase {
    public ExcelRange Item { get; }
    public ExcelRange Item { get; }
    public ExcelRange Item { get; }
    internal ExcelRange(ExcelWorksheet sheet);
    internal ExcelRange(ExcelWorksheet sheet, string address);
    internal ExcelRange(ExcelWorksheet sheet, int fromRow, int fromCol, int toRow, int toCol);
    public ExcelRange get_Item(string Address);
    private ExcelRange GetTableAddess(ExcelWorksheet _worksheet, string address);
    public ExcelRange get_Item(int Row, int Col);
    public ExcelRange get_Item(int FromRow, int FromCol, int ToRow, int ToCol);
    private static void ValidateRowCol(int Row, int Col);
}
public class OfficeOpenXml.ExcelRangeBase : ExcelAddress {
    protected ExcelWorksheet _worksheet;
    internal ExcelWorkbook _workbook;
    private _changeProp _changePropMethod;
    private int _styleID;
    private static _changeProp _setUnknownProp;
    private static _changeProp _setSingleProp;
    private static _changeProp _setRangeProp;
    private static _changeProp _setMultiProp;
    private static _setValue _setStyleIdDelegate;
    private static _setValue _setValueDelegate;
    private static _setValue _setHyperLinkDelegate;
    private static _setValue _setIsRichTextDelegate;
    private static _setValue _setExistsCommentDelegate;
    private static _setValue _setCommentDelegate;
    protected ExcelRichTextCollection _rtc;
    private CellsStoreEnumerator`1<ExcelCoreValue> cellEnum;
    private int _enumAddressIx;
    public ExcelStyle Style { get; }
    public string StyleName { get; public set; }
    public int StyleID { get; public set; }
    public object Value { get; public set; }
    public string Text { get; }
    internal string TextForWidth { get; }
    public string Formula { get; public set; }
    public string FormulaR1C1 { get; public set; }
    public Uri Hyperlink { get; public set; }
    public bool Merge { get; public set; }
    public bool AutoFilter { get; public set; }
    public bool IsRichText { get; public set; }
    public bool IsArrayFormula { get; }
    public ExcelRichTextCollection RichText { get; }
    public ExcelComment Comment { get; }
    public ExcelWorksheet Worksheet { get; }
    public string FullAddress { get; }
    public string FullAddressAbsolute { get; }
    internal string FullAddressAbsoluteNoFullRowCol { get; }
    public IRangeConditionalFormatting ConditionalFormatting { get; }
    public IRangeDataValidation DataValidation { get; }
    public ExcelRangeBase Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ExcelRangeBase(ExcelWorksheet xlWorksheet);
    internal ExcelRangeBase(ExcelWorksheet xlWorksheet, string address);
    internal ExcelRangeBase(ExcelWorkbook wb, ExcelWorksheet xlWorksheet, string address, bool isName);
    private static ExcelRangeBase();
    protected internal virtual void ChangeAddress();
    private void SetDelegate();
    private static void SetUnknown(ExcelRangeBase range, _setValue valueMethod, object value);
    private static void SetSingle(ExcelRangeBase range, _setValue valueMethod, object value);
    private static void SetRange(ExcelRangeBase range, _setValue valueMethod, object value);
    private static void SetMultiRange(ExcelRangeBase range, _setValue valueMethod, object value);
    private void SetValueAddress(ExcelAddress address, _setValue valueMethod, object value);
    private static void Set_StyleID(ExcelRangeBase range, object value, int row, int col);
    private static void Set_StyleName(ExcelRangeBase range, object value, int row, int col);
    private static void Set_Value(ExcelRangeBase range, object value, int row, int col);
    private static void Set_Formula(ExcelRangeBase range, object value, int row, int col);
    private static void Set_SharedFormula(ExcelRangeBase range, string value, ExcelAddress address, bool IsArray);
    private static void Set_HyperLink(ExcelRangeBase range, object value, int row, int col);
    private static void Set_IsRichText(ExcelRangeBase range, object value, int row, int col);
    private static void Exists_Comment(ExcelRangeBase range, object value, int row, int col);
    private static void Set_Comment(ExcelRangeBase range, object value, int row, int col);
    private void SetToSelectedRange();
    private void IsRangeValid(string type);
    internal void UpdateAddress(string address);
    public sealed virtual ExcelStyle get_Style();
    public sealed virtual string get_StyleName();
    public void set_StyleName(string value);
    private int GetColumnStyle(int col);
    public sealed virtual int get_StyleID();
    public sealed virtual void set_StyleID(int value);
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
    private bool IsInfinityValue(object value);
    private object GetValueArray();
    private ExcelAddressBase GetAddressDim(ExcelRangeBase addr);
    private object GetSingleValue();
    public string get_Text();
    public void AutoFitColumns();
    public void AutoFitColumns(double MinimumWidth);
    public void AutoFitColumns(double MinimumWidth, double MaximumWidth);
    private void SetMinWidth(double minimumWidth, int fromCol, int toCol);
    internal string get_TextForWidth();
    private string GetFormattedText(bool forWidthCalc);
    internal static string FormatValue(object v, ExcelFormatTranslator nf, string format, string textFormat);
    public sealed virtual string get_Formula();
    public sealed virtual void set_Formula(string value);
    public sealed virtual string get_FormulaR1C1();
    public sealed virtual void set_FormulaR1C1(string value);
    public sealed virtual Uri get_Hyperlink();
    public sealed virtual void set_Hyperlink(Uri value);
    public bool get_Merge();
    public void set_Merge(bool value);
    public bool get_AutoFilter();
    public void set_AutoFilter(bool value);
    public bool get_IsRichText();
    public void set_IsRichText(bool value);
    public bool get_IsArrayFormula();
    public ExcelRichTextCollection get_RichText();
    private ExcelRichTextCollection GetRichText(int row, int col);
    public ExcelComment get_Comment();
    public ExcelWorksheet get_Worksheet();
    public string get_FullAddress();
    public string get_FullAddressAbsolute();
    internal string get_FullAddressAbsoluteNoFullRowCol();
    internal void SetValueRichText(object value);
    private void SetValue(object value, int row, int col);
    internal void SetSharedFormulaID(int id);
    private void CheckAndSplitSharedFormula(ExcelAddressBase address);
    private void SplitFormulas(ExcelAddressBase address);
    private void SplitFormula(ExcelAddressBase address, int ix);
    private object ConvertData(ExcelTextFormat Format, string v, int col, bool isText);
    public IRangeConditionalFormatting get_ConditionalFormatting();
    public IRangeDataValidation get_DataValidation();
    public ExcelRangeBase LoadFromDataReader(IDataReader Reader, bool PrintHeaders, string TableName, TableStyles TableStyle);
    public ExcelRangeBase LoadFromDataReader(IDataReader Reader, bool PrintHeaders);
    public ExcelRangeBase LoadFromDataTable(DataTable Table, bool PrintHeaders, TableStyles TableStyle);
    public ExcelRangeBase LoadFromDataTable(DataTable Table, bool PrintHeaders);
    public ExcelRangeBase LoadFromArrays(IEnumerable`1<Object[]> Data);
    public ExcelRangeBase LoadFromCollection(IEnumerable`1<T> Collection);
    public ExcelRangeBase LoadFromCollection(IEnumerable`1<T> Collection, bool PrintHeaders);
    public ExcelRangeBase LoadFromCollection(IEnumerable`1<T> Collection, bool PrintHeaders, TableStyles TableStyle);
    public ExcelRangeBase LoadFromCollection(IEnumerable`1<T> Collection, bool PrintHeaders, TableStyles TableStyle, BindingFlags memberFlags, MemberInfo[] Members);
    public ExcelRangeBase LoadFromText(string Text);
    public ExcelRangeBase LoadFromText(string Text, ExcelTextFormat Format);
    public ExcelRangeBase LoadFromText(string Text, ExcelTextFormat Format, TableStyles TableStyle, bool FirstRowIsHeader);
    public ExcelRangeBase LoadFromText(FileInfo TextFile);
    public ExcelRangeBase LoadFromText(FileInfo TextFile, ExcelTextFormat Format);
    public ExcelRangeBase LoadFromText(FileInfo TextFile, ExcelTextFormat Format, TableStyles TableStyle, bool FirstRowIsHeader);
    public T GetValue();
    public ExcelRangeBase Offset(int RowOffset, int ColumnOffset);
    public ExcelRangeBase Offset(int RowOffset, int ColumnOffset, int NumberOfRows, int NumberOfColumns);
    public ExcelComment AddComment(string Text, string Author);
    public void Copy(ExcelRangeBase Destination);
    public void Copy(ExcelRangeBase Destination, Nullable`1<ExcelRangeCopyOptionFlags> excelRangeCopyOptionFlags);
    public void Clear();
    public void CreateArrayFormula(string ArrayFormula);
    internal void Delete(ExcelAddressBase Range, bool shift);
    private void DeleteCheckMergedCells(ExcelAddressBase Range);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<ExcelRangeBase> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ExcelRangeBase get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public void Sort();
    public void Sort(int column, bool descending);
    public void Sort(Int32[] columns, Boolean[] descending, CultureInfo culture, CompareOptions compareOptions);
    private static Dictionary`2<string, T> GetItems(CellStore`1<T> store, int fromRow, int fromCol, int toRow, int toCol);
    private static void SortSetValue(List`1<ExcelCoreValue> list, int index, object value);
    [CompilerGeneratedAttribute]
private void <LoadFromDataTable>b__113_1(List`1<ExcelCoreValue> list, int index, int rowIx, int columnIx, object value);
    [CompilerGeneratedAttribute]
private void <LoadFromArrays>b__114_0(List`1<ExcelCoreValue> list, int index, int rowIx, int columnIx, object value);
}
[FlagsAttribute]
public enum OfficeOpenXml.ExcelRangeCopyOptionFlags : Enum {
    public int value__;
    public static ExcelRangeCopyOptionFlags ExcludeFormulas;
}
public class OfficeOpenXml.ExcelRow : object {
    private ExcelWorksheet _worksheet;
    private XmlElement _rowElement;
    internal string _styleName;
    [CompilerGeneratedAttribute]
private int <Row>k__BackingField;
    [ObsoleteAttribute]
public ulong RowID { get; }
    internal XmlNode Node { get; }
    public bool Hidden { get; public set; }
    public double Height { get; public set; }
    public bool CustomHeight { get; public set; }
    public string StyleName { get; public set; }
    public int StyleID { get; public set; }
    public int Row { get; public set; }
    public bool Collapsed { get; public set; }
    public int OutlineLevel { get; public set; }
    public bool Phonetic { get; public set; }
    public ExcelStyle Style { get; }
    public bool PageBreak { get; public set; }
    public bool Merged { get; public set; }
    [ObsoleteAttribute]
private ulong OfficeOpenXml.IRangeID.RangeID { get; private set; }
    internal ExcelRow(ExcelWorksheet Worksheet, int row);
    public ulong get_RowID();
    internal XmlNode get_Node();
    public bool get_Hidden();
    public void set_Hidden(bool value);
    public double get_Height();
    public void set_Height(double value);
    public bool get_CustomHeight();
    public void set_CustomHeight(bool value);
    public string get_StyleName();
    public void set_StyleName(string value);
    public int get_StyleID();
    public void set_StyleID(int value);
    [CompilerGeneratedAttribute]
public int get_Row();
    [CompilerGeneratedAttribute]
public void set_Row(int value);
    public bool get_Collapsed();
    public void set_Collapsed(bool value);
    public int get_OutlineLevel();
    public void set_OutlineLevel(int value);
    private RowInternal GetRowInternal();
    public bool get_Phonetic();
    public void set_Phonetic(bool value);
    public ExcelStyle get_Style();
    public bool get_PageBreak();
    public void set_PageBreak(bool value);
    public bool get_Merged();
    public void set_Merged(bool value);
    internal static ulong GetRowID(int sheetID, int row);
    private sealed virtual override ulong OfficeOpenXml.IRangeID.get_RangeID();
    private sealed virtual override void OfficeOpenXml.IRangeID.set_RangeID(ulong value);
    internal void Clone(ExcelWorksheet added);
}
public class OfficeOpenXml.ExcelSheetProtection : XmlHelper {
    private static string _isProtectedPath;
    private static string _allowSelectLockedCellsPath;
    private static string _allowSelectUnlockedCellsPath;
    private static string _allowObjectPath;
    private static string _allowScenariosPath;
    private static string _allowFormatCellsPath;
    private static string _allowFormatColumnsPath;
    private static string _allowFormatRowsPath;
    private static string _allowInsertColumnsPath;
    private static string _allowInsertRowsPath;
    private static string _allowInsertHyperlinksPath;
    private static string _allowDeleteColumns;
    private static string _allowDeleteRowsPath;
    private static string _allowSortPath;
    private static string _allowAutoFilterPath;
    private static string _allowPivotTablesPath;
    private static string _passwordPath;
    public bool IsProtected { get; public set; }
    public bool AllowSelectLockedCells { get; public set; }
    public bool AllowSelectUnlockedCells { get; public set; }
    public bool AllowEditObject { get; public set; }
    public bool AllowEditScenarios { get; public set; }
    public bool AllowFormatCells { get; public set; }
    public bool AllowFormatColumns { get; public set; }
    public bool AllowFormatRows { get; public set; }
    public bool AllowInsertColumns { get; public set; }
    public bool AllowInsertRows { get; public set; }
    public bool AllowInsertHyperlinks { get; public set; }
    public bool AllowDeleteColumns { get; public set; }
    public bool AllowDeleteRows { get; public set; }
    public bool AllowSort { get; public set; }
    public bool AllowAutoFilter { get; public set; }
    public bool AllowPivotTables { get; public set; }
    internal ExcelSheetProtection(XmlNamespaceManager nsm, XmlNode topNode, ExcelWorksheet ws);
    public bool get_IsProtected();
    public void set_IsProtected(bool value);
    public bool get_AllowSelectLockedCells();
    public void set_AllowSelectLockedCells(bool value);
    public bool get_AllowSelectUnlockedCells();
    public void set_AllowSelectUnlockedCells(bool value);
    public bool get_AllowEditObject();
    public void set_AllowEditObject(bool value);
    public bool get_AllowEditScenarios();
    public void set_AllowEditScenarios(bool value);
    public bool get_AllowFormatCells();
    public void set_AllowFormatCells(bool value);
    public bool get_AllowFormatColumns();
    public void set_AllowFormatColumns(bool value);
    public bool get_AllowFormatRows();
    public void set_AllowFormatRows(bool value);
    public bool get_AllowInsertColumns();
    public void set_AllowInsertColumns(bool value);
    public bool get_AllowInsertRows();
    public void set_AllowInsertRows(bool value);
    public bool get_AllowInsertHyperlinks();
    public void set_AllowInsertHyperlinks(bool value);
    public bool get_AllowDeleteColumns();
    public void set_AllowDeleteColumns(bool value);
    public bool get_AllowDeleteRows();
    public void set_AllowDeleteRows(bool value);
    public bool get_AllowSort();
    public void set_AllowSort(bool value);
    public bool get_AllowAutoFilter();
    public void set_AllowAutoFilter(bool value);
    public bool get_AllowPivotTables();
    public void set_AllowPivotTables(bool value);
    public void SetPassword(string Password);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.ExcelStyleCollection`1 : object {
    private bool _setNextIdManual;
    [CompilerGeneratedAttribute]
private XmlNode <TopNode>k__BackingField;
    internal List`1<T> _list;
    private Dictionary`2<string, int> _dic;
    internal int NextId;
    public XmlNode TopNode { get; public set; }
    public T Item { get; }
    public int Count { get; }
    public ExcelStyleCollection`1(bool SetNextIdManual);
    [CompilerGeneratedAttribute]
public XmlNode get_TopNode();
    [CompilerGeneratedAttribute]
public void set_TopNode(XmlNode value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T get_Item(int PositionID);
    public int get_Count();
    internal int Add(string key, T item);
    internal bool FindByID(string key, T& obj);
    internal int FindIndexByID(string key);
    internal bool ExistsKey(string key);
    internal void Sort(Comparison`1<T> c);
}
public class OfficeOpenXml.ExcelStyles : XmlHelper {
    private static string NumberFormatsPath;
    private static string FontsPath;
    private static string FillsPath;
    private static string BordersPath;
    private static string CellStyleXfsPath;
    private static string CellXfsPath;
    private static string CellStylesPath;
    private static string dxfsPath;
    private XmlDocument _styleXml;
    private ExcelWorkbook _wb;
    private XmlNamespaceManager _nameSpaceManager;
    internal int _nextDfxNumFmtID;
    public ExcelStyleCollection`1<ExcelNumberFormatXml> NumberFormats;
    public ExcelStyleCollection`1<ExcelFontXml> Fonts;
    public ExcelStyleCollection`1<ExcelFillXml> Fills;
    public ExcelStyleCollection`1<ExcelBorderXml> Borders;
    public ExcelStyleCollection`1<ExcelXfs> CellStyleXfs;
    public ExcelStyleCollection`1<ExcelXfs> CellXfs;
    public ExcelStyleCollection`1<ExcelNamedStyleXml> NamedStyles;
    public ExcelStyleCollection`1<ExcelDxfStyleConditionalFormatting> Dxfs;
    internal string Id { get; }
    internal ExcelStyles(XmlNamespaceManager NameSpaceManager, XmlDocument xml, ExcelWorkbook wb);
    private void LoadFromDocument();
    internal ExcelStyle GetStyleObject(int Id, int PositionID, string Address);
    internal int PropertyChange(StyleBase sender, StyleChangeEventArgs e);
    private void SetStyleAddress(StyleBase sender, StyleChangeEventArgs e, ExcelAddressBase address, ExcelWorksheet ws, Dictionary`2& styleCashe);
    private void AddNewStyleColumn(StyleBase sender, StyleChangeEventArgs e, ExcelWorksheet ws, Dictionary`2<int, int> styleCashe, ExcelColumn column, int s);
    internal int GetStyleId(ExcelWorksheet ws, int row, int col);
    internal int NamedStylePropertyChange(StyleBase sender, StyleChangeEventArgs e);
    internal string get_Id();
    public ExcelNamedStyleXml CreateNamedStyle(string name);
    public ExcelNamedStyleXml CreateNamedStyle(string name, ExcelStyle Template);
    public void UpdateXml();
    private void AddNamedStyle(int id, XmlNode styleXfsNode, XmlNode cellXfsNode, ExcelNamedStyleXml style);
    private void RemoveUnusedStyles();
    internal int GetStyleIdFromName(string Name);
    private int GetXmlNodeInt(XmlNode node);
    private string GetXmlNode(XmlNode node);
    internal int CloneStyle(ExcelStyles style, int styleID);
    internal int CloneStyle(ExcelStyles style, int styleID, bool isNamedStyle);
    internal int CloneStyle(ExcelStyles style, int styleID, bool isNamedStyle, bool allwaysAdd);
}
public class OfficeOpenXml.ExcelTableAddress : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColumnSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAll>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTotals>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsThisRow>k__BackingField;
    public string Name { get; public set; }
    public string ColumnSpan { get; public set; }
    public bool IsAll { get; public set; }
    public bool IsHeader { get; public set; }
    public bool IsData { get; public set; }
    public bool IsTotals { get; public set; }
    public bool IsThisRow { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ColumnSpan();
    [CompilerGeneratedAttribute]
public void set_ColumnSpan(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAll();
    [CompilerGeneratedAttribute]
public void set_IsAll(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsHeader();
    [CompilerGeneratedAttribute]
public void set_IsHeader(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsData();
    [CompilerGeneratedAttribute]
public void set_IsData(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsTotals();
    [CompilerGeneratedAttribute]
public void set_IsTotals(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsThisRow();
    [CompilerGeneratedAttribute]
public void set_IsThisRow(bool value);
}
public class OfficeOpenXml.ExcelTextFormat : object {
    [CompilerGeneratedAttribute]
private char <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private char <TextQualifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EOL>k__BackingField;
    [CompilerGeneratedAttribute]
private eDataTypes[] <DataTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SkipLinesBeginning>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SkipLinesEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public char Delimiter { get; public set; }
    public char TextQualifier { get; public set; }
    public string EOL { get; public set; }
    public eDataTypes[] DataTypes { get; public set; }
    public CultureInfo Culture { get; public set; }
    public int SkipLinesBeginning { get; public set; }
    public int SkipLinesEnd { get; public set; }
    public Encoding Encoding { get; public set; }
    [CompilerGeneratedAttribute]
public char get_Delimiter();
    [CompilerGeneratedAttribute]
public void set_Delimiter(char value);
    [CompilerGeneratedAttribute]
public char get_TextQualifier();
    [CompilerGeneratedAttribute]
public void set_TextQualifier(char value);
    [CompilerGeneratedAttribute]
public string get_EOL();
    [CompilerGeneratedAttribute]
public void set_EOL(string value);
    [CompilerGeneratedAttribute]
public eDataTypes[] get_DataTypes();
    [CompilerGeneratedAttribute]
public void set_DataTypes(eDataTypes[] value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
public int get_SkipLinesBeginning();
    [CompilerGeneratedAttribute]
public void set_SkipLinesBeginning(int value);
    [CompilerGeneratedAttribute]
public int get_SkipLinesEnd();
    [CompilerGeneratedAttribute]
public void set_SkipLinesEnd(int value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
}
public class OfficeOpenXml.ExcelWorkbook : XmlHelper {
    internal ExcelPackage _package;
    private ExcelWorksheets _worksheets;
    private OfficeProperties _properties;
    private ExcelStyles _styles;
    internal Dictionary`2<string, SharedStringItem> _sharedStrings;
    internal List`1<SharedStringItem> _sharedStringsList;
    internal ExcelNamedRangeCollection _names;
    internal int _nextDrawingID;
    internal int _nextTableID;
    internal int _nextPivotTableID;
    internal XmlNamespaceManager _namespaceManager;
    internal FormulaParser _formulaParser;
    internal FormulaParserManager _parserManager;
    internal CellStore`1<List`1<Token>> _formulaTokens;
    private decimal _standardFontWidth;
    private string _fontID;
    private ExcelProtection _protection;
    private ExcelWorkbookView _view;
    private ExcelVbaProject _vba;
    [CompilerGeneratedAttribute]
private Uri <WorkbookUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <StylesUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SharedStringsUri>k__BackingField;
    private XmlDocument _workbookXml;
    private static string codeModuleNamePath;
    private static string date1904Path;
    internal static double date1904Offset;
    private Nullable`1<bool> date1904Cache;
    private XmlDocument _stylesXml;
    private string CALC_MODE_PATH;
    private static string FULL_CALC_ON_LOAD_PATH;
    internal List`1<string> _externalReferences;
    public ExcelWorksheets Worksheets { get; }
    public ExcelNamedRangeCollection Names { get; }
    internal FormulaParser FormulaParser { get; }
    public FormulaParserManager FormulaParserManager { get; }
    public decimal MaxFontWidth { get; public set; }
    public ExcelProtection Protection { get; }
    public ExcelWorkbookView View { get; }
    public ExcelVbaProject VbaProject { get; }
    internal Uri WorkbookUri { get; private set; }
    internal Uri StylesUri { get; private set; }
    internal Uri SharedStringsUri { get; private set; }
    internal ZipPackagePart Part { get; }
    public XmlDocument WorkbookXml { get; }
    internal string CodeModuleName { get; internal set; }
    public ExcelVBAModule CodeModule { get; }
    public bool Date1904 { get; public set; }
    public XmlDocument StylesXml { get; public set; }
    public ExcelStyles Styles { get; }
    public OfficeProperties Properties { get; }
    public ExcelCalcMode CalcMode { get; public set; }
    public bool FullCalcOnLoad { get; public set; }
    internal ExcelWorkbook(ExcelPackage package, XmlNamespaceManager namespaceManager);
    private void GetSharedStrings();
    internal void GetDefinedNames();
    public ExcelWorksheets get_Worksheets();
    public ExcelNamedRangeCollection get_Names();
    internal FormulaParser get_FormulaParser();
    public FormulaParserManager get_FormulaParserManager();
    public decimal get_MaxFontWidth();
    public void set_MaxFontWidth(decimal value);
    internal static decimal GetWidthPixels(string fontName, float fontSize);
    public ExcelProtection get_Protection();
    public ExcelWorkbookView get_View();
    public ExcelVbaProject get_VbaProject();
    public void CreateVBAProject();
    [CompilerGeneratedAttribute]
internal Uri get_WorkbookUri();
    [CompilerGeneratedAttribute]
private void set_WorkbookUri(Uri value);
    [CompilerGeneratedAttribute]
internal Uri get_StylesUri();
    [CompilerGeneratedAttribute]
private void set_StylesUri(Uri value);
    [CompilerGeneratedAttribute]
internal Uri get_SharedStringsUri();
    [CompilerGeneratedAttribute]
private void set_SharedStringsUri(Uri value);
    internal ZipPackagePart get_Part();
    public XmlDocument get_WorkbookXml();
    internal string get_CodeModuleName();
    internal void set_CodeModuleName(string value);
    internal void CodeNameChange(string value);
    public ExcelVBAModule get_CodeModule();
    public bool get_Date1904();
    public void set_Date1904(bool value);
    private void CreateWorkbookXml(XmlNamespaceManager namespaceManager);
    public XmlDocument get_StylesXml();
    public void set_StylesXml(XmlDocument value);
    public ExcelStyles get_Styles();
    public OfficeProperties get_Properties();
    public ExcelCalcMode get_CalcMode();
    public void set_CalcMode(ExcelCalcMode value);
    public bool get_FullCalcOnLoad();
    public void set_FullCalcOnLoad(bool value);
    internal void Save();
    private void DeleteCalcChain();
    private void ValidateDataValidations();
    private void SaveSharedStringHandler(ZipOutputStream stream, CompressionLevel compressionLevel, string fileName);
    private void UpdateDefinedNamesXml();
    private void SetNameElement(ExcelNamedRange name, XmlElement elem);
    private bool ExistsNames();
    internal bool ExistsTableName(string Name);
    internal bool ExistsPivotTableName(string Name);
    internal void AddPivotTable(string cacheID, Uri defUri);
    internal void GetExternalReferences();
    public sealed virtual void Dispose();
    internal void ReadAllTables();
}
public class OfficeOpenXml.ExcelWorkbookView : XmlHelper {
    private static string LEFT_PATH;
    private static string TOP_PATH;
    private static string WIDTH_PATH;
    private static string HEIGHT_PATH;
    private static string MINIMIZED_PATH;
    private static string SHOWVERTICALSCROLL_PATH;
    private static string SHOWHORIZONTALSCR_PATH;
    private static string SHOWSHEETTABS_PATH;
    private static string ACTIVETAB_PATH;
    public int Left { get; internal set; }
    public int Top { get; internal set; }
    public int Width { get; internal set; }
    public int Height { get; internal set; }
    public bool Minimized { get; public set; }
    public bool ShowVerticalScrollBar { get; public set; }
    public bool ShowHorizontalScrollBar { get; public set; }
    public bool ShowSheetTabs { get; public set; }
    public int ActiveTab { get; public set; }
    internal ExcelWorkbookView(XmlNamespaceManager ns, XmlNode node, ExcelWorkbook wb);
    public int get_Left();
    internal void set_Left(int value);
    public int get_Top();
    internal void set_Top(int value);
    public int get_Width();
    internal void set_Width(int value);
    public int get_Height();
    internal void set_Height(int value);
    public bool get_Minimized();
    public void set_Minimized(bool value);
    public bool get_ShowVerticalScrollBar();
    public void set_ShowVerticalScrollBar(bool value);
    public bool get_ShowHorizontalScrollBar();
    public void set_ShowHorizontalScrollBar(bool value);
    public bool get_ShowSheetTabs();
    public void set_ShowSheetTabs(bool value);
    public void SetWindowSize(int left, int top, int width, int height);
    public int get_ActiveTab();
    public void set_ActiveTab(int value);
}
public class OfficeOpenXml.ExcelWorksheet : XmlHelper {
    internal CellStore`1<ExcelCoreValue> _values;
    internal CellStore`1<object> _formulas;
    internal FlagCellStore _flags;
    internal CellStore`1<List`1<Token>> _formulaTokens;
    internal CellStore`1<Uri> _hyperLinks;
    internal CellStore`1<int> _commentsStore;
    internal Dictionary`2<int, Formulas> _sharedFormulas;
    internal int _minCol;
    internal int _maxCol;
    internal ExcelPackage _package;
    private Uri _worksheetUri;
    private string _name;
    private int _sheetID;
    private int _positionID;
    private string _relationshipID;
    private XmlDocument _worksheetXml;
    internal ExcelWorksheetView _sheetView;
    internal ExcelHeaderFooter _headerFooter;
    internal ExcelNamedRangeCollection _names;
    private double _defaultRowHeight;
    private static string outLineSummaryBelowPath;
    private static string outLineSummaryRightPath;
    private static string outLineApplyStylePath;
    private static string tabColorPath;
    private static string codeModuleNamePath;
    internal ExcelVmlDrawingCommentCollection _vmlDrawings;
    internal ExcelCommentCollection _comments;
    private static int BLOCKSIZE;
    private MergeCellsCollection _mergedCells;
    private Dictionary`2<int, int> columnStyles;
    private ExcelSheetProtection _protection;
    private ExcelProtectedRangeCollection _protectedRanges;
    private ExcelDrawings _drawings;
    private ExcelTableCollection _tables;
    private ExcelPivotTableCollection _pivotTables;
    private ExcelConditionalFormattingCollection _conditionalFormatting;
    private ExcelDataValidationCollection _dataValidation;
    private ExcelBackgroundImage _backgroundImage;
    private static SetValueDelegate<ExcelCoreValue> _setValueInnerUpdateDelegate;
    internal Uri WorksheetUri { get; }
    internal ZipPackagePart Part { get; }
    internal string RelationshipID { get; }
    internal int SheetID { get; }
    internal int PositionID { get; internal set; }
    public int Index { get; }
    public ExcelAddressBase AutoFilterAddress { get; internal set; }
    public ExcelWorksheetView View { get; }
    public string Name { get; public set; }
    public ExcelNamedRangeCollection Names { get; }
    public eWorkSheetHidden Hidden { get; public set; }
    public double DefaultRowHeight { get; public set; }
    public bool CustomHeight { get; public set; }
    public double DefaultColWidth { get; public set; }
    public bool OutLineSummaryBelow { get; public set; }
    public bool OutLineSummaryRight { get; public set; }
    public bool OutLineApplyStyle { get; public set; }
    public Color TabColor { get; public set; }
    internal string CodeModuleName { get; internal set; }
    public ExcelVBAModule CodeModule { get; }
    public XmlDocument WorksheetXml { get; }
    internal ExcelVmlDrawingCommentCollection VmlDrawingsComments { get; }
    public ExcelCommentCollection Comments { get; }
    public ExcelHeaderFooter HeaderFooter { get; }
    public ExcelPrinterSettings PrinterSettings { get; }
    public ExcelRange Cells { get; }
    public ExcelRange SelectedRange { get; }
    public MergeCellsCollection MergedCells { get; }
    public ExcelAddressBase Dimension { get; }
    public ExcelSheetProtection Protection { get; }
    public ExcelProtectedRangeCollection ProtectedRanges { get; }
    public ExcelDrawings Drawings { get; }
    public ExcelTableCollection Tables { get; }
    public ExcelPivotTableCollection PivotTables { get; }
    public ExcelConditionalFormattingCollection ConditionalFormatting { get; }
    public ExcelDataValidationCollection DataValidations { get; }
    public ExcelBackgroundImage BackgroundImage { get; }
    public ExcelWorkbook Workbook { get; }
    public ExcelWorksheet(XmlNamespaceManager ns, ExcelPackage excelPackage, string relID, Uri uriWorksheet, string sheetName, int sheetID, int positionID, eWorkSheetHidden hide);
    private static ExcelWorksheet();
    internal Uri get_WorksheetUri();
    internal ZipPackagePart get_Part();
    internal string get_RelationshipID();
    internal int get_SheetID();
    internal int get_PositionID();
    internal void set_PositionID(int value);
    public int get_Index();
    public ExcelAddressBase get_AutoFilterAddress();
    internal void set_AutoFilterAddress(ExcelAddressBase value);
    internal void CheckSheetType();
    public ExcelWorksheetView get_View();
    public string get_Name();
    public void set_Name(string value);
    private void ChangeNames(string value);
    public ExcelNamedRangeCollection get_Names();
    public eWorkSheetHidden get_Hidden();
    public void set_Hidden(eWorkSheetHidden value);
    public double get_DefaultRowHeight();
    public void set_DefaultRowHeight(double value);
    private double GetRowHeightFromNormalStyle();
    public bool get_CustomHeight();
    public void set_CustomHeight(bool value);
    public double get_DefaultColWidth();
    public void set_DefaultColWidth(double value);
    public bool get_OutLineSummaryBelow();
    public void set_OutLineSummaryBelow(bool value);
    public bool get_OutLineSummaryRight();
    public void set_OutLineSummaryRight(bool value);
    public bool get_OutLineApplyStyle();
    public void set_OutLineApplyStyle(bool value);
    public Color get_TabColor();
    public void set_TabColor(Color value);
    internal string get_CodeModuleName();
    internal void set_CodeModuleName(string value);
    internal void CodeNameChange(string value);
    public ExcelVBAModule get_CodeModule();
    public XmlDocument get_WorksheetXml();
    internal ExcelVmlDrawingCommentCollection get_VmlDrawingsComments();
    public ExcelCommentCollection get_Comments();
    private void CreateVmlCollection();
    private void CreateXml();
    private int GetAttributeLength(XmlTextReader xr);
    private void LoadRowPageBreakes(XmlTextReader xr);
    private void LoadColPageBreakes(XmlTextReader xr);
    private void ClearNodes();
    private string GetWorkSheetXml(Stream stream, long start, long end, Encoding& encoding);
    private void GetBlockPos(string xml, string tag, Int32& start, Int32& end);
    private bool ReadUntil(XmlTextReader xr, String[] tagName);
    private void LoadColumns(XmlTextReader xr);
    private static bool ReadXmlReaderUntil(XmlTextReader xr, string nodeText, string altNode);
    private void LoadHyperLinks(XmlTextReader xr);
    private void LoadCells(XmlTextReader xr);
    private bool DoAddRow(XmlTextReader xr);
    private void LoadMergeCells(XmlTextReader xr);
    private void UpdateMergedCells(StreamWriter sw);
    private RowInternal AddRow(XmlTextReader xr, int row);
    private void SetValueFromXml(XmlTextReader xr, string type, int styleID, int row, int col);
    private object GetErrorType(string v);
    public ExcelHeaderFooter get_HeaderFooter();
    public ExcelPrinterSettings get_PrinterSettings();
    public ExcelRange get_Cells();
    public ExcelRange get_SelectedRange();
    public MergeCellsCollection get_MergedCells();
    public ExcelRow Row(int row);
    public ExcelColumn Column(int col);
    public virtual string ToString();
    internal ExcelColumn CopyColumn(ExcelColumn c, int col, int maxCol);
    public void Select();
    public void Select(string Address);
    public void Select(string Address, bool SelectSheet);
    public void Select(ExcelAddress Address);
    public void Select(ExcelAddress Address, bool SelectSheet);
    public void InsertRow(int rowFrom, int rows);
    public void InsertRow(int rowFrom, int rows, int copyStylesFromRow);
    public void InsertColumn(int columnFrom, int columns);
    public void InsertColumn(int columnFrom, int columns, int copyStylesFromColumn);
    private static void InsertTableColumns(int columnFrom, int columns, ExcelTable tbl);
    private void FixMergedCellsRow(int row, int rows, bool delete);
    private void FixMergedCellsColumn(int column, int columns, bool delete);
    private void FixSharedFormulasRows(int position, int rows);
    private void AddFormulas(List`1<Formulas> added, int position, int rows);
    private void UpdateSharedFormulaRow(Formulas& formula, int startRow, int rows, List`1& newFormulas);
    public void DeleteRow(int row);
    public void DeleteRow(int rowFrom, int rows);
    public void DeleteColumn(int column);
    public void DeleteColumn(int columnFrom, int columns);
    internal void AdjustFormulasRow(int rowFrom, int rows);
    internal void AdjustFormulasColumn(int columnFrom, int columns);
    public void DeleteRow(int rowFrom, int rows, bool shiftOtherRowsUp);
    public object GetValue(int Row, int Column);
    public T GetValue(int Row, int Column);
    public void SetValue(int Row, int Column, object Value);
    public void SetValue(string Address, object Value);
    public int GetMergeCellId(int row, int column);
    private void UpdateCrossSheetReferences(string sheetWhoseReferencesShouldBeUpdated, int rowFrom, int rows, int columnFrom, int columns);
    private void UpdateCrossSheetReferenceNames(string oldName, string newName);
    internal void Save();
    internal void SaveHandler(ZipOutputStream stream, CompressionLevel compressionLevel, string fileName);
    private void DeletePrinterSettings();
    private void SaveComments();
    private void SaveTables();
    internal void SetTableTotalFunction(ExcelTable tbl, ExcelTableColumn col, int colNum);
    internal void SetFormula(int row, int col, object value);
    private void SavePivotTables();
    private string GetNewName(HashSet`1<string> flds, string fldName);
    private static string GetTotalFunction(ExcelTableColumn col, string FunctionNum);
    private void SaveXml(Stream stream);
    private void CleanupMergedCells(MergeCellsCollection _mergedCells);
    private void UpdateColBreaks(StreamWriter sw);
    private void UpdateRowBreaks(StreamWriter sw);
    private void UpdateColumnData(StreamWriter sw);
    private void UpdateRowCellData(StreamWriter sw);
    internal int GetStyleIdDefaultWithMemo(int row, int col);
    private object GetFormulaValue(object v);
    private string GetCellType(object v, bool allowStr);
    private string GetValueForXml(object v);
    private void WriteRow(StringBuilder cache, ExcelStyleCollection`1<ExcelXfs> cellXfs, int prevRow, int row);
    private void WriteRow(StreamWriter sw, ExcelStyleCollection`1<ExcelXfs> cellXfs, int prevRow, int row);
    private void UpdateHyperLinks(StreamWriter sw);
    private XmlNode CreateHyperLinkCollection();
    public ExcelAddressBase get_Dimension();
    public ExcelSheetProtection get_Protection();
    public ExcelProtectedRangeCollection get_ProtectedRanges();
    public ExcelDrawings get_Drawings();
    public ExcelTableCollection get_Tables();
    public ExcelPivotTableCollection get_PivotTables();
    public ExcelConditionalFormattingCollection get_ConditionalFormatting();
    public ExcelDataValidationCollection get_DataValidations();
    internal void ClearValidations();
    public ExcelBackgroundImage get_BackgroundImage();
    internal int GetStyleID(string StyleName);
    public ExcelWorkbook get_Workbook();
    internal int GetMaxShareFunctionIndex(bool isArray);
    internal void SetHFLegacyDrawingRel(string relID);
    internal void RemoveLegacyDrawingRel(string relID);
    internal void UpdateCellsWithDate1904Setting();
    internal string GetFormula(int row, int col);
    internal string GetFormulaR1C1(int row, int col);
    private void DisposeInternal(IDisposable candidateDisposable);
    public sealed virtual void Dispose();
    internal ExcelColumn GetColumn(int column);
    public sealed virtual bool Equals(ExcelWorksheet x, ExcelWorksheet y);
    public sealed virtual int GetHashCode(ExcelWorksheet obj);
    internal object GetValueInner(int row, int col);
    internal int GetStyleInner(int row, int col);
    internal void SetValueInner(int row, int col, object value);
    private static void SetValueInnerUpdate(List`1<ExcelCoreValue> list, int index, object value);
    internal void SetStyleInner(int row, int col, int styleId);
    private void SetStyleInnerUpdate(List`1<ExcelCoreValue> list, int index, object styleId);
    internal void SetRangeValueInner(int fromRow, int fromColumn, int toRow, int toColumn, Object[0...,0...] values);
    private void SetRangeValueUpdate(List`1<ExcelCoreValue> list, int index, int row, int column, object values);
    internal bool ExistsValueInner(int row, int col);
    internal bool ExistsStyleInner(int row, int col);
    internal bool ExistsValueInner(int row, int col, Object& value);
    internal bool ExistsStyleInner(int row, int col, Int32& styleId);
    [CompilerGeneratedAttribute]
private bool <InsertRow>b__133_0(ExcelNamedRange n);
    [CompilerGeneratedAttribute]
private bool <InsertRow>b__133_1(ExcelWorksheet sheet);
    [CompilerGeneratedAttribute]
private bool <InsertColumn>b__135_0(ExcelNamedRange n);
    [CompilerGeneratedAttribute]
private bool <InsertColumn>b__135_1(ExcelWorksheet sheet);
    [CompilerGeneratedAttribute]
private bool <DeleteRow>b__143_0(ExcelNamedRange n);
    [CompilerGeneratedAttribute]
private bool <DeleteColumn>b__145_0(ExcelNamedRange n);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.ExcelWorksheets : XmlHelper {
    private ExcelPackage _pck;
    private Dictionary`2<int, ExcelWorksheet> _worksheets;
    private XmlNamespaceManager _namespaceManager;
    private static string ERR_DUP_WORKSHEET;
    internal static string WORKSHEET_CONTENTTYPE;
    internal static string CHARTSHEET_CONTENTTYPE;
    public int Count { get; }
    public ExcelWorksheet Item { get; }
    public ExcelWorksheet Item { get; }
    internal ExcelWorksheets(ExcelPackage pck, XmlNamespaceManager nsm, XmlNode topNode);
    private eWorkSheetHidden TranslateHidden(string value);
    public int get_Count();
    public sealed virtual IEnumerator`1<ExcelWorksheet> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ExcelWorksheet Add(string Name);
    private ExcelWorksheet AddSheet(string Name, bool isChart, Nullable`1<eChartType> chartType);
    public ExcelWorksheet Add(string Name, ExcelWorksheet Copy);
    public ExcelChartsheet AddChart(string Name, eChartType chartType);
    private void CopySheetNames(ExcelWorksheet Copy, ExcelWorksheet added);
    private void CopyTable(ExcelWorksheet Copy, ExcelWorksheet added);
    private void CopyPivotTable(ExcelWorksheet Copy, ExcelWorksheet added);
    private void CopyHeaderFooterPictures(ExcelWorksheet Copy, ExcelWorksheet added);
    private void CopyText(ExcelHeaderFooterText from, ExcelHeaderFooterText to);
    private void CloneCells(ExcelWorksheet Copy, ExcelWorksheet added);
    private int CopyValues(ExcelWorksheet Copy, ExcelWorksheet added, int row, int col);
    private void CopyComment(ExcelWorksheet Copy, ExcelWorksheet workSheet);
    private void CopyDrawing(ExcelWorksheet Copy, ExcelWorksheet workSheet);
    private void CopyVmlDrawing(ExcelWorksheet origSheet, ExcelWorksheet newSheet);
    private string CreateWorkbookRel(string Name, int sheetID, Uri uriWorksheet, bool isChart);
    private void GetSheetURI(String& Name, Int32& sheetID, Uri& uriWorksheet, bool isChart);
    internal string ValidateFixSheetName(string Name);
    private bool ValidateName(string Name);
    internal XmlDocument CreateNewWorksheet(bool isChart);
    public void Delete(int Index);
    private void DeleteRelationsAndParts(ZipPackagePart part);
    public void Delete(string name);
    public void Delete(ExcelWorksheet Worksheet);
    private void ReindexWorksheetDictionary();
    public ExcelWorksheet get_Item(int PositionID);
    public ExcelWorksheet get_Item(string Name);
    public ExcelWorksheet Copy(string Name, string NewName);
    internal ExcelWorksheet GetBySheetID(int localSheetID);
    private ExcelWorksheet GetByName(string Name);
    public void MoveBefore(string sourceName, string targetName);
    public void MoveBefore(int sourcePositionId, int targetPositionId);
    public void MoveAfter(string sourceName, string targetName);
    public void MoveAfter(int sourcePositionId, int targetPositionId);
    public void MoveToStart(string sourceName);
    public void MoveToStart(int sourcePositionId);
    public void MoveToEnd(string sourceName);
    public void MoveToEnd(int sourcePositionId);
    private void Move(string sourceName, string targetName, bool placeAfter);
    private void Move(int sourcePositionId, int targetPositionId, bool placeAfter);
    private void MoveSheetXmlNode(ExcelWorksheet sourceSheet, ExcelWorksheet targetSheet, bool placeAfter);
    public sealed virtual void Dispose();
}
public class OfficeOpenXml.ExcelWorksheetView : XmlHelper {
    private ExcelWorksheet _worksheet;
    private XmlElement _selectionNode;
    [CompilerGeneratedAttribute]
private ExcelWorksheetPanes[] <Panes>k__BackingField;
    private string _paneNodePath;
    private string _selectionNodePath;
    protected internal XmlElement SheetViewElement { get; }
    private XmlElement SelectionNode { get; }
    public string ActiveCell { get; public set; }
    public string SelectedRange { get; public set; }
    public bool TabSelected { get; public set; }
    public bool TabSelectedMulti { get; public set; }
    public bool PageLayoutView { get; public set; }
    public bool PageBreakView { get; public set; }
    public bool ShowGridLines { get; public set; }
    public bool ShowHeaders { get; public set; }
    public int ZoomScale { get; public set; }
    public bool RightToLeft { get; public set; }
    internal bool WindowProtection { get; internal set; }
    public ExcelWorksheetPanes[] Panes { get; internal set; }
    internal ExcelWorksheetView(XmlNamespaceManager ns, XmlNode node, ExcelWorksheet xlWorksheet);
    private ExcelWorksheetPanes[] LoadPanes();
    protected internal XmlElement get_SheetViewElement();
    private XmlElement get_SelectionNode();
    public string get_ActiveCell();
    public void set_ActiveCell(string value);
    public string get_SelectedRange();
    public void set_SelectedRange(string value);
    private bool IsActiveCellInSelection(ExcelAddressBase ac, ExcelAddressBase sd);
    public bool get_TabSelected();
    public void set_TabSelected(bool value);
    public bool get_TabSelectedMulti();
    public void set_TabSelectedMulti(bool value);
    public void SetTabSelected(bool isSelected, bool allowMultiple);
    public bool get_PageLayoutView();
    public void set_PageLayoutView(bool value);
    public bool get_PageBreakView();
    public void set_PageBreakView(bool value);
    public bool get_ShowGridLines();
    public void set_ShowGridLines(bool value);
    public bool get_ShowHeaders();
    public void set_ShowHeaders(bool value);
    public int get_ZoomScale();
    public void set_ZoomScale(int value);
    public bool get_RightToLeft();
    public void set_RightToLeft(bool value);
    internal bool get_WindowProtection();
    internal void set_WindowProtection(bool value);
    [CompilerGeneratedAttribute]
public ExcelWorksheetPanes[] get_Panes();
    [CompilerGeneratedAttribute]
internal void set_Panes(ExcelWorksheetPanes[] value);
    public void FreezePanes(int Row, int Column);
    private void RemoveSelection();
    public void UnFreezePanes();
}
public static class OfficeOpenXml.FontSize : object {
    public static Dictionary`2<string, Dictionary`2<float, FontSizeInfo>> FontHeights;
    private static FontSize();
}
public class OfficeOpenXml.FontSizeInfo : object {
    [CompilerGeneratedAttribute]
private float <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Width>k__BackingField;
    public float Height { get; public set; }
    public float Width { get; public set; }
    public FontSizeInfo(float height, float width);
    [CompilerGeneratedAttribute]
public float get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(float value);
    [CompilerGeneratedAttribute]
public float get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(float value);
}
internal class OfficeOpenXml.FormulaParsing.DependencyChain : object {
    internal List`1<FormulaCell> list;
    internal Dictionary`2<ulong, int> index;
    internal List`1<int> CalcOrder;
    internal void Add(FormulaCell f);
}
internal static class OfficeOpenXml.FormulaParsing.DependencyChainFactory : object {
    internal static DependencyChain Create(ExcelWorkbook wb, ExcelCalculationOption options);
    internal static DependencyChain Create(ExcelWorksheet ws, ExcelCalculationOption options);
    internal static DependencyChain Create(ExcelWorksheet ws, string Formula, ExcelCalculationOption options);
    private static void GetWorksheetNames(ExcelWorksheet ws, DependencyChain depChain, ExcelCalculationOption options);
    internal static DependencyChain Create(ExcelRangeBase range, ExcelCalculationOption options);
    private static void GetChain(DependencyChain depChain, ILexer lexer, ExcelNamedRange name, ExcelCalculationOption options);
    private static void GetChain(DependencyChain depChain, ILexer lexer, ExcelWorksheet ws, string formula, ExcelCalculationOption options);
    private static void GetChain(DependencyChain depChain, ILexer lexer, ExcelRangeBase Range, ExcelCalculationOption options);
    private static void FollowChain(DependencyChain depChain, ILexer lexer, ExcelWorkbook wb, ExcelWorksheet ws, FormulaCell f, ExcelCalculationOption options);
}
public class OfficeOpenXml.FormulaParsing.EpplusExcelDataProvider : ExcelDataProvider {
    private ExcelPackage _package;
    private ExcelWorksheet _currentWorksheet;
    private RangeAddressFactory _rangeAddressFactory;
    private Dictionary`2<ulong, INameInfo> _names;
    public int ExcelMaxColumns { get; }
    public int ExcelMaxRows { get; }
    public EpplusExcelDataProvider(ExcelPackage package);
    public virtual ExcelNamedRangeCollection GetWorksheetNames(string worksheet);
    public virtual ExcelNamedRangeCollection GetWorkbookNameValues();
    public virtual IRangeInfo GetRange(string worksheet, int fromRow, int fromCol, int toRow, int toCol);
    public virtual IRangeInfo GetRange(string worksheet, int row, int column, string address);
    public virtual IRangeInfo GetRange(string worksheet, string address);
    private ExcelAddress ConvertToA1C1(ExcelAddress addr);
    public virtual INameInfo GetName(string worksheet, string name);
    public virtual IEnumerable`1<object> GetRangeValues(string address);
    public object GetValue(int row, int column);
    public bool IsMerged(int row, int column);
    public bool IsHidden(int row, int column);
    public virtual object GetCellValue(string sheetName, int row, int col);
    public virtual ExcelCellAddress GetDimensionEnd(string worksheet);
    private void SetCurrentWorksheet(ExcelAddressInfo addressInfo);
    private void SetCurrentWorksheet(string worksheetName);
    public virtual void Dispose();
    public virtual int get_ExcelMaxColumns();
    public virtual int get_ExcelMaxRows();
    public virtual string GetRangeFormula(string worksheetName, int row, int column);
    public virtual object GetRangeValue(string worksheetName, int row, int column);
    public virtual string GetFormat(object value, string format);
    public virtual List`1<Token> GetRangeFormulaTokens(string worksheetName, int row, int column);
    public virtual bool IsRowHidden(string worksheetName, int row);
    public virtual void Reset();
}
public class OfficeOpenXml.FormulaParsing.EpplusNameValueProvider : object {
    private ExcelDataProvider _excelDataProvider;
    private ExcelNamedRangeCollection _values;
    public EpplusNameValueProvider(ExcelDataProvider excelDataProvider);
    public virtual bool IsNamedValue(string key, string ws);
    public virtual object GetNamedValue(string key);
    public virtual void Reload();
}
[FlagsAttribute]
public enum OfficeOpenXml.FormulaParsing.Excel.ExcelCellState : Enum {
    public int value__;
    public static ExcelCellState HiddenCell;
    public static ExcelCellState ContainsError;
    public static ExcelCellState IsResultOfSubtotal;
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.ArgumentCollectionUtil : object {
    private DoubleEnumerableArgConverter _doubleEnumerableArgConverter;
    private ObjectEnumerableArgConverter _objectEnumerableArgConverter;
    public ArgumentCollectionUtil(DoubleEnumerableArgConverter doubleEnumerableArgConverter, ObjectEnumerableArgConverter objectEnumerableArgConverter);
    public virtual IEnumerable`1<ExcelDoubleCellValue> ArgsToDoubleEnumerable(bool ignoreHidden, bool ignoreErrors, IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    public virtual IEnumerable`1<object> ArgsToObjectEnumerable(bool ignoreHidden, IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    public virtual double CalculateCollection(IEnumerable`1<FunctionArgument> collection, double result, Func`3<FunctionArgument, double, double> action);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.ArgumentParser : object {
    public abstract virtual object Parse(object obj);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.ArgumentParserFactory : object {
    public virtual ArgumentParser CreateArgumentParser(DataType dataType);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.ArgumentParsers : object {
    private static object _syncRoot;
    private Dictionary`2<DataType, ArgumentParser> _parsers;
    private ArgumentParserFactory _parserFactory;
    public ArgumentParsers(ArgumentParserFactory factory);
    private static ArgumentParsers();
    public ArgumentParser GetParser(DataType dataType);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.BoolArgumentParser : ArgumentParser {
    public virtual object Parse(object obj);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.BuiltInFunctions : FunctionsModule {
}
internal static class OfficeOpenXml.FormulaParsing.Excel.Functions.CellStateHelper : object {
    private static bool IsSubTotal(ICellInfo c);
    internal static bool ShouldIgnore(bool ignoreHiddenValues, ICellInfo c, ParsingContext context);
    internal static bool ShouldIgnore(bool ignoreHiddenValues, FunctionArgument arg, ParsingContext context);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.CollectionFlattener`1 : object {
    public virtual IEnumerable`1<T> FuncArgsToFlatEnumerable(IEnumerable`1<FunctionArgument> arguments, Action`2<FunctionArgument, IList`1<T>> convertFunc);
    private void FuncArgsToFlatEnumerable(IEnumerable`1<FunctionArgument> arguments, List`1<T> argList, Action`2<FunctionArgument, IList`1<T>> convertFunc);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.CompileResultValidator : object {
    private static CompileResultValidator _empty;
    public static CompileResultValidator Empty { get; }
    public abstract virtual void Validate(object obj);
    public static CompileResultValidator get_Empty();
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.CompileResultValidators : object {
    private Dictionary`2<DataType, CompileResultValidator> _validators;
    private CompileResultValidator CreateOrGet(DataType dataType);
    public CompileResultValidator GetValidator(DataType dataType);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.DatabaseFunction : ExcelFunction {
    [CompilerGeneratedAttribute]
private RowMatcher <RowMatcher>k__BackingField;
    protected RowMatcher RowMatcher { get; private set; }
    public DatabaseFunction(RowMatcher rowMatcher);
    [CompilerGeneratedAttribute]
protected RowMatcher get_RowMatcher();
    [CompilerGeneratedAttribute]
private void set_RowMatcher(RowMatcher value);
    protected IEnumerable`1<double> GetMatchingValues(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.Daverage : DatabaseFunction {
    public Daverage(RowMatcher rowMatcher);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.Dcount : ExcelFunction {
    private RowMatcher _rowMatcher;
    public Dcount(RowMatcher rowMatcher);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.DcountA : DatabaseFunction {
    public DcountA(RowMatcher rowMatcher);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private bool ShouldCount(object value);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.Dget : DatabaseFunction {
    public Dget(RowMatcher rowMatcher);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.Dmax : DatabaseFunction {
    public Dmax(RowMatcher rowMatcher);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.Dmin : DatabaseFunction {
    public Dmin(RowMatcher rowMatcher);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.Dsum : DatabaseFunction {
    public Dsum(RowMatcher rowMatcher);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.Dvar : DatabaseFunction {
    public Dvar(RowMatcher rowMatcher);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.Dvarp : DatabaseFunction {
    public Dvarp(RowMatcher rowMatcher);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.ExcelDatabase : object {
    private ExcelDataProvider _dataProvider;
    private int _fromCol;
    private int _toCol;
    private int _fieldRow;
    private int _endRow;
    private string _worksheet;
    private int _rowIndex;
    private List`1<ExcelDatabaseField> _fields;
    public IEnumerable`1<ExcelDatabaseField> Fields { get; }
    public bool HasMoreRows { get; }
    public ExcelDatabase(ExcelDataProvider dataProvider, string range);
    public IEnumerable`1<ExcelDatabaseField> get_Fields();
    private void Initialize();
    private object GetCellValue(int row, int col);
    public bool get_HasMoreRows();
    public ExcelDatabaseRow Read();
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.ExcelDatabaseCriteria : object {
    private ExcelDataProvider _dataProvider;
    private int _fromCol;
    private int _toCol;
    private string _worksheet;
    private int _fieldRow;
    private Dictionary`2<ExcelDatabaseCriteriaField, object> _criterias;
    public IDictionary`2<ExcelDatabaseCriteriaField, object> Items { get; }
    public ExcelDatabaseCriteria(ExcelDataProvider dataProvider, string range);
    private void Initialize();
    public virtual IDictionary`2<ExcelDatabaseCriteriaField, object> get_Items();
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.ExcelDatabaseCriteriaField : object {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FieldIndex>k__BackingField;
    public string FieldName { get; private set; }
    public Nullable`1<int> FieldIndex { get; private set; }
    public ExcelDatabaseCriteriaField(string fieldName);
    public ExcelDatabaseCriteriaField(int fieldIndex);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FieldIndex();
    [CompilerGeneratedAttribute]
private void set_FieldIndex(Nullable`1<int> value);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.ExcelDatabaseField : object {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColIndex>k__BackingField;
    public string FieldName { get; private set; }
    public int ColIndex { get; private set; }
    public ExcelDatabaseField(string fieldName, int colIndex);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public int get_ColIndex();
    [CompilerGeneratedAttribute]
private void set_ColIndex(int value);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.ExcelDatabaseRow : object {
    private Dictionary`2<int, string> _fieldIndexes;
    private Dictionary`2<string, object> _items;
    private int _colIndex;
    public object Item { get; public set; }
    public object Item { get; }
    public object get_Item(string field);
    public void set_Item(string field, object value);
    public object get_Item(int index);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Database.RowMatcher : object {
    private WildCardValueMatcher _wildCardValueMatcher;
    private ExpressionEvaluator _expressionEvaluator;
    public RowMatcher(WildCardValueMatcher wildCardValueMatcher, ExpressionEvaluator expressionEvaluator);
    public bool IsMatch(ExcelDatabaseRow row, ExcelDatabaseCriteria criteria);
    private bool Evaluate(object obj, string expression);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Date : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.DateParsingFunction : ExcelFunction {
    protected DateTime ParseDate(IEnumerable`1<FunctionArgument> arguments, object dateObj);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.DateStringParser : object {
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.DateValue : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    internal CompileResult Execute(string dateString);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Day : DateParsingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Days360 : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private int GetNumWholeMonths(DateTime dt1, DateTime dt2);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Edate : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Eomonth : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Hour : DateParsingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.IsoWeekNum : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private int WeekNumber(DateTime fromDate);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Minute : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Month : DateParsingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Networkdays : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.NetworkdaysIntl : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Now : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Second : DateParsingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Time : TimeBaseFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.TimeBaseFunction : ExcelFunction {
    [CompilerGeneratedAttribute]
private TimeStringParser <TimeStringParser>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SerialNumber>k__BackingField;
    protected TimeStringParser TimeStringParser { get; private set; }
    protected double SerialNumber { get; private set; }
    protected double SecondsInADay { get; }
    [CompilerGeneratedAttribute]
protected TimeStringParser get_TimeStringParser();
    [CompilerGeneratedAttribute]
private void set_TimeStringParser(TimeStringParser value);
    [CompilerGeneratedAttribute]
protected double get_SerialNumber();
    [CompilerGeneratedAttribute]
private void set_SerialNumber(double value);
    public void ValidateAndInitSerialNumber(IEnumerable`1<FunctionArgument> arguments);
    protected double get_SecondsInADay();
    protected double GetTimeSerialNumber(double seconds);
    protected double GetSeconds(double serialNumber);
    protected double GetHour(double serialNumber);
    protected double GetMinute(double serialNumber);
    protected double GetSecond(double serialNumber);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.TimeStringParser : object {
    private static string RegEx24;
    private static string RegEx12;
    private double GetSerialNumber(int hour, int minute, int second);
    private void ValidateValues(int hour, int minute, int second);
    public virtual double Parse(string input);
    public virtual bool CanParse(string input);
    private double InternalParse(string input);
    private double Parse12HourTimeString(string input);
    private double Parse24HourTimeString(string input);
    private static void GetValuesFromString(string input, Int32& hour, Int32& minute, Int32& second);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.TimeValue : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    internal CompileResult Execute(string dateString);
    private double GetTimeValue(DateTime result);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Today : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Weekday : ExcelFunction {
    private static List`1<int> _oneBasedStartOnSunday;
    private static List`1<int> _oneBasedStartOnMonday;
    private static List`1<int> _zeroBasedStartOnSunday;
    private static Weekday();
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private int CalculateDayOfWeek(DateTime dateTime, int returnType);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Weeknum : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Workday : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Workdays.AdditionalHolidayDays : object {
    private FunctionArgument _holidayArg;
    private List`1<DateTime> _holidayDates;
    public IEnumerable`1<DateTime> AdditionalDates { get; }
    public AdditionalHolidayDays(FunctionArgument holidayArg);
    public IEnumerable`1<DateTime> get_AdditionalDates();
    private void Initialize();
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Workdays.HolidayWeekdays : object {
    private List`1<DayOfWeek> _holidayDays;
    public int NumberOfWorkdaysPerWeek { get; }
    public HolidayWeekdays(DayOfWeek[] holidayDays);
    public int get_NumberOfWorkdaysPerWeek();
    public bool IsHolidayWeekday(DateTime dateTime);
    public DateTime AdjustResultWithHolidays(DateTime resultDate, IEnumerable`1<FunctionArgument> arguments);
    public DateTime GetNextWorkday(DateTime date, WorkdayCalculationDirection direction);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Workdays.HolidayWeekdaysFactory : object {
    private DayOfWeek[] _dayOfWeekArray;
    public HolidayWeekdays Create(string weekdays);
    public HolidayWeekdays Create(int code);
}
public enum OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Workdays.WorkdayCalculationDirection : Enum {
    public int value__;
    public static WorkdayCalculationDirection Forward;
    public static WorkdayCalculationDirection Backward;
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Workdays.WorkdayCalculator : object {
    private HolidayWeekdays _holidayWeekdays;
    public WorkdayCalculator(HolidayWeekdays holidayWeekdays);
    public WorkdayCalculatorResult CalculateNumberOfWorkdays(DateTime startDate, DateTime endDate);
    public WorkdayCalculatorResult CalculateWorkday(DateTime startDate, int nWorkDays);
    public WorkdayCalculatorResult ReduceWorkdaysWithHolidays(WorkdayCalculatorResult calculatedResult, FunctionArgument holidayArgument);
    public WorkdayCalculatorResult AdjustResultWithHolidays(WorkdayCalculatorResult calculatedResult, FunctionArgument holidayArgument);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Workdays.WorkdayCalculatorResult : object {
    [CompilerGeneratedAttribute]
private int <NumberOfWorkdays>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartDate>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndDate>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkdayCalculationDirection <Direction>k__BackingField;
    public int NumberOfWorkdays { get; }
    public DateTime StartDate { get; }
    public DateTime EndDate { get; }
    public WorkdayCalculationDirection Direction { get; public set; }
    public WorkdayCalculatorResult(int numberOfWorkdays, DateTime startDate, DateTime endDate, WorkdayCalculationDirection direction);
    [CompilerGeneratedAttribute]
public int get_NumberOfWorkdays();
    [CompilerGeneratedAttribute]
public DateTime get_StartDate();
    [CompilerGeneratedAttribute]
public DateTime get_EndDate();
    [CompilerGeneratedAttribute]
public WorkdayCalculationDirection get_Direction();
    [CompilerGeneratedAttribute]
public void set_Direction(WorkdayCalculationDirection value);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Year : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DateTime.Yearfrac : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private double CalculateAcutalYear(DateTime dt1, DateTime dt2);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DecimalCompileResultValidator : CompileResultValidator {
    public virtual void Validate(object obj);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DoubleArgumentParser : ArgumentParser {
    public virtual object Parse(object obj);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.DoubleEnumerableArgConverter : CollectionFlattener`1<ExcelDoubleCellValue> {
    public virtual IEnumerable`1<ExcelDoubleCellValue> ConvertArgs(bool ignoreHidden, bool ignoreErrors, IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    public virtual IEnumerable`1<ExcelDoubleCellValue> ConvertArgsIncludingOtherTypes(IEnumerable`1<FunctionArgument> arguments);
}
internal class OfficeOpenXml.FormulaParsing.Excel.Functions.EmptyCompileResultValidator : CompileResultValidator {
    public virtual void Validate(object obj);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.ErrorHandlingFunction : ExcelFunction {
    public bool IsErrorHandlingFunction { get; }
    public virtual bool get_IsErrorHandlingFunction();
    public abstract virtual CompileResult HandleError(string errorCode);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelDoubleCellValue : ValueType {
    public Nullable`1<int> CellRow;
    public double Value;
    public ExcelDoubleCellValue(double val);
    public ExcelDoubleCellValue(double val, int cellRow);
    public static double op_Implicit(ExcelDoubleCellValue d);
    public static ExcelDoubleCellValue op_Implicit(double d);
    public sealed virtual int CompareTo(ExcelDoubleCellValue other);
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public static bool op_Equality(ExcelDoubleCellValue a, ExcelDoubleCellValue b);
    public static bool op_Equality(ExcelDoubleCellValue a, double b);
    public static bool op_Inequality(ExcelDoubleCellValue a, ExcelDoubleCellValue b);
    public static bool op_Inequality(ExcelDoubleCellValue a, double b);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.ExcelFunction : object {
    private ArgumentCollectionUtil _argumentCollectionUtil;
    private ArgumentParsers _argumentParsers;
    private CompileResultValidators _compileResultValidators;
    [CompilerGeneratedAttribute]
private bool <SkipArgumentEvaluation>k__BackingField;
    public bool IsLookupFuction { get; }
    public bool IsErrorHandlingFunction { get; }
    public bool SkipArgumentEvaluation { get; public set; }
    public ExcelFunction(ArgumentCollectionUtil argumentCollectionUtil, ArgumentParsers argumentParsers, CompileResultValidators compileResultValidators);
    public abstract virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    public virtual void BeforeInvoke(ParsingContext context);
    public virtual bool get_IsLookupFuction();
    public virtual bool get_IsErrorHandlingFunction();
    [CompilerGeneratedAttribute]
public bool get_SkipArgumentEvaluation();
    [CompilerGeneratedAttribute]
public void set_SkipArgumentEvaluation(bool value);
    protected object GetFirstValue(IEnumerable`1<FunctionArgument> val);
    protected void ValidateArguments(IEnumerable`1<FunctionArgument> arguments, int minLength, eErrorType errorTypeToThrow);
    protected void ValidateArguments(IEnumerable`1<FunctionArgument> arguments, int minLength);
    protected string ArgToAddress(IEnumerable`1<FunctionArgument> arguments, int index);
    protected int ArgToInt(IEnumerable`1<FunctionArgument> arguments, int index);
    protected string ArgToString(IEnumerable`1<FunctionArgument> arguments, int index);
    protected double ArgToDecimal(object obj);
    protected double ArgToDecimal(IEnumerable`1<FunctionArgument> arguments, int index);
    protected double Divide(double left, double right);
    protected bool IsNumericString(object value);
    protected bool ArgToBool(IEnumerable`1<FunctionArgument> arguments, int index);
    protected void ThrowArgumentExceptionIf(Func`1<bool> condition, string message);
    protected void ThrowArgumentExceptionIf(Func`1<bool> condition, string message, Object[] formats);
    protected void ThrowExcelErrorValueException(eErrorType errorType);
    protected void ThrowExcelErrorValueExceptionIf(Func`1<bool> condition, eErrorType errorType);
    protected bool IsNumeric(object val);
    protected bool AreEqual(double d1, double d2);
    protected virtual IEnumerable`1<ExcelDoubleCellValue> ArgsToDoubleEnumerable(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    protected virtual IEnumerable`1<ExcelDoubleCellValue> ArgsToDoubleEnumerable(bool ignoreHiddenCells, bool ignoreErrors, IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    protected virtual IEnumerable`1<ExcelDoubleCellValue> ArgsToDoubleEnumerable(bool ignoreHiddenCells, IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    protected virtual IEnumerable`1<double> ArgsToDoubleEnumerableZeroPadded(bool ignoreHiddenCells, IRangeInfo rangeInfo, ParsingContext context);
    protected virtual IEnumerable`1<object> ArgsToObjectEnumerable(bool ignoreHiddenCells, IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    protected CompileResult CreateResult(object result, DataType dataType);
    protected virtual double CalculateCollection(IEnumerable`1<FunctionArgument> collection, double result, Func`3<FunctionArgument, double, double> action);
    protected void CheckForAndHandleExcelError(FunctionArgument arg);
    protected void CheckForAndHandleExcelError(ICellInfo cell);
    protected CompileResult GetResultByObject(object result);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionArgument : object {
    private ExcelCellState _excelCellState;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private DataType <DataType>k__BackingField;
    public object Value { get; private set; }
    public DataType DataType { get; }
    public Type Type { get; }
    public bool IsExcelRange { get; }
    public bool ValueIsExcelError { get; }
    public ExcelErrorValue ValueAsExcelErrorValue { get; }
    public IRangeInfo ValueAsRangeInfo { get; }
    public object ValueFirst { get; }
    public FunctionArgument(object val);
    public FunctionArgument(object val, DataType dataType);
    public void SetExcelStateFlag(ExcelCellState state);
    public bool ExcelStateFlagIsSet(ExcelCellState state);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public DataType get_DataType();
    public Type get_Type();
    public bool get_IsExcelRange();
    public bool get_ValueIsExcelError();
    public ExcelErrorValue get_ValueAsExcelErrorValue();
    public IRangeInfo get_ValueAsRangeInfo();
    public object get_ValueFirst();
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionNameProvider : object {
    public static FunctionNameProvider Empty { get; }
    public static FunctionNameProvider get_Empty();
    public virtual bool IsFunctionName(string name);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionRepository : object {
    private Dictionary`2<Type, FunctionCompiler> _customCompilers;
    private Dictionary`2<string, ExcelFunction> _functions;
    public Dictionary`2<Type, FunctionCompiler> CustomCompilers { get; }
    public IEnumerable`1<string> FunctionNames { get; }
    public Dictionary`2<Type, FunctionCompiler> get_CustomCompilers();
    public static FunctionRepository Create();
    public virtual void LoadModule(IFunctionModule module);
    public virtual ExcelFunction GetFunction(string name);
    public virtual void Clear();
    public sealed virtual bool IsFunctionName(string name);
    public IEnumerable`1<string> get_FunctionNames();
    public void AddOrReplaceFunction(string functionName, ExcelFunction functionImpl);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.FunctionsModule : object {
    private Dictionary`2<string, ExcelFunction> _functions;
    private Dictionary`2<Type, FunctionCompiler> _customCompilers;
    public IDictionary`2<string, ExcelFunction> Functions { get; }
    public IDictionary`2<Type, FunctionCompiler> CustomCompilers { get; }
    public sealed virtual IDictionary`2<string, ExcelFunction> get_Functions();
    public sealed virtual IDictionary`2<Type, FunctionCompiler> get_CustomCompilers();
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.HiddenValuesHandlingFunction : ExcelFunction {
    [CompilerGeneratedAttribute]
private bool <IgnoreHiddenValues>k__BackingField;
    public bool IgnoreHiddenValues { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IgnoreHiddenValues();
    [CompilerGeneratedAttribute]
public void set_IgnoreHiddenValues(bool value);
    protected virtual IEnumerable`1<ExcelDoubleCellValue> ArgsToDoubleEnumerable(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    protected IEnumerable`1<ExcelDoubleCellValue> ArgsToDoubleEnumerable(IEnumerable`1<FunctionArgument> arguments, ParsingContext context, bool ignoreErrors);
    protected bool ShouldIgnore(ICellInfo c, ParsingContext context);
    protected bool ShouldIgnore(FunctionArgument arg);
}
public interface OfficeOpenXml.FormulaParsing.Excel.Functions.IFunctionModule {
    public IDictionary`2<string, ExcelFunction> Functions { get; }
    public IDictionary`2<Type, FunctionCompiler> CustomCompilers { get; }
    public abstract virtual IDictionary`2<string, ExcelFunction> get_Functions();
    public abstract virtual IDictionary`2<Type, FunctionCompiler> get_CustomCompilers();
}
public interface OfficeOpenXml.FormulaParsing.Excel.Functions.IFunctionNameProvider {
    public abstract virtual bool IsFunctionName(string name);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.ErrorType : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsBlank : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsErr : ErrorHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    public virtual CompileResult HandleError(string errorCode);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsError : ErrorHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    public virtual CompileResult HandleError(string errorCode);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsEven : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsLogical : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsNa : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsNonText : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsNumber : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsOdd : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.IsText : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.N : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Information.Na : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.IntArgumentParser : ArgumentParser {
    public virtual object Parse(object obj);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Logical.And : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Logical.False : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Logical.If : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Logical.IfError : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Logical.IfNa : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Logical.Not : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Logical.Or : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Logical.True : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Abs : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Acos : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Acosh : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Asin : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Asinh : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Atan : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Atan2 : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Atanh : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Average : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private void Calculate(FunctionArgument arg, ParsingContext context, Double& retVal, Double& nValues, bool isInArray);
    private Nullable`1<double> GetNumericValue(object obj, bool isInArray);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.AverageA : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private void Calculate(FunctionArgument arg, ParsingContext context, Double& retVal, Double& nValues, bool isInArray);
    private Nullable`1<double> GetNumericValue(object obj, bool isInArray);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.AverageIf : HiddenValuesHandlingFunction {
    private ExpressionEvaluator _expressionEvaluator;
    public AverageIf(ExpressionEvaluator evaluator);
    private bool Evaluate(object obj, string expression);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private double CalculateWithLookupRange(IRangeInfo range, string criteria, IRangeInfo sumRange, ParsingContext context);
    private double CalculateSingleRange(IRangeInfo range, string expression, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.AverageIfs : MultipleRangeCriteriasFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Ceiling : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private void ValidateNumberAndSign(double number, double sign);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Cos : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Cosh : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Count : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private void Calculate(IEnumerable`1<FunctionArgument> items, Double& nItems, ParsingContext context, ItemContext itemContext);
    private void _CheckForAndHandleExcelError(FunctionArgument arg, ParsingContext context);
    private void _CheckForAndHandleExcelError(ICellInfo cell, ParsingContext context);
    private bool ShouldCount(object value, ItemContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.CountA : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private void Calculate(IEnumerable`1<FunctionArgument> items, ParsingContext context, Double& nItems);
    private void _CheckForAndHandleExcelError(FunctionArgument arg, ParsingContext context);
    private void _CheckForAndHandleExcelError(ICellInfo cell, ParsingContext context);
    private bool ShouldCount(object value);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.CountBlank : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.CountIf : ExcelFunction {
    private ExpressionEvaluator _expressionEvaluator;
    public CountIf(ExpressionEvaluator evaluator);
    private bool Evaluate(object obj, string expression);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.CountIfs : MultipleRangeCriteriasFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Degrees : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Exp : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Fact : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Floor : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private void ValidateNumberAndSign(double number, double sign);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Large : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Ln : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Log : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Log10 : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public static class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.MathHelper : object {
    public static double Sec(double x);
    public static double Cosec(double x);
    public static double Cotan(double x);
    public static double Arcsin(double x);
    public static double Arccos(double x);
    public static double Arcsec(double x);
    public static double Arccosec(double x);
    public static double Arccotan(double x);
    public static double HSin(double x);
    public static double HCos(double x);
    public static double HTan(double x);
    public static double HSec(double x);
    public static double HCosec(double x);
    public static double HCotan(double x);
    public static double HArcsin(double x);
    public static double HArccos(double x);
    public static double HArctan(double x);
    public static double HArcsec(double x);
    public static double HArccosec(double x);
    public static double HArccotan(double x);
    public static double LogN(double x, double n);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Max : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Maxa : ExcelFunction {
    private DoubleEnumerableArgConverter _argConverter;
    public Maxa(DoubleEnumerableArgConverter argConverter);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Median : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Min : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Mina : ExcelFunction {
    private DoubleEnumerableArgConverter _argConverter;
    public Mina(DoubleEnumerableArgConverter argConverter);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Mod : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.MultipleRangeCriteriasFunction : ExcelFunction {
    private ExpressionEvaluator _expressionEvaluator;
    protected MultipleRangeCriteriasFunction(ExpressionEvaluator evaluator);
    protected bool Evaluate(object obj, string expression);
    protected List`1<int> GetMatchIndexes(IRangeInfo rangeInfo, string searched);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Pi : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Power : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Product : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private double CalculateFirstItem(IEnumerable`1<FunctionArgument> arguments, int index, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Quotient : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Rand : ExcelFunction {
    [CompilerGeneratedAttribute]
private static int <Seed>k__BackingField;
    private static int Seed { get; private set; }
    [CompilerGeneratedAttribute]
private static int get_Seed();
    [CompilerGeneratedAttribute]
private static void set_Seed(int value);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.RandBetween : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private double CalulateDiff(double high, double low);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Rank : ExcelFunction {
    private bool _isAvg;
    public Rank(bool isAvg);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Round : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Rounddown : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private static double RoundDownDecimalNumber(double number, int nDecimals);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Roundup : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Sign : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Sin : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Sinh : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Small : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Sqrt : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.SqrtPi : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Stdev : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private double StandardDeviation(IEnumerable`1<double> values);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.StdevP : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private static double StandardDeviation(IEnumerable`1<double> values);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Subtotal : ExcelFunction {
    private Dictionary`2<int, HiddenValuesHandlingFunction> _functions;
    private void Initialize();
    private void AddHiddenValueHandlingFunction(HiddenValuesHandlingFunction func, int funcNum);
    public virtual void BeforeInvoke(ParsingContext context);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private ExcelFunction GetFunctionByCalcType(int funcNum);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Sum : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private double Calculate(FunctionArgument arg, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.SumIf : HiddenValuesHandlingFunction {
    private ExpressionEvaluator _evaluator;
    public SumIf(ExpressionEvaluator evaluator);
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private double CalculateWithSumRange(IRangeInfo range, string criteria, IRangeInfo sumRange, ParsingContext context);
    private double CalculateSingleRange(IRangeInfo range, string expression, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.SumIfs : MultipleRangeCriteriasFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.SumProduct : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private void AddValue(object convertVal, List`1<double> currentResult);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Sumsq : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private double Calculate(FunctionArgument arg, ParsingContext context, bool isInArray);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Tan : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Tanh : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Trunc : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.Var : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
internal static class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.VarMethods : object {
    private static double Divide(double left, double right);
    public static double Var(IEnumerable`1<ExcelDoubleCellValue> args);
    public static double Var(IEnumerable`1<double> args);
    public static double VarP(IEnumerable`1<ExcelDoubleCellValue> args);
    public static double VarP(IEnumerable`1<double> args);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Math.VarP : HiddenValuesHandlingFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Numeric.CInt : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.ObjectEnumerableArgConverter : CollectionFlattener`1<object> {
    public virtual IEnumerable`1<object> ConvertArgs(bool ignoreHidden, IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Address : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.ArrayLookupNavigator : LookupNavigator {
    private FunctionArgument[] _arrayData;
    private int _index;
    private object _currentValue;
    public int Index { get; }
    public object CurrentValue { get; }
    public ArrayLookupNavigator(LookupDirection direction, LookupArguments arguments, ParsingContext parsingContext);
    private void Initialize();
    public virtual int get_Index();
    private void SetCurrentValue();
    private bool HasNext();
    public virtual bool MoveNext();
    public virtual object get_CurrentValue();
    public virtual object GetLookupValue();
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Choose : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.ChoosenInfo : object {
    private String[] chosenIndeces;
    public bool IsEmpty { get; }
    public bool IsMulti { get; }
    public ExcelAddressBase Address { get; }
    public ExcelWorksheet Worksheet { get; }
    public ICellInfo Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ChoosenInfo(String[] chosenIndeces);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool get_IsMulti();
    public sealed virtual int GetNCells();
    public sealed virtual ExcelAddressBase get_Address();
    public sealed virtual object GetValue(int row, int col);
    public sealed virtual object GetOffset(int rowOffset, int colOffset);
    public sealed virtual ExcelWorksheet get_Worksheet();
    public sealed virtual ICellInfo get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual IEnumerator`1<ICellInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Column : LookupFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Columns : LookupFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.ExcelLookupNavigator : LookupNavigator {
    private int _currentRow;
    private int _currentCol;
    private object _currentValue;
    private RangeAddress _rangeAddress;
    private int _index;
    public int Index { get; }
    public object CurrentValue { get; }
    public ExcelLookupNavigator(LookupDirection direction, LookupArguments arguments, ParsingContext parsingContext);
    private void Initialize();
    private void SetCurrentValue();
    private bool HasNext();
    public virtual int get_Index();
    public virtual bool MoveNext();
    public virtual object get_CurrentValue();
    public virtual object GetLookupValue();
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.HLookup : LookupFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Index : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Indirect : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Lookup : LookupFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private bool HaveTwoRanges(IEnumerable`1<FunctionArgument> arguments);
    private CompileResult HandleSingleRange(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private CompileResult HandleTwoRanges(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.LookupArguments : object {
    private ArgumentParsers _argumentParsers;
    [CompilerGeneratedAttribute]
private object <SearchedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RangeAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LookupIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LookupOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RangeLookup>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FunctionArgument> <DataArray>k__BackingField;
    [CompilerGeneratedAttribute]
private IRangeInfo <RangeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private LookupArgumentDataType <ArgumentDataType>k__BackingField;
    public object SearchedValue { get; private set; }
    public string RangeAddress { get; private set; }
    public int LookupIndex { get; private set; }
    public int LookupOffset { get; private set; }
    public bool RangeLookup { get; private set; }
    public IEnumerable`1<FunctionArgument> DataArray { get; private set; }
    public IRangeInfo RangeInfo { get; private set; }
    public LookupArgumentDataType ArgumentDataType { get; private set; }
    public LookupArguments(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    public LookupArguments(IEnumerable`1<FunctionArgument> arguments, ArgumentParsers argumentParsers, ParsingContext context);
    public LookupArguments(object searchedValue, string rangeAddress, int lookupIndex, int lookupOffset, bool rangeLookup, IRangeInfo rangeInfo);
    [CompilerGeneratedAttribute]
public object get_SearchedValue();
    [CompilerGeneratedAttribute]
private void set_SearchedValue(object value);
    [CompilerGeneratedAttribute]
public string get_RangeAddress();
    [CompilerGeneratedAttribute]
private void set_RangeAddress(string value);
    [CompilerGeneratedAttribute]
public int get_LookupIndex();
    [CompilerGeneratedAttribute]
private void set_LookupIndex(int value);
    [CompilerGeneratedAttribute]
public int get_LookupOffset();
    [CompilerGeneratedAttribute]
private void set_LookupOffset(int value);
    [CompilerGeneratedAttribute]
public bool get_RangeLookup();
    [CompilerGeneratedAttribute]
private void set_RangeLookup(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<FunctionArgument> get_DataArray();
    [CompilerGeneratedAttribute]
private void set_DataArray(IEnumerable`1<FunctionArgument> value);
    [CompilerGeneratedAttribute]
public IRangeInfo get_RangeInfo();
    [CompilerGeneratedAttribute]
private void set_RangeInfo(IRangeInfo value);
    [CompilerGeneratedAttribute]
public LookupArgumentDataType get_ArgumentDataType();
    [CompilerGeneratedAttribute]
private void set_ArgumentDataType(LookupArgumentDataType value);
}
public enum OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.LookupDirection : Enum {
    public int value__;
    public static LookupDirection Vertical;
    public static LookupDirection Horizontal;
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.LookupFunction : ExcelFunction {
    private ValueMatcher _valueMatcher;
    private CompileResultFactory _compileResultFactory;
    public bool IsLookupFuction { get; }
    public LookupFunction(ValueMatcher valueMatcher, CompileResultFactory compileResultFactory);
    public virtual bool get_IsLookupFuction();
    protected int IsMatch(object o1, object o2);
    protected LookupDirection GetLookupDirection(RangeAddress rangeAddress);
    protected CompileResult Lookup(LookupNavigator navigator, LookupArguments lookupArgs);
}
public abstract class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.LookupNavigator : object {
    protected LookupDirection Direction;
    protected LookupArguments Arguments;
    protected ParsingContext ParsingContext;
    public int Index { get; }
    public object CurrentValue { get; }
    public LookupNavigator(LookupDirection direction, LookupArguments arguments, ParsingContext parsingContext);
    public abstract virtual int get_Index();
    public abstract virtual bool MoveNext();
    public abstract virtual object get_CurrentValue();
    public abstract virtual object GetLookupValue();
}
public static class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.LookupNavigatorFactory : object {
    public static LookupNavigator Create(LookupDirection direction, LookupArguments args, ParsingContext parsingContext);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Match : LookupFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private MatchType GetMatchType(IEnumerable`1<FunctionArgument> arguments);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Offset : LookupFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Row : LookupFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.Rows : LookupFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.RefAndLookup.VLookup : LookupFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.CharFunction : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Concatenate : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.CStr : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Exact : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Find : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Fixed : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Hyperlink : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Left : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Len : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Lower : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Mid : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Proper : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Replace : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
    private string GetFirstPart(string text, int startPos);
    private string GetLastPart(string text, int startPos, int nCharactersToReplace);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Rept : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Right : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Search : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Substitute : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.T : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Text : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Upper : ExcelFunction {
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.Excel.Functions.Text.Value : ExcelFunction {
    private string _groupSeparator;
    private string _decimalSeparator;
    private string _timeSeparator;
    private string _shortTimePattern;
    private DateValue _dateValueFunc;
    private TimeValue _timeValueFunc;
    public virtual CompileResult Execute(IEnumerable`1<FunctionArgument> arguments, ParsingContext context);
}
public interface OfficeOpenXml.FormulaParsing.Excel.Operators.IOperator {
    public Operators Operator { get; }
    public int Precedence { get; }
    public abstract virtual Operators get_Operator();
    public abstract virtual CompileResult Apply(CompileResult left, CompileResult right);
    public abstract virtual int get_Precedence();
}
public class OfficeOpenXml.FormulaParsing.Excel.Operators.Operator : object {
    private static int PrecedencePercent;
    private static int PrecedenceExp;
    private static int PrecedenceMultiplyDevide;
    private static int PrecedenceIntegerDivision;
    private static int PrecedenceModulus;
    private static int PrecedenceAddSubtract;
    private static int PrecedenceConcat;
    private static int PrecedenceComparison;
    private Func`3<CompileResult, CompileResult, CompileResult> _implementation;
    private int _precedence;
    private Operators _operator;
    private static IOperator _plus;
    private static IOperator _minus;
    private static IOperator _multiply;
    private static IOperator _divide;
    private static IOperator _greaterThan;
    private static IOperator _eq;
    private static IOperator _notEqualsTo;
    private static IOperator _greaterThanOrEqual;
    private static IOperator _lessThan;
    private static IOperator _percent;
    private int OfficeOpenXml.FormulaParsing.Excel.Operators.IOperator.Precedence { get; }
    private Operators OfficeOpenXml.FormulaParsing.Excel.Operators.IOperator.Operator { get; }
    public static IOperator Plus { get; }
    public static IOperator Minus { get; }
    public static IOperator Multiply { get; }
    public static IOperator Divide { get; }
    public static IOperator Exp { get; }
    public static IOperator Concat { get; }
    public static IOperator GreaterThan { get; }
    public static IOperator Eq { get; }
    public static IOperator NotEqualsTo { get; }
    public static IOperator GreaterThanOrEqual { get; }
    public static IOperator LessThan { get; }
    public static IOperator LessThanOrEqual { get; }
    public static IOperator Percent { get; }
    private Operator(Operators operator, int precedence, Func`3<CompileResult, CompileResult, CompileResult> implementation);
    private sealed virtual override int OfficeOpenXml.FormulaParsing.Excel.Operators.IOperator.get_Precedence();
    private sealed virtual override Operators OfficeOpenXml.FormulaParsing.Excel.Operators.IOperator.get_Operator();
    public sealed virtual CompileResult Apply(CompileResult left, CompileResult right);
    public virtual string ToString();
    public static IOperator get_Plus();
    public static IOperator get_Minus();
    public static IOperator get_Multiply();
    public static IOperator get_Divide();
    public static IOperator get_Exp();
    public static IOperator get_Concat();
    public static IOperator get_GreaterThan();
    public static IOperator get_Eq();
    public static IOperator get_NotEqualsTo();
    public static IOperator get_GreaterThanOrEqual();
    public static IOperator get_LessThan();
    public static IOperator get_LessThanOrEqual();
    public static IOperator get_Percent();
    private static object GetObjFromOther(CompileResult obj, CompileResult other);
    private static CompileResult Compare(CompileResult l, CompileResult r, Func`2<int, bool> comparison);
    private static int CompareString(object l, object r);
    private static bool EitherIsError(CompileResult l, CompileResult r, ExcelErrorValue& errorVal);
}
public enum OfficeOpenXml.FormulaParsing.Excel.Operators.Operators : Enum {
    public int value__;
    public static Operators Undefined;
    public static Operators Concat;
    public static Operators Plus;
    public static Operators Minus;
    public static Operators Multiply;
    public static Operators Divide;
    public static Operators Modulus;
    public static Operators Percent;
    public static Operators Equals;
    public static Operators GreaterThan;
    public static Operators GreaterThanOrEqual;
    public static Operators LessThan;
    public static Operators LessThanOrEqual;
    public static Operators NotEqualTo;
    public static Operators IntegerDivision;
    public static Operators Exponentiation;
}
public class OfficeOpenXml.FormulaParsing.Excel.Operators.OperatorsDict : Dictionary`2<string, IOperator> {
    private static IDictionary`2<string, IOperator> _instance;
    public static IDictionary`2<string, IOperator> Instance { get; }
    public static IDictionary`2<string, IOperator> get_Instance();
}
public class OfficeOpenXml.FormulaParsing.ExcelCalculationOption : object {
    [CompilerGeneratedAttribute]
private bool <AllowCirculareReferences>k__BackingField;
    public bool AllowCirculareReferences { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowCirculareReferences();
    [CompilerGeneratedAttribute]
public void set_AllowCirculareReferences(bool value);
}
public class OfficeOpenXml.FormulaParsing.ExcelCell : object {
    [CompilerGeneratedAttribute]
private int <ColIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Formula>k__BackingField;
    public int ColIndex { get; private set; }
    public int RowIndex { get; private set; }
    public object Value { get; private set; }
    public string Formula { get; private set; }
    public ExcelCell(object val, string formula, int colIndex, int rowIndex);
    [CompilerGeneratedAttribute]
public int get_ColIndex();
    [CompilerGeneratedAttribute]
private void set_ColIndex(int value);
    [CompilerGeneratedAttribute]
public int get_RowIndex();
    [CompilerGeneratedAttribute]
private void set_RowIndex(int value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public string get_Formula();
    [CompilerGeneratedAttribute]
private void set_Formula(string value);
}
public abstract class OfficeOpenXml.FormulaParsing.ExcelDataProvider : object {
    public int ExcelMaxColumns { get; }
    public int ExcelMaxRows { get; }
    public abstract virtual ExcelNamedRangeCollection GetWorksheetNames(string worksheet);
    public abstract virtual ExcelNamedRangeCollection GetWorkbookNameValues();
    public abstract virtual IRangeInfo GetRange(string worksheetName, int row, int column, string address);
    public abstract virtual IRangeInfo GetRange(string worksheetName, string address);
    public abstract virtual INameInfo GetName(string worksheet, string name);
    public abstract virtual IEnumerable`1<object> GetRangeValues(string address);
    public abstract virtual string GetRangeFormula(string worksheetName, int row, int column);
    public abstract virtual List`1<Token> GetRangeFormulaTokens(string worksheetName, int row, int column);
    public abstract virtual bool IsRowHidden(string worksheetName, int row);
    public abstract virtual object GetCellValue(string sheetName, int row, int col);
    public abstract virtual ExcelCellAddress GetDimensionEnd(string worksheet);
    public abstract virtual void Dispose();
    public abstract virtual int get_ExcelMaxColumns();
    public abstract virtual int get_ExcelMaxRows();
    public abstract virtual object GetRangeValue(string worksheetName, int row, int column);
    public abstract virtual string GetFormat(object value, string format);
    public abstract virtual void Reset();
    public abstract virtual IRangeInfo GetRange(string worksheet, int fromRow, int fromCol, int toRow, int toCol);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.AddressTranslator : object {
    private ExcelDataProvider _excelDataProvider;
    public AddressTranslator(ExcelDataProvider excelDataProvider);
    public virtual void ToColAndRow(string address, Int32& col, Int32& row);
    public virtual void ToColAndRow(string address, Int32& col, Int32& row, RangeCalculationBehaviour behaviour);
    private int GetRowIndexByBehaviour(RangeCalculationBehaviour behaviour);
    private int GetNumericAlphaValue(char c);
    private string GetAlphaPart(string address);
    private Nullable`1<int> GetIntPart(string address);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.CellReferenceProvider : object {
    public virtual IEnumerable`1<string> GetReferencedAddresses(string cellFormula, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.ExcelAddressInfo : object {
    [CompilerGeneratedAttribute]
private string <Worksheet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartCell>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndCell>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AddressOnSheet>k__BackingField;
    public string Worksheet { get; private set; }
    public bool WorksheetIsSpecified { get; }
    public bool IsMultipleCells { get; }
    public string StartCell { get; private set; }
    public string EndCell { get; private set; }
    public string AddressOnSheet { get; private set; }
    private ExcelAddressInfo(string address);
    public static ExcelAddressInfo Parse(string address);
    [CompilerGeneratedAttribute]
public string get_Worksheet();
    [CompilerGeneratedAttribute]
private void set_Worksheet(string value);
    public bool get_WorksheetIsSpecified();
    public bool get_IsMultipleCells();
    [CompilerGeneratedAttribute]
public string get_StartCell();
    [CompilerGeneratedAttribute]
private void set_StartCell(string value);
    [CompilerGeneratedAttribute]
public string get_EndCell();
    [CompilerGeneratedAttribute]
private void set_EndCell(string value);
    [CompilerGeneratedAttribute]
public string get_AddressOnSheet();
    [CompilerGeneratedAttribute]
private void set_AddressOnSheet(string value);
}
public static class OfficeOpenXml.FormulaParsing.ExcelUtilities.ExcelAddressUtil : object {
    private static Char[] SheetNameInvalidChars;
    private static ExcelAddressUtil();
    public static bool IsValidAddress(string token);
}
public enum OfficeOpenXml.FormulaParsing.ExcelUtilities.ExcelReferenceType : Enum {
    public int value__;
    public static ExcelReferenceType AbsoluteRowAndColumn;
    public static ExcelReferenceType AbsoluteRowRelativeColumn;
    public static ExcelReferenceType RelativeRowAbsolutColumn;
    public static ExcelReferenceType RelativeRowAndColumn;
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.ExpressionEvaluator : object {
    private WildCardValueMatcher _wildCardValueMatcher;
    private CompileResultFactory _compileResultFactory;
    public ExpressionEvaluator(WildCardValueMatcher wildCardValueMatcher, CompileResultFactory compileResultFactory);
    private string GetNonAlphanumericStartChars(string expression);
    private bool EvaluateOperator(object left, object right, IOperator op);
    public bool TryConvertToDouble(object op, Double& d);
    public bool Evaluate(object left, string expression);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.FormulaDependencies : object {
    private FormulaDependencyFactory _formulaDependencyFactory;
    private Dictionary`2<string, FormulaDependency> _dependencies;
    public IEnumerable`1<KeyValuePair`2<string, FormulaDependency>> Dependencies { get; }
    public FormulaDependencies(FormulaDependencyFactory formulaDependencyFactory);
    public IEnumerable`1<KeyValuePair`2<string, FormulaDependency>> get_Dependencies();
    public void AddFormulaScope(ParsingScope parsingScope);
    public void Clear();
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.FormulaDependency : object {
    [CompilerGeneratedAttribute]
private Guid <ScopeId>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeAddress <Address>k__BackingField;
    private List`1<RangeAddress> _referencedBy;
    private List`1<RangeAddress> _references;
    public Guid ScopeId { get; private set; }
    public RangeAddress Address { get; private set; }
    public FormulaDependency(ParsingScope scope);
    [CompilerGeneratedAttribute]
public Guid get_ScopeId();
    [CompilerGeneratedAttribute]
private void set_ScopeId(Guid value);
    [CompilerGeneratedAttribute]
public RangeAddress get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(RangeAddress value);
    public virtual void AddReferenceFrom(RangeAddress rangeAddress);
    public virtual void AddReferenceTo(RangeAddress rangeAddress);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.FormulaDependencyFactory : object {
    public virtual FormulaDependency Create(ParsingScope scope);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.IndexToAddressTranslator : object {
    private ExcelDataProvider _excelDataProvider;
    private ExcelReferenceType _excelReferenceType;
    public IndexToAddressTranslator(ExcelDataProvider excelDataProvider);
    public IndexToAddressTranslator(ExcelDataProvider excelDataProvider, ExcelReferenceType referenceType);
    protected internal static string GetColumnLetter(int iColumnNumber, bool fixedCol);
    public string ToAddress(int col, int row);
    private string GetRowNumber(int rowNo);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.LookupValueMatcher : ValueMatcher {
    protected virtual int CompareObjectToString(object o1, string o2);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.RangeAddress : object {
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Worksheet>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FromCol>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ToCol>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FromRow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ToRow>k__BackingField;
    private static RangeAddress _empty;
    internal string Address { get; internal set; }
    public string Worksheet { get; internal set; }
    public int FromCol { get; internal set; }
    public int ToCol { get; internal set; }
    public int FromRow { get; internal set; }
    public int ToRow { get; internal set; }
    public static RangeAddress Empty { get; }
    private static RangeAddress();
    [CompilerGeneratedAttribute]
internal string get_Address();
    [CompilerGeneratedAttribute]
internal void set_Address(string value);
    [CompilerGeneratedAttribute]
public string get_Worksheet();
    [CompilerGeneratedAttribute]
internal void set_Worksheet(string value);
    [CompilerGeneratedAttribute]
public int get_FromCol();
    [CompilerGeneratedAttribute]
internal void set_FromCol(int value);
    [CompilerGeneratedAttribute]
public int get_ToCol();
    [CompilerGeneratedAttribute]
internal void set_ToCol(int value);
    [CompilerGeneratedAttribute]
public int get_FromRow();
    [CompilerGeneratedAttribute]
internal void set_FromRow(int value);
    [CompilerGeneratedAttribute]
public int get_ToRow();
    [CompilerGeneratedAttribute]
internal void set_ToRow(int value);
    public virtual string ToString();
    public static RangeAddress get_Empty();
    public bool CollidesWith(RangeAddress other);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.RangeAddressFactory : object {
    private ExcelDataProvider _excelDataProvider;
    private AddressTranslator _addressTranslator;
    private IndexToAddressTranslator _indexToAddressTranslator;
    public RangeAddressFactory(ExcelDataProvider excelDataProvider);
    public RangeAddressFactory(ExcelDataProvider excelDataProvider, AddressTranslator addressTranslator, IndexToAddressTranslator indexToAddressTranslator);
    public RangeAddress Create(int col, int row);
    public RangeAddress Create(string worksheetName, int col, int row);
    public RangeAddress Create(string worksheetName, string address);
    public RangeAddress Create(string range);
    private void HandleSingleCellAddress(RangeAddress rangeAddress, ExcelAddressInfo addressInfo);
    private void HandleMultipleCellAddress(RangeAddress rangeAddress, ExcelAddressInfo addressInfo);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.ValueMatcher : object {
    public static int IncompatibleOperands;
    public virtual int IsMatch(object o1, object o2);
    private static object CheckGetRange(object v);
    protected virtual int CompareStringToString(string s1, string s2);
    protected virtual int CompareStringToObject(string o1, object o2);
    protected virtual int CompareObjectToString(object o1, string o2);
}
public class OfficeOpenXml.FormulaParsing.ExcelUtilities.WildCardValueMatcher : ValueMatcher {
    protected virtual int CompareStringToString(string s1, string s2);
}
public class OfficeOpenXml.FormulaParsing.Exceptions.CircularReferenceException : Exception {
    public CircularReferenceException(string message);
}
public class OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorCodes : object {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    private static IEnumerable`1<string> Codes;
    public string Code { get; private set; }
    public static ExcelErrorCodes Value { get; }
    public static ExcelErrorCodes Name { get; }
    public static ExcelErrorCodes NoValueAvaliable { get; }
    private ExcelErrorCodes(string code);
    private static ExcelErrorCodes();
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
private void set_Code(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ExcelErrorCodes c1, ExcelErrorCodes c2);
    public static bool op_Inequality(ExcelErrorCodes c1, ExcelErrorCodes c2);
    public static bool IsErrorCode(object valueToTest);
    public static ExcelErrorCodes get_Value();
    public static ExcelErrorCodes get_Name();
    public static ExcelErrorCodes get_NoValueAvaliable();
}
public class OfficeOpenXml.FormulaParsing.Exceptions.ExcelErrorValueException : Exception {
    [CompilerGeneratedAttribute]
private ExcelErrorValue <ErrorValue>k__BackingField;
    public ExcelErrorValue ErrorValue { get; private set; }
    public ExcelErrorValueException(ExcelErrorValue error);
    public ExcelErrorValueException(string message, ExcelErrorValue error);
    public ExcelErrorValueException(eErrorType errorType);
    [CompilerGeneratedAttribute]
public ExcelErrorValue get_ErrorValue();
    [CompilerGeneratedAttribute]
private void set_ErrorValue(ExcelErrorValue value);
}
public class OfficeOpenXml.FormulaParsing.Exceptions.UnrecognizedTokenException : Exception {
    public UnrecognizedTokenException(Token token);
}
public abstract class OfficeOpenXml.FormulaParsing.ExpressionGraph.AtomicExpression : Expression {
    public bool IsGroupedExpression { get; }
    public AtomicExpression(string expression);
    public virtual bool get_IsGroupedExpression();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.BooleanExpression : AtomicExpression {
    private Nullable`1<bool> _precompiledValue;
    public BooleanExpression(string expression);
    public BooleanExpression(bool value);
    public virtual CompileResult Compile();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.CompileResult : object {
    private static CompileResult _empty;
    private Nullable`1<double> _ResultNumeric;
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private DataType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResultOfSubtotal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHiddenCell>k__BackingField;
    public static CompileResult Empty { get; }
    public object Result { get; private set; }
    public object ResultValue { get; }
    public double ResultNumeric { get; }
    public DataType DataType { get; private set; }
    public bool IsNumeric { get; }
    public bool IsNumericString { get; }
    public bool IsDateString { get; }
    public bool IsResultOfSubtotal { get; public set; }
    public bool IsHiddenCell { get; public set; }
    public CompileResult(object result, DataType dataType);
    public CompileResult(eErrorType errorType);
    public CompileResult(ExcelErrorValue errorValue);
    private static CompileResult();
    public static CompileResult get_Empty();
    [CompilerGeneratedAttribute]
public object get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(object value);
    public object get_ResultValue();
    public double get_ResultNumeric();
    [CompilerGeneratedAttribute]
public DataType get_DataType();
    [CompilerGeneratedAttribute]
private void set_DataType(DataType value);
    public bool get_IsNumeric();
    public bool get_IsNumericString();
    public bool get_IsDateString();
    [CompilerGeneratedAttribute]
public bool get_IsResultOfSubtotal();
    [CompilerGeneratedAttribute]
public void set_IsResultOfSubtotal(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsHiddenCell();
    [CompilerGeneratedAttribute]
public void set_IsHiddenCell(bool value);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.CompileResultFactory : object {
    public virtual CompileResult Create(object obj);
}
public abstract class OfficeOpenXml.FormulaParsing.ExpressionGraph.CompileStrategy.CompileStrategy : object {
    protected Expression _expression;
    public CompileStrategy(Expression expression);
    public abstract virtual Expression Compile();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.CompileStrategy.CompileStrategyFactory : object {
    public sealed virtual CompileStrategy Create(Expression expression);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.CompileStrategy.DefaultCompileStrategy : CompileStrategy {
    public DefaultCompileStrategy(Expression expression);
    public virtual Expression Compile();
}
public interface OfficeOpenXml.FormulaParsing.ExpressionGraph.CompileStrategy.ICompileStrategyFactory {
    public abstract virtual CompileStrategy Create(Expression expression);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.CompileStrategy.StringConcatStrategy : CompileStrategy {
    public StringConcatStrategy(Expression expression);
    public virtual Expression Compile();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.ConstantExpression : AtomicExpression {
    private Func`1<CompileResult> _factoryMethod;
    public ConstantExpression(string title, Func`1<CompileResult> factoryMethod);
    public virtual CompileResult Compile();
}
public static class OfficeOpenXml.FormulaParsing.ExpressionGraph.ConstantExpressions : object {
    public static Expression Percent { get; }
    public static Expression get_Percent();
}
public enum OfficeOpenXml.FormulaParsing.ExpressionGraph.DataType : Enum {
    public int value__;
    public static DataType Integer;
    public static DataType Decimal;
    public static DataType String;
    public static DataType Boolean;
    public static DataType Date;
    public static DataType Time;
    public static DataType Enumerable;
    public static DataType LookupArray;
    public static DataType ExcelAddress;
    public static DataType ExcelError;
    public static DataType Empty;
    public static DataType Unknown;
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.DateExpression : AtomicExpression {
    public DateExpression(string expression);
    public virtual CompileResult Compile();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.DecimalExpression : AtomicExpression {
    private Nullable`1<double> _compiledValue;
    private bool _negate;
    public DecimalExpression(string expression);
    public DecimalExpression(string expression, bool negate);
    public DecimalExpression(double compiledValue);
    public virtual CompileResult Compile();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.EnumerableExpression : Expression {
    private IExpressionCompiler _expressionCompiler;
    public bool IsGroupedExpression { get; }
    public EnumerableExpression(IExpressionCompiler expressionCompiler);
    public virtual bool get_IsGroupedExpression();
    public virtual Expression PrepareForNextChild();
    public virtual CompileResult Compile();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.ExcelAddressExpression : AtomicExpression {
    [CompilerGeneratedAttribute]
private bool <ResolveAsRange>k__BackingField;
    private ExcelDataProvider _excelDataProvider;
    private ParsingContext _parsingContext;
    private RangeAddressFactory _rangeAddressFactory;
    private bool _negate;
    public bool ResolveAsRange { get; public set; }
    public bool IsGroupedExpression { get; }
    public ExcelAddressExpression(string expression, ExcelDataProvider excelDataProvider, ParsingContext parsingContext);
    public ExcelAddressExpression(string expression, ExcelDataProvider excelDataProvider, ParsingContext parsingContext, bool negate);
    public ExcelAddressExpression(string expression, ExcelDataProvider excelDataProvider, ParsingContext parsingContext, RangeAddressFactory rangeAddressFactory, bool negate);
    [CompilerGeneratedAttribute]
public bool get_ResolveAsRange();
    [CompilerGeneratedAttribute]
public void set_ResolveAsRange(bool value);
    public virtual bool get_IsGroupedExpression();
    public virtual CompileResult Compile();
    private CompileResult CompileRangeValues();
    private CompileResult CompileSingleCell(IRangeInfo result);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.ExcelErrorExpression : Expression {
    private ExcelErrorValue _error;
    public bool IsGroupedExpression { get; }
    public ExcelErrorExpression(string expression, ExcelErrorValue error);
    public ExcelErrorExpression(ExcelErrorValue error);
    public virtual bool get_IsGroupedExpression();
    public virtual CompileResult Compile();
}
public abstract class OfficeOpenXml.FormulaParsing.ExpressionGraph.Expression : object {
    [CompilerGeneratedAttribute]
private string <ExpressionString>k__BackingField;
    private List`1<Expression> _children;
    [CompilerGeneratedAttribute]
private Expression <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Prev>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParentIsLookupFunction>k__BackingField;
    protected string ExpressionString { get; private set; }
    public IEnumerable`1<Expression> Children { get; }
    public Expression Next { get; public set; }
    public Expression Prev { get; public set; }
    public IOperator Operator { get; public set; }
    public bool IsGroupedExpression { get; }
    public bool ParentIsLookupFunction { get; public set; }
    public bool HasChildren { get; }
    public Expression(string expression);
    [CompilerGeneratedAttribute]
protected string get_ExpressionString();
    [CompilerGeneratedAttribute]
private void set_ExpressionString(string value);
    public IEnumerable`1<Expression> get_Children();
    [CompilerGeneratedAttribute]
public Expression get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(Expression value);
    [CompilerGeneratedAttribute]
public Expression get_Prev();
    [CompilerGeneratedAttribute]
public void set_Prev(Expression value);
    [CompilerGeneratedAttribute]
public IOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(IOperator value);
    public abstract virtual bool get_IsGroupedExpression();
    [CompilerGeneratedAttribute]
public virtual bool get_ParentIsLookupFunction();
    [CompilerGeneratedAttribute]
public virtual void set_ParentIsLookupFunction(bool value);
    public virtual bool get_HasChildren();
    public virtual Expression PrepareForNextChild();
    public virtual Expression AddChild(Expression child);
    public virtual Expression MergeWithNext();
    public abstract virtual CompileResult Compile();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.ExpressionCompiler : object {
    private IEnumerable`1<Expression> _expressions;
    private IExpressionConverter _expressionConverter;
    private ICompileStrategyFactory _compileStrategyFactory;
    public ExpressionCompiler(IExpressionConverter expressionConverter, ICompileStrategyFactory compileStrategyFactory);
    public sealed virtual CompileResult Compile(IEnumerable`1<Expression> expressions);
    public CompileResult Compile(string worksheet, int row, int column, IEnumerable`1<Expression> expressions);
    private CompileResult PerformCompilation(string worksheet, int row, int column);
    private IEnumerable`1<Expression> HandleGroupedExpressions();
    private IEnumerable`1<Expression> HandlePrecedenceLevel(int precedence);
    private int FindLowestPrecedence();
    private IEnumerable`1<Expression> RefreshList(Expression first);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.ExpressionConverter : object {
    private static IExpressionConverter _instance;
    public static IExpressionConverter Instance { get; }
    public sealed virtual StringExpression ToStringExpression(Expression expression);
    public sealed virtual Expression FromCompileResult(CompileResult compileResult);
    public static IExpressionConverter get_Instance();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.ExpressionFactory : object {
    private ExcelDataProvider _excelDataProvider;
    private ParsingContext _parsingContext;
    public ExpressionFactory(ExcelDataProvider excelDataProvider, ParsingContext context);
    public sealed virtual Expression Create(Token token);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.ExpressionGraph : object {
    private List`1<Expression> _expressions;
    [CompilerGeneratedAttribute]
private Expression <Current>k__BackingField;
    public IEnumerable`1<Expression> Expressions { get; }
    public Expression Current { get; private set; }
    public IEnumerable`1<Expression> get_Expressions();
    [CompilerGeneratedAttribute]
public Expression get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(Expression value);
    public Expression Add(Expression expression);
    public void Reset();
    public void Remove(Expression item);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.ExpressionGraphBuilder : object {
    private ExpressionGraph _graph;
    private IExpressionFactory _expressionFactory;
    private ParsingContext _parsingContext;
    private int _tokenIndex;
    private bool _negateNextExpression;
    public ExpressionGraphBuilder(ExcelDataProvider excelDataProvider, ParsingContext parsingContext);
    public ExpressionGraphBuilder(IExpressionFactory expressionFactory, ParsingContext parsingContext);
    public sealed virtual ExpressionGraph Build(IEnumerable`1<Token> tokens);
    private void BuildUp(Token[] tokens, Expression parent);
    private void BuildEnumerableExpression(Token[] tokens, Expression parent);
    private void CreateAndAppendExpression(Expression& parent, Token token);
    private bool IsWaste(Token token);
    private void BuildFunctionExpression(Token[] tokens, Expression parent, string funcName);
    private void HandleFunctionArguments(Token[] tokens, Expression function);
    private void BuildGroupExpression(Token[] tokens, Expression parent);
    private void SetOperatorOnExpression(Expression parent, IOperator op);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionArgumentExpression : GroupExpression {
    private Expression _function;
    public bool ParentIsLookupFunction { get; public set; }
    public bool IsGroupedExpression { get; }
    public FunctionArgumentExpression(Expression function);
    public virtual bool get_ParentIsLookupFunction();
    public virtual void set_ParentIsLookupFunction(bool value);
    public virtual bool get_IsGroupedExpression();
    public virtual Expression PrepareForNextChild();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionCompilers.DefaultCompiler : FunctionCompiler {
    public DefaultCompiler(ExcelFunction function);
    public virtual CompileResult Compile(IEnumerable`1<Expression> children, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionCompilers.ErrorHandlingFunctionCompiler : FunctionCompiler {
    public ErrorHandlingFunctionCompiler(ExcelFunction function);
    public virtual CompileResult Compile(IEnumerable`1<Expression> children, ParsingContext context);
}
public abstract class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionCompilers.FunctionCompiler : object {
    [CompilerGeneratedAttribute]
private ExcelFunction <Function>k__BackingField;
    protected ExcelFunction Function { get; private set; }
    public FunctionCompiler(ExcelFunction function);
    [CompilerGeneratedAttribute]
protected ExcelFunction get_Function();
    [CompilerGeneratedAttribute]
private void set_Function(ExcelFunction value);
    protected void BuildFunctionArguments(object result, DataType dataType, List`1<FunctionArgument> args);
    protected void BuildFunctionArguments(object result, List`1<FunctionArgument> args);
    public abstract virtual CompileResult Compile(IEnumerable`1<Expression> children, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionCompilers.FunctionCompilerFactory : object {
    private Dictionary`2<Type, FunctionCompiler> _specialCompilers;
    public FunctionCompilerFactory(FunctionRepository repository);
    private FunctionCompiler GetCompilerByType(ExcelFunction function);
    public virtual FunctionCompiler Create(ExcelFunction function);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionCompilers.IfErrorFunctionCompiler : FunctionCompiler {
    public IfErrorFunctionCompiler(ExcelFunction function);
    public virtual CompileResult Compile(IEnumerable`1<Expression> children, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionCompilers.IfFunctionCompiler : FunctionCompiler {
    public IfFunctionCompiler(ExcelFunction function);
    public virtual CompileResult Compile(IEnumerable`1<Expression> children, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionCompilers.IfNaFunctionCompiler : FunctionCompiler {
    public IfNaFunctionCompiler(ExcelFunction function);
    public virtual CompileResult Compile(IEnumerable`1<Expression> children, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionCompilers.LookupFunctionCompiler : FunctionCompiler {
    public LookupFunctionCompiler(ExcelFunction function);
    public virtual CompileResult Compile(IEnumerable`1<Expression> children, ParsingContext context);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.FunctionExpression : AtomicExpression {
    private ParsingContext _parsingContext;
    private FunctionCompilerFactory _functionCompilerFactory;
    private bool _isNegated;
    public bool HasChildren { get; }
    public FunctionExpression(string expression, ParsingContext parsingContext, bool isNegated);
    public virtual CompileResult Compile();
    public virtual Expression PrepareForNextChild();
    public virtual bool get_HasChildren();
    public virtual Expression AddChild(Expression child);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.GroupExpression : Expression {
    private IExpressionCompiler _expressionCompiler;
    private bool _isNegated;
    public bool IsGroupedExpression { get; }
    public GroupExpression(bool isNegated);
    public GroupExpression(bool isNegated, IExpressionCompiler expressionCompiler);
    public virtual CompileResult Compile();
    public virtual bool get_IsGroupedExpression();
}
public interface OfficeOpenXml.FormulaParsing.ExpressionGraph.IExpressionCompiler {
    public abstract virtual CompileResult Compile(IEnumerable`1<Expression> expressions);
}
public interface OfficeOpenXml.FormulaParsing.ExpressionGraph.IExpressionConverter {
    public abstract virtual StringExpression ToStringExpression(Expression expression);
    public abstract virtual Expression FromCompileResult(CompileResult compileResult);
}
public interface OfficeOpenXml.FormulaParsing.ExpressionGraph.IExpressionFactory {
    public abstract virtual Expression Create(Token token);
}
public interface OfficeOpenXml.FormulaParsing.ExpressionGraph.IExpressionGraphBuilder {
    public abstract virtual ExpressionGraph Build(IEnumerable`1<Token> tokens);
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.IntegerExpression : AtomicExpression {
    private Nullable`1<double> _compiledValue;
    private bool _negate;
    public IntegerExpression(string expression);
    public IntegerExpression(string expression, bool negate);
    public IntegerExpression(double val);
    public virtual CompileResult Compile();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.NamedValueExpression : AtomicExpression {
    private ParsingContext _parsingContext;
    public NamedValueExpression(string expression, ParsingContext parsingContext);
    public virtual CompileResult Compile();
}
public class OfficeOpenXml.FormulaParsing.ExpressionGraph.StringExpression : AtomicExpression {
    public StringExpression(string expression);
    public virtual CompileResult Compile();
}
internal class OfficeOpenXml.FormulaParsing.FormulaCell : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SheetID>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Row>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Formula>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Token> <Tokens>k__BackingField;
    internal int tokenIx;
    internal int addressIx;
    internal CellsStoreEnumerator`1<object> iterator;
    internal ExcelWorksheet ws;
    internal int Index { get; internal set; }
    internal int SheetID { get; internal set; }
    internal int Row { get; internal set; }
    internal int Column { get; internal set; }
    internal string Formula { get; internal set; }
    internal List`1<Token> Tokens { get; internal set; }
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [CompilerGeneratedAttribute]
internal int get_SheetID();
    [CompilerGeneratedAttribute]
internal void set_SheetID(int value);
    [CompilerGeneratedAttribute]
internal int get_Row();
    [CompilerGeneratedAttribute]
internal void set_Row(int value);
    [CompilerGeneratedAttribute]
internal int get_Column();
    [CompilerGeneratedAttribute]
internal void set_Column(int value);
    [CompilerGeneratedAttribute]
internal string get_Formula();
    [CompilerGeneratedAttribute]
internal void set_Formula(string value);
    [CompilerGeneratedAttribute]
internal List`1<Token> get_Tokens();
    [CompilerGeneratedAttribute]
internal void set_Tokens(List`1<Token> value);
}
public class OfficeOpenXml.FormulaParsing.FormulaParser : object {
    private ParsingContext _parsingContext;
    private ExcelDataProvider _excelDataProvider;
    private ILexer _lexer;
    private IExpressionGraphBuilder _graphBuilder;
    private IExpressionCompiler _compiler;
    public ILexer Lexer { get; }
    public IEnumerable`1<string> FunctionNames { get; }
    public IFormulaParserLogger Logger { get; }
    public FormulaParser(ExcelDataProvider excelDataProvider);
    public FormulaParser(ExcelDataProvider excelDataProvider, ParsingContext parsingContext);
    public void Configure(Action`1<ParsingConfiguration> configMethod);
    public ILexer get_Lexer();
    public IEnumerable`1<string> get_FunctionNames();
    internal virtual object Parse(string formula, RangeAddress rangeAddress);
    internal virtual object Parse(IEnumerable`1<Token> tokens, string worksheet, string address);
    internal virtual object ParseCell(IEnumerable`1<Token> tokens, string worksheet, int row, int column);
    public virtual object Parse(string formula, string address);
    public virtual object Parse(string formula);
    public virtual object ParseAt(string address);
    public virtual object ParseAt(string worksheetName, int row, int col);
    internal void InitNewCalc();
    public IFormulaParserLogger get_Logger();
    public sealed virtual void Dispose();
}
public class OfficeOpenXml.FormulaParsing.FormulaParserManager : object {
    private FormulaParser _parser;
    internal FormulaParserManager(FormulaParser parser);
    public void LoadFunctionModule(IFunctionModule module);
    public void AddOrReplaceFunction(string functionName, ExcelFunction functionImpl);
    public void CopyFunctionsFrom(ExcelWorkbook otherWorkbook);
    public IEnumerable`1<string> GetImplementedFunctionNames();
    public IEnumerable`1<KeyValuePair`2<string, ExcelFunction>> GetImplementedFunctions();
    public object Parse(string formula);
    public void AttachLogger(IFormulaParserLogger logger);
    public void AttachLogger(FileInfo logfile);
    public void DetachLogger();
}
public interface OfficeOpenXml.FormulaParsing.INameValueProvider {
    public abstract virtual bool IsNamedValue(string key, string worksheet);
    public abstract virtual object GetNamedValue(string key);
    public abstract virtual void Reload();
}
public interface OfficeOpenXml.FormulaParsing.IParsingLifetimeEventHandler {
    public abstract virtual void ParsingCompleted();
}
public interface OfficeOpenXml.FormulaParsing.LexicalAnalysis.ILexer {
    public abstract virtual IEnumerable`1<Token> Tokenize(string input);
    public abstract virtual IEnumerable`1<Token> Tokenize(string input, string worksheet);
}
public interface OfficeOpenXml.FormulaParsing.LexicalAnalysis.ISourceCodeTokenizer {
    public abstract virtual IEnumerable`1<Token> Tokenize(string input, string worksheet);
}
public interface OfficeOpenXml.FormulaParsing.LexicalAnalysis.ISyntacticAnalyzer {
    public abstract virtual void Analyze(IEnumerable`1<Token> tokens);
}
public interface OfficeOpenXml.FormulaParsing.LexicalAnalysis.ITokenFactory {
    public abstract virtual Token Create(IEnumerable`1<Token> tokens, string token);
    public abstract virtual Token Create(IEnumerable`1<Token> tokens, string token, string worksheet);
    public abstract virtual Token Create(string token, TokenType explicitTokenType);
}
public interface OfficeOpenXml.FormulaParsing.LexicalAnalysis.ITokenIndexProvider {
    public int Index { get; }
    public abstract virtual int get_Index();
    public abstract virtual void MoveIndexPointerForward();
}
public interface OfficeOpenXml.FormulaParsing.LexicalAnalysis.ITokenSeparatorProvider {
    public IDictionary`2<string, Token> Tokens { get; }
    public abstract virtual IDictionary`2<string, Token> get_Tokens();
    public abstract virtual bool IsOperator(string item);
    public abstract virtual bool IsPossibleLastPartOfMultipleCharOperator(string part);
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.Lexer : object {
    private ISourceCodeTokenizer _tokenizer;
    private ISyntacticAnalyzer _analyzer;
    public Lexer(FunctionRepository functionRepository, INameValueProvider nameValueProvider);
    public Lexer(ISourceCodeTokenizer tokenizer, ISyntacticAnalyzer analyzer);
    public sealed virtual IEnumerable`1<Token> Tokenize(string input);
    public sealed virtual IEnumerable`1<Token> Tokenize(string input, string worksheet);
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.SourceCodeTokenizer : object {
    private ITokenSeparatorProvider _separatorProvider;
    private ITokenFactory _tokenFactory;
    public static ISourceCodeTokenizer Default { get; }
    public SourceCodeTokenizer(IFunctionNameProvider functionRepository, INameValueProvider nameValueProvider);
    public SourceCodeTokenizer(ITokenFactory tokenFactory, ITokenSeparatorProvider tokenProvider);
    public static ISourceCodeTokenizer get_Default();
    public IEnumerable`1<Token> Tokenize(string input);
    public sealed virtual IEnumerable`1<Token> Tokenize(string input, string worksheet);
    private static void CleanupTokens(TokenizerContext context, IDictionary`2<string, Token> tokens);
    private static void SetNegatorOperator(TokenizerContext context, int i, IDictionary`2<string, Token> tokens);
    private static bool TokenIsNegator(TokenizerContext context);
    private static bool TokenIsNegator(Token t);
    private Token CreateToken(TokenizerContext context, string worksheet);
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.SyntacticAnalyzer : object {
    public sealed virtual void Analyze(IEnumerable`1<Token> tokens);
    private static void Validate(AnalyzingContext context);
    private void EnsureParenthesesAreWellFormed(Token token, AnalyzingContext context);
    private void EnsureStringsAreWellFormed(Token token, AnalyzingContext context);
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.Token : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNegated>k__BackingField;
    public string Value { get; internal set; }
    public TokenType TokenType { get; internal set; }
    public bool IsNegated { get; private set; }
    public Token(string token, TokenType tokenType);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(string value);
    [CompilerGeneratedAttribute]
public TokenType get_TokenType();
    [CompilerGeneratedAttribute]
internal void set_TokenType(TokenType value);
    public void Append(string stringToAppend);
    [CompilerGeneratedAttribute]
public bool get_IsNegated();
    [CompilerGeneratedAttribute]
private void set_IsNegated(bool value);
    public void Negate();
    public virtual string ToString();
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenFactory : object {
    private ITokenSeparatorProvider _tokenSeparatorProvider;
    private IFunctionNameProvider _functionNameProvider;
    private INameValueProvider _nameValueProvider;
    public TokenFactory(IFunctionNameProvider functionRepository, INameValueProvider nameValueProvider);
    public TokenFactory(ITokenSeparatorProvider tokenSeparatorProvider, INameValueProvider nameValueProvider, IFunctionNameProvider functionNameProvider);
    public sealed virtual Token Create(IEnumerable`1<Token> tokens, string token);
    public sealed virtual Token Create(IEnumerable`1<Token> tokens, string token, string worksheet);
    public sealed virtual Token Create(string token, TokenType explicitTokenType);
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenHandler : object {
    private TokenizerContext _context;
    private ITokenSeparatorProvider _tokenProvider;
    private ITokenFactory _tokenFactory;
    private int _tokenIndex;
    [CompilerGeneratedAttribute]
private string <Worksheet>k__BackingField;
    public string Worksheet { get; public set; }
    private int OfficeOpenXml.FormulaParsing.LexicalAnalysis.ITokenIndexProvider.Index { get; }
    public TokenHandler(TokenizerContext context, ITokenFactory tokenFactory, ITokenSeparatorProvider tokenProvider);
    [CompilerGeneratedAttribute]
public string get_Worksheet();
    [CompilerGeneratedAttribute]
public void set_Worksheet(string value);
    public bool HasMore();
    public void Next();
    private void Handle();
    private bool CharIsTokenSeparator(char c, Token& token);
    private static bool TokenIsNegator(TokenizerContext context);
    private static bool TokenIsNegator(Token t);
    private Token CreateToken(TokenizerContext context, string worksheet);
    private sealed virtual override int OfficeOpenXml.FormulaParsing.LexicalAnalysis.ITokenIndexProvider.get_Index();
    private sealed virtual override void OfficeOpenXml.FormulaParsing.LexicalAnalysis.ITokenIndexProvider.MoveIndexPointerForward();
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenizerContext : object {
    private Char[] _chars;
    private List`1<Token> _result;
    private StringBuilder _currentToken;
    [CompilerGeneratedAttribute]
private bool <IsInString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInSheetName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BracketCount>k__BackingField;
    public Char[] FormulaChars { get; }
    public IList`1<Token> Result { get; }
    public bool IsInString { get; private set; }
    public bool IsInSheetName { get; private set; }
    internal int BracketCount { get; internal set; }
    public string CurrentToken { get; }
    public bool CurrentTokenHasValue { get; }
    public Token LastToken { get; }
    public TokenizerContext(string formula);
    public Char[] get_FormulaChars();
    public IList`1<Token> get_Result();
    [CompilerGeneratedAttribute]
public bool get_IsInString();
    [CompilerGeneratedAttribute]
private void set_IsInString(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInSheetName();
    [CompilerGeneratedAttribute]
private void set_IsInSheetName(bool value);
    public void ToggleIsInString();
    public void ToggleIsInSheetName();
    [CompilerGeneratedAttribute]
internal int get_BracketCount();
    [CompilerGeneratedAttribute]
internal void set_BracketCount(int value);
    public string get_CurrentToken();
    public bool get_CurrentTokenHasValue();
    public void NewToken();
    public void AddToken(Token token);
    public void AppendToCurrentToken(char c);
    public void AppendToLastToken(string stringToAppend);
    public void SetLastTokenType(TokenType type);
    public void ReplaceLastToken(Token newToken);
    public Token get_LastToken();
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorHandlers.BracketHandler : SeparatorHandler {
    public virtual bool Handle(char c, Token tokenSeparator, TokenizerContext context, ITokenIndexProvider tokenIndexProvider);
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorHandlers.MultipleCharSeparatorHandler : SeparatorHandler {
    private ITokenSeparatorProvider _tokenSeparatorProvider;
    public MultipleCharSeparatorHandler(ITokenSeparatorProvider tokenSeparatorProvider);
    public virtual bool Handle(char c, Token tokenSeparator, TokenizerContext context, ITokenIndexProvider tokenIndexProvider);
    private bool IsPartOfMultipleCharSeparator(TokenizerContext context, char c);
}
public abstract class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorHandlers.SeparatorHandler : object {
    protected bool IsDoubleQuote(Token tokenSeparator, int formulaCharIndex, TokenizerContext context);
    public abstract virtual bool Handle(char c, Token tokenSeparator, TokenizerContext context, ITokenIndexProvider tokenIndexProvider);
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorHandlers.SheetnameHandler : SeparatorHandler {
    public virtual bool Handle(char c, Token tokenSeparator, TokenizerContext context, ITokenIndexProvider tokenIndexProvider);
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorHandlers.StringHandler : SeparatorHandler {
    public virtual bool Handle(char c, Token tokenSeparator, TokenizerContext context, ITokenIndexProvider tokenIndexProvider);
}
public static class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorHandlers.TokenSeparatorHandler : object {
    private static SeparatorHandler[] _handlers;
    private static TokenSeparatorHandler();
    public static bool Handle(char c, Token tokenSeparator, TokenizerContext context, ITokenIndexProvider tokenIndexProvider);
}
public class OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenSeparatorProvider : object {
    private static Dictionary`2<string, Token> _tokens;
    private IDictionary`2<string, Token> OfficeOpenXml.FormulaParsing.LexicalAnalysis.ITokenSeparatorProvider.Tokens { get; }
    private static TokenSeparatorProvider();
    private sealed virtual override IDictionary`2<string, Token> OfficeOpenXml.FormulaParsing.LexicalAnalysis.ITokenSeparatorProvider.get_Tokens();
    public sealed virtual bool IsOperator(string item);
    public sealed virtual bool IsPossibleLastPartOfMultipleCharOperator(string part);
}
public enum OfficeOpenXml.FormulaParsing.LexicalAnalysis.TokenType : Enum {
    public int value__;
    public static TokenType Operator;
    public static TokenType Negator;
    public static TokenType OpeningParenthesis;
    public static TokenType ClosingParenthesis;
    public static TokenType OpeningEnumerable;
    public static TokenType ClosingEnumerable;
    public static TokenType OpeningBracket;
    public static TokenType ClosingBracket;
    public static TokenType Enumerable;
    public static TokenType Comma;
    public static TokenType SemiColon;
    public static TokenType String;
    public static TokenType StringContent;
    public static TokenType WorksheetName;
    public static TokenType WorksheetNameContent;
    public static TokenType Integer;
    public static TokenType Boolean;
    public static TokenType Decimal;
    public static TokenType Percent;
    public static TokenType Function;
    public static TokenType ExcelAddress;
    public static TokenType NameValue;
    public static TokenType InvalidReference;
    public static TokenType NumericError;
    public static TokenType ValueDataTypeError;
    public static TokenType Null;
    public static TokenType Unrecognized;
}
public interface OfficeOpenXml.FormulaParsing.Logging.IFormulaParserLogger {
    public abstract virtual void Log(ParsingContext context, Exception ex);
    public abstract virtual void Log(ParsingContext context, string message);
    public abstract virtual void Log(string message);
    public abstract virtual void LogCellCounted();
    public abstract virtual void LogFunction(string func);
    public abstract virtual void LogFunction(string func, long milliseconds);
}
public static class OfficeOpenXml.FormulaParsing.Logging.LoggerFactory : object {
    public static IFormulaParserLogger CreateTextFileLogger(FileInfo file);
}
internal class OfficeOpenXml.FormulaParsing.Logging.TextFileLogger : object {
    private StreamWriter _sw;
    private static string Separator;
    private int _count;
    private DateTime _startTime;
    private Dictionary`2<string, int> _funcs;
    private Dictionary`2<string, long> _funcPerformance;
    internal TextFileLogger(FileInfo fileInfo);
    private void WriteSeparatorAndTimeStamp();
    private void WriteAddressInfo(ParsingContext context);
    public sealed virtual void Log(ParsingContext context, Exception ex);
    public sealed virtual void Log(ParsingContext context, string message);
    public sealed virtual void Log(string message);
    public sealed virtual void LogCellCounted();
    public sealed virtual void LogFunction(string func);
    public sealed virtual void LogFunction(string func, long milliseconds);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private int <LogCellCounted>b__12_0(string x);
}
public class OfficeOpenXml.FormulaParsing.NameValueProvider : object {
    public static INameValueProvider Empty { get; }
    public static INameValueProvider get_Empty();
    public sealed virtual bool IsNamedValue(string key, string worksheet);
    public sealed virtual object GetNamedValue(string key);
    public sealed virtual void Reload();
}
public class OfficeOpenXml.FormulaParsing.ParsedValue : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColIndex>k__BackingField;
    public object Value { get; private set; }
    public int RowIndex { get; private set; }
    public int ColIndex { get; private set; }
    public ParsedValue(object val, int rowIndex, int colIndex);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public int get_RowIndex();
    [CompilerGeneratedAttribute]
private void set_RowIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ColIndex();
    [CompilerGeneratedAttribute]
private void set_ColIndex(int value);
}
public class OfficeOpenXml.FormulaParsing.ParsingConfiguration : object {
    [CompilerGeneratedAttribute]
private ILexer <Lexer>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormulaParserLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionGraphBuilder <GraphBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private IExpressionCompiler <ExpressionCompiler>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionRepository <FunctionRepository>k__BackingField;
    public ILexer Lexer { get; private set; }
    public IFormulaParserLogger Logger { get; private set; }
    public IExpressionGraphBuilder GraphBuilder { get; private set; }
    public IExpressionCompiler ExpressionCompiler { get; private set; }
    public FunctionRepository FunctionRepository { get; private set; }
    [CompilerGeneratedAttribute]
public virtual ILexer get_Lexer();
    [CompilerGeneratedAttribute]
private void set_Lexer(ILexer value);
    [CompilerGeneratedAttribute]
public IFormulaParserLogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(IFormulaParserLogger value);
    [CompilerGeneratedAttribute]
public IExpressionGraphBuilder get_GraphBuilder();
    [CompilerGeneratedAttribute]
private void set_GraphBuilder(IExpressionGraphBuilder value);
    [CompilerGeneratedAttribute]
public IExpressionCompiler get_ExpressionCompiler();
    [CompilerGeneratedAttribute]
private void set_ExpressionCompiler(IExpressionCompiler value);
    [CompilerGeneratedAttribute]
public FunctionRepository get_FunctionRepository();
    [CompilerGeneratedAttribute]
private void set_FunctionRepository(FunctionRepository value);
    internal static ParsingConfiguration Create();
    public ParsingConfiguration SetLexer(ILexer lexer);
    public ParsingConfiguration SetGraphBuilder(IExpressionGraphBuilder graphBuilder);
    public ParsingConfiguration SetExpresionCompiler(IExpressionCompiler expressionCompiler);
    public ParsingConfiguration AttachLogger(IFormulaParserLogger logger);
    public ParsingConfiguration DetachLogger();
}
public class OfficeOpenXml.FormulaParsing.ParsingContext : object {
    [CompilerGeneratedAttribute]
private FormulaParser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDataProvider <ExcelDataProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeAddressFactory <RangeAddressFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private INameValueProvider <NameValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ParsingConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ParsingScopes <Scopes>k__BackingField;
    public FormulaParser Parser { get; public set; }
    public ExcelDataProvider ExcelDataProvider { get; public set; }
    public RangeAddressFactory RangeAddressFactory { get; public set; }
    public INameValueProvider NameValueProvider { get; public set; }
    public ParsingConfiguration Configuration { get; public set; }
    public ParsingScopes Scopes { get; private set; }
    public bool Debug { get; }
    [CompilerGeneratedAttribute]
public FormulaParser get_Parser();
    [CompilerGeneratedAttribute]
public void set_Parser(FormulaParser value);
    [CompilerGeneratedAttribute]
public ExcelDataProvider get_ExcelDataProvider();
    [CompilerGeneratedAttribute]
public void set_ExcelDataProvider(ExcelDataProvider value);
    [CompilerGeneratedAttribute]
public RangeAddressFactory get_RangeAddressFactory();
    [CompilerGeneratedAttribute]
public void set_RangeAddressFactory(RangeAddressFactory value);
    [CompilerGeneratedAttribute]
public INameValueProvider get_NameValueProvider();
    [CompilerGeneratedAttribute]
public void set_NameValueProvider(INameValueProvider value);
    [CompilerGeneratedAttribute]
public ParsingConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(ParsingConfiguration value);
    [CompilerGeneratedAttribute]
public ParsingScopes get_Scopes();
    [CompilerGeneratedAttribute]
private void set_Scopes(ParsingScopes value);
    public bool get_Debug();
    public static ParsingContext Create();
    private sealed virtual override void OfficeOpenXml.FormulaParsing.IParsingLifetimeEventHandler.ParsingCompleted();
}
public class OfficeOpenXml.FormulaParsing.ParsingScope : object {
    private ParsingScopes _parsingScopes;
    [CompilerGeneratedAttribute]
private Guid <ScopeId>k__BackingField;
    [CompilerGeneratedAttribute]
private ParsingScope <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeAddress <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSubtotal>k__BackingField;
    public Guid ScopeId { get; private set; }
    public ParsingScope Parent { get; private set; }
    public RangeAddress Address { get; private set; }
    public bool IsSubtotal { get; public set; }
    public ParsingScope(ParsingScopes parsingScopes, RangeAddress address);
    public ParsingScope(ParsingScopes parsingScopes, ParsingScope parent, RangeAddress address);
    [CompilerGeneratedAttribute]
public Guid get_ScopeId();
    [CompilerGeneratedAttribute]
private void set_ScopeId(Guid value);
    [CompilerGeneratedAttribute]
public ParsingScope get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(ParsingScope value);
    [CompilerGeneratedAttribute]
public RangeAddress get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(RangeAddress value);
    [CompilerGeneratedAttribute]
public bool get_IsSubtotal();
    [CompilerGeneratedAttribute]
public void set_IsSubtotal(bool value);
    public sealed virtual void Dispose();
}
public class OfficeOpenXml.FormulaParsing.ParsingScopes : object {
    private IParsingLifetimeEventHandler _lifetimeEventHandler;
    private Stack`1<ParsingScope> _scopes;
    public ParsingScope Current { get; }
    public ParsingScopes(IParsingLifetimeEventHandler lifetimeEventHandler);
    public virtual ParsingScope NewScope(RangeAddress address);
    public virtual ParsingScope get_Current();
    public virtual void KillScope(ParsingScope parsingScope);
}
public class OfficeOpenXml.FormulaParsing.Utilities.ArgumentInfo`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public T Value { get; private set; }
    public string Name { get; private set; }
    public ArgumentInfo`1(T val);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public ArgumentInfo`1<T> Named(string argName);
}
[ExtensionAttribute]
public static class OfficeOpenXml.FormulaParsing.Utilities.ExtensionMethods : object {
    [ExtensionAttribute]
public static void IsNotNullOrEmpty(ArgumentInfo`1<string> val);
    [ExtensionAttribute]
public static void IsNotNull(ArgumentInfo`1<T> val);
    [ExtensionAttribute]
public static bool IsNumeric(object obj);
}
public abstract class OfficeOpenXml.FormulaParsing.Utilities.IdProvider : object {
    public abstract virtual object NewId();
}
public class OfficeOpenXml.FormulaParsing.Utilities.IntegerIdProvider : IdProvider {
    private int _lastId;
    public virtual object NewId();
}
public static class OfficeOpenXml.FormulaParsing.Utilities.RegexConstants : object {
    public static string SingleCellAddress;
    public static string ExcelAddress;
    public static string Boolean;
    public static string Decimal;
    public static string Integer;
}
public static class OfficeOpenXml.FormulaParsing.Utilities.Require : object {
    public static ArgumentInfo`1<T> That(T arg);
}
internal interface OfficeOpenXml.IRangeID {
    public ulong RangeID { get; public set; }
    public abstract virtual ulong get_RangeID();
    public abstract virtual void set_RangeID(ulong value);
}
public class OfficeOpenXml.OfficeProperties : XmlHelper {
    private XmlDocument _xmlPropertiesCore;
    private XmlDocument _xmlPropertiesExtended;
    private XmlDocument _xmlPropertiesCustom;
    private Uri _uriPropertiesCore;
    private Uri _uriPropertiesExtended;
    private Uri _uriPropertiesCustom;
    private XmlHelper _coreHelper;
    private XmlHelper _extendedHelper;
    private XmlHelper _customHelper;
    private ExcelPackage _package;
    private static string TitlePath;
    private static string SubjectPath;
    private static string AuthorPath;
    private static string CommentsPath;
    private static string KeywordsPath;
    private static string LastModifiedByPath;
    private static string LastPrintedPath;
    private static string CreatedPath;
    private static string CategoryPath;
    private static string ContentStatusPath;
    private static string ApplicationPath;
    private static string HyperlinkBasePath;
    private static string AppVersionPath;
    private static string CompanyPath;
    private static string ManagerPath;
    private static string ModifiedPath;
    public XmlDocument CorePropertiesXml { get; }
    public string Title { get; public set; }
    public string Subject { get; public set; }
    public string Author { get; public set; }
    public string Comments { get; public set; }
    public string Keywords { get; public set; }
    public string LastModifiedBy { get; public set; }
    public string LastPrinted { get; public set; }
    public DateTime Created { get; public set; }
    public string Category { get; public set; }
    public string Status { get; public set; }
    public XmlDocument ExtendedPropertiesXml { get; }
    public string Application { get; public set; }
    public Uri HyperlinkBase { get; public set; }
    public string AppVersion { get; public set; }
    public string Company { get; public set; }
    public string Manager { get; public set; }
    public DateTime Modified { get; public set; }
    public XmlDocument CustomPropertiesXml { get; }
    internal OfficeProperties(ExcelPackage package, XmlNamespaceManager ns);
    public XmlDocument get_CorePropertiesXml();
    private XmlDocument GetXmlDocument(string startXml, Uri uri, string contentType, string relationship);
    public string get_Title();
    public void set_Title(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Author();
    public void set_Author(string value);
    public string get_Comments();
    public void set_Comments(string value);
    public string get_Keywords();
    public void set_Keywords(string value);
    public string get_LastModifiedBy();
    public void set_LastModifiedBy(string value);
    public string get_LastPrinted();
    public void set_LastPrinted(string value);
    public DateTime get_Created();
    public void set_Created(DateTime value);
    public string get_Category();
    public void set_Category(string value);
    public string get_Status();
    public void set_Status(string value);
    public XmlDocument get_ExtendedPropertiesXml();
    public string get_Application();
    public void set_Application(string value);
    public Uri get_HyperlinkBase();
    public void set_HyperlinkBase(Uri value);
    public string get_AppVersion();
    public void set_AppVersion(string value);
    public string get_Company();
    public void set_Company(string value);
    public string get_Manager();
    public void set_Manager(string value);
    public DateTime get_Modified();
    public void set_Modified(DateTime value);
    public string GetExtendedPropertyValue(string propertyName);
    public void SetExtendedPropertyValue(string propertyName, string value);
    public XmlDocument get_CustomPropertiesXml();
    public object GetCustomPropertyValue(string propertyName);
    public void SetCustomPropertyValue(string propertyName, object value);
    internal void Save();
}
internal class OfficeOpenXml.Packaging.Ionic.AttributesCriterion : SelectionCriterion {
    private FileAttributes _Attributes;
    internal ComparisonOperator Operator;
    internal string AttributeString { get; internal set; }
    internal string get_AttributeString();
    internal void set_AttributeString(string value);
    public virtual string ToString();
    private bool _EvaluateOne(FileAttributes fileAttrs, FileAttributes criterionAttrs);
    internal virtual bool Evaluate(string filename);
    private bool _Evaluate(FileAttributes fileAttrs);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal enum OfficeOpenXml.Packaging.Ionic.ComparisonOperator : Enum {
    public int value__;
    [DescriptionAttribute(">")]
public static ComparisonOperator GreaterThan;
    [DescriptionAttribute(">=")]
public static ComparisonOperator GreaterThanOrEqualTo;
    [DescriptionAttribute("<")]
public static ComparisonOperator LesserThan;
    [DescriptionAttribute("<=")]
public static ComparisonOperator LesserThanOrEqualTo;
    [DescriptionAttribute("=")]
public static ComparisonOperator EqualTo;
    [DescriptionAttribute("!=")]
public static ComparisonOperator NotEqualTo;
}
internal class OfficeOpenXml.Packaging.Ionic.CompoundCriterion : SelectionCriterion {
    internal LogicalConjunction Conjunction;
    internal SelectionCriterion Left;
    private SelectionCriterion _Right;
    internal SelectionCriterion Right { get; internal set; }
    internal SelectionCriterion get_Right();
    internal void set_Right(SelectionCriterion value);
    internal virtual bool Evaluate(string filename);
    public virtual string ToString();
    internal virtual bool Evaluate(ZipEntry entry);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000C")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
internal class OfficeOpenXml.Packaging.Ionic.Crc.CRC32 : object {
    private UInt32 dwPolynomial;
    private long _TotalBytesRead;
    private bool reverseBits;
    private UInt32[] crc32Table;
    private static int BUFFER_SIZE;
    private UInt32 _register;
    public long TotalBytesRead { get; }
    public int Crc32Result { get; }
    public CRC32(bool reverseBits);
    public CRC32(int polynomial, bool reverseBits);
    public long get_TotalBytesRead();
    public int get_Crc32Result();
    public int GetCrc32(Stream input);
    public int GetCrc32AndCopy(Stream input, Stream output);
    public int ComputeCrc32(int W, byte B);
    internal int _InternalComputeCrc32(UInt32 W, byte B);
    public void SlurpBlock(Byte[] block, int offset, int count);
    public void UpdateCRC(byte b);
    public void UpdateCRC(byte b, int n);
    private static UInt32 ReverseBits(UInt32 data);
    private static byte ReverseBits(byte data);
    private void GenerateLookupTable();
    private UInt32 gf2_matrix_times(UInt32[] matrix, UInt32 vec);
    private void gf2_matrix_square(UInt32[] square, UInt32[] mat);
    public void Combine(int crc, int length);
    public void Reset();
}
internal class OfficeOpenXml.Packaging.Ionic.Crc.CrcCalculatorStream : Stream {
    private static long UnsetLengthLimit;
    internal Stream _innerStream;
    private CRC32 _Crc32;
    private long _lengthLimit;
    private bool _leaveOpen;
    public long TotalBytesSlurped { get; }
    public int Crc { get; }
    public bool LeaveOpen { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CrcCalculatorStream(Stream stream);
    public CrcCalculatorStream(Stream stream, bool leaveOpen);
    public CrcCalculatorStream(Stream stream, long length);
    public CrcCalculatorStream(Stream stream, long length, bool leaveOpen);
    public CrcCalculatorStream(Stream stream, long length, bool leaveOpen, CRC32 crc32);
    private CrcCalculatorStream(bool leaveOpen, long length, Stream stream, CRC32 crc32);
    private static CrcCalculatorStream();
    public long get_TotalBytesSlurped();
    public int get_Crc();
    public bool get_LeaveOpen();
    public void set_LeaveOpen(bool value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual void Close();
}
internal class OfficeOpenXml.Packaging.Ionic.EnumUtil : object {
    internal static string GetDescription(Enum value);
    internal static object Parse(Type enumType, string stringRepresentation);
    internal static object Parse(Type enumType, string stringRepresentation, bool ignoreCase);
}
internal class OfficeOpenXml.Packaging.Ionic.FileSelector : object {
    internal SelectionCriterion _Criterion;
    [CompilerGeneratedAttribute]
private bool <TraverseReparsePoints>k__BackingField;
    public string SelectionCriteria { get; public set; }
    public bool TraverseReparsePoints { get; public set; }
    public FileSelector(string selectionCriteria);
    public FileSelector(string selectionCriteria, bool traverseDirectoryReparsePoints);
    public string get_SelectionCriteria();
    public void set_SelectionCriteria(string value);
    [CompilerGeneratedAttribute]
public bool get_TraverseReparsePoints();
    [CompilerGeneratedAttribute]
public void set_TraverseReparsePoints(bool value);
    private static string NormalizeCriteriaExpression(string source);
    private static SelectionCriterion _ParseCriterion(string s);
    public virtual string ToString();
    private bool Evaluate(string filename);
    [ConditionalAttribute("SelectorTrace")]
private void SelectorTrace(string format, Object[] args);
    public ICollection`1<string> SelectFiles(string directory);
    public ReadOnlyCollection`1<string> SelectFiles(string directory, bool recurseDirectories);
    private bool Evaluate(ZipEntry entry);
    public ICollection`1<ZipEntry> SelectEntries(ZipFile zip);
    public ICollection`1<ZipEntry> SelectEntries(ZipFile zip, string directoryPathInArchive);
}
internal enum OfficeOpenXml.Packaging.Ionic.LogicalConjunction : Enum {
    public int value__;
    public static LogicalConjunction NONE;
    public static LogicalConjunction AND;
    public static LogicalConjunction OR;
    public static LogicalConjunction XOR;
}
internal class OfficeOpenXml.Packaging.Ionic.NameCriterion : SelectionCriterion {
    private Regex _re;
    private string _regexString;
    internal ComparisonOperator Operator;
    private string _MatchingFileSpec;
    unknown string MatchingFileSpec {internal set; }
    internal virtual void set_MatchingFileSpec(string value);
    public virtual string ToString();
    internal virtual bool Evaluate(string filename);
    private bool _Evaluate(string fullpath);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal abstract class OfficeOpenXml.Packaging.Ionic.SelectionCriterion : object {
    [CompilerGeneratedAttribute]
private bool <Verbose>k__BackingField;
    internal bool Verbose { get; internal set; }
    [CompilerGeneratedAttribute]
internal virtual bool get_Verbose();
    [CompilerGeneratedAttribute]
internal virtual void set_Verbose(bool value);
    internal abstract virtual bool Evaluate(string filename);
    [ConditionalAttribute("SelectorTrace")]
protected static void CriterionTrace(string format, Object[] args);
    internal abstract virtual bool Evaluate(ZipEntry entry);
}
internal class OfficeOpenXml.Packaging.Ionic.SizeCriterion : SelectionCriterion {
    internal ComparisonOperator Operator;
    internal long Size;
    public virtual string ToString();
    internal virtual bool Evaluate(string filename);
    private bool _Evaluate(long Length);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal class OfficeOpenXml.Packaging.Ionic.TimeCriterion : SelectionCriterion {
    internal ComparisonOperator Operator;
    internal WhichTime Which;
    internal DateTime Time;
    public virtual string ToString();
    internal virtual bool Evaluate(string filename);
    private bool _Evaluate(DateTime x);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal class OfficeOpenXml.Packaging.Ionic.TypeCriterion : SelectionCriterion {
    private char ObjectType;
    internal ComparisonOperator Operator;
    internal string AttributeString { get; internal set; }
    internal string get_AttributeString();
    internal void set_AttributeString(string value);
    public virtual string ToString();
    internal virtual bool Evaluate(string filename);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal enum OfficeOpenXml.Packaging.Ionic.WhichTime : Enum {
    public int value__;
    public static WhichTime atime;
    public static WhichTime mtime;
    public static WhichTime ctime;
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.AddOrUpdateAction : Enum {
    public int value__;
    public static AddOrUpdateAction AddOnly;
    public static AddOrUpdateAction AddOrUpdate;
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.AddProgressEventArgs : ZipProgressEventArgs {
    private AddProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    internal static AddProgressEventArgs AfterEntry(string archiveName, ZipEntry entry, int entriesTotal);
    internal static AddProgressEventArgs Started(string archiveName);
    internal static AddProgressEventArgs Completed(string archiveName);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00009")]
public class OfficeOpenXml.Packaging.Ionic.Zip.BadCrcException : ZipException {
    public BadCrcException(string message);
    protected BadCrcException(SerializationInfo info, StreamingContext context);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000B")]
public class OfficeOpenXml.Packaging.Ionic.Zip.BadPasswordException : ZipException {
    public BadPasswordException(string message);
    public BadPasswordException(string message, Exception innerException);
    protected BadPasswordException(SerializationInfo info, StreamingContext context);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000A")]
public class OfficeOpenXml.Packaging.Ionic.Zip.BadReadException : ZipException {
    public BadReadException(string message);
    public BadReadException(string message, Exception innerException);
    protected BadReadException(SerializationInfo info, StreamingContext context);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00007")]
public class OfficeOpenXml.Packaging.Ionic.Zip.BadStateException : ZipException {
    public BadStateException(string message);
    public BadStateException(string message, Exception innerException);
    protected BadStateException(SerializationInfo info, StreamingContext context);
}
public class OfficeOpenXml.Packaging.Ionic.Zip.CloseDelegate : MulticastDelegate {
    public CloseDelegate(object object, IntPtr method);
    public virtual void Invoke(string entryName, Stream stream);
    public virtual IAsyncResult BeginInvoke(string entryName, Stream stream, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000F")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
internal class OfficeOpenXml.Packaging.Ionic.Zip.ComHelper : object {
    public bool IsZipFile(string filename);
    public bool IsZipFileWithExtract(string filename);
    public bool CheckZip(string filename);
    public bool CheckZipPassword(string filename, string password);
    public void FixZipDirectory(string filename);
    public string GetZipLibraryVersion();
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.CompressionMethod : Enum {
    public int value__;
    public static CompressionMethod None;
    public static CompressionMethod Deflate;
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.CountingStream : Stream {
    private Stream _s;
    private long _bytesWritten;
    private long _bytesRead;
    private long _initialOffset;
    public Stream WrappedStream { get; }
    public long BytesWritten { get; }
    public long BytesRead { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long ComputedPosition { get; }
    public long Position { get; public set; }
    public CountingStream(Stream stream);
    public Stream get_WrappedStream();
    public long get_BytesWritten();
    public long get_BytesRead();
    public void Adjust(long delta);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public long get_ComputedPosition();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.CryptoMode : Enum {
    public int value__;
    public static CryptoMode Encrypt;
    public static CryptoMode Decrypt;
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.EncryptionAlgorithm : Enum {
    public int value__;
    public static EncryptionAlgorithm None;
    public static EncryptionAlgorithm PkzipWeak;
    public static EncryptionAlgorithm Unsupported;
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.ExtractExistingFileAction : Enum {
    public int value__;
    public static ExtractExistingFileAction Throw;
    public static ExtractExistingFileAction OverwriteSilently;
    public static ExtractExistingFileAction DoNotOverwrite;
    public static ExtractExistingFileAction InvokeExtractProgressEvent;
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ExtractProgressEventArgs : ZipProgressEventArgs {
    private int _entriesExtracted;
    private string _target;
    public int EntriesExtracted { get; }
    public string ExtractLocation { get; }
    internal ExtractProgressEventArgs(string archiveName, bool before, int entriesTotal, int entriesExtracted, ZipEntry entry, string extractLocation);
    internal ExtractProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    internal static ExtractProgressEventArgs BeforeExtractEntry(string archiveName, ZipEntry entry, string extractLocation);
    internal static ExtractProgressEventArgs ExtractExisting(string archiveName, ZipEntry entry, string extractLocation);
    internal static ExtractProgressEventArgs AfterExtractEntry(string archiveName, ZipEntry entry, string extractLocation);
    internal static ExtractProgressEventArgs ExtractAllStarted(string archiveName, string extractLocation);
    internal static ExtractProgressEventArgs ExtractAllCompleted(string archiveName, string extractLocation);
    internal static ExtractProgressEventArgs ByteUpdate(string archiveName, ZipEntry entry, long bytesWritten, long totalBytes);
    public int get_EntriesExtracted();
    public string get_ExtractLocation();
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.OffsetStream : Stream {
    private long _originalPosition;
    private Stream _innerStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OffsetStream(Stream s);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual void Close();
}
public class OfficeOpenXml.Packaging.Ionic.Zip.OpenDelegate : MulticastDelegate {
    public OpenDelegate(object object, IntPtr method);
    public virtual Stream Invoke(string entryName);
    public virtual IAsyncResult BeginInvoke(string entryName, AsyncCallback callback, object object);
    public virtual Stream EndInvoke(IAsyncResult result);
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ReadOptions : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<ReadProgressEventArgs> <ReadProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <StatusMessageWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public EventHandler`1<ReadProgressEventArgs> ReadProgress { get; public set; }
    public TextWriter StatusMessageWriter { get; public set; }
    public Encoding Encoding { get; public set; }
    [CompilerGeneratedAttribute]
public EventHandler`1<ReadProgressEventArgs> get_ReadProgress();
    [CompilerGeneratedAttribute]
public void set_ReadProgress(EventHandler`1<ReadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public TextWriter get_StatusMessageWriter();
    [CompilerGeneratedAttribute]
public void set_StatusMessageWriter(TextWriter value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ReadProgressEventArgs : ZipProgressEventArgs {
    private ReadProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    internal static ReadProgressEventArgs Before(string archiveName, int entriesTotal);
    internal static ReadProgressEventArgs After(string archiveName, ZipEntry entry, int entriesTotal);
    internal static ReadProgressEventArgs Started(string archiveName);
    internal static ReadProgressEventArgs ByteUpdate(string archiveName, ZipEntry entry, long bytesXferred, long totalBytes);
    internal static ReadProgressEventArgs Completed(string archiveName);
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.SaveProgressEventArgs : ZipProgressEventArgs {
    private int _entriesSaved;
    public int EntriesSaved { get; }
    internal SaveProgressEventArgs(string archiveName, bool before, int entriesTotal, int entriesSaved, ZipEntry entry);
    internal SaveProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    internal static SaveProgressEventArgs ByteUpdate(string archiveName, ZipEntry entry, long bytesXferred, long totalBytes);
    internal static SaveProgressEventArgs Started(string archiveName);
    internal static SaveProgressEventArgs Completed(string archiveName);
    public int get_EntriesSaved();
}
public class OfficeOpenXml.Packaging.Ionic.Zip.SetCompressionCallback : MulticastDelegate {
    public SetCompressionCallback(object object, IntPtr method);
    public virtual CompressionLevel Invoke(string localFileName, string fileNameInArchive);
    public virtual IAsyncResult BeginInvoke(string localFileName, string fileNameInArchive, AsyncCallback callback, object object);
    public virtual CompressionLevel EndInvoke(IAsyncResult result);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00008")]
public class OfficeOpenXml.Packaging.Ionic.Zip.SfxGenerationException : ZipException {
    public SfxGenerationException(string message);
    protected SfxGenerationException(SerializationInfo info, StreamingContext context);
}
internal static class OfficeOpenXml.Packaging.Ionic.Zip.SharedUtilities : object {
    private static Regex doubleDotRegex1;
    private static Encoding ibm437;
    private static Encoding utf8;
    private static SharedUtilities();
    public static long GetFileLength(string fileName);
    [ConditionalAttribute("NETCF")]
public static void Workaround_Ladybug318918(Stream s);
    private static string SimplifyFwdSlashPath(string path);
    public static string NormalizePathForUseInZipFile(string pathName);
    internal static Byte[] StringToByteArray(string value, Encoding encoding);
    internal static Byte[] StringToByteArray(string value);
    internal static string Utf8StringFromBuffer(Byte[] buf);
    internal static string StringFromBuffer(Byte[] buf, Encoding encoding);
    internal static int ReadSignature(Stream s);
    internal static int ReadEntrySignature(Stream s);
    internal static int ReadInt(Stream s);
    private static int _ReadFourBytes(Stream s, string message);
    internal static long FindSignature(Stream stream, int SignatureToFind);
    internal static DateTime AdjustTime_Reverse(DateTime time);
    internal static DateTime PackedToDateTime(int packedDateTime);
    internal static int DateTimeToPacked(DateTime time);
    public static void CreateAndOpenUniqueTempFile(string dir, Stream& fs, String& filename);
    public static string InternalGetTempFileName();
    internal static int ReadWithRetry(Stream s, Byte[] buffer, int offset, int count, string FileName);
    private static UInt32 _HRForException(Exception ex1);
}
public class OfficeOpenXml.Packaging.Ionic.Zip.WriteDelegate : MulticastDelegate {
    public WriteDelegate(object object, IntPtr method);
    public virtual void Invoke(string entryName, Stream stream);
    public virtual IAsyncResult BeginInvoke(string entryName, Stream stream, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.Zip64Option : Enum {
    public int value__;
    public static Zip64Option Default;
    public static Zip64Option Never;
    public static Zip64Option AsNecessary;
    public static Zip64Option Always;
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ZipCipherStream : Stream {
    private ZipCrypto _cipher;
    private Stream _s;
    private CryptoMode _mode;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZipCipherStream(Stream s, ZipCrypto cipher, CryptoMode mode);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal static class OfficeOpenXml.Packaging.Ionic.Zip.ZipConstants : object {
    public static UInt32 PackedToRemovableMedia;
    public static UInt32 Zip64EndOfCentralDirectoryRecordSignature;
    public static UInt32 Zip64EndOfCentralDirectoryLocatorSignature;
    public static UInt32 EndOfCentralDirectorySignature;
    public static int ZipEntrySignature;
    public static int ZipEntryDataDescriptorSignature;
    public static int SplitArchiveSignature;
    public static int ZipDirEntrySignature;
    public static int AesKeySize;
    public static int AesBlockSize;
    public static ushort AesAlgId128;
    public static ushort AesAlgId192;
    public static ushort AesAlgId256;
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ZipContainer : object {
    private ZipFile _zf;
    private ZipOutputStream _zos;
    private ZipInputStream _zis;
    public ZipFile ZipFile { get; }
    public ZipOutputStream ZipOutputStream { get; }
    public string Name { get; }
    public string Password { get; }
    public Zip64Option Zip64 { get; }
    public int BufferSize { get; }
    public ParallelDeflateOutputStream ParallelDeflater { get; public set; }
    public long ParallelDeflateThreshold { get; }
    public int ParallelDeflateMaxBufferPairs { get; }
    public int CodecBufferSize { get; }
    public CompressionStrategy Strategy { get; }
    public Zip64Option UseZip64WhenSaving { get; }
    public Encoding AlternateEncoding { get; }
    public Encoding DefaultEncoding { get; }
    public ZipOption AlternateEncodingUsage { get; }
    public Stream ReadStream { get; }
    public ZipContainer(object o);
    public ZipFile get_ZipFile();
    public ZipOutputStream get_ZipOutputStream();
    public string get_Name();
    public string get_Password();
    public Zip64Option get_Zip64();
    public int get_BufferSize();
    public ParallelDeflateOutputStream get_ParallelDeflater();
    public void set_ParallelDeflater(ParallelDeflateOutputStream value);
    public long get_ParallelDeflateThreshold();
    public int get_ParallelDeflateMaxBufferPairs();
    public int get_CodecBufferSize();
    public CompressionStrategy get_Strategy();
    public Zip64Option get_UseZip64WhenSaving();
    public Encoding get_AlternateEncoding();
    public Encoding get_DefaultEncoding();
    public ZipOption get_AlternateEncodingUsage();
    public Stream get_ReadStream();
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ZipCrypto : object {
    private UInt32[] _Keys;
    private CRC32 crc32;
    private byte MagicByte { get; }
    public static ZipCrypto ForWrite(string password);
    public static ZipCrypto ForRead(string password, ZipEntry e);
    private byte get_MagicByte();
    public Byte[] DecryptMessage(Byte[] cipherText, int length);
    public Byte[] EncryptMessage(Byte[] plainText, int length);
    public void InitCipher(string passphrase);
    private void UpdateKeys(byte byteValue);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00004")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
internal class OfficeOpenXml.Packaging.Ionic.Zip.ZipEntry : object {
    private short _VersionMadeBy;
    private short _InternalFileAttrs;
    private int _ExternalFileAttrs;
    private short _filenameLength;
    private short _extraFieldLength;
    private short _commentLength;
    [CompilerGeneratedAttribute]
private ExtractExistingFileAction <ExtractExistingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipErrorAction <ZipErrorAction>k__BackingField;
    [CompilerGeneratedAttribute]
private SetCompressionCallback <SetCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <ProvisionalAlternateEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <AlternateEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipOption <AlternateEncodingUsage>k__BackingField;
    private ZipCrypto _zipCrypto_forExtract;
    private ZipCrypto _zipCrypto_forWrite;
    internal DateTime _LastModified;
    private DateTime _Mtime;
    private DateTime _Atime;
    private DateTime _Ctime;
    private bool _ntfsTimesAreSet;
    private bool _emitNtfsTimes;
    private bool _emitUnixTimes;
    private bool _TrimVolumeFromFullyQualifiedPaths;
    internal string _LocalFileName;
    private string _FileNameInArchive;
    internal short _VersionNeeded;
    internal short _BitField;
    internal short _CompressionMethod;
    private short _CompressionMethod_FromZipFile;
    private CompressionLevel _CompressionLevel;
    internal string _Comment;
    private bool _IsDirectory;
    private Byte[] _CommentBytes;
    internal long _CompressedSize;
    internal long _CompressedFileDataSize;
    internal long _UncompressedSize;
    internal int _TimeBlob;
    private bool _crcCalculated;
    internal int _Crc32;
    internal Byte[] _Extra;
    private bool _metadataChanged;
    private bool _restreamRequiredOnSave;
    private bool _sourceIsEncrypted;
    private bool _skippedDuringSave;
    private UInt32 _diskNumber;
    private static Encoding ibm437;
    private Encoding _actualEncoding;
    internal ZipContainer _container;
    private long __FileDataPosition;
    private Byte[] _EntryHeader;
    internal long _RelativeOffsetOfLocalHeader;
    private long _future_ROLH;
    private long _TotalEntrySize;
    private int _LengthOfHeader;
    private int _LengthOfTrailer;
    internal bool _InputUsesZip64;
    private UInt32 _UnsupportedAlgorithmId;
    internal string _Password;
    internal ZipEntrySource _Source;
    internal EncryptionAlgorithm _Encryption;
    internal EncryptionAlgorithm _Encryption_FromZipFile;
    internal Byte[] _WeakEncryptionHeader;
    internal Stream _archiveStream;
    private Stream _sourceStream;
    private Nullable`1<long> _sourceStreamOriginalPosition;
    private bool _sourceWasJitProvided;
    private bool _ioOperationCanceled;
    private bool _presumeZip64;
    private Nullable`1<bool> _entryRequiresZip64;
    private Nullable`1<bool> _OutputUsesZip64;
    private bool _IsText;
    private ZipEntryTimestamp _timestamp;
    private static DateTime _unixEpoch;
    private static DateTime _win32Epoch;
    private static DateTime _zeroHour;
    private WriteDelegate _WriteDelegate;
    private OpenDelegate _OpenDelegate;
    private CloseDelegate _CloseDelegate;
    private Stream _inputDecryptorStream;
    private int _readExtraDepth;
    private object _outputLock;
    internal bool AttributesIndicateDirectory { get; }
    public string Info { get; }
    public DateTime LastModified { get; public set; }
    private int BufferSize { get; }
    public DateTime ModifiedTime { get; public set; }
    public DateTime AccessedTime { get; public set; }
    public DateTime CreationTime { get; public set; }
    public bool EmitTimesInWindowsFormatWhenSaving { get; public set; }
    public bool EmitTimesInUnixFormatWhenSaving { get; public set; }
    internal ZipEntryTimestamp Timestamp { get; }
    public FileAttributes Attributes { get; public set; }
    internal string LocalFileName { get; }
    public string FileName { get; public set; }
    public Stream InputStream { get; public set; }
    public bool InputStreamWasJitProvided { get; }
    internal ZipEntrySource Source { get; }
    public short VersionNeeded { get; }
    public string Comment { get; public set; }
    public Nullable`1<bool> RequiresZip64 { get; }
    public Nullable`1<bool> OutputUsedZip64 { get; }
    public short BitField { get; }
    internal CompressionMethod CompressionMethod { get; internal set; }
    public CompressionLevel CompressionLevel { get; public set; }
    public long CompressedSize { get; }
    public long UncompressedSize { get; }
    public double CompressionRatio { get; }
    public int Crc { get; }
    public bool IsDirectory { get; }
    public bool UsesEncryption { get; }
    internal EncryptionAlgorithm Encryption { get; internal set; }
    private string Password { get; public set; }
    internal bool IsChanged { get; }
    internal ExtractExistingFileAction ExtractExistingFile { get; internal set; }
    internal ZipErrorAction ZipErrorAction { get; internal set; }
    internal bool IncludedInMostRecentSave { get; }
    public SetCompressionCallback SetCompression { get; public set; }
    [ObsoleteAttribute("Beginning with v1.9.1.6 of DotNetZip, this property is obsolete.  It will be removed in a future version of the library. Your applications should  use AlternateEncoding and AlternateEncodingUsage instead.")]
public bool UseUnicodeAsNecessary { get; public set; }
    [ObsoleteAttribute("This property is obsolete since v1.9.1.6. Use AlternateEncoding and AlternateEncodingUsage instead.", "True")]
public Encoding ProvisionalAlternateEncoding { get; public set; }
    public Encoding AlternateEncoding { get; public set; }
    internal ZipOption AlternateEncodingUsage { get; internal set; }
    public bool IsText { get; public set; }
    internal Stream ArchiveStream { get; }
    internal long FileDataPosition { get; }
    private int LengthOfHeader { get; }
    private string UnsupportedAlgorithm { get; }
    private string UnsupportedCompressionMethod { get; }
    private static ZipEntry();
    internal bool get_AttributesIndicateDirectory();
    internal void ResetDirEntry();
    public string get_Info();
    internal static ZipEntry ReadDirEntry(ZipFile zf, Dictionary`2<string, object> previouslySeen);
    internal static bool IsNotValidZipDirEntrySig(int signature);
    public DateTime get_LastModified();
    public void set_LastModified(DateTime value);
    private int get_BufferSize();
    public DateTime get_ModifiedTime();
    public void set_ModifiedTime(DateTime value);
    public DateTime get_AccessedTime();
    public void set_AccessedTime(DateTime value);
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public void SetEntryTimes(DateTime created, DateTime accessed, DateTime modified);
    public bool get_EmitTimesInWindowsFormatWhenSaving();
    public void set_EmitTimesInWindowsFormatWhenSaving(bool value);
    public bool get_EmitTimesInUnixFormatWhenSaving();
    public void set_EmitTimesInUnixFormatWhenSaving(bool value);
    internal ZipEntryTimestamp get_Timestamp();
    public FileAttributes get_Attributes();
    public void set_Attributes(FileAttributes value);
    internal string get_LocalFileName();
    public string get_FileName();
    public void set_FileName(string value);
    public Stream get_InputStream();
    public void set_InputStream(Stream value);
    public bool get_InputStreamWasJitProvided();
    internal ZipEntrySource get_Source();
    public short get_VersionNeeded();
    public string get_Comment();
    public void set_Comment(string value);
    public Nullable`1<bool> get_RequiresZip64();
    public Nullable`1<bool> get_OutputUsedZip64();
    public short get_BitField();
    internal CompressionMethod get_CompressionMethod();
    internal void set_CompressionMethod(CompressionMethod value);
    public CompressionLevel get_CompressionLevel();
    public void set_CompressionLevel(CompressionLevel value);
    public long get_CompressedSize();
    public long get_UncompressedSize();
    public double get_CompressionRatio();
    public int get_Crc();
    public bool get_IsDirectory();
    public bool get_UsesEncryption();
    internal EncryptionAlgorithm get_Encryption();
    internal void set_Encryption(EncryptionAlgorithm value);
    public void set_Password(string value);
    private string get_Password();
    internal bool get_IsChanged();
    [CompilerGeneratedAttribute]
internal ExtractExistingFileAction get_ExtractExistingFile();
    [CompilerGeneratedAttribute]
internal void set_ExtractExistingFile(ExtractExistingFileAction value);
    [CompilerGeneratedAttribute]
internal ZipErrorAction get_ZipErrorAction();
    [CompilerGeneratedAttribute]
internal void set_ZipErrorAction(ZipErrorAction value);
    internal bool get_IncludedInMostRecentSave();
    [CompilerGeneratedAttribute]
public SetCompressionCallback get_SetCompression();
    [CompilerGeneratedAttribute]
public void set_SetCompression(SetCompressionCallback value);
    public bool get_UseUnicodeAsNecessary();
    public void set_UseUnicodeAsNecessary(bool value);
    [CompilerGeneratedAttribute]
public Encoding get_ProvisionalAlternateEncoding();
    [CompilerGeneratedAttribute]
public void set_ProvisionalAlternateEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public Encoding get_AlternateEncoding();
    [CompilerGeneratedAttribute]
public void set_AlternateEncoding(Encoding value);
    [CompilerGeneratedAttribute]
internal ZipOption get_AlternateEncodingUsage();
    [CompilerGeneratedAttribute]
internal void set_AlternateEncodingUsage(ZipOption value);
    internal static string NameInArchive(string filename, string directoryPathInArchive);
    internal static ZipEntry CreateFromNothing(string nameInArchive);
    internal static ZipEntry CreateFromFile(string filename, string nameInArchive);
    internal static ZipEntry CreateForStream(string entryName, Stream s);
    internal static ZipEntry CreateForWriter(string entryName, WriteDelegate d);
    internal static ZipEntry CreateForJitStreamProvider(string nameInArchive, OpenDelegate opener, CloseDelegate closer);
    internal static ZipEntry CreateForZipOutputStream(string nameInArchive);
    private static ZipEntry Create(string nameInArchive, ZipEntrySource source, object arg1, object arg2);
    internal void MarkAsDirectory();
    public bool get_IsText();
    public void set_IsText(bool value);
    public virtual string ToString();
    internal Stream get_ArchiveStream();
    private void SetFdpLoh();
    internal static int GetLengthOfCryptoHeaderBytes(EncryptionAlgorithm a);
    internal long get_FileDataPosition();
    private int get_LengthOfHeader();
    internal void Extract();
    internal void Extract(ExtractExistingFileAction extractExistingFile);
    public void Extract(Stream stream);
    public void Extract(string baseDirectory);
    internal void Extract(string baseDirectory, ExtractExistingFileAction extractExistingFile);
    public void ExtractWithPassword(string password);
    public void ExtractWithPassword(string baseDirectory, string password);
    internal void ExtractWithPassword(ExtractExistingFileAction extractExistingFile, string password);
    internal void ExtractWithPassword(string baseDirectory, ExtractExistingFileAction extractExistingFile, string password);
    public void ExtractWithPassword(Stream stream, string password);
    internal CrcCalculatorStream OpenReader();
    internal CrcCalculatorStream OpenReader(string password);
    internal CrcCalculatorStream InternalOpenReader(string password);
    private void OnExtractProgress(long bytesWritten, long totalBytesToWrite);
    private void OnBeforeExtract(string path);
    private void OnAfterExtract(string path);
    private void OnExtractExisting(string path);
    private static void ReallyDelete(string fileName);
    private void WriteStatus(string format, Object[] args);
    private void InternalExtract(string baseDir, Stream outstream, string password);
    internal void VerifyCrcAfterExtract(int actualCrc32);
    private int CheckExtractExistingFile(string baseDir, string targetFileName);
    private void _CheckRead(int nbytes);
    private int ExtractOne(Stream output);
    internal Stream GetExtractDecompressor(Stream input2);
    internal Stream GetExtractDecryptor(Stream input);
    internal void _SetTimes(string fileOrDirectory, bool isFile);
    private string get_UnsupportedAlgorithm();
    private string get_UnsupportedCompressionMethod();
    internal void ValidateEncryption();
    private void ValidateCompression();
    private void SetupCryptoForExtract(string password);
    private bool ValidateOutput(string basedir, Stream outstream, String& outFileName);
    private void ReadExtraField();
    private static bool ReadHeader(ZipEntry ze, Encoding defaultEncoding);
    internal static int ReadWeakEncryptionHeader(Stream s, Byte[] buffer);
    private static bool IsNotValidSig(int signature);
    internal static ZipEntry ReadEntry(ZipContainer zc, bool first);
    internal static void HandlePK00Prefix(Stream s);
    private static void HandleUnexpectedDataDescriptor(ZipEntry entry);
    internal static int FindExtraFieldSegment(Byte[] extra, int offx, ushort targetHeaderId);
    internal int ProcessExtraField(Stream s, short extraFieldLength);
    private int ProcessExtraFieldPkwareStrongEncryption(Byte[] Buffer, int j);
    private int ProcessExtraFieldZip64(Byte[] buffer, int j, short dataSize, long posn);
    private int ProcessExtraFieldInfoZipTimes(Byte[] buffer, int j, short dataSize, long posn);
    private int ProcessExtraFieldUnixTimes(Byte[] buffer, int j, short dataSize, long posn);
    private int ProcessExtraFieldWindowsTimes(Byte[] buffer, int j, short dataSize, long posn);
    internal void WriteCentralDirectoryEntry(Stream s);
    private Byte[] ConstructExtraField(bool forCentralDirectory);
    private string NormalizeFileName();
    private Byte[] GetEncodedFileNameBytes();
    private bool WantReadAgain();
    private void MaybeUnsetCompressionMethodForWriting(int cycle);
    internal void WriteHeader(Stream s, int cycle);
    private int FigureCrc32();
    private void PrepSourceStream();
    internal void CopyMetaData(ZipEntry source);
    private void OnWriteBlock(long bytesXferred, long totalBytesToXfer);
    private void _WriteEntryData(Stream s);
    private long SetInputAndFigureFileLength(Stream& input);
    internal void FinishOutputStream(Stream s, CountingStream entryCounter, Stream encryptor, Stream compressor, CrcCalculatorStream output);
    internal void PostProcessOutput(Stream s);
    private void SetZip64Flags();
    internal void PrepOutputStream(Stream s, long streamLength, CountingStream& outputCounter, Stream& encryptor, Stream& compressor, CrcCalculatorStream& output);
    private Stream MaybeApplyCompression(Stream s, long streamLength);
    private Stream MaybeApplyEncryption(Stream s);
    private void OnZipErrorWhileSaving(Exception e);
    internal void Write(Stream s);
    internal void StoreRelativeOffset();
    internal void NotifySaveComplete();
    internal void WriteSecurityMetadata(Stream outstream);
    private void CopyThroughOneEntry(Stream outStream);
    private void CopyThroughWithRecompute(Stream outstream);
    private void CopyThroughWithNoChange(Stream outstream);
    [ConditionalAttribute("Trace")]
private void TraceWriteLine(string format, Object[] varParams);
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.ZipEntrySource : Enum {
    public int value__;
    public static ZipEntrySource None;
    public static ZipEntrySource FileSystem;
    public static ZipEntrySource Stream;
    public static ZipEntrySource ZipFile;
    public static ZipEntrySource WriteDelegate;
    public static ZipEntrySource JitStream;
    public static ZipEntrySource ZipOutputStream;
}
[FlagsAttribute]
internal enum OfficeOpenXml.Packaging.Ionic.Zip.ZipEntryTimestamp : Enum {
    public int value__;
    public static ZipEntryTimestamp None;
    public static ZipEntryTimestamp DOS;
    public static ZipEntryTimestamp Windows;
    public static ZipEntryTimestamp Unix;
    public static ZipEntryTimestamp InfoZip1;
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorAction : Enum {
    public int value__;
    public static ZipErrorAction Throw;
    public static ZipErrorAction Skip;
    public static ZipErrorAction Retry;
    public static ZipErrorAction InvokeErrorEvent;
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ZipErrorEventArgs : ZipProgressEventArgs {
    private Exception _exc;
    public Exception Exception { get; }
    public string FileName { get; }
    internal static ZipErrorEventArgs Saving(string archiveName, ZipEntry entry, Exception exception);
    public Exception get_Exception();
    public string get_FileName();
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00006")]
public class OfficeOpenXml.Packaging.Ionic.Zip.ZipException : Exception {
    public ZipException(string message);
    public ZipException(string message, Exception innerException);
    protected ZipException(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00005")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
internal class OfficeOpenXml.Packaging.Ionic.Zip.ZipFile : object {
    [CompilerGeneratedAttribute]
private bool <FullScan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortEntriesBeforeSaving>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddDirectoryWillTraverseReparsePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodecBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlattenFoldersOnExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractExistingFileAction <ExtractExistingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private SetCompressionCallback <SetCompression>k__BackingField;
    private TextWriter _StatusMessageTextWriter;
    private bool _CaseSensitiveRetrieval;
    private Stream _readstream;
    private Stream _writestream;
    private ushort _versionMadeBy;
    private ushort _versionNeededToExtract;
    private UInt32 _diskNumberWithCd;
    private int _maxOutputSegmentSize;
    private UInt32 _numberOfSegmentsForMostRecentSave;
    private ZipErrorAction _zipErrorAction;
    private bool _disposed;
    private Dictionary`2<string, ZipEntry> _entries;
    private List`1<ZipEntry> _zipEntriesAsList;
    private string _name;
    private string _readName;
    private string _Comment;
    internal string _Password;
    private bool _emitNtfsTimes;
    private bool _emitUnixTimes;
    private CompressionStrategy _Strategy;
    private CompressionMethod _compressionMethod;
    private bool _fileAlreadyExists;
    private string _temporaryFileName;
    private bool _contentsChanged;
    private bool _hasBeenSaved;
    private string _TempFileFolder;
    private bool _ReadStreamIsOurs;
    private object LOCK;
    private bool _saveOperationCanceled;
    private bool _extractOperationCanceled;
    private bool _addOperationCanceled;
    private EncryptionAlgorithm _Encryption;
    private bool _JustSaved;
    private long _locEndOfCDS;
    private UInt32 _OffsetOfCentralDirectory;
    private long _OffsetOfCentralDirectory64;
    private Nullable`1<bool> _OutputUsesZip64;
    internal bool _inExtractAll;
    private Encoding _alternateEncoding;
    private ZipOption _alternateEncodingUsage;
    private static Encoding _defaultEncoding;
    private int _BufferSize;
    internal ParallelDeflateOutputStream ParallelDeflater;
    private long _ParallelDeflateThreshold;
    private int _maxBufferPairs;
    internal Zip64Option _zip64;
    private bool _SavingSfx;
    public static int BufferSizeDefault;
    [CompilerGeneratedAttribute]
private EventHandler`1<SaveProgressEventArgs> SaveProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<ReadProgressEventArgs> ReadProgress;
    private long _lengthOfReadStream;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExtractProgressEventArgs> ExtractProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddProgressEventArgs> AddProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<ZipErrorEventArgs> ZipError;
    public string Info { get; }
    public bool FullScan { get; public set; }
    public bool SortEntriesBeforeSaving { get; public set; }
    public bool AddDirectoryWillTraverseReparsePoints { get; public set; }
    public int BufferSize { get; public set; }
    public int CodecBufferSize { get; public set; }
    public bool FlattenFoldersOnExtract { get; public set; }
    public CompressionStrategy Strategy { get; public set; }
    public string Name { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    internal CompressionMethod CompressionMethod { get; internal set; }
    public string Comment { get; public set; }
    public bool EmitTimesInWindowsFormatWhenSaving { get; public set; }
    public bool EmitTimesInUnixFormatWhenSaving { get; public set; }
    internal bool Verbose { get; }
    public bool CaseSensitiveRetrieval { get; public set; }
    [ObsoleteAttribute("Beginning with v1.9.1.6 of DotNetZip, this property is obsolete.  It will be removed in a future version of the library. Your applications should  use AlternateEncoding and AlternateEncodingUsage instead.")]
public bool UseUnicodeAsNecessary { get; public set; }
    internal Zip64Option UseZip64WhenSaving { get; internal set; }
    public Nullable`1<bool> RequiresZip64 { get; }
    public Nullable`1<bool> OutputUsedZip64 { get; }
    public Nullable`1<bool> InputUsesZip64 { get; }
    [ObsoleteAttribute("use AlternateEncoding instead.")]
public Encoding ProvisionalAlternateEncoding { get; public set; }
    public Encoding AlternateEncoding { get; public set; }
    internal ZipOption AlternateEncodingUsage { get; internal set; }
    public static Encoding DefaultEncoding { get; }
    public TextWriter StatusMessageTextWriter { get; public set; }
    public string TempFileFolder { get; public set; }
    private string Password { get; public set; }
    internal ExtractExistingFileAction ExtractExistingFile { get; internal set; }
    internal ZipErrorAction ZipErrorAction { get; internal set; }
    internal EncryptionAlgorithm Encryption { get; internal set; }
    public SetCompressionCallback SetCompression { get; public set; }
    public int MaxOutputSegmentSize { get; public set; }
    public int NumberOfSegmentsForMostRecentSave { get; }
    public long ParallelDeflateThreshold { get; public set; }
    public int ParallelDeflateMaxBufferPairs { get; public set; }
    public static Version LibraryVersion { get; }
    private List`1<ZipEntry> ZipEntriesAsList { get; }
    public ZipEntry Item { get; }
    public ZipEntry Item { get; }
    public ICollection`1<string> EntryFileNames { get; }
    public ICollection`1<ZipEntry> Entries { get; }
    public ICollection`1<ZipEntry> EntriesSorted { get; }
    public int Count { get; }
    internal Stream ReadStream { get; }
    private Stream WriteStream { get; private set; }
    private string ArchiveNameForEvent { get; }
    private long LengthOfReadStream { get; }
    public ZipFile(string fileName);
    public ZipFile(string fileName, Encoding encoding);
    public ZipFile(Encoding encoding);
    public ZipFile(string fileName, TextWriter statusMessageWriter);
    public ZipFile(string fileName, TextWriter statusMessageWriter, Encoding encoding);
    private static ZipFile();
    public ZipEntry AddItem(string fileOrDirectoryName);
    public ZipEntry AddItem(string fileOrDirectoryName, string directoryPathInArchive);
    public ZipEntry AddFile(string fileName);
    public ZipEntry AddFile(string fileName, string directoryPathInArchive);
    public void RemoveEntries(ICollection`1<ZipEntry> entriesToRemove);
    public void RemoveEntries(ICollection`1<string> entriesToRemove);
    public void AddFiles(IEnumerable`1<string> fileNames);
    public void UpdateFiles(IEnumerable`1<string> fileNames);
    public void AddFiles(IEnumerable`1<string> fileNames, string directoryPathInArchive);
    public void AddFiles(IEnumerable`1<string> fileNames, bool preserveDirHierarchy, string directoryPathInArchive);
    public void UpdateFiles(IEnumerable`1<string> fileNames, string directoryPathInArchive);
    public ZipEntry UpdateFile(string fileName);
    public ZipEntry UpdateFile(string fileName, string directoryPathInArchive);
    public ZipEntry UpdateDirectory(string directoryName);
    public ZipEntry UpdateDirectory(string directoryName, string directoryPathInArchive);
    public void UpdateItem(string itemName);
    public void UpdateItem(string itemName, string directoryPathInArchive);
    public ZipEntry AddEntry(string entryName, string content);
    public ZipEntry AddEntry(string entryName, string content, Encoding encoding);
    public ZipEntry AddEntry(string entryName, Stream stream);
    public ZipEntry AddEntry(string entryName, WriteDelegate writer);
    public ZipEntry AddEntry(string entryName, OpenDelegate opener, CloseDelegate closer);
    private ZipEntry _InternalAddEntry(ZipEntry ze);
    public ZipEntry UpdateEntry(string entryName, string content);
    public ZipEntry UpdateEntry(string entryName, string content, Encoding encoding);
    public ZipEntry UpdateEntry(string entryName, WriteDelegate writer);
    public ZipEntry UpdateEntry(string entryName, OpenDelegate opener, CloseDelegate closer);
    public ZipEntry UpdateEntry(string entryName, Stream stream);
    private void RemoveEntryForUpdate(string entryName);
    public ZipEntry AddEntry(string entryName, Byte[] byteContent);
    public ZipEntry UpdateEntry(string entryName, Byte[] byteContent);
    public ZipEntry AddDirectory(string directoryName);
    public ZipEntry AddDirectory(string directoryName, string directoryPathInArchive);
    public ZipEntry AddDirectoryByName(string directoryNameInArchive);
    private ZipEntry AddOrUpdateDirectoryImpl(string directoryName, string rootDirectoryPathInArchive, AddOrUpdateAction action);
    internal void InternalAddEntry(string name, ZipEntry entry);
    private ZipEntry AddOrUpdateDirectoryImpl(string directoryName, string rootDirectoryPathInArchive, AddOrUpdateAction action, bool recurse, int level);
    public static bool CheckZip(string zipFileName);
    public static bool CheckZip(string zipFileName, bool fixIfNecessary, TextWriter writer);
    public static void FixZipDirectory(string zipFileName);
    public static bool CheckZipPassword(string zipFileName, string password);
    public string get_Info();
    [CompilerGeneratedAttribute]
public bool get_FullScan();
    [CompilerGeneratedAttribute]
public void set_FullScan(bool value);
    [CompilerGeneratedAttribute]
public bool get_SortEntriesBeforeSaving();
    [CompilerGeneratedAttribute]
public void set_SortEntriesBeforeSaving(bool value);
    [CompilerGeneratedAttribute]
public bool get_AddDirectoryWillTraverseReparsePoints();
    [CompilerGeneratedAttribute]
public void set_AddDirectoryWillTraverseReparsePoints(bool value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_CodecBufferSize();
    [CompilerGeneratedAttribute]
public void set_CodecBufferSize(int value);
    [CompilerGeneratedAttribute]
public bool get_FlattenFoldersOnExtract();
    [CompilerGeneratedAttribute]
public void set_FlattenFoldersOnExtract(bool value);
    public CompressionStrategy get_Strategy();
    public void set_Strategy(CompressionStrategy value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    internal CompressionMethod get_CompressionMethod();
    internal void set_CompressionMethod(CompressionMethod value);
    public string get_Comment();
    public void set_Comment(string value);
    public bool get_EmitTimesInWindowsFormatWhenSaving();
    public void set_EmitTimesInWindowsFormatWhenSaving(bool value);
    public bool get_EmitTimesInUnixFormatWhenSaving();
    public void set_EmitTimesInUnixFormatWhenSaving(bool value);
    internal bool get_Verbose();
    public bool ContainsEntry(string name);
    public bool get_CaseSensitiveRetrieval();
    public void set_CaseSensitiveRetrieval(bool value);
    public bool get_UseUnicodeAsNecessary();
    public void set_UseUnicodeAsNecessary(bool value);
    internal Zip64Option get_UseZip64WhenSaving();
    internal void set_UseZip64WhenSaving(Zip64Option value);
    public Nullable`1<bool> get_RequiresZip64();
    public Nullable`1<bool> get_OutputUsedZip64();
    public Nullable`1<bool> get_InputUsesZip64();
    public Encoding get_ProvisionalAlternateEncoding();
    public void set_ProvisionalAlternateEncoding(Encoding value);
    public Encoding get_AlternateEncoding();
    public void set_AlternateEncoding(Encoding value);
    internal ZipOption get_AlternateEncodingUsage();
    internal void set_AlternateEncodingUsage(ZipOption value);
    public static Encoding get_DefaultEncoding();
    public TextWriter get_StatusMessageTextWriter();
    public void set_StatusMessageTextWriter(TextWriter value);
    public string get_TempFileFolder();
    public void set_TempFileFolder(string value);
    public void set_Password(string value);
    private string get_Password();
    [CompilerGeneratedAttribute]
internal ExtractExistingFileAction get_ExtractExistingFile();
    [CompilerGeneratedAttribute]
internal void set_ExtractExistingFile(ExtractExistingFileAction value);
    internal ZipErrorAction get_ZipErrorAction();
    internal void set_ZipErrorAction(ZipErrorAction value);
    internal EncryptionAlgorithm get_Encryption();
    internal void set_Encryption(EncryptionAlgorithm value);
    [CompilerGeneratedAttribute]
public SetCompressionCallback get_SetCompression();
    [CompilerGeneratedAttribute]
public void set_SetCompression(SetCompressionCallback value);
    public int get_MaxOutputSegmentSize();
    public void set_MaxOutputSegmentSize(int value);
    public int get_NumberOfSegmentsForMostRecentSave();
    public void set_ParallelDeflateThreshold(long value);
    public long get_ParallelDeflateThreshold();
    public int get_ParallelDeflateMaxBufferPairs();
    public void set_ParallelDeflateMaxBufferPairs(int value);
    public virtual string ToString();
    public static Version get_LibraryVersion();
    internal void NotifyEntryChanged();
    internal Stream StreamForDiskNumber(UInt32 diskNumber);
    internal void Reset(bool whileSaving);
    public void Initialize(string fileName);
    private void _initEntriesDictionary();
    private void _InitInstance(string zipFileName, TextWriter statusMessageWriter);
    private List`1<ZipEntry> get_ZipEntriesAsList();
    public ZipEntry get_Item(int ix);
    public ZipEntry get_Item(string fileName);
    public ICollection`1<string> get_EntryFileNames();
    public ICollection`1<ZipEntry> get_Entries();
    public ICollection`1<ZipEntry> get_EntriesSorted();
    public int get_Count();
    public void RemoveEntry(ZipEntry entry);
    public void RemoveEntry(string fileName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposeManagedResources);
    internal Stream get_ReadStream();
    private Stream get_WriteStream();
    private void set_WriteStream(Stream value);
    private string get_ArchiveNameForEvent();
    [CompilerGeneratedAttribute]
internal void add_SaveProgress(EventHandler`1<SaveProgressEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_SaveProgress(EventHandler`1<SaveProgressEventArgs> value);
    internal bool OnSaveBlock(ZipEntry entry, long bytesXferred, long totalBytesToXfer);
    private void OnSaveEntry(int current, ZipEntry entry, bool before);
    private void OnSaveEvent(ZipProgressEventType eventFlavor);
    private void OnSaveStarted();
    private void OnSaveCompleted();
    [CompilerGeneratedAttribute]
internal void add_ReadProgress(EventHandler`1<ReadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ReadProgress(EventHandler`1<ReadProgressEventArgs> value);
    private void OnReadStarted();
    private void OnReadCompleted();
    internal void OnReadBytes(ZipEntry entry);
    internal void OnReadEntry(bool before, ZipEntry entry);
    private long get_LengthOfReadStream();
    [CompilerGeneratedAttribute]
internal void add_ExtractProgress(EventHandler`1<ExtractProgressEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ExtractProgress(EventHandler`1<ExtractProgressEventArgs> value);
    private void OnExtractEntry(int current, bool before, ZipEntry currentEntry, string path);
    internal bool OnExtractBlock(ZipEntry entry, long bytesWritten, long totalBytesToWrite);
    internal bool OnSingleEntryExtract(ZipEntry entry, string path, bool before);
    internal bool OnExtractExisting(ZipEntry entry, string path);
    private void OnExtractAllCompleted(string path);
    private void OnExtractAllStarted(string path);
    [CompilerGeneratedAttribute]
internal void add_AddProgress(EventHandler`1<AddProgressEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_AddProgress(EventHandler`1<AddProgressEventArgs> value);
    private void OnAddStarted();
    private void OnAddCompleted();
    internal void AfterAddEntry(ZipEntry entry);
    [CompilerGeneratedAttribute]
internal void add_ZipError(EventHandler`1<ZipErrorEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ZipError(EventHandler`1<ZipErrorEventArgs> value);
    internal bool OnZipErrorSaving(ZipEntry entry, Exception exc);
    public void ExtractAll(string path);
    internal void ExtractAll(string path, ExtractExistingFileAction extractExistingFile);
    private void _InternalExtractAll(string path, bool overrideExtractExistingProperty);
    public static ZipFile Read(string fileName);
    internal static ZipFile Read(string fileName, ReadOptions options);
    private static ZipFile Read(string fileName, TextWriter statusMessageWriter, Encoding encoding, EventHandler`1<ReadProgressEventArgs> readProgress);
    public static ZipFile Read(Stream zipStream);
    internal static ZipFile Read(Stream zipStream, ReadOptions options);
    private static ZipFile Read(Stream zipStream, TextWriter statusMessageWriter, Encoding encoding, EventHandler`1<ReadProgressEventArgs> readProgress);
    private static void ReadIntoInstance(ZipFile zf);
    private static void Zip64SeekToCentralDirectory(ZipFile zf);
    private static UInt32 ReadFirstFourBytes(Stream s);
    private static void ReadCentralDirectory(ZipFile zf);
    private static void ReadIntoInstance_Orig(ZipFile zf);
    private static void ReadCentralDirectoryFooter(ZipFile zf);
    private static void ReadZipFileComment(ZipFile zf);
    public static bool IsZipFile(string fileName);
    public static bool IsZipFile(string fileName, bool testExtract);
    public static bool IsZipFile(Stream stream, bool testExtract);
    private void DeleteFileWithRetry(string filename);
    public void Save();
    private static void NotifyEntriesSaveComplete(ICollection`1<ZipEntry> c);
    private void RemoveTempFile();
    private void CleanupAfterSaveOperation();
    public void Save(string fileName);
    public void Save(Stream outputStream);
    public void AddSelectedFiles(string selectionCriteria);
    public void AddSelectedFiles(string selectionCriteria, bool recurseDirectories);
    public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk);
    public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk, bool recurseDirectories);
    public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive);
    public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive, bool recurseDirectories);
    public void UpdateSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive, bool recurseDirectories);
    private string EnsureendInSlash(string s);
    private void _AddOrUpdateSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive, bool recurseDirectories, bool wantUpdate);
    private static string ReplaceLeadingDirectory(string original, string pattern, string replacement);
    public ICollection`1<ZipEntry> SelectEntries(string selectionCriteria);
    public ICollection`1<ZipEntry> SelectEntries(string selectionCriteria, string directoryPathInArchive);
    public int RemoveSelectedEntries(string selectionCriteria);
    public int RemoveSelectedEntries(string selectionCriteria, string directoryPathInArchive);
    public void ExtractSelectedEntries(string selectionCriteria);
    internal void ExtractSelectedEntries(string selectionCriteria, ExtractExistingFileAction extractExistingFile);
    public void ExtractSelectedEntries(string selectionCriteria, string directoryPathInArchive);
    public void ExtractSelectedEntries(string selectionCriteria, string directoryInArchive, string extractDirectory);
    internal void ExtractSelectedEntries(string selectionCriteria, string directoryPathInArchive, string extractDirectory, ExtractExistingFileAction extractExistingFile);
    public sealed virtual IEnumerator`1<ZipEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [DispIdAttribute("-4")]
public IEnumerator GetNewEnum();
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.ZipOption : Enum {
    public int value__;
    public static ZipOption Default;
    public static ZipOption Never;
    public static ZipOption AsNecessary;
    public static ZipOption Always;
}
internal static class OfficeOpenXml.Packaging.Ionic.Zip.ZipOutput : object {
    public static bool WriteCentralDirectoryStructure(Stream s, ICollection`1<ZipEntry> entries, UInt32 numSegments, Zip64Option zip64, string comment, ZipContainer container);
    private static Encoding GetEncoding(ZipContainer container, string t);
    private static Byte[] GenCentralDirectoryFooter(long StartOfCentralDirectory, long EndOfCentralDirectory, Zip64Option zip64, int entryCount, string comment, ZipContainer container);
    private static Byte[] GenZip64EndOfCentralDirectory(long StartOfCentralDirectory, long EndOfCentralDirectory, int entryCount, UInt32 numSegments);
    private static int CountEntries(ICollection`1<ZipEntry> _entries);
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ZipOutputStream : Stream {
    [CompilerGeneratedAttribute]
private int <CodecBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionMethod <CompressionMethod>k__BackingField;
    private EncryptionAlgorithm _encryption;
    private ZipEntryTimestamp _timestamp;
    internal string _password;
    private string _comment;
    private Stream _outputStream;
    private ZipEntry _currentEntry;
    internal Zip64Option _zip64;
    private Dictionary`2<string, ZipEntry> _entriesWritten;
    private int _entryCount;
    private ZipOption _alternateEncodingUsage;
    private Encoding _alternateEncoding;
    private bool _leaveUnderlyingStreamOpen;
    private bool _disposed;
    private bool _exceptionPending;
    private bool _anyEntriesUsedZip64;
    private bool _directoryNeededZip64;
    private CountingStream _outputCounter;
    private Stream _encryptor;
    private Stream _deflater;
    private CrcCalculatorStream _entryOutputStream;
    private bool _needToWriteEntryHeader;
    private string _name;
    private bool _DontIgnoreCase;
    internal ParallelDeflateOutputStream ParallelDeflater;
    private long _ParallelDeflateThreshold;
    private int _maxBufferPairs;
    unknown string Password {public set; }
    public EncryptionAlgorithm Encryption { get; public set; }
    public int CodecBufferSize { get; public set; }
    public CompressionStrategy Strategy { get; public set; }
    public ZipEntryTimestamp Timestamp { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    public CompressionMethod CompressionMethod { get; public set; }
    public string Comment { get; public set; }
    public Zip64Option EnableZip64 { get; public set; }
    public bool OutputUsedZip64 { get; }
    public bool IgnoreCase { get; public set; }
    [ObsoleteAttribute("Beginning with v1.9.1.6 of DotNetZip, this property is obsolete. It will be removed in a future version of the library. Use AlternateEncoding and AlternateEncodingUsage instead.")]
public bool UseUnicodeAsNecessary { get; public set; }
    [ObsoleteAttribute("use AlternateEncoding and AlternateEncodingUsage instead.")]
public Encoding ProvisionalAlternateEncoding { get; public set; }
    public Encoding AlternateEncoding { get; public set; }
    public ZipOption AlternateEncodingUsage { get; public set; }
    public static Encoding DefaultEncoding { get; }
    public long ParallelDeflateThreshold { get; public set; }
    public int ParallelDeflateMaxBufferPairs { get; public set; }
    internal Stream OutputStream { get; }
    internal string Name { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZipOutputStream(Stream stream);
    public ZipOutputStream(string fileName);
    public ZipOutputStream(Stream stream, bool leaveOpen);
    private void _Init(Stream stream, bool leaveOpen, string name);
    public virtual string ToString();
    public void set_Password(string value);
    public EncryptionAlgorithm get_Encryption();
    public void set_Encryption(EncryptionAlgorithm value);
    [CompilerGeneratedAttribute]
public int get_CodecBufferSize();
    [CompilerGeneratedAttribute]
public void set_CodecBufferSize(int value);
    [CompilerGeneratedAttribute]
public CompressionStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(CompressionStrategy value);
    public ZipEntryTimestamp get_Timestamp();
    public void set_Timestamp(ZipEntryTimestamp value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public CompressionMethod get_CompressionMethod();
    [CompilerGeneratedAttribute]
public void set_CompressionMethod(CompressionMethod value);
    public string get_Comment();
    public void set_Comment(string value);
    public Zip64Option get_EnableZip64();
    public void set_EnableZip64(Zip64Option value);
    public bool get_OutputUsedZip64();
    public bool get_IgnoreCase();
    public void set_IgnoreCase(bool value);
    public bool get_UseUnicodeAsNecessary();
    public void set_UseUnicodeAsNecessary(bool value);
    public Encoding get_ProvisionalAlternateEncoding();
    public void set_ProvisionalAlternateEncoding(Encoding value);
    public Encoding get_AlternateEncoding();
    public void set_AlternateEncoding(Encoding value);
    public ZipOption get_AlternateEncodingUsage();
    public void set_AlternateEncodingUsage(ZipOption value);
    public static Encoding get_DefaultEncoding();
    public void set_ParallelDeflateThreshold(long value);
    public long get_ParallelDeflateThreshold();
    public int get_ParallelDeflateMaxBufferPairs();
    public void set_ParallelDeflateMaxBufferPairs(int value);
    private void InsureUniqueEntry(ZipEntry ze1);
    internal Stream get_OutputStream();
    internal string get_Name();
    public bool ContainsEntry(string name);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public ZipEntry PutNextEntry(string entryName);
    private void _InitiateCurrentEntry(bool finishing);
    private void _FinishCurrentEntry();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventArgs : EventArgs {
    private int _entriesTotal;
    private bool _cancel;
    private ZipEntry _latestEntry;
    private ZipProgressEventType _flavor;
    private string _archiveName;
    private long _bytesTransferred;
    private long _totalBytesToTransfer;
    public int EntriesTotal { get; public set; }
    public ZipEntry CurrentEntry { get; public set; }
    public bool Cancel { get; public set; }
    public ZipProgressEventType EventType { get; public set; }
    public string ArchiveName { get; public set; }
    public long BytesTransferred { get; public set; }
    public long TotalBytesToTransfer { get; public set; }
    internal ZipProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    public int get_EntriesTotal();
    public void set_EntriesTotal(int value);
    public ZipEntry get_CurrentEntry();
    public void set_CurrentEntry(ZipEntry value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public ZipProgressEventType get_EventType();
    public void set_EventType(ZipProgressEventType value);
    public string get_ArchiveName();
    public void set_ArchiveName(string value);
    public long get_BytesTransferred();
    public void set_BytesTransferred(long value);
    public long get_TotalBytesToTransfer();
    public void set_TotalBytesToTransfer(long value);
}
internal enum OfficeOpenXml.Packaging.Ionic.Zip.ZipProgressEventType : Enum {
    public int value__;
    public static ZipProgressEventType Adding_Started;
    public static ZipProgressEventType Adding_AfterAddEntry;
    public static ZipProgressEventType Adding_Completed;
    public static ZipProgressEventType Reading_Started;
    public static ZipProgressEventType Reading_BeforeReadEntry;
    public static ZipProgressEventType Reading_AfterReadEntry;
    public static ZipProgressEventType Reading_Completed;
    public static ZipProgressEventType Reading_ArchiveBytesRead;
    public static ZipProgressEventType Saving_Started;
    public static ZipProgressEventType Saving_BeforeWriteEntry;
    public static ZipProgressEventType Saving_AfterWriteEntry;
    public static ZipProgressEventType Saving_Completed;
    public static ZipProgressEventType Saving_AfterSaveTempArchive;
    public static ZipProgressEventType Saving_BeforeRenameTempArchive;
    public static ZipProgressEventType Saving_AfterRenameTempArchive;
    public static ZipProgressEventType Saving_AfterCompileSelfExtractor;
    public static ZipProgressEventType Saving_EntryBytesRead;
    public static ZipProgressEventType Extracting_BeforeExtractEntry;
    public static ZipProgressEventType Extracting_AfterExtractEntry;
    public static ZipProgressEventType Extracting_ExtractEntryWouldOverwrite;
    public static ZipProgressEventType Extracting_EntryBytesWritten;
    public static ZipProgressEventType Extracting_BeforeExtractAll;
    public static ZipProgressEventType Extracting_AfterExtractAll;
    public static ZipProgressEventType Error_Saving;
}
internal class OfficeOpenXml.Packaging.Ionic.Zip.ZipSegmentedStream : Stream {
    private RwMode rwMode;
    private bool _exceptionPending;
    private string _baseName;
    private string _baseDir;
    private string _currentName;
    private string _currentTempName;
    private UInt32 _currentDiskNumber;
    private UInt32 _maxDiskNumber;
    private int _maxSegmentSize;
    private Stream _innerStream;
    [CompilerGeneratedAttribute]
private bool <ContiguousWrite>k__BackingField;
    public bool ContiguousWrite { get; public set; }
    public UInt32 CurrentSegment { get; private set; }
    public string CurrentName { get; }
    public string CurrentTempName { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public static ZipSegmentedStream ForReading(string name, UInt32 initialDiskNumber, UInt32 maxDiskNumber);
    public static ZipSegmentedStream ForWriting(string name, int maxSegmentSize);
    public static Stream ForUpdate(string name, UInt32 diskNumber);
    [CompilerGeneratedAttribute]
public bool get_ContiguousWrite();
    [CompilerGeneratedAttribute]
public void set_ContiguousWrite(bool value);
    public UInt32 get_CurrentSegment();
    private void set_CurrentSegment(UInt32 value);
    public string get_CurrentName();
    public string get_CurrentTempName();
    private string _NameForSegment(UInt32 diskNumber);
    public UInt32 ComputeSegment(int length);
    public virtual string ToString();
    private void _SetReadStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void _SetWriteStream(UInt32 increment);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public long TruncateBackward(UInt32 diskNumber, long offset);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public class OfficeOpenXml.Packaging.Ionic.Zlib.Adler : object {
    private static UInt32 BASE;
    private static int NMAX;
    private static Adler();
    public static UInt32 Adler32(UInt32 adler, Byte[] buf, int index, int len);
}
internal enum OfficeOpenXml.Packaging.Ionic.Zlib.BlockState : Enum {
    public int value__;
    public static BlockState NeedMore;
    public static BlockState BlockDone;
    public static BlockState FinishStarted;
    public static BlockState FinishDone;
}
public enum OfficeOpenXml.Packaging.Ionic.Zlib.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel None;
    public static CompressionLevel Level0;
    public static CompressionLevel BestSpeed;
    public static CompressionLevel Level1;
    public static CompressionLevel Level2;
    public static CompressionLevel Level3;
    public static CompressionLevel Level4;
    public static CompressionLevel Level5;
    public static CompressionLevel Default;
    public static CompressionLevel Level6;
    public static CompressionLevel Level7;
    public static CompressionLevel Level8;
    public static CompressionLevel BestCompression;
    public static CompressionLevel Level9;
}
public enum OfficeOpenXml.Packaging.Ionic.Zlib.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Compress;
    public static CompressionMode Decompress;
}
public enum OfficeOpenXml.Packaging.Ionic.Zlib.CompressionStrategy : Enum {
    public int value__;
    public static CompressionStrategy Default;
    public static CompressionStrategy Filtered;
    public static CompressionStrategy HuffmanOnly;
}
internal enum OfficeOpenXml.Packaging.Ionic.Zlib.DeflateFlavor : Enum {
    public int value__;
    public static DeflateFlavor Store;
    public static DeflateFlavor Fast;
    public static DeflateFlavor Slow;
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.DeflateManager : object {
    private static int MEM_LEVEL_MAX;
    private static int MEM_LEVEL_DEFAULT;
    private CompressFunc DeflateFunction;
    private static String[] _ErrorMessage;
    private static int PRESET_DICT;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    internal ZlibCodec _codec;
    internal int status;
    internal Byte[] pending;
    internal int nextPending;
    internal int pendingCount;
    internal sbyte data_type;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    private Config config;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal CompressionLevel compressionLevel;
    internal CompressionStrategy compressionStrategy;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree treeLiterals;
    internal Tree treeDistances;
    internal Tree treeBitLengths;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal SByte[] depth;
    internal int _lengthOffset;
    internal int lit_bufsize;
    internal int last_lit;
    internal int _distanceOffset;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal short bi_buf;
    internal int bi_valid;
    private bool Rfc1950BytesEmitted;
    private bool _WantRfc1950HeaderBytes;
    internal bool WantRfc1950HeaderBytes { get; internal set; }
    private static DeflateManager();
    private void _InitializeLazyMatch();
    private void _InitializeTreeData();
    internal void _InitializeBlocks();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool _IsSmaller(Int16[] tree, int n, int m, SByte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    private void put_bytes(Byte[] p, int start, int len);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int value, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void send_compressed_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal BlockState DeflateNone(FlushType flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    private void _fillWindow();
    internal BlockState DeflateFast(FlushType flush);
    internal BlockState DeflateSlow(FlushType flush);
    internal int longest_match(int cur_match);
    internal bool get_WantRfc1950HeaderBytes();
    internal void set_WantRfc1950HeaderBytes(bool value);
    internal int Initialize(ZlibCodec codec, CompressionLevel level);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits, CompressionStrategy compressionStrategy);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy);
    internal void Reset();
    internal int End();
    private void SetDeflater();
    internal int SetParams(CompressionLevel level, CompressionStrategy strategy);
    internal int SetDictionary(Byte[] dictionary);
    internal int Deflate(FlushType flush);
}
public class OfficeOpenXml.Packaging.Ionic.Zlib.DeflateStream : Stream {
    internal ZlibBaseStream _baseStream;
    internal Stream _innerStream;
    private bool _disposed;
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public CompressionStrategy Strategy { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DeflateStream(Stream stream, CompressionMode mode);
    public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen);
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public CompressionStrategy get_Strategy();
    public void set_Strategy(CompressionStrategy value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public static Byte[] CompressString(string s);
    public static Byte[] CompressBuffer(Byte[] b);
    public static string UncompressString(Byte[] compressed);
    public static Byte[] UncompressBuffer(Byte[] compressed);
}
public enum OfficeOpenXml.Packaging.Ionic.Zlib.FlushType : Enum {
    public int value__;
    public static FlushType None;
    public static FlushType Partial;
    public static FlushType Sync;
    public static FlushType Full;
    public static FlushType Finish;
}
public class OfficeOpenXml.Packaging.Ionic.Zlib.GZipStream : Stream {
    public Nullable`1<DateTime> LastModified;
    private int _headerByteCount;
    internal ZlibBaseStream _baseStream;
    private bool _disposed;
    private bool _firstReadDone;
    private string _FileName;
    private string _Comment;
    private int _Crc32;
    internal static DateTime _unixEpoch;
    internal static Encoding iso8859dash1;
    public string Comment { get; public set; }
    public string FileName { get; public set; }
    public int Crc32 { get; }
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public GZipStream(Stream stream, CompressionMode mode);
    public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen);
    private static GZipStream();
    public string get_Comment();
    public void set_Comment(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public int get_Crc32();
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private int EmitHeader();
    public static Byte[] CompressString(string s);
    public static Byte[] CompressBuffer(Byte[] b);
    public static string UncompressString(Byte[] compressed);
    public static Byte[] UncompressBuffer(Byte[] compressed);
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.InflateBlocks : object {
    private static int MANY;
    internal static Int32[] border;
    private InflateBlockMode mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InflateCodes codes;
    internal int last;
    internal ZlibCodec _codec;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int readAt;
    internal int writeAt;
    internal object checkfn;
    internal UInt32 check;
    internal InfTree inftree;
    internal InflateBlocks(ZlibCodec codec, object checkfn, int w);
    private static InflateBlocks();
    internal UInt32 Reset();
    internal int Process(int r);
    internal void Free();
    internal void SetDictionary(Byte[] d, int start, int n);
    internal int SyncPoint();
    internal int Flush(int r);
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.InflateCodes : object {
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    internal int mode;
    internal int len;
    internal Int32[] tree;
    internal int tree_index;
    internal int need;
    internal int lit;
    internal int bitsToGet;
    internal int dist;
    internal byte lbits;
    internal byte dbits;
    internal Int32[] ltree;
    internal int ltree_index;
    internal Int32[] dtree;
    internal int dtree_index;
    internal void Init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index);
    internal int Process(InflateBlocks blocks, int r);
    internal int InflateFast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InflateBlocks s, ZlibCodec z);
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.InflateManager : object {
    private static int PRESET_DICT;
    private static int Z_DEFLATED;
    private InflateManagerMode mode;
    internal ZlibCodec _codec;
    internal int method;
    internal UInt32 computedCheck;
    internal UInt32 expectedCheck;
    internal int marker;
    private bool _handleRfc1950HeaderBytes;
    internal int wbits;
    internal InflateBlocks blocks;
    private static Byte[] mark;
    internal bool HandleRfc1950HeaderBytes { get; internal set; }
    public InflateManager(bool expectRfc1950HeaderBytes);
    private static InflateManager();
    internal bool get_HandleRfc1950HeaderBytes();
    internal void set_HandleRfc1950HeaderBytes(bool value);
    internal int Reset();
    internal int End();
    internal int Initialize(ZlibCodec codec, int w);
    internal int Inflate(FlushType flush);
    internal int SetDictionary(Byte[] dictionary);
    internal int Sync();
    internal int SyncPoint(ZlibCodec z);
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    internal static int fixed_bl;
    internal static int fixed_bd;
    internal static Int32[] fixed_tl;
    internal static Int32[] fixed_td;
    internal static Int32[] cplens;
    internal static Int32[] cplext;
    internal static Int32[] cpdist;
    internal static Int32[] cpdext;
    internal static int BMAX;
    internal Int32[] hn;
    internal Int32[] v;
    internal Int32[] c;
    internal Int32[] r;
    internal Int32[] u;
    internal Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZlibCodec z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZlibCodec z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZlibCodec z);
    private void initWorkArea(int vsize);
}
internal static class OfficeOpenXml.Packaging.Ionic.Zlib.InternalConstants : object {
    internal static int MAX_BITS;
    internal static int BL_CODES;
    internal static int D_CODES;
    internal static int LITERALS;
    internal static int LENGTH_CODES;
    internal static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    private static InternalConstants();
}
internal static class OfficeOpenXml.Packaging.Ionic.Zlib.InternalInflateConstants : object {
    internal static Int32[] InflateMask;
    private static InternalInflateConstants();
}
public class OfficeOpenXml.Packaging.Ionic.Zlib.ParallelDeflateOutputStream : Stream {
    private static int IO_BUFFER_SIZE_DEFAULT;
    private static int BufferPairsPerCore;
    private List`1<WorkItem> _pool;
    private bool _leaveOpen;
    private bool emitting;
    private Stream _outStream;
    private int _maxBufferPairs;
    private int _bufferSize;
    private AutoResetEvent _newlyCompressedBlob;
    private object _outputLock;
    private bool _isClosed;
    private bool _firstWriteDone;
    private int _currentlyFilling;
    private int _lastFilled;
    private int _lastWritten;
    private int _latestCompressed;
    private int _Crc32;
    private CRC32 _runningCrc;
    private object _latestLock;
    private Queue`1<int> _toWrite;
    private Queue`1<int> _toFill;
    private long _totalBytesProcessed;
    private CompressionLevel _compressLevel;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _pendingException;
    private bool _handlingException;
    private object _eLock;
    private TraceBits _DesiredTrace;
    [CompilerGeneratedAttribute]
private CompressionStrategy <Strategy>k__BackingField;
    public CompressionStrategy Strategy { get; private set; }
    public int MaxBufferPairs { get; public set; }
    public int BufferSize { get; public set; }
    public int Crc32 { get; }
    public long BytesProcessed { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ParallelDeflateOutputStream(Stream stream);
    public ParallelDeflateOutputStream(Stream stream, CompressionLevel level);
    public ParallelDeflateOutputStream(Stream stream, bool leaveOpen);
    public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, bool leaveOpen);
    public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, CompressionStrategy strategy, bool leaveOpen);
    private static ParallelDeflateOutputStream();
    [CompilerGeneratedAttribute]
public CompressionStrategy get_Strategy();
    [CompilerGeneratedAttribute]
private void set_Strategy(CompressionStrategy value);
    public int get_MaxBufferPairs();
    public void set_MaxBufferPairs(int value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public int get_Crc32();
    public long get_BytesProcessed();
    private void _InitializePoolOfWorkItems();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void _FlushFinish();
    private void _Flush(bool lastInput);
    public virtual void Flush();
    public virtual void Close();
    public void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset(Stream stream);
    private void EmitPendingBuffers(bool doAll, bool mustWait);
    private void _DeflateOne(object wi);
    private bool DeflateOneSegment(WorkItem workitem);
    [ConditionalAttribute("Trace")]
private void TraceOutput(TraceBits bits, string format, Object[] varParams);
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.SharedUtils : object {
    public static int URShift(int number, int bits);
    public static int ReadInput(TextReader sourceTextReader, Byte[] target, int start, int count);
    internal static Byte[] ToByteArray(string sourceString);
    internal static Char[] ToCharArray(Byte[] byteArray);
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.StaticTree : object {
    internal static Int16[] lengthAndLiteralsTreeCodes;
    internal static Int16[] distTreeCodes;
    internal static StaticTree Literals;
    internal static StaticTree Distances;
    internal static StaticTree BitLengths;
    internal Int16[] treeCodes;
    internal Int32[] extraBits;
    internal int extraBase;
    internal int elems;
    internal int maxLength;
    private StaticTree(Int16[] treeCodes, Int32[] extraBits, int extraBase, int elems, int maxLength);
    private static StaticTree();
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.Tree : object {
    private static int HEAP_SIZE;
    internal static Int32[] ExtraLengthBits;
    internal static Int32[] ExtraDistanceBits;
    internal static Int32[] extra_blbits;
    internal static SByte[] bl_order;
    internal static int Buf_size;
    private static SByte[] _dist_code;
    internal static SByte[] LengthCode;
    internal static Int32[] LengthBase;
    internal static Int32[] DistanceBase;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree staticTree;
    private static Tree();
    internal static int DistanceCode(int dist);
    internal void gen_bitlen(DeflateManager s);
    internal void build_tree(DeflateManager s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.WorkItem : object {
    public Byte[] buffer;
    public Byte[] compressed;
    public int crc;
    public int index;
    public int ordinal;
    public int inputBytesAvailable;
    public int compressedBytesAvailable;
    public ZlibCodec compressor;
    public WorkItem(int size, CompressionLevel compressLevel, CompressionStrategy strategy, int ix);
}
internal class OfficeOpenXml.Packaging.Ionic.Zlib.ZlibBaseStream : Stream {
    protected internal ZlibCodec _z;
    protected internal StreamMode _streamMode;
    protected internal FlushType _flushMode;
    protected internal ZlibStreamFlavor _flavor;
    protected internal CompressionMode _compressionMode;
    protected internal CompressionLevel _level;
    protected internal bool _leaveOpen;
    protected internal Byte[] _workingBuffer;
    protected internal int _bufferSize;
    protected internal Byte[] _buf1;
    protected internal Stream _stream;
    protected internal CompressionStrategy Strategy;
    private CRC32 crc;
    protected internal string _GzipFileName;
    protected internal string _GzipComment;
    protected internal DateTime _GzipMtime;
    protected internal int _gzipHeaderByteCount;
    private bool nomoreinput;
    internal int Crc32 { get; }
    protected internal bool _wantCompress { get; }
    private ZlibCodec z { get; }
    private Byte[] workingBuffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZlibBaseStream(Stream stream, CompressionMode compressionMode, CompressionLevel level, ZlibStreamFlavor flavor, bool leaveOpen);
    internal int get_Crc32();
    protected internal bool get__wantCompress();
    private ZlibCodec get_z();
    private Byte[] get_workingBuffer();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void finish();
    private void end();
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private string ReadZeroTerminatedString();
    private int _ReadAndValidateGzipHeader();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static void CompressString(string s, Stream compressor);
    public static void CompressBuffer(Byte[] b, Stream compressor);
    public static string UncompressString(Byte[] compressed, Stream decompressor);
    public static Byte[] UncompressBuffer(Byte[] compressed, Stream decompressor);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000D")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
public class OfficeOpenXml.Packaging.Ionic.Zlib.ZlibCodec : object {
    public Byte[] InputBuffer;
    public int NextIn;
    public int AvailableBytesIn;
    public long TotalBytesIn;
    public Byte[] OutputBuffer;
    public int NextOut;
    public int AvailableBytesOut;
    public long TotalBytesOut;
    public string Message;
    internal DeflateManager dstate;
    internal InflateManager istate;
    internal UInt32 _Adler32;
    public CompressionLevel CompressLevel;
    public int WindowBits;
    public CompressionStrategy Strategy;
    public int Adler32 { get; }
    public ZlibCodec(CompressionMode mode);
    public int get_Adler32();
    public int InitializeInflate();
    public int InitializeInflate(bool expectRfc1950Header);
    public int InitializeInflate(int windowBits);
    public int InitializeInflate(int windowBits, bool expectRfc1950Header);
    public int Inflate(FlushType flush);
    public int EndInflate();
    public int SyncInflate();
    public int InitializeDeflate();
    public int InitializeDeflate(CompressionLevel level);
    public int InitializeDeflate(CompressionLevel level, bool wantRfc1950Header);
    public int InitializeDeflate(CompressionLevel level, int bits);
    public int InitializeDeflate(CompressionLevel level, int bits, bool wantRfc1950Header);
    private int _InternalInitializeDeflate(bool wantRfc1950Header);
    public int Deflate(FlushType flush);
    public int EndDeflate();
    public void ResetDeflate();
    public int SetDeflateParams(CompressionLevel level, CompressionStrategy strategy);
    public int SetDictionary(Byte[] dictionary);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
}
public static class OfficeOpenXml.Packaging.Ionic.Zlib.ZlibConstants : object {
    public static int WindowBitsMax;
    public static int WindowBitsDefault;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_BUF_ERROR;
    public static int WorkingBufferSizeDefault;
    public static int WorkingBufferSizeMin;
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000E")]
public class OfficeOpenXml.Packaging.Ionic.Zlib.ZlibException : Exception {
    public ZlibException(string s);
}
public class OfficeOpenXml.Packaging.Ionic.Zlib.ZlibStream : Stream {
    internal ZlibBaseStream _baseStream;
    private bool _disposed;
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZlibStream(Stream stream, CompressionMode mode);
    public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public ZlibStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen);
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public static Byte[] CompressString(string s);
    public static Byte[] CompressBuffer(Byte[] b);
    public static string UncompressString(Byte[] compressed);
    public static Byte[] UncompressBuffer(Byte[] compressed);
}
internal enum OfficeOpenXml.Packaging.Ionic.Zlib.ZlibStreamFlavor : Enum {
    public int value__;
    public static ZlibStreamFlavor ZLIB;
    public static ZlibStreamFlavor DEFLATE;
    public static ZlibStreamFlavor GZIP;
}
public enum OfficeOpenXml.Packaging.TargetMode : Enum {
    public int value__;
    public static TargetMode Internal;
    public static TargetMode External;
}
public class OfficeOpenXml.Packaging.ZipPackage : ZipPackageRelationshipBase {
    private Dictionary`2<string, ZipPackagePart> Parts;
    internal Dictionary`2<string, ContentType> _contentTypes;
    private CompressionLevel _compression;
    public CompressionLevel Compression { get; public set; }
    internal ZipPackage(Stream stream);
    private void AddNew();
    private void AddContentTypes(string xml);
    internal ZipPackagePart CreatePart(Uri partUri, string contentType);
    internal ZipPackagePart CreatePart(Uri partUri, string contentType, CompressionLevel compressionLevel);
    internal ZipPackagePart GetPart(Uri partUri);
    internal string GetUriKey(string uri);
    internal bool PartExists(Uri partUri);
    internal void DeletePart(Uri Uri);
    internal void Save(Stream stream);
    private string GetContentTypeXml();
    internal void Flush();
    internal void Close();
    public CompressionLevel get_Compression();
    public void set_Compression(CompressionLevel value);
}
internal class OfficeOpenXml.Packaging.ZipPackagePart : ZipPackageRelationshipBase {
    [CompilerGeneratedAttribute]
private ZipPackage <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipEntry <Entry>k__BackingField;
    internal CompressionLevel CompressionLevel;
    private MemoryStream _stream;
    private string _contentType;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private SaveHandlerDelegate <SaveHandler>k__BackingField;
    internal ZipPackage Package { get; internal set; }
    internal ZipEntry Entry { get; internal set; }
    internal MemoryStream Stream { get; internal set; }
    public string ContentType { get; internal set; }
    public Uri Uri { get; private set; }
    internal SaveHandlerDelegate SaveHandler { get; internal set; }
    internal ZipPackagePart(ZipPackage package, ZipEntry entry);
    internal ZipPackagePart(ZipPackage package, Uri partUri, string contentType, CompressionLevel compressionLevel);
    [CompilerGeneratedAttribute]
internal ZipPackage get_Package();
    [CompilerGeneratedAttribute]
internal void set_Package(ZipPackage value);
    [CompilerGeneratedAttribute]
internal ZipEntry get_Entry();
    [CompilerGeneratedAttribute]
internal void set_Entry(ZipEntry value);
    internal MemoryStream get_Stream();
    internal void set_Stream(MemoryStream value);
    internal virtual ZipPackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
    internal MemoryStream GetStream();
    internal MemoryStream GetStream(FileMode fileMode);
    internal MemoryStream GetStream(FileMode fileMode, FileAccess fileAccess);
    public string get_ContentType();
    internal void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
    public Stream GetZipStream();
    [CompilerGeneratedAttribute]
internal SaveHandlerDelegate get_SaveHandler();
    [CompilerGeneratedAttribute]
internal void set_SaveHandler(SaveHandlerDelegate value);
    internal void WriteZip(ZipOutputStream os);
    public sealed virtual void Dispose();
}
public class OfficeOpenXml.Packaging.ZipPackageRelationship : object {
    [CompilerGeneratedAttribute]
private Uri <TargetUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelationshipType>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetMode <TargetMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public Uri TargetUri { get; internal set; }
    public Uri SourceUri { get; internal set; }
    public string RelationshipType { get; internal set; }
    public TargetMode TargetMode { get; internal set; }
    public string Id { get; internal set; }
    [CompilerGeneratedAttribute]
public Uri get_TargetUri();
    [CompilerGeneratedAttribute]
internal void set_TargetUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
internal void set_SourceUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_RelationshipType();
    [CompilerGeneratedAttribute]
internal void set_RelationshipType(string value);
    [CompilerGeneratedAttribute]
public TargetMode get_TargetMode();
    [CompilerGeneratedAttribute]
internal void set_TargetMode(TargetMode value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(string value);
}
public abstract class OfficeOpenXml.Packaging.ZipPackageRelationshipBase : object {
    protected ZipPackageRelationshipCollection _rels;
    protected internal int maxRId;
    internal void DeleteRelationship(string id);
    protected void UpdateMaxRId(string id, Int32& maxRId);
    internal virtual ZipPackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
    internal bool RelationshipExists(string id);
    internal ZipPackageRelationshipCollection GetRelationshipsByType(string schema);
    internal ZipPackageRelationshipCollection GetRelationships();
    internal ZipPackageRelationship GetRelationship(string id);
    internal void ReadRelation(string xml, string source);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Packaging.ZipPackageRelationshipCollection : object {
    protected internal Dictionary`2<string, ZipPackageRelationship> _rels;
    internal ZipPackageRelationship Item { get; }
    public int Count { get; }
    internal void Add(ZipPackageRelationship item);
    public sealed virtual IEnumerator`1<ZipPackageRelationship> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Remove(string id);
    internal bool ContainsKey(string id);
    internal ZipPackageRelationship get_Item(string id);
    internal ZipPackageRelationshipCollection GetRelationshipsByType(string relationshipType);
    internal void WriteZip(ZipOutputStream os, string fileName);
    public int get_Count();
}
public enum OfficeOpenXml.PictureAlignment : Enum {
    public int value__;
    public static PictureAlignment Left;
    public static PictureAlignment Centered;
    public static PictureAlignment Right;
}
[DefaultMemberAttribute("Item")]
internal class OfficeOpenXml.RangeCollection : object {
    private IndexItem[] _cellIndex;
    private List`1<IRangeID> _cells;
    private static Compare _comparer;
    [CompilerGeneratedAttribute]
private int <_size>k__BackingField;
    private int _ix;
    internal IRangeID Item { get; }
    internal IRangeID Item { get; }
    internal int Count { get; }
    private int _size { get; private set; }
    private IRangeID System.Collections.Generic.IEnumerator<OfficeOpenXml.IRangeID>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal RangeCollection(List`1<IRangeID> cells);
    private static RangeCollection();
    protected virtual override void Finalize();
    internal IRangeID get_Item(ulong RangeID);
    internal IRangeID get_Item(int Index);
    internal int get_Count();
    internal void Add(IRangeID cell);
    internal void Delete(ulong key);
    internal int IndexOf(ulong key);
    internal bool ContainsKey(ulong key);
    [CompilerGeneratedAttribute]
private int get__size();
    [CompilerGeneratedAttribute]
private void set__size(int value);
    internal int InsertRowsUpdateIndex(ulong rowID, int rows);
    internal int InsertRows(ulong rowID, int rows);
    internal int DeleteRows(ulong rowID, int rows, bool updateCells);
    internal void InsertColumn(ulong ColumnID, int columns);
    internal void DeleteColumn(ulong ColumnID, int columns);
    private void InitSize(List`1<IRangeID> _cells);
    private void CheckSize();
    private void Insert(int ix, IRangeID cell);
    private sealed virtual override IRangeID System.Collections.Generic.IEnumerator<OfficeOpenXml.IRangeID>.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class OfficeOpenXml.RowInternal : object {
    internal double Height;
    internal bool Hidden;
    internal bool Collapsed;
    internal short OutlineLevel;
    internal bool PageBreak;
    internal bool Phonetic;
    internal bool CustomHeight;
    internal int MergeID;
    internal RowInternal Clone();
}
public class OfficeOpenXml.Style.Border : StyleBase {
    public ExcelBorderItem Left { get; }
    public ExcelBorderItem Right { get; }
    public ExcelBorderItem Top { get; }
    public ExcelBorderItem Bottom { get; }
    public ExcelBorderItem Diagonal { get; }
    public bool DiagonalUp { get; public set; }
    public bool DiagonalDown { get; public set; }
    internal string Id { get; }
    internal Border(ExcelStyles styles, ChangedEventHandler ChangedEvent, int PositionID, string address, int index);
    public ExcelBorderItem get_Left();
    public ExcelBorderItem get_Right();
    public ExcelBorderItem get_Top();
    public ExcelBorderItem get_Bottom();
    public ExcelBorderItem get_Diagonal();
    public bool get_DiagonalUp();
    public void set_DiagonalUp(bool value);
    public bool get_DiagonalDown();
    public void set_DiagonalDown(bool value);
    internal virtual string get_Id();
    public void BorderAround(ExcelBorderStyle Style);
    public void BorderAround(ExcelBorderStyle Style, Color Color);
    private void SetBorderAroundStyle(ExcelBorderStyle Style, ExcelAddress addr);
}
public abstract class OfficeOpenXml.Style.Dxf.DxfStyleBase`1 : object {
    protected ExcelStyles _styles;
    [CompilerGeneratedAttribute]
private bool <AllowChange>k__BackingField;
    protected internal string Id { get; }
    protected internal bool HasValue { get; }
    protected internal bool AllowChange { get; protected internal set; }
    internal DxfStyleBase`1(ExcelStyles styles);
    protected internal abstract virtual string get_Id();
    protected internal abstract virtual bool get_HasValue();
    protected internal abstract virtual void CreateNodes(XmlHelper helper, string path);
    protected internal abstract virtual T Clone();
    protected void SetValueColor(XmlHelper helper, string path, ExcelDxfColor color);
    protected void SetValueEnum(XmlHelper helper, string path, Enum v);
    protected void SetValue(XmlHelper helper, string path, object v);
    protected void SetValueBool(XmlHelper helper, string path, Nullable`1<bool> v);
    protected internal string GetAsString(object v);
    [CompilerGeneratedAttribute]
protected internal bool get_AllowChange();
    [CompilerGeneratedAttribute]
protected internal void set_AllowChange(bool value);
}
public class OfficeOpenXml.Style.Dxf.ExcelDxfBorderBase : DxfStyleBase`1<ExcelDxfBorderBase> {
    [CompilerGeneratedAttribute]
private ExcelDxfBorderItem <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfBorderItem <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfBorderItem <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfBorderItem <Bottom>k__BackingField;
    public ExcelDxfBorderItem Left { get; internal set; }
    public ExcelDxfBorderItem Right { get; internal set; }
    public ExcelDxfBorderItem Top { get; internal set; }
    public ExcelDxfBorderItem Bottom { get; internal set; }
    protected internal string Id { get; }
    protected internal bool HasValue { get; }
    internal ExcelDxfBorderBase(ExcelStyles styles);
    [CompilerGeneratedAttribute]
public ExcelDxfBorderItem get_Left();
    [CompilerGeneratedAttribute]
internal void set_Left(ExcelDxfBorderItem value);
    [CompilerGeneratedAttribute]
public ExcelDxfBorderItem get_Right();
    [CompilerGeneratedAttribute]
internal void set_Right(ExcelDxfBorderItem value);
    [CompilerGeneratedAttribute]
public ExcelDxfBorderItem get_Top();
    [CompilerGeneratedAttribute]
internal void set_Top(ExcelDxfBorderItem value);
    [CompilerGeneratedAttribute]
public ExcelDxfBorderItem get_Bottom();
    [CompilerGeneratedAttribute]
internal void set_Bottom(ExcelDxfBorderItem value);
    protected internal virtual string get_Id();
    protected internal virtual void CreateNodes(XmlHelper helper, string path);
    protected internal virtual bool get_HasValue();
    protected internal virtual ExcelDxfBorderBase Clone();
}
public class OfficeOpenXml.Style.Dxf.ExcelDxfBorderItem : DxfStyleBase`1<ExcelDxfBorderItem> {
    [CompilerGeneratedAttribute]
private Nullable`1<ExcelBorderStyle> <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfColor <Color>k__BackingField;
    public Nullable`1<ExcelBorderStyle> Style { get; public set; }
    public ExcelDxfColor Color { get; internal set; }
    protected internal string Id { get; }
    protected internal bool HasValue { get; }
    internal ExcelDxfBorderItem(ExcelStyles styles);
    [CompilerGeneratedAttribute]
public Nullable`1<ExcelBorderStyle> get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(Nullable`1<ExcelBorderStyle> value);
    [CompilerGeneratedAttribute]
public ExcelDxfColor get_Color();
    [CompilerGeneratedAttribute]
internal void set_Color(ExcelDxfColor value);
    protected internal virtual string get_Id();
    protected internal virtual void CreateNodes(XmlHelper helper, string path);
    protected internal virtual bool get_HasValue();
    protected internal virtual ExcelDxfBorderItem Clone();
}
public class OfficeOpenXml.Style.Dxf.ExcelDxfColor : DxfStyleBase`1<ExcelDxfColor> {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Theme>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Auto>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Tint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Color> <Color>k__BackingField;
    public Nullable`1<int> Theme { get; public set; }
    public Nullable`1<int> Index { get; public set; }
    public Nullable`1<bool> Auto { get; public set; }
    public Nullable`1<double> Tint { get; public set; }
    public Nullable`1<Color> Color { get; public set; }
    protected internal string Id { get; }
    protected internal bool HasValue { get; }
    public ExcelDxfColor(ExcelStyles styles);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Theme();
    [CompilerGeneratedAttribute]
public void set_Theme(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Auto();
    [CompilerGeneratedAttribute]
public void set_Auto(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Tint();
    [CompilerGeneratedAttribute]
public void set_Tint(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Color> get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Nullable`1<Color> value);
    protected internal virtual string get_Id();
    protected internal virtual ExcelDxfColor Clone();
    protected internal virtual bool get_HasValue();
    protected internal virtual void CreateNodes(XmlHelper helper, string path);
}
public class OfficeOpenXml.Style.Dxf.ExcelDxfFill : DxfStyleBase`1<ExcelDxfFill> {
    [CompilerGeneratedAttribute]
private Nullable`1<ExcelFillStyle> <PatternType>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfColor <PatternColor>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfColor <BackgroundColor>k__BackingField;
    public Nullable`1<ExcelFillStyle> PatternType { get; public set; }
    public ExcelDxfColor PatternColor { get; internal set; }
    public ExcelDxfColor BackgroundColor { get; internal set; }
    protected internal string Id { get; }
    protected internal bool HasValue { get; }
    public ExcelDxfFill(ExcelStyles styles);
    [CompilerGeneratedAttribute]
public Nullable`1<ExcelFillStyle> get_PatternType();
    [CompilerGeneratedAttribute]
public void set_PatternType(Nullable`1<ExcelFillStyle> value);
    [CompilerGeneratedAttribute]
public ExcelDxfColor get_PatternColor();
    [CompilerGeneratedAttribute]
internal void set_PatternColor(ExcelDxfColor value);
    [CompilerGeneratedAttribute]
public ExcelDxfColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
internal void set_BackgroundColor(ExcelDxfColor value);
    protected internal virtual string get_Id();
    protected internal virtual void CreateNodes(XmlHelper helper, string path);
    protected internal virtual bool get_HasValue();
    protected internal virtual ExcelDxfFill Clone();
}
public class OfficeOpenXml.Style.Dxf.ExcelDxfFontBase : DxfStyleBase`1<ExcelDxfFontBase> {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Bold>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Italic>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Strike>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfColor <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ExcelUnderLineType> <Underline>k__BackingField;
    public Nullable`1<bool> Bold { get; public set; }
    public Nullable`1<bool> Italic { get; public set; }
    public Nullable`1<bool> Strike { get; public set; }
    public ExcelDxfColor Color { get; public set; }
    public Nullable`1<ExcelUnderLineType> Underline { get; public set; }
    protected internal string Id { get; }
    protected internal bool HasValue { get; }
    public ExcelDxfFontBase(ExcelStyles styles);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Bold();
    [CompilerGeneratedAttribute]
public void set_Bold(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Italic();
    [CompilerGeneratedAttribute]
public void set_Italic(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Strike();
    [CompilerGeneratedAttribute]
public void set_Strike(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public ExcelDxfColor get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(ExcelDxfColor value);
    [CompilerGeneratedAttribute]
public Nullable`1<ExcelUnderLineType> get_Underline();
    [CompilerGeneratedAttribute]
public void set_Underline(Nullable`1<ExcelUnderLineType> value);
    protected internal virtual string get_Id();
    protected internal virtual void CreateNodes(XmlHelper helper, string path);
    protected internal virtual bool get_HasValue();
    protected internal virtual ExcelDxfFontBase Clone();
}
public class OfficeOpenXml.Style.Dxf.ExcelDxfNumberFormat : DxfStyleBase`1<ExcelDxfNumberFormat> {
    private int _numFmtID;
    private string _format;
    public int NumFmtID { get; internal set; }
    public string Format { get; public set; }
    protected internal string Id { get; }
    protected internal bool HasValue { get; }
    public ExcelDxfNumberFormat(ExcelStyles styles);
    public int get_NumFmtID();
    internal void set_NumFmtID(int value);
    public string get_Format();
    public void set_Format(string value);
    protected internal virtual string get_Id();
    protected internal virtual void CreateNodes(XmlHelper helper, string path);
    protected internal virtual bool get_HasValue();
    protected internal virtual ExcelDxfNumberFormat Clone();
}
public class OfficeOpenXml.Style.Dxf.ExcelDxfStyleConditionalFormatting : DxfStyleBase`1<ExcelDxfStyleConditionalFormatting> {
    private XmlHelperInstance _helper;
    [CompilerGeneratedAttribute]
private int <DxfId>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfFontBase <Font>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfNumberFormat <NumberFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfFill <Fill>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelDxfBorderBase <Border>k__BackingField;
    internal int DxfId { get; internal set; }
    public ExcelDxfFontBase Font { get; public set; }
    public ExcelDxfNumberFormat NumberFormat { get; public set; }
    public ExcelDxfFill Fill { get; public set; }
    public ExcelDxfBorderBase Border { get; public set; }
    protected internal string Id { get; }
    protected internal bool HasValue { get; }
    internal ExcelDxfStyleConditionalFormatting(XmlNamespaceManager nameSpaceManager, XmlNode topNode, ExcelStyles styles);
    private ExcelDxfBorderItem GetBorderItem(XmlHelperInstance helper, string path);
    private ExcelBorderStyle GetBorderStyleEnum(string style);
    private ExcelFillStyle GetPatternTypeEnum(string patternType);
    private ExcelDxfColor GetColor(XmlHelperInstance helper, string path);
    private Nullable`1<ExcelUnderLineType> GetUnderLineEnum(string value);
    [CompilerGeneratedAttribute]
internal int get_DxfId();
    [CompilerGeneratedAttribute]
internal void set_DxfId(int value);
    [CompilerGeneratedAttribute]
public ExcelDxfFontBase get_Font();
    [CompilerGeneratedAttribute]
public void set_Font(ExcelDxfFontBase value);
    [CompilerGeneratedAttribute]
public ExcelDxfNumberFormat get_NumberFormat();
    [CompilerGeneratedAttribute]
public void set_NumberFormat(ExcelDxfNumberFormat value);
    [CompilerGeneratedAttribute]
public ExcelDxfFill get_Fill();
    [CompilerGeneratedAttribute]
public void set_Fill(ExcelDxfFill value);
    [CompilerGeneratedAttribute]
public ExcelDxfBorderBase get_Border();
    [CompilerGeneratedAttribute]
public void set_Border(ExcelDxfBorderBase value);
    protected internal virtual string get_Id();
    protected internal virtual ExcelDxfStyleConditionalFormatting Clone();
    protected internal virtual void CreateNodes(XmlHelper helper, string path);
    protected internal virtual bool get_HasValue();
}
public enum OfficeOpenXml.Style.eStrikeType : Enum {
    public int value__;
    public static eStrikeType Double;
    public static eStrikeType No;
    public static eStrikeType Single;
}
internal enum OfficeOpenXml.Style.eStyleClass : Enum {
    public int value__;
    public static eStyleClass Numberformat;
    public static eStyleClass Font;
    public static eStyleClass Border;
    public static eStyleClass BorderTop;
    public static eStyleClass BorderLeft;
    public static eStyleClass BorderBottom;
    public static eStyleClass BorderRight;
    public static eStyleClass BorderDiagonal;
    public static eStyleClass Fill;
    public static eStyleClass GradientFill;
    public static eStyleClass FillBackgroundColor;
    public static eStyleClass FillPatternColor;
    public static eStyleClass FillGradientColor1;
    public static eStyleClass FillGradientColor2;
    public static eStyleClass NamedStyle;
    public static eStyleClass Style;
}
internal enum OfficeOpenXml.Style.eStyleProperty : Enum {
    public int value__;
    public static eStyleProperty Format;
    public static eStyleProperty Name;
    public static eStyleProperty Size;
    public static eStyleProperty Bold;
    public static eStyleProperty Italic;
    public static eStyleProperty Strike;
    public static eStyleProperty Color;
    public static eStyleProperty Tint;
    public static eStyleProperty IndexedColor;
    public static eStyleProperty AutoColor;
    public static eStyleProperty GradientColor;
    public static eStyleProperty Family;
    public static eStyleProperty Scheme;
    public static eStyleProperty UnderlineType;
    public static eStyleProperty HorizontalAlign;
    public static eStyleProperty VerticalAlign;
    public static eStyleProperty Border;
    public static eStyleProperty NamedStyle;
    public static eStyleProperty Style;
    public static eStyleProperty PatternType;
    public static eStyleProperty ReadingOrder;
    public static eStyleProperty WrapText;
    public static eStyleProperty TextRotation;
    public static eStyleProperty Locked;
    public static eStyleProperty Hidden;
    public static eStyleProperty ShrinkToFit;
    public static eStyleProperty BorderDiagonalUp;
    public static eStyleProperty BorderDiagonalDown;
    public static eStyleProperty GradientDegree;
    public static eStyleProperty GradientType;
    public static eStyleProperty GradientTop;
    public static eStyleProperty GradientBottom;
    public static eStyleProperty GradientLeft;
    public static eStyleProperty GradientRight;
    public static eStyleProperty XfId;
    public static eStyleProperty Indent;
    public static eStyleProperty QuotePrefix;
}
public enum OfficeOpenXml.Style.eUnderLineType : Enum {
    public int value__;
    public static eUnderLineType Dash;
    public static eUnderLineType DashHeavy;
    public static eUnderLineType DashLong;
    public static eUnderLineType DashLongHeavy;
    public static eUnderLineType Double;
    public static eUnderLineType DotDash;
    public static eUnderLineType DotDashHeavy;
    public static eUnderLineType DotDotDash;
    public static eUnderLineType DotDotDashHeavy;
    public static eUnderLineType Dotted;
    public static eUnderLineType DottedHeavy;
    public static eUnderLineType Heavy;
    public static eUnderLineType None;
    public static eUnderLineType Single;
    public static eUnderLineType Wavy;
    public static eUnderLineType WavyDbl;
    public static eUnderLineType WavyHeavy;
    public static eUnderLineType Words;
}
public class OfficeOpenXml.Style.ExcelBorderItem : StyleBase {
    private eStyleClass _cls;
    private StyleBase _parent;
    private ExcelColor _color;
    public ExcelBorderStyle Style { get; public set; }
    public ExcelColor Color { get; }
    internal string Id { get; }
    internal ExcelBorderItem(ExcelStyles styles, ChangedEventHandler ChangedEvent, int worksheetID, string address, eStyleClass cls, StyleBase parent);
    public ExcelBorderStyle get_Style();
    public void set_Style(ExcelBorderStyle value);
    public ExcelColor get_Color();
    internal virtual string get_Id();
    internal virtual void SetIndex(int index);
    private ExcelBorderItemXml GetSource();
}
public enum OfficeOpenXml.Style.ExcelBorderStyle : Enum {
    public int value__;
    public static ExcelBorderStyle None;
    public static ExcelBorderStyle Hair;
    public static ExcelBorderStyle Dotted;
    public static ExcelBorderStyle DashDot;
    public static ExcelBorderStyle Thin;
    public static ExcelBorderStyle DashDotDot;
    public static ExcelBorderStyle Dashed;
    public static ExcelBorderStyle MediumDashDotDot;
    public static ExcelBorderStyle MediumDashed;
    public static ExcelBorderStyle MediumDashDot;
    public static ExcelBorderStyle Thick;
    public static ExcelBorderStyle Medium;
    public static ExcelBorderStyle Double;
}
public class OfficeOpenXml.Style.ExcelColor : StyleBase {
    private eStyleClass _cls;
    private StyleBase _parent;
    public string Theme { get; }
    public decimal Tint { get; public set; }
    public string Rgb { get; internal set; }
    public int Indexed { get; public set; }
    internal string Id { get; }
    internal ExcelColor(ExcelStyles styles, ChangedEventHandler ChangedEvent, int worksheetID, string address, eStyleClass cls, StyleBase parent);
    public string get_Theme();
    public decimal get_Tint();
    public void set_Tint(decimal value);
    public string get_Rgb();
    internal void set_Rgb(string value);
    public int get_Indexed();
    public void set_Indexed(int value);
    public void SetColor(Color color);
    internal virtual string get_Id();
    private ExcelColorXml GetSource();
    internal virtual void SetIndex(int index);
    public string LookupColor();
    public string LookupColor(ExcelColor theColor);
}
public class OfficeOpenXml.Style.ExcelFill : StyleBase {
    private ExcelColor _patternColor;
    private ExcelColor _backgroundColor;
    private ExcelGradientFill _gradient;
    public ExcelFillStyle PatternType { get; public set; }
    public ExcelColor PatternColor { get; }
    public ExcelColor BackgroundColor { get; }
    public ExcelGradientFill Gradient { get; }
    internal string Id { get; }
    internal ExcelFill(ExcelStyles styles, ChangedEventHandler ChangedEvent, int PositionID, string address, int index);
    public ExcelFillStyle get_PatternType();
    public void set_PatternType(ExcelFillStyle value);
    public ExcelColor get_PatternColor();
    public ExcelColor get_BackgroundColor();
    public ExcelGradientFill get_Gradient();
    internal virtual string get_Id();
}
public enum OfficeOpenXml.Style.ExcelFillGradientType : Enum {
    public int value__;
    public static ExcelFillGradientType None;
    public static ExcelFillGradientType Linear;
    public static ExcelFillGradientType Path;
}
public enum OfficeOpenXml.Style.ExcelFillStyle : Enum {
    public int value__;
    public static ExcelFillStyle None;
    public static ExcelFillStyle Solid;
    public static ExcelFillStyle DarkGray;
    public static ExcelFillStyle MediumGray;
    public static ExcelFillStyle LightGray;
    public static ExcelFillStyle Gray125;
    public static ExcelFillStyle Gray0625;
    public static ExcelFillStyle DarkVertical;
    public static ExcelFillStyle DarkHorizontal;
    public static ExcelFillStyle DarkDown;
    public static ExcelFillStyle DarkUp;
    public static ExcelFillStyle DarkGrid;
    public static ExcelFillStyle DarkTrellis;
    public static ExcelFillStyle LightVertical;
    public static ExcelFillStyle LightHorizontal;
    public static ExcelFillStyle LightDown;
    public static ExcelFillStyle LightUp;
    public static ExcelFillStyle LightGrid;
    public static ExcelFillStyle LightTrellis;
}
public class OfficeOpenXml.Style.ExcelFont : StyleBase {
    public string Name { get; public set; }
    public float Size { get; public set; }
    public int Family { get; public set; }
    public ExcelColor Color { get; }
    public string Scheme { get; public set; }
    public bool Bold { get; public set; }
    public bool Italic { get; public set; }
    public bool Strike { get; public set; }
    public bool UnderLine { get; public set; }
    public ExcelUnderLineType UnderLineType { get; public set; }
    public ExcelVerticalAlignmentFont VerticalAlign { get; public set; }
    internal string Id { get; }
    internal ExcelFont(ExcelStyles styles, ChangedEventHandler ChangedEvent, int PositionID, string address, int index);
    public string get_Name();
    public void set_Name(string value);
    public float get_Size();
    public void set_Size(float value);
    public int get_Family();
    public void set_Family(int value);
    public ExcelColor get_Color();
    public string get_Scheme();
    public void set_Scheme(string value);
    public bool get_Bold();
    public void set_Bold(bool value);
    public bool get_Italic();
    public void set_Italic(bool value);
    public bool get_Strike();
    public void set_Strike(bool value);
    public bool get_UnderLine();
    public void set_UnderLine(bool value);
    public ExcelUnderLineType get_UnderLineType();
    public void set_UnderLineType(ExcelUnderLineType value);
    public ExcelVerticalAlignmentFont get_VerticalAlign();
    public void set_VerticalAlign(ExcelVerticalAlignmentFont value);
    public void SetFromFont(Font Font);
    internal virtual string get_Id();
}
public class OfficeOpenXml.Style.ExcelGradientFill : StyleBase {
    private ExcelColor _gradientColor1;
    private ExcelColor _gradientColor2;
    public double Degree { get; public set; }
    public ExcelFillGradientType Type { get; public set; }
    public double Top { get; public set; }
    public double Bottom { get; public set; }
    public double Left { get; public set; }
    public double Right { get; public set; }
    public ExcelColor Color1 { get; }
    public ExcelColor Color2 { get; }
    internal string Id { get; }
    internal ExcelGradientFill(ExcelStyles styles, ChangedEventHandler ChangedEvent, int PositionID, string address, int index);
    public double get_Degree();
    public void set_Degree(double value);
    public ExcelFillGradientType get_Type();
    public void set_Type(ExcelFillGradientType value);
    public double get_Top();
    public void set_Top(double value);
    public double get_Bottom();
    public void set_Bottom(double value);
    public double get_Left();
    public void set_Left(double value);
    public double get_Right();
    public void set_Right(double value);
    public ExcelColor get_Color1();
    public ExcelColor get_Color2();
    internal virtual string get_Id();
}
public enum OfficeOpenXml.Style.ExcelHorizontalAlignment : Enum {
    public int value__;
    public static ExcelHorizontalAlignment General;
    public static ExcelHorizontalAlignment Left;
    public static ExcelHorizontalAlignment Center;
    public static ExcelHorizontalAlignment CenterContinuous;
    public static ExcelHorizontalAlignment Right;
    public static ExcelHorizontalAlignment Fill;
    public static ExcelHorizontalAlignment Distributed;
    public static ExcelHorizontalAlignment Justify;
}
public class OfficeOpenXml.Style.ExcelNumberFormat : StyleBase {
    [CompilerGeneratedAttribute]
private bool <BuildIn>k__BackingField;
    public int NumFmtID { get; }
    public string Format { get; public set; }
    internal string Id { get; }
    public bool BuildIn { get; private set; }
    internal ExcelNumberFormat(ExcelStyles styles, ChangedEventHandler ChangedEvent, int PositionID, string Address, int index);
    public int get_NumFmtID();
    public string get_Format();
    public void set_Format(string value);
    internal virtual string get_Id();
    [CompilerGeneratedAttribute]
public bool get_BuildIn();
    [CompilerGeneratedAttribute]
private void set_BuildIn(bool value);
    internal static string GetFromBuildInFromID(int _numFmtId);
    internal static int GetFromBuildIdFromFormat(string format);
}
public class OfficeOpenXml.Style.ExcelParagraph : ExcelTextFont {
    private static string TextPath;
    public string Text { get; public set; }
    public ExcelParagraph(XmlNamespaceManager ns, XmlNode rootNode, string path, String[] schemaNodeOrder);
    public string get_Text();
    public void set_Text(string value);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Style.ExcelParagraphCollection : XmlHelper {
    private List`1<ExcelParagraph> _list;
    private string _path;
    public ExcelParagraph Item { get; }
    public int Count { get; }
    public string Text { get; public set; }
    internal ExcelParagraphCollection(XmlNamespaceManager ns, XmlNode topNode, string path, String[] schemaNodeOrder);
    public ExcelParagraph get_Item(int Index);
    public int get_Count();
    public ExcelParagraph Add(string Text);
    public void Clear();
    public void RemoveAt(int Index);
    public void Remove(ExcelRichText Item);
    public string get_Text();
    public void set_Text(string value);
    private sealed virtual override IEnumerator`1<ExcelParagraph> System.Collections.Generic.IEnumerable<OfficeOpenXml.Style.ExcelParagraph>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum OfficeOpenXml.Style.ExcelReadingOrder : Enum {
    public int value__;
    public static ExcelReadingOrder ContextDependent;
    public static ExcelReadingOrder LeftToRight;
    public static ExcelReadingOrder RightToLeft;
}
public class OfficeOpenXml.Style.ExcelRichText : XmlHelper {
    private CallbackDelegate _callback;
    private static string TEXT_PATH;
    private static string BOLD_PATH;
    private static string ITALIC_PATH;
    private static string STRIKE_PATH;
    private static string UNDERLINE_PATH;
    private static string VERT_ALIGN_PATH;
    private static string SIZE_PATH;
    private static string FONT_PATH;
    private static string COLOR_PATH;
    [CompilerGeneratedAttribute]
private ExcelRichTextCollection <_collection>k__BackingField;
    public string Text { get; public set; }
    public bool PreserveSpace { get; public set; }
    public bool Bold { get; public set; }
    public bool Italic { get; public set; }
    public bool Strike { get; public set; }
    public bool UnderLine { get; public set; }
    public ExcelVerticalAlignmentFont VerticalAlign { get; public set; }
    public float Size { get; public set; }
    public string FontName { get; public set; }
    public Color Color { get; public set; }
    public ExcelRichTextCollection _collection { get; public set; }
    internal ExcelRichText(XmlNamespaceManager ns, XmlNode topNode, ExcelRichTextCollection collection);
    internal void SetCallback(CallbackDelegate callback);
    public string get_Text();
    public void set_Text(string value);
    public bool get_PreserveSpace();
    public void set_PreserveSpace(bool value);
    public bool get_Bold();
    public void set_Bold(bool value);
    public bool get_Italic();
    public void set_Italic(bool value);
    public bool get_Strike();
    public void set_Strike(bool value);
    public bool get_UnderLine();
    public void set_UnderLine(bool value);
    public ExcelVerticalAlignmentFont get_VerticalAlign();
    public void set_VerticalAlign(ExcelVerticalAlignmentFont value);
    public float get_Size();
    public void set_Size(float value);
    public string get_FontName();
    public void set_FontName(string value);
    public Color get_Color();
    public void set_Color(Color value);
    [CompilerGeneratedAttribute]
public ExcelRichTextCollection get__collection();
    [CompilerGeneratedAttribute]
public void set__collection(ExcelRichTextCollection value);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Style.ExcelRichTextCollection : XmlHelper {
    private List`1<ExcelRichText> _list;
    private ExcelRangeBase _cells;
    public ExcelRichText Item { get; }
    public int Count { get; }
    public string Text { get; public set; }
    internal ExcelRichTextCollection(XmlNamespaceManager ns, XmlNode topNode);
    internal ExcelRichTextCollection(XmlNamespaceManager ns, XmlNode topNode, ExcelRangeBase cells);
    public ExcelRichText get_Item(int Index);
    public int get_Count();
    public ExcelRichText Add(string Text);
    public ExcelRichText Insert(int index, string text);
    internal void ConvertRichtext();
    internal void UpdateCells();
    public void Clear();
    public void RemoveAt(int Index);
    public void Remove(ExcelRichText Item);
    public string get_Text();
    public void set_Text(string value);
    private sealed virtual override IEnumerator`1<ExcelRichText> System.Collections.Generic.IEnumerable<OfficeOpenXml.Style.ExcelRichText>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private ExcelRichText <System.Collections.Generic.IEnumerable<OfficeOpenXml.Style.ExcelRichText>.GetEnumerator>b__18_0(ExcelRichText x);
    [CompilerGeneratedAttribute]
private ExcelRichText <System.Collections.IEnumerable.GetEnumerator>b__19_0(ExcelRichText x);
}
public class OfficeOpenXml.Style.ExcelRichTextHtmlUtility : object {
    public static void SetRichTextFromHtml(ExcelRange range, string html, string defaultFontName, short defaultFontSize);
    private static void SetStyleFromTag(string tag, ExcelRichText settings);
    private static string CleanText(string s);
}
public class OfficeOpenXml.Style.ExcelStyle : StyleBase {
    [CompilerGeneratedAttribute]
private ExcelNumberFormat <Numberformat>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelFont <Font>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelFill <Fill>k__BackingField;
    [CompilerGeneratedAttribute]
private Border <Border>k__BackingField;
    private static string xfIdPath;
    [CompilerGeneratedAttribute]
private int <PositionID>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelStyles <Styles>k__BackingField;
    public ExcelNumberFormat Numberformat { get; public set; }
    public ExcelFont Font { get; public set; }
    public ExcelFill Fill { get; public set; }
    public Border Border { get; public set; }
    public ExcelHorizontalAlignment HorizontalAlignment { get; public set; }
    public ExcelVerticalAlignment VerticalAlignment { get; public set; }
    public bool WrapText { get; public set; }
    public ExcelReadingOrder ReadingOrder { get; public set; }
    public bool ShrinkToFit { get; public set; }
    public int Indent { get; public set; }
    public int TextRotation { get; public set; }
    public bool Locked { get; public set; }
    public bool Hidden { get; public set; }
    public bool QuotePrefix { get; public set; }
    public int XfId { get; public set; }
    internal int PositionID { get; internal set; }
    internal ExcelStyles Styles { get; internal set; }
    internal string Id { get; }
    internal ExcelStyle(ExcelStyles styles, ChangedEventHandler ChangedEvent, int positionID, string Address, int xfsId);
    [CompilerGeneratedAttribute]
public ExcelNumberFormat get_Numberformat();
    [CompilerGeneratedAttribute]
public void set_Numberformat(ExcelNumberFormat value);
    [CompilerGeneratedAttribute]
public ExcelFont get_Font();
    [CompilerGeneratedAttribute]
public void set_Font(ExcelFont value);
    [CompilerGeneratedAttribute]
public ExcelFill get_Fill();
    [CompilerGeneratedAttribute]
public void set_Fill(ExcelFill value);
    [CompilerGeneratedAttribute]
public Border get_Border();
    [CompilerGeneratedAttribute]
public void set_Border(Border value);
    public ExcelHorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(ExcelHorizontalAlignment value);
    public ExcelVerticalAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(ExcelVerticalAlignment value);
    public bool get_WrapText();
    public void set_WrapText(bool value);
    public ExcelReadingOrder get_ReadingOrder();
    public void set_ReadingOrder(ExcelReadingOrder value);
    public bool get_ShrinkToFit();
    public void set_ShrinkToFit(bool value);
    public int get_Indent();
    public void set_Indent(int value);
    public int get_TextRotation();
    public void set_TextRotation(int value);
    public bool get_Locked();
    public void set_Locked(bool value);
    public bool get_Hidden();
    public void set_Hidden(bool value);
    public bool get_QuotePrefix();
    public void set_QuotePrefix(bool value);
    public int get_XfId();
    public void set_XfId(int value);
    [CompilerGeneratedAttribute]
internal int get_PositionID();
    [CompilerGeneratedAttribute]
internal void set_PositionID(int value);
    [CompilerGeneratedAttribute]
internal ExcelStyles get_Styles();
    [CompilerGeneratedAttribute]
internal void set_Styles(ExcelStyles value);
    internal virtual string get_Id();
}
public class OfficeOpenXml.Style.ExcelTextFont : XmlHelper {
    private string _path;
    private XmlNode _rootNode;
    private string _fontLatinPath;
    private string _fontCsPath;
    private string _boldPath;
    private string _underLinePath;
    private string _underLineColorPath;
    private string _italicPath;
    private string _strikePath;
    private string _sizePath;
    private string _colorPath;
    public string LatinFont { get; public set; }
    public string ComplexFont { get; public set; }
    public bool Bold { get; public set; }
    public eUnderLineType UnderLine { get; public set; }
    public Color UnderLineColor { get; public set; }
    public bool Italic { get; public set; }
    public eStrikeType Strike { get; public set; }
    public float Size { get; public set; }
    public Color Color { get; public set; }
    internal ExcelTextFont(XmlNamespaceManager namespaceManager, XmlNode rootNode, string path, String[] schemaNodeOrder);
    public string get_LatinFont();
    public void set_LatinFont(string value);
    protected internal void CreateTopNode();
    public string get_ComplexFont();
    public void set_ComplexFont(string value);
    public bool get_Bold();
    public void set_Bold(bool value);
    public eUnderLineType get_UnderLine();
    public void set_UnderLine(eUnderLineType value);
    public Color get_UnderLineColor();
    public void set_UnderLineColor(Color value);
    public bool get_Italic();
    public void set_Italic(bool value);
    public eStrikeType get_Strike();
    public void set_Strike(eStrikeType value);
    public float get_Size();
    public void set_Size(float value);
    public Color get_Color();
    public void set_Color(Color value);
    private eUnderLineType TranslateUnderline(string text);
    private string TranslateUnderlineText(eUnderLineType value);
    private eStrikeType TranslateStrike(string text);
    private string TranslateStrikeText(eStrikeType value);
    public void SetFromFont(Font Font);
}
public enum OfficeOpenXml.Style.ExcelUnderLineType : Enum {
    public int value__;
    public static ExcelUnderLineType None;
    public static ExcelUnderLineType Single;
    public static ExcelUnderLineType Double;
    public static ExcelUnderLineType SingleAccounting;
    public static ExcelUnderLineType DoubleAccounting;
}
public enum OfficeOpenXml.Style.ExcelVerticalAlignment : Enum {
    public int value__;
    public static ExcelVerticalAlignment Top;
    public static ExcelVerticalAlignment Center;
    public static ExcelVerticalAlignment Bottom;
    public static ExcelVerticalAlignment Distributed;
    public static ExcelVerticalAlignment Justify;
}
public enum OfficeOpenXml.Style.ExcelVerticalAlignmentFont : Enum {
    public int value__;
    public static ExcelVerticalAlignmentFont None;
    public static ExcelVerticalAlignmentFont Subscript;
    public static ExcelVerticalAlignmentFont Superscript;
}
internal interface OfficeOpenXml.Style.IExcelCell {
    public object Value { get; public set; }
    public string StyleName { get; }
    public int StyleID { get; public set; }
    public ExcelStyle Style { get; }
    public Uri Hyperlink { get; public set; }
    public string Formula { get; public set; }
    public string FormulaR1C1 { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
    public abstract virtual string get_StyleName();
    public abstract virtual int get_StyleID();
    public abstract virtual void set_StyleID(int value);
    public abstract virtual ExcelStyle get_Style();
    public abstract virtual Uri get_Hyperlink();
    public abstract virtual void set_Hyperlink(Uri value);
    public abstract virtual string get_Formula();
    public abstract virtual void set_Formula(string value);
    public abstract virtual string get_FormulaR1C1();
    public abstract virtual void set_FormulaR1C1(string value);
}
internal interface OfficeOpenXml.Style.IStyle {
    public ulong Id { get; }
    public ExcelStyle ExcelStyle { get; }
    public abstract virtual void SetNewStyleID(string value);
    public abstract virtual ulong get_Id();
    public abstract virtual ExcelStyle get_ExcelStyle();
}
public abstract class OfficeOpenXml.Style.StyleBase : object {
    protected ExcelStyles _styles;
    internal ChangedEventHandler _ChangedEvent;
    protected int _positionID;
    protected string _address;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    internal int Index { get; internal set; }
    internal string Id { get; }
    internal StyleBase(ExcelStyles styles, ChangedEventHandler ChangedEvent, int PositionID, string Address);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    internal abstract virtual string get_Id();
    internal virtual void SetIndex(int index);
}
internal class OfficeOpenXml.Style.StyleChangeEventArgs : EventArgs {
    internal eStyleClass StyleClass;
    internal eStyleProperty StyleProperty;
    internal object Value;
    [CompilerGeneratedAttribute]
private int <PositionID>k__BackingField;
    internal string Address;
    internal int PositionID { get; internal set; }
    internal StyleChangeEventArgs(eStyleClass styleclass, eStyleProperty styleProperty, object value, int positionID, string address);
    [CompilerGeneratedAttribute]
internal int get_PositionID();
    [CompilerGeneratedAttribute]
internal void set_PositionID(int value);
}
public class OfficeOpenXml.Style.XmlAccess.ExcelBorderItemXml : StyleXmlHelper {
    private ExcelBorderStyle _borderStyle;
    private ExcelColorXml _color;
    private static string _colorPath;
    [CompilerGeneratedAttribute]
private bool <Exists>k__BackingField;
    public ExcelBorderStyle Style { get; public set; }
    public ExcelColorXml Color { get; internal set; }
    internal string Id { get; }
    public bool Exists { get; private set; }
    internal ExcelBorderItemXml(XmlNamespaceManager nameSpaceManager);
    internal ExcelBorderItemXml(XmlNamespaceManager nsm, XmlNode topNode);
    private ExcelBorderStyle GetBorderStyle(string style);
    public ExcelBorderStyle get_Style();
    public void set_Style(ExcelBorderStyle value);
    public ExcelColorXml get_Color();
    internal void set_Color(ExcelColorXml value);
    internal virtual string get_Id();
    internal ExcelBorderItemXml Copy();
    internal virtual XmlNode CreateXmlNode(XmlNode topNode);
    private string SetBorderString(ExcelBorderStyle Style);
    [CompilerGeneratedAttribute]
public bool get_Exists();
    [CompilerGeneratedAttribute]
private void set_Exists(bool value);
}
public class OfficeOpenXml.Style.XmlAccess.ExcelBorderXml : StyleXmlHelper {
    private static string leftPath;
    private ExcelBorderItemXml _left;
    private static string rightPath;
    private ExcelBorderItemXml _right;
    private static string topPath;
    private ExcelBorderItemXml _top;
    private static string bottomPath;
    private ExcelBorderItemXml _bottom;
    private static string diagonalPath;
    private ExcelBorderItemXml _diagonal;
    private static string diagonalUpPath;
    private bool _diagonalUp;
    private static string diagonalDownPath;
    private bool _diagonalDown;
    internal string Id { get; }
    public ExcelBorderItemXml Left { get; internal set; }
    public ExcelBorderItemXml Right { get; internal set; }
    public ExcelBorderItemXml Top { get; internal set; }
    public ExcelBorderItemXml Bottom { get; internal set; }
    public ExcelBorderItemXml Diagonal { get; internal set; }
    public bool DiagonalUp { get; internal set; }
    public bool DiagonalDown { get; internal set; }
    internal ExcelBorderXml(XmlNamespaceManager nameSpaceManager);
    internal ExcelBorderXml(XmlNamespaceManager nsm, XmlNode topNode);
    internal virtual string get_Id();
    public ExcelBorderItemXml get_Left();
    internal void set_Left(ExcelBorderItemXml value);
    public ExcelBorderItemXml get_Right();
    internal void set_Right(ExcelBorderItemXml value);
    public ExcelBorderItemXml get_Top();
    internal void set_Top(ExcelBorderItemXml value);
    public ExcelBorderItemXml get_Bottom();
    internal void set_Bottom(ExcelBorderItemXml value);
    public ExcelBorderItemXml get_Diagonal();
    internal void set_Diagonal(ExcelBorderItemXml value);
    public bool get_DiagonalUp();
    internal void set_DiagonalUp(bool value);
    public bool get_DiagonalDown();
    internal void set_DiagonalDown(bool value);
    internal ExcelBorderXml Copy();
    internal virtual XmlNode CreateXmlNode(XmlNode topNode);
}
public class OfficeOpenXml.Style.XmlAccess.ExcelColorXml : StyleXmlHelper {
    private bool _auto;
    private string _theme;
    private decimal _tint;
    private string _rgb;
    private int _indexed;
    private bool _exists;
    internal string Id { get; }
    public bool Auto { get; public set; }
    public string Theme { get; }
    public decimal Tint { get; public set; }
    public string Rgb { get; public set; }
    public int Indexed { get; public set; }
    internal bool Exists { get; }
    internal ExcelColorXml(XmlNamespaceManager nameSpaceManager);
    internal ExcelColorXml(XmlNamespaceManager nsm, XmlNode topNode);
    internal virtual string get_Id();
    public bool get_Auto();
    public void set_Auto(bool value);
    public string get_Theme();
    public decimal get_Tint();
    public void set_Tint(decimal value);
    public string get_Rgb();
    public void set_Rgb(string value);
    public int get_Indexed();
    public void set_Indexed(int value);
    internal void Clear();
    public void SetColor(Color color);
    internal ExcelColorXml Copy();
    internal virtual XmlNode CreateXmlNode(XmlNode topNode);
    internal bool get_Exists();
}
public class OfficeOpenXml.Style.XmlAccess.ExcelFillXml : StyleXmlHelper {
    private static string fillPatternTypePath;
    protected ExcelFillStyle _fillPatternType;
    protected ExcelColorXml _patternColor;
    private static string _patternColorPath;
    protected ExcelColorXml _backgroundColor;
    private static string _backgroundColorPath;
    internal string Id { get; }
    public ExcelFillStyle PatternType { get; public set; }
    public ExcelColorXml PatternColor { get; internal set; }
    public ExcelColorXml BackgroundColor { get; internal set; }
    internal ExcelFillXml(XmlNamespaceManager nameSpaceManager);
    internal ExcelFillXml(XmlNamespaceManager nsm, XmlNode topNode);
    private ExcelFillStyle GetPatternType(string patternType);
    internal virtual string get_Id();
    public ExcelFillStyle get_PatternType();
    public void set_PatternType(ExcelFillStyle value);
    public ExcelColorXml get_PatternColor();
    internal void set_PatternColor(ExcelColorXml value);
    public ExcelColorXml get_BackgroundColor();
    internal void set_BackgroundColor(ExcelColorXml value);
    internal virtual ExcelFillXml Copy();
    internal virtual XmlNode CreateXmlNode(XmlNode topNode);
    private string SetPatternString(ExcelFillStyle pattern);
}
public class OfficeOpenXml.Style.XmlAccess.ExcelFontXml : StyleXmlHelper {
    private static string namePath;
    private string _name;
    private static string sizePath;
    private float _size;
    private static string familyPath;
    private int _family;
    private ExcelColorXml _color;
    private static string _colorPath;
    private static string schemePath;
    private string _scheme;
    private static string boldPath;
    private bool _bold;
    private static string italicPath;
    private bool _italic;
    private static string strikePath;
    private bool _strike;
    private static string underLinedPath;
    private ExcelUnderLineType _underlineType;
    private static string verticalAlignPath;
    private string _verticalAlign;
    internal string Id { get; }
    public string Name { get; public set; }
    public float Size { get; public set; }
    public int Family { get; public set; }
    public ExcelColorXml Color { get; internal set; }
    public string Scheme { get; private set; }
    public bool Bold { get; public set; }
    public bool Italic { get; public set; }
    public bool Strike { get; public set; }
    public bool UnderLine { get; public set; }
    public ExcelUnderLineType UnderLineType { get; public set; }
    public string VerticalAlign { get; public set; }
    internal ExcelFontXml(XmlNamespaceManager nameSpaceManager);
    internal ExcelFontXml(XmlNamespaceManager nsm, XmlNode topNode);
    internal virtual string get_Id();
    public string get_Name();
    public void set_Name(string value);
    public float get_Size();
    public void set_Size(float value);
    public int get_Family();
    public void set_Family(int value);
    public ExcelColorXml get_Color();
    internal void set_Color(ExcelColorXml value);
    public string get_Scheme();
    private void set_Scheme(string value);
    public bool get_Bold();
    public void set_Bold(bool value);
    public bool get_Italic();
    public void set_Italic(bool value);
    public bool get_Strike();
    public void set_Strike(bool value);
    public bool get_UnderLine();
    public void set_UnderLine(bool value);
    public ExcelUnderLineType get_UnderLineType();
    public void set_UnderLineType(ExcelUnderLineType value);
    public string get_VerticalAlign();
    public void set_VerticalAlign(string value);
    public void SetFromFont(Font Font);
    public static float GetFontHeight(string name, float size);
    private static float GetHeightByName(string name, float size);
    internal ExcelFontXml Copy();
    internal virtual XmlNode CreateXmlNode(XmlNode topElement);
}
public class OfficeOpenXml.Style.XmlAccess.ExcelGradientFillXml : ExcelFillXml {
    private static string _typePath;
    [CompilerGeneratedAttribute]
private ExcelFillGradientType <Type>k__BackingField;
    private static string _degreePath;
    [CompilerGeneratedAttribute]
private double <Degree>k__BackingField;
    private static string _gradientColor1Path;
    [CompilerGeneratedAttribute]
private ExcelColorXml <GradientColor1>k__BackingField;
    private static string _gradientColor2Path;
    [CompilerGeneratedAttribute]
private ExcelColorXml <GradientColor2>k__BackingField;
    private static string _bottomPath;
    [CompilerGeneratedAttribute]
private double <Bottom>k__BackingField;
    private static string _topPath;
    [CompilerGeneratedAttribute]
private double <Top>k__BackingField;
    private static string _leftPath;
    [CompilerGeneratedAttribute]
private double <Left>k__BackingField;
    private static string _rightPath;
    [CompilerGeneratedAttribute]
private double <Right>k__BackingField;
    public ExcelFillGradientType Type { get; internal set; }
    public double Degree { get; internal set; }
    public ExcelColorXml GradientColor1 { get; private set; }
    public ExcelColorXml GradientColor2 { get; private set; }
    public double Bottom { get; internal set; }
    public double Top { get; internal set; }
    public double Left { get; internal set; }
    public double Right { get; internal set; }
    internal string Id { get; }
    internal ExcelGradientFillXml(XmlNamespaceManager nameSpaceManager);
    internal ExcelGradientFillXml(XmlNamespaceManager nsm, XmlNode topNode);
    [CompilerGeneratedAttribute]
public ExcelFillGradientType get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(ExcelFillGradientType value);
    [CompilerGeneratedAttribute]
public double get_Degree();
    [CompilerGeneratedAttribute]
internal void set_Degree(double value);
    [CompilerGeneratedAttribute]
public ExcelColorXml get_GradientColor1();
    [CompilerGeneratedAttribute]
private void set_GradientColor1(ExcelColorXml value);
    [CompilerGeneratedAttribute]
public ExcelColorXml get_GradientColor2();
    [CompilerGeneratedAttribute]
private void set_GradientColor2(ExcelColorXml value);
    [CompilerGeneratedAttribute]
public double get_Bottom();
    [CompilerGeneratedAttribute]
internal void set_Bottom(double value);
    [CompilerGeneratedAttribute]
public double get_Top();
    [CompilerGeneratedAttribute]
internal void set_Top(double value);
    [CompilerGeneratedAttribute]
public double get_Left();
    [CompilerGeneratedAttribute]
internal void set_Left(double value);
    [CompilerGeneratedAttribute]
public double get_Right();
    [CompilerGeneratedAttribute]
internal void set_Right(double value);
    internal virtual string get_Id();
    internal virtual ExcelFillXml Copy();
    internal virtual XmlNode CreateXmlNode(XmlNode topNode);
}
public class OfficeOpenXml.Style.XmlAccess.ExcelNamedStyleXml : StyleXmlHelper {
    private ExcelStyles _styles;
    private int _styleXfId;
    private static string idPath;
    private int _xfId;
    private static string buildInIdPath;
    [CompilerGeneratedAttribute]
private int <BuildInId>k__BackingField;
    private static string customBuiltinPath;
    [CompilerGeneratedAttribute]
private bool <CustomBuildin>k__BackingField;
    private static string namePath;
    private string _name;
    private ExcelStyle _style;
    internal string Id { get; }
    public int StyleXfId { get; public set; }
    internal int XfId { get; internal set; }
    public int BuildInId { get; public set; }
    public bool CustomBuildin { get; public set; }
    public string Name { get; internal set; }
    public ExcelStyle Style { get; internal set; }
    internal ExcelNamedStyleXml(XmlNamespaceManager nameSpaceManager, ExcelStyles styles);
    internal ExcelNamedStyleXml(XmlNamespaceManager NameSpaceManager, XmlNode topNode, ExcelStyles styles);
    internal virtual string get_Id();
    public int get_StyleXfId();
    public void set_StyleXfId(int value);
    internal int get_XfId();
    internal void set_XfId(int value);
    [CompilerGeneratedAttribute]
public int get_BuildInId();
    [CompilerGeneratedAttribute]
public void set_BuildInId(int value);
    [CompilerGeneratedAttribute]
public bool get_CustomBuildin();
    [CompilerGeneratedAttribute]
public void set_CustomBuildin(bool value);
    public string get_Name();
    internal void set_Name(string value);
    public ExcelStyle get_Style();
    internal void set_Style(ExcelStyle value);
    internal virtual XmlNode CreateXmlNode(XmlNode topNode);
}
public class OfficeOpenXml.Style.XmlAccess.ExcelNumberFormatXml : StyleXmlHelper {
    [CompilerGeneratedAttribute]
private bool <BuildIn>k__BackingField;
    private int _numFmtId;
    private static string fmtPath;
    private string _format;
    private ExcelFormatTranslator _translator;
    public bool BuildIn { get; private set; }
    public int NumFmtId { get; public set; }
    internal string Id { get; }
    public string Format { get; public set; }
    internal ExcelFormatTranslator FormatTranslator { get; }
    internal ExcelNumberFormatXml(XmlNamespaceManager nameSpaceManager);
    internal ExcelNumberFormatXml(XmlNamespaceManager nameSpaceManager, bool buildIn);
    internal ExcelNumberFormatXml(XmlNamespaceManager nsm, XmlNode topNode);
    [CompilerGeneratedAttribute]
public bool get_BuildIn();
    [CompilerGeneratedAttribute]
private void set_BuildIn(bool value);
    public int get_NumFmtId();
    public void set_NumFmtId(int value);
    internal virtual string get_Id();
    public string get_Format();
    public void set_Format(string value);
    internal string GetNewID(int NumFmtId, string Format);
    internal static void AddBuildIn(XmlNamespaceManager NameSpaceManager, ExcelStyleCollection`1<ExcelNumberFormatXml> NumberFormats);
    internal virtual XmlNode CreateXmlNode(XmlNode topNode);
    internal ExcelFormatTranslator get_FormatTranslator();
}
public class OfficeOpenXml.Style.XmlAccess.ExcelXfs : StyleXmlHelper {
    private ExcelStyles _styles;
    private int _xfID;
    private int _numFmtId;
    private int _fontId;
    private int _fillId;
    private int _borderId;
    [CompilerGeneratedAttribute]
private bool <isBuildIn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyNumberFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyFont>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyFill>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyBorder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyProtection>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelStyles <Styles>k__BackingField;
    private static string horizontalAlignPath;
    private ExcelHorizontalAlignment _horizontalAlignment;
    private static string verticalAlignPath;
    private ExcelVerticalAlignment _verticalAlignment;
    private static string wrapTextPath;
    private bool _wrapText;
    private string textRotationPath;
    private int _textRotation;
    private static string lockedPath;
    private bool _locked;
    private static string hiddenPath;
    private bool _hidden;
    private static string quotePrefixPath;
    private bool _quotePrefix;
    private static string readingOrderPath;
    private ExcelReadingOrder _readingOrder;
    private static string shrinkToFitPath;
    private bool _shrinkToFit;
    private static string indentPath;
    private int _indent;
    public int XfId { get; public set; }
    internal int NumberFormatId { get; internal set; }
    internal int FontId { get; internal set; }
    internal int FillId { get; internal set; }
    internal int BorderId { get; internal set; }
    private bool isBuildIn { get; private set; }
    internal bool ApplyNumberFormat { get; internal set; }
    internal bool ApplyFont { get; internal set; }
    internal bool ApplyFill { get; internal set; }
    internal bool ApplyBorder { get; internal set; }
    internal bool ApplyAlignment { get; internal set; }
    internal bool ApplyProtection { get; internal set; }
    public ExcelStyles Styles { get; private set; }
    public ExcelNumberFormatXml Numberformat { get; }
    public ExcelFontXml Font { get; }
    public ExcelFillXml Fill { get; }
    public ExcelBorderXml Border { get; }
    public ExcelHorizontalAlignment HorizontalAlignment { get; public set; }
    public ExcelVerticalAlignment VerticalAlignment { get; public set; }
    public bool WrapText { get; public set; }
    public int TextRotation { get; public set; }
    public bool Locked { get; public set; }
    public bool Hidden { get; public set; }
    public bool QuotePrefix { get; public set; }
    public ExcelReadingOrder ReadingOrder { get; public set; }
    public bool ShrinkToFit { get; public set; }
    public int Indent { get; public set; }
    internal string Id { get; }
    internal ExcelXfs(XmlNamespaceManager nameSpaceManager, ExcelStyles styles);
    internal ExcelXfs(XmlNamespaceManager nsm, XmlNode topNode, ExcelStyles styles);
    private ExcelReadingOrder GetReadingOrder(string value);
    private ExcelHorizontalAlignment GetHorizontalAlign(string align);
    private ExcelVerticalAlignment GetVerticalAlign(string align);
    internal void Xf_ChangedEvent(object sender, EventArgs e);
    public int get_XfId();
    public void set_XfId(int value);
    internal int get_NumberFormatId();
    internal void set_NumberFormatId(int value);
    internal int get_FontId();
    internal void set_FontId(int value);
    internal int get_FillId();
    internal void set_FillId(int value);
    internal int get_BorderId();
    internal void set_BorderId(int value);
    [CompilerGeneratedAttribute]
private bool get_isBuildIn();
    [CompilerGeneratedAttribute]
private void set_isBuildIn(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ApplyNumberFormat();
    [CompilerGeneratedAttribute]
internal void set_ApplyNumberFormat(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ApplyFont();
    [CompilerGeneratedAttribute]
internal void set_ApplyFont(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ApplyFill();
    [CompilerGeneratedAttribute]
internal void set_ApplyFill(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ApplyBorder();
    [CompilerGeneratedAttribute]
internal void set_ApplyBorder(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ApplyAlignment();
    [CompilerGeneratedAttribute]
internal void set_ApplyAlignment(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ApplyProtection();
    [CompilerGeneratedAttribute]
internal void set_ApplyProtection(bool value);
    [CompilerGeneratedAttribute]
public ExcelStyles get_Styles();
    [CompilerGeneratedAttribute]
private void set_Styles(ExcelStyles value);
    public ExcelNumberFormatXml get_Numberformat();
    public ExcelFontXml get_Font();
    public ExcelFillXml get_Fill();
    public ExcelBorderXml get_Border();
    public ExcelHorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(ExcelHorizontalAlignment value);
    public ExcelVerticalAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(ExcelVerticalAlignment value);
    public bool get_WrapText();
    public void set_WrapText(bool value);
    public int get_TextRotation();
    public void set_TextRotation(int value);
    public bool get_Locked();
    public void set_Locked(bool value);
    public bool get_Hidden();
    public void set_Hidden(bool value);
    public bool get_QuotePrefix();
    public void set_QuotePrefix(bool value);
    public ExcelReadingOrder get_ReadingOrder();
    public void set_ReadingOrder(ExcelReadingOrder value);
    public bool get_ShrinkToFit();
    public void set_ShrinkToFit(bool value);
    public int get_Indent();
    public void set_Indent(int value);
    internal void RegisterEvent(ExcelXfs xf);
    internal virtual string get_Id();
    internal ExcelXfs Copy();
    internal ExcelXfs Copy(ExcelStyles styles);
    internal int GetNewID(ExcelStyleCollection`1<ExcelXfs> xfsCol, StyleBase styleObject, eStyleClass styleClass, eStyleProperty styleProperty, object value);
    private int GetIdBorder(eStyleClass styleClass, eStyleProperty styleProperty, object value);
    private void SetBorderItem(ExcelBorderItemXml excelBorderItem, eStyleProperty styleProperty, object value);
    private int GetIdFill(eStyleClass styleClass, eStyleProperty styleProperty, object value);
    private int GetIdGradientFill(eStyleClass styleClass, eStyleProperty styleProperty, object value);
    private int GetIdNumberFormat(eStyleProperty styleProperty, object value);
    private int GetIdFont(eStyleProperty styleProperty, object value);
    internal virtual XmlNode CreateXmlNode(XmlNode topNode);
    internal XmlNode CreateXmlNode(XmlNode topNode, bool isCellStyleXsf);
    private string SetAlignString(Enum align);
}
public abstract class OfficeOpenXml.Style.XmlAccess.StyleXmlHelper : XmlHelper {
    internal long useCnt;
    internal int newID;
    internal string Id { get; }
    internal StyleXmlHelper(XmlNamespaceManager nameSpaceManager);
    internal StyleXmlHelper(XmlNamespaceManager nameSpaceManager, XmlNode topNode);
    internal abstract virtual XmlNode CreateXmlNode(XmlNode top);
    internal abstract virtual string get_Id();
    protected bool GetBoolValue(XmlNode topNode, string path);
}
public class OfficeOpenXml.Table.ExcelTable : XmlHelper {
    [CompilerGeneratedAttribute]
private ZipPackagePart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocument <TableXml>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <TableUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelationshipID>k__BackingField;
    private static string ID_PATH;
    private static string NAME_PATH;
    private static string DISPLAY_NAME_PATH;
    [CompilerGeneratedAttribute]
private ExcelWorksheet <WorkSheet>k__BackingField;
    private ExcelAddressBase _address;
    internal ExcelTableColumnCollection _cols;
    private TableStyles _tableStyle;
    private static string HEADERROWCOUNT_PATH;
    private static string AUTOFILTER_PATH;
    private static string TOTALSROWCOUNT_PATH;
    private static string TOTALSROWSHOWN_PATH;
    private static string STYLENAME_PATH;
    private static string SHOWFIRSTCOLUMN_PATH;
    private static string SHOWLASTCOLUMN_PATH;
    private static string SHOWROWSTRIPES_PATH;
    private static string SHOWCOLUMNSTRIPES_PATH;
    private static string TOTALSROWCELLSTYLE_PATH;
    private static string DATACELLSTYLE_PATH;
    private static string HEADERROWCELLSTYLE_PATH;
    internal ZipPackagePart Part { get; internal set; }
    public XmlDocument TableXml { get; public set; }
    public Uri TableUri { get; internal set; }
    internal string RelationshipID { get; internal set; }
    internal int Id { get; internal set; }
    public string Name { get; public set; }
    public ExcelWorksheet WorkSheet { get; public set; }
    public ExcelAddressBase Address { get; internal set; }
    public ExcelTableColumnCollection Columns { get; }
    public TableStyles TableStyle { get; public set; }
    public bool ShowHeader { get; public set; }
    internal ExcelAddressBase AutoFilterAddress { get; }
    public bool ShowFilter { get; public set; }
    public bool ShowTotal { get; public set; }
    public string StyleName { get; public set; }
    public bool ShowFirstColumn { get; public set; }
    public bool ShowLastColumn { get; public set; }
    public bool ShowRowStripes { get; public set; }
    public bool ShowColumnStripes { get; public set; }
    public string TotalsRowCellStyle { get; public set; }
    public string DataCellStyleName { get; public set; }
    public string HeaderRowCellStyle { get; public set; }
    internal ExcelTable(ZipPackageRelationship rel, ExcelWorksheet sheet);
    internal ExcelTable(ExcelWorksheet sheet, ExcelAddressBase address, string name, int tblId);
    private void init();
    private string GetStartXml(string name, int tblId);
    private string cleanDisplayName(string name);
    [CompilerGeneratedAttribute]
internal ZipPackagePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(ZipPackagePart value);
    [CompilerGeneratedAttribute]
public XmlDocument get_TableXml();
    [CompilerGeneratedAttribute]
public void set_TableXml(XmlDocument value);
    [CompilerGeneratedAttribute]
public Uri get_TableUri();
    [CompilerGeneratedAttribute]
internal void set_TableUri(Uri value);
    [CompilerGeneratedAttribute]
internal string get_RelationshipID();
    [CompilerGeneratedAttribute]
internal void set_RelationshipID(string value);
    internal int get_Id();
    internal void set_Id(int value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ExcelWorksheet get_WorkSheet();
    [CompilerGeneratedAttribute]
public void set_WorkSheet(ExcelWorksheet value);
    public ExcelAddressBase get_Address();
    internal void set_Address(ExcelAddressBase value);
    public ExcelTableColumnCollection get_Columns();
    public TableStyles get_TableStyle();
    public void set_TableStyle(TableStyles value);
    public bool get_ShowHeader();
    public void set_ShowHeader(bool value);
    internal ExcelAddressBase get_AutoFilterAddress();
    private void WriteAutoFilter(bool showTotal);
    public bool get_ShowFilter();
    public void set_ShowFilter(bool value);
    public bool get_ShowTotal();
    public void set_ShowTotal(bool value);
    public string get_StyleName();
    public void set_StyleName(string value);
    public bool get_ShowFirstColumn();
    public void set_ShowFirstColumn(bool value);
    public bool get_ShowLastColumn();
    public void set_ShowLastColumn(bool value);
    public bool get_ShowRowStripes();
    public void set_ShowRowStripes(bool value);
    public bool get_ShowColumnStripes();
    public void set_ShowColumnStripes(bool value);
    public string get_TotalsRowCellStyle();
    public void set_TotalsRowCellStyle(string value);
    public string get_DataCellStyleName();
    public void set_DataCellStyleName(string value);
    public string get_HeaderRowCellStyle();
    public void set_HeaderRowCellStyle(string value);
    public sealed virtual bool Equals(ExcelTable x, ExcelTable y);
    public sealed virtual int GetHashCode(ExcelTable obj);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Table.ExcelTableCollection : object {
    private List`1<ExcelTable> _tables;
    internal Dictionary`2<string, int> _tableNames;
    private ExcelWorksheet _ws;
    public int Count { get; }
    public ExcelTable Item { get; }
    public ExcelTable Item { get; }
    internal ExcelTableCollection(ExcelWorksheet ws);
    private ExcelTable Add(ExcelTable tbl);
    public ExcelTable Add(ExcelAddressBase Range, string Name);
    private void ValidateTableName(string Name);
    public void Delete(int Index, bool ClearRange);
    public void Delete(string Name, bool ClearRange);
    public void Delete(ExcelTable Table, bool ClearRange);
    internal string GetNewTableName();
    public int get_Count();
    public ExcelTable GetFromRange(ExcelRangeBase Range);
    public ExcelTable get_Item(int Index);
    public ExcelTable get_Item(string Name);
    public sealed virtual IEnumerator`1<ExcelTable> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class OfficeOpenXml.Table.ExcelTableColumn : XmlHelper {
    internal ExcelTable _tbl;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    private static string TOTALSROWFORMULA_PATH;
    private static string DATACELLSTYLE_PATH;
    private static string CALCULATEDCOLUMNFORMULA_PATH;
    public int Id { get; public set; }
    public int Position { get; private set; }
    public string Name { get; public set; }
    public string TotalsRowLabel { get; public set; }
    public RowFunctions TotalsRowFunction { get; public set; }
    public string TotalsRowFormula { get; public set; }
    public string DataCellStyleName { get; public set; }
    public string CalculatedColumnFormula { get; public set; }
    internal ExcelTableColumn(XmlNamespaceManager ns, XmlNode topNode, ExcelTable tbl, int pos);
    public int get_Id();
    public void set_Id(int value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public string get_Name();
    public void set_Name(string value);
    public string get_TotalsRowLabel();
    public void set_TotalsRowLabel(string value);
    public RowFunctions get_TotalsRowFunction();
    public void set_TotalsRowFunction(RowFunctions value);
    public string get_TotalsRowFormula();
    public void set_TotalsRowFormula(string value);
    public string get_DataCellStyleName();
    public void set_DataCellStyleName(string value);
    public string get_CalculatedColumnFormula();
    public void set_CalculatedColumnFormula(string value);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Table.ExcelTableColumnCollection : object {
    private List`1<ExcelTableColumn> _cols;
    private Dictionary`2<string, int> _colNames;
    [CompilerGeneratedAttribute]
private ExcelTable <Table>k__BackingField;
    public ExcelTable Table { get; private set; }
    public int Count { get; }
    public ExcelTableColumn Item { get; }
    public ExcelTableColumn Item { get; }
    public ExcelTableColumnCollection(ExcelTable table);
    [CompilerGeneratedAttribute]
public ExcelTable get_Table();
    [CompilerGeneratedAttribute]
private void set_Table(ExcelTable value);
    public int get_Count();
    public ExcelTableColumn get_Item(int Index);
    public ExcelTableColumn get_Item(string Name);
    private sealed virtual override IEnumerator`1<ExcelTableColumn> System.Collections.Generic.IEnumerable<OfficeOpenXml.Table.ExcelTableColumn>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal string GetUniqueName(string name);
}
public enum OfficeOpenXml.Table.PivotTable.DataFieldFunctions : Enum {
    public int value__;
    public static DataFieldFunctions Average;
    public static DataFieldFunctions Count;
    public static DataFieldFunctions CountNums;
    public static DataFieldFunctions Max;
    public static DataFieldFunctions Min;
    public static DataFieldFunctions Product;
    public static DataFieldFunctions None;
    public static DataFieldFunctions StdDev;
    public static DataFieldFunctions StdDevP;
    public static DataFieldFunctions Sum;
    public static DataFieldFunctions Var;
    public static DataFieldFunctions VarP;
}
[FlagsAttribute]
public enum OfficeOpenXml.Table.PivotTable.eDateGroupBy : Enum {
    public int value__;
    public static eDateGroupBy Years;
    public static eDateGroupBy Quarters;
    public static eDateGroupBy Months;
    public static eDateGroupBy Days;
    public static eDateGroupBy Hours;
    public static eDateGroupBy Minutes;
    public static eDateGroupBy Seconds;
}
public enum OfficeOpenXml.Table.PivotTable.ePivotFieldAxis : Enum {
    public int value__;
    public static ePivotFieldAxis None;
    public static ePivotFieldAxis Column;
    public static ePivotFieldAxis Page;
    public static ePivotFieldAxis Row;
    public static ePivotFieldAxis Values;
}
public enum OfficeOpenXml.Table.PivotTable.eShowDataAs : Enum {
    public int value__;
    public static eShowDataAs Difference;
    public static eShowDataAs Index;
    public static eShowDataAs Normal;
    public static eShowDataAs Percent;
    public static eShowDataAs PercentDiff;
    public static eShowDataAs PercentOfCol;
    public static eShowDataAs PercentOfRow;
    public static eShowDataAs PercentOfTotal;
    public static eShowDataAs RunTotal;
}
public enum OfficeOpenXml.Table.PivotTable.eSortType : Enum {
    public int value__;
    public static eSortType None;
    public static eSortType Ascending;
    public static eSortType Descending;
}
public enum OfficeOpenXml.Table.PivotTable.eSourceType : Enum {
    public int value__;
    public static eSourceType Consolidation;
    public static eSourceType External;
    public static eSourceType Scenario;
    public static eSourceType Worksheet;
}
[FlagsAttribute]
public enum OfficeOpenXml.Table.PivotTable.eSubTotalFunctions : Enum {
    public int value__;
    public static eSubTotalFunctions None;
    public static eSubTotalFunctions Count;
    public static eSubTotalFunctions CountA;
    public static eSubTotalFunctions Avg;
    public static eSubTotalFunctions Default;
    public static eSubTotalFunctions Min;
    public static eSubTotalFunctions Max;
    public static eSubTotalFunctions Product;
    public static eSubTotalFunctions StdDev;
    public static eSubTotalFunctions StdDevP;
    public static eSubTotalFunctions Sum;
    public static eSubTotalFunctions Var;
    public static eSubTotalFunctions VarP;
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotCacheDefinition : XmlHelper {
    [CompilerGeneratedAttribute]
private ZipPackagePart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocument <CacheDefinitionXml>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CacheDefinitionUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CacheRecordUri>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackageRelationship <Relationship>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackageRelationship <RecordRelationship>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelPivotTable <PivotTable>k__BackingField;
    private static string _sourceWorksheetPath;
    private static string _sourceNamePath;
    internal static string _sourceAddressPath;
    internal ExcelRangeBase _sourceRange;
    internal ZipPackagePart Part { get; internal set; }
    public XmlDocument CacheDefinitionXml { get; private set; }
    public Uri CacheDefinitionUri { get; internal set; }
    internal Uri CacheRecordUri { get; internal set; }
    internal ZipPackageRelationship Relationship { get; internal set; }
    internal ZipPackageRelationship RecordRelationship { get; internal set; }
    internal string RecordRelationshipID { get; internal set; }
    public ExcelPivotTable PivotTable { get; private set; }
    public ExcelRangeBase SourceRange { get; public set; }
    public eSourceType CacheSource { get; }
    internal ExcelPivotCacheDefinition(XmlNamespaceManager ns, ExcelPivotTable pivotTable);
    internal ExcelPivotCacheDefinition(XmlNamespaceManager ns, ExcelPivotTable pivotTable, ExcelRangeBase sourceAddress, int tblId);
    [CompilerGeneratedAttribute]
internal ZipPackagePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(ZipPackagePart value);
    [CompilerGeneratedAttribute]
public XmlDocument get_CacheDefinitionXml();
    [CompilerGeneratedAttribute]
private void set_CacheDefinitionXml(XmlDocument value);
    [CompilerGeneratedAttribute]
public Uri get_CacheDefinitionUri();
    [CompilerGeneratedAttribute]
internal void set_CacheDefinitionUri(Uri value);
    [CompilerGeneratedAttribute]
internal Uri get_CacheRecordUri();
    [CompilerGeneratedAttribute]
internal void set_CacheRecordUri(Uri value);
    [CompilerGeneratedAttribute]
internal ZipPackageRelationship get_Relationship();
    [CompilerGeneratedAttribute]
internal void set_Relationship(ZipPackageRelationship value);
    [CompilerGeneratedAttribute]
internal ZipPackageRelationship get_RecordRelationship();
    [CompilerGeneratedAttribute]
internal void set_RecordRelationship(ZipPackageRelationship value);
    internal string get_RecordRelationshipID();
    internal void set_RecordRelationshipID(string value);
    [CompilerGeneratedAttribute]
public ExcelPivotTable get_PivotTable();
    [CompilerGeneratedAttribute]
private void set_PivotTable(ExcelPivotTable value);
    public ExcelRangeBase get_SourceRange();
    public void set_SourceRange(ExcelRangeBase value);
    public eSourceType get_CacheSource();
    private string GetStartXml(ExcelRangeBase sourceAddress);
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTable : XmlHelper {
    [CompilerGeneratedAttribute]
private ZipPackagePart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocument <PivotTableXml>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PivotTableUri>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackageRelationship <Relationship>k__BackingField;
    private static string NAME_PATH;
    private static string DISPLAY_NAME_PATH;
    private ExcelPivotCacheDefinition _cacheDefinition;
    [CompilerGeneratedAttribute]
private ExcelWorksheet <WorkSheet>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelAddressBase <Address>k__BackingField;
    private static string FIRSTHEADERROW_PATH;
    private static string FIRSTDATAROW_PATH;
    private static string FIRSTDATACOL_PATH;
    private ExcelPivotTableFieldCollection _fields;
    private ExcelPivotTableRowColumnFieldCollection _rowFields;
    private ExcelPivotTableRowColumnFieldCollection _columnFields;
    private ExcelPivotTableDataFieldCollection _dataFields;
    private ExcelPivotTableRowColumnFieldCollection _pageFields;
    private static string STYLENAME_PATH;
    private TableStyles _tableStyle;
    internal ZipPackagePart Part { get; internal set; }
    public XmlDocument PivotTableXml { get; private set; }
    public Uri PivotTableUri { get; internal set; }
    internal ZipPackageRelationship Relationship { get; internal set; }
    public string Name { get; public set; }
    public ExcelPivotCacheDefinition CacheDefinition { get; }
    public ExcelWorksheet WorkSheet { get; public set; }
    public ExcelAddressBase Address { get; internal set; }
    public bool DataOnRows { get; public set; }
    public bool ApplyNumberFormats { get; public set; }
    public bool ApplyBorderFormats { get; public set; }
    public bool ApplyFontFormats { get; public set; }
    public bool ApplyPatternFormats { get; public set; }
    public bool ApplyWidthHeightFormats { get; public set; }
    public bool ShowMemberPropertyTips { get; public set; }
    public bool ShowCalcMember { get; public set; }
    public bool EnableDrill { get; public set; }
    public bool ShowDrill { get; public set; }
    public bool ShowDataTips { get; public set; }
    public bool FieldPrintTitles { get; public set; }
    public bool ItemPrintTitles { get; public set; }
    public bool ColumGrandTotals { get; public set; }
    public bool RowGrandTotals { get; public set; }
    public bool PrintDrill { get; public set; }
    public bool ShowError { get; public set; }
    public string ErrorCaption { get; public set; }
    public string DataCaption { get; public set; }
    public bool ShowHeaders { get; public set; }
    public int PageWrap { get; public set; }
    public bool UseAutoFormatting { get; public set; }
    public bool GridDropZones { get; public set; }
    public int Indent { get; public set; }
    public bool OutlineData { get; public set; }
    public bool Outline { get; public set; }
    public bool MultipleFieldFilters { get; public set; }
    public bool Compact { get; public set; }
    public bool CompactData { get; public set; }
    public string GrandTotalCaption { get; public set; }
    public string RowHeaderCaption { get; public set; }
    public string MissingCaption { get; public set; }
    public int FirstHeaderRow { get; public set; }
    public int FirstDataRow { get; public set; }
    public int FirstDataCol { get; public set; }
    public ExcelPivotTableFieldCollection Fields { get; }
    public ExcelPivotTableRowColumnFieldCollection RowFields { get; }
    public ExcelPivotTableRowColumnFieldCollection ColumnFields { get; }
    public ExcelPivotTableDataFieldCollection DataFields { get; }
    public ExcelPivotTableRowColumnFieldCollection PageFields { get; }
    public string StyleName { get; public set; }
    public TableStyles TableStyle { get; public set; }
    internal int CacheID { get; internal set; }
    internal ExcelPivotTable(ZipPackageRelationship rel, ExcelWorksheet sheet);
    internal ExcelPivotTable(ExcelWorksheet sheet, ExcelAddressBase address, ExcelRangeBase sourceAddress, string name, int tblId);
    private void init();
    private void LoadFields();
    private string GetStartXml(string name, int id, ExcelAddressBase address, ExcelAddressBase sourceAddress);
    [CompilerGeneratedAttribute]
internal ZipPackagePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(ZipPackagePart value);
    [CompilerGeneratedAttribute]
public XmlDocument get_PivotTableXml();
    [CompilerGeneratedAttribute]
private void set_PivotTableXml(XmlDocument value);
    [CompilerGeneratedAttribute]
public Uri get_PivotTableUri();
    [CompilerGeneratedAttribute]
internal void set_PivotTableUri(Uri value);
    [CompilerGeneratedAttribute]
internal ZipPackageRelationship get_Relationship();
    [CompilerGeneratedAttribute]
internal void set_Relationship(ZipPackageRelationship value);
    public string get_Name();
    public void set_Name(string value);
    public ExcelPivotCacheDefinition get_CacheDefinition();
    private string cleanDisplayName(string name);
    [CompilerGeneratedAttribute]
public ExcelWorksheet get_WorkSheet();
    [CompilerGeneratedAttribute]
public void set_WorkSheet(ExcelWorksheet value);
    [CompilerGeneratedAttribute]
public ExcelAddressBase get_Address();
    [CompilerGeneratedAttribute]
internal void set_Address(ExcelAddressBase value);
    public bool get_DataOnRows();
    public void set_DataOnRows(bool value);
    public bool get_ApplyNumberFormats();
    public void set_ApplyNumberFormats(bool value);
    public bool get_ApplyBorderFormats();
    public void set_ApplyBorderFormats(bool value);
    public bool get_ApplyFontFormats();
    public void set_ApplyFontFormats(bool value);
    public bool get_ApplyPatternFormats();
    public void set_ApplyPatternFormats(bool value);
    public bool get_ApplyWidthHeightFormats();
    public void set_ApplyWidthHeightFormats(bool value);
    public bool get_ShowMemberPropertyTips();
    public void set_ShowMemberPropertyTips(bool value);
    public bool get_ShowCalcMember();
    public void set_ShowCalcMember(bool value);
    public bool get_EnableDrill();
    public void set_EnableDrill(bool value);
    public bool get_ShowDrill();
    public void set_ShowDrill(bool value);
    public bool get_ShowDataTips();
    public void set_ShowDataTips(bool value);
    public bool get_FieldPrintTitles();
    public void set_FieldPrintTitles(bool value);
    public bool get_ItemPrintTitles();
    public void set_ItemPrintTitles(bool value);
    public bool get_ColumGrandTotals();
    public void set_ColumGrandTotals(bool value);
    public bool get_RowGrandTotals();
    public void set_RowGrandTotals(bool value);
    public bool get_PrintDrill();
    public void set_PrintDrill(bool value);
    public bool get_ShowError();
    public void set_ShowError(bool value);
    public string get_ErrorCaption();
    public void set_ErrorCaption(string value);
    public string get_DataCaption();
    public void set_DataCaption(string value);
    public bool get_ShowHeaders();
    public void set_ShowHeaders(bool value);
    public int get_PageWrap();
    public void set_PageWrap(int value);
    public bool get_UseAutoFormatting();
    public void set_UseAutoFormatting(bool value);
    public bool get_GridDropZones();
    public void set_GridDropZones(bool value);
    public int get_Indent();
    public void set_Indent(int value);
    public bool get_OutlineData();
    public void set_OutlineData(bool value);
    public bool get_Outline();
    public void set_Outline(bool value);
    public bool get_MultipleFieldFilters();
    public void set_MultipleFieldFilters(bool value);
    public bool get_Compact();
    public void set_Compact(bool value);
    public bool get_CompactData();
    public void set_CompactData(bool value);
    public string get_GrandTotalCaption();
    public void set_GrandTotalCaption(string value);
    public string get_RowHeaderCaption();
    public void set_RowHeaderCaption(string value);
    public string get_MissingCaption();
    public void set_MissingCaption(string value);
    public int get_FirstHeaderRow();
    public void set_FirstHeaderRow(int value);
    public int get_FirstDataRow();
    public void set_FirstDataRow(int value);
    public int get_FirstDataCol();
    public void set_FirstDataCol(int value);
    public ExcelPivotTableFieldCollection get_Fields();
    public ExcelPivotTableRowColumnFieldCollection get_RowFields();
    public ExcelPivotTableRowColumnFieldCollection get_ColumnFields();
    public ExcelPivotTableDataFieldCollection get_DataFields();
    public ExcelPivotTableRowColumnFieldCollection get_PageFields();
    public string get_StyleName();
    public void set_StyleName(string value);
    public TableStyles get_TableStyle();
    public void set_TableStyle(TableStyles value);
    internal int get_CacheID();
    internal void set_CacheID(int value);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableCollection : object {
    private List`1<ExcelPivotTable> _pivotTables;
    internal Dictionary`2<string, int> _pivotTableNames;
    private ExcelWorksheet _ws;
    public int Count { get; }
    public ExcelPivotTable Item { get; }
    public ExcelPivotTable Item { get; }
    internal ExcelPivotTableCollection(ExcelWorksheet ws);
    private ExcelPivotTable Add(ExcelPivotTable tbl);
    public ExcelPivotTable Add(ExcelAddressBase Range, ExcelRangeBase Source, string Name);
    internal string GetNewTableName();
    public int get_Count();
    public ExcelPivotTable get_Item(int Index);
    public ExcelPivotTable get_Item(string Name);
    public sealed virtual IEnumerator`1<ExcelPivotTable> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableDataField : XmlHelper {
    [CompilerGeneratedAttribute]
private ExcelPivotTableField <Field>k__BackingField;
    public ExcelPivotTableField Field { get; private set; }
    public int Index { get; internal set; }
    public string Name { get; public set; }
    public int BaseField { get; public set; }
    public int BaseItem { get; public set; }
    internal int NumFmtId { get; internal set; }
    public string Format { get; public set; }
    public DataFieldFunctions Function { get; public set; }
    internal ExcelPivotTableDataField(XmlNamespaceManager ns, XmlNode topNode, ExcelPivotTableField field);
    [CompilerGeneratedAttribute]
public ExcelPivotTableField get_Field();
    [CompilerGeneratedAttribute]
private void set_Field(ExcelPivotTableField value);
    public int get_Index();
    internal void set_Index(int value);
    public string get_Name();
    public void set_Name(string value);
    public int get_BaseField();
    public void set_BaseField(int value);
    public int get_BaseItem();
    public void set_BaseItem(int value);
    internal int get_NumFmtId();
    internal void set_NumFmtId(int value);
    public string get_Format();
    public void set_Format(string value);
    public DataFieldFunctions get_Function();
    public void set_Function(DataFieldFunctions value);
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableDataFieldCollection : ExcelPivotTableFieldCollectionBase`1<ExcelPivotTableDataField> {
    internal ExcelPivotTableDataFieldCollection(ExcelPivotTable table);
    public ExcelPivotTableDataField Add(ExcelPivotTableField field);
    private void ValidateDupName(ExcelPivotTableDataField dataField);
    internal bool ExistsDfName(string name, ExcelPivotTableDataField datafield);
    public void Remove(ExcelPivotTableDataField dataField);
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableField : XmlHelper {
    internal ExcelPivotTable _table;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BaseIndex>k__BackingField;
    internal ExcelPivotTablePageFieldSettings _pageFieldSettings;
    [CompilerGeneratedAttribute]
private eDateGroupBy <DateGrouping>k__BackingField;
    private ExcelPivotTableFieldGroup _grouping;
    internal XmlHelperInstance _cacheFieldHelper;
    internal ExcelPivotTableFieldCollectionBase`1<ExcelPivotTableFieldItem> _items;
    public int Index { get; public set; }
    internal int BaseIndex { get; internal set; }
    public string Name { get; public set; }
    public bool Compact { get; public set; }
    public bool Outline { get; public set; }
    public bool SubtotalTop { get; public set; }
    public bool ShowAll { get; public set; }
    public eSortType Sort { get; public set; }
    public bool IncludeNewItemsInFilter { get; public set; }
    public eSubTotalFunctions SubTotalFunctions { get; public set; }
    public ePivotFieldAxis Axis { get; internal set; }
    public bool IsRowField { get; internal set; }
    public bool IsColumnField { get; internal set; }
    public bool IsDataField { get; }
    public bool IsPageField { get; internal set; }
    public ExcelPivotTablePageFieldSettings PageFieldSettings { get; }
    internal eDateGroupBy DateGrouping { get; internal set; }
    public ExcelPivotTableFieldGroup Grouping { get; }
    public ExcelPivotTableFieldCollectionBase`1<ExcelPivotTableFieldItem> Items { get; }
    internal ExcelPivotTableField(XmlNamespaceManager ns, XmlNode topNode, ExcelPivotTable table, int index, int baseIndex);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
internal int get_BaseIndex();
    [CompilerGeneratedAttribute]
internal void set_BaseIndex(int value);
    public string get_Name();
    public void set_Name(string value);
    public bool get_Compact();
    public void set_Compact(bool value);
    public bool get_Outline();
    public void set_Outline(bool value);
    public bool get_SubtotalTop();
    public void set_SubtotalTop(bool value);
    public bool get_ShowAll();
    public void set_ShowAll(bool value);
    public eSortType get_Sort();
    public void set_Sort(eSortType value);
    public bool get_IncludeNewItemsInFilter();
    public void set_IncludeNewItemsInFilter(bool value);
    public eSubTotalFunctions get_SubTotalFunctions();
    public void set_SubTotalFunctions(eSubTotalFunctions value);
    public ePivotFieldAxis get_Axis();
    internal void set_Axis(ePivotFieldAxis value);
    public bool get_IsRowField();
    internal void set_IsRowField(bool value);
    public bool get_IsColumnField();
    internal void set_IsColumnField(bool value);
    public bool get_IsDataField();
    public bool get_IsPageField();
    internal void set_IsPageField(bool value);
    public ExcelPivotTablePageFieldSettings get_PageFieldSettings();
    [CompilerGeneratedAttribute]
internal eDateGroupBy get_DateGrouping();
    [CompilerGeneratedAttribute]
internal void set_DateGrouping(eDateGroupBy value);
    public ExcelPivotTableFieldGroup get_Grouping();
    internal XmlElement AppendField(XmlNode rowsNode, int index, string fieldNodeText, string indexAttrText);
    internal void SetCacheFieldNode(XmlNode cacheField);
    internal ExcelPivotTableFieldDateGroup SetDateGroup(eDateGroupBy GroupBy, DateTime StartDate, DateTime EndDate, int interval);
    internal ExcelPivotTableFieldNumericGroup SetNumericGroup(double start, double end, double interval);
    private int AddNumericGroupItems(ExcelPivotTableFieldNumericGroup group, double start, double end, double interval);
    private void AddFieldItems(int items);
    private int AddDateGroupItems(ExcelPivotTableFieldGroup group, eDateGroupBy GroupBy, DateTime StartDate, DateTime EndDate, int interval);
    private void AddTimeSerie(int count, XmlElement groupItems);
    private void AddGroupItem(XmlElement groupItems, string value);
    public ExcelPivotTableFieldCollectionBase`1<ExcelPivotTableFieldItem> get_Items();
    public void AddNumericGrouping(double Start, double End, double Interval);
    public void AddDateGrouping(eDateGroupBy groupBy);
    public void AddDateGrouping(eDateGroupBy groupBy, DateTime startDate, DateTime endDate);
    public void AddDateGrouping(int days, DateTime startDate, DateTime endDate);
    private void AddDateGrouping(eDateGroupBy groupBy, DateTime startDate, DateTime endDate, int groupInterval);
    private void ValidateGrouping();
    private ExcelPivotTableField AddField(eDateGroupBy groupBy, DateTime startDate, DateTime endDate, Boolean& firstField);
    private ExcelPivotTableField AddField(eDateGroupBy groupBy, DateTime startDate, DateTime endDate, Boolean& firstField, int interval);
    private void AddCacheField(ExcelPivotTableField field, DateTime startDate, DateTime endDate, int interval);
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableFieldCollection : ExcelPivotTableFieldCollectionBase`1<ExcelPivotTableField> {
    public ExcelPivotTableField Item { get; }
    internal ExcelPivotTableFieldCollection(ExcelPivotTable table, string topNode);
    public ExcelPivotTableField get_Item(string name);
    public ExcelPivotTableField GetDateGroupField(eDateGroupBy GroupBy);
    public ExcelPivotTableField GetNumericGroupField();
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableFieldCollectionBase`1 : object {
    protected ExcelPivotTable _table;
    internal List`1<T> _list;
    public int Count { get; }
    public T Item { get; }
    internal ExcelPivotTableFieldCollectionBase`1(ExcelPivotTable table);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int get_Count();
    internal void AddInternal(T field);
    internal void Clear();
    public T get_Item(int Index);
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableFieldDateGroup : ExcelPivotTableFieldGroup {
    private static string groupByPath;
    public eDateGroupBy GroupBy { get; private set; }
    public bool AutoStart { get; }
    public bool AutoEnd { get; }
    internal ExcelPivotTableFieldDateGroup(XmlNamespaceManager ns, XmlNode topNode);
    public eDateGroupBy get_GroupBy();
    private void set_GroupBy(eDateGroupBy value);
    public bool get_AutoStart();
    public bool get_AutoEnd();
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableFieldGroup : XmlHelper {
    internal ExcelPivotTableFieldGroup(XmlNamespaceManager ns, XmlNode topNode);
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableFieldItem : XmlHelper {
    private ExcelPivotTableField _field;
    public string Text { get; public set; }
    internal int X { get; }
    internal string T { get; }
    internal ExcelPivotTableFieldItem(XmlNamespaceManager ns, XmlNode topNode, ExcelPivotTableField field);
    public string get_Text();
    public void set_Text(string value);
    internal int get_X();
    internal string get_T();
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableFieldNumericGroup : ExcelPivotTableFieldGroup {
    private static string startPath;
    private static string endPath;
    private static string groupIntervalPath;
    public double Start { get; private set; }
    public double End { get; private set; }
    public double Interval { get; private set; }
    internal ExcelPivotTableFieldNumericGroup(XmlNamespaceManager ns, XmlNode topNode);
    public double get_Start();
    private void set_Start(double value);
    public double get_End();
    private void set_End(double value);
    public double get_Interval();
    private void set_Interval(double value);
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTablePageFieldSettings : XmlHelper {
    private ExcelPivotTableField _field;
    internal int Index { get; internal set; }
    public string Name { get; public set; }
    internal int NumFmtId { get; internal set; }
    internal int Hier { get; internal set; }
    internal ExcelPivotTablePageFieldSettings(XmlNamespaceManager ns, XmlNode topNode, ExcelPivotTableField field, int index);
    internal int get_Index();
    internal void set_Index(int value);
    public string get_Name();
    public void set_Name(string value);
    internal int get_NumFmtId();
    internal void set_NumFmtId(int value);
    internal int get_Hier();
    internal void set_Hier(int value);
}
public class OfficeOpenXml.Table.PivotTable.ExcelPivotTableRowColumnFieldCollection : ExcelPivotTableFieldCollectionBase`1<ExcelPivotTableField> {
    internal string _topNode;
    internal ExcelPivotTableRowColumnFieldCollection(ExcelPivotTable table, string topNode);
    public ExcelPivotTableField Add(ExcelPivotTableField Field);
    internal ExcelPivotTableField Insert(ExcelPivotTableField Field, int Index);
    private void SetFlag(ExcelPivotTableField field, bool value);
    public void Remove(ExcelPivotTableField Field);
    public void RemoveAt(int Index);
}
public enum OfficeOpenXml.Table.RowFunctions : Enum {
    public int value__;
    public static RowFunctions Average;
    public static RowFunctions Count;
    public static RowFunctions CountNums;
    public static RowFunctions Custom;
    public static RowFunctions Max;
    public static RowFunctions Min;
    public static RowFunctions None;
    public static RowFunctions StdDev;
    public static RowFunctions Sum;
    public static RowFunctions Var;
}
public enum OfficeOpenXml.Table.TableStyles : Enum {
    public int value__;
    public static TableStyles None;
    public static TableStyles Custom;
    public static TableStyles Light1;
    public static TableStyles Light2;
    public static TableStyles Light3;
    public static TableStyles Light4;
    public static TableStyles Light5;
    public static TableStyles Light6;
    public static TableStyles Light7;
    public static TableStyles Light8;
    public static TableStyles Light9;
    public static TableStyles Light10;
    public static TableStyles Light11;
    public static TableStyles Light12;
    public static TableStyles Light13;
    public static TableStyles Light14;
    public static TableStyles Light15;
    public static TableStyles Light16;
    public static TableStyles Light17;
    public static TableStyles Light18;
    public static TableStyles Light19;
    public static TableStyles Light20;
    public static TableStyles Light21;
    public static TableStyles Medium1;
    public static TableStyles Medium2;
    public static TableStyles Medium3;
    public static TableStyles Medium4;
    public static TableStyles Medium5;
    public static TableStyles Medium6;
    public static TableStyles Medium7;
    public static TableStyles Medium8;
    public static TableStyles Medium9;
    public static TableStyles Medium10;
    public static TableStyles Medium11;
    public static TableStyles Medium12;
    public static TableStyles Medium13;
    public static TableStyles Medium14;
    public static TableStyles Medium15;
    public static TableStyles Medium16;
    public static TableStyles Medium17;
    public static TableStyles Medium18;
    public static TableStyles Medium19;
    public static TableStyles Medium20;
    public static TableStyles Medium21;
    public static TableStyles Medium22;
    public static TableStyles Medium23;
    public static TableStyles Medium24;
    public static TableStyles Medium25;
    public static TableStyles Medium26;
    public static TableStyles Medium27;
    public static TableStyles Medium28;
    public static TableStyles Dark1;
    public static TableStyles Dark2;
    public static TableStyles Dark3;
    public static TableStyles Dark4;
    public static TableStyles Dark5;
    public static TableStyles Dark6;
    public static TableStyles Dark7;
    public static TableStyles Dark8;
    public static TableStyles Dark9;
    public static TableStyles Dark10;
    public static TableStyles Dark11;
}
public static class OfficeOpenXml.Utils.AddressUtility : object {
    public static string ParseEntireColumnSelections(string address);
    private static void AddRowNumbersToEntireColumnRange(String& address, string range);
}
internal class OfficeOpenXml.Utils.Argument`1 : object {
    private T _value;
    private T OfficeOpenXml.Utils.IArgument<T>.Value { get; }
    public Argument`1(T value);
    private sealed virtual override T OfficeOpenXml.Utils.IArgument<T>.get_Value();
}
[ExtensionAttribute]
public static class OfficeOpenXml.Utils.ArgumentExtensions : object {
    [ExtensionAttribute]
public static void IsNotNull(IArgument`1<T> argument, string argumentName);
    [ExtensionAttribute]
public static void IsNotNullOrEmpty(IArgument`1<string> argument, string argumentName);
    [ExtensionAttribute]
public static void IsInRange(IArgument`1<T> argument, T min, T max, string argumentName);
}
internal class OfficeOpenXml.Utils.CompoundDocument : object {
    internal StoragePart Storage;
    internal CompoundDocument(FileInfo fi);
    internal CompoundDocument(ILockBytes lb);
    internal CompoundDocument(Byte[] doc);
    internal void Read(FileInfo fi);
    [SecuritySafeCriticalAttribute]
internal void Read(Byte[] doc);
    [SecuritySafeCriticalAttribute]
internal void Read(ILockBytes lb);
    internal static Byte[] CompressPart(Byte[] part);
    private static Byte[] CompressChunk(Byte[] buffer, Int32& startPos);
    internal static Byte[] DecompressPart(Byte[] part);
    internal static Byte[] DecompressPart(Byte[] part, int startPos);
    private static void DecompressChunk(MemoryStream ms, Byte[] compBuffer, Int32& pos);
    private static int GetLengthBits(int decompPos);
    private static int StgIsStorageFile(string pwcsName);
    private static int StgIsStorageILockBytes(ILockBytes plkbyt);
    private static int StgOpenStorage(string pwcsName, IStorage pstgPriority, STGM grfMode, IntPtr snbExclude, UInt32 reserved, IStorage& ppstgOpen);
    private static int StgOpenStorageOnILockBytes(ILockBytes plkbyt, IStorage pStgPriority, STGM grfMode, IntPtr snbEnclude, UInt32 reserved, IStorage& ppstgOpen);
    private static int CreateILockBytesOnHGlobal(IntPtr hGlobal, bool fDeleteOnRelease, ILockBytes& ppLkbyt);
    private static int StgCreateDocfileOnILockBytes(ILockBytes plkbyt, STGM grfMode, int reserved, IStorage& ppstgOpen);
    [SecuritySafeCriticalAttribute]
internal static int IsStorageFile(string Name);
    [SecuritySafeCriticalAttribute]
internal static int IsStorageILockBytes(ILockBytes lb);
    [SecuritySafeCriticalAttribute]
internal static ILockBytes GetLockbyte(MemoryStream stream);
    [SecuritySafeCriticalAttribute]
private MemoryStream ReadParts(IStorage storage, StoragePart storagePart);
    [SecuritySafeCriticalAttribute]
private Byte[] GetOleStream(IStorage storage, STATSTG statstg);
    [SecuritySafeCriticalAttribute]
internal Byte[] Save();
    private void CreateStore(string name, StoragePart subStore, IStorage storage);
    private void CreateStreams(StoragePart subStore, IStorage subStorage);
}
internal static class OfficeOpenXml.Utils.ConvertUtil : object {
    internal static TextInfo _invariantTextInfo;
    internal static CompareInfo _invariantCompareInfo;
    private static ConvertUtil();
    internal static bool IsNumeric(object candidate);
    internal static bool TryParseNumericString(object candidate, Double& result);
    internal static bool TryParseBooleanString(object candidate, Boolean& result);
    internal static bool TryParseDateString(object candidate, DateTime& result);
    internal static double GetValueDouble(object v, bool ignoreBool, bool retNaN);
    internal static string ExcelEscapeString(string s);
    internal static void ExcelEncodeString(StreamWriter sw, string t);
    internal static void ExcelEncodeString(StringBuilder sb, string t, bool encodeTabCRLF);
    internal static string ExcelEncodeString(string t);
    internal static string ExcelDecodeString(string t);
    public static T GetTypedCellValue(object value);
}
public interface OfficeOpenXml.Utils.IArgument`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[GuidAttribute("0000000d-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface OfficeOpenXml.Utils.IEnumSTATSTG {
    public abstract virtual UInt32 Next(UInt32 celt, STATSTG[] rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual IEnumSTATSTG Clone();
}
[ComVisibleAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000A-0000-0000-C000-000000000046")]
internal interface OfficeOpenXml.Utils.ILockBytes {
    public abstract virtual void ReadAt(long ulOffset, IntPtr pv, int cb, UIntPtr& pcbRead);
    public abstract virtual void WriteAt(long ulOffset, IntPtr pv, int cb, UIntPtr& pcbWritten);
    public abstract virtual void Flush();
    public abstract virtual void SetSize(long cb);
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
}
[GuidAttribute("0000000b-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface OfficeOpenXml.Utils.IStorage {
    public abstract virtual void CreateStream(string pwcsName, UInt32 grfMode, UInt32 reserved1, UInt32 reserved2, IStream& ppstm);
    public abstract virtual void OpenStream(string pwcsName, IntPtr reserved1, UInt32 grfMode, UInt32 reserved2, IStream& ppstm);
    public abstract virtual void CreateStorage(string pwcsName, UInt32 grfMode, UInt32 reserved1, UInt32 reserved2, IStorage& ppstg);
    public abstract virtual void OpenStorage(string pwcsName, IStorage pstgPriority, UInt32 grfMode, IntPtr snbExclude, UInt32 reserved, IStorage& ppstg);
    public abstract virtual void CopyTo(UInt32 ciidExclude, Guid[] rgiidExclude, IntPtr snbExclude, IStorage pstgDest);
    public abstract virtual void MoveElementTo(string pwcsName, IStorage pstgDest, string pwcsNewName, UInt32 grfFlags);
    public abstract virtual void Commit(UInt32 grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void EnumElements(UInt32 reserved1, IntPtr reserved2, UInt32 reserved3, IEnumSTATSTG& ppenum);
    public abstract virtual void DestroyElement(string pwcsName);
    public abstract virtual void RenameElement(string pwcsOldName, string pwcsNewName);
    public abstract virtual void SetElementTimes(string pwcsName, FILETIME pctime, FILETIME patime, FILETIME pmtime);
    public abstract virtual void SetClass(Guid clsid);
    public abstract virtual void SetStateBits(UInt32 grfStateBits, UInt32 grfMask);
    public abstract virtual void Stat(STATSTG& pstatstg, UInt32 grfStatFlag);
}
public interface OfficeOpenXml.Utils.IValidationResult {
    public abstract virtual void IsTrue();
    public abstract virtual void IsFalse();
}
public static class OfficeOpenXml.Utils.Require : object {
    public static IArgument`1<T> Argument(T argument);
}
public static class OfficeOpenXml.Utils.SqRefUtility : object {
    public static string ToSqRefAddress(string address);
    public static string FromSqRefAddress(string address);
}
internal enum OfficeOpenXml.Utils.STATFLAG : Enum {
    public UInt32 value__;
    public static STATFLAG STATFLAG_DEFAULT;
    public static STATFLAG STATFLAG_NONAME;
    public static STATFLAG STATFLAG_NOOPEN;
}
[FlagsAttribute]
internal enum OfficeOpenXml.Utils.STGM : Enum {
    public int value__;
    public static STGM DIRECT;
    public static STGM TRANSACTED;
    public static STGM SIMPLE;
    public static STGM READ;
    public static STGM WRITE;
    public static STGM READWRITE;
    public static STGM SHARE_DENY_NONE;
    public static STGM SHARE_DENY_READ;
    public static STGM SHARE_DENY_WRITE;
    public static STGM SHARE_EXCLUSIVE;
    public static STGM PRIORITY;
    public static STGM DELETEONRELEASE;
    public static STGM NOSCRATCH;
    public static STGM CREATE;
    public static STGM CONVERT;
    public static STGM FAILIFTHERE;
    public static STGM NOSNAPSHOT;
    public static STGM DIRECT_SWMR;
}
internal enum OfficeOpenXml.Utils.STGTY : Enum {
    public int value__;
    public static STGTY STGTY_STORAGE;
    public static STGTY STGTY_STREAM;
    public static STGTY STGTY_LOCKBYTES;
    public static STGTY STGTY_PROPERTY;
}
internal class OfficeOpenXml.Utils.UriHelper : object {
    internal static Uri ResolvePartUri(Uri sourceUri, Uri targetUri);
    internal static Uri GetRelativeUri(Uri WorksheetUri, Uri uri);
}
public class OfficeOpenXml.Utils.ValidationResult : object {
    private bool _result;
    private string _errorMessage;
    public ValidationResult(bool result);
    public ValidationResult(bool result, string errorMessage);
    private void Throw();
    private sealed virtual override void OfficeOpenXml.Utils.IValidationResult.IsTrue();
    private sealed virtual override void OfficeOpenXml.Utils.IValidationResult.IsFalse();
}
public enum OfficeOpenXml.VBA.eAttributeDataType : Enum {
    public int value__;
    public static eAttributeDataType String;
    public static eAttributeDataType NonString;
}
public enum OfficeOpenXml.VBA.eModuleType : Enum {
    public int value__;
    public static eModuleType Document;
    public static eModuleType Module;
    public static eModuleType Class;
    public static eModuleType Designer;
}
[DefaultMemberAttribute("Item")]
public class OfficeOpenXml.VBA.ExcelVBACollectionBase`1 : object {
    protected internal List`1<T> _list;
    public T Item { get; }
    public T Item { get; }
    public int Count { get; }
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T get_Item(string Name);
    public T get_Item(int Index);
    public int get_Count();
    public bool Exists(string Name);
    public void Remove(T Item);
    public void RemoveAt(int index);
    internal void Clear();
}
public class OfficeOpenXml.VBA.ExcelVBAModule : object {
    private string _name;
    private ModuleNameChange _nameChangeCallback;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    private string _code;
    [CompilerGeneratedAttribute]
private int <HelpContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelVbaModuleAttributesCollection <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private eModuleType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Private>k__BackingField;
    [CompilerGeneratedAttribute]
private string <streamName>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Cookie>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClassID>k__BackingField;
    public string Name { get; public set; }
    public string Description { get; public set; }
    public string Code { get; public set; }
    public int HelpContext { get; public set; }
    public ExcelVbaModuleAttributesCollection Attributes { get; internal set; }
    public eModuleType Type { get; internal set; }
    public bool ReadOnly { get; public set; }
    public bool Private { get; public set; }
    internal string streamName { get; internal set; }
    internal ushort Cookie { get; internal set; }
    internal UInt32 ModuleOffset { get; internal set; }
    internal string ClassID { get; internal set; }
    internal ExcelVBAModule(ModuleNameChange nameChangeCallback);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public string get_Code();
    public void set_Code(string value);
    [CompilerGeneratedAttribute]
public int get_HelpContext();
    [CompilerGeneratedAttribute]
public void set_HelpContext(int value);
    [CompilerGeneratedAttribute]
public ExcelVbaModuleAttributesCollection get_Attributes();
    [CompilerGeneratedAttribute]
internal void set_Attributes(ExcelVbaModuleAttributesCollection value);
    [CompilerGeneratedAttribute]
public eModuleType get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(eModuleType value);
    [CompilerGeneratedAttribute]
public bool get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_Private();
    [CompilerGeneratedAttribute]
public void set_Private(bool value);
    [CompilerGeneratedAttribute]
internal string get_streamName();
    [CompilerGeneratedAttribute]
internal void set_streamName(string value);
    [CompilerGeneratedAttribute]
internal ushort get_Cookie();
    [CompilerGeneratedAttribute]
internal void set_Cookie(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ModuleOffset();
    [CompilerGeneratedAttribute]
internal void set_ModuleOffset(UInt32 value);
    [CompilerGeneratedAttribute]
internal string get_ClassID();
    [CompilerGeneratedAttribute]
internal void set_ClassID(string value);
    public virtual string ToString();
}
public class OfficeOpenXml.VBA.ExcelVbaModuleAttribute : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private eAttributeDataType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; internal set; }
    public eAttributeDataType DataType { get; internal set; }
    public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public eAttributeDataType get_DataType();
    [CompilerGeneratedAttribute]
internal void set_DataType(eAttributeDataType value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public virtual string ToString();
}
public class OfficeOpenXml.VBA.ExcelVbaModuleAttributesCollection : ExcelVBACollectionBase`1<ExcelVbaModuleAttribute> {
    internal string GetAttributeText();
}
public class OfficeOpenXml.VBA.ExcelVbaModuleCollection : ExcelVBACollectionBase`1<ExcelVBAModule> {
    private ExcelVbaProject _project;
    internal ExcelVbaModuleCollection(ExcelVbaProject project);
    internal void Add(ExcelVBAModule Item);
    public ExcelVBAModule AddModule(string Name);
    public ExcelVBAModule AddClass(string Name, bool Exposed);
}
public class OfficeOpenXml.VBA.ExcelVbaProject : object {
    private static string schemaRelVba;
    internal static string PartUri;
    internal ExcelWorkbook _wb;
    internal ZipPackage _pck;
    [CompilerGeneratedAttribute]
private eSyskind <SystemKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFile1>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFile2>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HelpContextID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constants>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LibFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Lcid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LcidInvoke>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectStreamText>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelVbaReferenceCollection <References>k__BackingField;
    [CompilerGeneratedAttribute]
private ExcelVbaModuleCollection <Modules>k__BackingField;
    private ExcelVbaSignature _signature;
    private ExcelVbaProtection _protection;
    [CompilerGeneratedAttribute]
private CompoundDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackagePart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    public eSyskind SystemKind { get; public set; }
    public string Name { get; public set; }
    public string Description { get; public set; }
    public string HelpFile1 { get; public set; }
    public string HelpFile2 { get; public set; }
    public int HelpContextID { get; public set; }
    public string Constants { get; public set; }
    public int CodePage { get; internal set; }
    internal int LibFlags { get; internal set; }
    internal int MajorVersion { get; internal set; }
    internal int MinorVersion { get; internal set; }
    internal int Lcid { get; internal set; }
    internal int LcidInvoke { get; internal set; }
    internal string ProjectID { get; internal set; }
    internal string ProjectStreamText { get; internal set; }
    public ExcelVbaReferenceCollection References { get; public set; }
    public ExcelVbaModuleCollection Modules { get; public set; }
    public ExcelVbaSignature Signature { get; }
    public ExcelVbaProtection Protection { get; }
    internal CompoundDocument Document { get; internal set; }
    internal ZipPackagePart Part { get; internal set; }
    internal Uri Uri { get; private set; }
    internal ExcelVbaProject(ExcelWorkbook wb);
    [CompilerGeneratedAttribute]
public eSyskind get_SystemKind();
    [CompilerGeneratedAttribute]
public void set_SystemKind(eSyskind value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_HelpFile1();
    [CompilerGeneratedAttribute]
public void set_HelpFile1(string value);
    [CompilerGeneratedAttribute]
public string get_HelpFile2();
    [CompilerGeneratedAttribute]
public void set_HelpFile2(string value);
    [CompilerGeneratedAttribute]
public int get_HelpContextID();
    [CompilerGeneratedAttribute]
public void set_HelpContextID(int value);
    [CompilerGeneratedAttribute]
public string get_Constants();
    [CompilerGeneratedAttribute]
public void set_Constants(string value);
    [CompilerGeneratedAttribute]
public int get_CodePage();
    [CompilerGeneratedAttribute]
internal void set_CodePage(int value);
    [CompilerGeneratedAttribute]
internal int get_LibFlags();
    [CompilerGeneratedAttribute]
internal void set_LibFlags(int value);
    [CompilerGeneratedAttribute]
internal int get_MajorVersion();
    [CompilerGeneratedAttribute]
internal void set_MajorVersion(int value);
    [CompilerGeneratedAttribute]
internal int get_MinorVersion();
    [CompilerGeneratedAttribute]
internal void set_MinorVersion(int value);
    [CompilerGeneratedAttribute]
internal int get_Lcid();
    [CompilerGeneratedAttribute]
internal void set_Lcid(int value);
    [CompilerGeneratedAttribute]
internal int get_LcidInvoke();
    [CompilerGeneratedAttribute]
internal void set_LcidInvoke(int value);
    [CompilerGeneratedAttribute]
internal string get_ProjectID();
    [CompilerGeneratedAttribute]
internal void set_ProjectID(string value);
    [CompilerGeneratedAttribute]
internal string get_ProjectStreamText();
    [CompilerGeneratedAttribute]
internal void set_ProjectStreamText(string value);
    [CompilerGeneratedAttribute]
public ExcelVbaReferenceCollection get_References();
    [CompilerGeneratedAttribute]
public void set_References(ExcelVbaReferenceCollection value);
    [CompilerGeneratedAttribute]
public ExcelVbaModuleCollection get_Modules();
    [CompilerGeneratedAttribute]
public void set_Modules(ExcelVbaModuleCollection value);
    public ExcelVbaSignature get_Signature();
    public ExcelVbaProtection get_Protection();
    private void GetProject();
    private void ReadModules();
    private void ReadProjectProperties();
    private Byte[] Decrypt(string value);
    private string Encrypt(Byte[] value);
    private string GetString(Byte[] value, int max);
    private Byte[] GetByte(string value);
    private void ReadDirStream();
    internal void Save();
    private bool Validate();
    private Byte[] CreateVBAProjectStream();
    private Byte[] CreateDirStream();
    private void WriteModuleRecord(BinaryWriter bw, ExcelVBAModule module);
    private void WriteNameReference(BinaryWriter bw, ExcelVbaReference reference);
    private void WriteControlReference(BinaryWriter bw, ExcelVbaReference reference);
    private void WriteOrginalReference(BinaryWriter bw, ExcelVbaReference reference);
    private void WriteProjectReference(BinaryWriter bw, ExcelVbaReference reference);
    private void WriteRegisteredReference(BinaryWriter bw, ExcelVbaReference reference);
    private Byte[] CreateProjectwmStream();
    private Byte[] CreateProjectStream();
    private string WriteProtectionStat();
    private string WritePassword();
    private string WriteVisibilityState();
    private string GetString(BinaryReader br, UInt32 size);
    private string GetString(BinaryReader br, UInt32 size, Encoding enc);
    private string GetUnicodeString(BinaryReader br, UInt32 size);
    [CompilerGeneratedAttribute]
internal CompoundDocument get_Document();
    [CompilerGeneratedAttribute]
internal void set_Document(CompoundDocument value);
    [CompilerGeneratedAttribute]
internal ZipPackagePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(ZipPackagePart value);
    [CompilerGeneratedAttribute]
internal Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
    internal void Create();
    internal string GetModuleNameFromWorksheet(ExcelWorksheet sheet);
    internal ExcelVbaModuleAttributesCollection GetDocumentAttributes(string name, string clsid);
    public void Remove();
    public virtual string ToString();
}
public class OfficeOpenXml.VBA.ExcelVbaProtection : object {
    private ExcelVbaProject _project;
    [CompilerGeneratedAttribute]
private bool <UserProtected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HostProtected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VbeProtected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VisibilityState>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PasswordHash>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PasswordKey>k__BackingField;
    public bool UserProtected { get; internal set; }
    public bool HostProtected { get; internal set; }
    public bool VbeProtected { get; internal set; }
    public bool VisibilityState { get; internal set; }
    internal Byte[] PasswordHash { get; internal set; }
    internal Byte[] PasswordKey { get; internal set; }
    internal ExcelVbaProtection(ExcelVbaProject project);
    [CompilerGeneratedAttribute]
public bool get_UserProtected();
    [CompilerGeneratedAttribute]
internal void set_UserProtected(bool value);
    [CompilerGeneratedAttribute]
public bool get_HostProtected();
    [CompilerGeneratedAttribute]
internal void set_HostProtected(bool value);
    [CompilerGeneratedAttribute]
public bool get_VbeProtected();
    [CompilerGeneratedAttribute]
internal void set_VbeProtected(bool value);
    [CompilerGeneratedAttribute]
public bool get_VisibilityState();
    [CompilerGeneratedAttribute]
internal void set_VisibilityState(bool value);
    [CompilerGeneratedAttribute]
internal Byte[] get_PasswordHash();
    [CompilerGeneratedAttribute]
internal void set_PasswordHash(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_PasswordKey();
    [CompilerGeneratedAttribute]
internal void set_PasswordKey(Byte[] value);
    public void SetPassword(string Password);
}
public class OfficeOpenXml.VBA.ExcelVbaReference : object {
    [CompilerGeneratedAttribute]
private int <ReferenceRecordID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Libid>k__BackingField;
    public int ReferenceRecordID { get; internal set; }
    public string Name { get; public set; }
    public string Libid { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ReferenceRecordID();
    [CompilerGeneratedAttribute]
internal void set_ReferenceRecordID(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Libid();
    [CompilerGeneratedAttribute]
public void set_Libid(string value);
    public virtual string ToString();
}
public class OfficeOpenXml.VBA.ExcelVbaReferenceCollection : ExcelVBACollectionBase`1<ExcelVbaReference> {
    public void Add(ExcelVbaReference Item);
}
public class OfficeOpenXml.VBA.ExcelVbaReferenceControl : ExcelVbaReference {
    [CompilerGeneratedAttribute]
private string <LibIdExternal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibIdTwiddled>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <OriginalTypeLib>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Cookie>k__BackingField;
    public string LibIdExternal { get; public set; }
    public string LibIdTwiddled { get; public set; }
    public Guid OriginalTypeLib { get; public set; }
    internal UInt32 Cookie { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_LibIdExternal();
    [CompilerGeneratedAttribute]
public void set_LibIdExternal(string value);
    [CompilerGeneratedAttribute]
public string get_LibIdTwiddled();
    [CompilerGeneratedAttribute]
public void set_LibIdTwiddled(string value);
    [CompilerGeneratedAttribute]
public Guid get_OriginalTypeLib();
    [CompilerGeneratedAttribute]
public void set_OriginalTypeLib(Guid value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Cookie();
    [CompilerGeneratedAttribute]
internal void set_Cookie(UInt32 value);
}
public class OfficeOpenXml.VBA.ExcelVbaReferenceProject : ExcelVbaReference {
    [CompilerGeneratedAttribute]
private string <LibIdRelative>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinorVersion>k__BackingField;
    public string LibIdRelative { get; public set; }
    public UInt32 MajorVersion { get; public set; }
    public ushort MinorVersion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LibIdRelative();
    [CompilerGeneratedAttribute]
public void set_LibIdRelative(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_MajorVersion();
    [CompilerGeneratedAttribute]
public void set_MajorVersion(UInt32 value);
    [CompilerGeneratedAttribute]
public ushort get_MinorVersion();
    [CompilerGeneratedAttribute]
public void set_MinorVersion(ushort value);
}
public class OfficeOpenXml.VBA.ExcelVbaSignature : object {
    private static string schemaRelVbaSignature;
    private ZipPackagePart _vbaPart;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private SignedCms <Verifier>k__BackingField;
    [CompilerGeneratedAttribute]
private CompoundDocument <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipPackagePart <Part>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    public X509Certificate2 Certificate { get; public set; }
    public SignedCms Verifier { get; internal set; }
    internal CompoundDocument Signature { get; internal set; }
    internal ZipPackagePart Part { get; internal set; }
    internal Uri Uri { get; private set; }
    internal ExcelVbaSignature(ZipPackagePart vbaPart);
    private void GetSignature();
    internal void Save(ExcelVbaProject proj);
    private X509Certificate2 GetCertFromStore(StoreLocation loc);
    private Byte[] GetCertStore();
    private void WriteProp(BinaryWriter bw, int id, Byte[] data);
    internal Byte[] SignProject(ExcelVbaProject proj);
    private Byte[] GetContentHash(ExcelVbaProject proj);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public SignedCms get_Verifier();
    [CompilerGeneratedAttribute]
internal void set_Verifier(SignedCms value);
    [CompilerGeneratedAttribute]
internal CompoundDocument get_Signature();
    [CompilerGeneratedAttribute]
internal void set_Signature(CompoundDocument value);
    [CompilerGeneratedAttribute]
internal ZipPackagePart get_Part();
    [CompilerGeneratedAttribute]
internal void set_Part(ZipPackagePart value);
    [CompilerGeneratedAttribute]
internal Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
}
internal class OfficeOpenXml.VBA.ModuleNameChange : MulticastDelegate {
    public ModuleNameChange(object object, IntPtr method);
    public virtual void Invoke(string value);
    public virtual IAsyncResult BeginInvoke(string value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class OfficeOpenXml.XmlHelper : object {
    [CompilerGeneratedAttribute]
private XmlNamespaceManager <NameSpaceManager>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlNode <TopNode>k__BackingField;
    private String[] _schemaNodeOrder;
    internal XmlNamespaceManager NameSpaceManager { get; internal set; }
    internal XmlNode TopNode { get; internal set; }
    internal String[] SchemaNodeOrder { get; internal set; }
    internal XmlHelper(XmlNamespaceManager nameSpaceManager);
    internal XmlHelper(XmlNamespaceManager nameSpaceManager, XmlNode topNode);
    [CompilerGeneratedAttribute]
internal XmlNamespaceManager get_NameSpaceManager();
    [CompilerGeneratedAttribute]
internal void set_NameSpaceManager(XmlNamespaceManager value);
    [CompilerGeneratedAttribute]
internal XmlNode get_TopNode();
    [CompilerGeneratedAttribute]
internal void set_TopNode(XmlNode value);
    internal String[] get_SchemaNodeOrder();
    internal void set_SchemaNodeOrder(String[] value);
    internal XmlNode CreateNode(string path);
    internal XmlNode CreateNode(string path, bool insertFirst);
    internal XmlNode CreateComplexNode(string path);
    internal XmlNode CreateComplexNode(XmlNode topNode, string path);
    internal XmlNode CreateComplexNode(XmlNode topNode, string path, eNodeInsertOrder nodeInsertOrder, XmlNode referenceNode);
    private XmlNode GetPrependNode(string nodeName, XmlNode node);
    private int GetNodePos(string nodeName);
    internal void DeleteAllNode(string path);
    internal void DeleteNode(string path);
    internal void DeleteTopNode();
    internal void SetXmlNodeString(string path, string value);
    internal void SetXmlNodeString(string path, string value, bool removeIfBlank);
    internal void SetXmlNodeString(XmlNode node, string path, string value);
    internal void SetXmlNodeString(XmlNode node, string path, string value, bool removeIfBlank);
    internal void SetXmlNodeString(XmlNode node, string path, string value, bool removeIfBlank, bool insertFirst);
    internal void SetXmlNodeBool(string path, bool value);
    internal void SetXmlNodeBool(string path, bool value, bool removeIf);
    internal bool ExistNode(string path);
    internal Nullable`1<bool> GetXmlNodeBoolNullable(string path);
    internal bool GetXmlNodeBool(string path);
    internal bool GetXmlNodeBool(string path, bool blankValue);
    internal int GetXmlNodeInt(string path);
    internal Nullable`1<int> GetXmlNodeIntNull(string path);
    internal decimal GetXmlNodeDecimal(string path);
    internal Nullable`1<decimal> GetXmlNodeDecimalNull(string path);
    internal Nullable`1<double> GetXmlNodeDoubleNull(string path);
    internal double GetXmlNodeDouble(string path);
    internal string GetXmlNodeString(XmlNode node, string path);
    internal string GetXmlNodeString(string path);
    internal static Uri GetNewUri(ZipPackage package, string sUri);
    internal static Uri GetNewUri(ZipPackage package, string sUri, Int32& id);
    internal void InserAfter(XmlNode parentNode, string beforeNodes, XmlNode newNode);
    internal static void LoadXmlSafe(XmlDocument xmlDoc, Stream stream);
    internal static void LoadXmlSafe(XmlDocument xmlDoc, string xml, Encoding encoding);
}
internal static class OfficeOpenXml.XmlHelperFactory : object {
    internal static XmlHelper Create(XmlNamespaceManager namespaceManager);
    internal static XmlHelper Create(XmlNamespaceManager namespaceManager, XmlNode topNode);
}
internal class OfficeOpenXml.XmlHelperInstance : XmlHelper {
    internal XmlHelperInstance(XmlNamespaceManager namespaceManager);
    internal XmlHelperInstance(XmlNamespaceManager namespaceManager, XmlNode topNode);
}
internal class PageIndex : IndexBase {
    internal IndexItem _searchIx;
    internal int Offset;
    [CompilerGeneratedAttribute]
private IndexItem[] <Rows>k__BackingField;
    internal int RowCount;
    internal int IndexOffset { get; }
    internal int IndexExpanded { get; }
    internal IndexItem[] Rows { get; internal set; }
    public int MinIndex { get; }
    public int MaxIndex { get; }
    public PageIndex(IndexItem[] rows, int count);
    public PageIndex(PageIndex pageItem, int start, int size);
    public PageIndex(PageIndex pageItem, int start, int size, short index, int offset);
    protected virtual override void Finalize();
    internal int get_IndexOffset();
    internal int get_IndexExpanded();
    [CompilerGeneratedAttribute]
internal IndexItem[] get_Rows();
    [CompilerGeneratedAttribute]
internal void set_Rows(IndexItem[] value);
    internal int GetPosition(int offset);
    internal int GetNextRow(int row);
    public int get_MinIndex();
    public int get_MaxIndex();
    public int GetIndex(int pos);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class System.DateTimeExtensions : object {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1899;
    private static long DoubleDateOffset;
    private static long OADateMinAsTicks;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    [ExtensionAttribute]
public static double ToOADate(DateTime dateTime);
    private static double TicksToOADate(long value);
    public static DateTime FromOADate(double d);
    private static long DoubleDateToTicks(double value);
}
public static class System.StringComparerEx : object {
    public static StringComparer InvariantCultureIgnoreCase;
    public static StringComparer InvariantCulture;
    private static StringComparerEx();
}
public static class System.StringComparisonEx : object {
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    private static StringComparisonEx();
}
[ExtensionAttribute]
public static class System.SystemExtensions : object {
    [ExtensionAttribute]
public static Byte[] GetBuffer(MemoryStream ms);
}
