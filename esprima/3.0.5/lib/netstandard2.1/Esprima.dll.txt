[ExtensionAttribute]
internal static class Esprima.ArrayList : object {
    public static ArrayList`1<T> Create(NodeList`1& source);
    [ExtensionAttribute]
public static void AddRange(ArrayList`1& destination, NodeList`1& source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Esprima.ArrayList`1 : ValueType {
    private static int MinAllocatedCount;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] _items;
    private int _count;
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    public ArrayList`1(int initialCapacity);
    internal ArrayList`1(T[] items);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    [ConditionalAttribute("DEBUG")]
private void AssertUnchanged();
    [ConditionalAttribute("DEBUG")]
private void OnChanged();
    public void AddRange(ReadOnlySpan`1<T> items);
    public void AddRange(ArrayList`1<TSource> list);
    public void Add(T item);
    public void Clear();
    public void Insert(int index, T item);
    public void RemoveAt(int index);
    public void Sort(IComparer`1<T> comparer);
    public void Push(T item);
    public T Pop();
    public void Yield(T[]& items, Int32& count);
    public void TrimExcess(int threshold);
    public Span`1<T> AsSpan();
    public ReadOnlySpan`1<T> AsReadOnlySpan();
    public T[] ToArray();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__ThrowInvalidInitialCapacity|3_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.AccessorProperty : ClassProperty {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Decorator> _decorators;
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Static>k__BackingField;
    public Expression Value { get; }
    public bool Static { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Decorators { get; }
    [NullableContextAttribute("1")]
public AccessorProperty(Expression key, bool computed, Expression value, bool isStatic, NodeList`1& decorators);
    [CompilerGeneratedAttribute]
public Expression get_Value();
    protected virtual Expression GetValue();
    [CompilerGeneratedAttribute]
public bool get_Static();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Decorators();
    [NullableContextAttribute("1")]
private AccessorProperty Rewrite(NodeList`1& decorators, Expression key, Expression value);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public AccessorProperty UpdateWith(NodeList`1& decorators, Expression key, Expression value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ArrayExpression : Expression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Expression> _elements;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Elements { get; }
    public ArrayExpression(NodeList`1& elements);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Elements();
    private static ArrayExpression Rewrite(NodeList`1& elements);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ArrayExpression UpdateWith(NodeList`1& elements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ArrayPattern : BindingPattern {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Node> _elements;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Elements { get; }
    public ArrayPattern(NodeList`1& elements);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Elements();
    private static ArrayPattern Rewrite(NodeList`1& elements);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ArrayPattern UpdateWith(NodeList`1& elements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ArrowFunctionExpression : Expression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Node> _params;
    [CompilerGeneratedAttribute]
private StatementListItem <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Async>k__BackingField;
    [NullableAttribute("2")]
private Identifier Esprima.Ast.IFunction.Id { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Params { get; }
    public StatementListItem Body { get; }
    private bool Esprima.Ast.IFunction.Generator { get; }
    public bool Expression { get; }
    public bool Strict { get; }
    public bool Async { get; }
    public ArrowFunctionExpression(NodeList`1& parameters, StatementListItem body, bool expression, bool strict, bool async);
    [NullableContextAttribute("2")]
private sealed virtual override Identifier Esprima.Ast.IFunction.get_Id();
    public sealed virtual NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Params();
    [CompilerGeneratedAttribute]
public sealed virtual StatementListItem get_Body();
    private sealed virtual override bool Esprima.Ast.IFunction.get_Generator();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Strict();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Async();
    private ArrowFunctionExpression Rewrite(NodeList`1& params, StatementListItem body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ArrowFunctionExpression UpdateWith(NodeList`1& params, StatementListItem body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Esprima.Ast.ArrowParameterPlaceHolder : Expression {
    public static Nodes NodeType;
    public static ArrowParameterPlaceHolder Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Node> _params;
    [CompilerGeneratedAttribute]
private bool <Async>k__BackingField;
    public bool Async { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Params { get; }
    public ArrowParameterPlaceHolder(NodeList`1& parameters, bool async);
    private static ArrowParameterPlaceHolder();
    [CompilerGeneratedAttribute]
public bool get_Async();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Params();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.AssignmentExpression : Expression {
    [CompilerGeneratedAttribute]
private AssignmentOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Right>k__BackingField;
    public AssignmentOperator Operator { get; }
    public Node Left { get; }
    public Expression Right { get; }
    public AssignmentExpression(string op, Node left, Expression right);
    public AssignmentExpression(AssignmentOperator op, Node left, Expression right);
    public static AssignmentOperator ParseAssignmentOperator(string op);
    public static string GetAssignmentOperatorToken(AssignmentOperator op);
    [CompilerGeneratedAttribute]
public AssignmentOperator get_Operator();
    [CompilerGeneratedAttribute]
public Node get_Left();
    [CompilerGeneratedAttribute]
public Expression get_Right();
    private AssignmentExpression Rewrite(Node left, Expression right);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public AssignmentExpression UpdateWith(Node left, Expression right);
}
public enum Esprima.Ast.AssignmentOperator : Enum {
    public int value__;
    public static AssignmentOperator Assign;
    public static AssignmentOperator PlusAssign;
    public static AssignmentOperator MinusAssign;
    public static AssignmentOperator TimesAssign;
    public static AssignmentOperator DivideAssign;
    public static AssignmentOperator ModuloAssign;
    public static AssignmentOperator BitwiseAndAssign;
    public static AssignmentOperator BitwiseOrAssign;
    public static AssignmentOperator BitwiseXorAssign;
    public static AssignmentOperator LeftShiftAssign;
    public static AssignmentOperator RightShiftAssign;
    public static AssignmentOperator UnsignedRightShiftAssign;
    public static AssignmentOperator ExponentiationAssign;
    public static AssignmentOperator NullishAssign;
    public static AssignmentOperator AndAssign;
    public static AssignmentOperator OrAssign;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.AssignmentPattern : Node {
    internal Expression _right;
    [CompilerGeneratedAttribute]
private Node <Left>k__BackingField;
    public Node Left { get; }
    public Expression Right { get; }
    public AssignmentPattern(Node left, Expression right);
    [CompilerGeneratedAttribute]
public Node get_Left();
    public Expression get_Right();
    private static AssignmentPattern Rewrite(Node left, Expression right);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public AssignmentPattern UpdateWith(Node left, Expression right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.AwaitExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Argument>k__BackingField;
    public Expression Argument { get; }
    public AwaitExpression(Expression argument);
    [CompilerGeneratedAttribute]
public Expression get_Argument();
    private static AwaitExpression Rewrite(Expression argument);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public AwaitExpression UpdateWith(Expression argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.BinaryExpression : Expression {
    [CompilerGeneratedAttribute]
private BinaryOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Right>k__BackingField;
    public BinaryOperator Operator { get; }
    public Expression Left { get; }
    public Expression Right { get; }
    public BinaryExpression(string op, Expression left, Expression right);
    public BinaryExpression(BinaryOperator op, Expression left, Expression right);
    private protected BinaryExpression(Nodes type, string op, Expression left, Expression right);
    private protected BinaryExpression(Nodes type, BinaryOperator op, Expression left, Expression right);
    public static BinaryOperator ParseBinaryOperator(string op);
    public static string GetBinaryOperatorToken(BinaryOperator op);
    [CompilerGeneratedAttribute]
public BinaryOperator get_Operator();
    [CompilerGeneratedAttribute]
public Expression get_Left();
    [CompilerGeneratedAttribute]
public Expression get_Right();
    protected virtual BinaryExpression Rewrite(Expression left, Expression right);
    [NullableContextAttribute("2")]
internal sealed virtual Node NextChildNode(Enumerator& enumerator);
    protected internal sealed virtual object Accept(AstVisitor visitor);
    public BinaryExpression UpdateWith(Expression left, Expression right);
}
public enum Esprima.Ast.BinaryOperator : Enum {
    public int value__;
    public static BinaryOperator Plus;
    public static BinaryOperator Minus;
    public static BinaryOperator Times;
    public static BinaryOperator Divide;
    public static BinaryOperator Modulo;
    public static BinaryOperator Equal;
    public static BinaryOperator NotEqual;
    public static BinaryOperator Greater;
    public static BinaryOperator GreaterOrEqual;
    public static BinaryOperator Less;
    public static BinaryOperator LessOrEqual;
    public static BinaryOperator StrictlyEqual;
    public static BinaryOperator StrictlyNotEqual;
    public static BinaryOperator BitwiseAnd;
    public static BinaryOperator BitwiseOr;
    public static BinaryOperator BitwiseXor;
    public static BinaryOperator LeftShift;
    public static BinaryOperator RightShift;
    public static BinaryOperator UnsignedRightShift;
    public static BinaryOperator InstanceOf;
    public static BinaryOperator In;
    public static BinaryOperator LogicalAnd;
    public static BinaryOperator LogicalOr;
    public static BinaryOperator Exponentiation;
    public static BinaryOperator NullishCoalescing;
}
public abstract class Esprima.Ast.BindingPattern : Node {
    protected BindingPattern(Nodes type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.BlockStatement : Statement {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Statement> _body;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Body { get; }
    public BlockStatement(NodeList`1& body);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Body();
    private static BlockStatement Rewrite(NodeList`1& body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public BlockStatement UpdateWith(NodeList`1& body);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.BreakStatement : Statement {
    [CompilerGeneratedAttribute]
private Identifier <Label>k__BackingField;
    public Identifier Label { get; }
    public BreakStatement(Identifier label);
    [CompilerGeneratedAttribute]
public Identifier get_Label();
    [NullableContextAttribute("1")]
private static BreakStatement Rewrite(Identifier label);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public BreakStatement UpdateWith(Identifier label);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.CallExpression : Expression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Expression> _arguments;
    [CompilerGeneratedAttribute]
private Expression <Callee>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Optional>k__BackingField;
    public Expression Callee { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Arguments { get; }
    public bool Optional { get; }
    public CallExpression(Expression callee, NodeList`1& args, bool optional);
    [CompilerGeneratedAttribute]
public Expression get_Callee();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Arguments();
    [CompilerGeneratedAttribute]
public bool get_Optional();
    private CallExpression Rewrite(Expression callee, NodeList`1& arguments);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public CallExpression UpdateWith(Expression callee, NodeList`1& arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.CatchClause : Node {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Node <Param>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockStatement <Body>k__BackingField;
    [NullableAttribute("2")]
public Node Param { get; }
    public BlockStatement Body { get; }
    public CatchClause(Node param, BlockStatement body);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Node get_Param();
    [CompilerGeneratedAttribute]
public BlockStatement get_Body();
    private static CatchClause Rewrite(Node param, BlockStatement body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public CatchClause UpdateWith(Node param, BlockStatement body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ChainExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    public ChainExpression(Expression expression);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    private static ChainExpression Rewrite(Expression expression);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ChainExpression UpdateWith(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Esprima.Ast.ChildNodes : ValueType {
    [NullableAttribute("2")]
private Node _parentNode;
    internal ChildNodes(Node parentNode);
    public bool IsEmpty();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Node> System.Collections.Generic.IEnumerable<Esprima.Ast.Node>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ClassBody : Node {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<ClassElement> _body;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Body { get; }
    public ClassBody(NodeList`1& body);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Body();
    private static ClassBody Rewrite(NodeList`1& body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ClassBody UpdateWith(NodeList`1& body);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ClassDeclaration : Declaration {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Decorator> _decorators;
    [CompilerGeneratedAttribute]
private Identifier <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <SuperClass>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ClassBody <Body>k__BackingField;
    public Identifier Id { get; }
    public Expression SuperClass { get; }
    [NullableAttribute("1")]
public ClassBody Body { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Decorators { get; }
    public ClassDeclaration(Identifier id, Expression superClass, ClassBody body, NodeList`1& decorators);
    [CompilerGeneratedAttribute]
public sealed virtual Identifier get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_SuperClass();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual ClassBody get_Body();
    public sealed virtual NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Decorators();
    [NullableContextAttribute("1")]
private static ClassDeclaration Rewrite(NodeList`1& decorators, Identifier id, Expression superClass, ClassBody body);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public ClassDeclaration UpdateWith(NodeList`1& decorators, Identifier id, Expression superClass, ClassBody body);
}
public abstract class Esprima.Ast.ClassElement : Node {
    protected ClassElement(Nodes type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ClassExpression : Expression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Decorator> _decorators;
    [CompilerGeneratedAttribute]
private Identifier <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <SuperClass>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ClassBody <Body>k__BackingField;
    public Identifier Id { get; }
    public Expression SuperClass { get; }
    [NullableAttribute("1")]
public ClassBody Body { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Decorators { get; }
    public ClassExpression(Identifier id, Expression superClass, ClassBody body, NodeList`1& decorators);
    [CompilerGeneratedAttribute]
public sealed virtual Identifier get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_SuperClass();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual ClassBody get_Body();
    public sealed virtual NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Decorators();
    [NullableContextAttribute("1")]
private static ClassExpression Rewrite(NodeList`1& decorators, Identifier id, Expression superClass, ClassBody body);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public ClassExpression UpdateWith(NodeList`1& decorators, Identifier id, Expression superClass, ClassBody body);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Esprima.Ast.ClassProperty : ClassElement {
    [CompilerGeneratedAttribute]
private PropertyKind <Kind>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Expression <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Computed>k__BackingField;
    public PropertyKind Kind { get; }
    [NullableAttribute("1")]
public Expression Key { get; }
    public bool Computed { get; }
    public Expression Value { get; }
    private Node Esprima.Ast.IProperty.Value { get; }
    [NullableContextAttribute("1")]
protected ClassProperty(Nodes type, PropertyKind kind, Expression key, bool computed);
    [CompilerGeneratedAttribute]
public sealed virtual PropertyKind get_Kind();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Expression get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Computed();
    public Expression get_Value();
    private sealed virtual override Node Esprima.Ast.IProperty.get_Value();
    protected abstract virtual Expression GetValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Ast.ComputedMemberExpression : MemberExpression {
    public ComputedMemberExpression(Expression obj, Expression property, bool optional);
    protected virtual MemberExpression Rewrite(Expression object, Expression property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ConditionalExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Consequent>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Alternate>k__BackingField;
    public Expression Test { get; }
    public Expression Consequent { get; }
    public Expression Alternate { get; }
    public ConditionalExpression(Expression test, Expression consequent, Expression alternate);
    [CompilerGeneratedAttribute]
public Expression get_Test();
    [CompilerGeneratedAttribute]
public Expression get_Consequent();
    [CompilerGeneratedAttribute]
public Expression get_Alternate();
    private static ConditionalExpression Rewrite(Expression test, Expression consequent, Expression alternate);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ConditionalExpression UpdateWith(Expression test, Expression consequent, Expression alternate);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ContinueStatement : Statement {
    [CompilerGeneratedAttribute]
private Identifier <Label>k__BackingField;
    public Identifier Label { get; }
    public ContinueStatement(Identifier label);
    [CompilerGeneratedAttribute]
public Identifier get_Label();
    [NullableContextAttribute("1")]
private static ContinueStatement Rewrite(Identifier label);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public ContinueStatement UpdateWith(Identifier label);
}
[VisitableNodeAttribute]
public class Esprima.Ast.DebuggerStatement : Statement {
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
}
public abstract class Esprima.Ast.Declaration : Statement {
    protected Declaration(Nodes type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Decorator : Node {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    public Decorator(Expression expression);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    private static Decorator Rewrite(Expression expression);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public Decorator UpdateWith(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Ast.Directive : ExpressionStatement {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public Directive(Expression expression, string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    protected virtual ExpressionStatement Rewrite(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.DoWhileStatement : Statement {
    [CompilerGeneratedAttribute]
private Statement <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Test>k__BackingField;
    public Statement Body { get; }
    public Expression Test { get; }
    public DoWhileStatement(Statement body, Expression test);
    [CompilerGeneratedAttribute]
public Statement get_Body();
    [CompilerGeneratedAttribute]
public Expression get_Test();
    private static DoWhileStatement Rewrite(Statement body, Expression test);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public DoWhileStatement UpdateWith(Statement body, Expression test);
}
[VisitableNodeAttribute]
public class Esprima.Ast.EmptyStatement : Statement {
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ExportAllDeclaration : ExportDeclaration {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<ImportAttribute> _attributes;
    [CompilerGeneratedAttribute]
private Literal <Source>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Expression <Exported>k__BackingField;
    public Literal Source { get; }
    [NullableAttribute("2")]
public Expression Exported { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Attributes { get; }
    public ExportAllDeclaration(Literal source);
    public ExportAllDeclaration(Literal source, Expression exported, NodeList`1& attributes);
    [CompilerGeneratedAttribute]
public Literal get_Source();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Expression get_Exported();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Attributes();
    private static ExportAllDeclaration Rewrite(Expression exported, Literal source, NodeList`1& attributes);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ExportAllDeclaration UpdateWith(Expression exported, Literal source, NodeList`1& attributes);
}
public abstract class Esprima.Ast.ExportDeclaration : Declaration {
    protected ExportDeclaration(Nodes type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ExportDefaultDeclaration : ExportDeclaration {
    [CompilerGeneratedAttribute]
private StatementListItem <Declaration>k__BackingField;
    public StatementListItem Declaration { get; }
    public ExportDefaultDeclaration(StatementListItem declaration);
    [CompilerGeneratedAttribute]
public StatementListItem get_Declaration();
    private static ExportDefaultDeclaration Rewrite(StatementListItem declaration);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ExportDefaultDeclaration UpdateWith(StatementListItem declaration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ExportNamedDeclaration : ExportDeclaration {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<ExportSpecifier> _specifiers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<ImportAttribute> _attributes;
    [CompilerGeneratedAttribute]
private Declaration <Declaration>k__BackingField;
    [CompilerGeneratedAttribute]
private Literal <Source>k__BackingField;
    public Declaration Declaration { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Specifiers { get; }
    public Literal Source { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Attributes { get; }
    public ExportNamedDeclaration(Declaration declaration, NodeList`1& specifiers, Literal source, NodeList`1& attributes);
    [CompilerGeneratedAttribute]
public Declaration get_Declaration();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Specifiers();
    [CompilerGeneratedAttribute]
public Literal get_Source();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Attributes();
    private static ExportNamedDeclaration Rewrite(Declaration declaration, NodeList`1& specifiers, Literal source, NodeList`1& attributes);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    public ExportNamedDeclaration UpdateWith(Declaration declaration, NodeList`1& specifiers, Literal source, NodeList`1& attributes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ExportSpecifier : Node {
    [CompilerGeneratedAttribute]
private Expression <Local>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Exported>k__BackingField;
    public Expression Local { get; }
    public Expression Exported { get; }
    public ExportSpecifier(Expression local, Expression exported);
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Local();
    [CompilerGeneratedAttribute]
public Expression get_Exported();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    private static ExportSpecifier Rewrite(Expression local, Expression exported);
    protected internal virtual object Accept(AstVisitor visitor);
    public ExportSpecifier UpdateWith(Expression local, Expression exported);
}
public abstract class Esprima.Ast.Expression : StatementListItem {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<SyntaxToken> Tokens { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<SyntaxComment> Comments { get; public set; }
    protected Expression(Nodes type);
    public sealed virtual IReadOnlyList`1<SyntaxToken> get_Tokens();
    public sealed virtual void set_Tokens(IReadOnlyList`1<SyntaxToken> value);
    public sealed virtual IReadOnlyList`1<SyntaxComment> get_Comments();
    public sealed virtual void set_Comments(IReadOnlyList`1<SyntaxComment> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ExpressionStatement : Statement {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    public ExpressionStatement(Expression expression);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    protected virtual ExpressionStatement Rewrite(Expression expression);
    [NullableContextAttribute("2")]
internal sealed virtual Node NextChildNode(Enumerator& enumerator);
    protected internal sealed virtual object Accept(AstVisitor visitor);
    public ExpressionStatement UpdateWith(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ForInStatement : Statement {
    [CompilerGeneratedAttribute]
private Node <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Body>k__BackingField;
    public Node Left { get; }
    public Expression Right { get; }
    public Statement Body { get; }
    public ForInStatement(Node left, Expression right, Statement body);
    [CompilerGeneratedAttribute]
public Node get_Left();
    [CompilerGeneratedAttribute]
public Expression get_Right();
    [CompilerGeneratedAttribute]
public Statement get_Body();
    private static ForInStatement Rewrite(Node left, Expression right, Statement body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ForInStatement UpdateWith(Node left, Expression right, Statement body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ForOfStatement : Statement {
    [CompilerGeneratedAttribute]
private Node <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Await>k__BackingField;
    public Node Left { get; }
    public Expression Right { get; }
    public Statement Body { get; }
    public bool Await { get; }
    public ForOfStatement(Node left, Expression right, Statement body, bool await);
    [CompilerGeneratedAttribute]
public Node get_Left();
    [CompilerGeneratedAttribute]
public Expression get_Right();
    [CompilerGeneratedAttribute]
public Statement get_Body();
    [CompilerGeneratedAttribute]
public bool get_Await();
    private ForOfStatement Rewrite(Node left, Expression right, Statement body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ForOfStatement UpdateWith(Node left, Expression right, Statement body);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ForStatement : Statement {
    [CompilerGeneratedAttribute]
private StatementListItem <Init>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Update>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Statement <Body>k__BackingField;
    public StatementListItem Init { get; }
    public Expression Test { get; }
    public Expression Update { get; }
    [NullableAttribute("1")]
public Statement Body { get; }
    public ForStatement(StatementListItem init, Expression test, Expression update, Statement body);
    [CompilerGeneratedAttribute]
public StatementListItem get_Init();
    [CompilerGeneratedAttribute]
public Expression get_Test();
    [CompilerGeneratedAttribute]
public Expression get_Update();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Statement get_Body();
    private static ForStatement Rewrite(StatementListItem init, Expression test, Expression update, Statement body);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    public ForStatement UpdateWith(StatementListItem init, Expression test, Expression update, Statement body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.FunctionDeclaration : Declaration {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Node> _params;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Identifier <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockStatement <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Generator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Async>k__BackingField;
    [NullableAttribute("2")]
public Identifier Id { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Params { get; }
    public BlockStatement Body { get; }
    private StatementListItem Esprima.Ast.IFunction.Body { get; }
    public bool Generator { get; }
    private bool Esprima.Ast.IFunction.Expression { get; }
    public bool Strict { get; }
    public bool Async { get; }
    public FunctionDeclaration(Identifier id, NodeList`1& parameters, BlockStatement body, bool generator, bool strict, bool async);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Identifier get_Id();
    public sealed virtual NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Params();
    [CompilerGeneratedAttribute]
public BlockStatement get_Body();
    private sealed virtual override StatementListItem Esprima.Ast.IFunction.get_Body();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Generator();
    private sealed virtual override bool Esprima.Ast.IFunction.get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Strict();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Async();
    private FunctionDeclaration Rewrite(Identifier id, NodeList`1& params, BlockStatement body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public FunctionDeclaration UpdateWith(Identifier id, NodeList`1& params, BlockStatement body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.FunctionExpression : Expression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Node> _params;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Identifier <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockStatement <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Generator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Async>k__BackingField;
    [NullableAttribute("2")]
public Identifier Id { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Params { get; }
    public BlockStatement Body { get; }
    private StatementListItem Esprima.Ast.IFunction.Body { get; }
    public bool Generator { get; }
    private bool Esprima.Ast.IFunction.Expression { get; }
    public bool Strict { get; }
    public bool Async { get; }
    public FunctionExpression(Identifier id, NodeList`1& parameters, BlockStatement body, bool generator, bool strict, bool async);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Identifier get_Id();
    public sealed virtual NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Params();
    [CompilerGeneratedAttribute]
public BlockStatement get_Body();
    private sealed virtual override StatementListItem Esprima.Ast.IFunction.get_Body();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Generator();
    private sealed virtual override bool Esprima.Ast.IFunction.get_Expression();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Strict();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Async();
    private FunctionExpression Rewrite(Identifier id, NodeList`1& params, BlockStatement body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public FunctionExpression UpdateWith(Identifier id, NodeList`1& params, BlockStatement body);
}
[NullableContextAttribute("2")]
public interface Esprima.Ast.IClass {
    public Nodes Type { get; }
    public Identifier Id { get; }
    public Expression SuperClass { get; }
    [NullableAttribute("1")]
public ClassBody Body { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Decorators { get; }
    public ChildNodes ChildNodes { get; }
    public abstract virtual Nodes get_Type();
    public abstract virtual Identifier get_Id();
    public abstract virtual Expression get_SuperClass();
    [NullableContextAttribute("1")]
public abstract virtual ClassBody get_Body();
    public abstract virtual NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Decorators();
    public abstract virtual ChildNodes get_ChildNodes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Identifier : Expression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public Identifier(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.IfStatement : Statement {
    [CompilerGeneratedAttribute]
private Expression <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Consequent>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Statement <Alternate>k__BackingField;
    public Expression Test { get; }
    public Statement Consequent { get; }
    [NullableAttribute("2")]
public Statement Alternate { get; }
    public IfStatement(Expression test, Statement consequent, Statement alternate);
    [CompilerGeneratedAttribute]
public Expression get_Test();
    [CompilerGeneratedAttribute]
public Statement get_Consequent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Statement get_Alternate();
    private static IfStatement Rewrite(Expression test, Statement consequent, Statement alternate);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public IfStatement UpdateWith(Expression test, Statement consequent, Statement alternate);
}
[NullableContextAttribute("1")]
public interface Esprima.Ast.IFunction {
    public Nodes Type { get; }
    [NullableAttribute("2")]
public Identifier Id { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Params { get; }
    public StatementListItem Body { get; }
    public bool Generator { get; }
    public bool Expression { get; }
    public bool Strict { get; }
    public bool Async { get; }
    public ChildNodes ChildNodes { get; }
    public abstract virtual Nodes get_Type();
    [NullableContextAttribute("2")]
public abstract virtual Identifier get_Id();
    public abstract virtual NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Params();
    public abstract virtual StatementListItem get_Body();
    public abstract virtual bool get_Generator();
    public abstract virtual bool get_Expression();
    public abstract virtual bool get_Strict();
    public abstract virtual bool get_Async();
    public abstract virtual ChildNodes get_ChildNodes();
}
[NullableContextAttribute("1")]
public interface Esprima.Ast.IModuleSpecifier {
    public Nodes Type { get; }
    public Expression Local { get; }
    public ChildNodes ChildNodes { get; }
    public abstract virtual Nodes get_Type();
    public abstract virtual Expression get_Local();
    public abstract virtual ChildNodes get_ChildNodes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ImportAttribute : Node {
    [CompilerGeneratedAttribute]
private Expression <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Literal <Value>k__BackingField;
    public Expression Key { get; }
    public Literal Value { get; }
    public ImportAttribute(Expression key, Literal value);
    [CompilerGeneratedAttribute]
public Expression get_Key();
    [CompilerGeneratedAttribute]
public Literal get_Value();
    private static ImportAttribute Rewrite(Expression key, Literal value);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ImportAttribute UpdateWith(Expression key, Literal value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ImportDeclaration : Declaration {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<ImportDeclarationSpecifier> _specifiers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<ImportAttribute> _attributes;
    [CompilerGeneratedAttribute]
private Literal <Source>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Specifiers { get; }
    public Literal Source { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Attributes { get; }
    public ImportDeclaration(NodeList`1& specifiers, Literal source, NodeList`1& attributes);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Specifiers();
    [CompilerGeneratedAttribute]
public Literal get_Source();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Attributes();
    private static ImportDeclaration Rewrite(NodeList`1& specifiers, Literal source, NodeList`1& attributes);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ImportDeclaration UpdateWith(NodeList`1& specifiers, Literal source, NodeList`1& attributes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Esprima.Ast.ImportDeclarationSpecifier : Node {
    [CompilerGeneratedAttribute]
private Identifier <Local>k__BackingField;
    public Identifier Local { get; }
    private Expression Esprima.Ast.IModuleSpecifier.Local { get; }
    protected ImportDeclarationSpecifier(Identifier local, Nodes type);
    [CompilerGeneratedAttribute]
public Identifier get_Local();
    private sealed virtual override Expression Esprima.Ast.IModuleSpecifier.get_Local();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ImportDefaultSpecifier : ImportDeclarationSpecifier {
    public ImportDefaultSpecifier(Identifier local);
    private static ImportDefaultSpecifier Rewrite(Identifier local);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ImportDefaultSpecifier UpdateWith(Identifier local);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ImportExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Source>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Expression <Options>k__BackingField;
    public Expression Source { get; }
    [NullableAttribute("2")]
public Expression Options { get; }
    public ImportExpression(Expression source);
    public ImportExpression(Expression source, Expression options);
    [CompilerGeneratedAttribute]
public Expression get_Source();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Expression get_Options();
    private static ImportExpression Rewrite(Expression source, Expression options);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ImportExpression UpdateWith(Expression source, Expression options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ImportNamespaceSpecifier : ImportDeclarationSpecifier {
    public ImportNamespaceSpecifier(Identifier local);
    private static ImportNamespaceSpecifier Rewrite(Identifier local);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ImportNamespaceSpecifier UpdateWith(Identifier local);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ImportSpecifier : ImportDeclarationSpecifier {
    [CompilerGeneratedAttribute]
private Expression <Imported>k__BackingField;
    public Expression Imported { get; }
    public ImportSpecifier(Identifier local, Expression imported);
    [CompilerGeneratedAttribute]
public Expression get_Imported();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    private static ImportSpecifier Rewrite(Expression imported, Identifier local);
    protected internal virtual object Accept(AstVisitor visitor);
    public ImportSpecifier UpdateWith(Expression imported, Identifier local);
}
[NullableContextAttribute("1")]
public interface Esprima.Ast.IProperty {
    public Nodes Type { get; }
    public PropertyKind Kind { get; }
    public Expression Key { get; }
    public bool Computed { get; }
    [NullableAttribute("2")]
public Node Value { get; }
    public ChildNodes ChildNodes { get; }
    public abstract virtual Nodes get_Type();
    public abstract virtual PropertyKind get_Kind();
    public abstract virtual Expression get_Key();
    public abstract virtual bool get_Computed();
    [NullableContextAttribute("2")]
public abstract virtual Node get_Value();
    public abstract virtual ChildNodes get_ChildNodes();
}
internal interface Esprima.Ast.ISyntaxTreeRoot {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<SyntaxToken> Tokens { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<SyntaxComment> Comments { get; public set; }
    public abstract virtual IReadOnlyList`1<SyntaxToken> get_Tokens();
    public abstract virtual void set_Tokens(IReadOnlyList`1<SyntaxToken> value);
    public abstract virtual IReadOnlyList`1<SyntaxComment> get_Comments();
    public abstract virtual void set_Comments(IReadOnlyList`1<SyntaxComment> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxAttribute : JsxExpression {
    [CompilerGeneratedAttribute]
private JsxExpression <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    public JsxExpression Name { get; }
    [NullableAttribute("2")]
public Expression Value { get; }
    public JsxAttribute(JsxExpression name, Expression value);
    [CompilerGeneratedAttribute]
public JsxExpression get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Expression get_Value();
    private static JsxAttribute Rewrite(JsxExpression name, Expression value);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
    public JsxAttribute UpdateWith(JsxExpression name, Expression value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxClosingElement : JsxExpression {
    [CompilerGeneratedAttribute]
private JsxExpression <Name>k__BackingField;
    public JsxExpression Name { get; }
    public JsxClosingElement(JsxExpression name);
    [CompilerGeneratedAttribute]
public JsxExpression get_Name();
    private static JsxClosingElement Rewrite(JsxExpression name);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
    public JsxClosingElement UpdateWith(JsxExpression name);
}
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxClosingFragment : JsxExpression {
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(IJsxAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxElement : JsxExpression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<JsxExpression> _children;
    [CompilerGeneratedAttribute]
private Node <OpeningElement>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Node <ClosingElement>k__BackingField;
    public Node OpeningElement { get; }
    [NullableAttribute("2")]
public Node ClosingElement { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Children { get; }
    public JsxElement(Node openingElement, NodeList`1& children, Node closingElement);
    [CompilerGeneratedAttribute]
public Node get_OpeningElement();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Node get_ClosingElement();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Children();
    private static JsxElement Rewrite(Node openingElement, NodeList`1& children, Node closingElement);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
    public JsxElement UpdateWith(Node openingElement, NodeList`1& children, Node closingElement);
}
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxEmptyExpression : JsxExpression {
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(IJsxAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Esprima.Ast.Jsx.JsxExpression : Expression {
    [CompilerGeneratedAttribute]
private JsxNodeType <Type>k__BackingField;
    private static AstToJavaScriptOptions s_toStringOptions;
    public JsxNodeType Type { get; }
    protected JsxExpression(JsxNodeType type);
    private static JsxExpression();
    [CompilerGeneratedAttribute]
public JsxNodeType get_Type();
    protected internal abstract virtual object Accept(IJsxAstVisitor visitor);
    protected internal sealed virtual object Accept(AstVisitor visitor);
    public virtual string ToString();
    private protected virtual string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxExpressionContainer : JsxExpression {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    public JsxExpressionContainer(Expression expression);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    private static JsxExpressionContainer Rewrite(Expression expression);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
    public JsxExpressionContainer UpdateWith(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxIdentifier : JsxExpression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public JsxIdentifier(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxMemberExpression : JsxExpression {
    [CompilerGeneratedAttribute]
private JsxExpression <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private JsxIdentifier <Property>k__BackingField;
    public JsxExpression Object { get; }
    public JsxIdentifier Property { get; }
    public JsxMemberExpression(JsxExpression obj, JsxIdentifier property);
    [CompilerGeneratedAttribute]
public JsxExpression get_Object();
    [CompilerGeneratedAttribute]
public JsxIdentifier get_Property();
    private static JsxMemberExpression Rewrite(JsxExpression object, JsxIdentifier property);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
    public JsxMemberExpression UpdateWith(JsxExpression object, JsxIdentifier property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxNamespacedName : JsxExpression {
    [CompilerGeneratedAttribute]
private JsxIdentifier <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private JsxIdentifier <Name>k__BackingField;
    public JsxIdentifier Namespace { get; }
    public JsxIdentifier Name { get; }
    public JsxNamespacedName(JsxIdentifier namespace, JsxIdentifier name);
    [CompilerGeneratedAttribute]
public JsxIdentifier get_Namespace();
    [CompilerGeneratedAttribute]
public JsxIdentifier get_Name();
    private static JsxNamespacedName Rewrite(JsxIdentifier name, JsxIdentifier namespace);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
    public JsxNamespacedName UpdateWith(JsxIdentifier name, JsxIdentifier namespace);
}
public enum Esprima.Ast.Jsx.JsxNodeType : Enum {
    public int value__;
    public static JsxNodeType Attribute;
    public static JsxNodeType ClosingElement;
    public static JsxNodeType ClosingFragment;
    public static JsxNodeType Element;
    public static JsxNodeType EmptyExpression;
    public static JsxNodeType ExpressionContainer;
    public static JsxNodeType Identifier;
    public static JsxNodeType MemberExpression;
    public static JsxNodeType NamespacedName;
    public static JsxNodeType OpeningElement;
    public static JsxNodeType OpeningFragment;
    public static JsxNodeType SpreadAttribute;
    public static JsxNodeType Text;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxOpeningElement : JsxExpression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<JsxExpression> _attributes;
    [CompilerGeneratedAttribute]
private JsxExpression <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SelfClosing>k__BackingField;
    public JsxExpression Name { get; }
    public bool SelfClosing { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Attributes { get; }
    public JsxOpeningElement(JsxExpression name, bool selfClosing, NodeList`1& attributes);
    [CompilerGeneratedAttribute]
public JsxExpression get_Name();
    [CompilerGeneratedAttribute]
public bool get_SelfClosing();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Attributes();
    private JsxOpeningElement Rewrite(JsxExpression name, NodeList`1& attributes);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
    public JsxOpeningElement UpdateWith(JsxExpression name, NodeList`1& attributes);
}
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxOpeningFragment : JsxExpression {
    [CompilerGeneratedAttribute]
private bool <SelfClosing>k__BackingField;
    public bool SelfClosing { get; }
    public JsxOpeningFragment(bool selfClosing);
    [CompilerGeneratedAttribute]
public bool get_SelfClosing();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(IJsxAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxSpreadAttribute : JsxExpression {
    [CompilerGeneratedAttribute]
private Expression <Argument>k__BackingField;
    public Expression Argument { get; }
    public JsxSpreadAttribute(Expression argument);
    [CompilerGeneratedAttribute]
public Expression get_Argument();
    private static JsxSpreadAttribute Rewrite(Expression argument);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
    public JsxSpreadAttribute UpdateWith(Expression argument);
}
public class Esprima.Ast.Jsx.JsxSyntaxToken : SyntaxToken {
    [CompilerGeneratedAttribute]
private JsxTokenType <Type>k__BackingField;
    public JsxTokenType Type { get; }
    [NullableContextAttribute("1")]
public JsxSyntaxToken(JsxTokenType type, string value);
    [CompilerGeneratedAttribute]
public JsxTokenType get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Jsx.JsxText : JsxExpression {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Raw>k__BackingField;
    [NullableAttribute("2")]
public string Value { get; }
    public string Raw { get; }
    public JsxText(string value, string raw);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public string get_Raw();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(IJsxAstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.LabeledStatement : Statement {
    [CompilerGeneratedAttribute]
private Identifier <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Body>k__BackingField;
    public Identifier Label { get; }
    public Statement Body { get; }
    public LabeledStatement(Identifier label, Statement body);
    [CompilerGeneratedAttribute]
public Identifier get_Label();
    [CompilerGeneratedAttribute]
public Statement get_Body();
    private static LabeledStatement Rewrite(Identifier label, Statement body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public LabeledStatement UpdateWith(Identifier label, Statement body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Literal : Expression {
    [CompilerGeneratedAttribute]
private TokenType <TokenType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Raw>k__BackingField;
    public TokenType TokenType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public string Raw { get; }
    [NullableAttribute("2")]
public string StringValue { get; }
    public Nullable`1<bool> BooleanValue { get; }
    public Nullable`1<double> NumericValue { get; }
    [NullableAttribute("2")]
public Regex RegexValue { get; }
    public Nullable`1<BigInteger> BigIntValue { get; }
    internal Literal(TokenType tokenType, object value, string raw);
    public Literal(string value, string raw);
    public Literal(bool value, string raw);
    public Literal(double value, string raw);
    public Literal(BigInteger value, string raw);
    public Literal(string raw);
    [CompilerGeneratedAttribute]
public TokenType get_TokenType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_Raw();
    [NullableContextAttribute("2")]
public string get_StringValue();
    public Nullable`1<bool> get_BooleanValue();
    public Nullable`1<double> get_NumericValue();
    [NullableContextAttribute("2")]
public Regex get_RegexValue();
    public Nullable`1<BigInteger> get_BigIntValue();
    [NullableContextAttribute("2")]
internal sealed virtual Node NextChildNode(Enumerator& enumerator);
    protected internal sealed virtual object Accept(AstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Ast.LogicalExpression : BinaryExpression {
    public LogicalExpression(string op, Expression left, Expression right);
    public LogicalExpression(BinaryOperator op, Expression left, Expression right);
    internal static bool IsLogicalOperator(BinaryOperator op);
    protected virtual BinaryExpression Rewrite(Expression left, Expression right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public abstract class Esprima.Ast.MemberExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Computed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Optional>k__BackingField;
    public Expression Object { get; }
    public Expression Property { get; }
    public bool Computed { get; }
    public bool Optional { get; }
    protected MemberExpression(Expression obj, Expression property, bool computed, bool optional);
    [CompilerGeneratedAttribute]
public Expression get_Object();
    [CompilerGeneratedAttribute]
public Expression get_Property();
    [CompilerGeneratedAttribute]
public bool get_Computed();
    [CompilerGeneratedAttribute]
public bool get_Optional();
    protected abstract virtual MemberExpression Rewrite(Expression object, Expression property);
    [NullableContextAttribute("2")]
internal sealed virtual Node NextChildNode(Enumerator& enumerator);
    protected internal sealed virtual object Accept(AstVisitor visitor);
    public MemberExpression UpdateWith(Expression object, Expression property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.MetaProperty : Expression {
    [CompilerGeneratedAttribute]
private Identifier <Meta>k__BackingField;
    [CompilerGeneratedAttribute]
private Identifier <Property>k__BackingField;
    public Identifier Meta { get; }
    public Identifier Property { get; }
    public MetaProperty(Identifier meta, Identifier property);
    [CompilerGeneratedAttribute]
public Identifier get_Meta();
    [CompilerGeneratedAttribute]
public Identifier get_Property();
    private static MetaProperty Rewrite(Identifier meta, Identifier property);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public MetaProperty UpdateWith(Identifier meta, Identifier property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.MethodDefinition : ClassProperty {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Decorator> _decorators;
    [CompilerGeneratedAttribute]
private FunctionExpression <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Static>k__BackingField;
    public FunctionExpression Value { get; }
    public bool Static { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Decorators { get; }
    public MethodDefinition(Expression key, bool computed, FunctionExpression value, PropertyKind kind, bool isStatic, NodeList`1& decorators);
    [CompilerGeneratedAttribute]
public FunctionExpression get_Value();
    [NullableContextAttribute("2")]
protected virtual Expression GetValue();
    [CompilerGeneratedAttribute]
public bool get_Static();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Decorators();
    private MethodDefinition Rewrite(NodeList`1& decorators, Expression key, FunctionExpression value);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public MethodDefinition UpdateWith(NodeList`1& decorators, Expression key, FunctionExpression value);
}
public class Esprima.Ast.Module : Program {
    public SourceType SourceType { get; }
    public bool Strict { get; }
    public Module(NodeList`1& body);
    public virtual SourceType get_SourceType();
    public virtual bool get_Strict();
    [NullableContextAttribute("1")]
protected virtual Program Rewrite(NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.NewExpression : Expression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Expression> _arguments;
    [CompilerGeneratedAttribute]
private Expression <Callee>k__BackingField;
    public Expression Callee { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Arguments { get; }
    public NewExpression(Expression callee, NodeList`1& args);
    [CompilerGeneratedAttribute]
public Expression get_Callee();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Arguments();
    private static NewExpression Rewrite(Expression callee, NodeList`1& arguments);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public NewExpression UpdateWith(Expression callee, NodeList`1& arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Esprima.Ast.Node : SyntaxElement {
    private protected static int TokensPropertyIndex;
    private protected static int CommentsPropertyIndex;
    [CompilerGeneratedAttribute]
private Nodes <Type>k__BackingField;
    private static AstToJavaScriptOptions s_toStringOptions;
    public Nodes Type { get; }
    public ChildNodes ChildNodes { get; }
    protected Node(Nodes type);
    private static Node();
    [CompilerGeneratedAttribute]
public sealed virtual Nodes get_Type();
    public sealed virtual ChildNodes get_ChildNodes();
    protected internal virtual IEnumerator`1<Node> GetChildNodes();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal abstract virtual object Accept(AstVisitor visitor);
    protected object AcceptAsExtension(AstVisitor visitor);
    public virtual string ToString();
    private protected virtual string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Esprima.Ast.NodeExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static T As(Node node);
    [ExtensionAttribute]
public static IEnumerable`1<Node> DescendantNodesAndSelf(Node node);
    [ExtensionAttribute]
public static IEnumerable`1<Node> DescendantNodes(Node node);
    [ExtensionAttribute]
public static IEnumerable`1<Node> AncestorNodesAndSelf(Node node, Node rootNode);
    [ExtensionAttribute]
public static IEnumerable`1<Node> AncestorNodes(Node node, Node rootNode);
    [IteratorStateMachineAttribute("Esprima.Ast.NodeExtensions/<<DescendantNodesAndSelf>g__Impl|1_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<Node> <DescendantNodesAndSelf>g__Impl|1_0(Node node);
    [IteratorStateMachineAttribute("Esprima.Ast.NodeExtensions/<<AncestorNodesAndSelf>g__Impl|3_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<Node> <AncestorNodesAndSelf>g__Impl|3_0(Node node, Node rootNode);
    [CompilerGeneratedAttribute]
internal static bool <AncestorNodes>g__Search|4_0(Node aNode, Node targetNode, Stack`1<Node> parents);
}
public static class Esprima.Ast.NodeList : object {
    internal static NodeList`1<T> From(ArrayList`1& arrayList);
    public static NodeList`1<T> Create(IEnumerable`1<T> source);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Esprima.Ast.NodeList`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] _items;
    private int _count;
    public int Count { get; }
    [NullableAttribute("1")]
public T Item { get; }
    [NullableContextAttribute("1")]
internal NodeList`1(ICollection`1<T> collection);
    internal NodeList`1(T[] items, int count);
    public sealed virtual int get_Count();
    [NullableContextAttribute("1")]
public sealed virtual T get_Item(int index);
    internal bool IsSameAs(NodeList`1& other);
    public NodeList`1<Node> AsNodes();
    public NodeList`1<TTo> As();
    public ReadOnlySpan`1<T> AsSpan();
    public ReadOnlyMemory`1<T> AsMemory();
    [NullableContextAttribute("1")]
public T[] ToArray();
    public Enumerator<T> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__ThrowArgumentNullException|2_0();
}
public enum Esprima.Ast.Nodes : Enum {
    public int value__;
    public static Nodes AccessorProperty;
    public static Nodes ArrayExpression;
    public static Nodes ArrayPattern;
    public static Nodes ArrowFunctionExpression;
    public static Nodes AssignmentExpression;
    public static Nodes AssignmentPattern;
    public static Nodes AwaitExpression;
    public static Nodes BinaryExpression;
    public static Nodes BlockStatement;
    public static Nodes BreakStatement;
    public static Nodes CallExpression;
    public static Nodes CatchClause;
    public static Nodes ChainExpression;
    public static Nodes ClassBody;
    public static Nodes ClassDeclaration;
    public static Nodes ClassExpression;
    public static Nodes ConditionalExpression;
    public static Nodes ContinueStatement;
    public static Nodes DebuggerStatement;
    public static Nodes Decorator;
    public static Nodes DoWhileStatement;
    public static Nodes EmptyStatement;
    public static Nodes ExportAllDeclaration;
    public static Nodes ExportDefaultDeclaration;
    public static Nodes ExportNamedDeclaration;
    public static Nodes ExportSpecifier;
    public static Nodes ExpressionStatement;
    public static Nodes ForInStatement;
    public static Nodes ForOfStatement;
    public static Nodes ForStatement;
    public static Nodes FunctionDeclaration;
    public static Nodes FunctionExpression;
    public static Nodes Identifier;
    public static Nodes IfStatement;
    public static Nodes ImportAttribute;
    public static Nodes ImportDeclaration;
    public static Nodes ImportDefaultSpecifier;
    public static Nodes ImportExpression;
    public static Nodes ImportNamespaceSpecifier;
    public static Nodes ImportSpecifier;
    public static Nodes LabeledStatement;
    public static Nodes Literal;
    public static Nodes LogicalExpression;
    public static Nodes MemberExpression;
    public static Nodes MetaProperty;
    public static Nodes MethodDefinition;
    public static Nodes NewExpression;
    public static Nodes ObjectExpression;
    public static Nodes ObjectPattern;
    public static Nodes PrivateIdentifier;
    public static Nodes Program;
    public static Nodes Property;
    public static Nodes PropertyDefinition;
    public static Nodes RestElement;
    public static Nodes ReturnStatement;
    public static Nodes SequenceExpression;
    public static Nodes SpreadElement;
    public static Nodes StaticBlock;
    public static Nodes Super;
    public static Nodes SwitchCase;
    public static Nodes SwitchStatement;
    public static Nodes TaggedTemplateExpression;
    public static Nodes TemplateElement;
    public static Nodes TemplateLiteral;
    public static Nodes ThisExpression;
    public static Nodes ThrowStatement;
    public static Nodes TryStatement;
    public static Nodes UnaryExpression;
    public static Nodes UpdateExpression;
    public static Nodes VariableDeclaration;
    public static Nodes VariableDeclarator;
    public static Nodes WhileStatement;
    public static Nodes WithStatement;
    public static Nodes YieldExpression;
    public static Nodes Extension;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ObjectExpression : Expression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Node> _properties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Properties { get; }
    public ObjectExpression(NodeList`1& properties);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Properties();
    private static ObjectExpression Rewrite(NodeList`1& properties);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ObjectExpression UpdateWith(NodeList`1& properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ObjectPattern : BindingPattern {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Node> _properties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Properties { get; }
    public ObjectPattern(NodeList`1& properties);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Properties();
    private static ObjectPattern Rewrite(NodeList`1& properties);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ObjectPattern UpdateWith(NodeList`1& properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.PrivateIdentifier : Expression {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public PrivateIdentifier(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public abstract class Esprima.Ast.Program : Node {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Statement> _body;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Body { get; }
    public SourceType SourceType { get; }
    public bool Strict { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<SyntaxToken> Tokens { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<SyntaxComment> Comments { get; public set; }
    protected Program(NodeList`1& body);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Body();
    public abstract virtual SourceType get_SourceType();
    public abstract virtual bool get_Strict();
    public sealed virtual IReadOnlyList`1<SyntaxToken> get_Tokens();
    public sealed virtual void set_Tokens(IReadOnlyList`1<SyntaxToken> value);
    public sealed virtual IReadOnlyList`1<SyntaxComment> get_Comments();
    public sealed virtual void set_Comments(IReadOnlyList`1<SyntaxComment> value);
    protected abstract virtual Program Rewrite(NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) body);
    [NullableContextAttribute("2")]
internal sealed virtual Node NextChildNode(Enumerator& enumerator);
    protected internal sealed virtual object Accept(AstVisitor visitor);
    public Program UpdateWith(NodeList`1& body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.Property : Node {
    internal Node _value;
    [CompilerGeneratedAttribute]
private PropertyKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Computed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Shorthand>k__BackingField;
    public PropertyKind Kind { get; }
    public Expression Key { get; }
    public bool Computed { get; }
    public Node Value { get; }
    [NullableAttribute("2")]
private Node Esprima.Ast.IProperty.Value { get; }
    public bool Method { get; }
    public bool Shorthand { get; }
    public Property(PropertyKind kind, Expression key, bool computed, Node value, bool method, bool shorthand);
    [CompilerGeneratedAttribute]
public sealed virtual PropertyKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Computed();
    public Node get_Value();
    [NullableContextAttribute("2")]
private sealed virtual override Node Esprima.Ast.IProperty.get_Value();
    [CompilerGeneratedAttribute]
public bool get_Method();
    [CompilerGeneratedAttribute]
public bool get_Shorthand();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    private Property Rewrite(Expression key, Node value);
    protected internal virtual object Accept(AstVisitor visitor);
    public Property UpdateWith(Expression key, Node value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.PropertyDefinition : ClassProperty {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Decorator> _decorators;
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Static>k__BackingField;
    public Expression Value { get; }
    public bool Static { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Decorators { get; }
    [NullableContextAttribute("1")]
public PropertyDefinition(Expression key, bool computed, Expression value, bool isStatic, NodeList`1& decorators);
    [CompilerGeneratedAttribute]
public Expression get_Value();
    protected virtual Expression GetValue();
    [CompilerGeneratedAttribute]
public bool get_Static();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Decorators();
    [NullableContextAttribute("1")]
private PropertyDefinition Rewrite(NodeList`1& decorators, Expression key, Expression value);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public PropertyDefinition UpdateWith(NodeList`1& decorators, Expression key, Expression value);
}
public enum Esprima.Ast.PropertyKind : Enum {
    public int value__;
    public static PropertyKind None;
    public static PropertyKind Get;
    public static PropertyKind Set;
    public static PropertyKind Init;
    public static PropertyKind Constructor;
    public static PropertyKind Method;
    public static PropertyKind Property;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Ast.RegExpLiteral : Literal {
    [CompilerGeneratedAttribute]
private RegexValue <Regex>k__BackingField;
    [CompilerGeneratedAttribute]
private RegExpParseResult <ParseResult>k__BackingField;
    public RegexValue Regex { get; }
    public RegExpParseResult ParseResult { get; }
    public RegExpLiteral(string pattern, string flags, RegExpParseResult parseResult, string raw);
    public RegExpLiteral(RegexValue regex, RegExpParseResult parseResult, string raw);
    [CompilerGeneratedAttribute]
public RegexValue get_Regex();
    [CompilerGeneratedAttribute]
public RegExpParseResult get_ParseResult();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Ast.RegexValue : object {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public string Pattern { get; public set; }
    public string Flags { get; public set; }
    public RegexValue(string Pattern, string Flags);
    [CompilerGeneratedAttribute]
private RegexValue(RegexValue original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Pattern(string value);
    [CompilerGeneratedAttribute]
public string get_Flags();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Flags(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(RegexValue left, RegexValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(RegexValue left, RegexValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RegexValue other);
    [CompilerGeneratedAttribute]
public RegexValue <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Pattern, String& Flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.RestElement : Node {
    [CompilerGeneratedAttribute]
private Node <Argument>k__BackingField;
    public Node Argument { get; }
    public RestElement(Node argument);
    [CompilerGeneratedAttribute]
public Node get_Argument();
    private static RestElement Rewrite(Node argument);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public RestElement UpdateWith(Node argument);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ReturnStatement : Statement {
    [CompilerGeneratedAttribute]
private Expression <Argument>k__BackingField;
    public Expression Argument { get; }
    public ReturnStatement(Expression argument);
    [CompilerGeneratedAttribute]
public Expression get_Argument();
    [NullableContextAttribute("1")]
private static ReturnStatement Rewrite(Expression argument);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public ReturnStatement UpdateWith(Expression argument);
}
public class Esprima.Ast.Script : Program {
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    public SourceType SourceType { get; }
    public bool Strict { get; }
    public Script(NodeList`1& body, bool strict);
    public virtual SourceType get_SourceType();
    [CompilerGeneratedAttribute]
public virtual bool get_Strict();
    [NullableContextAttribute("1")]
protected virtual Program Rewrite(NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.SequenceExpression : Expression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Expression> _expressions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Expressions { get; }
    public SequenceExpression(NodeList`1& expressions);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Expressions();
    private static SequenceExpression Rewrite(NodeList`1& expressions);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public SequenceExpression UpdateWith(NodeList`1& expressions);
}
public enum Esprima.Ast.SourceType : Enum {
    public int value__;
    public static SourceType Module;
    public static SourceType Script;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.SpreadElement : Expression {
    [CompilerGeneratedAttribute]
private Expression <Argument>k__BackingField;
    public Expression Argument { get; }
    public SpreadElement(Expression argument);
    [CompilerGeneratedAttribute]
public Expression get_Argument();
    private static SpreadElement Rewrite(Expression argument);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public SpreadElement UpdateWith(Expression argument);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Esprima.Ast.Statement : StatementListItem {
    internal Identifier _labelSet;
    public Identifier LabelSet { get; }
    protected Statement(Nodes type);
    public Identifier get_LabelSet();
}
public abstract class Esprima.Ast.StatementListItem : Node {
    protected StatementListItem(Nodes type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.StaticBlock : ClassElement {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Statement> _body;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Body { get; }
    public StaticBlock(NodeList`1& body);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Body();
    private static StaticBlock Rewrite(NodeList`1& body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public StaticBlock UpdateWith(NodeList`1& body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Ast.StaticMemberExpression : MemberExpression {
    public StaticMemberExpression(Expression obj, Expression property, bool optional);
    protected virtual MemberExpression Rewrite(Expression object, Expression property);
}
[VisitableNodeAttribute]
public class Esprima.Ast.Super : Expression {
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.SwitchCase : Node {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Statement> _consequent;
    [CompilerGeneratedAttribute]
private Expression <Test>k__BackingField;
    public Expression Test { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Consequent { get; }
    public SwitchCase(Expression test, NodeList`1& consequent);
    [CompilerGeneratedAttribute]
public Expression get_Test();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Consequent();
    [NullableContextAttribute("1")]
private static SwitchCase Rewrite(Expression test, NodeList`1& consequent);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public SwitchCase UpdateWith(Expression test, NodeList`1& consequent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.SwitchStatement : Statement {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<SwitchCase> _cases;
    [CompilerGeneratedAttribute]
private Expression <Discriminant>k__BackingField;
    public Expression Discriminant { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Cases { get; }
    public SwitchStatement(Expression discriminant, NodeList`1& cases);
    [CompilerGeneratedAttribute]
public Expression get_Discriminant();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Cases();
    private static SwitchStatement Rewrite(Expression discriminant, NodeList`1& cases);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public SwitchStatement UpdateWith(Expression discriminant, NodeList`1& cases);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Ast.SyntaxComment : SyntaxElement {
    private static String[] s_blockSeparators;
    [CompilerGeneratedAttribute]
private CommentType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public CommentType Type { get; }
    public string Value { get; }
    public SyntaxComment(CommentType type, string value);
    private static SyntaxComment();
    [CompilerGeneratedAttribute]
public CommentType get_Type();
    [CompilerGeneratedAttribute]
public string get_Value();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public abstract class Esprima.Ast.SyntaxElement : object {
    private protected AdditionalDataSlot _additionalDataSlot;
    public Range Range;
    public Location Location;
    public object AssociatedData { get; public set; }
    private protected object GetDynamicPropertyValue(int propertyIndex);
    private protected void SetDynamicPropertyValue(int propertyIndex, object value);
    public object get_AssociatedData();
    public void set_AssociatedData(object value);
    [NullableContextAttribute("1")]
private protected virtual string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Ast.SyntaxToken : SyntaxElement {
    private static int RegexValuePropertyIndex;
    [CompilerGeneratedAttribute]
private TokenType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public TokenType Type { get; }
    public string Value { get; }
    [NullableAttribute("2")]
public RegexValue RegexValue { get; private set; }
    public SyntaxToken(TokenType type, string value, RegexValue regexValue);
    [CompilerGeneratedAttribute]
public TokenType get_Type();
    [CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("2")]
public RegexValue get_RegexValue();
    [NullableContextAttribute("2")]
private void set_RegexValue(RegexValue value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.TaggedTemplateExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private TemplateLiteral <Quasi>k__BackingField;
    public Expression Tag { get; }
    public TemplateLiteral Quasi { get; }
    public TaggedTemplateExpression(Expression tag, TemplateLiteral quasi);
    [CompilerGeneratedAttribute]
public Expression get_Tag();
    [CompilerGeneratedAttribute]
public TemplateLiteral get_Quasi();
    private static TaggedTemplateExpression Rewrite(Expression tag, TemplateLiteral quasi);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public TaggedTemplateExpression UpdateWith(Expression tag, TemplateLiteral quasi);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.TemplateElement : Node {
    [CompilerGeneratedAttribute]
private TemplateElementValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Tail>k__BackingField;
    public TemplateElementValue Value { get; }
    public bool Tail { get; }
    public TemplateElement(TemplateElementValue value, bool tail);
    [CompilerGeneratedAttribute]
public TemplateElementValue get_Value();
    [CompilerGeneratedAttribute]
public bool get_Tail();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.TemplateLiteral : Expression {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<TemplateElement> _quasis;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<Expression> _expressions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Quasis { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Expressions { get; }
    public TemplateLiteral(NodeList`1& quasis, NodeList`1& expressions);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Quasis();
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Expressions();
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    private static TemplateLiteral Rewrite(NodeList`1& quasis, NodeList`1& expressions);
    protected internal virtual object Accept(AstVisitor visitor);
    public TemplateLiteral UpdateWith(NodeList`1& quasis, NodeList`1& expressions);
}
[VisitableNodeAttribute]
public class Esprima.Ast.ThisExpression : Expression {
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.ThrowStatement : Statement {
    [CompilerGeneratedAttribute]
private Expression <Argument>k__BackingField;
    public Expression Argument { get; }
    public ThrowStatement(Expression argument);
    [CompilerGeneratedAttribute]
public Expression get_Argument();
    private static ThrowStatement Rewrite(Expression argument);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public ThrowStatement UpdateWith(Expression argument);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.TryStatement : Statement {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private BlockStatement <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private CatchClause <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockStatement <Finalizer>k__BackingField;
    [NullableAttribute("1")]
public BlockStatement Block { get; }
    public CatchClause Handler { get; }
    public BlockStatement Finalizer { get; }
    public TryStatement(BlockStatement block, CatchClause handler, BlockStatement finalizer);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public BlockStatement get_Block();
    [CompilerGeneratedAttribute]
public CatchClause get_Handler();
    [CompilerGeneratedAttribute]
public BlockStatement get_Finalizer();
    [NullableContextAttribute("1")]
private static TryStatement Rewrite(BlockStatement block, CatchClause handler, BlockStatement finalizer);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public TryStatement UpdateWith(BlockStatement block, CatchClause handler, BlockStatement finalizer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.UnaryExpression : Expression {
    [CompilerGeneratedAttribute]
private UnaryOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Prefix>k__BackingField;
    public UnaryOperator Operator { get; }
    public Expression Argument { get; }
    public bool Prefix { get; }
    public UnaryExpression(string op, Expression arg);
    public UnaryExpression(UnaryOperator op, Expression arg);
    private protected UnaryExpression(Nodes type, string op, Expression arg, bool prefix);
    private protected UnaryExpression(Nodes type, UnaryOperator op, Expression arg, bool prefix);
    public static UnaryOperator ParseUnaryOperator(string op);
    public static string GetUnaryOperatorToken(UnaryOperator op);
    [CompilerGeneratedAttribute]
public UnaryOperator get_Operator();
    [CompilerGeneratedAttribute]
public Expression get_Argument();
    [CompilerGeneratedAttribute]
public bool get_Prefix();
    protected virtual UnaryExpression Rewrite(Expression argument);
    [NullableContextAttribute("2")]
internal sealed virtual Node NextChildNode(Enumerator& enumerator);
    protected internal sealed virtual object Accept(AstVisitor visitor);
    public UnaryExpression UpdateWith(Expression argument);
}
public enum Esprima.Ast.UnaryOperator : Enum {
    public int value__;
    public static UnaryOperator Plus;
    public static UnaryOperator Minus;
    public static UnaryOperator BitwiseNot;
    public static UnaryOperator LogicalNot;
    public static UnaryOperator Delete;
    public static UnaryOperator Void;
    public static UnaryOperator TypeOf;
    public static UnaryOperator Increment;
    public static UnaryOperator Decrement;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Ast.UpdateExpression : UnaryExpression {
    public UpdateExpression(string op, Expression arg, bool prefix);
    public UpdateExpression(UnaryOperator op, Expression arg, bool prefix);
    internal static bool IsUpdateOperator(UnaryOperator op);
    protected virtual UnaryExpression Rewrite(Expression argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.VariableDeclaration : Declaration {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NodeList`1<VariableDeclarator> _declarations;
    [CompilerGeneratedAttribute]
private VariableDeclarationKind <Kind>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[IsReadOnlyAttribute]
public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Declarations { get; }
    public VariableDeclarationKind Kind { get; }
    public VariableDeclaration(NodeList`1& declarations, VariableDeclarationKind kind);
    public static string GetVariableDeclarationKindToken(VariableDeclarationKind kind);
    public NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) get_Declarations();
    [CompilerGeneratedAttribute]
public VariableDeclarationKind get_Kind();
    private VariableDeclaration Rewrite(NodeList`1& declarations);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public VariableDeclaration UpdateWith(NodeList`1& declarations);
}
public enum Esprima.Ast.VariableDeclarationKind : Enum {
    public int value__;
    public static VariableDeclarationKind Var;
    public static VariableDeclarationKind Let;
    public static VariableDeclarationKind Const;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.VariableDeclarator : Node {
    [CompilerGeneratedAttribute]
private Node <Id>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Expression <Init>k__BackingField;
    public Node Id { get; }
    [NullableAttribute("2")]
public Expression Init { get; }
    public VariableDeclarator(Node id, Expression init);
    [CompilerGeneratedAttribute]
public Node get_Id();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Expression get_Init();
    private static VariableDeclarator Rewrite(Node id, Expression init);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public VariableDeclarator UpdateWith(Node id, Expression init);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Esprima.Ast.VisitableNodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VisitorType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <ChildProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SealOverrideMethods>k__BackingField;
    public Type VisitorType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] ChildProperties { get; public set; }
    public bool SealOverrideMethods { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_VisitorType();
    [CompilerGeneratedAttribute]
public void set_VisitorType(Type value);
    [CompilerGeneratedAttribute]
public String[] get_ChildProperties();
    [CompilerGeneratedAttribute]
public void set_ChildProperties(String[] value);
    [CompilerGeneratedAttribute]
public bool get_SealOverrideMethods();
    [CompilerGeneratedAttribute]
public void set_SealOverrideMethods(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.WhileStatement : Statement {
    [CompilerGeneratedAttribute]
private Expression <Test>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Body>k__BackingField;
    public Expression Test { get; }
    public Statement Body { get; }
    public WhileStatement(Expression test, Statement body);
    [CompilerGeneratedAttribute]
public Expression get_Test();
    [CompilerGeneratedAttribute]
public Statement get_Body();
    private static WhileStatement Rewrite(Expression test, Statement body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public WhileStatement UpdateWith(Expression test, Statement body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.WithStatement : Statement {
    [CompilerGeneratedAttribute]
private Expression <Object>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Body>k__BackingField;
    public Expression Object { get; }
    public Statement Body { get; }
    public WithStatement(Expression obj, Statement body);
    [CompilerGeneratedAttribute]
public Expression get_Object();
    [CompilerGeneratedAttribute]
public Statement get_Body();
    private static WithStatement Rewrite(Expression object, Statement body);
    [NullableContextAttribute("2")]
internal virtual Node NextChildNode(Enumerator& enumerator);
    protected internal virtual object Accept(AstVisitor visitor);
    public WithStatement UpdateWith(Expression object, Statement body);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[VisitableNodeAttribute]
public class Esprima.Ast.YieldExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Delegate>k__BackingField;
    public Expression Argument { get; }
    public bool Delegate { get; }
    public YieldExpression(Expression argument, bool delegate);
    [CompilerGeneratedAttribute]
public Expression get_Argument();
    [CompilerGeneratedAttribute]
public bool get_Delegate();
    [NullableContextAttribute("1")]
private YieldExpression Rewrite(Expression argument);
    internal virtual Node NextChildNode(Enumerator& enumerator);
    [NullableContextAttribute("1")]
protected internal virtual object Accept(AstVisitor visitor);
    [NullableContextAttribute("1")]
public YieldExpression UpdateWith(Expression argument);
}
public static class Esprima.Character : object {
    internal static int UnicodeLastCodePoint;
    [NullableAttribute("1")]
internal static Func`2<char, bool> IsDecimalDigitFunc;
    [NullableAttribute("1")]
internal static Func`2<char, bool> IsHexDigitFunc;
    [NullableAttribute("1")]
internal static Func`2<char, bool> IsOctalDigitFunc;
    private static Int32[] s_identifierStartAstralRanges;
    private static Int32[] s_identifierPartAstralRanges;
    private static Int32[] s_rangeLengthLookup;
    private static ReadOnlySpan`1<byte> s_characterData { get; }
    private static Character();
    internal static bool HasCharacterFlag(char ch, CharacterMask flag);
    internal static bool IsLineTerminator(char ch);
    internal static bool IsWhiteSpace(char ch);
    internal static bool IsIdentifierStart(char ch);
    internal static bool IsIdentifierStartAstral(int cp);
    internal static bool IsIdentifierPart(char ch);
    internal static bool IsIdentifierPartAstral(int cp);
    public static bool IsDecimalDigit(char cp);
    public static bool IsHexDigit(char cp);
    public static bool IsOctalDigit(char cp);
    private static bool IsInRange(char c, char min, char max);
    internal static void GetSurrogatePair(UInt32 cp, Char& highSurrogate, Char& lowSurrogate);
    internal static UInt32 GetCodePoint(char highSurrogate, char lowSurrogate);
    private static ReadOnlySpan`1<byte> get_s_characterData();
}
[FlagsAttribute]
internal enum Esprima.CharacterMask : Enum {
    public byte value__;
    public static CharacterMask None;
    public static CharacterMask WhiteSpace;
    public static CharacterMask IdentifierStart;
    public static CharacterMask IdentifierPart;
}
[IsReadOnlyAttribute]
internal class Esprima.CodePointRange : ValueType {
    public int Start;
    public int End;
    public int Length { get; }
    public CodePointRange(int codePoint);
    public CodePointRange(int start, int end);
    public int get_Length();
    public bool Contains(int codePoint);
    public sealed virtual int CompareTo(CodePointRange other);
    public static void NormalizeRanges(ArrayList`1& ranges);
    public static ArrayList`1<CodePointRange> InvertRanges(ReadOnlySpan`1<CodePointRange> ranges, int start, int end);
    [NullableContextAttribute("1")]
internal static bool RangesContain(int codePoint, Int32[] ranges, Int32[] rangeLengthLookup);
    [NullableContextAttribute("1")]
private static CodePointRange DecodeRange(int data, Int32[] rangeLengths);
    internal static void AddRanges(ArrayList`1& ranges, Predicate`1<int> includesCodePoint, int start, int end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.CollectingErrorHandler : ErrorHandler {
    private List`1<ParseError> _errors;
    public IReadOnlyCollection`1<ParseError> Errors { get; }
    public IReadOnlyCollection`1<ParseError> get_Errors();
    protected internal virtual void Reset();
    protected virtual void RecordError(ParseError error);
}
[IsReadOnlyAttribute]
public class Esprima.Comment : ValueType {
    public CommentType Type;
    public Range Slice;
    public int Start;
    public int End;
    public Position StartPosition;
    public Position EndPosition;
    internal Comment(CommentType type, Range slice, int start, int end, Position startPosition, Position endPosition);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Comment left, Comment right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Comment left, Comment right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Comment other);
}
public enum Esprima.CommentType : Enum {
    public int value__;
    public static CommentType Block;
    public static CommentType Line;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.ErrorHandler : object {
    public static ErrorHandler Default;
    private static ErrorHandler();
    protected internal virtual void Reset();
    protected virtual void RecordError(ParseError error);
    internal void Tolerate(ParseError error, bool tolerant);
    protected internal virtual ParseError CreateError(string source, int index, int line, int col, string description);
    internal ParseError TolerateError(string source, int index, int line, int col, string description, bool tolerant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Esprima.EsprimaExceptionHelper : object {
    [DoesNotReturnAttribute]
public static T ThrowArgumentNullException(string paramName);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException(string paramName, T actualValue, string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(string message, string paramName);
    [DoesNotReturnAttribute]
public static T ThrowIndexOutOfRangeException();
    [DoesNotReturnAttribute]
public static T ThrowFormatException(string message);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public static T ThrowInvalidOperationException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.JavaScriptParser : object {
    private Func`1<Expression> _parseAssignmentExpression;
    private Func`1<Expression> _parseBinaryExpressionOperand;
    private Func`1<Expression> _parseUnaryExpression;
    private Func`1<Expression> _parseExpression;
    private Func`1<Expression> _parseNewExpression;
    private Func`1<Expression> _parsePrimaryExpression;
    private Func`1<Expression> _parseGroupExpression;
    private Func`1<Expression> _parseArrayInitializer;
    private Func`1<Expression> _parseObjectInitializer;
    private Func`1<Expression> _parseBinaryExpression;
    private Func`1<Expression> _parseLeftHandSideExpression;
    private Func`1<Expression> _parseLeftHandSideExpressionAllowCall;
    private Func`1<Statement> _parseStatement;
    private Func`1<BlockStatement> _parseFunctionSourceElements;
    private Func`1<Expression> _parseAsyncArgument;
    private protected Token _lookahead;
    private protected Context _context;
    private protected Marker _startMarker;
    private protected Marker _lastMarker;
    private protected ErrorHandler _errorHandler;
    private protected bool _tolerant;
    private protected bool _allowReturnOutsideFunction;
    private protected int _maxAssignmentDepth;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<Node> _onNodeCreated;
    private protected Scanner _scanner;
    private protected bool _hasLineTerminator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected List`1<SyntaxToken> _tokens;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected List`1<SyntaxComment> _comments;
    [NullableAttribute("2")]
private Stack`1<Token> _markersStack;
    [NullableAttribute("2")]
private Stack`1<int> _precedencesStack;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ArrayList`1<object>> _sharedStack;
    private int _assignmentDepth;
    [NullableAttribute("0")]
private Nullable`1<ArrayList`1<Token>> _parseVariableBindingParameters;
    public JavaScriptParser(ParserOptions options);
    [StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static bool IsAssignmentOperator(string id);
    private void Reset(string code, string source);
    private void ReleaseLargeBuffers();
    public Module ParseModule(string code, string source);
    public Script ParseScript(string code, string source, bool strict);
    private protected void CollectComments();
    private protected string GetTokenRaw(Token& token);
    private protected SyntaxToken FinalizeToken(int start, int end, SyntaxToken token);
    private protected SyntaxToken ConvertToken(Token& token);
    private protected Token NextToken(bool allowIdentifierEscape);
    private Token NextRegExpToken();
    private Marker CreateNode();
    private static Marker StartNode(Token& token, int lastLineStart);
    private protected T Finalize(Marker& marker, T node);
    private T FinalizeRoot(T node);
    private void Expect(string value);
    private void ExpectCommaSeparator();
    private void ExpectKeyword(string keyword);
    private protected bool Match(string value);
    private protected bool ConsumeMatch(string value);
    private bool MatchAny(char value1, char value2, char value3, char value4);
    private bool MatchKeyword(string keyword);
    private bool MatchContextualKeyword(string keyword);
    private bool MatchAssign();
    private T IsolateCoverGrammar(Func`1<T> parseFunction);
    private T InheritCoverGrammar(Func`1<T> parseFunction);
    private void ConsumeSemicolon();
    private protected virtual Expression ParsePrimaryExpression();
    private Expression ParseDecoratedPrimaryExpression(Marker& node);
    private void ThrowTemplateLiteralEarlyErrors(Token& token);
    private SpreadElement ParseSpreadElement();
    private ArrayExpression ParseArrayInitializer();
    private BlockStatement ParsePropertyMethod(ParsedParameters& parameters, Boolean& hasStrictDirective);
    private FunctionExpression ParsePropertyMethodFunction(bool isAsync, bool isGenerator, bool allowSuperCall);
    private Expression ParseObjectPropertyKey();
    private PrivateIdentifier ParsePrivateIdentifier();
    private PrivateIdentifier ParsePrivateIdentifier(Marker& node);
    private static bool IsPropertyKey(Node key, string value);
    private Property ParseObjectProperty(Int32& protoCount);
    private ObjectExpression ParseObjectInitializer();
    private TemplateElement ParseTemplateHead(bool isTagged);
    private TemplateElement ParseTemplateElement(bool isTagged);
    private TemplateLiteral ParseTemplateLiteral(bool isTagged);
    private static Node ReinterpretExpressionAsPattern(Node expr);
    private Expression ParseGroupExpression();
    private Expression ParseSequenceExpression(Expression expr, Token& startToken, Boolean& arrow);
    private NodeList`1<Expression> ParseArguments();
    private static bool IsIdentifierName(Token& token);
    private Identifier ParseIdentifierName();
    private Expression ParseIdentifierOrPrivateIdentifierName();
    private Expression ParseNewExpression();
    private Expression ParseAsyncArgument();
    private NodeList`1<Expression> ParseAsyncArguments();
    private bool MatchImportCall();
    private ImportExpression ParseImportCall();
    private bool MatchImportMeta();
    private MetaProperty ParseImportMeta();
    private Expression ParseLeftHandSideExpressionAllowCall();
    private Expression ParseCallExpression(bool maybeAsync, Marker& startToken, Expression callee, bool optional);
    private Super ParseSuperAccess();
    private Expression ParseLeftHandSideExpression();
    private Expression ParseUpdateExpression();
    private Expression ParsePostfixUnaryExpression(Expression expr, Marker& marker);
    private Expression ParsePrefixUnaryExpression(Marker& marker);
    private AwaitExpression ParseAwaitExpression();
    private Expression ParseUnaryExpression();
    private UnaryExpression ParseBasicUnaryExpression();
    [StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private bool MatchUnaryKeyword(string input);
    private static BinaryExpression CreateBinaryExpression(string op, Expression left, Expression right);
    private Expression ParseBinaryExpressionOperand();
    private BinaryExpression ParseExponentiationExpression(Expression expr, Marker& marker);
    private int BinaryPrecedence(Token& token);
    private Expression ParseBinaryExpression();
    private ConditionalExpression ParseConditionalExpression(Expression expr, Marker& marker);
    private void CheckPatternParam(ParsedParameters& options, Node param);
    private Nullable`1<ParsedParameters> ReinterpretAsCoverFormalsList(Expression expr);
    private protected Expression ParseAssignmentExpression();
    private Expression ParseExpression();
    public Expression ParseExpression(string code, bool strict);
    private Statement ParseStatementListItem();
    private BlockStatement ParseBlock();
    private VariableDeclarator ParseLexicalBinding(VariableDeclarationKind kind, bool inFor);
    private NodeList`1<VariableDeclarator> ParseBindingList(VariableDeclarationKind kind, bool inFor);
    private bool IsLexicalDeclaration();
    private VariableDeclaration ParseLexicalDeclaration();
    [NullableContextAttribute("2")]
private VariableDeclarationKind ParseVariableDeclarationKind(string kindString);
    [NullableContextAttribute("0")]
private RestElement ParseBindingRestElement(ArrayList`1& parameters, Nullable`1<VariableDeclarationKind> kind);
    [NullableContextAttribute("0")]
private ArrayPattern ParseArrayPattern(ArrayList`1& parameters, Nullable`1<VariableDeclarationKind> kind);
    [NullableContextAttribute("0")]
private Property ParsePropertyPattern(ArrayList`1& parameters, Nullable`1<VariableDeclarationKind> kind);
    [NullableContextAttribute("0")]
private RestElement ParseRestProperty(ArrayList`1& parameters, Nullable`1<VariableDeclarationKind> kind);
    [NullableContextAttribute("0")]
private ObjectPattern ParseObjectPattern(ArrayList`1& parameters, Nullable`1<VariableDeclarationKind> kind);
    [NullableContextAttribute("0")]
private Node ParsePattern(ArrayList`1& parameters, Nullable`1<VariableDeclarationKind> kind);
    [NullableContextAttribute("0")]
private Node ParsePatternWithDefault(ArrayList`1& parameters, Nullable`1<VariableDeclarationKind> kind);
    private Identifier ParseVariableIdentifier(Nullable`1<VariableDeclarationKind> kind, bool allowAwaitKeyword);
    private VariableDeclarator ParseVariableDeclaration(bool inFor);
    private NodeList`1<VariableDeclarator> ParseVariableDeclarationList(bool inFor);
    private VariableDeclaration ParseVariableStatement();
    private EmptyStatement ParseEmptyStatement();
    private ExpressionStatement ParseExpressionStatement();
    private Statement ParseIfClause();
    private IfStatement ParseIfStatement();
    private DoWhileStatement ParseDoWhileStatement();
    private WhileStatement ParseWhileStatement();
    private Statement ParseForStatement();
    private ContinueStatement ParseContinueStatement();
    private BreakStatement ParseBreakStatement();
    private ReturnStatement ParseReturnStatement();
    private WithStatement ParseWithStatement();
    private SwitchCase ParseSwitchCase();
    private SwitchStatement ParseSwitchStatement();
    private Statement ParseLabelledStatement();
    private ThrowStatement ParseThrowStatement();
    private CatchClause ParseCatchClause();
    private BlockStatement ParseFinallyClause();
    private TryStatement ParseTryStatement();
    private DebuggerStatement ParseDebuggerStatement();
    private Statement ParseStatement();
    private BlockStatement ParseFunctionSourceElements();
    private void ValidateParam(ParsedParameters& options, Node param, string name);
    [NullableContextAttribute("2")]
private void ValidateParam2(ParsedParameters& options, Token& param, string name);
    [NullableContextAttribute("0")]
private RestElement ParseRestElement(ArrayList`1& parameters);
    private void ParseFormalParameter(ParsedParameters& options);
    private ParsedParameters ParseFormalParameters(Nullable`1<Token> firstRestricted);
    private bool MatchAsyncFunction();
    private FunctionDeclaration ParseFunctionDeclaration(bool identifierIsOptional);
    private FunctionExpression ParseFunctionExpression();
    private ExpressionStatement ParseDirective();
    private ArrayList`1<Statement> ParseDirectivePrologues();
    private static bool QualifiedPropertyName(Token& token);
    private FunctionExpression ParseGetterMethod();
    private FunctionExpression ParseSetterMethod();
    private FunctionExpression ParseGeneratorMethod(bool isAsync);
    private FunctionExpression ParseMethod(bool isAsync, bool generator);
    [StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static bool IsPunctuatorExpressionStart(string input);
    [StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static bool IsKeywordExpressionStart(string input);
    private protected virtual bool IsStartOfExpression();
    private YieldExpression ParseYieldExpression();
    private StaticBlock ParseStaticBlock();
    private Decorator ParseDecorator();
    private ArrayList`1<Decorator> ParseDecorators();
    private ClassElement ParseClassElement(bool hasSuperClass, Boolean& hasConstructor);
    private ArrayList`1<ClassElement> ParseClassElementList(bool hasSuperClass);
    private ClassBody ParseClassBody(bool hasSuperClass);
    private ClassDeclaration ParseClassDeclarationCore(Marker& node, bool identifierIsOptional);
    private ClassDeclaration ParseClassDeclaration(bool identifierIsOptional);
    private ClassDeclaration ParseDecoratedClassDeclaration(bool identifierIsOptional);
    private ClassExpression ParseClassExpression();
    private Literal ParseModuleSpecifier();
    private ArrayList`1<ImportAttribute> ParseImportAttributes();
    private ImportAttribute ParseImportAttribute();
    private ImportSpecifier ParseImportSpecifier();
    private ArrayList`1<ImportSpecifier> ParseNamedImports();
    private ImportDefaultSpecifier ParseImportDefaultSpecifier();
    private ImportNamespaceSpecifier ParseImportNamespaceSpecifier();
    private ImportDeclaration ParseImportDeclaration();
    private ExportSpecifier ParseExportSpecifier();
    private ExportDeclaration ParseExportDeclaration();
    [DoesNotReturnAttribute]
internal void ThrowError(string messageFormat, Object[] values);
    [DoesNotReturnAttribute]
internal T ThrowError(string messageFormat, Object[] values);
    private ParseError CreateError(string messageFormat, Object[] values);
    private protected void TolerateError(string messageFormat, Object[] values);
    private ParseError UnexpectedTokenError(Token& token, string message);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
private protected T ThrowUnexpectedToken(Token& token, string message);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
private protected void ThrowUnexpectedToken(Token& token, string message);
    [NullableContextAttribute("2")]
private protected void TolerateUnexpectedToken(Token& token, string message);
    private void TolerateInvalidLoopStatement();
    [CompilerGeneratedAttribute]
internal static void <ParseBinaryExpression>g__UpdateNullishCoalescingRestrictions|107_0(Token& t, Boolean& allowAndOr, Boolean& allowNullishCoalescing);
    [CompilerGeneratedAttribute]
internal static bool <MatchAsyncFunction>g__ValidateMatch|160_0(Scanner scanner, Context context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.JsxParser : JavaScriptParser {
    private static Dictionary`2<string, string> XHTMLEntities;
    public JsxParser(JsxParserOptions options);
    private static JsxParser();
    private protected virtual Expression ParsePrimaryExpression();
    private protected virtual bool IsStartOfExpression();
    private void StartJsx();
    private void FinishJsx();
    private void ReEnterJsx();
    private Marker CreateJsxNode();
    private Marker CreateJsxChildNode();
    private string ScanXHTMLEntity(char quote);
    private Token LexJsx();
    private SyntaxToken ConvertJsxToken(Token& token);
    private Token NextJsxToken();
    private Token NextJsxText();
    private Token PeekJsxToken();
    private void ExpectJsx(string value);
    private bool MatchJsx(string value);
    private JsxIdentifier ParseJsxIdentifier();
    private JsxExpression ParseJsxElementName();
    private JsxExpression ParseJsxAttributeName();
    private Literal ParseJsxStringLiteralAttribute();
    private JsxExpressionContainer ParseJsxExpressionAttribute();
    private Expression ParseJsxAttributeValue();
    private JsxAttribute ParseJsxNameValueAttribute();
    private JsxSpreadAttribute ParseJsxSpreadAttribute();
    private NodeList`1<JsxExpression> ParseJsxAttributes();
    private JsxExpression ParseJsxOpeningElement();
    private JsxExpression ParseJsxBoundartElement();
    private JsxEmptyExpression ParseJsxEmptyExpression();
    private JsxExpressionContainer ParseJsxExpressionContainer();
    private ArrayList`1<JsxExpression> ParseJsxChildren();
    private MetaJsxElement ParseComplexJsxElement(MetaJsxElement el);
    private JsxElement ParseJsxElement();
    private JsxElement ParseJsxRoot();
    private static string GetQualifiedElementName(JsxExpression elementName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.JsxParserOptions : ParserOptions {
    public static JsxParserOptions Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected JsxParserOptions(JsxParserOptions original);
    private static JsxParserOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(JsxParserOptions left, JsxParserOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(JsxParserOptions left, JsxParserOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ParserOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(JsxParserOptions other);
    [CompilerGeneratedAttribute]
public virtual ParserOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Esprima.JsxToken : object {
    internal static Token CreateIdentifier(string value, int start, int end, int lineNumber, int lineStart);
    internal static Token CreateText(string value, int start, int end, int lineNumber, int lineStart);
    [ExtensionAttribute]
public static JsxTokenType JsxTokenType(Token& token);
}
public enum Esprima.JsxTokenType : Enum {
    public int value__;
    public static JsxTokenType Unknown;
    public static JsxTokenType Identifier;
    public static JsxTokenType Text;
}
internal enum Esprima.LegacyOctalKind : Enum {
    public byte value__;
    public static LegacyOctalKind None;
    public static LegacyOctalKind Octal;
    public static LegacyOctalKind Escaped8or9;
}
[IsReadOnlyAttribute]
internal class Esprima.LexOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIdentifierEscape>k__BackingField;
    public bool Strict { get; public set; }
    public bool AllowIdentifierEscape { get; public set; }
    public LexOptions(bool Strict, bool AllowIdentifierEscape);
    [NullableContextAttribute("1")]
public LexOptions(Context context);
    [CompilerGeneratedAttribute]
public bool get_Strict();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Strict(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowIdentifierEscape();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowIdentifierEscape(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(LexOptions left, LexOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(LexOptions left, LexOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LexOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& Strict, Boolean& AllowIdentifierEscape);
}
[IsReadOnlyAttribute]
public class Esprima.Location : ValueType {
    public Position Start;
    public Position End;
    [NullableAttribute("2")]
public string Source;
    internal Location(Position start, Position end);
    [NullableContextAttribute("2")]
internal Location(Position start, Position end, string source);
    private static bool Validate(Position start, Position end, bool throwOnError);
    [NullableContextAttribute("2")]
public static Location From(Position start, Position end, string source);
    public Location WithPosition(Position start, Position end);
    [NullableContextAttribute("1")]
public Location WithSource(string source);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(Location& other);
    private sealed virtual override bool System.IEquatable<Esprima.Location>.Equals(Location other);
    public static bool op_Equality(Location& left, Location& right);
    public static bool op_Inequality(Location& left, Location& right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    private static bool TryParseCore(ReadOnlySpan`1<char> s, bool throwIfInvalid, Location& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Location& result);
    [NullableContextAttribute("1")]
public static bool TryParse(string s, Location& result);
    public static Location Parse(ReadOnlySpan`1<char> s);
    [NullableContextAttribute("1")]
public static Location Parse(string s);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Position& start, Position& end);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public void Deconstruct(Position& start, Position& end, String& source);
}
[IsReadOnlyAttribute]
internal class Esprima.Marker : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Index { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public Marker(int Index, int Line, int Column);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Column(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Marker left, Marker right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Marker left, Marker right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Marker other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Index, Int32& Line, Int32& Column);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Esprima.Messages : object {
    public static string ArgumentsNotAllowedInClassField;
    public static string AsyncFunctionInSingleStatementContext;
    public static string BadGetterArity;
    public static string BadSetterArity;
    public static string BadSetterRestParameter;
    public static string CannotUseAwaitInClassStaticBlock;
    public static string CannotUseImportMetaOutsideAModule;
    public static string CannotUseImportWithNew;
    public static string ConstructorIsAccessor;
    public static string ConstructorIsAsync;
    public static string ConstructorIsField;
    public static string ConstructorIsGenerator;
    public static string DeclarationMissingInitializer;
    public static string DefaultRestParameter;
    public static string DefaultRestProperty;
    public static string DuplicateBinding;
    public static string DuplicateConstructor;
    public static string DuplicateParameter;
    public static string DuplicateProtoProperty;
    public static string DuplicateKeyInImportAttributes;
    public static string ForInOfLoopInitializer;
    public static string GeneratorInLegacyContext;
    public static string IllegalBreak;
    public static string IllegalContinue;
    public static string IllegalExportDeclaration;
    public static string IllegalImportDeclaration;
    public static string IllegalLanguageModeDirective;
    public static string IllegalReturn;
    public static string InvalidDecoratorMemberExpression;
    public static string InvalidEscapedReservedWord;
    public static string InvalidHexEscapeSequence;
    public static string InvalidLHSInAssignment;
    public static string InvalidLHSInForIn;
    public static string InvalidLHSInForLoop;
    public static string InvalidModuleSpecifier;
    public static string InvalidOptionalChainFromNewExpression;
    public static string InvalidRegExpFlags;
    public static string InvalidTaggedTemplateOnOptionalChain;
    public static string InvalidUnicodeEscapeSequence;
    public static string LetInLexicalBinding;
    public static string MissingFromClause;
    public static string MultipleDefaultsInSwitch;
    public static string NewlineAfterThrow;
    public static string NewTargetNotAllowedHere;
    public static string NoAsAfterImportNamespace;
    public static string NoCatchOrFinally;
    public static string NoSemicolonAfterDecorator;
    public static string NumericSeparatorAfterLeadingZero;
    public static string NumericSeparatorNotAllowedHere;
    public static string NumericSeparatorOneUnderscore;
    public static string ParameterAfterRestParameter;
    public static string PrivateFieldNoDelete;
    public static string PrivateFieldOutsideClass;
    public static string PropertyAfterRestProperty;
    public static string Redeclaration;
    public static string RegExpDuplicateCaptureGroupName;
    public static string RegExpIncompleteQuantifier;
    public static string RegExpInvalidCaptureGroupName;
    public static string RegExpInvalidEscape;
    public static string RegExpInvalidDecimalEscape;
    public static string RegExpInvalidCharacterClass;
    public static string RegExpInvalidClassEscape;
    public static string RegExpInvalidGroup;
    public static string RegExpInvalidPropertyName;
    public static string RegExpInvalidPropertyNameInCharacterClass;
    public static string RegExpInvalidNamedCaptureReferenced;
    public static string RegExpInvalidNamedReference;
    public static string RegExpInvalidQuantifier;
    public static string RegExpInvalidUnicodeEscape;
    public static string RegExpLoneQuantifierBrackets;
    public static string RegExpNothingToRepeat;
    public static string RegExpNumbersOutOfOrderInQuantifier;
    public static string RegExpRangeOutOfOrderInCharacterClass;
    public static string RegExpUnmatchedOpenParen;
    public static string RegExpUnterminatedCharacterClass;
    public static string RegExpUnterminatedGroup;
    public static string StaticPrototype;
    public static string StrictCatchVariable;
    public static string StrictDecimalWithLeadingZero;
    public static string StrictDelete;
    public static string StrictEscape89;
    public static string StrictFunction;
    public static string StrictFunctionName;
    public static string StrictLHSAssignment;
    public static string StrictLHSPostfix;
    public static string StrictLHSPrefix;
    public static string StrictModeWith;
    public static string StrictOctalEscape;
    public static string StrictOctalLiteral;
    public static string StrictParamName;
    public static string StrictReservedWord;
    public static string StrictVarName;
    public static string TemplateEscape89;
    public static string TemplateOctalLiteral;
    public static string UndefinedUnicodeCodePoint;
    public static string UnexpectedEOS;
    public static string UnexpectedIdentifier;
    public static string UnexpectedNumber;
    public static string UnexpectedPrivateField;
    public static string UnexpectedReserved;
    public static string UnexpectedString;
    public static string UnexpectedSuper;
    public static string UnexpectedTemplate;
    public static string UnexpectedToken;
    public static string UnexpectedTokenIllegal;
    public static string UnknownLabel;
    public static string UnterminatedRegExp;
    public static string InvalidUnicodeKeyword;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.ParseError : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <Position>k__BackingField;
    public string Description { get; }
    [NullableAttribute("2")]
public string Source { get; }
    public bool IsIndexDefined { get; }
    public int Index { get; }
    public bool IsPositionDefined { get; }
    public Position Position { get; }
    public int LineNumber { get; }
    public int Column { get; }
    public ParseError(string description, string source, int index, Position position);
    [CompilerGeneratedAttribute]
public string get_Description();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Source();
    public bool get_IsIndexDefined();
    [CompilerGeneratedAttribute]
public int get_Index();
    public bool get_IsPositionDefined();
    [CompilerGeneratedAttribute]
public Position get_Position();
    public int get_LineNumber();
    public int get_Column();
    public virtual string ToString();
    public ParserException ToException();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Esprima.ParserException : Exception {
    [CompilerGeneratedAttribute]
private ParseError <Error>k__BackingField;
    public ParseError Error { get; }
    public string Description { get; }
    public string SourceLocation { get; }
    public int Index { get; }
    public int LineNumber { get; }
    public int Column { get; }
    [NullableContextAttribute("1")]
public ParserException(ParseError error);
    public ParserException(string message, Exception innerException, ParseError error);
    [CompilerGeneratedAttribute]
public ParseError get_Error();
    public string get_Description();
    public string get_SourceLocation();
    public int get_Index();
    public int get_LineNumber();
    public int get_Column();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Esprima.ParserExtensions : object {
    private static int MethodImplOptionsAggressiveOptimization;
    internal static object s_boxedTrue;
    internal static object s_boxedFalse;
    private static String[] s_charToString;
    private static ParserExtensions();
    [ExtensionAttribute]
public static object AsCachedObject(bool value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static ReadOnlySpan`1<char> Between(string s, int start, int end);
    [ExtensionAttribute]
public static T& modreq(System.Runtime.InteropServices.InAttribute) Last(ReadOnlySpan`1<T> span);
    [ExtensionAttribute]
public static T& Last(Span`1<T> span);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static ReadOnlySpan`1<char> ToParsable(ReadOnlySpan`1<char> s);
    [ExtensionAttribute]
internal static int FindIndex(ReadOnlySpan`1<T> s, Predicate`1<T> match, int startIndex);
    [ExtensionAttribute]
internal static int FindIndex(string s, Predicate`1<char> match, int startIndex);
    [ExtensionAttribute]
internal static string Replace(string s, Predicate`1<char> match, char c);
    [NullableContextAttribute("0")]
[StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string TryGetInternedString(ReadOnlySpan`1<char> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static string ToInternedString(ReadOnlySpan`1<char> source, StringPool& stringPool);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static string ToInternedString(ReadOnlySpan`1<char> source, StringPool& stringPool, int interningThreshold);
    internal static string CharToString(char c);
    [ExtensionAttribute]
internal static StringBuilder AppendCodePoint(StringBuilder sb, int cp);
    [ExtensionAttribute]
public static int CodePointAt(string text, int i);
    [ExtensionAttribute]
internal static char CharCodeAt(string source, int index);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool TryConsumeInt(ReadOnlySpan`1& s, Int32& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.ParserOptions : object {
    public static ParserOptions Default;
    private ScannerOptions _scannerOptions;
    [CompilerGeneratedAttribute]
private bool <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowReturnOutsideFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAssignmentDepth>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<Node> <OnNodeCreated>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool Tokens { get; public set; }
    public bool Comments { get; public set; }
    public bool Tolerant { get; public set; }
    public bool AllowReturnOutsideFunction { get; public set; }
    public ErrorHandler ErrorHandler { get; public set; }
    public RegExpParseMode RegExpParseMode { get; public set; }
    public TimeSpan RegexTimeout { get; public set; }
    public int MaxAssignmentDepth { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<Node> OnNodeCreated { get; public set; }
    protected ParserOptions(ParserOptions original);
    private static ParserOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public ScannerOptions GetScannerOptions();
    [CompilerGeneratedAttribute]
public bool get_Tokens();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Tokens(bool value);
    public bool get_Comments();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Comments(bool value);
    public bool get_Tolerant();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Tolerant(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowReturnOutsideFunction();
    [CompilerGeneratedAttribute]
public void set_AllowReturnOutsideFunction(bool value);
    public ErrorHandler get_ErrorHandler();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ErrorHandler(ErrorHandler value);
    public RegExpParseMode get_RegExpParseMode();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RegExpParseMode(RegExpParseMode value);
    public TimeSpan get_RegexTimeout();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RegexTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxAssignmentDepth();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MaxAssignmentDepth(int value);
    [CompilerGeneratedAttribute]
public Action`1<Node> get_OnNodeCreated();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OnNodeCreated(Action`1<Node> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ParserOptions left, ParserOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ParserOptions left, ParserOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ParserOptions other);
    [CompilerGeneratedAttribute]
public virtual ParserOptions <Clone>$();
}
[IsReadOnlyAttribute]
public class Esprima.Position : ValueType {
    public int Line;
    public int Column;
    internal Position(int line, int column);
    private static bool Validate(int line, int column, bool throwOnError);
    public static Position From(int line, int column);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Position other);
    public sealed virtual int CompareTo(Position other);
    public static bool op_Equality(Position left, Position right);
    public static bool op_Inequality(Position left, Position right);
    public static bool op_LessThan(Position left, Position right);
    public static bool op_LessThanOrEqual(Position left, Position right);
    public static bool op_GreaterThan(Position left, Position right);
    public static bool op_GreaterThanOrEqual(Position left, Position right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    private static bool TryParseCore(ReadOnlySpan`1<char> s, bool throwIfInvalid, Position& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Position& result);
    [NullableContextAttribute("1")]
public static bool TryParse(string s, Position& result);
    public static Position Parse(ReadOnlySpan`1<char> s);
    [NullableContextAttribute("1")]
public static Position Parse(string s);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Int32& line, Int32& column);
}
[IsReadOnlyAttribute]
public class Esprima.Range : ValueType {
    public int Start;
    public int End;
    public int Length { get; }
    internal Range(int start, int end);
    public int get_Length();
    private static bool Validate(int start, int end, bool throwOnError);
    public static Range From(int start, int end);
    public sealed virtual bool Equals(Range other);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Range left, Range right);
    public static bool op_Inequality(Range left, Range right);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    private static bool TryParseCore(ReadOnlySpan`1<char> s, bool throwIfInvalid, Range& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Range& result);
    [NullableContextAttribute("1")]
public static bool TryParse(string s, Range& result);
    public static Range Parse(ReadOnlySpan`1<char> s);
    [NullableContextAttribute("1")]
public static Range Parse(string s);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Int32& start, Int32& end);
    public Range ToSystemRange();
}
public enum Esprima.RegExpParseMode : Enum {
    public int value__;
    public static RegExpParseMode Skip;
    public static RegExpParseMode Validate;
    public static RegExpParseMode AdaptToInterpreted;
    public static RegExpParseMode AdaptToCompiled;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Esprima.RegExpParseResult : ValueType {
    private object _regexOrConversionError;
    [NullableAttribute("0")]
private ArrayList`1<RegExpCapturingGroup> _capturingGroups;
    public bool Success { get; }
    public ParseError ConversionError { get; }
    public Regex Regex { get; }
    public int ActualRegexGroupCount { get; }
    [NullableContextAttribute("0")]
internal RegExpParseResult(Regex regex, ArrayList`1<RegExpCapturingGroup> capturingGroups);
    internal RegExpParseResult(ParseError conversionError);
    public bool get_Success();
    public ParseError get_ConversionError();
    public Regex get_Regex();
    public int get_ActualRegexGroupCount();
    public string GetRegexGroupName(int number);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Scanner : object {
    internal static int NonIdentifierInterningThreshold;
    private ErrorHandler _errorHandler;
    private bool _tolerant;
    private bool _trackComment;
    private RegExpParseMode _regExpParseMode;
    private TimeSpan _regexTimeout;
    private int _length;
    internal string _source;
    [NullableAttribute("2")]
internal string _sourceLocation;
    internal int _index;
    internal int _lineNumber;
    internal int _lineStart;
    internal bool _isModule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayList`1<string> _curlyStack;
    private StringBuilder _sb;
    internal StringPool _stringPool;
    [NullableAttribute("2")]
internal Cache _codePointRangeCache;
    public string Code { get; }
    public int Index { get; }
    public int LineNumber { get; }
    public int LineStart { get; }
    internal Scanner(ScannerOptions options);
    public Scanner(string code);
    public Scanner(string code, ScannerOptions options);
    public Scanner(string code, string source);
    public Scanner(string code, string source, ScannerOptions options);
    private static int OctalValue(char ch);
    public void Reset();
    public void Reset(int startIndex, int lineNumber, int lineStartIndex);
    internal void Reset(string code, string source);
    internal void Reset(string code, string source, int startIndex, int lineNumber, int lineStartIndex);
    internal void ReleaseLargeBuffers();
    public string get_Code();
    public int get_Index();
    public int get_LineNumber();
    public int get_LineStart();
    internal ScannerState SaveState();
    internal void RestoreState(ScannerState& state);
    internal bool Eof();
    [DoesNotReturnAttribute]
private void ThrowUnexpectedToken(string message);
    [DoesNotReturnAttribute]
private T ThrowUnexpectedToken(string message);
    private ParseError TolerateUnexpectedToken(string message);
    private StringBuilder GetStringBuilder();
    [StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool IsFutureReservedWord(string id);
    [StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool IsStrictModeReservedWord(string id);
    public static bool IsRestrictedWord(string id);
    [NullableContextAttribute("0")]
[StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static string TryGetInternedTwoCharacterPunctuator(ReadOnlySpan`1<char> id);
    [NullableContextAttribute("0")]
[StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static string TryGetInternedThreeCharacterPunctuator(ReadOnlySpan`1<char> id);
    [StringMatcherAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool IsKeyword(string id);
    [NullableContextAttribute("0")]
private ArrayList`1<Comment> SkipSingleLineComment(int offset);
    [NullableContextAttribute("0")]
private ArrayList`1<Comment> SkipMultiLineComment();
    [NullableContextAttribute("0")]
internal ArrayList`1<Comment> ScanCommentsInternal();
    [NullableContextAttribute("0")]
public ReadOnlySpan`1<Comment> ScanComments();
    private bool ScanHexEscape(char prefix, Char& result);
    private bool TryScanUnicodeCodePointEscape(Int32& code);
    private int ScanUnicodeCodePointEscape();
    private string GetIdentifier(bool allowEscapedSurrogates);
    private string GetComplexIdentifier(bool allowEscapedSurrogates);
    private bool TryGetEscapedSurrogate(char highSurrogate, Int32& cp);
    private int OctalToDecimal(char ch, Int32& length);
    private Token ScanIdentifier(bool allowEscapes);
    private Token ScanPunctuator();
    private Token ScanHexLiteral(int start);
    [NullableContextAttribute("0")]
private static double ParseIntAsDouble(ReadOnlySpan`1<char> number, byte fromBase);
    [NullableContextAttribute("0")]
private Token ScanBigIntLiteral(int start, ReadOnlySpan`1<char> number, JavaScriptNumberStyle style);
    private Token ScanBinaryLiteral(int start);
    private Token ScanOctalLiteral(char prefix, int start, bool isLegacyOctalDigital);
    private bool IsImplicitOctalLiteral();
    [NullableContextAttribute("0")]
private ReadOnlySpan`1<char> ScanLiteralPart(Func`2<char, bool> check, bool allowNumericSeparator);
    private Token ScanNumericLiteral(bool strict);
    private Token ScanStringLiteral(bool strict);
    private Token ScanTemplate();
    public static bool ValidateRegExp(string pattern, string flags, ParseError& error);
    public static RegExpParseResult AdaptRegExp(string pattern, string flags, bool compiled, Nullable`1<TimeSpan> matchTimeout, bool throwIfNotAdaptable);
    private string ScanRegExpBody();
    private string ScanRegExpFlags();
    internal Token ScanRegExp();
    public Token Lex();
    internal Token Lex(LexOptions& options);
    internal Marker GetMarker();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.ScannerOptions : object {
    public static ScannerOptions Default;
    internal bool _comments;
    internal bool _tolerant;
    internal ErrorHandler _errorHandler;
    internal RegExpParseMode _regExpParseMode;
    internal TimeSpan _regexTimeout;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool Comments { get; public set; }
    public bool Tolerant { get; public set; }
    public ErrorHandler ErrorHandler { get; public set; }
    public RegExpParseMode RegExpParseMode { get; public set; }
    public TimeSpan RegexTimeout { get; public set; }
    [CompilerGeneratedAttribute]
protected ScannerOptions(ScannerOptions original);
    private static ScannerOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public bool get_Comments();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Comments(bool value);
    public bool get_Tolerant();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Tolerant(bool value);
    public ErrorHandler get_ErrorHandler();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ErrorHandler(ErrorHandler value);
    public RegExpParseMode get_RegExpParseMode();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RegExpParseMode(RegExpParseMode value);
    public TimeSpan get_RegexTimeout();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RegexTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ScannerOptions left, ScannerOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ScannerOptions left, ScannerOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ScannerOptions other);
    [CompilerGeneratedAttribute]
public virtual ScannerOptions <Clone>$();
}
[IsReadOnlyAttribute]
internal class Esprima.ScannerState : ValueType {
    public int Index;
    public int LineNumber;
    public int LineStart;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ArrayList`1<string> CurlyStack;
    public ScannerState(int index, int lineNumber, int lineStart, ArrayList`1<string> curlyStack);
}
internal static class Esprima.Shims : object {
    public static UnicodeCategory GetUnicodeCategory(int codePoint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class Esprima.StringMatcherAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    public String[] Targets { get; }
    public StringMatcherAttribute(String[] targets);
    [CompilerGeneratedAttribute]
public String[] get_Targets();
}
internal class Esprima.StringPool : ValueType {
    private static int MinAllocatedCount;
    [NullableAttribute("2")]
private Int32[] _buckets;
    [NullableAttribute("2")]
private Entry[] _entries;
    private int _count;
    public int Count { get; }
    public int get_Count();
    private int Initialize(int capacity);
    private void Resize(int newSize);
    private Int32& GetBucketRef(int hashCode);
    public string GetOrCreate(ReadOnlySpan`1<char> value);
    private static int GetHashCode(ReadOnlySpan`1<char> span);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Esprima.Token : ValueType {
    internal object _value;
    public TokenType Type;
    internal LegacyOctalKind OctalKind;
    public int Start;
    public int End;
    public int LineNumber;
    public int LineStart;
    public bool Octal { get; }
    public object Value { get; }
    internal char NotEscapeSequenceHead { get; }
    public bool Head { get; }
    public bool Tail { get; }
    public string RawTemplate { get; }
    public RegExpParseResult RegExpParseResult { get; }
    public RegexValue RegexValue { get; }
    internal Token(TokenType type, object value, int start, int end, int lineNumber, int lineStart, LegacyOctalKind octalKind);
    internal static Token Create(TokenType type, object value, int start, int end, int lineNumber, int lineStart);
    [NullableContextAttribute("1")]
internal static Token CreateStringLiteral(string str, LegacyOctalKind octalKind, int start, int end, int lineNumber, int lineStart);
    [NullableContextAttribute("1")]
internal static Token CreateRegExpLiteral(RegExpParseResult parseResult, RegexValue regexValue, int start, int end, int lineNumber, int lineStart);
    internal static Token CreateNumericLiteral(double value, bool octal, int start, int end, int lineNumber, int lineStart);
    internal static Token CreateBigIntLiteral(BigInteger value, int start, int end, int lineNumber, int lineStart);
    internal static Token CreateEof(int index, int lineNumber, int lineStart);
    [NullableContextAttribute("1")]
internal static Token CreatePunctuator(string str, int start, int end, int lineNumber, int lineStart);
    [NullableContextAttribute("1")]
internal static Token CreateTemplate(string cooked, string rawTemplate, bool head, bool tail, char notEscapeSequenceHead, int start, int end, int lineNumber, int lineStart);
    public bool get_Octal();
    public object get_Value();
    internal char get_NotEscapeSequenceHead();
    public bool get_Head();
    public bool get_Tail();
    public string get_RawTemplate();
    public RegExpParseResult get_RegExpParseResult();
    public RegexValue get_RegexValue();
    internal Token ChangeType(TokenType newType);
    [NullableContextAttribute("1")]
internal bool IsEscaped(string value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Token left, Token right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Token left, Token right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Token other);
    [CompilerGeneratedAttribute]
internal static object <get_Value>g__GetValueFromHolder|22_0(Token& token);
}
public enum Esprima.TokenType : Enum {
    public byte value__;
    public static TokenType Unknown;
    public static TokenType BooleanLiteral;
    public static TokenType EOF;
    public static TokenType Identifier;
    public static TokenType Keyword;
    public static TokenType NullLiteral;
    public static TokenType NumericLiteral;
    public static TokenType Punctuator;
    public static TokenType StringLiteral;
    public static TokenType RegularExpression;
    public static TokenType Template;
    public static TokenType BigIntLiteral;
    public static TokenType Extension;
}
internal class Esprima.Utils.AdditionalDataHolder : ValueType {
    [NullableAttribute("2")]
public object Data;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Esprima.Utils.AdditionalDataSlot : ValueType {
    private object _data;
    public object PrimaryData { get; public set; }
    public object Item { get; public set; }
    private static Object& GetPrimaryDataRef(AdditionalDataSlot& slot);
    public object get_PrimaryData();
    public void set_PrimaryData(object value);
    public object get_Item(int index);
    public void set_Item(int index, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AutoGeneratedAstVisitorAttribute]
public class Esprima.Utils.AstRewriter : AstVisitor {
    public virtual T VisitAndConvert(T node, bool allowNull, string callerName);
    [NullableContextAttribute("2")]
public virtual bool VisitAndConvert(NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) nodes, NodeList`1& newNodes, bool allowNullElement, string callerName);
    protected internal virtual object VisitExportSpecifier(ExportSpecifier exportSpecifier);
    protected internal virtual object VisitImportSpecifier(ImportSpecifier importSpecifier);
    protected internal virtual object VisitProperty(Property property);
    protected internal virtual object VisitAccessorProperty(AccessorProperty accessorProperty);
    protected internal virtual object VisitArrayExpression(ArrayExpression arrayExpression);
    protected internal virtual object VisitArrayPattern(ArrayPattern arrayPattern);
    protected internal virtual object VisitArrowFunctionExpression(ArrowFunctionExpression arrowFunctionExpression);
    protected internal virtual object VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    protected internal virtual object VisitAssignmentPattern(AssignmentPattern assignmentPattern);
    protected internal virtual object VisitAwaitExpression(AwaitExpression awaitExpression);
    protected internal virtual object VisitBinaryExpression(BinaryExpression binaryExpression);
    protected internal virtual object VisitBlockStatement(BlockStatement blockStatement);
    protected internal virtual object VisitBreakStatement(BreakStatement breakStatement);
    protected internal virtual object VisitCallExpression(CallExpression callExpression);
    protected internal virtual object VisitCatchClause(CatchClause catchClause);
    protected internal virtual object VisitChainExpression(ChainExpression chainExpression);
    protected internal virtual object VisitClassBody(ClassBody classBody);
    protected internal virtual object VisitClassDeclaration(ClassDeclaration classDeclaration);
    protected internal virtual object VisitClassExpression(ClassExpression classExpression);
    protected internal virtual object VisitConditionalExpression(ConditionalExpression conditionalExpression);
    protected internal virtual object VisitContinueStatement(ContinueStatement continueStatement);
    protected internal virtual object VisitDecorator(Decorator decorator);
    protected internal virtual object VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    protected internal virtual object VisitExportAllDeclaration(ExportAllDeclaration exportAllDeclaration);
    protected internal virtual object VisitExportDefaultDeclaration(ExportDefaultDeclaration exportDefaultDeclaration);
    protected internal virtual object VisitExportNamedDeclaration(ExportNamedDeclaration exportNamedDeclaration);
    protected internal virtual object VisitExpressionStatement(ExpressionStatement expressionStatement);
    protected internal virtual object VisitForInStatement(ForInStatement forInStatement);
    protected internal virtual object VisitForOfStatement(ForOfStatement forOfStatement);
    protected internal virtual object VisitForStatement(ForStatement forStatement);
    protected internal virtual object VisitFunctionDeclaration(FunctionDeclaration functionDeclaration);
    protected internal virtual object VisitFunctionExpression(FunctionExpression functionExpression);
    protected internal virtual object VisitIfStatement(IfStatement ifStatement);
    protected internal virtual object VisitImportAttribute(ImportAttribute importAttribute);
    protected internal virtual object VisitImportDeclaration(ImportDeclaration importDeclaration);
    protected internal virtual object VisitImportDefaultSpecifier(ImportDefaultSpecifier importDefaultSpecifier);
    protected internal virtual object VisitImportExpression(ImportExpression importExpression);
    protected internal virtual object VisitImportNamespaceSpecifier(ImportNamespaceSpecifier importNamespaceSpecifier);
    protected internal virtual object VisitLabeledStatement(LabeledStatement labeledStatement);
    protected internal virtual object VisitMemberExpression(MemberExpression memberExpression);
    protected internal virtual object VisitMetaProperty(MetaProperty metaProperty);
    protected internal virtual object VisitMethodDefinition(MethodDefinition methodDefinition);
    protected internal virtual object VisitNewExpression(NewExpression newExpression);
    protected internal virtual object VisitObjectExpression(ObjectExpression objectExpression);
    protected internal virtual object VisitObjectPattern(ObjectPattern objectPattern);
    protected internal virtual object VisitProgram(Program program);
    protected internal virtual object VisitPropertyDefinition(PropertyDefinition propertyDefinition);
    protected internal virtual object VisitRestElement(RestElement restElement);
    protected internal virtual object VisitReturnStatement(ReturnStatement returnStatement);
    protected internal virtual object VisitSequenceExpression(SequenceExpression sequenceExpression);
    protected internal virtual object VisitSpreadElement(SpreadElement spreadElement);
    protected internal virtual object VisitStaticBlock(StaticBlock staticBlock);
    protected internal virtual object VisitSwitchCase(SwitchCase switchCase);
    protected internal virtual object VisitSwitchStatement(SwitchStatement switchStatement);
    protected internal virtual object VisitTaggedTemplateExpression(TaggedTemplateExpression taggedTemplateExpression);
    protected internal virtual object VisitTemplateLiteral(TemplateLiteral templateLiteral);
    protected internal virtual object VisitThrowStatement(ThrowStatement throwStatement);
    protected internal virtual object VisitTryStatement(TryStatement tryStatement);
    protected internal virtual object VisitUnaryExpression(UnaryExpression unaryExpression);
    protected internal virtual object VisitVariableDeclaration(VariableDeclaration variableDeclaration);
    protected internal virtual object VisitVariableDeclarator(VariableDeclarator variableDeclarator);
    protected internal virtual object VisitWhileStatement(WhileStatement whileStatement);
    protected internal virtual object VisitWithStatement(WithStatement withStatement);
    protected internal virtual object VisitYieldExpression(YieldExpression yieldExpression);
    [CompilerGeneratedAttribute]
internal static Exception <VisitAndConvert>g__MustRewriteToSameNodeNonNullable|0_0(Type nodeType, string callerName);
    [CompilerGeneratedAttribute]
internal static Exception <VisitAndConvert>g__MustRewriteToSameNodeNullable|0_1(Type nodeType, string callerName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Esprima.Utils.AstToJavaScript : object {
    [ExtensionAttribute]
public static string ToJavaScriptString(Node node);
    [ExtensionAttribute]
public static string ToJavaScriptString(Node node, KnRJavaScriptTextFormatterOptions formattingOptions);
    [ExtensionAttribute]
public static string ToJavaScriptString(Node node, bool format);
    [ExtensionAttribute]
public static string ToJavaScriptString(Node node, JavaScriptTextWriterOptions writerOptions, AstToJavaScriptOptions options);
    [ExtensionAttribute]
public static void WriteJavaScript(Node node, TextWriter writer);
    [ExtensionAttribute]
public static void WriteJavaScript(Node node, TextWriter writer, KnRJavaScriptTextFormatterOptions formattingOptions);
    [ExtensionAttribute]
public static void WriteJavaScript(Node node, TextWriter writer, bool format);
    [ExtensionAttribute]
public static void WriteJavaScript(Node node, TextWriter writer, JavaScriptTextWriterOptions writerOptions, AstToJavaScriptOptions options);
    [ExtensionAttribute]
public static void WriteJavaScript(Node node, JavaScriptTextWriter writer, AstToJavaScriptOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.AstToJavaScriptConverter : AstVisitor {
    private static object s_lastSwitchCaseFlag;
    private static object s_forLoopInitDeclarationFlag;
    private static object s_bindingPatternAllowsExpressionsFlag;
    private bool _ignoreExtensions;
    private WriteContext _writeContext;
    private StatementFlags _currentStatementFlags;
    private ExpressionFlags _currentExpressionFlags;
    [NullableAttribute("2")]
private object _currentAuxiliaryNodeContext;
    [CompilerGeneratedAttribute]
private JavaScriptTextWriter <Writer>k__BackingField;
    private protected static Func`4<AstToJavaScriptConverter, Statement, StatementFlags, StatementFlags> s_getCombinedStatementFlags;
    private protected static Func`4<AstToJavaScriptConverter, Expression, ExpressionFlags, ExpressionFlags> s_getCombinedRootExpressionFlags;
    private protected static Func`4<AstToJavaScriptConverter, Expression, ExpressionFlags, ExpressionFlags> s_getCombinedSubExpressionFlags;
    public JavaScriptTextWriter Writer { get; }
    protected WriteContext& WriteContext { get; }
    [NullableAttribute("2")]
protected Node ParentNode { get; }
    public AstToJavaScriptConverter(JavaScriptTextWriter writer, AstToJavaScriptOptions options);
    private static AstToJavaScriptConverter();
    [CompilerGeneratedAttribute]
public JavaScriptTextWriter get_Writer();
    protected WriteContext& get_WriteContext();
    [NullableContextAttribute("2")]
protected Node get_ParentNode();
    public void Convert(Node node);
    public virtual object Visit(Node node);
    protected internal virtual object VisitAccessorProperty(AccessorProperty accessorProperty);
    protected internal virtual object VisitArrayExpression(ArrayExpression arrayExpression);
    protected internal virtual object VisitArrayPattern(ArrayPattern arrayPattern);
    protected internal virtual object VisitArrowFunctionExpression(ArrowFunctionExpression arrowFunctionExpression);
    protected internal virtual object VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    protected internal virtual object VisitAssignmentPattern(AssignmentPattern assignmentPattern);
    protected internal virtual object VisitAwaitExpression(AwaitExpression awaitExpression);
    protected internal virtual object VisitBinaryExpression(BinaryExpression binaryExpression);
    protected internal virtual object VisitBlockStatement(BlockStatement blockStatement);
    protected internal virtual object VisitBreakStatement(BreakStatement breakStatement);
    protected internal virtual object VisitCallExpression(CallExpression callExpression);
    protected internal virtual object VisitCatchClause(CatchClause catchClause);
    protected internal virtual object VisitChainExpression(ChainExpression chainExpression);
    protected internal virtual object VisitClassBody(ClassBody classBody);
    protected internal virtual object VisitClassDeclaration(ClassDeclaration classDeclaration);
    protected internal virtual object VisitClassExpression(ClassExpression classExpression);
    protected internal virtual object VisitConditionalExpression(ConditionalExpression conditionalExpression);
    protected internal virtual object VisitContinueStatement(ContinueStatement continueStatement);
    protected internal virtual object VisitDebuggerStatement(DebuggerStatement debuggerStatement);
    protected internal virtual object VisitDecorator(Decorator decorator);
    protected internal virtual object VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    protected internal virtual object VisitEmptyStatement(EmptyStatement emptyStatement);
    protected internal virtual object VisitExportAllDeclaration(ExportAllDeclaration exportAllDeclaration);
    protected internal virtual object VisitExportDefaultDeclaration(ExportDefaultDeclaration exportDefaultDeclaration);
    protected internal virtual object VisitExportNamedDeclaration(ExportNamedDeclaration exportNamedDeclaration);
    protected internal virtual object VisitExportSpecifier(ExportSpecifier exportSpecifier);
    protected internal virtual object VisitExpressionStatement(ExpressionStatement expressionStatement);
    protected internal virtual object VisitExtension(Node node);
    protected internal virtual object VisitForInStatement(ForInStatement forInStatement);
    protected internal virtual object VisitForOfStatement(ForOfStatement forOfStatement);
    protected internal virtual object VisitForStatement(ForStatement forStatement);
    protected internal virtual object VisitFunctionDeclaration(FunctionDeclaration functionDeclaration);
    protected internal virtual object VisitFunctionExpression(FunctionExpression functionExpression);
    protected internal virtual object VisitIdentifier(Identifier identifier);
    protected internal virtual object VisitIfStatement(IfStatement ifStatement);
    protected internal virtual object VisitImportAttribute(ImportAttribute importAttribute);
    protected internal virtual object VisitImportDeclaration(ImportDeclaration importDeclaration);
    protected internal virtual object VisitImportDefaultSpecifier(ImportDefaultSpecifier importDefaultSpecifier);
    protected internal virtual object VisitImportExpression(ImportExpression importExpression);
    protected internal virtual object VisitImportNamespaceSpecifier(ImportNamespaceSpecifier importNamespaceSpecifier);
    protected internal virtual object VisitImportSpecifier(ImportSpecifier importSpecifier);
    protected internal virtual object VisitLabeledStatement(LabeledStatement labeledStatement);
    protected internal virtual object VisitLiteral(Literal literal);
    protected internal virtual object VisitMemberExpression(MemberExpression memberExpression);
    protected internal virtual object VisitMetaProperty(MetaProperty metaProperty);
    protected internal virtual object VisitMethodDefinition(MethodDefinition methodDefinition);
    protected internal virtual object VisitNewExpression(NewExpression newExpression);
    protected internal virtual object VisitObjectExpression(ObjectExpression objectExpression);
    protected internal virtual object VisitObjectPattern(ObjectPattern objectPattern);
    protected internal virtual object VisitPrivateIdentifier(PrivateIdentifier privateIdentifier);
    protected internal virtual object VisitProgram(Program program);
    protected internal virtual object VisitProperty(Property property);
    protected internal virtual object VisitPropertyDefinition(PropertyDefinition propertyDefinition);
    protected internal virtual object VisitRestElement(RestElement restElement);
    protected internal virtual object VisitReturnStatement(ReturnStatement returnStatement);
    protected internal virtual object VisitSequenceExpression(SequenceExpression sequenceExpression);
    protected internal virtual object VisitSpreadElement(SpreadElement spreadElement);
    protected internal virtual object VisitStaticBlock(StaticBlock staticBlock);
    protected internal virtual object VisitSuper(Super super);
    protected internal virtual object VisitSwitchCase(SwitchCase switchCase);
    protected internal virtual object VisitSwitchStatement(SwitchStatement switchStatement);
    protected internal virtual object VisitTaggedTemplateExpression(TaggedTemplateExpression taggedTemplateExpression);
    protected internal virtual object VisitTemplateElement(TemplateElement templateElement);
    protected internal virtual object VisitTemplateLiteral(TemplateLiteral templateLiteral);
    protected internal virtual object VisitThisExpression(ThisExpression thisExpression);
    protected internal virtual object VisitThrowStatement(ThrowStatement throwStatement);
    protected internal virtual object VisitTryStatement(TryStatement tryStatement);
    protected internal virtual object VisitUnaryExpression(UnaryExpression unaryExpression);
    protected internal virtual object VisitVariableDeclaration(VariableDeclaration variableDeclaration);
    protected internal virtual object VisitVariableDeclarator(VariableDeclarator variableDeclarator);
    protected internal virtual object VisitWhileStatement(WhileStatement whileStatement);
    protected internal virtual object VisitWithStatement(WithStatement withStatement);
    protected internal virtual object VisitYieldExpression(YieldExpression yieldExpression);
    private protected static StatementFlags StatementBodyFlags(bool isRightMost);
    private protected static TokenFlags StatementBodyFlagsToKeywordFlags(StatementFlags previousBodyFlags);
    protected StatementFlags PropagateStatementFlags(StatementFlags flags);
    protected void VisitStatement(Statement statement, StatementFlags flags);
    protected void VisitStatement(Statement statement, StatementFlags flags, Func`4<AstToJavaScriptConverter, Statement, StatementFlags, StatementFlags> getCombinedFlags);
    protected void VisitStatementList(NodeList`1& statementList);
    protected void VisitStatementList(NodeList`1& statementList, Func`5<AstToJavaScriptConverter, Statement, int, int, StatementFlags> getCombinedItemFlags);
    protected void VisitStatementListItem(Statement statement, int index, int count, Func`5<AstToJavaScriptConverter, Statement, int, int, StatementFlags> getCombinedFlags);
    protected void StatementNeedsSemicolon();
    private protected static ExpressionFlags RootExpressionFlags(bool needsBrackets);
    private protected static ExpressionFlags SubExpressionFlags(bool needsBrackets, bool isLeftMost);
    protected ExpressionFlags PropagateExpressionFlags(ExpressionFlags flags);
    protected ExpressionFlags DisambiguateExpression(Expression expression, ExpressionFlags flags);
    protected void VisitRootExpression(Expression expression, ExpressionFlags flags);
    protected void VisitSubExpression(Expression expression, ExpressionFlags flags);
    protected void VisitExpression(Expression expression, ExpressionFlags flags, Func`4<AstToJavaScriptConverter, Expression, ExpressionFlags, ExpressionFlags> getCombinedFlags);
    protected void VisitSubExpressionList(NodeList`1& expressionList);
    protected void VisitExpressionList(NodeList`1& expressionList, Func`5<AstToJavaScriptConverter, Expression, int, int, ExpressionFlags> getCombinedItemFlags);
    protected void VisitExpressionListItem(Expression expression, int index, int count, Func`5<AstToJavaScriptConverter, Expression, int, int, ExpressionFlags> getCombinedFlags);
    private void VisitImportAttributes(NodeList`1& attributes);
    private void VisitExportOrImportSpecifierIdentifier(Expression identifierExpression);
    private void VisitPropertyKey(Expression key, bool computed, TokenFlags leadingBracketFlags, TokenFlags trailingBracketFlags);
    protected virtual bool ExpressionIsAmbiguousAsStatementExpression(Expression expression);
    protected virtual bool ExpressionIsAmbiguousAsExportDefaultExpression(Expression expression);
    protected virtual bool ExpressionIsAmbiguousAsArrowFunctionBody(Expression expression);
    protected virtual bool ExpressionIsAmbiguousAsNewCallee(Expression expression);
    protected virtual bool LeftHandSideExpressionIsParenthesized(Expression expression);
    protected virtual bool DecoratorLeftMostExpressionIsParenthesized(Expression expression, bool isRoot);
    protected virtual bool ExpressionNeedsBracketsInList(Expression expression);
    protected virtual int GetOperatorPrecedence(Expression expression, Int32& associativity);
    protected bool UnaryOperandNeedsBrackets(Expression operation, Expression operand);
    protected BinaryOperationFlags BinaryOperandsNeedBrackets(Expression operation, Expression leftOperand, Expression rightOperand);
    protected void VisitAuxiliaryNode(Node node);
    protected void VisitAuxiliaryNode(Node node, Func`3<AstToJavaScriptConverter, Node, object> getNodeContext);
    protected void VisitAuxiliaryNodeList(NodeList`1& nodeList, string separator);
    protected void VisitAuxiliaryNodeList(NodeList`1& nodeList, string separator, Func`5<AstToJavaScriptConverter, Node, int, int, object> getNodeContext);
    protected void VisitAuxiliaryNodeListItem(TNode node, int index, int count, string separator, Func`5<AstToJavaScriptConverter, Node, int, int, object> getNodeContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.AstToJavaScriptOptions : object {
    public static AstToJavaScriptOptions Default;
    [CompilerGeneratedAttribute]
private bool <IgnoreExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    internal bool IgnoreExtensions { get; internal set; }
    [CompilerGeneratedAttribute]
protected AstToJavaScriptOptions(AstToJavaScriptOptions original);
    private static AstToJavaScriptOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
internal bool get_IgnoreExtensions();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IgnoreExtensions(bool value);
    protected internal virtual AstToJavaScriptConverter CreateConverter(JavaScriptTextWriter writer);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(AstToJavaScriptOptions left, AstToJavaScriptOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(AstToJavaScriptOptions left, AstToJavaScriptOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(AstToJavaScriptOptions other);
    [CompilerGeneratedAttribute]
public virtual AstToJavaScriptOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Esprima.Utils.AstToJson : object {
    [ExtensionAttribute]
public static string ToJsonString(Node node);
    [ExtensionAttribute]
public static string ToJsonString(Node node, string indent);
    [ExtensionAttribute]
public static string ToJsonString(Node node, AstToJsonOptions options);
    [ExtensionAttribute]
public static string ToJsonString(Node node, AstToJsonOptions options, string indent);
    [ExtensionAttribute]
public static void WriteJson(Node node, TextWriter writer);
    [ExtensionAttribute]
public static void WriteJson(Node node, TextWriter writer, string indent);
    [ExtensionAttribute]
public static void WriteJson(Node node, TextWriter writer, AstToJsonOptions options);
    [ExtensionAttribute]
public static void WriteJson(Node node, TextWriter writer, AstToJsonOptions options, string indent);
    [ExtensionAttribute]
public static void WriteJson(Node node, JsonWriter writer, AstToJsonOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.AstToJsonConverter : AstVisitor {
    private JsonWriter _writer;
    private protected bool _includeTokens;
    private protected bool _includeComments;
    private protected bool _includeLineColumn;
    private protected bool _includeRange;
    private protected LocationMembersPlacement _locationMembersPlacement;
    private protected AstToJsonTestCompatibilityMode _testCompatibilityMode;
    private static ConditionalWeakTable`2<Type, IDictionary> EnumMap;
    public AstToJsonConverter(JsonWriter writer, AstToJsonOptions options);
    private static AstToJsonConverter();
    protected virtual string GetNodeType(Node node);
    protected virtual string GetTokenType(SyntaxToken token);
    protected virtual string GetCommentType(SyntaxComment comment);
    private void WriteLocationInfo(SyntaxElement element);
    private void WriteRegexValue(RegexValue value);
    private void WriteTokens(IReadOnlyList`1<SyntaxToken> tokens);
    private void WriteComments(IReadOnlyList`1<SyntaxComment> comments);
    private void OnStartSyntaxElementObject(SyntaxElement element);
    private void OnEndSyntaxElementObject(SyntaxElement element);
    protected NodeObjectDisposable StartNodeObject(Node node);
    protected void EmptyNodeObject(Node node);
    protected void Member(string name);
    protected void Member(string name, Node node);
    protected void Member(string name, string value);
    protected void Member(string name, bool value);
    protected void Member(string name, int value);
    protected void Member(string name, T value);
    [NullableContextAttribute("0")]
protected void Member(string name, NodeList`1& nodes);
    [NullableContextAttribute("0")]
protected void Member(string name, NodeList`1& list, Func`2<T, Node> nodeSelector);
    public void Convert(Node node);
    [NullableContextAttribute("2")]
public virtual object Visit(Node node);
    protected internal virtual object VisitAccessorProperty(AccessorProperty accessorProperty);
    protected internal virtual object VisitArrayExpression(ArrayExpression arrayExpression);
    protected internal virtual object VisitArrayPattern(ArrayPattern arrayPattern);
    protected internal virtual object VisitArrowFunctionExpression(ArrowFunctionExpression arrowFunctionExpression);
    protected internal virtual object VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    protected internal virtual object VisitAssignmentPattern(AssignmentPattern assignmentPattern);
    protected internal virtual object VisitAwaitExpression(AwaitExpression awaitExpression);
    protected internal virtual object VisitBinaryExpression(BinaryExpression binaryExpression);
    protected internal virtual object VisitBlockStatement(BlockStatement blockStatement);
    protected internal virtual object VisitBreakStatement(BreakStatement breakStatement);
    protected internal virtual object VisitCallExpression(CallExpression callExpression);
    protected internal virtual object VisitCatchClause(CatchClause catchClause);
    protected internal virtual object VisitChainExpression(ChainExpression chainExpression);
    protected internal virtual object VisitClassBody(ClassBody classBody);
    protected internal virtual object VisitClassDeclaration(ClassDeclaration classDeclaration);
    protected internal virtual object VisitClassExpression(ClassExpression classExpression);
    protected internal virtual object VisitConditionalExpression(ConditionalExpression conditionalExpression);
    protected internal virtual object VisitContinueStatement(ContinueStatement continueStatement);
    protected internal virtual object VisitDebuggerStatement(DebuggerStatement debuggerStatement);
    protected internal virtual object VisitDecorator(Decorator decorator);
    protected internal virtual object VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    protected internal virtual object VisitEmptyStatement(EmptyStatement emptyStatement);
    protected internal virtual object VisitExportAllDeclaration(ExportAllDeclaration exportAllDeclaration);
    protected internal virtual object VisitExportDefaultDeclaration(ExportDefaultDeclaration exportDefaultDeclaration);
    protected internal virtual object VisitExportNamedDeclaration(ExportNamedDeclaration exportNamedDeclaration);
    protected internal virtual object VisitExportSpecifier(ExportSpecifier exportSpecifier);
    protected internal virtual object VisitExpressionStatement(ExpressionStatement expressionStatement);
    protected internal virtual object VisitForInStatement(ForInStatement forInStatement);
    protected internal virtual object VisitForOfStatement(ForOfStatement forOfStatement);
    protected internal virtual object VisitForStatement(ForStatement forStatement);
    protected internal virtual object VisitFunctionDeclaration(FunctionDeclaration functionDeclaration);
    protected internal virtual object VisitFunctionExpression(FunctionExpression functionExpression);
    protected internal virtual object VisitIdentifier(Identifier identifier);
    protected internal virtual object VisitIfStatement(IfStatement ifStatement);
    protected internal virtual object VisitImportAttribute(ImportAttribute importAttribute);
    private ImportCompat VisitImportCompat(ImportCompat import);
    protected internal virtual object VisitImportDeclaration(ImportDeclaration importDeclaration);
    protected internal virtual object VisitImportDefaultSpecifier(ImportDefaultSpecifier importDefaultSpecifier);
    protected internal virtual object VisitImportExpression(ImportExpression importExpression);
    protected internal virtual object VisitImportNamespaceSpecifier(ImportNamespaceSpecifier importNamespaceSpecifier);
    protected internal virtual object VisitImportSpecifier(ImportSpecifier importSpecifier);
    protected internal virtual object VisitLabeledStatement(LabeledStatement labeledStatement);
    protected internal virtual object VisitLiteral(Literal literal);
    protected internal virtual object VisitMemberExpression(MemberExpression memberExpression);
    protected internal virtual object VisitMetaProperty(MetaProperty metaProperty);
    protected internal virtual object VisitMethodDefinition(MethodDefinition methodDefinition);
    protected internal virtual object VisitNewExpression(NewExpression newExpression);
    protected internal virtual object VisitObjectExpression(ObjectExpression objectExpression);
    protected internal virtual object VisitObjectPattern(ObjectPattern objectPattern);
    protected internal virtual object VisitPrivateIdentifier(PrivateIdentifier privateIdentifier);
    protected internal virtual object VisitProgram(Program program);
    protected internal virtual object VisitProperty(Property property);
    protected internal virtual object VisitPropertyDefinition(PropertyDefinition propertyDefinition);
    protected internal virtual object VisitRestElement(RestElement restElement);
    protected internal virtual object VisitReturnStatement(ReturnStatement returnStatement);
    protected internal virtual object VisitSequenceExpression(SequenceExpression sequenceExpression);
    protected internal virtual object VisitSpreadElement(SpreadElement spreadElement);
    protected internal virtual object VisitStaticBlock(StaticBlock staticBlock);
    protected internal virtual object VisitSuper(Super super);
    protected internal virtual object VisitSwitchCase(SwitchCase switchCase);
    protected internal virtual object VisitSwitchStatement(SwitchStatement switchStatement);
    protected internal virtual object VisitTaggedTemplateExpression(TaggedTemplateExpression taggedTemplateExpression);
    protected internal virtual object VisitTemplateElement(TemplateElement templateElement);
    protected internal virtual object VisitTemplateLiteral(TemplateLiteral templateLiteral);
    protected internal virtual object VisitThisExpression(ThisExpression thisExpression);
    protected internal virtual object VisitThrowStatement(ThrowStatement throwStatement);
    protected internal virtual object VisitTryStatement(TryStatement tryStatement);
    protected internal virtual object VisitUnaryExpression(UnaryExpression unaryExpression);
    protected internal virtual object VisitVariableDeclaration(VariableDeclaration variableDeclaration);
    protected internal virtual object VisitVariableDeclarator(VariableDeclarator variableDeclarator);
    protected internal virtual object VisitWhileStatement(WhileStatement whileStatement);
    protected internal virtual object VisitWithStatement(WithStatement withStatement);
    protected internal virtual object VisitYieldExpression(YieldExpression yieldExpression);
    [CompilerGeneratedAttribute]
private void <WriteLocationInfo>g__Write|11_0(Position position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.AstToJsonOptions : object {
    public static AstToJsonOptions Default;
    [CompilerGeneratedAttribute]
private bool <IncludeTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeLineColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LocationMembersPlacement <LocationMembersPlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private AstToJsonTestCompatibilityMode <TestCompatibilityMode>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool IncludeTokens { get; public set; }
    public bool IncludeComments { get; public set; }
    public bool IncludeLineColumn { get; public set; }
    public bool IncludeRange { get; public set; }
    public LocationMembersPlacement LocationMembersPlacement { get; public set; }
    internal AstToJsonTestCompatibilityMode TestCompatibilityMode { get; internal set; }
    [CompilerGeneratedAttribute]
protected AstToJsonOptions(AstToJsonOptions original);
    private static AstToJsonOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_IncludeTokens();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeTokens(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeComments();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeComments(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLineColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeLineColumn(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeRange();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeRange(bool value);
    [CompilerGeneratedAttribute]
public LocationMembersPlacement get_LocationMembersPlacement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LocationMembersPlacement(LocationMembersPlacement value);
    [CompilerGeneratedAttribute]
internal AstToJsonTestCompatibilityMode get_TestCompatibilityMode();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TestCompatibilityMode(AstToJsonTestCompatibilityMode value);
    protected internal virtual AstToJsonConverter CreateConverter(JsonWriter writer);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(AstToJsonOptions left, AstToJsonOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(AstToJsonOptions left, AstToJsonOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(AstToJsonOptions other);
    [CompilerGeneratedAttribute]
public virtual AstToJsonOptions <Clone>$();
}
internal enum Esprima.Utils.AstToJsonTestCompatibilityMode : Enum {
    public int value__;
    public static AstToJsonTestCompatibilityMode None;
    public static AstToJsonTestCompatibilityMode EsprimaOrg;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AutoGeneratedAstVisitorAttribute]
public class Esprima.Utils.AstVisitor : object {
    private static NotImplementedException UnsupportedNodeType(Type nodeType, string callerName);
    public virtual object Visit(Node node);
    protected internal virtual object VisitExportSpecifier(ExportSpecifier exportSpecifier);
    protected internal virtual object VisitExtension(Node node);
    protected internal virtual object VisitImportSpecifier(ImportSpecifier importSpecifier);
    protected internal virtual object VisitProperty(Property property);
    protected internal virtual object VisitTemplateLiteral(TemplateLiteral templateLiteral);
    protected internal virtual object VisitAccessorProperty(AccessorProperty accessorProperty);
    protected internal virtual object VisitArrayExpression(ArrayExpression arrayExpression);
    protected internal virtual object VisitArrayPattern(ArrayPattern arrayPattern);
    protected internal virtual object VisitArrowFunctionExpression(ArrowFunctionExpression arrowFunctionExpression);
    protected internal virtual object VisitAssignmentExpression(AssignmentExpression assignmentExpression);
    protected internal virtual object VisitAssignmentPattern(AssignmentPattern assignmentPattern);
    protected internal virtual object VisitAwaitExpression(AwaitExpression awaitExpression);
    protected internal virtual object VisitBinaryExpression(BinaryExpression binaryExpression);
    protected internal virtual object VisitBlockStatement(BlockStatement blockStatement);
    protected internal virtual object VisitBreakStatement(BreakStatement breakStatement);
    protected internal virtual object VisitCallExpression(CallExpression callExpression);
    protected internal virtual object VisitCatchClause(CatchClause catchClause);
    protected internal virtual object VisitChainExpression(ChainExpression chainExpression);
    protected internal virtual object VisitClassBody(ClassBody classBody);
    protected internal virtual object VisitClassDeclaration(ClassDeclaration classDeclaration);
    protected internal virtual object VisitClassExpression(ClassExpression classExpression);
    protected internal virtual object VisitConditionalExpression(ConditionalExpression conditionalExpression);
    protected internal virtual object VisitContinueStatement(ContinueStatement continueStatement);
    protected internal virtual object VisitDebuggerStatement(DebuggerStatement debuggerStatement);
    protected internal virtual object VisitDecorator(Decorator decorator);
    protected internal virtual object VisitDoWhileStatement(DoWhileStatement doWhileStatement);
    protected internal virtual object VisitEmptyStatement(EmptyStatement emptyStatement);
    protected internal virtual object VisitExportAllDeclaration(ExportAllDeclaration exportAllDeclaration);
    protected internal virtual object VisitExportDefaultDeclaration(ExportDefaultDeclaration exportDefaultDeclaration);
    protected internal virtual object VisitExportNamedDeclaration(ExportNamedDeclaration exportNamedDeclaration);
    protected internal virtual object VisitExpressionStatement(ExpressionStatement expressionStatement);
    protected internal virtual object VisitForInStatement(ForInStatement forInStatement);
    protected internal virtual object VisitForOfStatement(ForOfStatement forOfStatement);
    protected internal virtual object VisitForStatement(ForStatement forStatement);
    protected internal virtual object VisitFunctionDeclaration(FunctionDeclaration functionDeclaration);
    protected internal virtual object VisitFunctionExpression(FunctionExpression functionExpression);
    protected internal virtual object VisitIdentifier(Identifier identifier);
    protected internal virtual object VisitIfStatement(IfStatement ifStatement);
    protected internal virtual object VisitImportAttribute(ImportAttribute importAttribute);
    protected internal virtual object VisitImportDeclaration(ImportDeclaration importDeclaration);
    protected internal virtual object VisitImportDefaultSpecifier(ImportDefaultSpecifier importDefaultSpecifier);
    protected internal virtual object VisitImportExpression(ImportExpression importExpression);
    protected internal virtual object VisitImportNamespaceSpecifier(ImportNamespaceSpecifier importNamespaceSpecifier);
    protected internal virtual object VisitLabeledStatement(LabeledStatement labeledStatement);
    protected internal virtual object VisitLiteral(Literal literal);
    protected internal virtual object VisitMemberExpression(MemberExpression memberExpression);
    protected internal virtual object VisitMetaProperty(MetaProperty metaProperty);
    protected internal virtual object VisitMethodDefinition(MethodDefinition methodDefinition);
    protected internal virtual object VisitNewExpression(NewExpression newExpression);
    protected internal virtual object VisitObjectExpression(ObjectExpression objectExpression);
    protected internal virtual object VisitObjectPattern(ObjectPattern objectPattern);
    protected internal virtual object VisitPrivateIdentifier(PrivateIdentifier privateIdentifier);
    protected internal virtual object VisitProgram(Program program);
    protected internal virtual object VisitPropertyDefinition(PropertyDefinition propertyDefinition);
    protected internal virtual object VisitRestElement(RestElement restElement);
    protected internal virtual object VisitReturnStatement(ReturnStatement returnStatement);
    protected internal virtual object VisitSequenceExpression(SequenceExpression sequenceExpression);
    protected internal virtual object VisitSpreadElement(SpreadElement spreadElement);
    protected internal virtual object VisitStaticBlock(StaticBlock staticBlock);
    protected internal virtual object VisitSuper(Super super);
    protected internal virtual object VisitSwitchCase(SwitchCase switchCase);
    protected internal virtual object VisitSwitchStatement(SwitchStatement switchStatement);
    protected internal virtual object VisitTaggedTemplateExpression(TaggedTemplateExpression taggedTemplateExpression);
    protected internal virtual object VisitTemplateElement(TemplateElement templateElement);
    protected internal virtual object VisitThisExpression(ThisExpression thisExpression);
    protected internal virtual object VisitThrowStatement(ThrowStatement throwStatement);
    protected internal virtual object VisitTryStatement(TryStatement tryStatement);
    protected internal virtual object VisitUnaryExpression(UnaryExpression unaryExpression);
    protected internal virtual object VisitVariableDeclaration(VariableDeclaration variableDeclaration);
    protected internal virtual object VisitVariableDeclarator(VariableDeclarator variableDeclarator);
    protected internal virtual object VisitWhileStatement(WhileStatement whileStatement);
    protected internal virtual object VisitWithStatement(WithStatement withStatement);
    protected internal virtual object VisitYieldExpression(YieldExpression yieldExpression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class Esprima.Utils.AutoGeneratedAstVisitorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VisitorType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetVisitorFieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseVisitorFieldName>k__BackingField;
    public Type VisitorType { get; public set; }
    public string TargetVisitorFieldName { get; public set; }
    public string BaseVisitorFieldName { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_VisitorType();
    [CompilerGeneratedAttribute]
public void set_VisitorType(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetVisitorFieldName();
    [CompilerGeneratedAttribute]
public void set_TargetVisitorFieldName(string value);
    [CompilerGeneratedAttribute]
public string get_BaseVisitorFieldName();
    [CompilerGeneratedAttribute]
public void set_BaseVisitorFieldName(string value);
}
[ExtensionAttribute]
internal static class Esprima.Utils.EnumHelper : object {
    [ExtensionAttribute]
public static TEnum ToFlag(bool value, TEnum flag);
    [ExtensionAttribute]
public static TEnum ToFlag(bool value, TEnum flag, TEnum fallbackFlag);
    [ExtensionAttribute]
public static bool HasFlagFast(BinaryOperationFlags flags, BinaryOperationFlags flag);
    [ExtensionAttribute]
public static bool HasFlagFast(StatementFlags flags, StatementFlags flag);
    [ExtensionAttribute]
public static bool HasFlagFast(ExpressionFlags flags, ExpressionFlags flag);
    [ExtensionAttribute]
public static bool HasFlagFast(TriviaType flags, TriviaType flag);
    [ExtensionAttribute]
public static bool HasFlagFast(TriviaFlags flags, TriviaFlags flag);
    [ExtensionAttribute]
public static bool HasFlagFast(TokenFlags flags, TokenFlags flag);
    [ExtensionAttribute]
public static bool HasFlagFast(StatementFlags flags, StatementFlags flag);
    [ExtensionAttribute]
public static bool HasFlagFast(ExpressionFlags flags, ExpressionFlags flag);
}
[ExtensionAttribute]
internal static class Esprima.Utils.ExpressionHelper : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int GetOperatorPrecedence(Expression expression, Int32& associativity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Esprima.Utils.JavaScriptTextFormatter : JavaScriptTextWriter {
    private string _indent;
    private int _indentionLevel;
    [CompilerGeneratedAttribute]
private bool <KeepSingleStatementBodyInLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepEmptyBlockBodyInLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MultiLineArrayLiteralThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MultiLineObjectLiteralThreshold>k__BackingField;
    protected bool KeepSingleStatementBodyInLine { get; }
    protected bool KeepEmptyBlockBodyInLine { get; }
    protected int MultiLineArrayLiteralThreshold { get; }
    protected int MultiLineObjectLiteralThreshold { get; }
    public JavaScriptTextFormatter(TextWriter writer, JavaScriptTextFormatterOptions options);
    [CompilerGeneratedAttribute]
protected bool get_KeepSingleStatementBodyInLine();
    [CompilerGeneratedAttribute]
protected bool get_KeepEmptyBlockBodyInLine();
    [CompilerGeneratedAttribute]
protected int get_MultiLineArrayLiteralThreshold();
    [CompilerGeneratedAttribute]
protected int get_MultiLineObjectLiteralThreshold();
    protected void IncreaseIndent();
    protected void DecreaseIndent();
    protected void WriteIndent();
    protected virtual void WriteLine();
    protected virtual void WriteLineCommentCore(TextWriter writer, string line, TriviaFlags flags);
    protected virtual void WriteBlockCommentLine(TextWriter writer, string line, bool isFirst);
    protected virtual void WriteBlockCommentCore(TextWriter writer, IEnumerable`1<string> lines, TriviaFlags flags);
    protected virtual void WriteWhiteSpaceBetweenTokenAndIdentifier(string value, TokenFlags flags, WriteContext& context);
    protected virtual void StartIdentifier(string value, TokenFlags flags, WriteContext& context);
    protected virtual void WriteWhiteSpaceBetweenTokenAndKeyword(string value, TokenFlags flags, WriteContext& context);
    protected virtual void StartKeyword(string value, TokenFlags flags, WriteContext& context);
    protected virtual void WriteWhiteSpaceBetweenTokenAndLiteral(string value, TokenType type, TokenFlags flags, WriteContext& context);
    protected virtual void StartLiteral(string value, TokenType type, TokenFlags flags, WriteContext& context);
    protected virtual void WriteWhiteSpaceBetweenTokenAndPunctuator(string value, TokenFlags flags, WriteContext& context);
    protected virtual void StartPunctuator(string value, TokenFlags flags, WriteContext& context);
    public virtual void StartArray(int elementCount, WriteContext& context);
    public virtual void EndArray(int elementCount, WriteContext& context);
    protected virtual bool CanKeepArrayInLine(int elementCount, WriteContext& context);
    public virtual void StartObject(int propertyCount, WriteContext& context);
    public virtual void EndObject(int propertyCount, WriteContext& context);
    protected virtual bool CanKeepObjectInLine(int propertyCount, WriteContext& context);
    public virtual void StartBlock(int statementCount, WriteContext& context);
    public virtual void EndBlock(int statementCount, WriteContext& context);
    protected virtual bool CanKeepBlockInLine(int statementCount, WriteContext& context);
    protected void StoreStatementBodyIntoContext(Statement statement, WriteContext& context);
    protected Statement RetrieveStatementBodyFromContext(WriteContext& context);
    public virtual void StartStatement(StatementFlags flags, WriteContext& context);
    public virtual void EndStatement(StatementFlags flags, WriteContext& context);
    public virtual void StartStatementList(int count, WriteContext& context);
    public virtual void StartStatementListItem(int index, int count, StatementFlags flags, WriteContext& context);
    public virtual void EndStatementListItem(int index, int count, StatementFlags flags, WriteContext& context);
    public virtual void EndStatementList(int count, WriteContext& context);
    protected virtual bool CanKeepSingleStatementBodyInLine(Statement statement, StatementFlags flags, WriteContext& context);
    protected virtual bool ShouldTerminateStatementAnyway(Statement statement, StatementFlags flags, WriteContext& context);
    public virtual void StartExpression(ExpressionFlags flags, WriteContext& context);
    public virtual void EndExpression(ExpressionFlags flags, WriteContext& context);
    public virtual void StartExpressionListItem(int index, int count, ExpressionFlags flags, WriteContext& context);
    public virtual void EndExpressionListItem(int index, int count, ExpressionFlags flags, WriteContext& context);
    protected virtual bool ShouldWrapExpressionInBracketsAnyway(Expression expression, ExpressionFlags flags, WriteContext& context);
    [NullableContextAttribute("2")]
public virtual void StartAuxiliaryNodeListItem(int index, int count, string separator, object nodeContext, WriteContext& context);
    [NullableContextAttribute("2")]
public virtual void EndAuxiliaryNodeListItem(int index, int count, string separator, object nodeContext, WriteContext& context);
    public virtual void Finish();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Esprima.Utils.JavaScriptTextFormatterOptions : JavaScriptTextWriterOptions {
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepSingleStatementBodyInLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepEmptyBlockBodyInLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MultiLineArrayLiteralThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MultiLineObjectLiteralThreshold>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Indent { get; public set; }
    public bool KeepSingleStatementBodyInLine { get; public set; }
    public bool KeepEmptyBlockBodyInLine { get; public set; }
    public int MultiLineArrayLiteralThreshold { get; public set; }
    public int MultiLineObjectLiteralThreshold { get; public set; }
    [CompilerGeneratedAttribute]
protected JavaScriptTextFormatterOptions(JavaScriptTextFormatterOptions original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Indent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Indent(string value);
    [CompilerGeneratedAttribute]
public bool get_KeepSingleStatementBodyInLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeepSingleStatementBodyInLine(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepEmptyBlockBodyInLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeepEmptyBlockBodyInLine(bool value);
    [CompilerGeneratedAttribute]
public int get_MultiLineArrayLiteralThreshold();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MultiLineArrayLiteralThreshold(int value);
    [CompilerGeneratedAttribute]
public int get_MultiLineObjectLiteralThreshold();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MultiLineObjectLiteralThreshold(int value);
    [NullableContextAttribute("1")]
protected abstract virtual JavaScriptTextFormatter CreateFormatter(TextWriter writer);
    [NullableContextAttribute("1")]
protected internal sealed virtual JavaScriptTextWriter CreateWriter(TextWriter writer);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(JavaScriptTextFormatterOptions left, JavaScriptTextFormatterOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(JavaScriptTextFormatterOptions left, JavaScriptTextFormatterOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(JavaScriptTextWriterOptions other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(JavaScriptTextFormatterOptions other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public abstract virtual JavaScriptTextWriterOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.JavaScriptTextWriter : object {
    private TextWriter _writer;
    private TokenSequence _lookbehind;
    [CompilerGeneratedAttribute]
private TokenType <LastTokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenFlags <LastTokenFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private TriviaType <LastTriviaType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CurrentLineIsEmptyOrWhiteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PendingRequiredNewLine>k__BackingField;
    private protected static TriviaType WhiteSpaceTriviaFlag;
    private protected static TriviaType CommentTriviaFlag;
    protected TokenType LastTokenType { get; private set; }
    protected TokenFlags LastTokenFlags { get; private set; }
    protected TriviaType LastTriviaType { get; private set; }
    protected bool CurrentLineIsEmptyOrWhiteSpace { get; private set; }
    protected bool PendingRequiredNewLine { get; private set; }
    public JavaScriptTextWriter(TextWriter writer, JavaScriptTextWriterOptions options);
    [CompilerGeneratedAttribute]
protected TokenType get_LastTokenType();
    [CompilerGeneratedAttribute]
private void set_LastTokenType(TokenType value);
    [CompilerGeneratedAttribute]
protected TokenFlags get_LastTokenFlags();
    [CompilerGeneratedAttribute]
private void set_LastTokenFlags(TokenFlags value);
    [CompilerGeneratedAttribute]
protected TriviaType get_LastTriviaType();
    [CompilerGeneratedAttribute]
private void set_LastTriviaType(TriviaType value);
    [CompilerGeneratedAttribute]
protected bool get_CurrentLineIsEmptyOrWhiteSpace();
    [CompilerGeneratedAttribute]
private void set_CurrentLineIsEmptyOrWhiteSpace(bool value);
    [CompilerGeneratedAttribute]
protected bool get_PendingRequiredNewLine();
    [CompilerGeneratedAttribute]
private void set_PendingRequiredNewLine(bool value);
    protected virtual void OnTriviaWritten(TriviaType type, TriviaFlags flags);
    protected void WriteSpace();
    protected void WriteWhiteSpace(string value);
    protected void WriteEndOfLine();
    protected virtual void WriteLine();
    protected virtual void WriteLineCommentCore(TextWriter writer, string line, TriviaFlags flags);
    public void WriteLineComment(string line, TriviaFlags flags);
    protected virtual void WriteBlockCommentLine(TextWriter writer, string line, bool isFirst);
    protected virtual void WriteBlockCommentCore(TextWriter writer, IEnumerable`1<string> lines, TriviaFlags flags);
    public void WriteBlockComment(IEnumerable`1<string> lines, TriviaFlags flags);
    protected virtual void OnTokenWritten(TokenType type, TokenFlags flags);
    public void SpaceRecommendedAfterLastToken();
    protected void WriteRequiredSpaceBetweenTokenAndIdentifier();
    protected virtual void StartIdentifier(string value, TokenFlags flags, WriteContext& context);
    public void WriteIdentifier(string value, TokenFlags flags, WriteContext& context);
    public void WriteIdentifier(string value, WriteContext& context);
    protected virtual void EndIdentifier(string value, TokenFlags flags, WriteContext& context);
    protected void WriteRequiredSpaceBetweenTokenAndKeyword();
    protected virtual void StartKeyword(string value, TokenFlags flags, WriteContext& context);
    public void WriteKeyword(string value, TokenFlags flags, WriteContext& context);
    public void WriteKeyword(string value, WriteContext& context);
    protected virtual void EndKeyword(string value, TokenFlags flags, WriteContext& context);
    protected void WriteRequiredSpaceBetweenTokenAndLiteral(TokenType type);
    protected virtual void StartLiteral(string value, TokenType type, TokenFlags flags, WriteContext& context);
    public void WriteLiteral(string value, TokenType type, TokenFlags flags, WriteContext& context);
    public void WriteLiteral(string value, TokenType tokenType, WriteContext& context);
    protected virtual void EndLiteral(string value, TokenType type, TokenFlags flags, WriteContext& context);
    protected virtual bool ShouldDisambiguatePunctuator(string value, TokenFlags flags, WriteContext& context);
    protected void WriteRequiredSpaceBetweenTokenAndPunctuator(string value, TokenFlags flags, WriteContext& context);
    protected virtual void StartPunctuator(string value, TokenFlags flags, WriteContext& context);
    public void WritePunctuator(string value, TokenFlags flags, WriteContext& context);
    public void WritePunctuator(string value, WriteContext& context);
    protected virtual void EndPunctuator(string value, TokenFlags flags, WriteContext& context);
    public virtual void StartArray(int elementCount, WriteContext& context);
    public virtual void EndArray(int elementCount, WriteContext& context);
    public virtual void StartObject(int propertyCount, WriteContext& context);
    public virtual void EndObject(int propertyCount, WriteContext& context);
    public virtual void StartBlock(int statementCount, WriteContext& context);
    public virtual void EndBlock(int statementCount, WriteContext& context);
    public virtual void StartStatement(StatementFlags flags, WriteContext& context);
    public virtual void EndStatement(StatementFlags flags, WriteContext& context);
    public virtual void StartStatementList(int count, WriteContext& context);
    public virtual void StartStatementListItem(int index, int count, StatementFlags flags, WriteContext& context);
    public virtual void EndStatementListItem(int index, int count, StatementFlags flags, WriteContext& context);
    public virtual void EndStatementList(int count, WriteContext& context);
    public virtual void StartExpression(ExpressionFlags flags, WriteContext& context);
    public virtual void EndExpression(ExpressionFlags flags, WriteContext& context);
    public virtual void StartExpressionList(int count, WriteContext& context);
    public virtual void StartExpressionListItem(int index, int count, ExpressionFlags flags, WriteContext& context);
    public virtual void EndExpressionListItem(int index, int count, ExpressionFlags flags, WriteContext& context);
    public virtual void EndExpressionList(int count, WriteContext& context);
    [NullableContextAttribute("2")]
public virtual void StartAuxiliaryNode(object nodeContext, WriteContext& context);
    [NullableContextAttribute("2")]
public virtual void EndAuxiliaryNode(object nodeContext, WriteContext& context);
    [NullableContextAttribute("0")]
public virtual void StartAuxiliaryNodeList(int count, WriteContext& context);
    [NullableContextAttribute("2")]
public virtual void StartAuxiliaryNodeListItem(int index, int count, string separator, object nodeContext, WriteContext& context);
    [NullableContextAttribute("2")]
public virtual void EndAuxiliaryNodeListItem(int index, int count, string separator, object nodeContext, WriteContext& context);
    [NullableContextAttribute("0")]
public virtual void EndAuxiliaryNodeList(int count, WriteContext& context);
    public virtual void Finish();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.JavaScriptTextWriterOptions : object {
    public static JavaScriptTextWriterOptions Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected JavaScriptTextWriterOptions(JavaScriptTextWriterOptions original);
    private static JavaScriptTextWriterOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    protected internal virtual JavaScriptTextWriter CreateWriter(TextWriter writer);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(JavaScriptTextWriterOptions left, JavaScriptTextWriterOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(JavaScriptTextWriterOptions left, JavaScriptTextWriterOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(JavaScriptTextWriterOptions other);
    [CompilerGeneratedAttribute]
public virtual JavaScriptTextWriterOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Esprima.Utils.JsonTextWriter : JsonWriter {
    private TextWriter _writer;
    private string _indent;
    [NullableAttribute("0")]
private Stack`1<StructureKind> _structures;
    [NullableAttribute("0")]
private Stack`1<int> _counters;
    [NullableAttribute("2")]
private string _memberName;
    public int Depth { get; }
    private bool Pretty { get; }
    public JsonTextWriter(TextWriter writer);
    public JsonTextWriter(TextWriter writer, string indent);
    public int get_Depth();
    public virtual void StartObject();
    public virtual void EndObject();
    public virtual void StartArray();
    public virtual void EndArray();
    public virtual void Member(string name);
    [NullableContextAttribute("2")]
public virtual void String(string str);
    public virtual void Null();
    public virtual void Boolean(bool flag);
    public void Number(int n);
    public virtual void Number(long n);
    public virtual void Number(double n);
    private bool get_Pretty();
    private void Eol();
    private void Indent(Nullable`1<int> depth);
    private void StartStructured(StructureKind kind);
    private void EndStructured();
    private void Write(string token, TokenKind kind);
    private static void Enquote(string s, TextWriter writer);
}
public abstract class Esprima.Utils.JsonWriter : object {
    public abstract virtual void Null();
    public abstract virtual void Number(long n);
    public abstract virtual void Number(double n);
    [NullableContextAttribute("2")]
public abstract virtual void String(string value);
    public abstract virtual void Boolean(bool flag);
    public abstract virtual void StartArray();
    public abstract virtual void EndArray();
    public abstract virtual void StartObject();
    [NullableContextAttribute("1")]
public abstract virtual void Member(string name);
    public abstract virtual void EndObject();
}
[NullableContextAttribute("1")]
public interface Esprima.Utils.Jsx.IJsxAstVisitor {
    public abstract virtual object VisitJsxAttribute(JsxAttribute jsxAttribute);
    public abstract virtual object VisitJsxClosingElement(JsxClosingElement jsxClosingElement);
    public abstract virtual object VisitJsxClosingFragment(JsxClosingFragment jsxClosingFragment);
    public abstract virtual object VisitJsxElement(JsxElement jsxElement);
    public abstract virtual object VisitJsxEmptyExpression(JsxEmptyExpression jsxEmptyExpression);
    public abstract virtual object VisitJsxExpressionContainer(JsxExpressionContainer jsxExpressionContainer);
    public abstract virtual object VisitJsxIdentifier(JsxIdentifier jsxIdentifier);
    public abstract virtual object VisitJsxMemberExpression(JsxMemberExpression jsxMemberExpression);
    public abstract virtual object VisitJsxNamespacedName(JsxNamespacedName jsxNamespacedName);
    public abstract virtual object VisitJsxOpeningElement(JsxOpeningElement jsxOpeningElement);
    public abstract virtual object VisitJsxOpeningFragment(JsxOpeningFragment jsxOpeningFragment);
    public abstract virtual object VisitJsxSpreadAttribute(JsxSpreadAttribute jsxSpreadAttribute);
    public abstract virtual object VisitJsxText(JsxText jsxText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AutoGeneratedAstVisitorAttribute]
public class Esprima.Utils.Jsx.JsxAstRewriter : AstRewriter {
    private AstRewriter _rewriter;
    private IJsxAstVisitor _jsxVisitor;
    private JsxAstRewriter(AstRewriter rewriter);
    public static IJsxAstVisitor CreateJsxRewriterFor(TRewriter rewriter);
    public virtual object VisitJsxAttribute(JsxAttribute jsxAttribute);
    public virtual object VisitJsxClosingElement(JsxClosingElement jsxClosingElement);
    public virtual object VisitJsxClosingFragment(JsxClosingFragment jsxClosingFragment);
    public virtual object VisitJsxElement(JsxElement jsxElement);
    public virtual object VisitJsxEmptyExpression(JsxEmptyExpression jsxEmptyExpression);
    public virtual object VisitJsxExpressionContainer(JsxExpressionContainer jsxExpressionContainer);
    public virtual object VisitJsxIdentifier(JsxIdentifier jsxIdentifier);
    public virtual object VisitJsxMemberExpression(JsxMemberExpression jsxMemberExpression);
    public virtual object VisitJsxNamespacedName(JsxNamespacedName jsxNamespacedName);
    public virtual object VisitJsxOpeningElement(JsxOpeningElement jsxOpeningElement);
    public virtual object VisitJsxOpeningFragment(JsxOpeningFragment jsxOpeningFragment);
    public virtual object VisitJsxSpreadAttribute(JsxSpreadAttribute jsxSpreadAttribute);
    public virtual object VisitJsxText(JsxText jsxText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.Jsx.JsxAstToJavaScriptConverter : AstToJavaScriptConverter {
    public JsxAstToJavaScriptConverter(JavaScriptTextWriter writer, JsxAstToJavaScriptOptions options);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxAttribute(JsxAttribute jsxAttribute);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxClosingElement(JsxClosingElement jsxClosingElement);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxClosingFragment(JsxClosingFragment jsxClosingFragment);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxElement(JsxElement jsxElement);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxEmptyExpression(JsxEmptyExpression jsxEmptyExpression);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxExpressionContainer(JsxExpressionContainer jsxExpressionContainer);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxIdentifier(JsxIdentifier jsxIdentifier);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxMemberExpression(JsxMemberExpression jsxMemberExpression);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxNamespacedName(JsxNamespacedName jsxNamespacedName);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxOpeningElement(JsxOpeningElement jsxOpeningElement);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxOpeningFragment(JsxOpeningFragment jsxOpeningFragment);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxSpreadAttribute(JsxSpreadAttribute jsxSpreadAttribute);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxText(JsxText jsxText);
    protected virtual int GetOperatorPrecedence(Expression expression, Int32& associativity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.Jsx.JsxAstToJavaScriptOptions : AstToJavaScriptOptions {
    public static JsxAstToJavaScriptOptions Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected JsxAstToJavaScriptOptions(JsxAstToJavaScriptOptions original);
    private static JsxAstToJavaScriptOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    protected internal virtual AstToJavaScriptConverter CreateConverter(JavaScriptTextWriter writer);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(JsxAstToJavaScriptOptions left, JsxAstToJavaScriptOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(JsxAstToJavaScriptOptions left, JsxAstToJavaScriptOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(AstToJavaScriptOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(JsxAstToJavaScriptOptions other);
    [CompilerGeneratedAttribute]
public virtual AstToJavaScriptOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.Jsx.JsxAstToJsonConverter : AstToJsonConverter {
    public JsxAstToJsonConverter(JsonWriter writer, JsxAstToJsonOptions options);
    protected virtual string GetNodeType(Node node);
    protected virtual string GetTokenType(SyntaxToken token);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxAttribute(JsxAttribute jsxAttribute);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxClosingElement(JsxClosingElement jsxClosingElement);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxClosingFragment(JsxClosingFragment jsxClosingFragment);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxElement(JsxElement jsxElement);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxEmptyExpression(JsxEmptyExpression jsxEmptyExpression);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxExpressionContainer(JsxExpressionContainer jsxExpressionContainer);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxIdentifier(JsxIdentifier jsxIdentifier);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxMemberExpression(JsxMemberExpression jsxMemberExpression);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxNamespacedName(JsxNamespacedName jsxNamespacedName);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxOpeningElement(JsxOpeningElement jsxOpeningElement);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxOpeningFragment(JsxOpeningFragment jsxOpeningFragment);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxSpreadAttribute(JsxSpreadAttribute jsxSpreadAttribute);
    private sealed virtual override object Esprima.Utils.Jsx.IJsxAstVisitor.VisitJsxText(JsxText jsxText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.Jsx.JsxAstToJsonOptions : AstToJsonOptions {
    public static JsxAstToJsonOptions Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected JsxAstToJsonOptions(JsxAstToJsonOptions original);
    private static JsxAstToJsonOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    protected internal virtual AstToJsonConverter CreateConverter(JsonWriter writer);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(JsxAstToJsonOptions left, JsxAstToJsonOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(JsxAstToJsonOptions left, JsxAstToJsonOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(AstToJsonOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(JsxAstToJsonOptions other);
    [CompilerGeneratedAttribute]
public virtual AstToJsonOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AutoGeneratedAstVisitorAttribute]
public class Esprima.Utils.Jsx.JsxAstVisitor : AstVisitor {
    private AstVisitor _visitor;
    private JsxAstVisitor(AstVisitor visitor);
    public static IJsxAstVisitor CreateJsxVisitorFor(TVisitor visitor);
    public virtual object VisitJsxAttribute(JsxAttribute jsxAttribute);
    public virtual object VisitJsxClosingElement(JsxClosingElement jsxClosingElement);
    public virtual object VisitJsxClosingFragment(JsxClosingFragment jsxClosingFragment);
    public virtual object VisitJsxElement(JsxElement jsxElement);
    public virtual object VisitJsxEmptyExpression(JsxEmptyExpression jsxEmptyExpression);
    public virtual object VisitJsxExpressionContainer(JsxExpressionContainer jsxExpressionContainer);
    public virtual object VisitJsxIdentifier(JsxIdentifier jsxIdentifier);
    public virtual object VisitJsxMemberExpression(JsxMemberExpression jsxMemberExpression);
    public virtual object VisitJsxNamespacedName(JsxNamespacedName jsxNamespacedName);
    public virtual object VisitJsxOpeningElement(JsxOpeningElement jsxOpeningElement);
    public virtual object VisitJsxOpeningFragment(JsxOpeningFragment jsxOpeningFragment);
    public virtual object VisitJsxSpreadAttribute(JsxSpreadAttribute jsxSpreadAttribute);
    public virtual object VisitJsxText(JsxText jsxText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.KnRJavaScriptTextFormatter : JavaScriptTextFormatter {
    [CompilerGeneratedAttribute]
private bool <UseEgyptianBraces>k__BackingField;
    protected bool UseEgyptianBraces { get; }
    public KnRJavaScriptTextFormatter(TextWriter writer, KnRJavaScriptTextFormatterOptions options);
    [CompilerGeneratedAttribute]
protected bool get_UseEgyptianBraces();
    protected virtual void WriteWhiteSpaceBetweenTokenAndKeyword(string value, TokenFlags flags, WriteContext& context);
    protected virtual bool CanUseEgyptianBraces(WriteContext& context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Esprima.Utils.KnRJavaScriptTextFormatterOptions : JavaScriptTextFormatterOptions {
    public static KnRJavaScriptTextFormatterOptions Default;
    [CompilerGeneratedAttribute]
private bool <UseEgyptianBraces>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool UseEgyptianBraces { get; public set; }
    [CompilerGeneratedAttribute]
protected KnRJavaScriptTextFormatterOptions(KnRJavaScriptTextFormatterOptions original);
    private static KnRJavaScriptTextFormatterOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_UseEgyptianBraces();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseEgyptianBraces(bool value);
    protected virtual JavaScriptTextFormatter CreateFormatter(TextWriter writer);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(KnRJavaScriptTextFormatterOptions left, KnRJavaScriptTextFormatterOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(KnRJavaScriptTextFormatterOptions left, KnRJavaScriptTextFormatterOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(JavaScriptTextFormatterOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(KnRJavaScriptTextFormatterOptions other);
    [CompilerGeneratedAttribute]
public virtual JavaScriptTextWriterOptions <Clone>$();
}
public enum Esprima.Utils.LocationMembersPlacement : Enum {
    public int value__;
    public static LocationMembersPlacement End;
    public static LocationMembersPlacement Start;
}
public class Esprima.Utils.NodePropertyListValueAccessor`1 : MulticastDelegate {
    public NodePropertyListValueAccessor`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) Invoke(Node node);
    public virtual IAsyncResult BeginInvoke(Node node, AsyncCallback callback, object object);
    public virtual NodeList`1& modreq(System.Runtime.InteropServices.InAttribute) EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Esprima.Utils.NodePropertyListValueHelper : object {
    public Type ItemType { get; }
    public abstract virtual Type get_ItemType();
    public abstract virtual NodeList`1<Node> GetNodeList(WriteContext& context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Esprima.Utils.NodePropertyListValueHelper`1 : NodePropertyListValueHelper {
    public static NodePropertyListValueHelper`1<T> Instance;
    public Type ItemType { get; }
    private static NodePropertyListValueHelper`1();
    public virtual Type get_ItemType();
    public virtual NodeList`1<Node> GetNodeList(WriteContext& context);
}
public class Esprima.Utils.NodePropertyValueAccessor : MulticastDelegate {
    public NodePropertyValueAccessor(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual object Invoke(Node node);
    public virtual IAsyncResult BeginInvoke(Node node, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static bool IsHexChar(int c);
    public static int FromChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("1774")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
