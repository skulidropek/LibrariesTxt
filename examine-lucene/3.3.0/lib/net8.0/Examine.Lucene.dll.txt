public class Examine.Lucene.Analyzers.CultureInvariantStandardAnalyzer : Analyzer {
    private CharArraySet _stopWordsSet;
    private bool _caseInsensitive;
    private bool _ignoreLanguageAccents;
    [CompilerGeneratedAttribute]
private int <MaxTokenLength>k__BackingField;
    public int MaxTokenLength { get; public set; }
    public CultureInvariantStandardAnalyzer(CharArraySet stopWords);
    public CultureInvariantStandardAnalyzer(CharArraySet stopWords, bool caseInsensitive, bool ignoreLanguageAccents);
    protected virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
    [CompilerGeneratedAttribute]
public void set_MaxTokenLength(int value);
    [CompilerGeneratedAttribute]
public int get_MaxTokenLength();
}
public class Examine.Lucene.Analyzers.CultureInvariantWhitespaceAnalyzer : Analyzer {
    private bool _caseInsensitive;
    private bool _ignoreLanguageAccents;
    public CultureInvariantWhitespaceAnalyzer(bool caseInsensitive, bool ignoreLanguageAccents);
    protected virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Examine.Lucene.Analyzers.EmailAddressAnalyzer : Analyzer {
    protected virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Examine.Lucene.Analyzers.PatternAnalyzer : Analyzer {
    private int _regexGroup;
    private bool _lowercase;
    private CharArraySet _stopWords;
    private Regex _pattern;
    public PatternAnalyzer(string format, int regexGroup, bool lowercase, CharArraySet stopWords);
    protected virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Examine.Lucene.DelegateFieldValueTypeFactory : object {
    private Func`2<string, IIndexFieldValueType> _factory;
    public DelegateFieldValueTypeFactory(Func`2<string, IIndexFieldValueType> factory);
    public sealed virtual IIndexFieldValueType Create(string fieldName);
}
public class Examine.Lucene.Directories.DefaultLockFactory : object {
    public sealed virtual LockFactory GetLockFactory(DirectoryInfo directory);
}
public abstract class Examine.Lucene.Directories.DirectoryFactoryBase : object {
    private ConcurrentDictionary`2<string, Directory> _createdDirectories;
    private bool _disposedValue;
    private sealed virtual override Directory Examine.Lucene.Directories.IDirectoryFactory.CreateDirectory(LuceneIndex luceneIndex, bool forceUnlock);
    protected abstract virtual Directory CreateDirectory(LuceneIndex luceneIndex, bool forceUnlock);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Examine.Lucene.Directories.FileSystemDirectoryFactory : DirectoryFactoryBase {
    private DirectoryInfo _baseDir;
    [CompilerGeneratedAttribute]
private ILockFactory <LockFactory>k__BackingField;
    public ILockFactory LockFactory { get; }
    public FileSystemDirectoryFactory(DirectoryInfo baseDir, ILockFactory lockFactory);
    [CompilerGeneratedAttribute]
public ILockFactory get_LockFactory();
    protected virtual Directory CreateDirectory(LuceneIndex luceneIndex, bool forceUnlock);
}
public class Examine.Lucene.Directories.GenericDirectoryFactory : DirectoryFactoryBase {
    private Func`2<string, Directory> _factory;
    public GenericDirectoryFactory(Func`2<string, Directory> factory);
    protected virtual Directory CreateDirectory(LuceneIndex luceneIndex, bool forceUnlock);
}
public interface Examine.Lucene.Directories.IApplicationIdentifier {
    public abstract virtual string GetApplicationUniqueIdentifier();
}
public interface Examine.Lucene.Directories.IDirectoryFactory {
    public abstract virtual Directory CreateDirectory(LuceneIndex luceneIndex, bool forceUnlock);
}
public interface Examine.Lucene.Directories.ILockFactory {
    public abstract virtual LockFactory GetLockFactory(DirectoryInfo directory);
}
internal class Examine.Lucene.Directories.MultiIndexLock : Lock {
    private Lock _dirMaster;
    private Lock _dirChild;
    private bool _isDisposed;
    public MultiIndexLock(Lock dirMaster, Lock dirChild);
    public virtual bool Obtain();
    protected virtual void Dispose(bool disposing);
    public virtual bool IsLocked();
}
public class Examine.Lucene.Directories.MultiIndexLockFactory : LockFactory {
    private LockFactory _master;
    private LockFactory _child;
    private static object Locker;
    public MultiIndexLockFactory(Directory master, Directory child);
    public MultiIndexLockFactory(LockFactory master, LockFactory child);
    private static MultiIndexLockFactory();
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
public class Examine.Lucene.Directories.SyncedFileSystemDirectoryFactory : FileSystemDirectoryFactory {
    private DirectoryInfo _localDir;
    private DirectoryInfo _mainDir;
    private ILoggerFactory _loggerFactory;
    private bool _tryFixMainIndexIfCorrupt;
    private ILogger`1<SyncedFileSystemDirectoryFactory> _logger;
    private ExamineReplicator _replicator;
    public SyncedFileSystemDirectoryFactory(DirectoryInfo localDir, DirectoryInfo mainDir, ILockFactory lockFactory, ILoggerFactory loggerFactory);
    public SyncedFileSystemDirectoryFactory(DirectoryInfo localDir, DirectoryInfo mainDir, ILockFactory lockFactory, ILoggerFactory loggerFactory, bool tryFixMainIndexIfCorrupt);
    internal CreateResult TryCreateDirectory(LuceneIndex luceneIndex, bool forceUnlock, Directory& directory);
    protected virtual Directory CreateDirectory(LuceneIndex luceneIndex, bool forceUnlock);
    protected virtual void Dispose(bool disposing);
    private CreateResult TryGetIndexWriter(OpenMode openMode, Directory luceneDirectory, bool createNewIfCorrupt, string indexName, IndexWriter& indexWriter);
    private void SyncIndex(IndexWriter sourceIndexWriter, bool forceUnlock, string indexName, DirectoryInfo destinationDirectory, DirectoryInfo tempDir);
    private CreateResult CheckIndexHealthAndFix(Directory luceneDir, string indexName, bool doFix);
    private IndexWriter GetIndexWriter(Directory mainDir, OpenMode openMode);
}
public class Examine.Lucene.Directories.TempEnvFileSystemDirectoryFactory : FileSystemDirectoryFactory {
    public TempEnvFileSystemDirectoryFactory(IApplicationIdentifier applicationIdentifier, ILockFactory lockFactory);
    public static string GetTempPath(IApplicationIdentifier applicationIdentifier);
}
public class Examine.Lucene.DocumentWritingEventArgs : CancelEventArgs {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueSet <ValueSet>k__BackingField;
    public Document Document { get; }
    public ValueSet ValueSet { get; }
    public DocumentWritingEventArgs(ValueSet valueSet, Document d);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public ValueSet get_ValueSet();
}
public class Examine.Lucene.ExamineReplicator : object {
    private bool _disposedValue;
    private IReplicator _replicator;
    private LuceneIndex _sourceIndex;
    private Directory _destinationDirectory;
    private ReplicationClient _localReplicationClient;
    private object _locker;
    private bool _started;
    private ILogger`1<ExamineReplicator> _logger;
    public ExamineReplicator(ILoggerFactory loggerFactory, LuceneIndex sourceIndex, Directory destinationDirectory, DirectoryInfo tempStorage);
    public void ReplicateIndex();
    public void StartIndexReplicationOnSchedule(int milliseconds);
    private void SourceIndex_IndexCommitted(object sender, EventArgs e);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Examine.Lucene.FieldValueTypeCollection : object {
    private Lazy`1<ConcurrentDictionary`2<string, IIndexFieldValueType>> _resolvedValueTypes;
    [CompilerGeneratedAttribute]
private PerFieldAnalyzerWrapper <Analyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueTypeFactoryCollection <ValueTypeFactories>k__BackingField;
    public PerFieldAnalyzerWrapper Analyzer { get; }
    public ValueTypeFactoryCollection ValueTypeFactories { get; }
    public IEnumerable`1<IIndexFieldValueType> ValueTypes { get; }
    public FieldValueTypeCollection(Analyzer defaultAnalyzer, IReadOnlyDictionary`2<string, IFieldValueTypeFactory> valueTypeFactories, ReadOnlyFieldDefinitionCollection fieldDefinitionCollection);
    [CompilerGeneratedAttribute]
public PerFieldAnalyzerWrapper get_Analyzer();
    [CompilerGeneratedAttribute]
public ValueTypeFactoryCollection get_ValueTypeFactories();
    public IIndexFieldValueType GetValueType(string fieldName, IFieldValueTypeFactory fieldValueTypeFactory);
    public IIndexFieldValueType GetValueType(string fieldName);
    public IEnumerable`1<IIndexFieldValueType> get_ValueTypes();
}
public interface Examine.Lucene.IFieldValueTypeFactory {
    public abstract virtual IIndexFieldValueType Create(string fieldName);
}
public class Examine.Lucene.Indexing.DateTimeType : IndexFieldRangeValueType`1<DateTime> {
    [CompilerGeneratedAttribute]
private DateResolution <Resolution>k__BackingField;
    public DateResolution Resolution { get; }
    public string SortableFieldName { get; }
    public DateTimeType(string fieldName, ILoggerFactory logger, DateResolution resolution, bool store);
    [CompilerGeneratedAttribute]
public DateResolution get_Resolution();
    public virtual string get_SortableFieldName();
    protected virtual void AddSingleValue(Document doc, object value);
    protected long DateToLong(DateTime date);
    public virtual Query GetQuery(string query);
    public virtual Query GetQuery(Nullable`1<DateTime> lower, Nullable`1<DateTime> upper, bool lowerInclusive, bool upperInclusive);
}
public class Examine.Lucene.Indexing.DoubleType : IndexFieldRangeValueType`1<double> {
    public string SortableFieldName { get; }
    public DoubleType(string fieldName, ILoggerFactory logger, bool store);
    public virtual string get_SortableFieldName();
    protected virtual void AddSingleValue(Document doc, object value);
    public virtual Query GetQuery(string query);
    public virtual Query GetQuery(Nullable`1<double> lower, Nullable`1<double> upper, bool lowerInclusive, bool upperInclusive);
}
public class Examine.Lucene.Indexing.FullTextType : IndexFieldValueTypeBase {
    private bool _sortable;
    private Analyzer _analyzer;
    public string SortableFieldName { get; }
    public Analyzer Analyzer { get; }
    public FullTextType(string fieldName, ILoggerFactory logger, Analyzer analyzer, bool sortable);
    public virtual string get_SortableFieldName();
    public virtual Analyzer get_Analyzer();
    protected virtual void AddSingleValue(Document doc, object value);
    public static Query GenerateQuery(string fieldName, string query, Analyzer analyzer);
    public virtual Query GetQuery(string query);
}
public class Examine.Lucene.Indexing.GenericAnalyzerFieldValueType : IndexFieldValueTypeBase {
    private Analyzer _analyzer;
    private bool _sortable;
    public string SortableFieldName { get; }
    public Analyzer Analyzer { get; }
    public GenericAnalyzerFieldValueType(string fieldName, ILoggerFactory logger, Analyzer analyzer, bool sortable);
    public virtual string get_SortableFieldName();
    public virtual Analyzer get_Analyzer();
    protected virtual void AddSingleValue(Document doc, object value);
}
public interface Examine.Lucene.Indexing.IIndexFieldValueType {
    public string FieldName { get; }
    public string SortableFieldName { get; }
    public bool Store { get; }
    public Analyzer Analyzer { get; }
    public abstract virtual string get_FieldName();
    public abstract virtual string get_SortableFieldName();
    public abstract virtual bool get_Store();
    public abstract virtual Analyzer get_Analyzer();
    public abstract virtual void AddValue(Document doc, object value);
    public abstract virtual Query GetQuery(string query);
}
public interface Examine.Lucene.Indexing.IIndexRangeValueType {
    public abstract virtual Query GetQuery(string lower, string upper, bool lowerInclusive, bool upperInclusive);
}
public interface Examine.Lucene.Indexing.IIndexRangeValueType`1 {
    public abstract virtual Query GetQuery(Nullable`1<T> lower, Nullable`1<T> upper, bool lowerInclusive, bool upperInclusive);
}
public abstract class Examine.Lucene.Indexing.IndexFieldRangeValueType`1 : IndexFieldValueTypeBase {
    protected IndexFieldRangeValueType`1(string fieldName, ILoggerFactory logger, bool store);
    public abstract virtual Query GetQuery(Nullable`1<T> lower, Nullable`1<T> upper, bool lowerInclusive, bool upperInclusive);
    public sealed virtual Query GetQuery(string lower, string upper, bool lowerInclusive, bool upperInclusive);
}
public abstract class Examine.Lucene.Indexing.IndexFieldValueTypeBase : object {
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public string FieldName { get; }
    public string SortableFieldName { get; }
    public bool Store { get; }
    public Analyzer Analyzer { get; }
    public ILogger Logger { get; }
    protected IndexFieldValueTypeBase(string fieldName, ILoggerFactory loggerFactory, bool store);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FieldName();
    public virtual string get_SortableFieldName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Store();
    public virtual Analyzer get_Analyzer();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    public virtual void AddValue(Document doc, object value);
    private void AddSingleValueInternal(Document doc, object value);
    protected abstract virtual void AddSingleValue(Document doc, object value);
    public virtual Query GetQuery(string query);
    protected bool TryConvert(object val, T& parsedVal);
}
public class Examine.Lucene.Indexing.Int32Type : IndexFieldRangeValueType`1<int> {
    public string SortableFieldName { get; }
    public Int32Type(string fieldName, ILoggerFactory logger, bool store);
    public virtual string get_SortableFieldName();
    protected virtual void AddSingleValue(Document doc, object value);
    public virtual Query GetQuery(string query);
    public virtual Query GetQuery(Nullable`1<int> lower, Nullable`1<int> upper, bool lowerInclusive, bool upperInclusive);
}
public class Examine.Lucene.Indexing.Int64Type : IndexFieldRangeValueType`1<long> {
    public string SortableFieldName { get; }
    public Int64Type(string fieldName, ILoggerFactory logger, bool store);
    public virtual string get_SortableFieldName();
    protected virtual void AddSingleValue(Document doc, object value);
    public virtual Query GetQuery(string query);
    public virtual Query GetQuery(Nullable`1<long> lower, Nullable`1<long> upper, bool lowerInclusive, bool upperInclusive);
}
public class Examine.Lucene.Indexing.RawStringType : IndexFieldValueTypeBase {
    private Analyzer _analyzer;
    public Analyzer Analyzer { get; }
    public RawStringType(string fieldName, ILoggerFactory logger, bool store);
    public virtual Analyzer get_Analyzer();
    protected virtual void AddSingleValue(Document doc, object value);
}
public class Examine.Lucene.Indexing.SingleType : IndexFieldRangeValueType`1<float> {
    public string SortableFieldName { get; }
    public SingleType(string fieldName, ILoggerFactory logger, bool store);
    public virtual string get_SortableFieldName();
    protected virtual void AddSingleValue(Document doc, object value);
    public virtual Query GetQuery(string query);
    public virtual Query GetQuery(Nullable`1<float> lower, Nullable`1<float> upper, bool lowerInclusive, bool upperInclusive);
}
internal class Examine.Lucene.LoggingInfoStream`1 : InfoStream {
    [CompilerGeneratedAttribute]
private ILogger`1<T> <Logger>k__BackingField;
    public ILogger`1<T> Logger { get; }
    public LoggingInfoStream`1(ILogger`1<T> logger);
    [CompilerGeneratedAttribute]
public ILogger`1<T> get_Logger();
    public virtual bool IsEnabled(string component);
    public virtual void Message(string component, string message);
}
public class Examine.Lucene.LoggingReplicationClient : ReplicationClient {
    private ILogger`1<LoggingReplicationClient> _logger;
    public LoggingReplicationClient(ILogger`1<LoggingReplicationClient> logger, IReplicator replicator, IReplicationHandler handler, ISourceDirectoryFactory factory);
    protected virtual void HandleUpdateException(Exception exception);
}
public class Examine.Lucene.LuceneDirectoryIndexOptions : LuceneIndexOptions {
    [CompilerGeneratedAttribute]
private IDirectoryFactory <DirectoryFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnlockIndex>k__BackingField;
    public IDirectoryFactory DirectoryFactory { get; public set; }
    public bool UnlockIndex { get; public set; }
    [CompilerGeneratedAttribute]
public IDirectoryFactory get_DirectoryFactory();
    [CompilerGeneratedAttribute]
public void set_DirectoryFactory(IDirectoryFactory value);
    [CompilerGeneratedAttribute]
public bool get_UnlockIndex();
    [CompilerGeneratedAttribute]
public void set_UnlockIndex(bool value);
}
[ExtensionAttribute]
public static class Examine.Lucene.LuceneExtensions : object {
    [ExtensionAttribute]
internal static void CopyTo(IndexInput indexInput, IndexOutput indexOutput, string name);
}
public class Examine.Lucene.LuceneIndexOptions : IndexOptions {
    [CompilerGeneratedAttribute]
private IndexDeletionPolicy <IndexDeletionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Analyzer <Analyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IFieldValueTypeFactory> <IndexValueTypesFactory>k__BackingField;
    public IndexDeletionPolicy IndexDeletionPolicy { get; public set; }
    public Analyzer Analyzer { get; public set; }
    public IReadOnlyDictionary`2<string, IFieldValueTypeFactory> IndexValueTypesFactory { get; public set; }
    [CompilerGeneratedAttribute]
public IndexDeletionPolicy get_IndexDeletionPolicy();
    [CompilerGeneratedAttribute]
public void set_IndexDeletionPolicy(IndexDeletionPolicy value);
    [CompilerGeneratedAttribute]
public Analyzer get_Analyzer();
    [CompilerGeneratedAttribute]
public void set_Analyzer(Analyzer value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IFieldValueTypeFactory> get_IndexValueTypesFactory();
    [CompilerGeneratedAttribute]
public void set_IndexValueTypesFactory(IReadOnlyDictionary`2<string, IFieldValueTypeFactory> value);
}
public abstract class Examine.Lucene.Providers.BaseLuceneSearcher : BaseSearchProvider {
    [CompilerGeneratedAttribute]
private Analyzer <LuceneAnalyzer>k__BackingField;
    public Analyzer LuceneAnalyzer { get; }
    protected BaseLuceneSearcher(string name, Analyzer analyzer);
    [CompilerGeneratedAttribute]
public Analyzer get_LuceneAnalyzer();
    public abstract virtual ISearchContext GetSearchContext();
    public virtual IQuery CreateQuery(string category, BooleanOperation defaultOperation);
    public IQuery CreateQuery(string category, BooleanOperation defaultOperation, Analyzer luceneAnalyzer, LuceneSearchOptions searchOptions);
    public virtual ISearchResults Search(string searchText, QueryOptions options);
}
public class Examine.Lucene.Providers.ErrorCheckingScoringBooleanQueryRewrite : RewriteMethod {
    public virtual Query Rewrite(IndexReader reader, MultiTermQuery query);
}
internal class Examine.Lucene.Providers.ErrorLoggingConcurrentMergeScheduler : ConcurrentMergeScheduler {
    private Action`2<string, Exception> _logger;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    public string IndexName { get; }
    public ErrorLoggingConcurrentMergeScheduler(string indexName, Action`2<string, Exception> logger);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    protected virtual void HandleMergeException(Exception exc);
}
public enum Examine.Lucene.Providers.IndexThreadingMode : Enum {
    public int value__;
    public static IndexThreadingMode Asynchronous;
    public static IndexThreadingMode Synchronous;
}
public class Examine.Lucene.Providers.LuceneIndex : BaseIndexProvider {
    private static String[] s_possibleSuffixes;
    private LuceneIndexOptions _options;
    private PerFieldAnalyzerWrapper _fieldAnalyzer;
    private ControlledRealTimeReopenThread`1<IndexSearcher> _nrtReopenThread;
    private ILogger`1<LuceneIndex> _logger;
    private Lazy`1<Directory> _directory;
    private FileStream _logOutput;
    private bool _disposedValue;
    private IndexCommiter _committer;
    private TrackingIndexWriter modreq(System.Runtime.CompilerServices.IsVolatile) _writer;
    private int _activeWrites;
    private object _taskLocker;
    private object _writerLocker;
    private Lazy`1<LuceneSearcher> _searcher;
    private Nullable`1<bool> _exists;
    private Task _asyncTask;
    private CancellationTokenSource _cancellationTokenSource;
    private CancellationToken _cancellationToken;
    private Lazy`1<FieldValueTypeCollection> _fieldValueTypeCollection;
    private Nullable`1<long> _latestGen;
    [CompilerGeneratedAttribute]
private Analyzer <DefaultAnalyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CommitCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<DocumentWritingEventArgs> DocumentWriting;
    [CompilerGeneratedAttribute]
private EventHandler IndexCommitted;
    public ISearcher Searcher { get; }
    public FieldValueTypeCollection FieldValueTypeCollection { get; }
    public Analyzer DefaultAnalyzer { get; }
    public PerFieldAnalyzerWrapper FieldAnalyzer { get; }
    [ObsoleteAttribute("Not used, will be removed in future versions")]
[EditorBrowsableAttribute("1")]
public int CommitCount { get; protected internal set; }
    public bool RunAsync { get; protected internal set; }
    [EditorBrowsableAttribute("1")]
protected bool IsCancellationRequested { get; }
    public TrackingIndexWriter IndexWriter { get; }
    private LuceneIndex(ILoggerFactory loggerFactory, string name, IOptionsMonitor`1<LuceneIndexOptions> indexOptions);
    public LuceneIndex(ILoggerFactory loggerFactory, string name, IOptionsMonitor`1<LuceneDirectoryIndexOptions> indexOptions);
    internal LuceneIndex(ILoggerFactory loggerFactory, string name, IOptionsMonitor`1<LuceneIndexOptions> indexOptions, IndexWriter writer);
    private static LuceneIndex();
    public virtual ISearcher get_Searcher();
    public FieldValueTypeCollection get_FieldValueTypeCollection();
    [CompilerGeneratedAttribute]
public Analyzer get_DefaultAnalyzer();
    public PerFieldAnalyzerWrapper get_FieldAnalyzer();
    [CompilerGeneratedAttribute]
public int get_CommitCount();
    [CompilerGeneratedAttribute]
protected internal void set_CommitCount(int value);
    [CompilerGeneratedAttribute]
public bool get_RunAsync();
    [CompilerGeneratedAttribute]
protected internal void set_RunAsync(bool value);
    protected bool get_IsCancellationRequested();
    [CompilerGeneratedAttribute]
public void add_DocumentWriting(EventHandler`1<DocumentWritingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DocumentWriting(EventHandler`1<DocumentWritingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_IndexCommitted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IndexCommitted(EventHandler value);
    protected virtual void OnIndexingError(IndexingErrorEventArgs e);
    protected virtual void OnDocumentWriting(DocumentWritingEventArgs docArgs);
    protected virtual void PerformIndexItems(IEnumerable`1<ValueSet> values, Action`1<IndexOperationEventArgs> onComplete);
    private int PerformIndexItemsInternal(IEnumerable`1<ValueSet> valueSets, CancellationToken cancellationToken);
    public void EnsureIndex(bool forceOverwrite);
    private void CreateNewIndex(Directory dir);
    public virtual void CreateIndex();
    protected virtual void PerformDeleteFromIndex(IEnumerable`1<string> itemIds, Action`1<IndexOperationEventArgs> onComplete);
    private int PerformDeleteFromIndexInternal(IEnumerable`1<string> itemIds, CancellationToken cancellationToken);
    protected virtual FieldValueTypeCollection CreateFieldValueTypes(IReadOnlyDictionary`2<string, IFieldValueTypeFactory> indexValueTypesFactory);
    protected bool IndexReady();
    public virtual bool IndexExists();
    public bool IsReadable(Exception& ex);
    private bool IndexExistsImpl();
    private bool DeleteFromIndex(Term indexTerm, bool performCommit);
    protected virtual void AddDocument(Document doc, ValueSet valueSet);
    protected virtual Nullable`1<long> UpdateLuceneDocument(Term term, Document doc);
    private bool ProcessQueueItem(IndexOperation item);
    public Directory GetLuceneDirectory();
    private TrackingIndexWriter CreateIndexWriterInternal();
    protected virtual IndexWriter CreateIndexWriter(Directory d);
    public TrackingIndexWriter get_IndexWriter();
    private LuceneSearcher CreateSearcher();
    private void ProcessDeleteQueueItem(IndexOperation op, bool performCommit);
    private bool ProcessIndexQueueItem(IndexOperation op);
    private void QueueTask(Func`1<int> op, Action`1<IndexOperationEventArgs> onComplete, CancellationToken currentToken);
    public void WaitForChanges();
    public IDisposable WithThreadingMode(IndexThreadingMode mode);
    public sealed virtual long GetDocumentCount();
    public sealed virtual IEnumerable`1<string> GetFieldNames();
    private bool RetryUntilSuccessOrTimeout(Func`1<bool> task, TimeSpan timeout, TimeSpan pause, string timeoutMsg);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private sealed virtual override void Lucene.Net.Search.ReferenceManager.IRefreshListener.BeforeRefresh();
    private sealed virtual override void Lucene.Net.Search.ReferenceManager.IRefreshListener.AfterRefresh(bool didRefresh);
    [CompilerGeneratedAttribute]
private FieldValueTypeCollection <.ctor>b__0_0();
    [CompilerGeneratedAttribute]
private void <CreateNewIndex>b__53_0(string s, Exception e);
    [CompilerGeneratedAttribute]
private void <CreateIndexWriter>b__69_0(string s, Exception e);
    [CompilerGeneratedAttribute]
private bool <Dispose>b__82_0();
}
public class Examine.Lucene.Providers.LuceneSearcher : BaseLuceneSearcher {
    private SearcherManager _searcherManager;
    private FieldValueTypeCollection _fieldValueTypeCollection;
    private bool _disposedValue;
    public LuceneSearcher(string name, SearcherManager searcherManager, Analyzer analyzer, FieldValueTypeCollection fieldValueTypeCollection);
    public virtual ISearchContext GetSearchContext();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Examine.Lucene.Providers.MultiIndexSearcher : BaseLuceneSearcher {
    private Lazy`1<IEnumerable`1<ISearcher>> _searchers;
    public IEnumerable`1<LuceneSearcher> Searchers { get; }
    public bool SearchersInitialized { get; }
    public MultiIndexSearcher(string name, IEnumerable`1<IIndex> indexes, Analyzer analyzer);
    public MultiIndexSearcher(string name, Lazy`1<IEnumerable`1<ISearcher>> searchers, Analyzer analyzer);
    public IEnumerable`1<LuceneSearcher> get_Searchers();
    public bool get_SearchersInitialized();
    public virtual ISearchContext GetSearchContext();
}
public class Examine.Lucene.Providers.ValueSetValidatorDelegate : object {
    private Func`2<ValueSet, ValueSetValidationResult> _validator;
    public ValueSetValidatorDelegate(Func`2<ValueSet, ValueSetValidationResult> validator);
    public sealed virtual ValueSetValidationResult Validate(ValueSet valueSet);
}
public enum Examine.Lucene.ReaderStatus : Enum {
    public int value__;
    public static ReaderStatus Current;
    public static ReaderStatus Closed;
    public static ReaderStatus NotCurrent;
}
public class Examine.Lucene.Search.CustomMultiFieldQueryParser : MultiFieldQueryParser {
    private QueryParser _keywordAnalyzerQueryParser;
    [CompilerGeneratedAttribute]
private String[] <SearchableFields>k__BackingField;
    internal QueryParser KeywordAnalyzerQueryParser { get; }
    public String[] SearchableFields { get; }
    public CustomMultiFieldQueryParser(LuceneVersion matchVersion, String[] fields, Analyzer analyzer);
    internal QueryParser get_KeywordAnalyzerQueryParser();
    [CompilerGeneratedAttribute]
public String[] get_SearchableFields();
    public virtual Query GetFuzzyQueryInternal(string field, string termStr, float minSimilarity);
    protected virtual Query GetRangeQuery(string field, string part1, string part2, bool startInclusive, bool endInclusive);
    public virtual Query GetWildcardQueryInternal(string field, string termStr);
    public virtual Query GetProximityQueryInternal(string field, string queryText, int slop);
    public Query GetFieldQueryInternal(string field, string queryText);
}
public class Examine.Lucene.Search.ExamineMultiFieldQueryParser : CustomMultiFieldQueryParser {
    private ISearchContext _searchContext;
    public ExamineMultiFieldQueryParser(ISearchContext searchContext, LuceneVersion matchVersion, Analyzer analyzer);
    protected virtual Query GetRangeQuery(string field, string part1, string part2, bool startInclusive, bool endInclusive);
}
public interface Examine.Lucene.Search.ILuceneSearchResults {
    public SearchAfterOptions SearchAfter { get; }
    public float MaxScore { get; }
    public abstract virtual SearchAfterOptions get_SearchAfter();
    public abstract virtual float get_MaxScore();
}
public interface Examine.Lucene.Search.ISearchContext {
    public String[] SearchableFields { get; }
    public abstract virtual ISearcherReference GetSearcher();
    public abstract virtual String[] get_SearchableFields();
    public abstract virtual IIndexFieldValueType GetFieldValueType(string fieldName);
}
public interface Examine.Lucene.Search.ISearcherReference {
    public IndexSearcher IndexSearcher { get; }
    public abstract virtual IndexSearcher get_IndexSearcher();
}
public class Examine.Lucene.Search.LateBoundQuery : Query {
    private Func`1<Query> _factory;
    private Query _wrapped;
    public Query Wrapped { get; }
    public float Boost { get; public set; }
    public LateBoundQuery(Func`1<Query> factory);
    public Query get_Wrapped();
    public virtual object Clone();
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual float get_Boost();
    public virtual void set_Boost(float value);
    public virtual Query Rewrite(IndexReader reader);
    public virtual string ToString(string field);
}
[DebuggerDisplayAttribute("{_search}")]
public class Examine.Lucene.Search.LuceneBooleanOperation : LuceneBooleanOperationBase {
    private LuceneSearchQuery _search;
    public LuceneBooleanOperation(LuceneSearchQuery search);
    protected virtual INestedQuery AndNested();
    protected virtual INestedQuery OrNested();
    protected virtual INestedQuery NotNested();
    public virtual IQuery And();
    public virtual IQuery Or();
    public virtual IQuery Not();
    public virtual ISearchResults Execute(QueryOptions options);
    public virtual IOrdering OrderBy(SortableField[] fields);
    public virtual IOrdering OrderByDescending(SortableField[] fields);
    public virtual IOrdering SelectFields(ISet`1<string> fieldNames);
    public virtual IOrdering SelectField(string fieldName);
    public virtual IOrdering SelectAllFields();
    public virtual string ToString();
}
public abstract class Examine.Lucene.Search.LuceneBooleanOperationBase : object {
    private LuceneSearchQueryBase _search;
    protected LuceneBooleanOperationBase(LuceneSearchQueryBase search);
    public abstract virtual IQuery And();
    public abstract virtual IQuery Or();
    public abstract virtual IQuery Not();
    public sealed virtual IBooleanOperation And(Func`2<INestedQuery, INestedBooleanOperation> inner, BooleanOperation defaultOp);
    public sealed virtual IBooleanOperation Or(Func`2<INestedQuery, INestedBooleanOperation> inner, BooleanOperation defaultOp);
    public sealed virtual IBooleanOperation AndNot(Func`2<INestedQuery, INestedBooleanOperation> inner, BooleanOperation defaultOp);
    protected abstract virtual INestedQuery AndNested();
    protected abstract virtual INestedQuery OrNested();
    protected abstract virtual INestedQuery NotNested();
    private sealed virtual override INestedQuery Examine.Search.INestedBooleanOperation.And();
    private sealed virtual override INestedQuery Examine.Search.INestedBooleanOperation.Or();
    private sealed virtual override INestedQuery Examine.Search.INestedBooleanOperation.Not();
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedBooleanOperation.And(Func`2<INestedQuery, INestedBooleanOperation> inner, BooleanOperation defaultOp);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedBooleanOperation.Or(Func`2<INestedQuery, INestedBooleanOperation> inner, BooleanOperation defaultOp);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedBooleanOperation.AndNot(Func`2<INestedQuery, INestedBooleanOperation> inner, BooleanOperation defaultOp);
    protected internal LuceneBooleanOperationBase Op(Func`2<INestedQuery, INestedBooleanOperation> inner, BooleanOperation outerOp, Nullable`1<BooleanOperation> defaultInnerOp);
    public abstract virtual ISearchResults Execute(QueryOptions options);
    public abstract virtual IOrdering OrderBy(SortableField[] fields);
    public abstract virtual IOrdering OrderByDescending(SortableField[] fields);
    public abstract virtual IOrdering SelectFields(ISet`1<string> fieldNames);
    public abstract virtual IOrdering SelectField(string fieldName);
    public abstract virtual IOrdering SelectAllFields();
}
public class Examine.Lucene.Search.LuceneQuery : object {
    private LuceneSearchQuery _search;
    private Occur _occurrence;
    public string Category { get; }
    public LuceneQuery(LuceneSearchQuery search, Occur occurrence);
    public sealed virtual IBooleanOperation Field(string fieldName, T fieldValue);
    public sealed virtual IBooleanOperation Field(string fieldName, string fieldValue);
    public sealed virtual IBooleanOperation Field(string fieldName, IExamineValue fieldValue);
    public sealed virtual IBooleanOperation GroupedAnd(IEnumerable`1<string> fields, String[] query);
    public sealed virtual IBooleanOperation GroupedAnd(IEnumerable`1<string> fields, IExamineValue[] query);
    public sealed virtual IBooleanOperation GroupedOr(IEnumerable`1<string> fields, String[] query);
    public sealed virtual IBooleanOperation GroupedOr(IEnumerable`1<string> fields, IExamineValue[] query);
    public sealed virtual IBooleanOperation GroupedNot(IEnumerable`1<string> fields, String[] query);
    public sealed virtual IBooleanOperation GroupedNot(IEnumerable`1<string> fields, IExamineValue[] query);
    public sealed virtual IOrdering All();
    public sealed virtual IBooleanOperation ManagedQuery(string query, String[] fields);
    public sealed virtual IBooleanOperation RangeQuery(String[] fields, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive);
    public string get_Category();
    public sealed virtual IBooleanOperation NativeQuery(string query);
    public sealed virtual IBooleanOperation Group(Func`2<INestedQuery, INestedBooleanOperation> inner, BooleanOperation defaultOp);
    public sealed virtual IBooleanOperation Id(string id);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.Field(string fieldName, T fieldValue);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.Field(string fieldName, string fieldValue);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.Field(string fieldName, IExamineValue fieldValue);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedAnd(IEnumerable`1<string> fields, String[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedAnd(IEnumerable`1<string> fields, IExamineValue[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedOr(IEnumerable`1<string> fields, String[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedOr(IEnumerable`1<string> fields, IExamineValue[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedNot(IEnumerable`1<string> fields, String[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedNot(IEnumerable`1<string> fields, IExamineValue[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.ManagedQuery(string query, String[] fields);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.RangeQuery(String[] fields, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive);
}
public class Examine.Lucene.Search.LuceneQueryOptions : QueryOptions {
    [CompilerGeneratedAttribute]
private bool <TrackDocumentScores>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackDocumentMaxScore>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchAfterOptions <SearchAfter>k__BackingField;
    public bool TrackDocumentScores { get; }
    public bool TrackDocumentMaxScore { get; }
    public SearchAfterOptions SearchAfter { get; }
    public LuceneQueryOptions(int skip, Nullable`1<int> take, SearchAfterOptions searchAfter, bool trackDocumentScores, bool trackDocumentMaxScore);
    [CompilerGeneratedAttribute]
public bool get_TrackDocumentScores();
    [CompilerGeneratedAttribute]
public bool get_TrackDocumentMaxScore();
    [CompilerGeneratedAttribute]
public SearchAfterOptions get_SearchAfter();
}
public class Examine.Lucene.Search.LuceneSearchExecutor : object {
    private QueryOptions _options;
    private LuceneQueryOptions _luceneQueryOptions;
    private IEnumerable`1<SortField> _sortField;
    private ISearchContext _searchContext;
    private Query _luceneQuery;
    private ISet`1<string> _fieldsToLoad;
    private Nullable`1<int> _maxDoc;
    private int MaxDoc { get; }
    internal LuceneSearchExecutor(QueryOptions options, Query query, IEnumerable`1<SortField> sortField, ISearchContext searchContext, ISet`1<string> fieldsToLoad);
    private int get_MaxDoc();
    public ISearchResults Execute();
    private static FieldDoc GetScoreDocAfter(LuceneQueryOptions luceneQueryOptions);
    private static SearchAfterOptions GetSearchAfterOptions(TopDocs topDocs);
    private LuceneSearchResult GetSearchResult(int index, TopDocs topDocs, IndexSearcher luceneSearcher);
    private LuceneSearchResult CreateSearchResult(Document doc, float score, int shardIndex);
    private bool CheckQueryForExtractTerms(Query query);
}
[ExtensionAttribute]
public static class Examine.Lucene.Search.LuceneSearchExtensions : object {
    [ExtensionAttribute]
public static Occur ToLuceneOccurrence(BooleanOperation o);
    [ExtensionAttribute]
public static BooleanOperation ToBooleanOperation(Occur o);
    [ExtensionAttribute]
public static ILuceneSearchResults ExecuteWithLucene(IQueryExecutor queryExecutor, QueryOptions options);
}
public class Examine.Lucene.Search.LuceneSearchOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <LowercaseExpandedTerms>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowLeadingWildcard>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnablePositionIncrements>k__BackingField;
    [CompilerGeneratedAttribute]
private RewriteMethod <MultiTermRewriteMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FuzzyPrefixLength>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeZoneInfo <TimeZone>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PhraseSlop>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <FuzzyMinSim>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateResolution> <DateResolution>k__BackingField;
    public Nullable`1<bool> LowercaseExpandedTerms { get; public set; }
    public Nullable`1<bool> AllowLeadingWildcard { get; public set; }
    public Nullable`1<bool> EnablePositionIncrements { get; public set; }
    public RewriteMethod MultiTermRewriteMethod { get; public set; }
    public Nullable`1<int> FuzzyPrefixLength { get; public set; }
    public CultureInfo Locale { get; public set; }
    public TimeZoneInfo TimeZone { get; public set; }
    public Nullable`1<int> PhraseSlop { get; public set; }
    public Nullable`1<float> FuzzyMinSim { get; public set; }
    public Nullable`1<DateResolution> DateResolution { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_LowercaseExpandedTerms();
    [CompilerGeneratedAttribute]
public void set_LowercaseExpandedTerms(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowLeadingWildcard();
    [CompilerGeneratedAttribute]
public void set_AllowLeadingWildcard(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnablePositionIncrements();
    [CompilerGeneratedAttribute]
public void set_EnablePositionIncrements(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public RewriteMethod get_MultiTermRewriteMethod();
    [CompilerGeneratedAttribute]
public void set_MultiTermRewriteMethod(RewriteMethod value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FuzzyPrefixLength();
    [CompilerGeneratedAttribute]
public void set_FuzzyPrefixLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Locale();
    [CompilerGeneratedAttribute]
public void set_Locale(CultureInfo value);
    [CompilerGeneratedAttribute]
public TimeZoneInfo get_TimeZone();
    [CompilerGeneratedAttribute]
public void set_TimeZone(TimeZoneInfo value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PhraseSlop();
    [CompilerGeneratedAttribute]
public void set_PhraseSlop(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_FuzzyMinSim();
    [CompilerGeneratedAttribute]
public void set_FuzzyMinSim(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateResolution> get_DateResolution();
    [CompilerGeneratedAttribute]
public void set_DateResolution(Nullable`1<DateResolution> value);
}
[DebuggerDisplayAttribute("Category: {Category}, LuceneQuery: {Query}")]
public class Examine.Lucene.Search.LuceneSearchQuery : LuceneSearchQueryBase {
    private ISearchContext _searchContext;
    private ISet`1<string> _fieldsToLoad;
    public LuceneSearchQuery(ISearchContext searchContext, string category, Analyzer analyzer, LuceneSearchOptions searchOptions, BooleanOperation occurance);
    private static CustomMultiFieldQueryParser CreateQueryParser(ISearchContext searchContext, Analyzer analyzer, LuceneSearchOptions searchOptions);
    public virtual IBooleanOperation OrderBy(SortableField[] fields);
    public virtual IBooleanOperation OrderByDescending(SortableField[] fields);
    public virtual IBooleanOperation Field(string fieldName, T fieldValue);
    public virtual IBooleanOperation ManagedQuery(string query, String[] fields);
    public virtual IBooleanOperation RangeQuery(String[] fields, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive);
    protected virtual INestedBooleanOperation FieldNested(string fieldName, T fieldValue);
    protected virtual INestedBooleanOperation ManagedQueryNested(string query, String[] fields);
    protected virtual INestedBooleanOperation RangeQueryNested(String[] fields, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive);
    internal LuceneBooleanOperationBase ManagedQueryInternal(string query, String[] fields, Occur occurance);
    internal LuceneBooleanOperationBase RangeQueryInternal(String[] fields, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive, Occur occurance);
    public sealed virtual ISearchResults Execute(QueryOptions options);
    private ISearchResults Search(QueryOptions options);
    private LuceneBooleanOperationBase OrderByInternal(bool descending, SortableField[] fields);
    internal IBooleanOperation SelectFieldsInternal(ISet`1<string> loadedFieldNames);
    internal IBooleanOperation SelectFieldInternal(string fieldName);
    public IBooleanOperation SelectAllFieldsInternal();
    protected virtual LuceneBooleanOperationBase CreateOp();
}
public abstract class Examine.Lucene.Search.LuceneSearchQueryBase : object {
    private CustomMultiFieldQueryParser _queryParser;
    [CompilerGeneratedAttribute]
private Stack`1<BooleanQuery> <Queries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SortField> <SortFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Occur <Occurrence>k__BackingField;
    private BooleanOperation _boolOp;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private LuceneSearchOptions <SearchOptions>k__BackingField;
    private static String[] s_emptyStringArray;
    public QueryParser QueryParser { get; }
    internal Stack`1<BooleanQuery> Queries { get; }
    public BooleanQuery Query { get; }
    public IList`1<SortField> SortFields { get; }
    protected Occur Occurrence { get; protected set; }
    public BooleanOperation BooleanOperation { get; public set; }
    public string Category { get; }
    public String[] AllFields { get; }
    public LuceneSearchOptions SearchOptions { get; }
    protected LuceneSearchQueryBase(CustomMultiFieldQueryParser queryParser, string category, LuceneSearchOptions searchOptions, BooleanOperation occurance);
    private static LuceneSearchQueryBase();
    public QueryParser get_QueryParser();
    [CompilerGeneratedAttribute]
internal Stack`1<BooleanQuery> get_Queries();
    public BooleanQuery get_Query();
    [CompilerGeneratedAttribute]
public IList`1<SortField> get_SortFields();
    [CompilerGeneratedAttribute]
protected Occur get_Occurrence();
    [CompilerGeneratedAttribute]
protected void set_Occurrence(Occur value);
    protected abstract virtual LuceneBooleanOperationBase CreateOp();
    public BooleanOperation get_BooleanOperation();
    public void set_BooleanOperation(BooleanOperation value);
    [CompilerGeneratedAttribute]
public string get_Category();
    public String[] get_AllFields();
    [CompilerGeneratedAttribute]
public LuceneSearchOptions get_SearchOptions();
    public sealed virtual IBooleanOperation Group(Func`2<INestedQuery, INestedBooleanOperation> inner, BooleanOperation defaultOp);
    public sealed virtual IOrdering All();
    public sealed virtual IBooleanOperation NativeQuery(string query);
    public LuceneBooleanOperationBase LuceneQuery(Query query, Nullable`1<BooleanOperation> op);
    public sealed virtual IBooleanOperation Id(string id);
    public abstract virtual IBooleanOperation Field(string fieldName, T fieldValue);
    public abstract virtual IBooleanOperation ManagedQuery(string query, String[] fields);
    public abstract virtual IBooleanOperation RangeQuery(String[] fields, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive);
    public sealed virtual IBooleanOperation Field(string fieldName, string fieldValue);
    public sealed virtual IBooleanOperation Field(string fieldName, IExamineValue fieldValue);
    public sealed virtual IBooleanOperation GroupedAnd(IEnumerable`1<string> fields, String[] query);
    public sealed virtual IBooleanOperation GroupedAnd(IEnumerable`1<string> fields, IExamineValue[] fieldVals);
    public sealed virtual IBooleanOperation GroupedOr(IEnumerable`1<string> fields, String[] query);
    public sealed virtual IBooleanOperation GroupedOr(IEnumerable`1<string> fields, IExamineValue[] query);
    public sealed virtual IBooleanOperation GroupedNot(IEnumerable`1<string> fields, String[] query);
    public sealed virtual IBooleanOperation GroupedNot(IEnumerable`1<string> fields, IExamineValue[] query);
    protected abstract virtual INestedBooleanOperation FieldNested(string fieldName, T fieldValue);
    protected abstract virtual INestedBooleanOperation ManagedQueryNested(string query, String[] fields);
    protected abstract virtual INestedBooleanOperation RangeQueryNested(String[] fields, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.Field(string fieldName, string fieldValue);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.Field(string fieldName, IExamineValue fieldValue);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedAnd(IEnumerable`1<string> fields, String[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedAnd(IEnumerable`1<string> fields, IExamineValue[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedOr(IEnumerable`1<string> fields, String[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedOr(IEnumerable`1<string> fields, IExamineValue[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedNot(IEnumerable`1<string> fields, String[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.GroupedNot(IEnumerable`1<string> fields, IExamineValue[] query);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.ManagedQuery(string query, String[] fields);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.RangeQuery(String[] fields, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive);
    private sealed virtual override INestedBooleanOperation Examine.Search.INestedQuery.Field(string fieldName, T fieldValue);
    protected internal LuceneBooleanOperationBase FieldInternal(string fieldName, IExamineValue fieldValue, Occur occurrence);
    private LuceneBooleanOperationBase FieldInternal(string fieldName, IExamineValue fieldValue, Occur occurrence, bool useQueryParser);
    protected internal LuceneBooleanOperationBase GroupedAndInternal(String[] fields, IExamineValue[] fieldVals, Occur occurrence);
    protected internal LuceneBooleanOperationBase GroupedNotInternal(String[] fields, IExamineValue[] fieldVals);
    protected internal LuceneBooleanOperationBase GroupedOrInternal(String[] fields, IExamineValue[] fieldVals, Occur occurrence);
    protected internal LuceneBooleanOperationBase IdInternal(string id, Occur occurrence);
    protected virtual Query GetFieldInternalQuery(string fieldName, IExamineValue fieldValue, bool useQueryParser);
    private Query ParseRawQuery(string rawQuery);
    private static Query CreatePhraseQuery(string field, string txt);
    private BooleanQuery GetMultiFieldQuery(IReadOnlyList`1<string> fields, IReadOnlyList`1<IExamineValue> fieldVals, Occur occurance, bool matchAllCombinations);
    public virtual string ToString();
}
public class Examine.Lucene.Search.LuceneSearchResult : SearchResult {
    [CompilerGeneratedAttribute]
private int <ShardIndex>k__BackingField;
    public int ShardIndex { get; }
    public LuceneSearchResult(string id, float score, Func`1<IDictionary`2<string, List`1<string>>> lazyFieldVals, int shardId);
    [CompilerGeneratedAttribute]
public int get_ShardIndex();
}
public class Examine.Lucene.Search.LuceneSearchResults : object {
    [CompilerGeneratedAttribute]
private static LuceneSearchResults <Empty>k__BackingField;
    private IReadOnlyCollection`1<ISearchResult> _results;
    [CompilerGeneratedAttribute]
private long <TotalItemCount>k__BackingField;
    [CompilerGeneratedAttribute]
private float <MaxScore>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchAfterOptions <SearchAfter>k__BackingField;
    public static LuceneSearchResults Empty { get; }
    public long TotalItemCount { get; }
    public float MaxScore { get; }
    public SearchAfterOptions SearchAfter { get; }
    public LuceneSearchResults(IReadOnlyCollection`1<ISearchResult> results, int totalItemCount, float maxScore, SearchAfterOptions searchAfterOptions);
    private static LuceneSearchResults();
    [CompilerGeneratedAttribute]
public static LuceneSearchResults get_Empty();
    [CompilerGeneratedAttribute]
public sealed virtual long get_TotalItemCount();
    [CompilerGeneratedAttribute]
public sealed virtual float get_MaxScore();
    [CompilerGeneratedAttribute]
public sealed virtual SearchAfterOptions get_SearchAfter();
    public sealed virtual IEnumerator`1<ISearchResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Examine.Lucene.Search.MultiSearchContext : object {
    private ISearchContext[] _inner;
    private String[] _fields;
    public String[] SearchableFields { get; }
    public MultiSearchContext(ISearchContext[] inner);
    public sealed virtual ISearcherReference GetSearcher();
    public sealed virtual String[] get_SearchableFields();
    public sealed virtual IIndexFieldValueType GetFieldValueType(string fieldName);
}
public class Examine.Lucene.Search.MultiSearchSearcherReference : object {
    private bool _disposedValue;
    private IndexSearcher _searcher;
    private ISearcherReference[] _inner;
    public IndexSearcher IndexSearcher { get; }
    public MultiSearchSearcherReference(ISearcherReference[] inner);
    public sealed virtual IndexSearcher get_IndexSearcher();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Examine.Lucene.Search.SearchAfterOptions : object {
    [CompilerGeneratedAttribute]
private int <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private float <DocumentScore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ShardIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Fields>k__BackingField;
    public int DocumentId { get; }
    public float DocumentScore { get; }
    public Nullable`1<int> ShardIndex { get; }
    public Object[] Fields { get; }
    public SearchAfterOptions(int documentId, float documentScore, Object[] fields, int shardIndex);
    [CompilerGeneratedAttribute]
public int get_DocumentId();
    [CompilerGeneratedAttribute]
public float get_DocumentScore();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ShardIndex();
    [CompilerGeneratedAttribute]
public Object[] get_Fields();
}
public class Examine.Lucene.Search.SearchContext : object {
    private SearcherManager _searcherManager;
    private FieldValueTypeCollection _fieldValueTypeCollection;
    private String[] _searchableFields;
    public String[] SearchableFields { get; }
    public SearchContext(SearcherManager searcherManager, FieldValueTypeCollection fieldValueTypeCollection);
    public sealed virtual ISearcherReference GetSearcher();
    public sealed virtual String[] get_SearchableFields();
    public sealed virtual IIndexFieldValueType GetFieldValueType(string fieldName);
}
public class Examine.Lucene.Search.SearcherReference : object {
    private bool _disposedValue;
    private SearcherManager _searcherManager;
    private IndexSearcher _searcher;
    public IndexSearcher IndexSearcher { get; }
    public SearcherReference(SearcherManager searcherManager);
    public sealed virtual IndexSearcher get_IndexSearcher();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Examine.Lucene.ValueTypeFactoryCollection : object {
    private ConcurrentDictionary`2<string, IFieldValueTypeFactory> _valueTypeFactories;
    public int Count { get; }
    public ValueTypeFactoryCollection(IReadOnlyDictionary`2<string, IFieldValueTypeFactory> valueTypeFactories);
    public bool TryGetFactory(string valueTypeName, IFieldValueTypeFactory& fieldValueTypeFactory);
    public IFieldValueTypeFactory GetRequiredFactory(string valueTypeName);
    public int get_Count();
    public static IReadOnlyDictionary`2<string, IFieldValueTypeFactory> GetDefaultValueTypes(ILoggerFactory loggerFactory, Analyzer defaultAnalyzer);
    private static IReadOnlyDictionary`2<string, Func`2<string, IIndexFieldValueType>> GetDefaults(ILoggerFactory loggerFactory, Analyzer defaultAnalyzer);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, IFieldValueTypeFactory>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class Examine.LuceneInfo : object {
    [CompilerGeneratedAttribute]
private static LuceneVersion <CurrentVersion>k__BackingField;
    public static LuceneVersion CurrentVersion { get; }
    private static LuceneInfo();
    [CompilerGeneratedAttribute]
public static LuceneVersion get_CurrentVersion();
}
[ExtensionAttribute]
public static class Examine.StringExtensions : object {
    [ExtensionAttribute]
public static string GenerateHash(string str);
    [ExtensionAttribute]
public static string GenerateSha1Hash(string str);
    [ExtensionAttribute]
public static string GenerateMd5(string str);
    [ExtensionAttribute]
private static string GenerateHash(string str, string hashType);
    [ExtensionAttribute]
internal static string EnsureEndsWith(string input, char value);
    [ExtensionAttribute]
internal static string ReplaceNonAlphanumericChars(string input, string replacement);
    private static bool IsStandardAnalyzerStopWord(string stringToCheck);
    [ExtensionAttribute]
public static string RemoveStopWords(string searchText);
}
