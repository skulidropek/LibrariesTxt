public class CoverageExcludeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[ExtensionAttribute]
public static class Xpand.Utils.BackingFieldResolver.BackingFieldResolver : object {
    private static ILPattern GetterPattern;
    private static ILPattern SetterPattern;
    private static BackingFieldResolver();
    private static FieldInfo GetBackingField(MethodInfo method, ILPattern pattern);
    [ExtensionAttribute]
public static FieldInfo GetBackingField(PropertyInfo self);
}
internal abstract class Xpand.Utils.BackingFieldResolver.ILPattern : object {
    public static ILPattern Optional(OpCode opcode);
    public static ILPattern Optional(ILPattern pattern);
    public static ILPattern Sequence(ILPattern[] patterns);
    public static ILPattern OpCode(OpCode opcode);
    public static ILPattern Either(ILPattern a, ILPattern b);
    public static ILPattern Field(OpCode opcode);
    internal abstract virtual void Match(MatchContext context);
    internal bool TryMatch(MatchContext context);
    public static MatchContext Match(MethodBase method, ILPattern pattern);
}
public class Xpand.Utils.BackingFieldResolver.Instruction : object {
    private OpCode opcode;
    private object operand;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Instruction <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Instruction <Next>k__BackingField;
    public int Offset { get; public set; }
    public OpCode OpCode { get; public set; }
    public object Operand { get; public set; }
    public Instruction Previous { get; public set; }
    public Instruction Next { get; public set; }
    internal Instruction(int offset, OpCode opCode, object operand);
    internal Instruction(int offset, OpCode opCode);
    internal Instruction(OpCode opCode, object operand);
    internal Instruction(OpCode opCode);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    public OpCode get_OpCode();
    public void set_OpCode(OpCode value);
    public object get_Operand();
    public void set_Operand(object value);
    [CompilerGeneratedAttribute]
public Instruction get_Previous();
    [CompilerGeneratedAttribute]
public void set_Previous(Instruction value);
    [CompilerGeneratedAttribute]
public Instruction get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(Instruction value);
    public int GetSize();
    public virtual string ToString();
}
internal class Xpand.Utils.BackingFieldResolver.MatchContext : object {
    internal FieldInfo field;
    internal Instruction _instruction;
    internal bool success;
    public MatchContext(Instruction instruction);
    public void Reset(Instruction instruction);
    public void Advance();
}
[ExtensionAttribute]
public static class Xpand.Utils.BackingFieldResolver.MethodBaseRocks : object {
    [ExtensionAttribute]
public static IList`1<Instruction> GetInstructions(MethodBase self);
}
internal class Xpand.Utils.BackingFieldResolver.MethodBodyReader : object {
    private static OpCode[] one_byte_opcodes;
    private static OpCode[] two_bytes_opcodes;
    private MethodBody body;
    private Instruction instruction;
    private List`1<Instruction> instructions;
    private IList`1<LocalVariableInfo> locals;
    private MethodBase method;
    private Type[] method_arguments;
    private Module module;
    private ParameterInfo[] parameters;
    private ByteBuffer raw_il;
    private Type[] type_arguments;
    private static MethodBodyReader();
    private MethodBodyReader(MethodBase method);
    private static IEnumerable`1<FieldInfo> GetOpCodeFields();
    private void ReadInstructions();
    private void CreateInstruction();
    private void ReadInstruction();
    private object GetVariable(int index);
    private static bool TargetsLocalVariable(OpCode opcode);
    private LocalVariableInfo GetLocalVariable(int index);
    private ParameterInfo GetParameter(int index);
    private OpCode ReadOpCode();
    public static List`1<Instruction> GetInstructions(MethodBase method);
}
public abstract class Xpand.Utils.ExpressionBuilder.Builder`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Dictionary`2<PropertyInfo, object> <PropertiesAndValues>k__BackingField;
    private Dictionary`2<PropertyInfo, object> PropertiesAndValues { get; private set; }
    [CompilerGeneratedAttribute]
private Dictionary`2<PropertyInfo, object> get_PropertiesAndValues();
    [CompilerGeneratedAttribute]
private void set_PropertiesAndValues(Dictionary`2<PropertyInfo, object> value);
    public sealed virtual T Build();
    private static PropertyInfo GetProperty(Expression`1<Func`2<T, object>> expression);
    public static T op_Implicit(Builder`1<T> builder);
    protected void ProvideValueFor(Expression`1<Func`2<T, object>> expression, object value);
    private void SetPropertyAndValue(PropertyInfo property, object value);
    private void RegisterPropertyAndValue(PropertyInfo property, object value);
    private static bool IsCollection(PropertyInfo property);
    private static bool IsCollection(FieldInfo field);
    private static bool IsCollectionOfType(Type collectionType, Type type);
    private static bool HasParameterlessConstructor(Type type);
    private static void SetValueFor(PropertyInfo property, T instance, object value);
    private static void SetCollectionValuesFor(PropertyInfo property, T instance, IEnumerable`1<object> values);
}
public interface Xpand.Utils.ExpressionBuilder.IBuilder`1 {
    public abstract virtual T Build();
}
[ExtensionAttribute]
public static class Xpand.Utils.Fastreflect.PropertyExtensions : object {
    [ExtensionAttribute]
public static bool IsReservedName(string name);
    [ExtensionAttribute]
public static string TrimExplicitlyImplementedName(string name);
    [ExtensionAttribute]
private static bool ContainsOverride(IEnumerable`1<T> candidates, MethodInfo method);
    [ExtensionAttribute]
public static IList`1<T> Filter(IList`1<T> members, Flags bindingFlags);
    [ExtensionAttribute]
public static PropertyInfo PropertyX(Type type, string name);
    [ExtensionAttribute]
public static PropertyInfo PropertyX(Type type, string name, Flags bindingFlags);
}
public class Xpand.Utils.GeneralDataStructures.ConcurrentHashSet`1 : object {
    private HashSet`1<T> _hashSet;
    private ReaderWriterLockSlim _lock;
    public int Count { get; }
    public int get_Count();
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool TryAdd(T item);
    public void Clear();
    public bool Contains(T item);
    public bool TryRemove(T item);
    public T FirstOrDefault(Func`2<T, bool> predicate);
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
public static class Xpand.Utils.GeneralDataStructures.ExtensionMethods : object {
    [ExtensionAttribute]
public static MultiValueDictionary`2<TKey, TValue> ToMultiValueDictionary(IEnumerable`1<TValue> source, Func`2<TValue, TKey> keySelectorFunc);
    [ExtensionAttribute]
public static IEnumerable`1<TKey> KeysFromValue(Dictionary`2<TKey, TValue> dict, TValue val);
}
public class Xpand.Utils.GeneralDataStructures.Grouping`2 : object {
    private IEnumerable`1<TElement> _elements;
    private TKey _key;
    private TKey System.Linq.IGrouping<TKey,TElement>.Key { get; }
    public Grouping`2(TKey key, IEnumerable`1<TElement> elements);
    private sealed virtual override TKey System.Linq.IGrouping<TKey,TElement>.get_Key();
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Xpand.Utils.GeneralDataStructures.HashedArrayList : ArrayList {
    private HashSet`1<object> hashSet;
    public virtual bool Contains(object item);
    public virtual void Clear();
    public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    public virtual object Clone();
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    [CompilerGeneratedAttribute]
private bool <AddRange>b__4_0(object o);
    [CompilerGeneratedAttribute]
private bool <InsertRange>b__7_0(object o);
}
[DefaultMemberAttribute("Item")]
public class Xpand.Utils.GeneralDataStructures.MultiKeyDictionary`3 : object {
    internal Dictionary`2<K, V> baseDictionary;
    internal Dictionary`2<K, L> primaryToSubkeyMapping;
    private ReaderWriterLockSlim readerWriterLock;
    internal Dictionary`2<L, K> subDictionary;
    public V Item { get; }
    public V Item { get; }
    public List`1<V> Values { get; }
    public int Count { get; }
    public V get_Item(L subKey);
    public V get_Item(K primaryKey);
    public List`1<V> get_Values();
    public int get_Count();
    public void Associate(L subKey, K primaryKey);
    public bool TryGetValue(L subKey, V& val);
    public bool TryGetValue(K primaryKey, V& val);
    public bool ContainsKey(L subKey);
    public bool ContainsKey(K primaryKey);
    public void Remove(K primaryKey);
    public void Remove(L subKey);
    public void Add(K primaryKey, V val);
    public void Add(K primaryKey, L subKey, V val);
    public V[] CloneValues();
    public K[] ClonePrimaryKeys();
    public L[] CloneSubKeys();
    public void Clear();
    public IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
}
public class Xpand.Utils.GeneralDataStructures.MultiValueDictionary`2 : ConcurrentDictionary`2<TKey, ConcurrentHashSet`1<TValue>> {
    private int System.Linq.ILookup<TKey,TValue>.Count { get; }
    private IEnumerable`1<TValue> System.Linq.ILookup<TKey,TValue>.Item { get; }
    private sealed virtual override bool System.Linq.ILookup<TKey,TValue>.Contains(TKey key);
    private sealed virtual override int System.Linq.ILookup<TKey,TValue>.get_Count();
    private sealed virtual override IEnumerable`1<TValue> System.Linq.ILookup<TKey,TValue>.get_Item(TKey key);
    [IteratorStateMachineAttribute("Xpand.Utils.GeneralDataStructures.MultiValueDictionary`2/<System-Collections-Generic-IEnumerable<System-Linq-IGrouping<TKey,TValue>>-GetEnumerator>d__5")]
private sealed virtual override IEnumerator`1<IGrouping`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Linq.IGrouping<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(TKey key, TValue value);
    public void AddRange(TKey key, IEnumerable`1<TValue> values);
    public bool ContainsValue(TKey key, TValue value);
    public void Remove(TKey key, TValue value);
    public void Merge(MultiValueDictionary`2<TKey, TValue> toMergeWith);
    public ConcurrentHashSet`1<TValue> GetValues(TKey key, bool returnEmptySet);
}
public class Xpand.Utils.GeneralDataStructures.SerializableDictionary`2 : Dictionary`2<TKey, TValue> {
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void ReadXml(XmlReader reader);
    public sealed virtual void WriteXml(XmlWriter writer);
}
public class Xpand.Utils.Helpers.BaseClassExplicitInterfaceInvoker`1 : object {
    private Dictionary`2<string, MethodInfo> _cache;
    private Type _baseType;
    private MethodInfo FindMethod(string methodName);
    public TRt Invoke(T obj, string methodName, Object[] paramaters);
}
public class Xpand.Utils.Helpers.CompilerException : Exception {
    private CompilerErrorExceptionState _state;
    public CompilerResults CompilerResults { get; }
    public string SourceCode { get; }
    public CompilerException(CompilerResults compilerResults, string source, string errors);
    public CompilerResults get_CompilerResults();
    public string get_SourceCode();
}
[ObsoleteAttribute("Not run in .netcore")]
public class Xpand.Utils.Helpers.CSharpEvaluator : object {
    public static List`1<string> Usings;
    public static List`1<string> References;
    private static object Locker;
    private static Dictionary`2<int, Assembly> EvaluatorAssemblies;
    private static CSharpEvaluator();
    public static object Eval(string csCode, String[] usings);
    private static Assembly GetCompiledAssembly(string csCode, String[] usings, String[] referencedAssemblies);
    private static object EvalCode(Assembly assembly);
}
[ExtensionAttribute]
public static class Xpand.Utils.Helpers.EnumerableExtensions : object {
    [ExtensionAttribute]
public static bool ContainsExactly(IEnumerable`1<T> source, int count);
    [ExtensionAttribute]
public static bool ContainsExactly(IEnumerable`1<T> source, int count, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool ContainsMoreThan(IEnumerable`1<T> source, int count);
    [ExtensionAttribute]
public static bool ContainsMoreThan(IEnumerable`1<T> source, int count, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static string AggregateWith(IEnumerable`1<string> instance, string accumulator);
    [ExtensionAttribute]
public static void Each(IEnumerable`1<T> instance, Action`1<T> action);
}
[ExtensionAttribute]
public static class Xpand.Utils.Helpers.EnviromentEx : object {
    private static bool WTSLogoffSession(IntPtr hServer, int sessionId, bool bWait);
    private static bool WTSQuerySessionInformation(IntPtr hServer, int sessionId, WTS_INFO_CLASS wtsInfoClass, IntPtr& ppBuffer, UInt32& pBytesReturned);
    private static IntPtr WTSOpenServer(string pServerName);
    private static void WTSCloseServer(IntPtr hServer);
    private static int WTSEnumerateSessions(IntPtr hServer, int reserved, int version, IntPtr& ppSessionInfo, Int32& pCount);
    private static void WTSFreeMemory(IntPtr pMemory);
    [DebuggerStepThroughAttribute]
private static void KillProcess(string user, ManagementObject managementObject, Func`2<int, bool> match);
    private static void KillProcessAndChildren(int pid);
    public static void KillProccesses(string user, Func`2<int, bool> match);
    public static void LogOffAllUsers(String[] users);
    private static Dictionary`2<string, int> GetUserSessionDictionary(IntPtr server, IEnumerable`1<long> sessions);
    private static bool LogOffUser(string userName, IntPtr server);
    public static bool LogOffUser(string userName);
    private static IEnumerable`1<long> GetSessionIDs(IntPtr server);
    private static string GetUserName(int sessionId, IntPtr server);
    [ExtensionAttribute]
public static IEnumerable`1<Process> GetRunningProcess(Process currentProcess);
}
[ExtensionAttribute]
public static class Xpand.Utils.Helpers.ImageExtensions : object {
    private static Size GetPhotoSize(Image image, int maxWidth, int maxHeight);
    [ExtensionAttribute]
public static Image CreateImage(Image srcImage, int maxWidth, int maxHeight);
}
[FlagsAttribute]
public enum Xpand.Utils.Helpers.Keys : Enum {
    public int value__;
    public static Keys KeyCode;
    public static Keys Modifiers;
    public static Keys None;
    public static Keys LButton;
    public static Keys RButton;
    public static Keys Cancel;
    public static Keys MButton;
    public static Keys XButton1;
    public static Keys XButton2;
    public static Keys Back;
    public static Keys Tab;
    public static Keys LineFeed;
    public static Keys Clear;
    public static Keys Return;
    public static Keys Enter;
    public static Keys ShiftKey;
    public static Keys ControlKey;
    public static Keys Menu;
    public static Keys Pause;
    public static Keys Capital;
    public static Keys CapsLock;
    public static Keys KanaMode;
    public static Keys HanguelMode;
    public static Keys HangulMode;
    public static Keys JunjaMode;
    public static Keys FinalMode;
    public static Keys HanjaMode;
    public static Keys KanjiMode;
    public static Keys Escape;
    public static Keys IMEConvert;
    public static Keys IMENonconvert;
    public static Keys IMEAccept;
    public static Keys IMEAceept;
    public static Keys IMEModeChange;
    public static Keys Space;
    public static Keys Prior;
    public static Keys PageUp;
    public static Keys Next;
    public static Keys PageDown;
    public static Keys End;
    public static Keys Home;
    public static Keys Left;
    public static Keys Up;
    public static Keys Right;
    public static Keys Down;
    public static Keys Select;
    public static Keys Print;
    public static Keys Execute;
    public static Keys Snapshot;
    public static Keys PrintScreen;
    public static Keys Insert;
    public static Keys Delete;
    public static Keys Help;
    public static Keys D0;
    public static Keys D1;
    public static Keys D2;
    public static Keys D3;
    public static Keys D4;
    public static Keys D5;
    public static Keys D6;
    public static Keys D7;
    public static Keys D8;
    public static Keys D9;
    public static Keys A;
    public static Keys B;
    public static Keys C;
    public static Keys D;
    public static Keys E;
    public static Keys F;
    public static Keys G;
    public static Keys H;
    public static Keys I;
    public static Keys J;
    public static Keys K;
    public static Keys L;
    public static Keys M;
    public static Keys N;
    public static Keys O;
    public static Keys P;
    public static Keys Q;
    public static Keys R;
    public static Keys S;
    public static Keys T;
    public static Keys U;
    public static Keys V;
    public static Keys W;
    public static Keys X;
    public static Keys Y;
    public static Keys Z;
    public static Keys LWin;
    public static Keys RWin;
    public static Keys Apps;
    public static Keys Sleep;
    public static Keys NumPad0;
    public static Keys NumPad1;
    public static Keys NumPad2;
    public static Keys NumPad3;
    public static Keys NumPad4;
    public static Keys NumPad5;
    public static Keys NumPad6;
    public static Keys NumPad7;
    public static Keys NumPad8;
    public static Keys NumPad9;
    public static Keys Multiply;
    public static Keys Add;
    public static Keys Separator;
    public static Keys Subtract;
    public static Keys Decimal;
    public static Keys Divide;
    public static Keys F1;
    public static Keys F2;
    public static Keys F3;
    public static Keys F4;
    public static Keys F5;
    public static Keys F6;
    public static Keys F7;
    public static Keys F8;
    public static Keys F9;
    public static Keys F10;
    public static Keys F11;
    public static Keys F12;
    public static Keys F13;
    public static Keys F14;
    public static Keys F15;
    public static Keys F16;
    public static Keys F17;
    public static Keys F18;
    public static Keys F19;
    public static Keys F20;
    public static Keys F21;
    public static Keys F22;
    public static Keys F23;
    public static Keys F24;
    public static Keys NumLock;
    public static Keys Scroll;
    public static Keys LShiftKey;
    public static Keys RShiftKey;
    public static Keys LControlKey;
    public static Keys RControlKey;
    public static Keys LMenu;
    public static Keys RMenu;
    public static Keys BrowserBack;
    public static Keys BrowserForward;
    public static Keys BrowserRefresh;
    public static Keys BrowserStop;
    public static Keys BrowserSearch;
    public static Keys BrowserFavorites;
    public static Keys BrowserHome;
    public static Keys VolumeMute;
    public static Keys VolumeDown;
    public static Keys VolumeUp;
    public static Keys MediaNextTrack;
    public static Keys MediaPreviousTrack;
    public static Keys MediaStop;
    public static Keys MediaPlayPause;
    public static Keys LaunchMail;
    public static Keys SelectMedia;
    public static Keys LaunchApplication1;
    public static Keys LaunchApplication2;
    public static Keys OemSemicolon;
    public static Keys Oem1;
    public static Keys Oemplus;
    public static Keys Oemcomma;
    public static Keys OemMinus;
    public static Keys OemPeriod;
    public static Keys OemQuestion;
    public static Keys Oem2;
    public static Keys Oemtilde;
    public static Keys Oem3;
    public static Keys OemOpenBrackets;
    public static Keys Oem4;
    public static Keys OemPipe;
    public static Keys Oem5;
    public static Keys OemCloseBrackets;
    public static Keys Oem6;
    public static Keys OemQuotes;
    public static Keys Oem7;
    public static Keys Oem8;
    public static Keys OemBackslash;
    public static Keys Oem102;
    public static Keys ProcessKey;
    public static Keys Packet;
    public static Keys Attn;
    public static Keys Crsel;
    public static Keys Exsel;
    public static Keys EraseEof;
    public static Keys Play;
    public static Keys Zoom;
    public static Keys NoName;
    public static Keys Pa1;
    public static Keys OemClear;
    public static Keys Shift;
    public static Keys Control;
    public static Keys Alt;
}
public class Xpand.Utils.Helpers.KeysConverter : TypeConverter {
    private List`1<string> _displayOrder;
    private IDictionary _keyNames;
    private StandardValuesCollection _values;
    private IDictionary KeyNames { get; }
    private IEnumerable`1<string> DisplayOrder { get; }
    private IDictionary get_KeyNames();
    private IEnumerable`1<string> get_DisplayOrder();
    public sealed virtual int Compare(object a, object b);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    private void AddKey(string key, Keys value);
    private void Initialize();
}
public class Xpand.Utils.Helpers.KeyShortcut : object {
    public static KeyShortcut Empty;
    private Keys _keys;
    public Keys Key { get; }
    public bool IsExist { get; }
    public static string AltKeyName { get; }
    public static string ShiftKeyName { get; }
    public static string ControlKeyName { get; }
    public KeyShortcut(Shortcut shortcut);
    public KeyShortcut(Keys key);
    private static KeyShortcut();
    public Keys get_Key();
    public bool get_IsExist();
    public static string get_AltKeyName();
    public static string get_ShiftKeyName();
    public static string get_ControlKeyName();
    public virtual string ToString();
    private Keys CheckKey(Keys key, bool isSecond);
    private bool IsValidShortcut(Keys key);
    public static string GetKeyDisplayText(Keys key);
    private static string GetModifierKeyName(Keys key);
    public static bool op_Equality(KeyShortcut left, KeyShortcut right);
    public static bool op_Inequality(KeyShortcut left, KeyShortcut right);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class Xpand.Utils.Helpers.LinqExpressionAccessors : object {
    private static Dictionary`2<KeyValuePair`2<Type, string>, object> Delegates;
    private static LinqExpressionAccessors();
    public static Func`2<T, R> GenerateMemberGetter(string member_name);
    public static Func`2<object, R> GenerateMemberGetter(Type type, string member_name);
    public static ValueTypeMemberSetterDelegate`2<T, V> GenerateValueTypeMemberSetter(string member_name);
    public static ReferenceTypeMemberSetterDelegate`2<T, V> GenerateReferenceTypeMemberSetter(string member_name);
    [ExtensionAttribute]
public static ReferenceTypeMemberSetterDelegate`2<object, V> GenerateReferenceTypeMemberSetter(object obj, string member_name);
}
[ExtensionAttribute]
public static class Xpand.Utils.Helpers.ListExtensions : object {
    [ExtensionAttribute]
public static IList`1<T> Shuffle(IList`1<T> list);
}
[ExtensionAttribute]
public static class Xpand.Utils.Helpers.NotificationExtensions : object {
    [ExtensionAttribute]
public static void Notify(PropertyChangedEventHandler eventHandler, Expression`1<Func`1<object>> property);
    [ExtensionAttribute]
public static void SubscribeToPropertyChange(T objectThatNotifies, Expression`1<Func`1<object>> property, PropertyChangedHandler`1<T> handler);
    [ExtensionAttribute]
public static void SubscribeToPropertyChange(T objectThatNotifies, Expression`1<Func`2<T, object>> property, PropertyChangedHandler`1<T> handler);
    private static void Subscribe(T objectThatNotifies, PropertyInfo info, PropertyChangedHandler`1<T> handler);
}
public class Xpand.Utils.Helpers.PasswordAdvisor : object {
    public static PasswordScore CheckStrength(string password);
}
public enum Xpand.Utils.Helpers.PasswordScore : Enum {
    public int value__;
    public static PasswordScore Blank;
    public static PasswordScore VeryWeak;
    public static PasswordScore Weak;
    public static PasswordScore Medium;
    public static PasswordScore Strong;
    public static PasswordScore VeryStrong;
}
public static class Xpand.Utils.Helpers.PropertyHelper`1 : object {
    public static PropertyInfo GetProperty(Expression`1<Func`2<T, TValue>> selector);
}
[ExtensionAttribute]
public static class Xpand.Utils.Helpers.ReflectionExtensions : object {
    public static string GetTempPath();
    [ExtensionAttribute]
public static bool IsDynamic(Assembly assembly);
    [ExtensionAttribute]
public static object Invoke(Type type, object target, string methodName);
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(TTarget target, Expression`1<Action`1<TTarget>> method);
    public static MethodInfo GetMethodInfo(Expression method);
    [ExtensionAttribute]
public static string GetPath(Expression`1<Func`2<T, object>> expr);
    [ExtensionAttribute]
public static MemberInfo GetMemberInfo(LambdaExpression lambda);
    public static string GetPropertyName(Expression`1<Func`2<TTarget, object>> property);
    public static string GetPropertyName(Expression`1<Func`2<TTarget, TObject>> property);
    [ExtensionAttribute]
public static string GetPropertyName(TTarget target, Expression`1<Func`2<TTarget, object>> property);
    [ExtensionAttribute]
public static void SetPropertyInfoBackingFieldValue(TTarget target, Expression`1<Func`2<TTarget, object>> property, object obj, object value);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyInfo(TTarget target, Expression`1<Func`2<TTarget, object>> property);
    [ExtensionAttribute]
public static FieldInfo GetFieldInfo(TTarget target, Expression`1<Func`2<TTarget, object>> field);
    [ExtensionAttribute]
public static MemberInfo GetMemberInfo(TTarget target, Expression member);
    [ExtensionAttribute]
public static void SetProperty(INotifyPropertyChanged source, Expression`1<Func`1<T>> propExpr, T& propertyValueHolder, T value, Action doIfChanged);
    [ExtensionAttribute]
public static void SetProperty(INotifyPropertyChanged source, Expression`1<Func`1<T>> propExpr, T& propertyValueHolder, T value);
    [ExtensionAttribute]
public static PropertyInfo[] GetPublicProperties(Type type);
    [ExtensionAttribute]
public static object CreateGeneric(Type generic, Type innerType, Object[] args);
}
public static class Xpand.Utils.Helpers.Retry : object {
    public static void Do(Action action, TimeSpan retryInterval, int retryCount);
    public static T Do(Func`1<T> action, TimeSpan retryInterval, int retryCount);
}
public enum Xpand.Utils.Helpers.Shortcut : Enum {
    public int value__;
    public static Shortcut None;
    public static Shortcut Ins;
    public static Shortcut Del;
    public static Shortcut F1;
    public static Shortcut F2;
    public static Shortcut F3;
    public static Shortcut F4;
    public static Shortcut F5;
    public static Shortcut F6;
    public static Shortcut F7;
    public static Shortcut F8;
    public static Shortcut F9;
    public static Shortcut F10;
    public static Shortcut F11;
    public static Shortcut F12;
    public static Shortcut ShiftIns;
    public static Shortcut ShiftDel;
    public static Shortcut ShiftF1;
    public static Shortcut ShiftF2;
    public static Shortcut ShiftF3;
    public static Shortcut ShiftF4;
    public static Shortcut ShiftF5;
    public static Shortcut ShiftF6;
    public static Shortcut ShiftF7;
    public static Shortcut ShiftF8;
    public static Shortcut ShiftF9;
    public static Shortcut ShiftF10;
    public static Shortcut ShiftF11;
    public static Shortcut ShiftF12;
    public static Shortcut CtrlIns;
    public static Shortcut CtrlDel;
    public static Shortcut Ctrl0;
    public static Shortcut Ctrl1;
    public static Shortcut Ctrl2;
    public static Shortcut Ctrl3;
    public static Shortcut Ctrl4;
    public static Shortcut Ctrl5;
    public static Shortcut Ctrl6;
    public static Shortcut Ctrl7;
    public static Shortcut Ctrl8;
    public static Shortcut Ctrl9;
    public static Shortcut CtrlA;
    public static Shortcut CtrlB;
    public static Shortcut CtrlC;
    public static Shortcut CtrlD;
    public static Shortcut CtrlE;
    public static Shortcut CtrlF;
    public static Shortcut CtrlG;
    public static Shortcut CtrlH;
    public static Shortcut CtrlI;
    public static Shortcut CtrlJ;
    public static Shortcut CtrlK;
    public static Shortcut CtrlL;
    public static Shortcut CtrlM;
    public static Shortcut CtrlN;
    public static Shortcut CtrlO;
    public static Shortcut CtrlP;
    public static Shortcut CtrlQ;
    public static Shortcut CtrlR;
    public static Shortcut CtrlS;
    public static Shortcut CtrlT;
    public static Shortcut CtrlU;
    public static Shortcut CtrlV;
    public static Shortcut CtrlW;
    public static Shortcut CtrlX;
    public static Shortcut CtrlY;
    public static Shortcut CtrlZ;
    public static Shortcut CtrlF1;
    public static Shortcut CtrlF2;
    public static Shortcut CtrlF3;
    public static Shortcut CtrlF4;
    public static Shortcut CtrlF5;
    public static Shortcut CtrlF6;
    public static Shortcut CtrlF7;
    public static Shortcut CtrlF8;
    public static Shortcut CtrlF9;
    public static Shortcut CtrlF10;
    public static Shortcut CtrlF11;
    public static Shortcut CtrlF12;
    public static Shortcut CtrlShift0;
    public static Shortcut CtrlShift1;
    public static Shortcut CtrlShift2;
    public static Shortcut CtrlShift3;
    public static Shortcut CtrlShift4;
    public static Shortcut CtrlShift5;
    public static Shortcut CtrlShift6;
    public static Shortcut CtrlShift7;
    public static Shortcut CtrlShift8;
    public static Shortcut CtrlShift9;
    public static Shortcut CtrlShiftA;
    public static Shortcut CtrlShiftB;
    public static Shortcut CtrlShiftC;
    public static Shortcut CtrlShiftD;
    public static Shortcut CtrlShiftE;
    public static Shortcut CtrlShiftF;
    public static Shortcut CtrlShiftG;
    public static Shortcut CtrlShiftH;
    public static Shortcut CtrlShiftI;
    public static Shortcut CtrlShiftJ;
    public static Shortcut CtrlShiftK;
    public static Shortcut CtrlShiftL;
    public static Shortcut CtrlShiftM;
    public static Shortcut CtrlShiftN;
    public static Shortcut CtrlShiftO;
    public static Shortcut CtrlShiftP;
    public static Shortcut CtrlShiftQ;
    public static Shortcut CtrlShiftR;
    public static Shortcut CtrlShiftS;
    public static Shortcut CtrlShiftT;
    public static Shortcut CtrlShiftU;
    public static Shortcut CtrlShiftV;
    public static Shortcut CtrlShiftW;
    public static Shortcut CtrlShiftX;
    public static Shortcut CtrlShiftY;
    public static Shortcut CtrlShiftZ;
    public static Shortcut CtrlShiftF1;
    public static Shortcut CtrlShiftF2;
    public static Shortcut CtrlShiftF3;
    public static Shortcut CtrlShiftF4;
    public static Shortcut CtrlShiftF5;
    public static Shortcut CtrlShiftF6;
    public static Shortcut CtrlShiftF7;
    public static Shortcut CtrlShiftF8;
    public static Shortcut CtrlShiftF9;
    public static Shortcut CtrlShiftF10;
    public static Shortcut CtrlShiftF11;
    public static Shortcut CtrlShiftF12;
    public static Shortcut AltBksp;
    public static Shortcut AltLeftArrow;
    public static Shortcut AltUpArrow;
    public static Shortcut AltRightArrow;
    public static Shortcut AltDownArrow;
    public static Shortcut Alt0;
    public static Shortcut Alt1;
    public static Shortcut Alt2;
    public static Shortcut Alt3;
    public static Shortcut Alt4;
    public static Shortcut Alt5;
    public static Shortcut Alt6;
    public static Shortcut Alt7;
    public static Shortcut Alt8;
    public static Shortcut Alt9;
    public static Shortcut AltF1;
    public static Shortcut AltF2;
    public static Shortcut AltF3;
    public static Shortcut AltF4;
    public static Shortcut AltF5;
    public static Shortcut AltF6;
    public static Shortcut AltF7;
    public static Shortcut AltF8;
    public static Shortcut AltF9;
    public static Shortcut AltF10;
    public static Shortcut AltF11;
    public static Shortcut AltF12;
}
[ExtensionAttribute]
public static class Xpand.Utils.Helpers.StringExtensions : object {
    [ExtensionAttribute]
public static string GetAttributeValue(XElement element, XName name);
}
[ExtensionAttribute]
public static class Xpand.Utils.Helpers.SystemExtensions : object {
    [ExtensionAttribute]
public static bool IsDefault(T value);
    public static double Convert(long amount, SizeDefinition from, SizeDefinition to);
    [ExtensionAttribute]
public static double Convert(int amount, SizeDefinition from, SizeDefinition to);
    [ExtensionAttribute]
public static double Convert(double amount, SizeDefinition from, SizeDefinition to);
    private static double ConvertCore(double amount, SizeDefinition from, SizeDefinition to);
    [ExtensionAttribute]
public static string AggregateErrors(CompilerResults compilerResults);
}
public static class Xpand.Utils.Helpers.ThreadSafeRandom : object {
    [ThreadStaticAttribute]
private static Random _local;
    public static Random ThisThreadsRandom { get; }
    public static Random get_ThisThreadsRandom();
}
[EditorBrowsableAttribute("1")]
public interface Xpand.Utils.IHideObjectMembers {
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object obj);
}
[ObsoleteAttribute("use ReverseLineReader", "True")]
public class Xpand.Utils.IO.InverseReader : object {
    private FileStream fileStream;
    public bool SOF { get; }
    public InverseReader(string path);
    public InverseReader(FileStream fs);
    public bool get_SOF();
    public string Readline();
    public void Close();
}
public class Xpand.Utils.IO.ReverseLineReader : object {
    private static int DefaultBufferSize;
    private Func`1<Stream> streamSource;
    private Encoding encoding;
    private int bufferSize;
    private Func`3<long, byte, bool> characterStartDetector;
    public ReverseLineReader(Func`1<Stream> streamSource);
    public ReverseLineReader(string filename);
    public ReverseLineReader(string filename, Encoding encoding);
    public ReverseLineReader(Func`1<Stream> streamSource, Encoding encoding);
    internal ReverseLineReader(Func`1<Stream> streamSource, Encoding encoding, int bufferSize);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    [IteratorStateMachineAttribute("Xpand.Utils.IO.ReverseLineReader/<GetEnumeratorImpl>d__11")]
private IEnumerator`1<string> GetEnumeratorImpl(Stream stream);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class Xpand.Utils.IO.StreamUtil : object {
    public static void ReadExactly(Stream input, Byte[] buffer, int bytesToRead);
}
public abstract class Xpand.Utils.Linq.Dynamic.DynamicClass : object {
    public virtual string ToString();
}
public class Xpand.Utils.Linq.Dynamic.DynamicProperty : object {
    private string name;
    private Type type;
    public string Name { get; }
    public Type Type { get; }
    public DynamicProperty(string name, Type type);
    public string get_Name();
    public Type get_Type();
}
public class Xpand.Utils.Linq.Dynamic.ParseException : Exception {
    private int position;
    public int Position { get; }
    public ParseException(string message, int position);
    public int get_Position();
    public virtual string ToString();
}
internal static class Xpand.Utils.Linq.Dynamic.Res : object {
    public static string DuplicateIdentifier;
    public static string ExpressionTypeMismatch;
    public static string ExpressionExpected;
    public static string InvalidCharacterLiteral;
    public static string InvalidIntegerLiteral;
    public static string InvalidRealLiteral;
    public static string UnknownIdentifier;
    public static string NoItInScope;
    public static string IifRequiresThreeArgs;
    public static string FirstExprMustBeBool;
    public static string BothTypesConvertToOther;
    public static string NeitherTypeConvertsToOther;
    public static string MissingAsClause;
    public static string ArgsIncompatibleWithLambda;
    public static string TypeHasNoNullableForm;
    public static string NoMatchingConstructor;
    public static string AmbiguousConstructorInvocation;
    public static string CannotConvertValue;
    public static string NoApplicableMethod;
    public static string MethodsAreInaccessible;
    public static string MethodIsVoid;
    public static string AmbiguousMethodInvocation;
    public static string UnknownPropertyOrField;
    public static string NoApplicableAggregate;
    public static string CannotIndexMultiDimArray;
    public static string InvalidIndex;
    public static string NoApplicableIndexer;
    public static string AmbiguousIndexerInvocation;
    public static string IncompatibleOperand;
    public static string IncompatibleOperands;
    public static string UnterminatedStringLiteral;
    public static string InvalidCharacter;
    public static string DigitExpected;
    public static string SyntaxError;
    public static string TokenExpected;
    public static string ParseExceptionFormat;
    public static string ColonExpected;
    public static string OpenParenExpected;
    public static string CloseParenOrOperatorExpected;
    public static string CloseParenOrCommaExpected;
    public static string DotOrOpenParenExpected;
    public static string OpenBracketExpected;
    public static string CloseBracketOrCommaExpected;
    public static string IdentifierExpected;
}
internal class Xpand.Utils.Linq.Dynamic.Signature : object {
    public DynamicProperty[] properties;
    public int hashCode;
    public Signature(IEnumerable`1<DynamicProperty> properties);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Signature other);
}
public class Xpand.Utils.Linq.ExpressionConverter : object {
    public static Expression Tranform(Expression`1<Func`2<TFrom, bool>> expression, Type targeType);
}
[ExtensionAttribute]
public static class Xpand.Utils.Linq.Extensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> Split(IEnumerable`1<T> list, int parts);
    [IteratorStateMachineAttribute("Xpand.Utils.Linq.Extensions/<SkipLastN>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SkipLastN(IEnumerable`1<T> source, int n);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectNonNull(IEnumerable`1<T> sequence, Func`2<T, TResult> projection);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
public static TResult NullSafeEval(TSource source, Expression`1<Func`2<TSource, TResult>> expression, TResult defaultValue);
    private static Expression NullSafeEvalWrapper(Expression expr, Expression defaultValue);
    private static bool IsNullSafe(Expression expr, Expression& nullableObject);
    [ExtensionAttribute]
public static void ThrowIfNull(T container);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<Nullable`1<T>> sequence);
}
[ExtensionAttribute]
public static class Xpand.Utils.Linq.PredicateBuilder : object {
    public static Expression`1<Func`2<T, bool>> True();
    public static Expression`1<Func`2<T, bool>> False();
    [ExtensionAttribute]
public static Expression`1<Func`2<T, bool>> Or(Expression`1<Func`2<T, bool>> expr1, Expression`1<Func`2<T, bool>> expr2);
    [ExtensionAttribute]
public static Expression`1<Func`2<T, bool>> And(Expression`1<Func`2<T, bool>> expr1, Expression`1<Func`2<T, bool>> expr2);
}
[ExtensionAttribute]
public static class Xpand.Utils.Linq.RecursiveLinq : object {
    [IteratorStateMachineAttribute("Xpand.Utils.Linq.RecursiveLinq/<GetItems>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> GetItems(IEnumerable collection, Func`2<T, IEnumerable> selector);
}
public class Xpand.Utils.ObjectMerger : object {
    public static void Merge(S& source, T& target);
    public static void Merge(S source, T& target, MergeConcurrency winner);
}
public interface Xpand.Utils.Threading.IProgress`1 {
    public abstract virtual void Report(T value);
}
public class Xpand.Utils.Threading.Progress`1 : object {
    private SynchronizationContext _context;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Action`1<T> ProgressReported;
    public Progress`1(Action`1<T> action);
    [CompilerGeneratedAttribute]
public void add_ProgressReported(Action`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressReported(Action`1<T> value);
    private sealed virtual override void Xpand.Utils.Threading.IProgress<T>.Report(T data);
}
[DefaultMemberAttribute("Item")]
public class Xpand.Utils.Threading.Synchronizer`1 : object {
    private Dictionary`2<T, object> _locks;
    private object _myLock;
    public object Item { get; }
    public object get_Item(T index);
}
[ExtensionAttribute]
public static class Xpand.Utils.Threading.TaskExtensions : object {
    [ExtensionAttribute]
public static Task StartNewPeriodic(TaskFactory taskFactory, Action action, TaskScheduler taskScheduler, int interval, int delay, int duration, int maxIterations, bool synchronous, CancellationToken cancelToken, TaskCreationOptions periodicTaskCreationOptions);
    private static void MainPeriodicTaskAction(int intervalInMilliseconds, int delayInMilliseconds, int duration, int maxIterations, CancellationToken cancelToken, Stopwatch stopWatch, bool synchronous, Action wrapperAction, TaskCreationOptions periodicTaskCreationOptions, TaskScheduler taskScheduler);
    private static void CheckIfCancelled(CancellationToken cancellationToken);
    internal static void MarshalTaskResults(Task source, TaskCompletionSource`1<TResult> proxy);
    [ExtensionAttribute]
public static CancellationTokenSource Execute(int timeout);
    [ExtensionAttribute]
public static bool WaitToCompleteOrTimeOut(Task task);
    [ExtensionAttribute]
public static Task TimeoutAfter(Task task, int millisecondsTimeout);
    [ExtensionAttribute]
public static Task`1<TResult> TimeoutAfter(Task`1<TResult> task, int millisecondsTimeout);
}
public class Xpand.Utils.XpandReflectionHelper : object {
    private static Random random;
    private static XpandReflectionHelper();
    public static List`1<T> Shuffle(IList`1<T> list);
    public static PropertyInfo[] GetProperties(Type className, Type interfaceType);
    public static MemberInfo FindMethod(Type containerType, Type decorationAttributeType);
    public static object CreateGenerik(string name, Type[] types);
    public static PropertyInfo[] GetPropertiesAssignAbleFrom(Type className, Type assignAbleFrom);
    public static IEnumerable`1<PropertyInfo> GetExplicitProperties(Type attributeType);
    public static Object[] GetAttributes(PropertyInfo propertyInfo, Type attributeType);
    public static Attribute GetAttribute(PropertyInfo propertyInfo, Type attributeType, bool inherit);
    public static Attribute GetAttribute(Type decoratedType, Type attributeType, bool inherit);
    public static Attribute GetAttribute(Type decoratedType, Type attributeType);
    public static Attribute GetAttribute(PropertyInfo propertyInfo, Type attributeType);
    private static Attribute getAttribute(IEnumerable`1<object> attributes, Type attributeType);
    public static Type FindDecoratedInterface(Type objectType, Type attributeType);
    public static Type[] GetTypes(Type assignAbleFrom, Assembly assembly, Type decoratedAttributeType);
    public static Type[] GetTypes(Type assignAbleFrom, Assembly assembly);
    public static PropertyInfo[] GetDecoratedProperties(Type objectType, Type attributeType);
    public static PropertyInfo[] GetDecoratedProperties(Type objectType, Type attributeType, BindingFlags bindingFlags);
    public static bool FindInterface(Type interfaceType, Type typeToSearch);
    public static void SetPropertyValue(PropertyInfo propertyInfo, object obj, object value);
    public static PropertyInfo[] GetAssingAbleProperties(Type assignableFrom, Type containerType);
    public static FieldInfo[] GetFields(Type assignableFrom, Type containerType, BindingFlags bindingFlags);
    public static Object[] GetFieldsValues(Type assignableFrom, object containerObject, bool excludeNullValues);
    public static FieldInfo[] GetFields(Type assignableFrom, Type containerType);
    public static void FilterProperties(PropertyInfo[]& properties, bool readWrite);
    public static void FilterTypes(Type[]& types, Type[] excludedTypesAssignAbleFrom);
    public static void FilterTypes(Type[]& types, bool excludeAbstracts);
    public static MethodInfo[] GetMethods(Type type, Type decoratedAttribute, BindingFlags bindingFlags);
    public static MethodInfo[] GetMethods(Type type, Type decoratedAttribute);
    public static Object[] GetPropertiesValues(Type decoratedAttributeType, object container, bool excludeNullValues);
    public static FieldInfo GetFieldByValue(object value, object containerControl);
    public static PropertyDescriptor GetPropertyDescriptorByValue(object value, object containedControl);
    public static MethodInfo[] GetDecoratedMethods(Type classType, Type attributeType);
    public static bool HasAttribute(PropertyInfo propertyInfo, Type attributeType);
}
public class XpandAssemblyInfo : object {
    public static string Version;
    public static string FileVersion;
    public static string Token;
    public static string TabAspNetModules;
    public static string TabWinModules;
    public static string TabMobileModules;
    public static string TabWinWebModules;
    public static string TabSecurity;
}
