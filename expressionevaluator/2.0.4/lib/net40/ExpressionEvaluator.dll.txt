public class ExpressionEvaluator.CompiledExpression : CompiledExpression`1<object> {
    public CompiledExpression(string expression);
}
public class ExpressionEvaluator.CompiledExpression`1 : ExpressionCompiler {
    private Func`1<TResult> _compiledMethod;
    private Action _compiledAction;
    unknown object Global {public set; }
    public CompiledExpression`1(string expression);
    public Func`1<TResult> Compile();
    public Expression`1<T> GenerateLambda(bool withScope, bool asCall);
    private T Compile(bool withScope, bool asCall);
    public Action CompileCall();
    public Action`1<object> ScopeCompileCall();
    public Action`1<TParam> ScopeCompileCall();
    public Func`2<object, TResult> ScopeCompile();
    public Func`2<TScope, TResult> ScopeCompile();
    private T CompileWithScope(bool asCall);
    protected virtual void ClearCompiledMethod();
    public TResult Eval();
    public void Call();
    public void set_Global(object value);
}
public enum ExpressionEvaluator.CompiledExpressionType : Enum {
    public int value__;
    public static CompiledExpressionType Expression;
    public static CompiledExpressionType Statement;
    public static CompiledExpressionType StatementList;
}
public class ExpressionEvaluator.DelegateType : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<object> <Value>k__BackingField;
    public Type Type { get; public set; }
    public Func`1<object> Value { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public Func`1<object> get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Func`1<object> value);
}
public class ExpressionEvaluator.DelegateType`1 : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<T> <Value>k__BackingField;
    public Type Type { get; public set; }
    public Func`1<T> Value { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public Func`1<T> get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Func`1<T> value);
}
public abstract class ExpressionEvaluator.ExpressionCompiler : object {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private CompiledExpressionType <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <LambdaExpression>k__BackingField;
    protected AntlrParser Parser;
    [CompilerGeneratedAttribute]
private TypeRegistry <TypeRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Type> <DynamicTypeLookup>k__BackingField;
    protected string Pstr;
    public Expression Expression { get; public set; }
    public CompiledExpressionType ExpressionType { get; public set; }
    public LambdaExpression LambdaExpression { get; public set; }
    public TypeRegistry TypeRegistry { get; public set; }
    public Dictionary`2<string, Type> DynamicTypeLookup { get; public set; }
    public string StringToParse { get; public set; }
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public CompiledExpressionType get_ExpressionType();
    [CompilerGeneratedAttribute]
public void set_ExpressionType(CompiledExpressionType value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_LambdaExpression();
    [CompilerGeneratedAttribute]
public void set_LambdaExpression(LambdaExpression value);
    [CompilerGeneratedAttribute]
public TypeRegistry get_TypeRegistry();
    [CompilerGeneratedAttribute]
public void set_TypeRegistry(TypeRegistry value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Type> get_DynamicTypeLookup();
    [CompilerGeneratedAttribute]
public void set_DynamicTypeLookup(Dictionary`2<string, Type> value);
    public string get_StringToParse();
    public void set_StringToParse(string value);
    protected Expression BuildTree(Expression scopeParam, bool isCall);
    protected abstract virtual void ClearCompiledMethod();
    public T Compile(String[] parameters);
    public void ScopeParse();
    protected Expression WrapExpression(Expression source, bool castToObject);
    protected Expression WrapExpression(Expression source);
    protected Expression WrapExpressionCall(Expression source);
    protected Expression WrapToVoid(Expression source);
    protected Expression WrapToNull(Expression source);
    public virtual string ToString();
}
public class ExpressionEvaluator.ExpressionContainerAttribute : Attribute {
}
public class ExpressionEvaluator.ExpressionContainerException : Exception {
    [CompilerGeneratedAttribute]
private Expression <Container>k__BackingField;
    public Expression Container { get; private set; }
    public ExpressionContainerException(Expression container);
    [CompilerGeneratedAttribute]
public Expression get_Container();
    [CompilerGeneratedAttribute]
private void set_Container(Expression value);
}
public interface ExpressionEvaluator.IDynamicObjectProvider {
    public abstract virtual void setVar(string propertyname, object value);
    public abstract virtual object getVar(string propertyname);
}
public class ExpressionEvaluator.ParseException : Exception {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    public string Expression { get; private set; }
    public ParseException(string expression, string message);
    public ParseException(string expression, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(string value);
}
public class ExpressionEvaluator.Parser.AntlrParser : object {
    [CompilerGeneratedAttribute]
private string <ExpressionString>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeRegistry <TypeRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Type> <DynamicTypeLookup>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Global>k__BackingField;
    [CompilerGeneratedAttribute]
private CompiledExpressionType <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ParameterExpression> <ExternalParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public string ExpressionString { get; public set; }
    public Expression Expression { get; public set; }
    public TypeRegistry TypeRegistry { get; public set; }
    public Dictionary`2<string, Type> DynamicTypeLookup { get; public set; }
    public object Global { get; public set; }
    public CompiledExpressionType ExpressionType { get; public set; }
    public List`1<ParameterExpression> ExternalParameters { get; public set; }
    public Type ReturnType { get; public set; }
    public AntlrParser(string expression);
    [CompilerGeneratedAttribute]
public string get_ExpressionString();
    [CompilerGeneratedAttribute]
public void set_ExpressionString(string value);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public TypeRegistry get_TypeRegistry();
    [CompilerGeneratedAttribute]
public void set_TypeRegistry(TypeRegistry value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Type> get_DynamicTypeLookup();
    [CompilerGeneratedAttribute]
public void set_DynamicTypeLookup(Dictionary`2<string, Type> value);
    public Expression Parse(Expression scope, bool isCall);
    [CompilerGeneratedAttribute]
public object get_Global();
    [CompilerGeneratedAttribute]
public void set_Global(object value);
    [CompilerGeneratedAttribute]
public CompiledExpressionType get_ExpressionType();
    [CompilerGeneratedAttribute]
public void set_ExpressionType(CompiledExpressionType value);
    [CompilerGeneratedAttribute]
public List`1<ParameterExpression> get_ExternalParameters();
    [CompilerGeneratedAttribute]
public void set_ExternalParameters(List`1<ParameterExpression> value);
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
public void set_ReturnType(Type value);
}
public class ExpressionEvaluator.Parser.CompilerException : Exception {
    public CompilerException(string message);
}
internal class ExpressionEvaluator.Parser.CompilerState : object {
    [CompilerGeneratedAttribute]
private LabelTarget <ReturnTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<LabelTarget> <BreakContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<LabelTarget> <ContinueContext>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelTarget <CurrentBreak>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelTarget <CurrentContinue>k__BackingField;
    public LabelTarget ReturnTarget { get; public set; }
    public Stack`1<LabelTarget> BreakContext { get; private set; }
    public Stack`1<LabelTarget> ContinueContext { get; private set; }
    public LabelTarget CurrentBreak { get; private set; }
    public LabelTarget CurrentContinue { get; private set; }
    [CompilerGeneratedAttribute]
public LabelTarget get_ReturnTarget();
    [CompilerGeneratedAttribute]
public void set_ReturnTarget(LabelTarget value);
    [CompilerGeneratedAttribute]
public Stack`1<LabelTarget> get_BreakContext();
    [CompilerGeneratedAttribute]
private void set_BreakContext(Stack`1<LabelTarget> value);
    [CompilerGeneratedAttribute]
public Stack`1<LabelTarget> get_ContinueContext();
    [CompilerGeneratedAttribute]
private void set_ContinueContext(Stack`1<LabelTarget> value);
    [CompilerGeneratedAttribute]
public LabelTarget get_CurrentBreak();
    [CompilerGeneratedAttribute]
private void set_CurrentBreak(LabelTarget value);
    [CompilerGeneratedAttribute]
public LabelTarget get_CurrentContinue();
    [CompilerGeneratedAttribute]
private void set_CurrentContinue(LabelTarget value);
    public LabelTarget PushContinue();
    public LabelTarget PushBreak();
    public void PopBreak();
    public void PopContinue();
    public Expression Break();
    public Expression Continue();
}
internal class ExpressionEvaluator.Parser.ExpressionHelper : object {
    private static Type StringType;
    private static string HexChars;
    private static ExpressionHelper();
    private static Expression ConvertToString(Expression instance);
    public static Expression Add(Expression le, Expression re);
    public static Expression GetPropertyIndex(Expression le, IEnumerable`1<Expression> args);
    public static Expression Assign(Expression le, Expression re, Dictionary`2<string, Type> dynamicTypeLookup);
    public static Type[] InferTypes(MethodInfo methodInfo, List`1<Expression> args);
    public static void ExactInference(Type U, Type V, Dictionary`2<string, TypeVariable> lookup);
    public static void LowerBoundInference(Type U, Type V, Dictionary`2<string, TypeVariable> lookup);
    private static bool IsDynamic(Expression expr);
    public static Expression GetProperty(Expression le, string membername);
    public static Expression GetMethod(Expression le, TypeOrGeneric member, IEnumerable`1<Argument> args, bool isCall);
    public static Expression MethodInvokeExpression(Type type, Expression instance, TypeOrGeneric member, IEnumerable`1<Argument> args);
    public static Expression ParseRealLiteral(string token);
    public static Expression ParseIntLiteral(string token);
    public static Expression ParseDateLiteral(string token);
    public static Expression ParseHexLiteral(string token);
    public static Expression ParseCharLiteral(string token);
    public static string Unescape(string txt);
    public static Expression ParseStringLiteral(string token);
    public static Expression UnaryOperator(Expression le, ExpressionType expressionType);
    public static Expression BinaryOperator(Expression le, Expression re, ExpressionType expressionType);
    public static Expression GetUnaryOperator(Expression le, ExpressionType expressionType);
    public static Expression GetBinaryOperator(Expression le, Expression re, ExpressionType expressionType);
    private static Expression DynamicUnaryOperator(Expression le, ExpressionType expressionType);
    private static Expression DynamicBinaryOperator(Expression le, Expression re, ExpressionType expressionType);
    public static Expression Condition(Expression condition, Expression ifTrue, Expression ifFalse);
    public static Expression New(Type t, IEnumerable`1<Argument> arguments, ObjectOrCollectionInitializer initializer);
    public static Expression Switch(LabelTarget breakTarget, Expression switchCase, List`1<SwitchCase> switchBlock);
    public static Expression ForEach(LabelTarget exitLabel, LabelTarget continueLabel, ParameterExpression parameter, Expression iterator, Expression body);
    public static Expression For(LabelTarget exitLabel, LabelTarget continueLabel, MultiStatement initializer, Expression condition, StatementList iterator, Expression body);
    public static Expression DoWhile(LabelTarget breakTarget, LabelTarget continueLabel, Expression body, Expression boolean);
    public static Expression While(LabelTarget breakTarget, LabelTarget continueLabel, LocalVariableDeclaration setup, Expression boolean, Expression body);
}
public class ExpressionEvaluator.Parser.ExpressionParseException : Exception {
    private ITokenStream _tokenStream;
    public ExpressionParseException(string message, ITokenStream tokenStream);
}
public class ExpressionEvaluator.Parser.Expressions.AccessIdentifier : PrimaryExpressionPart {
    [CompilerGeneratedAttribute]
private TypeOrGeneric <Value>k__BackingField;
    public TypeOrGeneric Value { get; public set; }
    [CompilerGeneratedAttribute]
public TypeOrGeneric get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(TypeOrGeneric value);
}
public class ExpressionEvaluator.Parser.Expressions.ApplicableFunctionMember : object {
    [CompilerGeneratedAttribute]
private MethodInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParamArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExpanded>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParamArrayPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParamArrayElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParamArrayElementLength>k__BackingField;
    public MethodInfo Member { get; public set; }
    public bool IsParamArray { get; public set; }
    public bool IsExpanded { get; public set; }
    public int ParamArrayPosition { get; public set; }
    public Type ParamArrayElementType { get; public set; }
    public Type ParamArrayElementLength { get; public set; }
    [CompilerGeneratedAttribute]
public MethodInfo get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(MethodInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsParamArray();
    [CompilerGeneratedAttribute]
public void set_IsParamArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExpanded();
    [CompilerGeneratedAttribute]
public void set_IsExpanded(bool value);
    [CompilerGeneratedAttribute]
public int get_ParamArrayPosition();
    [CompilerGeneratedAttribute]
public void set_ParamArrayPosition(int value);
    [CompilerGeneratedAttribute]
public Type get_ParamArrayElementType();
    [CompilerGeneratedAttribute]
public void set_ParamArrayElementType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ParamArrayElementLength();
    [CompilerGeneratedAttribute]
public void set_ParamArrayElementLength(Type value);
}
public class ExpressionEvaluator.Parser.Expressions.Argument : object {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamedArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterPassingModeEnum <ParameterPassingMode>k__BackingField;
    public Expression Expression { get; public set; }
    public bool IsNamedArgument { get; public set; }
    public string Name { get; public set; }
    public int Position { get; public set; }
    public ParameterPassingModeEnum ParameterPassingMode { get; public set; }
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public bool get_IsNamedArgument();
    [CompilerGeneratedAttribute]
public void set_IsNamedArgument(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    [CompilerGeneratedAttribute]
public ParameterPassingModeEnum get_ParameterPassingMode();
    [CompilerGeneratedAttribute]
public void set_ParameterPassingMode(ParameterPassingModeEnum value);
}
public class ExpressionEvaluator.Parser.Expressions.Arguments : PrimaryExpressionPart {
    [CompilerGeneratedAttribute]
private List`1<Argument> <Values>k__BackingField;
    public List`1<Argument> Values { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Argument> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(List`1<Argument> value);
}
public class ExpressionEvaluator.Parser.Expressions.Brackets : ExpressionList {
}
public class ExpressionEvaluator.Parser.Expressions.CandidatePoints : object {
    [CompilerGeneratedAttribute]
private ApplicableFunctionMember <Candidate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Points>k__BackingField;
    public ApplicableFunctionMember Candidate { get; public set; }
    public int Points { get; public set; }
    [CompilerGeneratedAttribute]
public ApplicableFunctionMember get_Candidate();
    [CompilerGeneratedAttribute]
public void set_Candidate(ApplicableFunctionMember value);
    [CompilerGeneratedAttribute]
public int get_Points();
    [CompilerGeneratedAttribute]
public void set_Points(int value);
}
public class ExpressionEvaluator.Parser.Expressions.DeclarationStatement : MultiStatement {
}
public class ExpressionEvaluator.Parser.Expressions.ExpressionList : PrimaryExpressionPart {
    [CompilerGeneratedAttribute]
private List`1<Expression> <Values>k__BackingField;
    public List`1<Expression> Values { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Expression> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(List`1<Expression> value);
}
public class ExpressionEvaluator.Parser.Expressions.InitializerValue : object {
}
public class ExpressionEvaluator.Parser.Expressions.LocalConstDeclaration : DeclarationStatement {
}
public class ExpressionEvaluator.Parser.Expressions.LocalVariableDeclaration : DeclarationStatement {
    [CompilerGeneratedAttribute]
private List`1<ParameterExpression> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <Initializers>k__BackingField;
    public List`1<ParameterExpression> Variables { get; public set; }
    public List`1<Expression> Initializers { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ParameterExpression> get_Variables();
    [CompilerGeneratedAttribute]
public void set_Variables(List`1<ParameterExpression> value);
    [CompilerGeneratedAttribute]
public List`1<Expression> get_Initializers();
    [CompilerGeneratedAttribute]
public void set_Initializers(List`1<Expression> value);
}
public class ExpressionEvaluator.Parser.Expressions.MemberInitializer : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    public string Identifier { get; public set; }
    public Expression Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public Expression get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Expression value);
}
public class ExpressionEvaluator.Parser.Expressions.MultiStatement : Statement {
}
public class ExpressionEvaluator.Parser.Expressions.ObjectOrCollectionInitializer : object {
    [CompilerGeneratedAttribute]
private List`1<MemberInitializer> <ObjectInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <CollectionInitializer>k__BackingField;
    public List`1<MemberInitializer> ObjectInitializer { get; public set; }
    public List`1<Expression> CollectionInitializer { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<MemberInitializer> get_ObjectInitializer();
    [CompilerGeneratedAttribute]
public void set_ObjectInitializer(List`1<MemberInitializer> value);
    [CompilerGeneratedAttribute]
public List`1<Expression> get_CollectionInitializer();
    [CompilerGeneratedAttribute]
public void set_CollectionInitializer(List`1<Expression> value);
}
public enum ExpressionEvaluator.Parser.Expressions.ParameterPassingModeEnum : Enum {
    public int value__;
    public static ParameterPassingModeEnum ByVal;
    public static ParameterPassingModeEnum ByRef;
    public static ParameterPassingModeEnum Out;
}
public class ExpressionEvaluator.Parser.Expressions.PostDecrement : PrimaryExpressionPart {
}
public class ExpressionEvaluator.Parser.Expressions.PostIncrement : PrimaryExpressionPart {
}
public class ExpressionEvaluator.Parser.Expressions.PrimaryExpressionPart : object {
}
public class ExpressionEvaluator.Parser.Expressions.Statement : object {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; public set; }
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(Expression value);
}
public class ExpressionEvaluator.Parser.Expressions.StatementList : MultiStatement {
    [CompilerGeneratedAttribute]
private List`1<LocalVariableDeclaration> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Statement> <Statements>k__BackingField;
    public List`1<LocalVariableDeclaration> Variables { get; public set; }
    public List`1<Statement> Statements { get; private set; }
    public IEnumerable`1<Expression> Expressions { get; }
    public void Add(Statement statement);
    public void Add(Expression expression);
    [CompilerGeneratedAttribute]
public List`1<LocalVariableDeclaration> get_Variables();
    [CompilerGeneratedAttribute]
public void set_Variables(List`1<LocalVariableDeclaration> value);
    [CompilerGeneratedAttribute]
public List`1<Statement> get_Statements();
    [CompilerGeneratedAttribute]
private void set_Statements(List`1<Statement> value);
    public IEnumerable`1<Expression> get_Expressions();
    public BlockExpression ToBlock();
}
public class ExpressionEvaluator.Parser.Expressions.TypeOrGeneric : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <TypeArgs>k__BackingField;
    public string Identifier { get; public set; }
    public List`1<Type> TypeArgs { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_TypeArgs();
    [CompilerGeneratedAttribute]
public void set_TypeArgs(List`1<Type> value);
    public virtual string ToString();
}
internal class ExpressionEvaluator.Parser.Expressions.TypeVariable : object {
    [CompilerGeneratedAttribute]
private bool <IsFixed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <UpperBounds>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <LowerBounds>k__BackingField;
    public bool IsFixed { get; public set; }
    public string Name { get; public set; }
    public List`1<Type> Bounds { get; public set; }
    public List`1<Type> UpperBounds { get; public set; }
    public List`1<Type> LowerBounds { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsFixed();
    [CompilerGeneratedAttribute]
public void set_IsFixed(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_Bounds();
    [CompilerGeneratedAttribute]
public void set_Bounds(List`1<Type> value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_UpperBounds();
    [CompilerGeneratedAttribute]
public void set_UpperBounds(List`1<Type> value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_LowerBounds();
    [CompilerGeneratedAttribute]
public void set_LowerBounds(List`1<Type> value);
}
public class ExpressionEvaluator.Parser.Expressions.Variable : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Initializer>k__BackingField;
    public string Identifier { get; public set; }
    public Expression Initializer { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public Expression get_Initializer();
    [CompilerGeneratedAttribute]
public void set_Initializer(Expression value);
}
[GeneratedCodeAttribute("ANTLR", "3.5.0.2")]
[CLSCompliantAttribute("False")]
public class ExpressionEvaluator.Parser.ExprEvalLexer : Lexer {
    public static int EOF;
    public static int ANYCHAR;
    public static int COMMENT;
    public static int Character_literal;
    public static int DECIMAL_DIGIT;
    public static int DEFINE;
    public static int DEFINE_TOKEN;
    public static int DOC_LINE_COMMENT;
    public static int DOT;
    public static int Decimal_digits;
    public static int Decimal_integer_literal;
    public static int ELIF;
    public static int ELSE_TOKEN;
    public static int ENDIF;
    public static int ENDIF_TOKEN;
    public static int ENUM;
    public static int EscapeSequence;
    public static int Exponent_part;
    public static int FALSE;
    public static int GT;
    public static int GooBall;
    public static int GooBallIdentifier;
    public static int HEX_DIGIT;
    public static int HEX_DIGITS;
    public static int Hex_number;
    public static int IDENTIFIER;
    public static int IF;
    public static int IF_TOKEN;
    public static int INTEGER_TYPE_SUFFIX;
    public static int IdentifierPart;
    public static int IdentifierStart;
    public static int LINE_COMMENT;
    public static int LPAREN;
    public static int MINUS;
    public static int NULL;
    public static int NUMBER;
    public static int PP_AND_EXPRESSION;
    public static int PP_CONDITIONAL;
    public static int PP_EQUALITY_EXPRESSION;
    public static int PP_EXPRESSION;
    public static int PP_OR_EXPRESSION;
    public static int PP_PRIMARY_EXPRESSION;
    public static int PP_UNARY_EXPRESSION;
    public static int PREPROCESSOR_DIRECTIVE;
    public static int PTR;
    public static int Pragma;
    public static int RPAREN;
    public static int Real_literal;
    public static int Real_type_suffix;
    public static int SEMI;
    public static int STRINGLITERAL;
    public static int Sign;
    public static int StringEscapeSequence;
    public static int TRUE;
    public static int TS;
    public static int UNDEF;
    public static int UNDEF_TOKEN;
    public static int USING;
    public static int Verbatim_string_literal;
    public static int Verbatim_string_literal_character;
    public static int WS;
    public static int T__64;
    public static int T__65;
    public static int T__66;
    public static int T__67;
    public static int T__68;
    public static int T__69;
    public static int T__70;
    public static int T__71;
    public static int T__72;
    public static int T__73;
    public static int T__74;
    public static int T__75;
    public static int T__76;
    public static int T__77;
    public static int T__78;
    public static int T__79;
    public static int T__80;
    public static int T__81;
    public static int T__82;
    public static int T__83;
    public static int T__84;
    public static int T__85;
    public static int T__86;
    public static int T__87;
    public static int T__88;
    public static int T__89;
    public static int T__90;
    public static int T__91;
    public static int T__92;
    public static int T__93;
    public static int T__94;
    public static int T__95;
    public static int T__96;
    public static int T__97;
    public static int T__98;
    public static int T__99;
    public static int T__100;
    public static int T__101;
    public static int T__102;
    public static int T__103;
    public static int T__104;
    public static int T__105;
    public static int T__106;
    public static int T__107;
    public static int T__108;
    public static int T__109;
    public static int T__110;
    public static int T__111;
    public static int T__112;
    public static int T__113;
    public static int T__114;
    public static int T__115;
    public static int T__116;
    public static int T__117;
    public static int T__118;
    public static int T__119;
    public static int T__120;
    public static int T__121;
    public static int T__122;
    public static int T__123;
    public static int T__124;
    public static int T__125;
    public static int T__126;
    public static int T__127;
    public static int T__128;
    public static int T__129;
    public static int T__130;
    public static int T__131;
    public static int T__132;
    public static int T__133;
    public static int T__134;
    public static int T__135;
    public static int T__136;
    public static int T__137;
    public static int T__138;
    public static int T__139;
    public static int T__140;
    public static int T__141;
    public static int T__142;
    public static int T__143;
    public static int T__144;
    public static int T__145;
    public static int T__146;
    public static int T__147;
    public static int T__148;
    public static int T__149;
    public static int T__150;
    public static int T__151;
    public static int T__152;
    public static int T__153;
    public static int T__154;
    public static int T__155;
    public static int T__156;
    public static int T__157;
    public static int T__158;
    public static int T__159;
    public static int T__160;
    public static int T__161;
    public static int T__162;
    public static int T__163;
    public static int T__164;
    public static int T__165;
    public static int T__166;
    public static int T__167;
    public static int T__168;
    public static int T__169;
    public static int T__170;
    public static int T__171;
    public static int T__172;
    public static int T__173;
    public static int T__174;
    public static int T__175;
    public static int T__176;
    public static int T__177;
    public static int T__178;
    public static int T__179;
    public static int T__180;
    public static int T__181;
    public static int T__182;
    public static int T__183;
    public static int T__184;
    public static int T__185;
    public static int T__186;
    public static int T__187;
    public static int T__188;
    public static int T__189;
    public static int T__190;
    public static int T__191;
    public static int T__192;
    public static int T__193;
    public static int T__194;
    public static int T__195;
    public static int T__196;
    public static int T__197;
    public static int T__198;
    public static int T__199;
    public static int T__200;
    public static int T__201;
    public static int T__202;
    public static int T__203;
    public static int T__204;
    public static int T__205;
    public static int T__206;
    protected Dictionary`2<string, string> MacroDefines;
    protected Stack`1<bool> Processing;
    protected Stack`1<bool> Returns;
    private DFA25 dfa25;
    private DFA32 dfa32;
    private DFA46 dfa46;
    private DFA71 dfa71;
    public string GrammarFileName { get; }
    public ExprEvalLexer(ICharStream input);
    public ExprEvalLexer(ICharStream input, RecognizerSharedState state);
    public virtual void ReportError(RecognitionException e);
    public virtual string get_GrammarFileName();
    [GrammarRuleAttribute("T__64")]
private void mT__64();
    [GrammarRuleAttribute("T__65")]
private void mT__65();
    [GrammarRuleAttribute("T__66")]
private void mT__66();
    [GrammarRuleAttribute("T__67")]
private void mT__67();
    [GrammarRuleAttribute("T__68")]
private void mT__68();
    [GrammarRuleAttribute("T__69")]
private void mT__69();
    [GrammarRuleAttribute("T__70")]
private void mT__70();
    [GrammarRuleAttribute("T__71")]
private void mT__71();
    [GrammarRuleAttribute("T__72")]
private void mT__72();
    [GrammarRuleAttribute("T__73")]
private void mT__73();
    [GrammarRuleAttribute("T__74")]
private void mT__74();
    [GrammarRuleAttribute("T__75")]
private void mT__75();
    [GrammarRuleAttribute("T__76")]
private void mT__76();
    [GrammarRuleAttribute("T__77")]
private void mT__77();
    [GrammarRuleAttribute("T__78")]
private void mT__78();
    [GrammarRuleAttribute("T__79")]
private void mT__79();
    [GrammarRuleAttribute("T__80")]
private void mT__80();
    [GrammarRuleAttribute("T__81")]
private void mT__81();
    [GrammarRuleAttribute("T__82")]
private void mT__82();
    [GrammarRuleAttribute("T__83")]
private void mT__83();
    [GrammarRuleAttribute("T__84")]
private void mT__84();
    [GrammarRuleAttribute("T__85")]
private void mT__85();
    [GrammarRuleAttribute("T__86")]
private void mT__86();
    [GrammarRuleAttribute("T__87")]
private void mT__87();
    [GrammarRuleAttribute("T__88")]
private void mT__88();
    [GrammarRuleAttribute("T__89")]
private void mT__89();
    [GrammarRuleAttribute("T__90")]
private void mT__90();
    [GrammarRuleAttribute("T__91")]
private void mT__91();
    [GrammarRuleAttribute("T__92")]
private void mT__92();
    [GrammarRuleAttribute("T__93")]
private void mT__93();
    [GrammarRuleAttribute("T__94")]
private void mT__94();
    [GrammarRuleAttribute("T__95")]
private void mT__95();
    [GrammarRuleAttribute("T__96")]
private void mT__96();
    [GrammarRuleAttribute("T__97")]
private void mT__97();
    [GrammarRuleAttribute("T__98")]
private void mT__98();
    [GrammarRuleAttribute("T__99")]
private void mT__99();
    [GrammarRuleAttribute("T__100")]
private void mT__100();
    [GrammarRuleAttribute("T__101")]
private void mT__101();
    [GrammarRuleAttribute("T__102")]
private void mT__102();
    [GrammarRuleAttribute("T__103")]
private void mT__103();
    [GrammarRuleAttribute("T__104")]
private void mT__104();
    [GrammarRuleAttribute("T__105")]
private void mT__105();
    [GrammarRuleAttribute("T__106")]
private void mT__106();
    [GrammarRuleAttribute("T__107")]
private void mT__107();
    [GrammarRuleAttribute("T__108")]
private void mT__108();
    [GrammarRuleAttribute("T__109")]
private void mT__109();
    [GrammarRuleAttribute("T__110")]
private void mT__110();
    [GrammarRuleAttribute("T__111")]
private void mT__111();
    [GrammarRuleAttribute("T__112")]
private void mT__112();
    [GrammarRuleAttribute("T__113")]
private void mT__113();
    [GrammarRuleAttribute("T__114")]
private void mT__114();
    [GrammarRuleAttribute("T__115")]
private void mT__115();
    [GrammarRuleAttribute("T__116")]
private void mT__116();
    [GrammarRuleAttribute("T__117")]
private void mT__117();
    [GrammarRuleAttribute("T__118")]
private void mT__118();
    [GrammarRuleAttribute("T__119")]
private void mT__119();
    [GrammarRuleAttribute("T__120")]
private void mT__120();
    [GrammarRuleAttribute("T__121")]
private void mT__121();
    [GrammarRuleAttribute("T__122")]
private void mT__122();
    [GrammarRuleAttribute("T__123")]
private void mT__123();
    [GrammarRuleAttribute("T__124")]
private void mT__124();
    [GrammarRuleAttribute("T__125")]
private void mT__125();
    [GrammarRuleAttribute("T__126")]
private void mT__126();
    [GrammarRuleAttribute("T__127")]
private void mT__127();
    [GrammarRuleAttribute("T__128")]
private void mT__128();
    [GrammarRuleAttribute("T__129")]
private void mT__129();
    [GrammarRuleAttribute("T__130")]
private void mT__130();
    [GrammarRuleAttribute("T__131")]
private void mT__131();
    [GrammarRuleAttribute("T__132")]
private void mT__132();
    [GrammarRuleAttribute("T__133")]
private void mT__133();
    [GrammarRuleAttribute("T__134")]
private void mT__134();
    [GrammarRuleAttribute("T__135")]
private void mT__135();
    [GrammarRuleAttribute("T__136")]
private void mT__136();
    [GrammarRuleAttribute("T__137")]
private void mT__137();
    [GrammarRuleAttribute("T__138")]
private void mT__138();
    [GrammarRuleAttribute("T__139")]
private void mT__139();
    [GrammarRuleAttribute("T__140")]
private void mT__140();
    [GrammarRuleAttribute("T__141")]
private void mT__141();
    [GrammarRuleAttribute("T__142")]
private void mT__142();
    [GrammarRuleAttribute("T__143")]
private void mT__143();
    [GrammarRuleAttribute("T__144")]
private void mT__144();
    [GrammarRuleAttribute("T__145")]
private void mT__145();
    [GrammarRuleAttribute("T__146")]
private void mT__146();
    [GrammarRuleAttribute("T__147")]
private void mT__147();
    [GrammarRuleAttribute("T__148")]
private void mT__148();
    [GrammarRuleAttribute("T__149")]
private void mT__149();
    [GrammarRuleAttribute("T__150")]
private void mT__150();
    [GrammarRuleAttribute("T__151")]
private void mT__151();
    [GrammarRuleAttribute("T__152")]
private void mT__152();
    [GrammarRuleAttribute("T__153")]
private void mT__153();
    [GrammarRuleAttribute("T__154")]
private void mT__154();
    [GrammarRuleAttribute("T__155")]
private void mT__155();
    [GrammarRuleAttribute("T__156")]
private void mT__156();
    [GrammarRuleAttribute("T__157")]
private void mT__157();
    [GrammarRuleAttribute("T__158")]
private void mT__158();
    [GrammarRuleAttribute("T__159")]
private void mT__159();
    [GrammarRuleAttribute("T__160")]
private void mT__160();
    [GrammarRuleAttribute("T__161")]
private void mT__161();
    [GrammarRuleAttribute("T__162")]
private void mT__162();
    [GrammarRuleAttribute("T__163")]
private void mT__163();
    [GrammarRuleAttribute("T__164")]
private void mT__164();
    [GrammarRuleAttribute("T__165")]
private void mT__165();
    [GrammarRuleAttribute("T__166")]
private void mT__166();
    [GrammarRuleAttribute("T__167")]
private void mT__167();
    [GrammarRuleAttribute("T__168")]
private void mT__168();
    [GrammarRuleAttribute("T__169")]
private void mT__169();
    [GrammarRuleAttribute("T__170")]
private void mT__170();
    [GrammarRuleAttribute("T__171")]
private void mT__171();
    [GrammarRuleAttribute("T__172")]
private void mT__172();
    [GrammarRuleAttribute("T__173")]
private void mT__173();
    [GrammarRuleAttribute("T__174")]
private void mT__174();
    [GrammarRuleAttribute("T__175")]
private void mT__175();
    [GrammarRuleAttribute("T__176")]
private void mT__176();
    [GrammarRuleAttribute("T__177")]
private void mT__177();
    [GrammarRuleAttribute("T__178")]
private void mT__178();
    [GrammarRuleAttribute("T__179")]
private void mT__179();
    [GrammarRuleAttribute("T__180")]
private void mT__180();
    [GrammarRuleAttribute("T__181")]
private void mT__181();
    [GrammarRuleAttribute("T__182")]
private void mT__182();
    [GrammarRuleAttribute("T__183")]
private void mT__183();
    [GrammarRuleAttribute("T__184")]
private void mT__184();
    [GrammarRuleAttribute("T__185")]
private void mT__185();
    [GrammarRuleAttribute("T__186")]
private void mT__186();
    [GrammarRuleAttribute("T__187")]
private void mT__187();
    [GrammarRuleAttribute("T__188")]
private void mT__188();
    [GrammarRuleAttribute("T__189")]
private void mT__189();
    [GrammarRuleAttribute("T__190")]
private void mT__190();
    [GrammarRuleAttribute("T__191")]
private void mT__191();
    [GrammarRuleAttribute("T__192")]
private void mT__192();
    [GrammarRuleAttribute("T__193")]
private void mT__193();
    [GrammarRuleAttribute("T__194")]
private void mT__194();
    [GrammarRuleAttribute("T__195")]
private void mT__195();
    [GrammarRuleAttribute("T__196")]
private void mT__196();
    [GrammarRuleAttribute("T__197")]
private void mT__197();
    [GrammarRuleAttribute("T__198")]
private void mT__198();
    [GrammarRuleAttribute("T__199")]
private void mT__199();
    [GrammarRuleAttribute("T__200")]
private void mT__200();
    [GrammarRuleAttribute("T__201")]
private void mT__201();
    [GrammarRuleAttribute("T__202")]
private void mT__202();
    [GrammarRuleAttribute("T__203")]
private void mT__203();
    [GrammarRuleAttribute("T__204")]
private void mT__204();
    [GrammarRuleAttribute("T__205")]
private void mT__205();
    [GrammarRuleAttribute("T__206")]
private void mT__206();
    [GrammarRuleAttribute("TRUE")]
private void mTRUE();
    [GrammarRuleAttribute("FALSE")]
private void mFALSE();
    [GrammarRuleAttribute("NULL")]
private void mNULL();
    [GrammarRuleAttribute("DOT")]
private void mDOT();
    [GrammarRuleAttribute("PTR")]
private void mPTR();
    [GrammarRuleAttribute("MINUS")]
private void mMINUS();
    [GrammarRuleAttribute("GT")]
private void mGT();
    [GrammarRuleAttribute("USING")]
private void mUSING();
    [GrammarRuleAttribute("ENUM")]
private void mENUM();
    [GrammarRuleAttribute("IF")]
private void mIF();
    [GrammarRuleAttribute("ELIF")]
private void mELIF();
    [GrammarRuleAttribute("ENDIF")]
private void mENDIF();
    [GrammarRuleAttribute("DEFINE")]
private void mDEFINE();
    [GrammarRuleAttribute("UNDEF")]
private void mUNDEF();
    [GrammarRuleAttribute("SEMI")]
private void mSEMI();
    [GrammarRuleAttribute("LPAREN")]
private void mLPAREN();
    [GrammarRuleAttribute("RPAREN")]
private void mRPAREN();
    [GrammarRuleAttribute("WS")]
private void mWS();
    [GrammarRuleAttribute("TS")]
private void mTS();
    [GrammarRuleAttribute("DOC_LINE_COMMENT")]
private void mDOC_LINE_COMMENT();
    [GrammarRuleAttribute("LINE_COMMENT")]
private void mLINE_COMMENT();
    [GrammarRuleAttribute("COMMENT")]
private void mCOMMENT();
    [GrammarRuleAttribute("STRINGLITERAL")]
private void mSTRINGLITERAL();
    [GrammarRuleAttribute("Verbatim_string_literal")]
private void mVerbatim_string_literal();
    [GrammarRuleAttribute("Verbatim_string_literal_character")]
private void mVerbatim_string_literal_character();
    [GrammarRuleAttribute("NUMBER")]
private void mNUMBER();
    [GrammarRuleAttribute("GooBall")]
private void mGooBall();
    [GrammarRuleAttribute("GooBallIdentifier")]
private void mGooBallIdentifier();
    [GrammarRuleAttribute("Real_literal")]
private void mReal_literal();
    [GrammarRuleAttribute("Character_literal")]
private void mCharacter_literal();
    [GrammarRuleAttribute("IDENTIFIER")]
private void mIDENTIFIER();
    [GrammarRuleAttribute("Pragma")]
private void mPragma();
    [GrammarRuleAttribute("PREPROCESSOR_DIRECTIVE")]
private void mPREPROCESSOR_DIRECTIVE();
    [GrammarRuleAttribute("PP_CONDITIONAL")]
private void mPP_CONDITIONAL();
    [GrammarRuleAttribute("IF_TOKEN")]
private void mIF_TOKEN();
    [GrammarRuleAttribute("DEFINE_TOKEN")]
private void mDEFINE_TOKEN();
    [GrammarRuleAttribute("UNDEF_TOKEN")]
private void mUNDEF_TOKEN();
    [GrammarRuleAttribute("ELSE_TOKEN")]
private void mELSE_TOKEN();
    [GrammarRuleAttribute("ENDIF_TOKEN")]
private void mENDIF_TOKEN();
    [GrammarRuleAttribute("PP_EXPRESSION")]
private void mPP_EXPRESSION();
    [GrammarRuleAttribute("PP_OR_EXPRESSION")]
private void mPP_OR_EXPRESSION();
    [GrammarRuleAttribute("PP_AND_EXPRESSION")]
private void mPP_AND_EXPRESSION();
    [GrammarRuleAttribute("PP_EQUALITY_EXPRESSION")]
private void mPP_EQUALITY_EXPRESSION();
    [GrammarRuleAttribute("PP_UNARY_EXPRESSION")]
private void mPP_UNARY_EXPRESSION();
    [GrammarRuleAttribute("PP_PRIMARY_EXPRESSION")]
private void mPP_PRIMARY_EXPRESSION();
    [GrammarRuleAttribute("IdentifierStart")]
private void mIdentifierStart();
    [GrammarRuleAttribute("IdentifierPart")]
private void mIdentifierPart();
    [GrammarRuleAttribute("StringEscapeSequence")]
private void mStringEscapeSequence();
    [GrammarRuleAttribute("EscapeSequence")]
private void mEscapeSequence();
    [GrammarRuleAttribute("Decimal_integer_literal")]
private void mDecimal_integer_literal();
    [GrammarRuleAttribute("Hex_number")]
private void mHex_number();
    [GrammarRuleAttribute("Decimal_digits")]
private void mDecimal_digits();
    [GrammarRuleAttribute("DECIMAL_DIGIT")]
private void mDECIMAL_DIGIT();
    [GrammarRuleAttribute("INTEGER_TYPE_SUFFIX")]
private void mINTEGER_TYPE_SUFFIX();
    [GrammarRuleAttribute("HEX_DIGITS")]
private void mHEX_DIGITS();
    [GrammarRuleAttribute("HEX_DIGIT")]
private void mHEX_DIGIT();
    [GrammarRuleAttribute("Exponent_part")]
private void mExponent_part();
    [GrammarRuleAttribute("Sign")]
private void mSign();
    [GrammarRuleAttribute("Real_type_suffix")]
private void mReal_type_suffix();
    [GrammarRuleAttribute("ANYCHAR")]
private void mANYCHAR();
    public virtual void mTokens();
    protected virtual void InitDFAs();
    private int SpecialStateTransition71(DFA dfa, int s, IIntStream _input);
}
[GeneratedCodeAttribute("ANTLR", "3.5.0.2")]
[CLSCompliantAttribute("False")]
public class ExpressionEvaluator.Parser.ExprEvalParser : Parser {
    private CompilerState compilerState;
    [CompilerGeneratedAttribute]
private Expression <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCall>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelTarget <ReturnTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeRegistry <TypeRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Type> <DynamicTypeLookup>k__BackingField;
    private Stack`1<TypeOrGeneric> methodStack;
    public ParameterList ParameterList;
    internal static String[] tokenNames;
    public static int EOF;
    public static int ANYCHAR;
    public static int COMMENT;
    public static int Character_literal;
    public static int DECIMAL_DIGIT;
    public static int DEFINE;
    public static int DEFINE_TOKEN;
    public static int DOC_LINE_COMMENT;
    public static int DOT;
    public static int Decimal_digits;
    public static int Decimal_integer_literal;
    public static int ELIF;
    public static int ELSE_TOKEN;
    public static int ENDIF;
    public static int ENDIF_TOKEN;
    public static int ENUM;
    public static int EscapeSequence;
    public static int Exponent_part;
    public static int FALSE;
    public static int GT;
    public static int GooBall;
    public static int GooBallIdentifier;
    public static int HEX_DIGIT;
    public static int HEX_DIGITS;
    public static int Hex_number;
    public static int IDENTIFIER;
    public static int IF;
    public static int IF_TOKEN;
    public static int INTEGER_TYPE_SUFFIX;
    public static int IdentifierPart;
    public static int IdentifierStart;
    public static int LINE_COMMENT;
    public static int LPAREN;
    public static int MINUS;
    public static int NULL;
    public static int NUMBER;
    public static int PP_AND_EXPRESSION;
    public static int PP_CONDITIONAL;
    public static int PP_EQUALITY_EXPRESSION;
    public static int PP_EXPRESSION;
    public static int PP_OR_EXPRESSION;
    public static int PP_PRIMARY_EXPRESSION;
    public static int PP_UNARY_EXPRESSION;
    public static int PREPROCESSOR_DIRECTIVE;
    public static int PTR;
    public static int Pragma;
    public static int RPAREN;
    public static int Real_literal;
    public static int Real_type_suffix;
    public static int SEMI;
    public static int STRINGLITERAL;
    public static int Sign;
    public static int StringEscapeSequence;
    public static int TRUE;
    public static int TS;
    public static int UNDEF;
    public static int UNDEF_TOKEN;
    public static int USING;
    public static int Verbatim_string_literal;
    public static int Verbatim_string_literal_character;
    public static int WS;
    public static int T__64;
    public static int T__65;
    public static int T__66;
    public static int T__67;
    public static int T__68;
    public static int T__69;
    public static int T__70;
    public static int T__71;
    public static int T__72;
    public static int T__73;
    public static int T__74;
    public static int T__75;
    public static int T__76;
    public static int T__77;
    public static int T__78;
    public static int T__79;
    public static int T__80;
    public static int T__81;
    public static int T__82;
    public static int T__83;
    public static int T__84;
    public static int T__85;
    public static int T__86;
    public static int T__87;
    public static int T__88;
    public static int T__89;
    public static int T__90;
    public static int T__91;
    public static int T__92;
    public static int T__93;
    public static int T__94;
    public static int T__95;
    public static int T__96;
    public static int T__97;
    public static int T__98;
    public static int T__99;
    public static int T__100;
    public static int T__101;
    public static int T__102;
    public static int T__103;
    public static int T__104;
    public static int T__105;
    public static int T__106;
    public static int T__107;
    public static int T__108;
    public static int T__109;
    public static int T__110;
    public static int T__111;
    public static int T__112;
    public static int T__113;
    public static int T__114;
    public static int T__115;
    public static int T__116;
    public static int T__117;
    public static int T__118;
    public static int T__119;
    public static int T__120;
    public static int T__121;
    public static int T__122;
    public static int T__123;
    public static int T__124;
    public static int T__125;
    public static int T__126;
    public static int T__127;
    public static int T__128;
    public static int T__129;
    public static int T__130;
    public static int T__131;
    public static int T__132;
    public static int T__133;
    public static int T__134;
    public static int T__135;
    public static int T__136;
    public static int T__137;
    public static int T__138;
    public static int T__139;
    public static int T__140;
    public static int T__141;
    public static int T__142;
    public static int T__143;
    public static int T__144;
    public static int T__145;
    public static int T__146;
    public static int T__147;
    public static int T__148;
    public static int T__149;
    public static int T__150;
    public static int T__151;
    public static int T__152;
    public static int T__153;
    public static int T__154;
    public static int T__155;
    public static int T__156;
    public static int T__157;
    public static int T__158;
    public static int T__159;
    public static int T__160;
    public static int T__161;
    public static int T__162;
    public static int T__163;
    public static int T__164;
    public static int T__165;
    public static int T__166;
    public static int T__167;
    public static int T__168;
    public static int T__169;
    public static int T__170;
    public static int T__171;
    public static int T__172;
    public static int T__173;
    public static int T__174;
    public static int T__175;
    public static int T__176;
    public static int T__177;
    public static int T__178;
    public static int T__179;
    public static int T__180;
    public static int T__181;
    public static int T__182;
    public static int T__183;
    public static int T__184;
    public static int T__185;
    public static int T__186;
    public static int T__187;
    public static int T__188;
    public static int T__189;
    public static int T__190;
    public static int T__191;
    public static int T__192;
    public static int T__193;
    public static int T__194;
    public static int T__195;
    public static int T__196;
    public static int T__197;
    public static int T__198;
    public static int T__199;
    public static int T__200;
    public static int T__201;
    public static int T__202;
    public static int T__203;
    public static int T__204;
    public static int T__205;
    public static int T__206;
    private bool fakedot;
    private DFA49 dfa49;
    private DFA68 dfa68;
    private DFA69 dfa69;
    public Expression Scope { get; public set; }
    public bool IsCall { get; public set; }
    public LabelTarget ReturnTarget { get; public set; }
    public bool HasReturn { get; private set; }
    public TypeRegistry TypeRegistry { get; public set; }
    public Dictionary`2<string, Type> DynamicTypeLookup { get; public set; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public ExprEvalParser(ITokenStream input);
    public ExprEvalParser(ITokenStream input, RecognizerSharedState state);
    private static ExprEvalParser();
    [CompilerGeneratedAttribute]
public Expression get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(Expression value);
    [CompilerGeneratedAttribute]
public bool get_IsCall();
    [CompilerGeneratedAttribute]
public void set_IsCall(bool value);
    [CompilerGeneratedAttribute]
public LabelTarget get_ReturnTarget();
    [CompilerGeneratedAttribute]
public void set_ReturnTarget(LabelTarget value);
    [CompilerGeneratedAttribute]
public bool get_HasReturn();
    [CompilerGeneratedAttribute]
private void set_HasReturn(bool value);
    [CompilerGeneratedAttribute]
public TypeRegistry get_TypeRegistry();
    [CompilerGeneratedAttribute]
public void set_TypeRegistry(TypeRegistry value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Type> get_DynamicTypeLookup();
    [CompilerGeneratedAttribute]
public void set_DynamicTypeLookup(Dictionary`2<string, Type> value);
    public object Eval(string expressionString);
    protected Expression GetPrimaryExpressionPart(PrimaryExpressionPart primary_expression_part2, ITokenStream input, Expression value, bool throwsException);
    public virtual void ReportError(RecognitionException e);
    private Expression GetIdentifier(string identifier);
    public Type GetType(string type);
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    protected bool is_class_modifier();
    [GrammarRuleAttribute("compilation_unit")]
public void compilation_unit();
    [GrammarRuleAttribute("namespace_declaration")]
public void namespace_declaration();
    [GrammarRuleAttribute("namespace_block")]
public void namespace_block();
    [GrammarRuleAttribute("namespace_body")]
private void namespace_body(bool bGlobal);
    [GrammarRuleAttribute("extern_alias_directives")]
public void extern_alias_directives();
    [GrammarRuleAttribute("extern_alias_directive")]
public void extern_alias_directive();
    [GrammarRuleAttribute("using_directives")]
public void using_directives();
    [GrammarRuleAttribute("using_directive")]
public void using_directive();
    [GrammarRuleAttribute("using_alias_directive")]
public void using_alias_directive();
    [GrammarRuleAttribute("using_namespace_directive")]
public void using_namespace_directive();
    [GrammarRuleAttribute("namespace_member_declarations")]
public void namespace_member_declarations();
    [GrammarRuleAttribute("namespace_member_declaration")]
public void namespace_member_declaration();
    [GrammarRuleAttribute("type_declaration")]
public void type_declaration();
    [GrammarRuleAttribute("qualified_identifier")]
public void qualified_identifier();
    [GrammarRuleAttribute("namespace_name")]
private void namespace_name();
    [GrammarRuleAttribute("modifiers")]
public void modifiers();
    [GrammarRuleAttribute("modifier")]
public void modifier();
    [GrammarRuleAttribute("class_member_declaration")]
public void class_member_declaration();
    [GrammarRuleAttribute("primary_expression")]
public Expression primary_expression();
    [GrammarRuleAttribute("primary_expression_start")]
public primary_expression_start_return primary_expression_start();
    [GrammarRuleAttribute("primary_expression_part")]
public PrimaryExpressionPart primary_expression_part();
    [GrammarRuleAttribute("access_identifier")]
public AccessIdentifier access_identifier();
    [GrammarRuleAttribute("access_operator")]
public void access_operator();
    [GrammarRuleAttribute("brackets_or_arguments")]
public PrimaryExpressionPart brackets_or_arguments();
    [GrammarRuleAttribute("brackets")]
public Brackets brackets();
    [GrammarRuleAttribute("paren_expression")]
public Expression paren_expression();
    [GrammarRuleAttribute("arguments")]
public Arguments arguments();
    [GrammarRuleAttribute("argument_list")]
public List`1<Argument> argument_list();
    [GrammarRuleAttribute("argument")]
public Argument argument();
    [GrammarRuleAttribute("argument_name")]
public string argument_name();
    [GrammarRuleAttribute("argument_value")]
public Argument argument_value();
    [GrammarRuleAttribute("ref_variable_reference")]
public Expression ref_variable_reference();
    [GrammarRuleAttribute("variable_reference")]
public Expression variable_reference();
    [GrammarRuleAttribute("rank_specifiers")]
public void rank_specifiers();
    [GrammarRuleAttribute("rank_specifier")]
public void rank_specifier();
    [GrammarRuleAttribute("dim_separators")]
public void dim_separators();
    [GrammarRuleAttribute("delegate_creation_expression")]
public void delegate_creation_expression();
    [GrammarRuleAttribute("anonymous_object_creation_expression")]
public void anonymous_object_creation_expression();
    [GrammarRuleAttribute("anonymous_object_initializer")]
public void anonymous_object_initializer();
    [GrammarRuleAttribute("member_declarator_list")]
public void member_declarator_list();
    [GrammarRuleAttribute("member_declarator")]
public void member_declarator();
    [GrammarRuleAttribute("primary_or_array_creation_expression")]
public Expression primary_or_array_creation_expression();
    [GrammarRuleAttribute("array_creation_expression")]
public Expression array_creation_expression();
    [GrammarRuleAttribute("array_initializer")]
public NewArrayExpression array_initializer();
    [GrammarRuleAttribute("variable_initializer_list")]
public List`1<Expression> variable_initializer_list();
    [GrammarRuleAttribute("variable_initializer")]
public Expression variable_initializer();
    [GrammarRuleAttribute("sizeof_expression")]
public void sizeof_expression();
    [GrammarRuleAttribute("checked_expression")]
public void checked_expression();
    [GrammarRuleAttribute("unchecked_expression")]
public void unchecked_expression();
    [GrammarRuleAttribute("default_value_expression")]
public void default_value_expression();
    [GrammarRuleAttribute("anonymous_method_expression")]
public void anonymous_method_expression();
    [GrammarRuleAttribute("explicit_anonymous_function_signature")]
public void explicit_anonymous_function_signature();
    [GrammarRuleAttribute("explicit_anonymous_function_parameter_list")]
public void explicit_anonymous_function_parameter_list();
    [GrammarRuleAttribute("explicit_anonymous_function_parameter")]
public void explicit_anonymous_function_parameter();
    [GrammarRuleAttribute("anonymous_function_parameter_modifier")]
public void anonymous_function_parameter_modifier();
    [GrammarRuleAttribute("object_creation_expression")]
public Expression object_creation_expression();
    [GrammarRuleAttribute("object_or_collection_initializer")]
public ObjectOrCollectionInitializer object_or_collection_initializer();
    [GrammarRuleAttribute("collection_initializer")]
public void collection_initializer();
    [GrammarRuleAttribute("element_initializer_list")]
public void element_initializer_list();
    [GrammarRuleAttribute("element_initializer")]
public void element_initializer();
    [GrammarRuleAttribute("object_initializer")]
public List`1<MemberInitializer> object_initializer();
    [GrammarRuleAttribute("member_initializer_list")]
public List`1<MemberInitializer> member_initializer_list();
    [GrammarRuleAttribute("member_initializer")]
public MemberInitializer member_initializer();
    [GrammarRuleAttribute("initializer_value")]
public Expression initializer_value();
    [GrammarRuleAttribute("typeof_expression")]
public Expression typeof_expression();
    [GrammarRuleAttribute("unbound_type_name")]
public ParserRuleReturnScope`1<IToken> unbound_type_name();
    [GrammarRuleAttribute("unbound_type_name_start")]
public void unbound_type_name_start();
    [GrammarRuleAttribute("unbound_type_name_part")]
public void unbound_type_name_part();
    [GrammarRuleAttribute("generic_dimension_specifier")]
public void generic_dimension_specifier();
    [GrammarRuleAttribute("commas")]
public void commas();
    [GrammarRuleAttribute("type_name")]
public TypeOrGeneric type_name();
    [GrammarRuleAttribute("namespace_or_type_name")]
public TypeOrGeneric namespace_or_type_name();
    [GrammarRuleAttribute("type_or_generic")]
public TypeOrGeneric type_or_generic();
    [GrammarRuleAttribute("qid")]
public void qid();
    [GrammarRuleAttribute("qid_start")]
public void qid_start();
    [GrammarRuleAttribute("qid_part")]
public void qid_part();
    [GrammarRuleAttribute("generic_argument_list")]
public List`1<Type> generic_argument_list();
    [GrammarRuleAttribute("type_arguments")]
public List`1<Type> type_arguments();
    [GrammarRuleAttribute("type")]
public type_return type();
    [GrammarRuleAttribute("non_nullable_type")]
public void non_nullable_type();
    [GrammarRuleAttribute("non_array_type")]
public void non_array_type();
    [GrammarRuleAttribute("array_type")]
public void array_type();
    [GrammarRuleAttribute("unmanaged_type")]
public void unmanaged_type();
    [GrammarRuleAttribute("class_type")]
public void class_type();
    [GrammarRuleAttribute("pointer_type")]
public void pointer_type();
    [GrammarRuleAttribute("block")]
public Expression block();
    [GrammarRuleAttribute("statement_list")]
public StatementList statement_list();
    [GrammarRuleAttribute("single_expression")]
public Expression single_expression();
    [GrammarRuleAttribute("expression")]
public Expression expression();
    [GrammarRuleAttribute("expression_list")]
public List`1<Expression> expression_list();
    [GrammarRuleAttribute("assignment")]
public Expression assignment();
    [GrammarRuleAttribute("unary_expression")]
public Expression unary_expression();
    [GrammarRuleAttribute("cast_expression")]
public Expression cast_expression();
    [GrammarRuleAttribute("assignment_operator")]
public ParserRuleReturnScope`1<IToken> assignment_operator();
    [GrammarRuleAttribute("pre_increment_expression")]
public Expression pre_increment_expression();
    [GrammarRuleAttribute("pre_decrement_expression")]
public Expression pre_decrement_expression();
    [GrammarRuleAttribute("pointer_indirection_expression")]
public Expression pointer_indirection_expression();
    [GrammarRuleAttribute("addressof_expression")]
public Expression addressof_expression();
    [GrammarRuleAttribute("non_assignment_expression")]
public Expression non_assignment_expression();
    [GrammarRuleAttribute("multiplicative_expression")]
public Expression multiplicative_expression();
    [GrammarRuleAttribute("additive_expression")]
public Expression additive_expression();
    [GrammarRuleAttribute("shift_expression")]
public Expression shift_expression();
    [GrammarRuleAttribute("relational_expression")]
public Expression relational_expression();
    [GrammarRuleAttribute("equality_expression")]
public Expression equality_expression();
    [GrammarRuleAttribute("and_expression")]
public Expression and_expression();
    [GrammarRuleAttribute("exclusive_or_expression")]
public Expression exclusive_or_expression();
    [GrammarRuleAttribute("inclusive_or_expression")]
public Expression inclusive_or_expression();
    [GrammarRuleAttribute("conditional_and_expression")]
public Expression conditional_and_expression();
    [GrammarRuleAttribute("conditional_or_expression")]
public Expression conditional_or_expression();
    [GrammarRuleAttribute("null_coalescing_expression")]
public Expression null_coalescing_expression();
    [GrammarRuleAttribute("conditional_expression")]
public Expression conditional_expression();
    [GrammarRuleAttribute("lambda_expression")]
public Expression lambda_expression();
    [GrammarRuleAttribute("anonymous_function_signature")]
public List`1<ParameterExpression> anonymous_function_signature();
    [GrammarRuleAttribute("implicit_anonymous_function_parameter_list")]
public List`1<ParameterExpression> implicit_anonymous_function_parameter_list();
    [GrammarRuleAttribute("implicit_anonymous_function_parameter")]
public ParameterExpression implicit_anonymous_function_parameter();
    [GrammarRuleAttribute("anonymous_function_body")]
public Expression anonymous_function_body();
    [GrammarRuleAttribute("query_expression")]
public void query_expression();
    [GrammarRuleAttribute("query_body")]
public void query_body();
    [GrammarRuleAttribute("query_continuation")]
public void query_continuation();
    [GrammarRuleAttribute("query_body_clauses")]
public void query_body_clauses();
    [GrammarRuleAttribute("query_body_clause")]
public void query_body_clause();
    [GrammarRuleAttribute("from_clause")]
public void from_clause();
    [GrammarRuleAttribute("join_clause")]
public void join_clause();
    [GrammarRuleAttribute("let_clause")]
public void let_clause();
    [GrammarRuleAttribute("orderby_clause")]
public void orderby_clause();
    [GrammarRuleAttribute("ordering_list")]
public void ordering_list();
    [GrammarRuleAttribute("ordering")]
public void ordering();
    [GrammarRuleAttribute("ordering_direction")]
public void ordering_direction();
    [GrammarRuleAttribute("select_or_group_clause")]
public void select_or_group_clause();
    [GrammarRuleAttribute("select_clause")]
public void select_clause();
    [GrammarRuleAttribute("group_clause")]
public void group_clause();
    [GrammarRuleAttribute("where_clause")]
public void where_clause();
    [GrammarRuleAttribute("boolean_expression")]
public Expression boolean_expression();
    [GrammarRuleAttribute("global_attributes")]
public void global_attributes();
    [GrammarRuleAttribute("global_attribute")]
public void global_attribute();
    [GrammarRuleAttribute("global_attribute_target_specifier")]
public void global_attribute_target_specifier();
    [GrammarRuleAttribute("global_attribute_target")]
public void global_attribute_target();
    [GrammarRuleAttribute("attributes")]
public void attributes();
    [GrammarRuleAttribute("attribute_sections")]
public void attribute_sections();
    [GrammarRuleAttribute("attribute_section")]
public void attribute_section();
    [GrammarRuleAttribute("attribute_target_specifier")]
public void attribute_target_specifier();
    [GrammarRuleAttribute("attribute_target")]
public void attribute_target();
    [GrammarRuleAttribute("attribute_list")]
public void attribute_list();
    [GrammarRuleAttribute("attribute")]
public void attribute();
    [GrammarRuleAttribute("attribute_arguments")]
public void attribute_arguments();
    [GrammarRuleAttribute("positional_argument_list")]
public void positional_argument_list();
    [GrammarRuleAttribute("positional_argument")]
public void positional_argument();
    [GrammarRuleAttribute("named_argument_list")]
public void named_argument_list();
    [GrammarRuleAttribute("named_argument")]
public void named_argument();
    [GrammarRuleAttribute("attribute_argument_expression")]
public void attribute_argument_expression();
    [GrammarRuleAttribute("class_declaration")]
public void class_declaration();
    [GrammarRuleAttribute("class_base")]
public void class_base();
    [GrammarRuleAttribute("interface_type_list")]
public void interface_type_list();
    [GrammarRuleAttribute("class_body")]
public void class_body();
    [GrammarRuleAttribute("class_member_declarations")]
public void class_member_declarations();
    [GrammarRuleAttribute("constant_declaration")]
public void constant_declaration();
    [GrammarRuleAttribute("constant_declarators")]
public void constant_declarators();
    [GrammarRuleAttribute("constant_declarator")]
public void constant_declarator();
    [GrammarRuleAttribute("constant_expression")]
public Expression constant_expression();
    [GrammarRuleAttribute("field_declaration")]
public Expression field_declaration();
    [GrammarRuleAttribute("variable_declarators")]
public Expression variable_declarators();
    [GrammarRuleAttribute("variable_declarator")]
public Expression variable_declarator();
    [GrammarRuleAttribute("method_declaration")]
public void method_declaration();
    [GrammarRuleAttribute("method_header")]
public void method_header();
    [GrammarRuleAttribute("method_body")]
public void method_body();
    [GrammarRuleAttribute("member_name")]
public void member_name();
    [GrammarRuleAttribute("property_declaration")]
public void property_declaration();
    [GrammarRuleAttribute("accessor_declarations")]
public void accessor_declarations();
    [GrammarRuleAttribute("get_accessor_declaration")]
public void get_accessor_declaration();
    [GrammarRuleAttribute("set_accessor_declaration")]
public void set_accessor_declaration();
    [GrammarRuleAttribute("accessor_modifier")]
public void accessor_modifier();
    [GrammarRuleAttribute("accessor_body")]
public void accessor_body();
    [GrammarRuleAttribute("event_declaration")]
public void event_declaration();
    [GrammarRuleAttribute("event_modifiers")]
public void event_modifiers();
    [GrammarRuleAttribute("event_accessor_declarations")]
public void event_accessor_declarations();
    [GrammarRuleAttribute("add_accessor_declaration")]
public void add_accessor_declaration();
    [GrammarRuleAttribute("remove_accessor_declaration")]
public void remove_accessor_declaration();
    [GrammarRuleAttribute("enum_declaration")]
public void enum_declaration();
    [GrammarRuleAttribute("enum_base")]
public void enum_base();
    [GrammarRuleAttribute("enum_body")]
public void enum_body();
    [GrammarRuleAttribute("enum_member_declarations")]
public void enum_member_declarations();
    [GrammarRuleAttribute("enum_member_declaration")]
public void enum_member_declaration();
    [GrammarRuleAttribute("integral_type")]
public void integral_type();
    [GrammarRuleAttribute("delegate_declaration")]
public void delegate_declaration();
    [GrammarRuleAttribute("delegate_modifiers")]
public void delegate_modifiers();
    [GrammarRuleAttribute("variant_generic_parameter_list")]
public void variant_generic_parameter_list();
    [GrammarRuleAttribute("variant_type_parameters")]
public void variant_type_parameters();
    [GrammarRuleAttribute("variant_type_variable_name")]
public void variant_type_variable_name();
    [GrammarRuleAttribute("variance_annotation")]
public void variance_annotation();
    [GrammarRuleAttribute("type_parameter_constraints_clauses")]
public void type_parameter_constraints_clauses();
    [GrammarRuleAttribute("type_parameter_constraints_clause")]
public void type_parameter_constraints_clause();
    [GrammarRuleAttribute("type_parameter_constraint_list")]
public void type_parameter_constraint_list();
    [GrammarRuleAttribute("secondary_constraint_list")]
public void secondary_constraint_list();
    [GrammarRuleAttribute("secondary_constraint")]
public void secondary_constraint();
    [GrammarRuleAttribute("type_variable_name")]
public void type_variable_name();
    [GrammarRuleAttribute("constructor_constraint")]
public void constructor_constraint();
    [GrammarRuleAttribute("return_type")]
public void return_type();
    [GrammarRuleAttribute("formal_parameter_list")]
public void formal_parameter_list();
    [GrammarRuleAttribute("formal_parameter")]
public void formal_parameter();
    [GrammarRuleAttribute("fixed_parameters")]
public void fixed_parameters();
    [GrammarRuleAttribute("fixed_parameter")]
public void fixed_parameter();
    [GrammarRuleAttribute("default_argument")]
public void default_argument();
    [GrammarRuleAttribute("parameter_modifier")]
public void parameter_modifier();
    [GrammarRuleAttribute("parameter_array")]
public void parameter_array();
    [GrammarRuleAttribute("interface_declaration")]
public void interface_declaration();
    [GrammarRuleAttribute("interface_modifiers")]
public void interface_modifiers();
    [GrammarRuleAttribute("interface_base")]
public void interface_base();
    [GrammarRuleAttribute("interface_body")]
public void interface_body();
    [GrammarRuleAttribute("interface_member_declarations")]
public void interface_member_declarations();
    [GrammarRuleAttribute("interface_member_declaration")]
public void interface_member_declaration();
    [GrammarRuleAttribute("interface_property_declaration")]
public void interface_property_declaration();
    [GrammarRuleAttribute("interface_method_declaration")]
public void interface_method_declaration();
    [GrammarRuleAttribute("interface_event_declaration")]
public void interface_event_declaration();
    [GrammarRuleAttribute("interface_indexer_declaration")]
public void interface_indexer_declaration();
    [GrammarRuleAttribute("interface_accessor_declarations")]
public void interface_accessor_declarations();
    [GrammarRuleAttribute("interface_get_accessor_declaration")]
public void interface_get_accessor_declaration();
    [GrammarRuleAttribute("interface_set_accessor_declaration")]
public void interface_set_accessor_declaration();
    [GrammarRuleAttribute("method_modifiers")]
public void method_modifiers();
    [GrammarRuleAttribute("struct_declaration")]
public void struct_declaration();
    [GrammarRuleAttribute("struct_modifiers")]
public void struct_modifiers();
    [GrammarRuleAttribute("struct_modifier")]
public void struct_modifier();
    [GrammarRuleAttribute("struct_interfaces")]
public void struct_interfaces();
    [GrammarRuleAttribute("struct_body")]
public void struct_body();
    [GrammarRuleAttribute("struct_member_declarations")]
public void struct_member_declarations();
    [GrammarRuleAttribute("struct_member_declaration")]
public void struct_member_declaration();
    [GrammarRuleAttribute("indexer_declaration")]
public void indexer_declaration();
    [GrammarRuleAttribute("indexer_declarator")]
public void indexer_declarator();
    [GrammarRuleAttribute("operator_declaration")]
public void operator_declaration();
    [GrammarRuleAttribute("operator_declarator")]
public void operator_declarator();
    [GrammarRuleAttribute("unary_operator_declarator")]
public void unary_operator_declarator();
    [GrammarRuleAttribute("overloadable_unary_operator")]
public void overloadable_unary_operator();
    [GrammarRuleAttribute("binary_operator_declarator")]
public void binary_operator_declarator();
    [GrammarRuleAttribute("overloadable_binary_operator")]
public void overloadable_binary_operator();
    [GrammarRuleAttribute("conversion_operator_declaration")]
public void conversion_operator_declaration();
    [GrammarRuleAttribute("conversion_operator_declarator")]
public void conversion_operator_declarator();
    [GrammarRuleAttribute("operator_body")]
public void operator_body();
    [GrammarRuleAttribute("constructor_declaration")]
public void constructor_declaration();
    [GrammarRuleAttribute("constructor_declarator")]
public void constructor_declarator();
    [GrammarRuleAttribute("constructor_initializer")]
public void constructor_initializer();
    [GrammarRuleAttribute("constructor_body")]
public void constructor_body();
    [GrammarRuleAttribute("destructor_declaration")]
public void destructor_declaration();
    [GrammarRuleAttribute("destructor_body")]
public void destructor_body();
    [GrammarRuleAttribute("invocation_expression")]
public void invocation_expression();
    [GrammarRuleAttribute("invocation_start")]
public void invocation_start();
    [GrammarRuleAttribute("invocation_part")]
public void invocation_part();
    [GrammarRuleAttribute("statement")]
public Statement statement();
    [GrammarRuleAttribute("embedded_statement")]
public Expression embedded_statement();
    [GrammarRuleAttribute("fixed_statement")]
public void fixed_statement();
    [GrammarRuleAttribute("fixed_pointer_declarators")]
public void fixed_pointer_declarators();
    [GrammarRuleAttribute("fixed_pointer_declarator")]
public void fixed_pointer_declarator();
    [GrammarRuleAttribute("fixed_pointer_initializer")]
public void fixed_pointer_initializer();
    [GrammarRuleAttribute("unsafe_statement")]
public void unsafe_statement();
    [GrammarRuleAttribute("labeled_statement")]
public void labeled_statement();
    [GrammarRuleAttribute("declaration_statement")]
public DeclarationStatement declaration_statement();
    [GrammarRuleAttribute("local_variable_declaration")]
public LocalVariableDeclaration local_variable_declaration();
    [GrammarRuleAttribute("local_constant_declaration")]
public LocalConstDeclaration local_constant_declaration();
    [GrammarRuleAttribute("local_variable_type")]
public TypeOrGeneric local_variable_type();
    [GrammarRuleAttribute("local_variable_declarators")]
public List`1<Variable> local_variable_declarators();
    [GrammarRuleAttribute("local_variable_declarator")]
public Variable local_variable_declarator();
    [GrammarRuleAttribute("local_variable_initializer")]
public Expression local_variable_initializer();
    [GrammarRuleAttribute("stackalloc_initializer")]
public void stackalloc_initializer();
    [GrammarRuleAttribute("expression_statement")]
public Expression expression_statement();
    [GrammarRuleAttribute("selection_statement")]
public Expression selection_statement();
    [GrammarRuleAttribute("if_statement")]
public Expression if_statement();
    [GrammarRuleAttribute("else_statement")]
public Expression else_statement();
    [GrammarRuleAttribute("switch_statement")]
public Expression switch_statement();
    [GrammarRuleAttribute("switch_block")]
public List`1<SwitchCase> switch_block();
    [GrammarRuleAttribute("switch_sections")]
public List`1<SwitchCase> switch_sections();
    [GrammarRuleAttribute("switch_section")]
public SwitchCase switch_section();
    [GrammarRuleAttribute("switch_labels")]
public List`1<Expression> switch_labels();
    [GrammarRuleAttribute("switch_label")]
public Expression switch_label();
    [GrammarRuleAttribute("iteration_statement")]
public Expression iteration_statement();
    [GrammarRuleAttribute("while_statement")]
public Expression while_statement();
    [GrammarRuleAttribute("do_statement")]
public Expression do_statement();
    [GrammarRuleAttribute("for_statement")]
public Expression for_statement();
    [GrammarRuleAttribute("foreach_statement")]
public Expression foreach_statement();
    [GrammarRuleAttribute("for_initializer")]
public MultiStatement for_initializer();
    [GrammarRuleAttribute("for_condition")]
public Expression for_condition();
    [GrammarRuleAttribute("for_iterator")]
public StatementList for_iterator();
    [GrammarRuleAttribute("statement_expression_list")]
public StatementList statement_expression_list();
    [GrammarRuleAttribute("statement_expression")]
public Expression statement_expression();
    [GrammarRuleAttribute("jump_statement")]
public Expression jump_statement();
    [GrammarRuleAttribute("break_statement")]
public Expression break_statement();
    [GrammarRuleAttribute("continue_statement")]
public Expression continue_statement();
    [GrammarRuleAttribute("goto_statement")]
public void goto_statement();
    [GrammarRuleAttribute("return_statement")]
public Expression return_statement();
    [GrammarRuleAttribute("throw_statement")]
public void throw_statement();
    [GrammarRuleAttribute("try_statement")]
public void try_statement();
    [GrammarRuleAttribute("catch_clauses")]
public void catch_clauses();
    [GrammarRuleAttribute("specific_catch_clauses")]
public void specific_catch_clauses();
    [GrammarRuleAttribute("specific_catch_clause")]
public void specific_catch_clause();
    [GrammarRuleAttribute("general_catch_clause")]
public void general_catch_clause();
    [GrammarRuleAttribute("finally_clause")]
public void finally_clause();
    [GrammarRuleAttribute("checked_statement")]
public void checked_statement();
    [GrammarRuleAttribute("unchecked_statement")]
public void unchecked_statement();
    [GrammarRuleAttribute("lock_statement")]
public void lock_statement();
    [GrammarRuleAttribute("using_statement")]
public void using_statement();
    [GrammarRuleAttribute("resource_acquisition")]
public void resource_acquisition();
    [GrammarRuleAttribute("yield_statement")]
public void yield_statement();
    [GrammarRuleAttribute("predefined_type")]
public ParserRuleReturnScope`1<IToken> predefined_type();
    [GrammarRuleAttribute("identifier")]
public identifier_return identifier();
    [GrammarRuleAttribute("keyword")]
public void keyword();
    [GrammarRuleAttribute("also_keyword")]
public ParserRuleReturnScope`1<IToken> also_keyword();
    [GrammarRuleAttribute("literal")]
public Expression literal();
    [GrammarRuleAttribute("assignment_list")]
public void assignment_list();
    [GrammarRuleAttribute("field_declarations")]
public void field_declarations();
    [GrammarRuleAttribute("property_declaration_list")]
public void property_declaration_list();
    [GrammarRuleAttribute("constant_declarations")]
public void constant_declarations();
    [GrammarRuleAttribute("literals")]
public void literals();
    [GrammarRuleAttribute("delegate_declaration_list")]
public void delegate_declaration_list();
    [GrammarRuleAttribute("local_variable_declaration_list")]
public void local_variable_declaration_list();
    [GrammarRuleAttribute("local_variable_initializer_list")]
public void local_variable_initializer_list();
    [GrammarRuleAttribute("expression_list_test")]
public void expression_list_test();
    [GrammarRuleAttribute("unary_expression_list")]
public void unary_expression_list();
    [GrammarRuleAttribute("invocation_expression_list")]
public void invocation_expression_list();
    [GrammarRuleAttribute("primary_expression_list")]
public void primary_expression_list();
    [GrammarRuleAttribute("non_assignment_expression_list")]
public void non_assignment_expression_list();
    [GrammarRuleAttribute("method_declarations")]
public void method_declarations();
    private void synpred13_ExprEval_fragment();
    private void synpred45_ExprEval_fragment();
    private void synpred46_ExprEval_fragment();
    private void synpred47_ExprEval_fragment();
    private void synpred49_ExprEval_fragment();
    private void synpred57_ExprEval_fragment();
    private void synpred58_ExprEval_fragment();
    private void synpred59_ExprEval_fragment();
    private void synpred60_ExprEval_fragment();
    private void synpred61_ExprEval_fragment();
    private void synpred62_ExprEval_fragment();
    private void synpred65_ExprEval_fragment();
    private void synpred66_ExprEval_fragment();
    private void synpred67_ExprEval_fragment();
    private void synpred68_ExprEval_fragment();
    private void synpred75_ExprEval_fragment();
    private void synpred76_ExprEval_fragment();
    private void synpred81_ExprEval_fragment();
    private void synpred93_ExprEval_fragment();
    private void synpred102_ExprEval_fragment();
    private void synpred103_ExprEval_fragment();
    private void synpred110_ExprEval_fragment();
    private void synpred131_ExprEval_fragment();
    private void synpred141_ExprEval_fragment();
    private void synpred144_ExprEval_fragment();
    private void synpred149_ExprEval_fragment();
    private void synpred155_ExprEval_fragment();
    private void synpred160_ExprEval_fragment();
    private void synpred172_ExprEval_fragment();
    private void synpred174_ExprEval_fragment();
    private void synpred175_ExprEval_fragment();
    private void synpred193_ExprEval_fragment();
    private void synpred194_ExprEval_fragment();
    private void synpred221_ExprEval_fragment();
    private void synpred248_ExprEval_fragment();
    private void synpred275_ExprEval_fragment();
    private void synpred333_ExprEval_fragment();
    private void synpred334_ExprEval_fragment();
    private void synpred367_ExprEval_fragment();
    private void synpred368_ExprEval_fragment();
    private void synpred369_ExprEval_fragment();
    private void synpred371_ExprEval_fragment();
    private void synpred407_ExprEval_fragment();
    private void synpred410_ExprEval_fragment();
    private void synpred416_ExprEval_fragment();
    private void synpred417_ExprEval_fragment();
    private void synpred432_ExprEval_fragment();
    private void synpred433_ExprEval_fragment();
    private void synpred439_ExprEval_fragment();
    private void synpred450_ExprEval_fragment();
    private void synpred466_ExprEval_fragment();
    private bool EvaluatePredicate(Action fragment);
    protected virtual void InitDFAs();
    private int SpecialStateTransition68(DFA dfa, int s, IIntStream _input);
}
internal class ExpressionEvaluator.Parser.InvalidNumericPromotionException : Exception {
}
internal class ExpressionEvaluator.Parser.MethodResolution : object {
    private static Dictionary`2<Type, List`1<Type>> NumConv;
    private static Func`2<MethodInfo, bool> IsVirtual;
    private static Func`2<MethodInfo, bool> HasVTable;
    private static BindingFlags findFlags;
    private static MethodResolution();
    private static Type[] GetTypesInNamespace(Assembly assembly, string nameSpace);
    public static List`1<TypeInferrence> SecondPhase(ApplicableFunctionMember member, IEnumerable`1<Argument> arguments);
    public void MakeLowerBoundInference(TypeParameter X, Type U, Type V);
    public static List`1<TypeInferrence> FirstPhase(ApplicableFunctionMember member, IEnumerable`1<Argument> arguments);
    public static List`1<TypeInferrence> TypeInference(ApplicableFunctionMember member, IEnumerable`1<Argument> arguments);
    public static bool CanConvertType(object value, bool isLiteral, Type from, Type to);
    public static ApplicableFunctionMember IsApplicableFunctionMember(MethodInfo F, IEnumerable`1<Argument> argList);
    public static bool HasIdentityConversion(Type T1, Type T2);
    public static bool HasImplicitNumericConversion(Type T1, Type T2);
    public static bool HasImplicitEnumerationConversion(Type T1, Type T2);
    public static bool HasImplicitNullableConversion(Type S, Type T);
    public static bool HasNullLiteralConversion(Expression E, Type T1);
    public static bool IsDelegate(Type t);
    public static bool IsReferenceType(Type T);
    public static bool HasImplicitReferenceConversion(Type S, Type T);
    public static bool HasImplicitBoxingConversions(Expression E, Type T2);
    public static bool HasImplicitConstantExpressionConversions(Expression E, Type T2);
    public static bool HasImplicitConversionInvolvingTypeParameters(Type T1, Type T2);
    public static bool HasImplicitConversion(Expression E, Type T1, Type T2);
    public static bool IsBetterConversionTarget(Expression E, Type T1, Type T2);
    public static bool BetterConversion(Expression E, Type T1, Type T2);
    public static Type[] GetExpandedParameterTypes(ParameterInfo[] parameters, int argCount);
    public static int GetBetterFunctionMember(ApplicableFunctionMember MP, ApplicableFunctionMember MQ, IEnumerable`1<Argument> argList);
    public static ApplicableFunctionMember OverloadResolution(IEnumerable`1<ApplicableFunctionMember> candidates, IEnumerable`1<Argument> A);
    public static IEnumerable`1<ApplicableFunctionMember> GetApplicableMembers(Type type, TypeOrGeneric M, IEnumerable`1<Argument> A);
    public static Nullable`1<bool> ImpRefConv(object value, Type from, Type to);
    public static bool CrawlThatShit(int target, Type current, List`1<int> visitedTypes);
    public static bool IsNullableType(Type t);
    public static bool IsBoxingConversion(Type from, Type to);
    public static List`1<MethodInfo> GetCandidateMembers(Type type, string membername);
    public static List`1<MethodInfo> GetMethodInfos(Type env, string memberName);
}
public class ExpressionEvaluator.Parser.NullLiteralType : object {
}
public class ExpressionEvaluator.Parser.ParameterList : object {
    private List`1<ParameterExpression> _parameters;
    private Dictionary`2<string, ParameterExpression> ParameterLookup { get; }
    public void Add(ParameterExpression parameter);
    public void Add(List`1<ParameterExpression> list);
    private Dictionary`2<string, ParameterExpression> get_ParameterLookup();
    public bool TryGetValue(string name, ParameterExpression& parameter);
    public void Remove(List`1<ParameterExpression> list);
}
internal class ExpressionEvaluator.Parser.TypeConversion : object {
    private static Dictionary`2<Type, List`1<Type>> ImplicitNumericConversions;
    private Dictionary`2<Type, int> _typePrecedence;
    private static TypeConversion Instance;
    private static TypeConversion();
    internal static void Convert(Expression& le, Expression& re);
    internal static Expression Convert(Expression le, Type type);
    internal static int CanConvert(Type from, Type to);
    public static bool ReferenceConversion(Expression& src, Type destType);
    public static bool BoxingConversion(Expression& src, Type destType);
    public static bool NullableConverion(Expression& src, Type destType);
    public static bool NullLiteralConverion(Expression& src, Type destType);
    public static Expression EnumConversion(Expression& src);
    public static bool ImplicitConversion(Expression& src, Type destType);
    public static bool ImplicitConstantConversion(Expression& src, Type destType);
    public static Type GetBaseCommonType(IEnumerable`1<Expression> expressions);
    public static bool DynamicConversion(Expression& src, Type destType);
    public static bool ImplicitNumericConversion(Expression& src, Type target);
}
[ExtensionAttribute]
internal static class ExpressionEvaluator.Parser.TypeExtensions : object {
    private static List`1<Type> NumericTypes;
    private static TypeExtensions();
    [ExtensionAttribute]
public static bool IsNumericType(Type type);
    [ExtensionAttribute]
public static bool IsDynamicOrObject(Type type);
    [ExtensionAttribute]
public static bool IsDelegate(Type t);
    [ExtensionAttribute]
public static bool IsReferenceType(Type T);
    [ExtensionAttribute]
public static bool IsDerivedFrom(Type T, Type superClass);
    [ExtensionAttribute]
public static bool Implements(Type T, Type interfaceType);
    [ExtensionAttribute]
public static bool IsDynamic(Type type);
    [ExtensionAttribute]
public static bool IsObject(Type type);
    [ExtensionAttribute]
public static bool IsNullable(Type type);
}
public class ExpressionEvaluator.Parser.TypeInferrence : object {
    [CompilerGeneratedAttribute]
private Argument <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <UnfixedBounds>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <FixedType>k__BackingField;
    public Argument Argument { get; public set; }
    public ParameterInfo Parameter { get; public set; }
    public Type[] UnfixedBounds { get; public set; }
    public Type FixedType { get; public set; }
    [CompilerGeneratedAttribute]
public Argument get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(Argument value);
    [CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(ParameterInfo value);
    [CompilerGeneratedAttribute]
public Type[] get_UnfixedBounds();
    [CompilerGeneratedAttribute]
public void set_UnfixedBounds(Type[] value);
    [CompilerGeneratedAttribute]
public Type get_FixedType();
    [CompilerGeneratedAttribute]
public void set_FixedType(Type value);
}
public class ExpressionEvaluator.Parser.TypeParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <LowerBounds>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <Unfixed>k__BackingField;
    public string Name { get; public set; }
    public List`1<Type> LowerBounds { get; public set; }
    public List`1<Type> Unfixed { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_LowerBounds();
    [CompilerGeneratedAttribute]
public void set_LowerBounds(List`1<Type> value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_Unfixed();
    [CompilerGeneratedAttribute]
public void set_Unfixed(List`1<Type> value);
}
internal class ExpressionEvaluator.Parser.UnknownMethodException : Exception {
}
public class ExpressionEvaluator.TypeRegistry : Dictionary`2<string, object> {
    public void RegisterDefaultTypes();
    public void RegisterType();
    public void RegisterType(string alias);
    public void RegisterType(string alias, Type t);
    public void RegisterSymbol(string identifier, object value);
    public void RegisterParameter(string identifier, Func`1<object> valueGetter);
    public void RegisterParameter(string identifier, Func`1<T> valueGetter);
    public void RegisterSymbol(string identifier, object value, Type type);
}
public class ExpressionEvaluator.ValueType : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Type Type { get; public set; }
    public object Value { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
