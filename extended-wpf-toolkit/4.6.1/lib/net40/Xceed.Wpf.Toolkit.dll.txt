internal static class _XceedVersionInfo : object {
    public static string BaseVersion;
    public static string Version;
    public static string PublicKeyToken;
}
internal static class _XceedVersionInfoCommon : object {
    public static string Build;
}
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
public class XamlGeneratedNamespace.GeneratedInternalTypeHelper : InternalTypeHelper {
    protected virtual object CreateInstance(Type type, CultureInfo culture);
    protected virtual object GetPropertyValue(PropertyInfo propertyInfo, object target, CultureInfo culture);
    protected virtual void SetPropertyValue(PropertyInfo propertyInfo, object target, object value, CultureInfo culture);
    protected virtual Delegate CreateDelegate(Type delegateType, object target, string handler);
    protected virtual void AddEventHandler(EventInfo eventInfo, object target, Delegate handler);
}
internal class Xceed.Utils.Exceptions.ThrowException : object {
    public static void ThrowArgumentException(string message, string paramName, Exception innerExcept);
    public static void ThrowArgumentOutOfRangeException(string paramName, object value, string message);
    public static void ThrowLicenseException(Type type, object instance, string message);
}
[FlagsAttribute]
public enum Xceed.Wpf.Toolkit.AllowedSpecialValues : Enum {
    public int value__;
    public static AllowedSpecialValues None;
    public static AllowedSpecialValues NaN;
    public static AllowedSpecialValues PositiveInfinity;
    public static AllowedSpecialValues NegativeInfinity;
    public static AllowedSpecialValues AnyInfinity;
    public static AllowedSpecialValues Any;
}
public class Xceed.Wpf.Toolkit.AutoCompletingMaskEventArgs : CancelEventArgs {
    private MaskedTextProvider m_maskedTextProvider;
    private int m_startPosition;
    private int m_selectionLength;
    private string m_input;
    private int m_autoCompleteStartPosition;
    private string m_autoCompleteText;
    public MaskedTextProvider MaskedTextProvider { get; }
    public int StartPosition { get; }
    public int SelectionLength { get; }
    public string Input { get; }
    public int AutoCompleteStartPosition { get; public set; }
    public string AutoCompleteText { get; public set; }
    public AutoCompletingMaskEventArgs(MaskedTextProvider maskedTextProvider, int startPosition, int selectionLength, string input);
    public MaskedTextProvider get_MaskedTextProvider();
    public int get_StartPosition();
    public int get_SelectionLength();
    public string get_Input();
    public int get_AutoCompleteStartPosition();
    public void set_AutoCompleteStartPosition(int value);
    public string get_AutoCompleteText();
    public void set_AutoCompleteText(string value);
}
public enum Xceed.Wpf.Toolkit.AutoSelectBehavior : Enum {
    public int value__;
    public static AutoSelectBehavior Never;
    public static AutoSelectBehavior OnFocus;
}
public class Xceed.Wpf.Toolkit.AutoSelectTextBox : TextBox {
    public static DependencyProperty AutoSelectBehaviorProperty;
    public static DependencyProperty AutoMoveFocusProperty;
    public static RoutedEvent QueryMoveFocusEvent;
    public AutoSelectBehavior AutoSelectBehavior { get; public set; }
    public bool AutoMoveFocus { get; public set; }
    private static AutoSelectTextBox();
    public AutoSelectBehavior get_AutoSelectBehavior();
    public void set_AutoSelectBehavior(AutoSelectBehavior value);
    public bool get_AutoMoveFocus();
    public void set_AutoMoveFocus(bool value);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnTextChanged(TextChangedEventArgs e);
    private bool CanMoveFocus(FocusNavigationDirection direction, bool reachedMax);
    private bool MoveFocusLeft();
    private bool MoveFocusRight();
    private bool MoveFocusUp();
    private bool MoveFocusDown();
}
[TemplateVisualStateAttribute]
[TemplateVisualStateAttribute]
[TemplateVisualStateAttribute]
[TemplateVisualStateAttribute]
[StyleTypedPropertyAttribute]
[StyleTypedPropertyAttribute]
public class Xceed.Wpf.Toolkit.BusyIndicator : ContentControl {
    private DispatcherTimer _displayAfterTimer;
    [CompilerGeneratedAttribute]
private bool <IsContentVisible>k__BackingField;
    public static DependencyProperty IsBusyProperty;
    public static DependencyProperty BusyContentProperty;
    public static DependencyProperty BusyContentTemplateProperty;
    public static DependencyProperty DisplayAfterProperty;
    public static DependencyProperty FocusAfterBusyProperty;
    public static DependencyProperty OverlayStyleProperty;
    public static DependencyProperty ProgressBarStyleProperty;
    protected bool IsContentVisible { get; protected set; }
    public bool IsBusy { get; public set; }
    public object BusyContent { get; public set; }
    public DataTemplate BusyContentTemplate { get; public set; }
    public TimeSpan DisplayAfter { get; public set; }
    public Control FocusAfterBusy { get; public set; }
    public Style OverlayStyle { get; public set; }
    public Style ProgressBarStyle { get; public set; }
    private static BusyIndicator();
    public virtual void OnApplyTemplate();
    [CompilerGeneratedAttribute]
protected bool get_IsContentVisible();
    [CompilerGeneratedAttribute]
protected void set_IsContentVisible(bool value);
    public bool get_IsBusy();
    public void set_IsBusy(bool value);
    private static void OnIsBusyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsBusyChanged(DependencyPropertyChangedEventArgs e);
    public object get_BusyContent();
    public void set_BusyContent(object value);
    public DataTemplate get_BusyContentTemplate();
    public void set_BusyContentTemplate(DataTemplate value);
    public TimeSpan get_DisplayAfter();
    public void set_DisplayAfter(TimeSpan value);
    public Control get_FocusAfterBusy();
    public void set_FocusAfterBusy(Control value);
    public Style get_OverlayStyle();
    public void set_OverlayStyle(Style value);
    public Style get_ProgressBarStyle();
    public void set_ProgressBarStyle(Style value);
    private void DisplayAfterTimerElapsed(object sender, EventArgs e);
    protected virtual void ChangeVisualState(bool useTransitions);
    [CompilerGeneratedAttribute]
private void <OnIsBusyChanged>b__13_0();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[ContentPropertyAttribute("Content")]
public class Xceed.Wpf.Toolkit.ButtonSpinner : Spinner {
    private static string PART_IncreaseButton;
    private static string PART_DecreaseButton;
    public static DependencyProperty AllowSpinProperty;
    [ObsoleteAttribute("ButtonSpinnerLocation is obsolete. Use SpinnerLocation instead.")]
public static DependencyProperty ButtonSpinnerLocationProperty;
    public static DependencyProperty SpinnerLocationProperty;
    public static DependencyProperty SpinnerWidthProperty;
    public static DependencyProperty SpinnerHeightProperty;
    public static DependencyProperty SpinnerDownContentTemplateProperty;
    public static DependencyProperty SpinnerDownDisabledContentTemplateProperty;
    public static DependencyProperty SpinnerUpContentTemplateProperty;
    public static DependencyProperty SpinnerUpDisabledContentTemplateProperty;
    public static DependencyProperty ContentProperty;
    [ObsoleteAttribute("ShowButtonSpinner is obsolete. Use ShowSpinner instead.")]
public static DependencyProperty ShowButtonSpinnerProperty;
    public static DependencyProperty ShowSpinnerProperty;
    private ButtonBase _decreaseButton;
    private ButtonBase _increaseButton;
    public bool AllowSpin { get; public set; }
    [ObsoleteAttribute("ButtonSpinnerLocation is obsolete. Use SpinnerLocation instead.")]
public Location ButtonSpinnerLocation { get; public set; }
    public Location SpinnerLocation { get; public set; }
    public double SpinnerWidth { get; public set; }
    public double SpinnerHeight { get; public set; }
    public DataTemplate SpinnerDownContentTemplate { get; public set; }
    public DataTemplate SpinnerDownDisabledContentTemplate { get; public set; }
    public DataTemplate SpinnerUpContentTemplate { get; public set; }
    public DataTemplate SpinnerUpDisabledContentTemplate { get; public set; }
    public object Content { get; public set; }
    [ObsoleteAttribute("ShowButtonSpinner is obsolete. Use ShowSpinner instead.")]
public bool ShowButtonSpinner { get; public set; }
    public bool ShowSpinner { get; public set; }
    private ButtonBase DecreaseButton { get; private set; }
    private ButtonBase IncreaseButton { get; private set; }
    private static ButtonSpinner();
    public bool get_AllowSpin();
    public void set_AllowSpin(bool value);
    private static void AllowSpinPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Location get_ButtonSpinnerLocation();
    public void set_ButtonSpinnerLocation(Location value);
    public Location get_SpinnerLocation();
    public void set_SpinnerLocation(Location value);
    public double get_SpinnerWidth();
    public void set_SpinnerWidth(double value);
    public double get_SpinnerHeight();
    public void set_SpinnerHeight(double value);
    public DataTemplate get_SpinnerDownContentTemplate();
    public void set_SpinnerDownContentTemplate(DataTemplate value);
    public DataTemplate get_SpinnerDownDisabledContentTemplate();
    public void set_SpinnerDownDisabledContentTemplate(DataTemplate value);
    public DataTemplate get_SpinnerUpContentTemplate();
    public void set_SpinnerUpContentTemplate(DataTemplate value);
    public DataTemplate get_SpinnerUpDisabledContentTemplate();
    public void set_SpinnerUpDisabledContentTemplate(DataTemplate value);
    public object get_Content();
    public void set_Content(object value);
    private static void OnContentPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_ShowButtonSpinner();
    public void set_ShowButtonSpinner(bool value);
    public bool get_ShowSpinner();
    public void set_ShowSpinner(bool value);
    private ButtonBase get_DecreaseButton();
    private void set_DecreaseButton(ButtonBase value);
    private ButtonBase get_IncreaseButton();
    private void set_IncreaseButton(ButtonBase value);
    public virtual void OnApplyTemplate();
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnValidSpinDirectionChanged(ValidSpinDirections oldValue, ValidSpinDirections newValue);
    private void OnButtonClick(object sender, RoutedEventArgs e);
    protected virtual void OnContentChanged(object oldValue, object newValue);
    protected virtual void OnAllowSpinChanged(bool oldValue, bool newValue);
    private void SetButtonUsage();
}
public class Xceed.Wpf.Toolkit.ByteUpDown : CommonNumericUpDown`1<byte> {
    private static ByteUpDown();
    protected virtual byte IncrementValue(byte value, byte increment);
    protected virtual byte DecrementValue(byte value, byte increment);
}
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.Calculator : Control {
    private static string PART_CalculatorButtonPanel;
    private ContentControl _buttonPanel;
    private bool _showNewNumber;
    private decimal _previousValue;
    private Operation _lastOperation;
    private Dictionary`2<Button, DispatcherTimer> _timers;
    public static DependencyProperty CalculatorButtonPanelTemplateProperty;
    public static DependencyProperty CalculatorButtonTypeProperty;
    public static DependencyProperty DisplayTextProperty;
    public static DependencyProperty MemoryProperty;
    public static DependencyProperty PrecisionProperty;
    public static DependencyProperty ValueProperty;
    public static RoutedEvent ValueChangedEvent;
    public ControlTemplate CalculatorButtonPanelTemplate { get; public set; }
    public string DisplayText { get; public set; }
    public decimal Memory { get; public set; }
    public int Precision { get; public set; }
    public Nullable`1<decimal> Value { get; public set; }
    private static Calculator();
    public ControlTemplate get_CalculatorButtonPanelTemplate();
    public void set_CalculatorButtonPanelTemplate(ControlTemplate value);
    public static CalculatorButtonType GetCalculatorButtonType(DependencyObject target);
    public static void SetCalculatorButtonType(DependencyObject target, CalculatorButtonType value);
    private static void OnCalculatorButtonTypeChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    private static void OnCalculatorButtonTypeChanged(DependencyObject o, CalculatorButtonType oldValue, CalculatorButtonType newValue);
    public string get_DisplayText();
    public void set_DisplayText(string value);
    private static void OnDisplayTextChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDisplayTextChanged(string oldValue, string newValue);
    public decimal get_Memory();
    public void set_Memory(decimal value);
    public int get_Precision();
    public void set_Precision(int value);
    public Nullable`1<decimal> get_Value();
    public void set_Value(Nullable`1<decimal> value);
    private static void OnValueChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnValueChanged(Nullable`1<decimal> oldValue, Nullable`1<decimal> newValue);
    public virtual void OnApplyTemplate();
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    private void Calculator_OnMouseDown(object sender, MouseButtonEventArgs e);
    private void Timer_Tick(object sender, EventArgs e);
    internal void InitializeToValue(Nullable`1<decimal> value);
    private void Calculate();
    private void SetDisplayText(Nullable`1<decimal> newValue);
    private void Calculate(Operation newOperation);
    private void Calculate(Operation currentOperation, Operation newOperation);
    private decimal CalculateValue(Operation operation);
    private void ProcessBackKey();
    private void ProcessCalculatorButton(CalculatorButtonType buttonType);
    private void ProcessDigitKey(CalculatorButtonType buttonType);
    private void ProcessMemoryKey(CalculatorButtonType buttonType);
    private void ProcessOperationKey(CalculatorButtonType buttonType);
    private void SimulateCalculatorButtonClick(CalculatorButtonType buttonType);
    public void add_ValueChanged(RoutedPropertyChangedEventHandler`1<object> value);
    public void remove_ValueChanged(RoutedPropertyChangedEventHandler`1<object> value);
    private void ExecuteCalculatorButtonClick(object sender, ExecutedRoutedEventArgs e);
}
public static class Xceed.Wpf.Toolkit.CalculatorCommands : object {
    private static RoutedCommand _calculatorButtonClickCommand;
    public static RoutedCommand CalculatorButtonClick { get; }
    private static CalculatorCommands();
    public static RoutedCommand get_CalculatorButtonClick();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.CalculatorUpDown : DecimalUpDown {
    private static string PART_CalculatorPopup;
    private static string PART_Calculator;
    private Popup _calculatorPopup;
    private Calculator _calculator;
    private Nullable`1<decimal> _initialValue;
    public static DependencyProperty DisplayTextProperty;
    public static DependencyProperty DropDownButtonContentProperty;
    public static DependencyProperty DropDownButtonDisabledContentProperty;
    public static DependencyProperty DropDownButtonHeightProperty;
    public static DependencyProperty DropDownButtonWidthProperty;
    public static DependencyProperty EnterClosesCalculatorProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty MemoryProperty;
    public static DependencyProperty PrecisionProperty;
    public string DisplayText { get; public set; }
    public object DropDownButtonContent { get; public set; }
    public object DropDownButtonDisabledContent { get; public set; }
    public double DropDownButtonHeight { get; public set; }
    public double DropDownButtonWidth { get; public set; }
    public bool EnterClosesCalculator { get; public set; }
    public bool IsOpen { get; public set; }
    public decimal Memory { get; public set; }
    public int Precision { get; public set; }
    private static CalculatorUpDown();
    public string get_DisplayText();
    public void set_DisplayText(string value);
    public object get_DropDownButtonContent();
    public void set_DropDownButtonContent(object value);
    public object get_DropDownButtonDisabledContent();
    public void set_DropDownButtonDisabledContent(object value);
    public double get_DropDownButtonHeight();
    public void set_DropDownButtonHeight(double value);
    public double get_DropDownButtonWidth();
    public void set_DropDownButtonWidth(double value);
    public bool get_EnterClosesCalculator();
    public void set_EnterClosesCalculator(bool value);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    private static void OnIsOpenChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsOpenChanged(bool oldValue, bool newValue);
    public decimal get_Memory();
    public void set_Memory(decimal value);
    public int get_Precision();
    public void set_Precision(int value);
    public virtual void OnApplyTemplate();
    private void OnCalculatorValueChanged(object sender, RoutedPropertyChangedEventArgs`1<object> e);
    private void CalculatorPopup_Opened(object sender, EventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    private void OnKeyDown(object sender, KeyEventArgs e);
    private void OnMouseDownOutsideCapturedElement(object sender, MouseButtonEventArgs e);
    private void CloseCalculatorUpDown(bool isFocusOnTextBox);
}
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.CheckComboBox : SelectAllSelector {
    private static string PART_Popup;
    private ValueChangeHelper _displayMemberPathValuesChangeHelper;
    private bool _ignoreTextValueChanged;
    private Popup _popup;
    private List`1<object> _initialValue;
    public static DependencyProperty IsEditableProperty;
    public static DependencyProperty TextProperty;
    public static DependencyProperty IsDropDownOpenProperty;
    public static DependencyProperty MaxDropDownHeightProperty;
    public static RoutedEvent ClosedEvent;
    public static RoutedEvent OpenedEvent;
    public bool IsEditable { get; public set; }
    public string Text { get; public set; }
    public bool IsDropDownOpen { get; public set; }
    public double MaxDropDownHeight { get; public set; }
    private static CheckComboBox();
    public bool get_IsEditable();
    public void set_IsEditable(bool value);
    public string get_Text();
    public void set_Text(string value);
    private static void OnTextChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTextChanged(string oldValue, string newValue);
    public bool get_IsDropDownOpen();
    public void set_IsDropDownOpen(bool value);
    private static void OnIsDropDownOpenChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsDropDownOpenChanged(bool oldValue, bool newValue);
    public double get_MaxDropDownHeight();
    public void set_MaxDropDownHeight(double value);
    private static void OnMaxDropDownHeightChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMaxDropDownHeightChanged(double oldValue, double newValue);
    protected virtual void OnSelectedValueChanged(string oldValue, string newValue);
    protected virtual void OnDisplayMemberPathChanged(string oldDisplayMemberPath, string newDisplayMemberPath);
    protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue);
    protected virtual void OnIsAllItemsSelectedContentActiveChanged(bool oldValue, bool newValue);
    public virtual void OnApplyTemplate();
    private void OnMouseDownOutsideCapturedElement(object sender, MouseButtonEventArgs e);
    private void OnKeyDown(object sender, KeyEventArgs e);
    private void Popup_Opened(object sender, EventArgs e);
    public void add_Closed(RoutedEventHandler value);
    public void remove_Closed(RoutedEventHandler value);
    public void add_Opened(RoutedEventHandler value);
    public void remove_Opened(RoutedEventHandler value);
    protected virtual void UpdateText();
    private void UpdateDisplayMemberPathValuesBindings();
    private void OnDisplayMemberPathValuesChanged();
    private void UpdateFromText();
    protected object GetItemDisplayValue(object item);
    private void CloseDropDown(bool isFocusOnComboBox);
    [CompilerGeneratedAttribute]
private object <UpdateText>b__45_0(object x);
}
public class Xceed.Wpf.Toolkit.CheckListBox : SelectAllSelector {
    private static CheckListBox();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.ChildWindow : WindowControl {
    private static string PART_WindowRoot;
    private static string PART_Root;
    private static string PART_WindowControl;
    private static int _horizontalOffset;
    private static int _verticalOffset;
    private Grid _root;
    private TranslateTransform _moveTransform;
    private bool _startupPositionInitialized;
    private FrameworkElement _parentContainer;
    private Rectangle _modalLayer;
    private Canvas _modalLayerPanel;
    private Grid _windowRoot;
    private WindowControl _windowControl;
    private bool _ignorePropertyChanged;
    private bool _hasChildren;
    private bool _hasWindowContainer;
    private Nullable`1<bool> _dialogResult;
    public static DependencyProperty DesignerWindowStateProperty;
    public static DependencyProperty FocusedElementProperty;
    public static DependencyProperty IsModalProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> IsModalChanged;
    [ObsoleteAttribute("This property is obsolete and should no longer be used. Use WindowContainer.ModalBackgroundBrushProperty instead.")]
public static DependencyProperty OverlayBrushProperty;
    [ObsoleteAttribute("This property is obsolete and should no longer be used. Use WindowContainer.ModalBackgroundBrushProperty instead.")]
public static DependencyProperty OverlayOpacityProperty;
    public static DependencyProperty WindowStartupLocationProperty;
    public static DependencyProperty WindowStateProperty;
    [CompilerGeneratedAttribute]
private EventHandler Closed;
    [CompilerGeneratedAttribute]
private EventHandler`1<CancelEventArgs> Closing;
    [TypeConverterAttribute("System.Windows.NullableBoolConverter")]
public Nullable`1<bool> DialogResult { get; public set; }
    public WindowState DesignerWindowState { get; public set; }
    public FrameworkElement FocusedElement { get; public set; }
    public bool IsModal { get; public set; }
    [ObsoleteAttribute("This property is obsolete and should no longer be used. Use WindowContainer.ModalBackgroundBrushProperty instead.")]
public Brush OverlayBrush { get; public set; }
    [ObsoleteAttribute("This property is obsolete and should no longer be used. Use WindowContainer.ModalBackgroundBrushProperty instead.")]
public double OverlayOpacity { get; public set; }
    public WindowStartupLocation WindowStartupLocation { get; public set; }
    public WindowState WindowState { get; public set; }
    internal bool AllowPublicIsActiveChange { get; }
    private static ChildWindow();
    public Nullable`1<bool> get_DialogResult();
    public void set_DialogResult(Nullable`1<bool> value);
    public WindowState get_DesignerWindowState();
    public void set_DesignerWindowState(WindowState value);
    private static void OnDesignerWindowStatePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDesignerWindowStatePropertyChanged(WindowState oldValue, WindowState newValue);
    public FrameworkElement get_FocusedElement();
    public void set_FocusedElement(FrameworkElement value);
    public bool get_IsModal();
    public void set_IsModal(bool value);
    private static void OnIsModalPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_IsModalChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_IsModalChanged(EventHandler`1<EventArgs> value);
    private void OnIsModalChanged(bool oldValue, bool newValue);
    public Brush get_OverlayBrush();
    public void set_OverlayBrush(Brush value);
    private static void OnOverlayBrushChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [ObsoleteAttribute("This method is obsolete and should no longer be used. Use WindowContainer.ModalBackgroundBrushProperty instead.")]
protected virtual void OnOverlayBrushChanged(Brush oldValue, Brush newValue);
    public double get_OverlayOpacity();
    public void set_OverlayOpacity(double value);
    private static void OnOverlayOpacityChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [ObsoleteAttribute("This method is obsolete and should no longer be used. Use WindowContainer.ModalBackgroundBrushProperty instead.")]
protected virtual void OnOverlayOpacityChanged(double oldValue, double newValue);
    public WindowStartupLocation get_WindowStartupLocation();
    public void set_WindowStartupLocation(WindowStartupLocation value);
    private static void OnWindowStartupLocationChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnWindowStartupLocationChanged(WindowStartupLocation oldValue, WindowStartupLocation newValue);
    public WindowState get_WindowState();
    public void set_WindowState(WindowState value);
    private static void OnWindowStatePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnWindowStatePropertyChanged(WindowState oldValue, WindowState newValue);
    internal virtual bool get_AllowPublicIsActiveChange();
    public virtual void OnApplyTemplate();
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnLeftPropertyChanged(double oldValue, double newValue);
    protected virtual void OnTopPropertyChanged(double oldValue, double newValue);
    internal virtual void UpdateBlockMouseInputsPanel();
    protected virtual void OnHeaderDragDelta(DragDeltaEventArgs e);
    protected virtual void OnHeaderIconDoubleClick(MouseButtonEventArgs e);
    protected virtual void OnCloseButtonClicked(RoutedEventArgs e);
    [ObsoleteAttribute("This method is obsolete and should no longer be used.")]
private void ParentContainer_LayoutUpdated(object sender, EventArgs e);
    [ObsoleteAttribute("This method is obsolete and should no longer be used.")]
private void ChildWindow_Unloaded(object sender, RoutedEventArgs e);
    [ObsoleteAttribute("This method is obsolete and should no longer be used.")]
private void ParentContainer_SizeChanged(object sender, SizeChangedEventArgs e);
    private void ChildWindow_IsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    [ObsoleteAttribute("This method is obsolete and should no longer be used. Use WindowContainer.GetRestrictedLeft() instead.")]
private double GetRestrictedLeft();
    [ObsoleteAttribute("This method is obsolete and should no longer be used. Use WindowContainer.GetRestrictedTop() instead.")]
private double GetRestrictedTop();
    private void SetWindowState(WindowState state);
    private void ExecuteClose();
    private void CancelClose();
    private void ExecuteOpen();
    private bool IsCurrentWindow(object windowtoTest);
    [ObsoleteAttribute("This method is obsolete and should no longer be used. Use WindowContainer.BringToFront() instead.")]
private void BringToFront();
    [ObsoleteAttribute("This method is obsolete and should no longer be used. Use WindowContainer.CenterChild() instead.")]
private void CenterChildWindow();
    [ObsoleteAttribute("This method is obsolete and should no longer be used.")]
private void ShowModalLayer();
    [ObsoleteAttribute("This method is obsolete and should no longer be used.")]
private void HideModalLayer();
    [ObsoleteAttribute("This method is obsolete and should no longer be used. Use the ChildWindow in a WindowContainer instead.")]
private void ProcessMove(double x, double y);
    public void Show();
    public void Close();
    [CompilerGeneratedAttribute]
public void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Closed(EventHandler value);
    protected virtual void OnClosed(EventArgs e);
    [CompilerGeneratedAttribute]
public void add_Closing(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Closing(EventHandler`1<CancelEventArgs> value);
    protected virtual void OnClosing(CancelEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__67_0(object o, DragDeltaEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__67_1(object o, MouseButtonEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__67_2(object o, RoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__67_3(object o, DragDeltaEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__67_4(object o, MouseButtonEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__67_5(object o, RoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__67_6(object o, RoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnGotFocus>b__68_0();
    [CompilerGeneratedAttribute]
private void <ChildWindow_Unloaded>b__78_0(object o, RoutedEventArgs ev);
}
public class Xceed.Wpf.Toolkit.Chromes.ButtonChrome : ContentControl {
    public static DependencyProperty CornerRadiusProperty;
    public static DependencyProperty InnerCornerRadiusProperty;
    public static DependencyProperty RenderCheckedProperty;
    public static DependencyProperty RenderEnabledProperty;
    public static DependencyProperty RenderFocusedProperty;
    public static DependencyProperty RenderMouseOverProperty;
    public static DependencyProperty RenderNormalProperty;
    public static DependencyProperty RenderPressedProperty;
    public CornerRadius CornerRadius { get; public set; }
    public CornerRadius InnerCornerRadius { get; public set; }
    public bool RenderChecked { get; public set; }
    public bool RenderEnabled { get; public set; }
    public bool RenderFocused { get; public set; }
    public bool RenderMouseOver { get; public set; }
    public bool RenderNormal { get; public set; }
    public bool RenderPressed { get; public set; }
    private static ButtonChrome();
    public CornerRadius get_CornerRadius();
    public void set_CornerRadius(CornerRadius value);
    private static void OnCornerRadiusChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCornerRadiusChanged(CornerRadius oldValue, CornerRadius newValue);
    public CornerRadius get_InnerCornerRadius();
    public void set_InnerCornerRadius(CornerRadius value);
    private static void OnInnerCornerRadiusChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnInnerCornerRadiusChanged(CornerRadius oldValue, CornerRadius newValue);
    public bool get_RenderChecked();
    public void set_RenderChecked(bool value);
    private static void OnRenderCheckedChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnRenderCheckedChanged(bool oldValue, bool newValue);
    public bool get_RenderEnabled();
    public void set_RenderEnabled(bool value);
    private static void OnRenderEnabledChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnRenderEnabledChanged(bool oldValue, bool newValue);
    public bool get_RenderFocused();
    public void set_RenderFocused(bool value);
    private static void OnRenderFocusedChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnRenderFocusedChanged(bool oldValue, bool newValue);
    public bool get_RenderMouseOver();
    public void set_RenderMouseOver(bool value);
    private static void OnRenderMouseOverChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnRenderMouseOverChanged(bool oldValue, bool newValue);
    public bool get_RenderNormal();
    public void set_RenderNormal(bool value);
    private static void OnRenderNormalChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnRenderNormalChanged(bool oldValue, bool newValue);
    public bool get_RenderPressed();
    public void set_RenderPressed(bool value);
    private static void OnRenderPressedChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnRenderPressedChanged(bool oldValue, bool newValue);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.CollectionControl : Control {
    private static string PART_NewItemTypesComboBox;
    private static string PART_PropertyGrid;
    private static string PART_ListBox;
    private ComboBox _newItemTypesComboBox;
    private PropertyGrid _propertyGrid;
    private ListBox _listBox;
    private bool _isCollectionUpdated;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty ItemsProperty;
    public static DependencyProperty ItemsSourceProperty;
    public static DependencyProperty ItemsSourceTypeProperty;
    public static DependencyProperty NewItemTypesProperty;
    public static DependencyProperty PropertiesLabelProperty;
    public static DependencyProperty SelectedItemProperty;
    public static DependencyProperty TypeSelectionLabelProperty;
    public static DependencyProperty EditorDefinitionsProperty;
    public static RoutedEvent ItemDeletingEvent;
    public static RoutedEvent ItemDeletedEvent;
    public static RoutedEvent ItemAddingEvent;
    public static RoutedEvent ItemAddedEvent;
    public static RoutedEvent ItemMovedDownEvent;
    public static RoutedEvent ItemMovedUpEvent;
    public bool IsReadOnly { get; public set; }
    public ObservableCollection`1<object> Items { get; public set; }
    public IEnumerable ItemsSource { get; public set; }
    public Type ItemsSourceType { get; public set; }
    public IList`1<Type> NewItemTypes { get; public set; }
    public object PropertiesLabel { get; public set; }
    public object SelectedItem { get; public set; }
    public object TypeSelectionLabel { get; public set; }
    public EditorDefinitionCollection EditorDefinitions { get; public set; }
    public PropertyGrid PropertyGrid { get; }
    private static CollectionControl();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public ObservableCollection`1<object> get_Items();
    public void set_Items(ObservableCollection`1<object> value);
    public IEnumerable get_ItemsSource();
    public void set_ItemsSource(IEnumerable value);
    private static void OnItemsSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void OnItemSourceChanged(IEnumerable oldValue, IEnumerable newValue);
    public Type get_ItemsSourceType();
    public void set_ItemsSourceType(Type value);
    public IList`1<Type> get_NewItemTypes();
    public void set_NewItemTypes(IList`1<Type> value);
    public object get_PropertiesLabel();
    public void set_PropertiesLabel(object value);
    public object get_SelectedItem();
    public void set_SelectedItem(object value);
    public object get_TypeSelectionLabel();
    public void set_TypeSelectionLabel(object value);
    public EditorDefinitionCollection get_EditorDefinitions();
    public void set_EditorDefinitions(EditorDefinitionCollection value);
    public virtual void OnApplyTemplate();
    public PropertyGrid get_PropertyGrid();
    public void add_ItemDeleting(ItemDeletingRoutedEventHandler value);
    public void remove_ItemDeleting(ItemDeletingRoutedEventHandler value);
    public void add_ItemDeleted(ItemDeletedRoutedEventHandler value);
    public void remove_ItemDeleted(ItemDeletedRoutedEventHandler value);
    public void add_ItemAdding(ItemAddingRoutedEventHandler value);
    public void remove_ItemAdding(ItemAddingRoutedEventHandler value);
    public void add_ItemAdded(ItemAddedRoutedEventHandler value);
    public void remove_ItemAdded(ItemAddedRoutedEventHandler value);
    public void add_ItemMovedDown(ItemMovedDownRoutedEventHandler value);
    public void remove_ItemMovedDown(ItemMovedDownRoutedEventHandler value);
    public void add_ItemMovedUp(ItemMovedUpRoutedEventHandler value);
    public void remove_ItemMovedUp(ItemMovedUpRoutedEventHandler value);
    private void NewItemTypesComboBox_Loaded(object sender, RoutedEventArgs e);
    private void PropertyGrid_PropertyValueChanged(object sender, PropertyValueChangedEventArgs e);
    private void AddNew(object sender, ExecutedRoutedEventArgs e);
    private void CanAddNew(object sender, CanExecuteRoutedEventArgs e);
    private void CanAddNewCore(Type t, CanExecuteRoutedEventArgs e);
    private void AddNewCore(object newItem);
    private void Delete(object sender, ExecutedRoutedEventArgs e);
    private void CanDelete(object sender, CanExecuteRoutedEventArgs e);
    private void Duplicate(object sender, ExecutedRoutedEventArgs e);
    private void CanDuplicate(object sender, CanExecuteRoutedEventArgs e);
    private object DuplicateItem(ExecutedRoutedEventArgs e);
    private void MoveDown(object sender, ExecutedRoutedEventArgs e);
    private void CanMoveDown(object sender, CanExecuteRoutedEventArgs e);
    private void MoveUp(object sender, ExecutedRoutedEventArgs e);
    private void CanMoveUp(object sender, CanExecuteRoutedEventArgs e);
    public bool PersistChanges();
    internal void PersistChanges(IList sourceList);
    private IEnumerable CreateItemsSource();
    private object CreateNewItem(Type type);
    private IEnumerable ComputeItemsSource();
    [CompilerGeneratedAttribute]
private void <PropertyGrid_PropertyValueChanged>b__81_0();
}
public class Xceed.Wpf.Toolkit.CollectionControlButton : Button {
    public static DependencyProperty EditorDefinitionsProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty ItemsSourceProperty;
    public static DependencyProperty ItemsSourceTypeProperty;
    public static DependencyProperty NewItemTypesProperty;
    public static RoutedEvent CollectionUpdatedEvent;
    public EditorDefinitionCollection EditorDefinitions { get; public set; }
    public bool IsReadOnly { get; public set; }
    public IEnumerable ItemsSource { get; public set; }
    public Type ItemsSourceType { get; public set; }
    public IList`1<Type> NewItemTypes { get; public set; }
    private static CollectionControlButton();
    public EditorDefinitionCollection get_EditorDefinitions();
    public void set_EditorDefinitions(EditorDefinitionCollection value);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public IEnumerable get_ItemsSource();
    public void set_ItemsSource(IEnumerable value);
    public Type get_ItemsSourceType();
    public void set_ItemsSourceType(Type value);
    public IList`1<Type> get_NewItemTypes();
    public void set_NewItemTypes(IList`1<Type> value);
    private void CollectionControlButton_Click(object sender, RoutedEventArgs e);
    public void add_CollectionUpdated(RoutedEventHandler value);
    public void remove_CollectionUpdated(RoutedEventHandler value);
}
public class Xceed.Wpf.Toolkit.CollectionControlDialog : CollectionControlDialogBase {
    private IList originalData;
    public static DependencyProperty ItemsSourceProperty;
    public static DependencyProperty ItemsSourceTypeProperty;
    public static DependencyProperty NewItemTypesProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty EditorDefinitionsProperty;
    internal CollectionControl _collectionControl;
    private bool _contentLoaded;
    public IEnumerable ItemsSource { get; public set; }
    public Type ItemsSourceType { get; public set; }
    public IList`1<Type> NewItemTypes { get; public set; }
    public bool IsReadOnly { get; public set; }
    public EditorDefinitionCollection EditorDefinitions { get; public set; }
    public CollectionControl CollectionControl { get; }
    public CollectionControlDialog(Type itemsourceType);
    public CollectionControlDialog(Type itemsourceType, IList`1<Type> newItemTypes);
    private static CollectionControlDialog();
    public IEnumerable get_ItemsSource();
    public void set_ItemsSource(IEnumerable value);
    public Type get_ItemsSourceType();
    public void set_ItemsSourceType(Type value);
    public IList`1<Type> get_NewItemTypes();
    public void set_NewItemTypes(IList`1<Type> value);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public EditorDefinitionCollection get_EditorDefinitions();
    public void set_EditorDefinitions(EditorDefinitionCollection value);
    public CollectionControl get_CollectionControl();
    protected virtual void OnSourceInitialized(EventArgs e);
    private void OkButton_Click(object sender, RoutedEventArgs e);
    private void CancelButton_Click(object sender, RoutedEventArgs e);
    [SecuritySafeCriticalAttribute]
private object Clone(object source);
    private void GenerateValue(PropertyInfo propertyInfo, object propertyInfoValue, object result, bool isIndexed);
    private bool IsCyclingDependency(object propertyInfoValue);
    private object GenerateEditableKeyValuePair(object source);
    private bool AreDictionaryKeysValid();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
internal Delegate _CreateDelegate(Type delegateType, string handler);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
public class Xceed.Wpf.Toolkit.CollectionControlDialogBase : Window {
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.ColorCanvas : Control {
    private static string PART_ColorShadingCanvas;
    private static string PART_ColorShadeSelector;
    private static string PART_SpectrumSlider;
    private static string PART_HexadecimalTextBox;
    private TranslateTransform _colorShadeSelectorTransform;
    private Canvas _colorShadingCanvas;
    private Canvas _colorShadeSelector;
    private ColorSpectrumSlider _spectrumSlider;
    private TextBox _hexadecimalTextBox;
    private Nullable`1<Point> _currentColorPosition;
    private bool _surpressPropertyChanged;
    private bool _updateSpectrumSliderValue;
    public static DependencyProperty SelectedColorProperty;
    public static DependencyProperty AProperty;
    public static DependencyProperty RProperty;
    public static DependencyProperty GProperty;
    public static DependencyProperty BProperty;
    public static DependencyProperty HexadecimalStringProperty;
    public static DependencyProperty UsingAlphaChannelProperty;
    public static RoutedEvent SelectedColorChangedEvent;
    public Nullable`1<Color> SelectedColor { get; public set; }
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    public string HexadecimalString { get; public set; }
    public bool UsingAlphaChannel { get; public set; }
    private static ColorCanvas();
    public Nullable`1<Color> get_SelectedColor();
    public void set_SelectedColor(Nullable`1<Color> value);
    private static void OnSelectedColorChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectedColorChanged(Nullable`1<Color> oldValue, Nullable`1<Color> newValue);
    public byte get_A();
    public void set_A(byte value);
    private static void OnAChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAChanged(byte oldValue, byte newValue);
    public byte get_R();
    public void set_R(byte value);
    private static void OnRChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnRChanged(byte oldValue, byte newValue);
    public byte get_G();
    public void set_G(byte value);
    private static void OnGChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnGChanged(byte oldValue, byte newValue);
    public byte get_B();
    public void set_B(byte value);
    private static void OnBChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnBChanged(byte oldValue, byte newValue);
    public string get_HexadecimalString();
    public void set_HexadecimalString(string value);
    private static void OnHexadecimalStringChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHexadecimalStringChanged(string oldValue, string newValue);
    private static object OnCoerceHexadecimalString(DependencyObject d, object basevalue);
    private object OnCoerceHexadecimalString(object newValue);
    public bool get_UsingAlphaChannel();
    public void set_UsingAlphaChannel(bool value);
    private static void OnUsingAlphaChannelPropertyChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnUsingAlphaChannelChanged();
    public virtual void OnApplyTemplate();
    protected virtual void OnKeyDown(KeyEventArgs e);
    private void ColorShadingCanvas_MouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void ColorShadingCanvas_MouseLeftButtonUp(object sender, MouseButtonEventArgs e);
    private void ColorShadingCanvas_MouseMove(object sender, MouseEventArgs e);
    private void ColorShadingCanvas_SizeChanged(object sender, SizeChangedEventArgs e);
    private void SpectrumSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs`1<double> e);
    private void HexadecimalTextBox_LostFocus(object sender, RoutedEventArgs e);
    public void add_SelectedColorChanged(RoutedPropertyChangedEventHandler`1<Nullable`1<Color>> value);
    public void remove_SelectedColorChanged(RoutedPropertyChangedEventHandler`1<Nullable`1<Color>> value);
    private void UpdateSelectedColor();
    private void UpdateSelectedColor(Nullable`1<Color> color);
    private void UpdateRGBValues(Nullable`1<Color> color);
    private void UpdateColorShadeSelectorPositionAndCalculateColor(Point p, bool calculateColor);
    private void UpdateColorShadeSelectorPosition(Nullable`1<Color> color);
    private void CalculateColor(Point p);
    private string GetFormatedColorString(Nullable`1<Color> colorToFormat);
    private string GetFormatedColorString(string stringToFormat);
    private void SetHexadecimalStringProperty(string newValue, bool modifyFromUI);
    private void SetHexadecimalTextBoxTextProperty(string newValue);
}
public class Xceed.Wpf.Toolkit.ColorItem : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Color> <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Nullable`1<Color> Color { get; public set; }
    public string Name { get; public set; }
    public ColorItem(Nullable`1<Color> color, string name);
    [CompilerGeneratedAttribute]
public Nullable`1<Color> get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Nullable`1<Color> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Xceed.Wpf.Toolkit.ColorMode : Enum {
    public int value__;
    public static ColorMode ColorPalette;
    public static ColorMode ColorCanvas;
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.ColorPicker : Control {
    private static string PART_AvailableColors;
    private static string PART_StandardColors;
    private static string PART_RecentColors;
    private static string PART_ColorPickerToggleButton;
    private static string PART_ColorPickerPalettePopup;
    private ListBox _availableColors;
    private ListBox _standardColors;
    private ListBox _recentColors;
    private ToggleButton _toggleButton;
    private Popup _popup;
    private Nullable`1<Color> _initialColor;
    private bool _selectionChanged;
    public static DependencyProperty AdvancedTabHeaderProperty;
    public static DependencyProperty AvailableColorsProperty;
    public static DependencyProperty AvailableColorsSortingModeProperty;
    public static DependencyProperty AvailableColorsHeaderProperty;
    public static DependencyProperty ButtonStyleProperty;
    public static DependencyProperty DisplayColorAndNameProperty;
    public static DependencyProperty DisplayColorTooltipProperty;
    public static DependencyProperty ColorModeProperty;
    public static DependencyProperty DropDownBackgroundProperty;
    public static DependencyProperty DropDownBorderBrushProperty;
    public static DependencyProperty DropDownBorderThicknessProperty;
    public static DependencyProperty HeaderBackgroundProperty;
    public static DependencyProperty HeaderForegroundProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty MaxDropDownWidthProperty;
    public static DependencyProperty RecentColorsProperty;
    public static DependencyProperty RecentColorsHeaderProperty;
    public static DependencyProperty SelectedColorProperty;
    public static DependencyProperty SelectedColorTextProperty;
    public static DependencyProperty ShowTabHeadersProperty;
    public static DependencyProperty ShowAvailableColorsProperty;
    public static DependencyProperty ShowRecentColorsProperty;
    public static DependencyProperty ShowStandardColorsProperty;
    public static DependencyProperty ShowDropDownButtonProperty;
    public static DependencyProperty StandardTabHeaderProperty;
    public static DependencyProperty StandardColorsProperty;
    public static DependencyProperty StandardColorsHeaderProperty;
    public static DependencyProperty TabBackgroundProperty;
    public static DependencyProperty TabForegroundProperty;
    public static DependencyProperty UsingAlphaChannelProperty;
    public static RoutedEvent SelectedColorChangedEvent;
    public static RoutedEvent OpenedEvent;
    public static RoutedEvent ClosedEvent;
    public string AdvancedTabHeader { get; public set; }
    public ObservableCollection`1<ColorItem> AvailableColors { get; public set; }
    public ColorSortingMode AvailableColorsSortingMode { get; public set; }
    public string AvailableColorsHeader { get; public set; }
    public Style ButtonStyle { get; public set; }
    public bool DisplayColorAndName { get; public set; }
    public bool DisplayColorTooltip { get; public set; }
    public ColorMode ColorMode { get; public set; }
    public Brush DropDownBackground { get; public set; }
    public Brush DropDownBorderBrush { get; public set; }
    public Thickness DropDownBorderThickness { get; public set; }
    public Brush HeaderBackground { get; public set; }
    public Brush HeaderForeground { get; public set; }
    public bool IsOpen { get; public set; }
    public double MaxDropDownWidth { get; public set; }
    public ObservableCollection`1<ColorItem> RecentColors { get; public set; }
    public string RecentColorsHeader { get; public set; }
    public Nullable`1<Color> SelectedColor { get; public set; }
    public string SelectedColorText { get; protected set; }
    public bool ShowTabHeaders { get; public set; }
    public bool ShowAvailableColors { get; public set; }
    public bool ShowRecentColors { get; public set; }
    public bool ShowStandardColors { get; public set; }
    public bool ShowDropDownButton { get; public set; }
    public string StandardTabHeader { get; public set; }
    public ObservableCollection`1<ColorItem> StandardColors { get; public set; }
    public string StandardColorsHeader { get; public set; }
    public Brush TabBackground { get; public set; }
    public Brush TabForeground { get; public set; }
    public bool UsingAlphaChannel { get; public set; }
    private static ColorPicker();
    public string get_AdvancedTabHeader();
    public void set_AdvancedTabHeader(string value);
    public ObservableCollection`1<ColorItem> get_AvailableColors();
    public void set_AvailableColors(ObservableCollection`1<ColorItem> value);
    public ColorSortingMode get_AvailableColorsSortingMode();
    public void set_AvailableColorsSortingMode(ColorSortingMode value);
    private static void OnAvailableColorsSortingModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnAvailableColorsSortingModeChanged(ColorSortingMode oldValue, ColorSortingMode newValue);
    public string get_AvailableColorsHeader();
    public void set_AvailableColorsHeader(string value);
    public Style get_ButtonStyle();
    public void set_ButtonStyle(Style value);
    public bool get_DisplayColorAndName();
    public void set_DisplayColorAndName(bool value);
    public bool get_DisplayColorTooltip();
    public void set_DisplayColorTooltip(bool value);
    public ColorMode get_ColorMode();
    public void set_ColorMode(ColorMode value);
    public Brush get_DropDownBackground();
    public void set_DropDownBackground(Brush value);
    public Brush get_DropDownBorderBrush();
    public void set_DropDownBorderBrush(Brush value);
    public Thickness get_DropDownBorderThickness();
    public void set_DropDownBorderThickness(Thickness value);
    public Brush get_HeaderBackground();
    public void set_HeaderBackground(Brush value);
    public Brush get_HeaderForeground();
    public void set_HeaderForeground(Brush value);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    private static void OnIsOpenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnIsOpenChanged(bool oldValue, bool newValue);
    public double get_MaxDropDownWidth();
    public void set_MaxDropDownWidth(double value);
    private static void OnMaxDropDownWidthChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMaxDropDownWidthChanged(double oldValue, double newValue);
    public ObservableCollection`1<ColorItem> get_RecentColors();
    public void set_RecentColors(ObservableCollection`1<ColorItem> value);
    public string get_RecentColorsHeader();
    public void set_RecentColorsHeader(string value);
    public Nullable`1<Color> get_SelectedColor();
    public void set_SelectedColor(Nullable`1<Color> value);
    private static void OnSelectedColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnSelectedColorChanged(Nullable`1<Color> oldValue, Nullable`1<Color> newValue);
    public string get_SelectedColorText();
    protected void set_SelectedColorText(string value);
    public bool get_ShowTabHeaders();
    public void set_ShowTabHeaders(bool value);
    public bool get_ShowAvailableColors();
    public void set_ShowAvailableColors(bool value);
    public bool get_ShowRecentColors();
    public void set_ShowRecentColors(bool value);
    public bool get_ShowStandardColors();
    public void set_ShowStandardColors(bool value);
    public bool get_ShowDropDownButton();
    public void set_ShowDropDownButton(bool value);
    public string get_StandardTabHeader();
    public void set_StandardTabHeader(string value);
    public ObservableCollection`1<ColorItem> get_StandardColors();
    public void set_StandardColors(ObservableCollection`1<ColorItem> value);
    public string get_StandardColorsHeader();
    public void set_StandardColorsHeader(string value);
    public Brush get_TabBackground();
    public void set_TabBackground(Brush value);
    public Brush get_TabForeground();
    public void set_TabForeground(Brush value);
    public bool get_UsingAlphaChannel();
    public void set_UsingAlphaChannel(bool value);
    private static void OnUsingAlphaChannelPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnUsingAlphaChannelChanged();
    public virtual void OnApplyTemplate();
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    private void OnKeyDown(object sender, KeyEventArgs e);
    private void OnMouseDownOutsideCapturedElement(object sender, MouseButtonEventArgs e);
    private void Color_SelectionChanged(object sender, SelectionChangedEventArgs e);
    private void Popup_Opened(object sender, EventArgs e);
    private void FocusOnListBoxItem(ListBox listBox);
    public void add_SelectedColorChanged(RoutedPropertyChangedEventHandler`1<Nullable`1<Color>> value);
    public void remove_SelectedColorChanged(RoutedPropertyChangedEventHandler`1<Nullable`1<Color>> value);
    public void add_Opened(RoutedEventHandler value);
    public void remove_Opened(RoutedEventHandler value);
    public void add_Closed(RoutedEventHandler value);
    public void remove_Closed(RoutedEventHandler value);
    private void CloseColorPicker(bool isFocusOnColorPicker);
    private void UpdateRecentColors(ColorItem colorItem);
    private string GetFormatedColorString(Nullable`1<Color> colorToFormat);
    private static ObservableCollection`1<ColorItem> CreateStandardColors();
    private static ObservableCollection`1<ColorItem> CreateAvailableColors();
}
public class Xceed.Wpf.Toolkit.ColorPickerTabItem : TabItem {
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
}
internal class Xceed.Wpf.Toolkit.ColorSorter : object {
    public sealed virtual int Compare(object firstItem, object secondItem);
}
public enum Xceed.Wpf.Toolkit.ColorSortingMode : Enum {
    public int value__;
    public static ColorSortingMode Alphabetical;
    public static ColorSortingMode HueSaturationBrightness;
}
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.ColorSpectrumSlider : Slider {
    private static string PART_SpectrumDisplay;
    private Rectangle _spectrumDisplay;
    private LinearGradientBrush _pickerBrush;
    public static DependencyProperty SelectedColorProperty;
    public Color SelectedColor { get; public set; }
    private static ColorSpectrumSlider();
    public Color get_SelectedColor();
    public void set_SelectedColor(Color value);
    public virtual void OnApplyTemplate();
    protected virtual void OnValueChanged(double oldValue, double newValue);
    private void CreateSpectrum();
}
public abstract class Xceed.Wpf.Toolkit.CommonNumericUpDown`1 : NumericUpDown`1<Nullable`1<T>> {
    private FromText<T> _fromText;
    private FromDecimal<T> _fromDecimal;
    private Func`3<T, T, bool> _fromLowerThan;
    private Func`3<T, T, bool> _fromGreaterThan;
    internal static DependencyProperty IsInvalidProperty;
    public static DependencyProperty ParsingNumberStyleProperty;
    internal bool IsInvalid { get; private set; }
    public NumberStyles ParsingNumberStyle { get; public set; }
    protected CommonNumericUpDown`1(FromText<T> fromText, FromDecimal<T> fromDecimal, Func`3<T, T, bool> fromLowerThan, Func`3<T, T, bool> fromGreaterThan);
    private static CommonNumericUpDown`1();
    internal bool get_IsInvalid();
    private void set_IsInvalid(bool value);
    public NumberStyles get_ParsingNumberStyle();
    public void set_ParsingNumberStyle(NumberStyles value);
    protected static void UpdateMetadata(Type type, Nullable`1<T> increment, Nullable`1<T> minValue, Nullable`1<T> maxValue);
    protected void TestInputSpecialValue(AllowedSpecialValues allowedValues, AllowedSpecialValues valueToCompare);
    internal bool IsBetweenMinMax(Nullable`1<T> value);
    private static void UpdateMetadataCommon(Type type, Nullable`1<T> increment, Nullable`1<T> minValue, Nullable`1<T> maxValue);
    private bool IsLowerThan(Nullable`1<T> value1, Nullable`1<T> value2);
    private bool IsGreaterThan(Nullable`1<T> value1, Nullable`1<T> value2);
    private bool HandleNullSpin();
    private Nullable`1<T> CoerceValueMinMax(T value);
    protected virtual void OnIncrement();
    protected virtual void OnDecrement();
    protected virtual void OnMinimumChanged(Nullable`1<T> oldValue, Nullable`1<T> newValue);
    protected virtual void OnMaximumChanged(Nullable`1<T> oldValue, Nullable`1<T> newValue);
    protected virtual Nullable`1<T> ConvertTextToValue(string text);
    protected virtual string ConvertValueToText();
    protected virtual void SetValidSpinDirection();
    private bool IsPercent(string stringToTest);
    private bool CultureContainsCharacter(char c);
    private Nullable`1<T> ConvertTextToValueCore(string currentValueText, string text);
    private Nullable`1<T> GetClippedMinMaxValue(Nullable`1<T> result);
    private void ValidateDefaultMinMax(Nullable`1<T> value);
    protected abstract virtual T IncrementValue(T value, T increment);
    protected abstract virtual T DecrementValue(T value, T increment);
    [CompilerGeneratedAttribute]
private bool <ConvertTextToValueCore>b__32_2(char c);
}
public class Xceed.Wpf.Toolkit.Converters.BorderThicknessConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Converters.NewItemTypesComboBoxConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Converters.ProgressBarWidthConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
[ObsoleteAttribute("This class is no longer used internaly and may be removed in a future release")]
public class Xceed.Wpf.Toolkit.Converters.SliderThumbWidthConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Converters.StyleableWindowClippingBorderConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.CancelRoutedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private bool <Cancel>k__BackingField;
    public bool Cancel { get; public set; }
    public CancelRoutedEventArgs(RoutedEvent routedEvent);
    public CancelRoutedEventArgs(RoutedEvent routedEvent, object source);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class Xceed.Wpf.Toolkit.Core.CancelRoutedEventHandler : MulticastDelegate {
    public CancelRoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CancelRoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CancelRoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.Core.Converters.AdditionConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.BorderThicknessToStrokeThicknessConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.CalculatorMemoryToVisibilityConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.CenterTitleConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.ColorBlendConverter : object {
    private double _blendedColorRatio;
    [CompilerGeneratedAttribute]
private Color <BlendedColor>k__BackingField;
    public double BlendedColorRatio { get; public set; }
    public Color BlendedColor { get; public set; }
    public double get_BlendedColorRatio();
    public void set_BlendedColorRatio(double value);
    [CompilerGeneratedAttribute]
public Color get_BlendedColor();
    [CompilerGeneratedAttribute]
public void set_BlendedColor(Color value);
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    private byte BlendValue(byte original, byte blend);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.ColorModeToTabItemSelectedConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.ColorToSolidColorBrushConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.CornerRadiusToDoubleConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.HalfConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.IntToThicknessConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.InverseBoolConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.NotNullToBoolConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.NullToBoolConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.ObjectTypeToNameConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.PrintableFontFamilyConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.RoundedValueConverter : object {
    private int _precision;
    public int Precision { get; public set; }
    public int get_Precision();
    public void set_Precision(int value);
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.SolidColorBrushToColorConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.TabItemSizeConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.ThicknessSideRemovalConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.ThicknessToDoubleConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.VisibilityToBoolConverter : object {
    private bool _inverted;
    private bool _not;
    public bool Inverted { get; public set; }
    public bool Not { get; public set; }
    public bool get_Inverted();
    public void set_Inverted(bool value);
    public bool get_Not();
    public void set_Not(bool value);
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
    private object VisibilityToBool(object value);
    private object BoolToVisibility(object value);
}
public class Xceed.Wpf.Toolkit.Core.Converters.WindowContentBorderMarginConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.WindowControlBackgroundConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.Converters.WizardPageButtonVisibilityConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.Core.EditableKeyValuePair`2 : CustomTypeDescriptor {
    private PropertyDescriptorCollection _properties;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public TKey Key { get; public set; }
    public TValue Value { get; public set; }
    public EditableKeyValuePair`2(TKey key, TValue value);
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(TKey value);
    [CompilerGeneratedAttribute]
public TValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(TValue value);
    public virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public virtual PropertyDescriptorCollection GetProperties();
    public virtual object GetPropertyOwner(PropertyDescriptor pd);
    public virtual string ToString();
}
internal static class Xceed.Wpf.Toolkit.Core.ErrorMessages : object {
    public static string EndAngleCannotBeSetDirectlyInSlice;
    public static string SliceCannotBeSetDirectlyInEndAngle;
    public static string SliceOOR;
    public static string AnimationAccelerationRatioOOR;
    public static string AnimationDecelerationRatioOOR;
    public static string ZoomboxContentMustBeUIElement;
    public static string ViewModeInvalidForSource;
    public static string ZoomboxTemplateNeedsContent;
    public static string ZoomboxHasViewFinderButNotDisplay;
    public static string PositionOnlyAccessibleOnAbsolute;
    public static string ZoomboxViewAlreadyInitialized;
    public static string ScaleOnlyAccessibleOnAbsolute;
    public static string RegionOnlyAccessibleOnRegionalView;
    public static string UnableToConvertToZoomboxView;
    public static string ViewStackCannotBeManipulatedNow;
    public static string SuppliedValueWasNotVisibility;
    public static string NegativeTimeSpanNotSupported;
    public static string NegativeSpeedNotSupported;
    public static string InvalidRatePropertyAccessed;
    public static string AlreadyInColumnCollection;
    public static string AlreadyInRowCollection;
    public static string AlreadyInStackDefinition;
    public static string ArrayDestTooShort;
    public static string CollectionDisposed;
    public static string CollectionModified;
    public static string ColumnValueIsReadOnly;
    public static string DefaultAnimatorCantAnimate;
    public static string DefaultAnimationRateAnimationRateDefault;
    public static string DefaultAnimatorIterativeAnimationDefault;
    public static string DestMultidimensional;
    public static string EnumerationFinished;
    public static string EnumerationNotStarted;
    public static string InvalidDefaultStackLength;
    public static string MustBeColumnDefinition;
    public static string MustBeRowDefinition;
    public static string MustBeStackDefinition;
    public static string RowValueIsReadOnly;
    public static string StackValueIsReadOnly;
    public static string UnexpectedType;
    private static ResourceManager _resourceManager;
    private static ErrorMessages();
    public static string GetMessage(string msgId);
}
public class Xceed.Wpf.Toolkit.Core.GenericTextBlock : TextBlock {
}
[MarkupExtensionReturnTypeAttribute("System.Windows.Media.Imaging.BitmapImage")]
public class Xceed.Wpf.Toolkit.Core.ImageUriExtension : PackUriExtension {
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
public class Xceed.Wpf.Toolkit.Core.IndexChangedEventArgs : PropertyChangedEventArgs`1<int> {
    public IndexChangedEventArgs(RoutedEvent routedEvent, int oldIndex, int newIndex);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class Xceed.Wpf.Toolkit.Core.IndexChangedEventHandler : MulticastDelegate {
    public IndexChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, IndexChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, IndexChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.Core.Input.InputValidationErrorEventArgs : EventArgs {
    private Exception exception;
    private bool _throwException;
    public Exception Exception { get; private set; }
    public bool ThrowException { get; public set; }
    public InputValidationErrorEventArgs(Exception e);
    public Exception get_Exception();
    private void set_Exception(Exception value);
    public bool get_ThrowException();
    public void set_ThrowException(bool value);
}
public class Xceed.Wpf.Toolkit.Core.Input.InputValidationErrorEventHandler : MulticastDelegate {
    public InputValidationErrorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputValidationErrorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputValidationErrorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface Xceed.Wpf.Toolkit.Core.Input.IValidateInput {
    [CompilerGeneratedAttribute]
public abstract virtual void add_InputValidationError(InputValidationErrorEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_InputValidationError(InputValidationErrorEventHandler value);
    public abstract virtual bool CommitInput();
}
public enum Xceed.Wpf.Toolkit.Core.Input.KeyModifier : Enum {
    public int value__;
    public static KeyModifier None;
    public static KeyModifier Blocked;
    public static KeyModifier Ctrl;
    public static KeyModifier LeftCtrl;
    public static KeyModifier RightCtrl;
    public static KeyModifier Shift;
    public static KeyModifier LeftShift;
    public static KeyModifier RightShift;
    public static KeyModifier Alt;
    public static KeyModifier LeftAlt;
    public static KeyModifier RightAlt;
    public static KeyModifier Exact;
}
[TypeConverterAttribute("Xceed.Wpf.Toolkit.Core.Input.KeyModifierCollectionConverter")]
public class Xceed.Wpf.Toolkit.Core.Input.KeyModifierCollection : Collection`1<KeyModifier> {
    public bool AreActive { get; }
    public bool get_AreActive();
    private static bool IsKeyPressed(KeyModifier modifier, ICollection`1<Key> keys);
    private static bool HasModifier(Key key, ICollection`1<KeyModifier> modifiers);
    private bool IsExactMatch();
    private bool MatchAny();
    private HashSet`1<KeyModifier> GetKeyModifiers();
    private HashSet`1<Key> GetKeysPressed();
}
public class Xceed.Wpf.Toolkit.Core.Input.KeyModifierCollectionConverter : TypeConverter {
    private static TypeConverter _keyModifierConverter;
    private static KeyModifierCollectionConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    private static object ConstructInstanceDescriptor();
}
public class Xceed.Wpf.Toolkit.Core.InvalidContentException : Exception {
    public InvalidContentException(string message);
    public InvalidContentException(string message, Exception innerException);
}
public class Xceed.Wpf.Toolkit.Core.InvalidTemplateException : Exception {
    public InvalidTemplateException(string message);
    public InvalidTemplateException(string message, Exception innerException);
}
public enum Xceed.Wpf.Toolkit.Core.Location : Enum {
    public int value__;
    public static Location Left;
    public static Location Right;
}
public static class Xceed.Wpf.Toolkit.Core.Media.WindowColors : object {
    private static Nullable`1<Color> _colorizationMode;
    private static Nullable`1<bool> _colorizationOpaqueBlend;
    public static Color ColorizationColor { get; }
    public static bool ColorizationOpaqueBlend { get; }
    public static Color get_ColorizationColor();
    public static bool get_ColorizationOpaqueBlend();
    private static int GetDWMIntValue(string keyName);
    private static Color GetDWMColorValue(string keyName);
    private static bool GetDWMBoolValue(string keyName);
}
internal static class Xceed.Wpf.Toolkit.Core.Message : object {
    private static bool m_shown;
    private static IEnumerable`1<ulong> Data { get; }
    private static IEnumerable`1<ulong> get_Data();
    internal static void ShowMessage();
    private static char ConvVal(ulong x);
}
[MarkupExtensionReturnTypeAttribute("System.Uri")]
public class Xceed.Wpf.Toolkit.Core.PackUriExtension : MarkupExtension {
    private string m_assemblyName;
    private string m_path;
    private UriKind m_uriKind;
    public string AssemblyName { get; public set; }
    public string Path { get; public set; }
    public UriKind Kind { get; public set; }
    public PackUriExtension(UriKind uriKind);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_Path();
    public void set_Path(string value);
    public UriKind get_Kind();
    public void set_Kind(UriKind value);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    internal static string BuildRelativePackUriString(string assemblyName, string path);
    internal static string BuildRelativePackUriString(string assemblyName, string version, string path);
    internal static string BuildAbsolutePackUriString(string assemblyName, string path);
    internal static string BuildAbsolutePackUriString(string assemblyName, string version, string path);
}
public class Xceed.Wpf.Toolkit.Core.PropertyChangedEventArgs`1 : RoutedEventArgs {
    private T _newValue;
    private T _oldValue;
    public T NewValue { get; }
    public T OldValue { get; }
    public PropertyChangedEventArgs`1(RoutedEvent Event, T oldValue, T newValue);
    public T get_NewValue();
    public T get_OldValue();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class Xceed.Wpf.Toolkit.Core.PropertyChangedEventHandler`1 : MulticastDelegate {
    public PropertyChangedEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyChangedEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyChangedEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.Core.QueryTextFromValueEventArgs : EventArgs {
    private object m_value;
    private string m_text;
    public object Value { get; }
    public string Text { get; public set; }
    public QueryTextFromValueEventArgs(object value, string text);
    public object get_Value();
    public string get_Text();
    public void set_Text(string value);
}
public class Xceed.Wpf.Toolkit.Core.QueryValueFromTextEventArgs : EventArgs {
    private string m_text;
    private object m_value;
    private bool m_hasParsingError;
    public string Text { get; }
    public object Value { get; public set; }
    public bool HasParsingError { get; public set; }
    public QueryValueFromTextEventArgs(string text, object value);
    public string get_Text();
    public object get_Value();
    public void set_Value(object value);
    public bool get_HasParsingError();
    public void set_HasParsingError(bool value);
}
public class Xceed.Wpf.Toolkit.Core.ResourceDictionary : ResourceDictionary {
    private int _initializingCount;
    private string _assemblyName;
    private string _sourcePath;
    public string AssemblyName { get; public set; }
    public string SourcePath { get; public set; }
    public ResourceDictionary(string assemblyName, string sourcePath);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_SourcePath();
    public void set_SourcePath(string value);
    protected virtual Uri BuildUri();
    private void EnsureInitialization();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
internal class Xceed.Wpf.Toolkit.Core.UIElementAdorner`1 : Adorner {
    private TElement _child;
    private double _offsetLeft;
    private double _offsetTop;
    public TElement Child { get; public set; }
    public double OffsetLeft { get; public set; }
    public double OffsetTop { get; public set; }
    protected IEnumerator LogicalChildren { get; }
    protected int VisualChildrenCount { get; }
    public UIElementAdorner`1(UIElement adornedElement);
    public TElement get_Child();
    public void set_Child(TElement value);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    public double get_OffsetLeft();
    public void set_OffsetLeft(double value);
    public void SetOffsets(double left, double top);
    public double get_OffsetTop();
    public void set_OffsetTop(double value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual IEnumerator get_LogicalChildren();
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    private void UpdateLocation();
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.CalculatorUtilities : object {
    public static CalculatorButtonType GetCalculatorButtonTypeFromText(string text);
    public static Button FindButtonByCalculatorButtonType(DependencyObject parent, CalculatorButtonType type);
    public static string GetCalculatorButtonContent(CalculatorButtonType type);
    public static bool IsDigit(CalculatorButtonType buttonType);
    public static bool IsMemory(CalculatorButtonType buttonType);
    public static decimal ParseDecimal(string text);
    public static decimal Add(decimal firstNumber, decimal secondNumber);
    public static decimal Subtract(decimal firstNumber, decimal secondNumber);
    public static decimal Multiply(decimal firstNumber, decimal secondNumber);
    public static decimal Divide(decimal firstNumber, decimal secondNumber);
    public static decimal Percent(decimal firstNumber, decimal secondNumber);
    public static decimal SquareRoot(decimal operand);
    public static decimal Fraction(decimal operand);
    public static decimal Negate(decimal operand);
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.ChangeTypeHelper : object {
    internal static object ChangeType(object value, Type conversionType, IFormatProvider provider);
}
[ExtensionAttribute]
internal static class Xceed.Wpf.Toolkit.Core.Utilities.ColorUtilities : object {
    public static Dictionary`2<string, Color> KnownColors;
    private static ColorUtilities();
    [ExtensionAttribute]
public static string GetColorName(Color color);
    public static string FormatColorString(string stringToFormat, bool isUsingAlphaChannel);
    private static Dictionary`2<string, Color> GetKnownColors();
    public static HsvColor ConvertRgbToHsv(int r, int g, int b);
    public static Color ConvertHsvToRgb(double h, double s, double v);
    public static List`1<Color> GenerateHsvSpectrum();
}
public class Xceed.Wpf.Toolkit.Core.Utilities.ContextMenuUtilities : object {
    public static DependencyProperty OpenOnMouseLeftButtonClickProperty;
    private static ContextMenuUtilities();
    public static void SetOpenOnMouseLeftButtonClick(FrameworkElement element, bool value);
    public static bool GetOpenOnMouseLeftButtonClick(FrameworkElement element);
    public static void OpenOnMouseLeftButtonClickChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    private static void Control_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e);
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.DateTimeUtilities : object {
    public static DateTime GetContextNow(DateTimeKind kind);
    public static bool IsSameDate(Nullable`1<DateTime> date1, Nullable`1<DateTime> date2);
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.DoubleHelper : object {
    public static bool AreVirtuallyEqual(double d1, double d2);
    public static bool AreVirtuallyEqual(Size s1, Size s2);
    public static bool AreVirtuallyEqual(Point p1, Point p2);
    public static bool AreVirtuallyEqual(Rect r1, Rect r2);
    public static bool AreVirtuallyEqual(Vector v1, Vector v2);
    public static bool AreVirtuallyEqual(Segment s1, Segment s2);
    public static bool IsNaN(double value);
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.EllipseHelper : object {
    public static Point PointOfRadialIntersection(Rect ellipseRect, double angle);
    public static double RadialDistanceFromCenter(Rect ellipseRect, double angle);
}
internal class Xceed.Wpf.Toolkit.Core.Utilities.FontUtilities : object {
    internal static IEnumerable`1<FontFamily> Families { get; }
    internal static IEnumerable`1<FontWeight> Weights { get; }
    internal static IEnumerable`1<FontStyle> Styles { get; }
    internal static IEnumerable`1<FontStretch> Stretches { get; }
    internal static IEnumerable`1<FontFamily> get_Families();
    internal static IEnumerable`1<FontWeight> get_Weights();
    internal static IEnumerable`1<FontStyle> get_Styles();
    internal static IEnumerable`1<FontStretch> get_Stretches();
    internal static FontFamily GetFontFamily(string fontFamilyName);
    internal static string GetFontFamilyName(FontFamily fontFamily);
}
internal class Xceed.Wpf.Toolkit.Core.Utilities.GeneralUtilities : DependencyObject {
    internal static DependencyProperty StubValueProperty;
    private static GeneralUtilities();
    internal static object GetStubValue(DependencyObject obj);
    internal static void SetStubValue(DependencyObject obj, object value);
    public static object GetPathValue(object sourceObject, string path);
    public static object GetBindingValue(object sourceObject, Binding binding);
    internal static bool CanConvertValue(object value, object targetType);
}
internal class Xceed.Wpf.Toolkit.Core.Utilities.KeyboardUtilities : object {
    internal static bool IsKeyModifyingPopupState(KeyEventArgs e);
}
internal class Xceed.Wpf.Toolkit.Core.Utilities.ListUtilities : object {
    internal static bool IsListOfItems(Type listType);
    internal static Type GetListItemType(Type listType);
    internal static bool IsCollectionOfItems(Type colType);
    internal static Type GetCollectionItemType(Type colType);
    internal static bool IsDictionaryOfItems(Type dictType);
    internal static Type[] GetDictionaryItemsType(Type dictType);
    internal static object CreateEditableKeyValuePair(object key, Type keyType, object value, Type valueType);
    internal static Type CreateEditableKeyValuePairType(Type keyType, Type valueType);
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.PointHelper : object {
    public static Point Empty { get; }
    public static double DistanceBetween(Point p1, Point p2);
    public static Point get_Empty();
    public static bool IsEmpty(Point point);
}
[ExtensionAttribute]
internal static class Xceed.Wpf.Toolkit.Core.Utilities.PropertyChangedExt : object {
    [ExtensionAttribute]
public static void Notify(INotifyPropertyChanged sender, PropertyChangedEventHandler handler, Expression`1<Func`1<TMember>> expression);
    [ExtensionAttribute]
public static void Notify(INotifyPropertyChanged sender, PropertyChangedEventHandler handler, string propertyName);
    private static void NotifyCore(INotifyPropertyChanged sender, PropertyChangedEventHandler handler, string propertyName);
    internal static bool PropertyChanged(string propertyName, PropertyChangedEventArgs e, bool targetPropertyOnly);
    internal static bool PropertyChanged(Expression`1<Func`1<TMember>> expression, PropertyChangedEventArgs e, bool targetPropertyOnly);
    internal static bool PropertyChanged(Expression`1<Func`2<TOwner, TMember>> expression, PropertyChangedEventArgs e, bool targetPropertyOnly);
    private static bool PropertyChanged(MemberExpression expression, Type ownerType, PropertyChangedEventArgs e, bool targetPropertyOnly);
    private static string GetPropertyName(MemberExpression expression, Type ownerType);
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.RectHelper : object {
    public static Point Center(Rect rect);
    public static Nullable`1<Point> GetNearestPointOfIntersectionBetweenRectAndSegment(Rect rect, Segment segment, Point point);
    public static Rect GetRectCenteredOnPoint(Point center, Size size);
    private static void AdjustResultForIntersectionWithSide(Nullable`1& result, Double& distance, Segment intersection, Point point);
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.ReflectionHelper : object {
    [ConditionalAttribute("DEBUG")]
internal static void ValidatePublicPropertyName(object sourceObject, string propertyName);
    [ConditionalAttribute("DEBUG")]
internal static void ValidatePropertyName(object sourceObject, string propertyName);
    internal static bool TryGetEnumDescriptionAttributeValue(Enum enumeration, String& description);
    [DebuggerStepThroughAttribute]
internal static string GetPropertyOrFieldName(MemberExpression expression);
    [DebuggerStepThroughAttribute]
internal static string GetPropertyOrFieldName(Expression`1<Func`1<TMember>> expression);
    [DebuggerStepThroughAttribute]
internal static bool TryGetPropertyOrFieldName(MemberExpression expression, String& propertyOrFieldName);
    [DebuggerStepThroughAttribute]
internal static bool TryGetPropertyOrFieldName(Expression`1<Func`1<TMember>> expression, String& propertyOrFieldName);
    public static bool IsPublicInstanceProperty(Type type, string propertyName);
}
internal class Xceed.Wpf.Toolkit.Core.Utilities.ResourceHelper : object {
    internal static Stream LoadResourceStream(Assembly assembly, string resId);
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.RoutedEventHelper : object {
    internal static void RaiseEvent(DependencyObject target, RoutedEventArgs args);
    internal static void AddHandler(DependencyObject element, RoutedEvent routedEvent, Delegate handler);
    internal static void RemoveHandler(DependencyObject element, RoutedEvent routedEvent, Delegate handler);
}
internal class Xceed.Wpf.Toolkit.Core.Utilities.Segment : ValueType {
    private bool _isP1Excluded;
    private bool _isP2Excluded;
    private Point _p1;
    private Point _p2;
    public static Segment Empty { get; }
    public Point P1 { get; }
    public Point P2 { get; }
    public bool IsP1Excluded { get; }
    public bool IsP2Excluded { get; }
    public bool IsEmpty { get; }
    public bool IsPoint { get; }
    public double Length { get; }
    public double Slope { get; }
    public Segment(Point point);
    public Segment(Point p1, Point p2);
    public Segment(Point p1, Point p2, bool excludeP1, bool excludeP2);
    public static Segment get_Empty();
    public Point get_P1();
    public Point get_P2();
    public bool get_IsP1Excluded();
    public bool get_IsP2Excluded();
    public bool get_IsEmpty();
    public bool get_IsPoint();
    public double get_Length();
    public double get_Slope();
    public bool Contains(Point point);
    public bool Contains(Segment segment);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public Segment Intersection(Segment segment);
    public virtual string ToString();
    public static bool op_Equality(Segment s1, Segment s2);
    public static bool op_Inequality(Segment s1, Segment s2);
}
internal static class Xceed.Wpf.Toolkit.Core.Utilities.TreeHelper : object {
    public static DependencyObject GetParent(DependencyObject element);
    private static DependencyObject GetParent(DependencyObject element, bool recurseIntoPopup);
    public static T FindParent(DependencyObject startingObject);
    public static T FindParent(DependencyObject startingObject, bool checkStartingObject);
    public static T FindParent(DependencyObject startingObject, bool checkStartingObject, Func`2<T, bool> additionalCheck);
    public static T FindChild(DependencyObject parent);
    public static T FindChild(DependencyObject parent, Func`2<T, bool> additionalCheck);
    public static bool IsDescendantOf(DependencyObject element, DependencyObject parent);
    public static bool IsDescendantOf(DependencyObject element, DependencyObject parent, bool recurseIntoPopup);
}
internal class Xceed.Wpf.Toolkit.Core.Utilities.ValueChangeHelper : DependencyObject {
    private static DependencyProperty ValueProperty;
    [CompilerGeneratedAttribute]
private EventHandler ValueChanged;
    private object Value { get; private set; }
    public ValueChangeHelper(Action changeCallback);
    private static ValueChangeHelper();
    private object get_Value();
    private void set_Value(object value);
    private static void OnValueChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    [CompilerGeneratedAttribute]
public void add_ValueChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ValueChanged(EventHandler value);
    public void UpdateValueSource(object sourceItem, string path);
    public void UpdateValueSource(IEnumerable sourceItems, string path);
    private void UpdateBinding(BindingBase binding);
    private void ClearBinding();
    private void RaiseValueChanged();
}
public static class Xceed.Wpf.Toolkit.Core.Utilities.VisualTreeHelperEx : object {
    public static DependencyObject FindAncestorByType(DependencyObject element, Type type, bool specificTypeOnly);
    public static T FindAncestorByType(DependencyObject depObj);
    public static Visual FindDescendantByName(Visual element, string name);
    public static Visual FindDescendantByType(Visual element, Type type);
    public static Visual FindDescendantByType(Visual element, Type type, bool specificTypeOnly);
    public static T FindDescendantByType(Visual element);
    public static Visual FindDescendantWithPropertyValue(Visual element, DependencyProperty dp, object value);
}
internal class Xceed.Wpf.Toolkit.Core.Utilities.WeakEventListener`1 : object {
    private Action`2<object, TArgs> _callback;
    public WeakEventListener`1(Action`2<object, TArgs> callback);
    public sealed virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
internal class Xceed.Wpf.Toolkit.Core.Utilities.WindowUtilities : object {
}
public class Xceed.Wpf.Toolkit.Core.VersionResourceDictionary : ResourceDictionary {
    public VersionResourceDictionary(string assemblyName, string sourcePath);
    protected virtual Uri BuildUri();
}
internal class Xceed.Wpf.Toolkit.Core.WeakCollectionChangedWrapper : object {
    private WeakEventListener`1<NotifyCollectionChangedEventArgs> _innerListListener;
    private IList _innerList;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public WeakCollectionChangedWrapper(IList sourceList);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void OnInnerCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
    internal void ReleaseEvents();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Xceed.Wpf.Toolkit.DateElement : object {
    internal Rect PlacementRectangle;
    private int _originalIndex;
    private DateTime _date;
    private DateTime _dateEnd;
    private UIElement _element;
    public DateTime Date { get; }
    public DateTime DateEnd { get; }
    public UIElement Element { get; }
    internal DateElement(UIElement element, DateTime date, DateTime dateEnd);
    internal DateElement(UIElement element, DateTime date, DateTime dateEnd, int originalIndex);
    public DateTime get_Date();
    public DateTime get_DateEnd();
    public UIElement get_Element();
    public virtual string ToString();
    public sealed virtual int CompareTo(DateElement d);
}
public enum Xceed.Wpf.Toolkit.DateTimeFormat : Enum {
    public int value__;
    public static DateTimeFormat Custom;
    public static DateTimeFormat FullDateTime;
    public static DateTimeFormat LongDate;
    public static DateTimeFormat LongTime;
    public static DateTimeFormat MonthDay;
    public static DateTimeFormat RFC1123;
    public static DateTimeFormat ShortDate;
    public static DateTimeFormat ShortTime;
    public static DateTimeFormat SortableDateTime;
    public static DateTimeFormat UniversalSortableDateTime;
    public static DateTimeFormat YearMonth;
}
internal class Xceed.Wpf.Toolkit.DateTimeInfo : object {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimePart <Type>k__BackingField;
    public string Content { get; public set; }
    public string Format { get; public set; }
    public bool IsReadOnly { get; public set; }
    public int Length { get; public set; }
    public int StartPosition { get; public set; }
    public DateTimePart Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    [CompilerGeneratedAttribute]
public int get_StartPosition();
    [CompilerGeneratedAttribute]
public void set_StartPosition(int value);
    [CompilerGeneratedAttribute]
public DateTimePart get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(DateTimePart value);
}
internal class Xceed.Wpf.Toolkit.DateTimeParser : object {
    public static bool TryParse(string value, string format, DateTime currentDate, CultureInfo cultureInfo, bool autoClipTimeParts, DateTime& result);
    private static void UpdateValueFormatForQuotes(String& value, String& format);
    private static string ComputeDateTimeString(string dateTime, string format, DateTime currentDate, CultureInfo cultureInfo, bool autoClipTimeParts);
    private static void UpdateSortableDateTimeString(String& dateTime, String& format, CultureInfo cultureInfo);
    private static Dictionary`2<string, string> GetDateParts(DateTime currentDate, CultureInfo cultureInfo);
}
public enum Xceed.Wpf.Toolkit.DateTimePart : Enum {
    public int value__;
    public static DateTimePart Day;
    public static DateTimePart DayName;
    public static DateTimePart AmPmDesignator;
    public static DateTimePart Millisecond;
    public static DateTimePart Hour12;
    public static DateTimePart Hour24;
    public static DateTimePart Minute;
    public static DateTimePart Month;
    public static DateTimePart MonthName;
    public static DateTimePart Other;
    public static DateTimePart Period;
    public static DateTimePart TimeZone;
    public static DateTimePart Second;
    public static DateTimePart Year;
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.DateTimePicker : DateTimePickerBase {
    private static string PART_Calendar;
    private static string PART_TimeUpDown;
    private Calendar _calendar;
    private TimePicker _timePicker;
    private Nullable`1<DateTime> _calendarTemporaryDateTime;
    private Nullable`1<DateTime> _calendarIntendedDateTime;
    private bool _isModifyingCalendarInternally;
    public static DependencyProperty AutoCloseCalendarProperty;
    public static DependencyProperty AutoCloseCalendarOnTimeSelectionProperty;
    public static DependencyProperty CalendarDisplayModeProperty;
    public static DependencyProperty CalendarWidthProperty;
    public static DependencyProperty TimeFormatProperty;
    public static DependencyProperty TimeFormatStringProperty;
    public static DependencyProperty TimePickerAllowSpinProperty;
    public static DependencyProperty TimePickerTimeListItemsStyleProperty;
    public static DependencyProperty TimePickerShowButtonSpinnerProperty;
    public static DependencyProperty TimePickerVisibilityProperty;
    public static DependencyProperty TimeWatermarkProperty;
    public static DependencyProperty TimeWatermarkTemplateProperty;
    public static RoutedEvent TodayEvent;
    public bool AutoCloseCalendar { get; public set; }
    public bool AutoCloseCalendarOnTimeSelection { get; public set; }
    public CalendarMode CalendarDisplayMode { get; public set; }
    public double CalendarWidth { get; public set; }
    public DateTimeFormat TimeFormat { get; public set; }
    public string TimeFormatString { get; public set; }
    public bool TimePickerAllowSpin { get; public set; }
    public Style TimePickerTimeListItemsStyle { get; public set; }
    public bool TimePickerShowButtonSpinner { get; public set; }
    public Visibility TimePickerVisibility { get; public set; }
    public object TimeWatermark { get; public set; }
    public DataTemplate TimeWatermarkTemplate { get; public set; }
    private static DateTimePicker();
    public bool get_AutoCloseCalendar();
    public void set_AutoCloseCalendar(bool value);
    public bool get_AutoCloseCalendarOnTimeSelection();
    public void set_AutoCloseCalendarOnTimeSelection(bool value);
    public CalendarMode get_CalendarDisplayMode();
    public void set_CalendarDisplayMode(CalendarMode value);
    public double get_CalendarWidth();
    public void set_CalendarWidth(double value);
    public DateTimeFormat get_TimeFormat();
    public void set_TimeFormat(DateTimeFormat value);
    public string get_TimeFormatString();
    public void set_TimeFormatString(string value);
    private static bool IsTimeFormatStringValid(object value);
    public bool get_TimePickerAllowSpin();
    public void set_TimePickerAllowSpin(bool value);
    public Style get_TimePickerTimeListItemsStyle();
    public void set_TimePickerTimeListItemsStyle(Style value);
    private static void OnTimePickerTimeListItemsStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTimePickerTimeListItemsStyleChanged(DependencyPropertyChangedEventArgs e);
    public bool get_TimePickerShowButtonSpinner();
    public void set_TimePickerShowButtonSpinner(bool value);
    public Visibility get_TimePickerVisibility();
    public void set_TimePickerVisibility(Visibility value);
    public object get_TimeWatermark();
    public void set_TimeWatermark(object value);
    public DataTemplate get_TimeWatermarkTemplate();
    public void set_TimeWatermarkTemplate(DataTemplate value);
    public virtual void OnApplyTemplate();
    protected virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    protected virtual void OnValueChanged(Nullable`1<DateTime> oldValue, Nullable`1<DateTime> newValue);
    protected virtual void OnIsOpenChanged(bool oldValue, bool newValue);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnMaximumChanged(Nullable`1<DateTime> oldValue, Nullable`1<DateTime> newValue);
    protected virtual void OnMinimumChanged(Nullable`1<DateTime> oldValue, Nullable`1<DateTime> newValue);
    public void add_Today(RoutedEventHandler value);
    public void remove_Today(RoutedEventHandler value);
    protected virtual void HandleKeyDown(object sender, KeyEventArgs e);
    private void TimePicker_ValueChanged(object sender, RoutedPropertyChangedEventArgs`1<object> e);
    private void Calendar_SelectedDatesChanged(object sender, SelectionChangedEventArgs e);
    private void Calendar_MouseDoubleClick(object sender, MouseButtonEventArgs e);
    protected virtual void Popup_Opened(object sender, EventArgs e);
    private void SetBlackOutDates();
}
public class Xceed.Wpf.Toolkit.DateTimeUpDown : DateTimeUpDownBase`1<Nullable`1<DateTime>> {
    private Nullable`1<DateTime> _lastValidDate;
    private bool _setKindInternal;
    public static DependencyProperty AutoClipTimePartsProperty;
    public static DependencyProperty FormatProperty;
    public static DependencyProperty FormatStringProperty;
    public static DependencyProperty KindProperty;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <TempValue>k__BackingField;
    public bool AutoClipTimeParts { get; public set; }
    public DateTimeFormat Format { get; public set; }
    public string FormatString { get; public set; }
    public DateTimeKind Kind { get; public set; }
    internal Nullable`1<DateTime> TempValue { get; internal set; }
    internal DateTime ContextNow { get; }
    private static DateTimeUpDown();
    public bool get_AutoClipTimeParts();
    public void set_AutoClipTimeParts(bool value);
    public DateTimeFormat get_Format();
    public void set_Format(DateTimeFormat value);
    private static void OnFormatChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnFormatChanged(DateTimeFormat oldValue, DateTimeFormat newValue);
    public string get_FormatString();
    public void set_FormatString(string value);
    internal static bool IsFormatStringValid(object value);
    private static void OnFormatStringChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnFormatStringChanged(string oldValue, string newValue);
    public DateTimeKind get_Kind();
    public void set_Kind(DateTimeKind value);
    private static void OnKindChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnKindChanged(DateTimeKind oldValue, DateTimeKind newValue);
    private void SetKindInternal(DateTimeKind kind);
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_TempValue();
    [CompilerGeneratedAttribute]
internal void set_TempValue(Nullable`1<DateTime> value);
    internal DateTime get_ContextNow();
    public virtual bool CommitInput();
    protected virtual void OnCultureInfoChanged(CultureInfo oldValue, CultureInfo newValue);
    protected virtual void OnIncrement();
    protected virtual void OnDecrement();
    protected virtual void OnTextChanged(string previousValue, string currentValue);
    protected virtual Nullable`1<DateTime> ConvertTextToValue(string text);
    protected virtual string ConvertValueToText();
    protected virtual void SetValidSpinDirection();
    protected virtual object OnCoerceValue(object newValue);
    protected virtual void OnValueChanged(Nullable`1<DateTime> oldValue, Nullable`1<DateTime> newValue);
    protected virtual bool IsCurrentValueValid();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void PerformMouseSelection();
    protected internal virtual void PerformKeyboardSelection(int nextSelectionStart);
    protected virtual void InitializeDateTimeInfoList(Nullable`1<DateTime> value);
    protected virtual bool IsLowerThan(Nullable`1<DateTime> value1, Nullable`1<DateTime> value2);
    protected virtual bool IsGreaterThan(Nullable`1<DateTime> value1, Nullable`1<DateTime> value2);
    protected virtual void OnUpdateValueOnEnterKeyChanged(bool oldValue, bool newValue);
    protected virtual void OnKeyDown(KeyEventArgs e);
    public void SelectAll();
    private void FormatUpdated();
    private static int GetElementLengthByFormat(string format);
    private void Increment(int step);
    private void ParseValueIntoDateTimeInfo(Nullable`1<DateTime> newDate);
    internal string GetFormatString(DateTimeFormat dateTimeFormat);
    private Nullable`1<DateTime> UpdateDateTime(Nullable`1<DateTime> currentDateTime, int value);
    protected virtual bool TryParseDateTime(string text, DateTime& result);
    private DateTime ConvertToKind(DateTime dateTime, DateTimeKind kind);
    private void DateTimeUpDown_Loaded(object sender, RoutedEventArgs e);
}
public class Xceed.Wpf.Toolkit.DecimalUpDown : CommonNumericUpDown`1<decimal> {
    private static DecimalUpDown();
    protected virtual decimal IncrementValue(decimal value, decimal increment);
    protected virtual decimal DecrementValue(decimal value, decimal increment);
}
public class Xceed.Wpf.Toolkit.DoubleUpDown : CommonNumericUpDown`1<double> {
    public static DependencyProperty AllowInputSpecialValuesProperty;
    public AllowedSpecialValues AllowInputSpecialValues { get; public set; }
    private static DoubleUpDown();
    public AllowedSpecialValues get_AllowInputSpecialValues();
    public void set_AllowInputSpecialValues(AllowedSpecialValues value);
    protected virtual Nullable`1<double> OnCoerceIncrement(Nullable`1<double> baseValue);
    protected virtual Nullable`1<double> OnCoerceMaximum(Nullable`1<double> baseValue);
    protected virtual Nullable`1<double> OnCoerceMinimum(Nullable`1<double> baseValue);
    protected virtual double IncrementValue(double value, double increment);
    protected virtual double DecrementValue(double value, double increment);
    protected virtual void SetValidSpinDirection();
    protected virtual Nullable`1<double> ConvertTextToValue(string text);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.DropDownButton : ContentControl {
    private static string PART_DropDownButton;
    private static string PART_ContentPresenter;
    private static string PART_Popup;
    private ContentPresenter _contentPresenter;
    private Popup _popup;
    private ButtonBase _button;
    public static DependencyProperty DropDownContentProperty;
    public static DependencyProperty DropDownContentBackgroundProperty;
    public static DependencyProperty DropDownPositionProperty;
    public static DependencyProperty IsDefaultProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty MaxDropDownHeightProperty;
    public static RoutedEvent ClickEvent;
    public static RoutedEvent OpenedEvent;
    public static RoutedEvent ClosedEvent;
    private EventHandler canExecuteChangedHandler;
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    protected ButtonBase Button { get; protected set; }
    public object DropDownContent { get; public set; }
    public Brush DropDownContentBackground { get; public set; }
    public PlacementMode DropDownPosition { get; public set; }
    public bool IsDefault { get; public set; }
    public bool IsOpen { get; public set; }
    public double MaxDropDownHeight { get; public set; }
    [TypeConverterAttribute("System.Windows.Input.CommandConverter")]
public ICommand Command { get; public set; }
    public object CommandParameter { get; public set; }
    public IInputElement CommandTarget { get; public set; }
    private static DropDownButton();
    protected ButtonBase get_Button();
    protected void set_Button(ButtonBase value);
    public object get_DropDownContent();
    public void set_DropDownContent(object value);
    private static void OnDropDownContentChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDropDownContentChanged(object oldValue, object newValue);
    public Brush get_DropDownContentBackground();
    public void set_DropDownContentBackground(Brush value);
    public PlacementMode get_DropDownPosition();
    public void set_DropDownPosition(PlacementMode value);
    public bool get_IsDefault();
    public void set_IsDefault(bool value);
    private static void OnIsDefaultChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsDefaultChanged(bool oldValue, bool newValue);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    private static void OnIsOpenChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsOpenChanged(bool oldValue, bool newValue);
    public double get_MaxDropDownHeight();
    public void set_MaxDropDownHeight(double value);
    private static void OnMaxDropDownHeightChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMaxDropDownHeightChanged(double oldValue, double newValue);
    public virtual void OnApplyTemplate();
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    public void add_Click(RoutedEventHandler value);
    public void remove_Click(RoutedEventHandler value);
    public void add_Opened(RoutedEventHandler value);
    public void remove_Opened(RoutedEventHandler value);
    public void add_Closed(RoutedEventHandler value);
    public void remove_Closed(RoutedEventHandler value);
    private ContextMenu GetContextMenu(DependencyObject parent);
    private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs e);
    private void OnKeyDown(object sender, KeyEventArgs e);
    private void OnMouseDownOutsideCapturedElement(object sender, MouseButtonEventArgs e);
    private void DropDownButton_Click(object sender, RoutedEventArgs e);
    private void CanExecuteChanged(object sender, EventArgs e);
    private void Popup_Opened(object sender, EventArgs e);
    private void CanExecuteChanged();
    private void CloseDropDown(bool isFocusOnButton);
    protected virtual void OnClick();
    private void RaiseRoutedEvent(RoutedEvent routedEvent);
    private void RaiseCommand();
    private void UnhookCommand(ICommand oldCommand, ICommand newCommand);
    private void HookUpCommand(ICommand oldCommand, ICommand newCommand);
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    private static void OnCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCommandChanged(ICommand oldValue, ICommand newValue);
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
}
public enum Xceed.Wpf.Toolkit.FrameType : Enum {
    public int value__;
    public static FrameType Circle;
    public static FrameType Rectangle;
}
public class Xceed.Wpf.Toolkit.IconButton : Button {
    public static DependencyProperty IconProperty;
    public static DependencyProperty IconLocationProperty;
    public static DependencyProperty MouseOverBackgroundProperty;
    public static DependencyProperty MouseOverBorderBrushProperty;
    public static DependencyProperty MouseOverForegroundProperty;
    public static DependencyProperty MousePressedBackgroundProperty;
    public static DependencyProperty MousePressedBorderBrushProperty;
    public static DependencyProperty MousePressedForegroundProperty;
    public Image Icon { get; public set; }
    public Location IconLocation { get; public set; }
    public Brush MouseOverBackground { get; public set; }
    public Brush MouseOverBorderBrush { get; public set; }
    public Brush MouseOverForeground { get; public set; }
    public Brush MousePressedBackground { get; public set; }
    public Brush MousePressedBorderBrush { get; public set; }
    public Brush MousePressedForeground { get; public set; }
    private static IconButton();
    public Image get_Icon();
    public void set_Icon(Image value);
    public Location get_IconLocation();
    public void set_IconLocation(Location value);
    public Brush get_MouseOverBackground();
    public void set_MouseOverBackground(Brush value);
    public Brush get_MouseOverBorderBrush();
    public void set_MouseOverBorderBrush(Brush value);
    public Brush get_MouseOverForeground();
    public void set_MouseOverForeground(Brush value);
    public Brush get_MousePressedBackground();
    public void set_MousePressedBackground(Brush value);
    public Brush get_MousePressedBorderBrush();
    public void set_MousePressedBorderBrush(Brush value);
    public Brush get_MousePressedForeground();
    public void set_MousePressedForeground(Brush value);
}
public enum Xceed.Wpf.Toolkit.InsertKeyMode : Enum {
    public int value__;
    public static InsertKeyMode Default;
    public static InsertKeyMode Insert;
    public static InsertKeyMode Overwrite;
}
public class Xceed.Wpf.Toolkit.IntegerUpDown : CommonNumericUpDown`1<int> {
    private static IntegerUpDown();
    protected virtual int IncrementValue(int value, int increment);
    protected virtual int DecrementValue(int value, int increment);
}
public interface Xceed.Wpf.Toolkit.IRichTextBoxFormatBar {
    public RichTextBox Target { get; public set; }
    public bool PreventDisplayFadeOut { get; }
    public abstract virtual RichTextBox get_Target();
    public abstract virtual void set_Target(RichTextBox value);
    public abstract virtual bool get_PreventDisplayFadeOut();
    public abstract virtual void Update();
}
public class Xceed.Wpf.Toolkit.ItemAddingEventArgs : CancelRoutedEventArgs {
    [CompilerGeneratedAttribute]
private object <Item>k__BackingField;
    public object Item { get; public set; }
    public ItemAddingEventArgs(RoutedEvent itemAddingEvent, object itemAdding);
    [CompilerGeneratedAttribute]
public object get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(object value);
}
public class Xceed.Wpf.Toolkit.ItemDeletingEventArgs : CancelRoutedEventArgs {
    private object _item;
    public object Item { get; }
    public ItemDeletingEventArgs(RoutedEvent itemDeletingEvent, object itemDeleting);
    public object get_Item();
}
public class Xceed.Wpf.Toolkit.ItemEventArgs : RoutedEventArgs {
    private object _item;
    public object Item { get; }
    internal ItemEventArgs(RoutedEvent routedEvent, object newItem);
    public object get_Item();
}
public interface Xceed.Wpf.Toolkit.ITextFormatter {
    public abstract virtual string GetText(FlowDocument document);
    public abstract virtual void SetText(FlowDocument document, string text);
}
public enum Xceed.Wpf.Toolkit.Location : Enum {
    public int value__;
    public static Location Left;
    public static Location Right;
}
public class Xceed.Wpf.Toolkit.LongUpDown : CommonNumericUpDown`1<long> {
    private static LongUpDown();
    protected virtual long IncrementValue(long value, long increment);
    protected virtual long DecrementValue(long value, long increment);
}
public class Xceed.Wpf.Toolkit.Mag.Converters.RadiusConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.Magnifier : Control {
    private static double DEFAULT_SIZE;
    private static string PART_VisualBrush;
    private VisualBrush _visualBrush;
    public static DependencyProperty FrameTypeProperty;
    public static DependencyProperty IsUsingZoomOnMouseWheelProperty;
    [CompilerGeneratedAttribute]
private bool <IsFrozen>k__BackingField;
    public static DependencyProperty RadiusProperty;
    public static DependencyProperty TargetProperty;
    public static DependencyProperty ZoomFactorProperty;
    public static DependencyProperty ZoomFactorOnMouseWheelProperty;
    public FrameType FrameType { get; public set; }
    public bool IsUsingZoomOnMouseWheel { get; public set; }
    public bool IsFrozen { get; private set; }
    public double Radius { get; public set; }
    public UIElement Target { get; public set; }
    internal Rect ViewBox { get; internal set; }
    public double ZoomFactor { get; public set; }
    public double ZoomFactorOnMouseWheel { get; public set; }
    private static Magnifier();
    public FrameType get_FrameType();
    public void set_FrameType(FrameType value);
    private static void OnFrameTypeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnFrameTypeChanged(FrameType oldValue, FrameType newValue);
    public bool get_IsUsingZoomOnMouseWheel();
    public void set_IsUsingZoomOnMouseWheel(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFrozen();
    [CompilerGeneratedAttribute]
private void set_IsFrozen(bool value);
    public double get_Radius();
    public void set_Radius(double value);
    private static void OnRadiusPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnRadiusChanged(DependencyPropertyChangedEventArgs e);
    public UIElement get_Target();
    public void set_Target(UIElement value);
    internal Rect get_ViewBox();
    internal void set_ViewBox(Rect value);
    public double get_ZoomFactor();
    public void set_ZoomFactor(double value);
    private static bool OnValidationCallback(object baseValue);
    private static void OnZoomFactorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnZoomFactorChanged(DependencyPropertyChangedEventArgs e);
    public double get_ZoomFactorOnMouseWheel();
    public void set_ZoomFactorOnMouseWheel(double value);
    private static bool OnZoomFactorOnMouseWheelValidationCallback(object baseValue);
    private static void OnZoomFactorOnMouseWheelPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnZoomFactorOnMouseWheelChanged(DependencyPropertyChangedEventArgs e);
    private void OnSizeChangedEvent(object sender, SizeChangedEventArgs e);
    private void UpdateSizeFromRadius();
    public virtual void OnApplyTemplate();
    public void Freeze(bool freeze);
    private void UpdateViewBox();
}
public class Xceed.Wpf.Toolkit.MagnifierAdorner : Adorner {
    private Magnifier _magnifier;
    private Point _currentMousePosition;
    private double _currentZoomFactor;
    protected int VisualChildrenCount { get; }
    public MagnifierAdorner(UIElement element, Magnifier magnifier);
    private void OnProcessInput(object sender, ProcessInputEventArgs e);
    internal void UpdateViewBox();
    private Point CalculateViewBoxLocation();
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object s, RoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_1(object s, RoutedEventArgs e);
}
public class Xceed.Wpf.Toolkit.MagnifierManager : DependencyObject {
    private MagnifierAdorner _adorner;
    private UIElement _element;
    public static DependencyProperty CurrentProperty;
    private static MagnifierManager();
    public static void SetMagnifier(UIElement element, Magnifier value);
    public static Magnifier GetMagnifier(UIElement element);
    private static void OnMagnifierChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void Element_MouseLeave(object sender, MouseEventArgs e);
    private void Element_MouseEnter(object sender, MouseEventArgs e);
    private void Element_MouseWheel(object sender, MouseWheelEventArgs e);
    private void AttachToMagnifier(UIElement element, Magnifier magnifier);
    private void ShowAdorner();
    private bool VerifyAdornerLayer();
    private void HideAdorner();
}
public class Xceed.Wpf.Toolkit.MaskedTextBox : ValueRangeTextBox {
    private static Char[] MaskChars;
    private static char DefaultPasswordChar;
    private static string NullMaskString;
    public static DependencyProperty AllowPromptAsInputProperty;
    public static DependencyProperty ClipboardMaskFormatProperty;
    public static DependencyProperty HidePromptOnLeaveProperty;
    public static DependencyProperty IncludeLiteralsInValueProperty;
    public static DependencyProperty IncludePromptInValueProperty;
    public static DependencyProperty InsertKeyModeProperty;
    private static DependencyPropertyKey IsMaskCompletedPropertyKey;
    public static DependencyProperty IsMaskCompletedProperty;
    private static DependencyPropertyKey IsMaskFullPropertyKey;
    public static DependencyProperty IsMaskFullProperty;
    public static DependencyProperty MaskProperty;
    public static DependencyProperty PromptCharProperty;
    public static DependencyProperty RejectInputOnFirstFailureProperty;
    public static DependencyProperty ResetOnPromptProperty;
    public static DependencyProperty ResetOnSpaceProperty;
    public static DependencyProperty RestrictToAsciiProperty;
    public static DependencyProperty SkipLiteralsProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<AutoCompletingMaskEventArgs> AutoCompletingMask;
    private MaskedTextProvider m_maskedTextProvider;
    private bool m_insertToggled;
    private bool m_maskIsNull;
    private bool m_forcingMask;
    private List`1<int> m_unhandledLiteralsPositions;
    private string m_formatSpecifier;
    private MethodInfo m_valueToStringMethodInfo;
    public bool AllowPromptAsInput { get; public set; }
    public MaskFormat ClipboardMaskFormat { get; public set; }
    public bool HidePromptOnLeave { get; public set; }
    public bool IncludeLiteralsInValue { get; public set; }
    public bool IncludePromptInValue { get; public set; }
    public InsertKeyMode InsertKeyMode { get; public set; }
    public bool IsMaskCompleted { get; }
    public bool IsMaskFull { get; }
    public string Mask { get; public set; }
    public MaskedTextProvider MaskedTextProvider { get; }
    public char PromptChar { get; public set; }
    public bool RejectInputOnFirstFailure { get; public set; }
    public bool ResetOnPrompt { get; public set; }
    public bool ResetOnSpace { get; public set; }
    public bool RestrictToAscii { get; public set; }
    public bool SkipLiterals { get; public set; }
    internal bool IsForcingMask { get; }
    internal string FormatSpecifier { get; internal set; }
    internal bool IsTextReadyToBeParsed { get; }
    private bool IsOverwriteMode { get; }
    private string MaskedTextOutput { get; }
    private static MaskedTextBox();
    private static string GetRawText(MaskedTextProvider provider);
    public static string GetFormatSpecifierFromMask(string mask, IFormatProvider formatProvider);
    private static string GetFormatSpecifierFromMask(string mask, Char[] maskChars, IFormatProvider formatProvider, bool includeNonSeparatorLiteralsInValue, List`1& unhandledLiteralsPositions);
    private void InitializeMaskedTextProvider();
    protected virtual void OnInitialized(EventArgs e);
    public bool get_AllowPromptAsInput();
    public void set_AllowPromptAsInput(bool value);
    private static void AllowPromptAsInputPropertyChangedCallback(object sender, DependencyPropertyChangedEventArgs e);
    public MaskFormat get_ClipboardMaskFormat();
    public void set_ClipboardMaskFormat(MaskFormat value);
    public bool get_HidePromptOnLeave();
    public void set_HidePromptOnLeave(bool value);
    public bool get_IncludeLiteralsInValue();
    public void set_IncludeLiteralsInValue(bool value);
    private static void InlcudeLiteralsInValuePropertyChangedCallback(object sender, DependencyPropertyChangedEventArgs e);
    public bool get_IncludePromptInValue();
    public void set_IncludePromptInValue(bool value);
    private static void IncludePromptInValuePropertyChangedCallback(object sender, DependencyPropertyChangedEventArgs e);
    public InsertKeyMode get_InsertKeyMode();
    public void set_InsertKeyMode(InsertKeyMode value);
    public bool get_IsMaskCompleted();
    private void SetIsMaskCompleted(bool value);
    public bool get_IsMaskFull();
    private void SetIsMaskFull(bool value);
    public string get_Mask();
    public void set_Mask(string value);
    private static object MaskCoerceValueCallback(DependencyObject sender, object value);
    private static void MaskPropertyChangedCallback(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    public MaskedTextProvider get_MaskedTextProvider();
    public char get_PromptChar();
    public void set_PromptChar(char value);
    private static object PromptCharCoerceValueCallback(object sender, object value);
    private static void PromptCharPropertyChangedCallback(object sender, DependencyPropertyChangedEventArgs e);
    public bool get_RejectInputOnFirstFailure();
    public void set_RejectInputOnFirstFailure(bool value);
    public bool get_ResetOnPrompt();
    public void set_ResetOnPrompt(bool value);
    private static void ResetOnPromptPropertyChangedCallback(object sender, DependencyPropertyChangedEventArgs e);
    public bool get_ResetOnSpace();
    public void set_ResetOnSpace(bool value);
    private static void ResetOnSpacePropertyChangedCallback(object sender, DependencyPropertyChangedEventArgs e);
    public bool get_RestrictToAscii();
    public void set_RestrictToAscii(bool value);
    private static object RestrictToAsciiCoerceValueCallback(object sender, object value);
    private static void RestrictToAsciiPropertyChangedCallback(object sender, DependencyPropertyChangedEventArgs e);
    public bool get_SkipLiterals();
    public void set_SkipLiterals(bool value);
    private static void SkipLiteralsPropertyChangedCallback(object sender, DependencyPropertyChangedEventArgs e);
    private static object TextCoerceValueCallback(DependencyObject sender, object value);
    private string ValidateText(string text);
    protected virtual void OnTextChanged(TextChangedEventArgs e);
    private void OnPreviewCanExecuteCommands(object sender, CanExecuteRoutedEventArgs e);
    private void OnPreviewExecutedCommands(object sender, ExecutedRoutedEventArgs e);
    private void CanExecuteDelete(object sender, CanExecuteRoutedEventArgs e);
    private void CanExecuteDeletePreviousWord(object sender, CanExecuteRoutedEventArgs e);
    private void CanExecuteDeleteNextWord(object sender, CanExecuteRoutedEventArgs e);
    private void CanExecuteBackspace(object sender, CanExecuteRoutedEventArgs e);
    private void CanExecuteCut(object sender, CanExecuteRoutedEventArgs e);
    private void CanExecutePaste(object sender, CanExecuteRoutedEventArgs e);
    private void CanExecuteCopy(object sender, CanExecuteRoutedEventArgs e);
    private void ExecuteCopy();
    private void ToggleInsertExecutedCallback(object sender, ExecutedRoutedEventArgs e);
    private void PreviewQueryContinueDragCallback(object sender, QueryContinueDragEventArgs e);
    protected virtual void OnDragEnter(DragEventArgs e);
    protected virtual void OnDragOver(DragEventArgs e);
    protected virtual bool QueryValueFromTextCore(string text, Object& value);
    protected virtual string QueryTextFromValueCore(object value);
    protected virtual Char[] GetMaskCharacters();
    private MaskedTextProvider CreateMaskedTextProvider(string mask);
    protected virtual MaskedTextProvider CreateMaskedTextProvider(string mask, CultureInfo cultureInfo, bool allowPromptAsInput, char promptChar, char passwordChar, bool restrictToAscii);
    internal virtual void OnIMECompositionEnded(CachedTextInfo cachedTextInfo);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    private void ProcessTextInput(string text);
    protected virtual void ValidateValue(object value);
    internal bool get_IsForcingMask();
    internal string get_FormatSpecifier();
    internal void set_FormatSpecifier(string value);
    internal virtual bool get_IsTextReadyToBeParsed();
    internal virtual bool GetIsEditTextEmpty();
    internal virtual string GetCurrentText();
    internal virtual string GetParsableText();
    internal virtual void OnFormatProviderChanged();
    internal virtual void RefreshConversionHelpers();
    internal void SetValueToStringMethodInfo(MethodInfo valueToStringMethodInfo);
    internal void ForceMask(string mask);
    private bool get_IsOverwriteMode();
    private void PlayBeep();
    private bool PlaceChar(char ch, int startPosition, int length, bool overwrite, Int32& caretIndex);
    private bool PlaceChar(MaskedTextProvider provider, char ch, int startPosition, int length, bool overwrite, Int32& caretPosition);
    private bool ShouldQueryAutoCompleteMask(MaskedTextProvider provider, char ch, int startPosition);
    protected virtual void OnAutoCompletingMask(AutoCompletingMaskEventArgs e);
    [CompilerGeneratedAttribute]
public void add_AutoCompletingMask(EventHandler`1<AutoCompletingMaskEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AutoCompletingMask(EventHandler`1<AutoCompletingMaskEventArgs> value);
    private bool PlaceCharCore(MaskedTextProvider provider, char ch, int startPosition, int length, bool overwrite, Int32& caretPosition);
    internal void Replace(string text, int startPosition, int selectionLength);
    internal virtual bool CanReplace(MaskedTextProvider provider, string text, int startPosition, int selectionLength, bool rejectInputOnFirstFailure, Int32& tentativeCaretIndex);
    private bool CanDelete(int startPosition, int selectionLength, bool deleteForward, MaskedTextProvider provider);
    private void Delete(int startPosition, int selectionLength, bool deleteForward);
    private string get_MaskedTextOutput();
    private string GetRawText();
    private string GetFormattedString(MaskedTextProvider provider, string text);
    private string GetSelectedText();
}
public enum Xceed.Wpf.Toolkit.MaskFormat : Enum {
    public int value__;
    public static MaskFormat ExcludePromptAndLiterals;
    public static MaskFormat IncludeLiterals;
    public static MaskFormat IncludePrompt;
    public static MaskFormat IncludePromptAndLiterals;
}
[TypeConverterAttribute("Xceed.Wpf.Toolkit.Media.Animation.AnimationRateConverter")]
public class Xceed.Wpf.Toolkit.Media.Animation.AnimationRate : ValueType {
    private static AnimationRate _default;
    private long _duration;
    private double _speed;
    private RateType _rateType;
    public static AnimationRate Default { get; }
    public bool HasDuration { get; }
    public TimeSpan Duration { get; }
    public bool HasSpeed { get; }
    public double Speed { get; }
    public AnimationRate(TimeSpan duration);
    public AnimationRate(double speed);
    private AnimationRate(bool ignore);
    private static AnimationRate();
    public static AnimationRate get_Default();
    public bool get_HasDuration();
    public TimeSpan get_Duration();
    public bool get_HasSpeed();
    public double get_Speed();
    public AnimationRate Add(AnimationRate animationRate);
    public virtual bool Equals(object value);
    public bool Equals(AnimationRate animationRate);
    public static bool Equals(AnimationRate t1, AnimationRate t2);
    public virtual int GetHashCode();
    public AnimationRate Subtract(AnimationRate animationRate);
    public virtual string ToString();
    public static AnimationRate op_Implicit(TimeSpan duration);
    public static AnimationRate op_Implicit(double speed);
    public static AnimationRate op_Implicit(int speed);
    public static AnimationRate op_Addition(AnimationRate t1, AnimationRate t2);
    public static AnimationRate op_Subtraction(AnimationRate t1, AnimationRate t2);
    public static bool op_Equality(AnimationRate t1, AnimationRate t2);
    public static bool op_Inequality(AnimationRate t1, AnimationRate t2);
    public static bool op_GreaterThan(AnimationRate t1, AnimationRate t2);
    public static bool op_GreaterThanOrEqual(AnimationRate t1, AnimationRate t2);
    public static bool op_LessThan(AnimationRate t1, AnimationRate t2);
    public static bool op_LessThanOrEqual(AnimationRate t1, AnimationRate t2);
    public static int Compare(AnimationRate t1, AnimationRate t2);
    public static AnimationRate Plus(AnimationRate animationRate);
    public static AnimationRate op_UnaryPlus(AnimationRate animationRate);
}
public class Xceed.Wpf.Toolkit.Media.Animation.AnimationRateConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
public class Xceed.Wpf.Toolkit.Media.Animation.IterativeAnimationEquationDelegate`1 : MulticastDelegate {
    public IterativeAnimationEquationDelegate`1(object object, IntPtr method);
    public virtual T Invoke(TimeSpan currentTime, T from, T to, TimeSpan duration);
    public virtual IAsyncResult BeginInvoke(TimeSpan currentTime, T from, T to, TimeSpan duration, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("Xceed.Wpf.Toolkit.Media.Animation.IterativeEquationConverter")]
public class Xceed.Wpf.Toolkit.Media.Animation.IterativeEquation`1 : object {
    private IterativeAnimationEquationDelegate`1<T> _equation;
    public IterativeEquation`1(IterativeAnimationEquationDelegate`1<T> equation);
    public virtual T Evaluate(TimeSpan currentTime, T from, T to, TimeSpan duration);
}
public class Xceed.Wpf.Toolkit.Media.Animation.IterativeEquationConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value);
}
public class Xceed.Wpf.Toolkit.Media.Animation.PennerEquation : IterativeEquation`1<double> {
    private PennerEquationDelegate _pennerImpl;
    internal PennerEquation(PennerEquationDelegate pennerImpl);
    public virtual double Evaluate(TimeSpan currentTime, double from, double to, TimeSpan duration);
}
public static class Xceed.Wpf.Toolkit.Media.Animation.PennerEquations : object {
    private static PennerEquation _backEaseIn;
    private static PennerEquation _backEaseInOut;
    private static PennerEquation _backEaseOut;
    private static PennerEquation _bounceEaseIn;
    private static PennerEquation _bounceEaseInOut;
    private static PennerEquation _bounceEaseOut;
    private static PennerEquation _circEaseIn;
    private static PennerEquation _circEaseInOut;
    private static PennerEquation _circEaseOut;
    private static PennerEquation _cubicEaseIn;
    private static PennerEquation _cubicEaseInOut;
    private static PennerEquation _cubicEaseOut;
    private static PennerEquation _elasticEaseIn;
    private static PennerEquation _elasticEaseInOut;
    private static PennerEquation _elasticEaseOut;
    private static PennerEquation _expoEaseIn;
    private static PennerEquation _expoEaseInOut;
    private static PennerEquation _expoEaseOut;
    private static PennerEquation _linear;
    private static PennerEquation _quadEaseIn;
    private static PennerEquation _quadEaseInOut;
    private static PennerEquation _quadEaseOut;
    private static PennerEquation _quartEaseIn;
    private static PennerEquation _quartEaseInOut;
    private static PennerEquation _quartEaseOut;
    private static PennerEquation _quintEaseIn;
    private static PennerEquation _quintEaseInOut;
    private static PennerEquation _quintEaseOut;
    private static PennerEquation _sineEaseIn;
    private static PennerEquation _sineEaseInOut;
    private static PennerEquation _sineEaseOut;
    public static PennerEquation BackEaseIn { get; }
    public static PennerEquation BackEaseInOut { get; }
    public static PennerEquation BackEaseOut { get; }
    public static PennerEquation BounceEaseIn { get; }
    public static PennerEquation BounceEaseInOut { get; }
    public static PennerEquation BounceEaseOut { get; }
    public static PennerEquation CircEaseIn { get; }
    public static PennerEquation CircEaseInOut { get; }
    public static PennerEquation CircEaseOut { get; }
    public static PennerEquation CubicEaseIn { get; }
    public static PennerEquation CubicEaseInOut { get; }
    public static PennerEquation CubicEaseOut { get; }
    public static PennerEquation ElasticEaseIn { get; }
    public static PennerEquation ElasticEaseInOut { get; }
    public static PennerEquation ElasticEaseOut { get; }
    public static PennerEquation ExpoEaseIn { get; }
    public static PennerEquation ExpoEaseInOut { get; }
    public static PennerEquation ExpoEaseOut { get; }
    public static PennerEquation Linear { get; }
    public static PennerEquation QuadEaseIn { get; }
    public static PennerEquation QuadEaseInOut { get; }
    public static PennerEquation QuadEaseOut { get; }
    public static PennerEquation QuartEaseIn { get; }
    public static PennerEquation QuartEaseInOut { get; }
    public static PennerEquation QuartEaseOut { get; }
    public static PennerEquation QuintEaseIn { get; }
    public static PennerEquation QuintEaseInOut { get; }
    public static PennerEquation QuintEaseOut { get; }
    public static PennerEquation SineEaseIn { get; }
    public static PennerEquation SineEaseInOut { get; }
    public static PennerEquation SineEaseOut { get; }
    public static PennerEquation get_BackEaseIn();
    public static PennerEquation get_BackEaseInOut();
    public static PennerEquation get_BackEaseOut();
    public static PennerEquation get_BounceEaseIn();
    public static PennerEquation get_BounceEaseInOut();
    public static PennerEquation get_BounceEaseOut();
    public static PennerEquation get_CircEaseIn();
    public static PennerEquation get_CircEaseInOut();
    public static PennerEquation get_CircEaseOut();
    public static PennerEquation get_CubicEaseIn();
    public static PennerEquation get_CubicEaseInOut();
    public static PennerEquation get_CubicEaseOut();
    public static PennerEquation get_ElasticEaseIn();
    public static PennerEquation get_ElasticEaseInOut();
    public static PennerEquation get_ElasticEaseOut();
    public static PennerEquation get_ExpoEaseIn();
    public static PennerEquation get_ExpoEaseInOut();
    public static PennerEquation get_ExpoEaseOut();
    public static PennerEquation get_Linear();
    public static PennerEquation get_QuadEaseIn();
    public static PennerEquation get_QuadEaseInOut();
    public static PennerEquation get_QuadEaseOut();
    public static PennerEquation get_QuartEaseIn();
    public static PennerEquation get_QuartEaseInOut();
    public static PennerEquation get_QuartEaseOut();
    public static PennerEquation get_QuintEaseIn();
    public static PennerEquation get_QuintEaseInOut();
    public static PennerEquation get_QuintEaseOut();
    public static PennerEquation get_SineEaseIn();
    public static PennerEquation get_SineEaseInOut();
    public static PennerEquation get_SineEaseOut();
    private static double BackEaseOutImpl(double t, double b, double c, double d);
    private static double BackEaseInImpl(double t, double b, double c, double d);
    private static double BackEaseInOutImpl(double t, double b, double c, double d);
    private static double BounceEaseOutImpl(double t, double b, double c, double d);
    private static double BounceEaseInImpl(double t, double b, double c, double d);
    private static double BounceEaseInOutImpl(double t, double b, double c, double d);
    private static double CircEaseOutImpl(double t, double b, double c, double d);
    private static double CircEaseInImpl(double t, double b, double c, double d);
    private static double CircEaseInOutImpl(double t, double b, double c, double d);
    private static double CubicEaseOutImpl(double t, double b, double c, double d);
    private static double CubicEaseInImpl(double t, double b, double c, double d);
    private static double CubicEaseInOutImpl(double t, double b, double c, double d);
    private static double ElasticEaseOutImpl(double t, double b, double c, double d);
    private static double ElasticEaseInImpl(double t, double b, double c, double d);
    private static double ElasticEaseInOutImpl(double t, double b, double c, double d);
    private static double ExpoEaseOutImpl(double t, double b, double c, double d);
    private static double ExpoEaseInImpl(double t, double b, double c, double d);
    private static double ExpoEaseInOutImpl(double t, double b, double c, double d);
    private static double LinearImpl(double t, double b, double c, double d);
    private static double QuadEaseOutImpl(double t, double b, double c, double d);
    private static double QuadEaseInImpl(double t, double b, double c, double d);
    private static double QuadEaseInOutImpl(double t, double b, double c, double d);
    private static double QuartEaseOutImpl(double t, double b, double c, double d);
    private static double QuartEaseInImpl(double t, double b, double c, double d);
    private static double QuartEaseInOutImpl(double t, double b, double c, double d);
    private static double QuintEaseOutImpl(double t, double b, double c, double d);
    private static double QuintEaseInImpl(double t, double b, double c, double d);
    private static double QuintEaseInOutImpl(double t, double b, double c, double d);
    private static double SineEaseOutImpl(double t, double b, double c, double d);
    private static double SineEaseInImpl(double t, double b, double c, double d);
    private static double SineEaseInOutImpl(double t, double b, double c, double d);
}
[TemplateVisualStateAttribute]
[TemplateVisualStateAttribute]
[TemplateVisualStateAttribute]
[TemplateVisualStateAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.MessageBox : WindowControl {
    private static string PART_CancelButton;
    private static string PART_NoButton;
    private static string PART_OkButton;
    private static string PART_YesButton;
    private static string PART_CloseButton;
    private static string PART_WindowControl;
    private MessageBoxButton _button;
    private MessageBoxResult _defaultResult;
    private MessageBoxResult _dialogResult;
    private Window _owner;
    private IntPtr _ownerHandle;
    private WindowControl _windowControl;
    public static DependencyProperty ButtonRegionBackgroundProperty;
    public static DependencyProperty CancelButtonContentProperty;
    public static DependencyProperty CancelButtonStyleProperty;
    public static DependencyProperty ImageSourceProperty;
    public static DependencyProperty OkButtonContentProperty;
    public static DependencyProperty OkButtonStyleProperty;
    public static DependencyProperty NoButtonContentProperty;
    public static DependencyProperty NoButtonStyleProperty;
    public static DependencyProperty TextProperty;
    public static DependencyProperty YesButtonContentProperty;
    public static DependencyProperty YesButtonStyleProperty;
    [CompilerGeneratedAttribute]
private EventHandler Closed;
    protected Window Container { get; }
    public Brush ButtonRegionBackground { get; public set; }
    public object CancelButtonContent { get; public set; }
    public Style CancelButtonStyle { get; public set; }
    public ImageSource ImageSource { get; public set; }
    public object OkButtonContent { get; public set; }
    public Style OkButtonStyle { get; public set; }
    public MessageBoxResult MessageBoxResult { get; }
    public object NoButtonContent { get; public set; }
    public Style NoButtonStyle { get; public set; }
    public string Text { get; public set; }
    public object YesButtonContent { get; public set; }
    public Style YesButtonStyle { get; public set; }
    internal bool AllowPublicIsActiveChange { get; }
    private static MessageBox();
    protected Window get_Container();
    public Brush get_ButtonRegionBackground();
    public void set_ButtonRegionBackground(Brush value);
    public object get_CancelButtonContent();
    public void set_CancelButtonContent(object value);
    public Style get_CancelButtonStyle();
    public void set_CancelButtonStyle(Style value);
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    public object get_OkButtonContent();
    public void set_OkButtonContent(object value);
    public Style get_OkButtonStyle();
    public void set_OkButtonStyle(Style value);
    public MessageBoxResult get_MessageBoxResult();
    public object get_NoButtonContent();
    public void set_NoButtonContent(object value);
    public Style get_NoButtonStyle();
    public void set_NoButtonStyle(Style value);
    public string get_Text();
    public void set_Text(string value);
    public object get_YesButtonContent();
    public void set_YesButtonContent(object value);
    public Style get_YesButtonStyle();
    public void set_YesButtonStyle(Style value);
    internal virtual bool get_AllowPublicIsActiveChange();
    public virtual void OnApplyTemplate();
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual object OnCoerceCloseButtonVisibility(Visibility newValue);
    protected virtual object OnCoerceWindowStyle(WindowStyle newValue);
    internal virtual void UpdateBlockMouseInputsPanel();
    public static MessageBoxResult Show(string messageText);
    public static MessageBoxResult Show(Window owner, string messageText);
    public static MessageBoxResult Show(string messageText, string caption);
    public static MessageBoxResult Show(Window owner, string messageText, string caption);
    public static MessageBoxResult Show(Window owner, string messageText, string caption, Style messageBoxStyle);
    public static MessageBoxResult Show(string messageText, string caption, MessageBoxButton button);
    public static MessageBoxResult Show(string messageText, string caption, MessageBoxButton button, Style messageBoxStyle);
    public static MessageBoxResult Show(Window owner, string messageText, string caption, MessageBoxButton button);
    public static MessageBoxResult Show(Window owner, string messageText, string caption, MessageBoxButton button, Style messageBoxStyle);
    public static MessageBoxResult Show(string messageText, string caption, MessageBoxButton button, MessageBoxImage icon);
    public static MessageBoxResult Show(string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, Style messageBoxStyle);
    public static MessageBoxResult Show(Window owner, string messageText, string caption, MessageBoxButton button, MessageBoxImage icon);
    public static MessageBoxResult Show(Window owner, string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, Style messageBoxStyle);
    public static MessageBoxResult Show(string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult);
    public static MessageBoxResult Show(string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, Style messageBoxStyle);
    public static MessageBoxResult Show(Window owner, string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult);
    public static MessageBoxResult Show(Window owner, string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, Style messageBoxStyle);
    public static MessageBoxResult Show(IntPtr ownerWindowHandle, string messageText);
    public static MessageBoxResult Show(IntPtr ownerWindowHandle, string messageText, string caption);
    public static MessageBoxResult Show(IntPtr ownerWindowHandle, string messageText, string caption, Style messageBoxStyle);
    public static MessageBoxResult Show(IntPtr ownerWindowHandle, string messageText, string caption, MessageBoxButton button);
    public static MessageBoxResult Show(IntPtr ownerWindowHandle, string messageText, string caption, MessageBoxButton button, Style messageBoxStyle);
    public static MessageBoxResult Show(IntPtr ownerWindowHandle, string messageText, string caption, MessageBoxButton button, MessageBoxImage icon);
    public static MessageBoxResult Show(IntPtr ownerWindowHandle, string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, Style messageBoxStyle);
    public static MessageBoxResult Show(IntPtr ownerWindowHandle, string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult);
    public static MessageBoxResult Show(IntPtr ownerWindowHandle, string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, Style messageBoxStyle);
    public void ShowMessageBox();
    public void ShowMessageBox(string messageText);
    public void ShowMessageBox(string messageText, string caption);
    public void ShowMessageBox(string messageText, string caption, MessageBoxButton button);
    public void ShowMessageBox(string messageText, string caption, MessageBoxButton button, MessageBoxImage icon);
    public void ShowMessageBox(string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult);
    public Nullable`1<bool> ShowDialog();
    protected void InitializeMessageBox(Window owner, IntPtr ownerHandle, string text, string caption, MessageBoxButton button, MessageBoxImage image, MessageBoxResult defaultResult);
    protected void ChangeVisualState(string name, bool useTransitions);
    private bool IsCurrentWindow(object windowtoTest);
    private void Close();
    private void SetDefaultResult();
    private Button GetDefaultButtonFromDefaultResult();
    private Button GetDefaultButton();
    private Button GetMessageBoxButton(string name);
    private void ShowMessageBoxCore(string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult);
    private void InitHandlers();
    private static MessageBoxResult ShowCore(Window owner, IntPtr ownerHandle, string messageText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, Style messageBoxStyle);
    private static Window ComputeOwnerWindow();
    private static Window ComputeOwnerWindowCore();
    private void SetImageSource(MessageBoxImage image);
    private Window CreateContainer();
    protected virtual void OnHeaderDragDelta(DragDeltaEventArgs e);
    protected virtual void OnHeaderIconDoubleClicked(MouseButtonEventArgs e);
    protected virtual void OnCloseButtonClicked(RoutedEventArgs e);
    private void Button_Click(object sender, RoutedEventArgs e);
    private void OnContainerClosed(object sender, EventArgs e);
    private void OnClose();
    private void MessageBox_IsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Closed(EventHandler value);
    protected virtual void OnClosed(EventArgs e);
    private void ExecuteCopy(object sender, ExecutedRoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__64_0(object o, DragDeltaEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__64_1(object o, MouseButtonEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__64_2(object o, RoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__64_3(object o, DragDeltaEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__64_4(object o, MouseButtonEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnApplyTemplate>b__64_5(object o, RoutedEventArgs e);
    [CompilerGeneratedAttribute]
private void <MessageBox_IsVisibleChanged>b__124_0();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.MultiLineTextEditor : ContentControl {
    private static string PART_ResizeThumb;
    private static string PART_TextBox;
    private static string PART_DropDownButton;
    private Thumb _resizeThumb;
    private TextBox _textBox;
    private ToggleButton _toggleButton;
    public static DependencyProperty DropDownHeightProperty;
    public static DependencyProperty DropDownWidthProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty IsSpellCheckEnabledProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty TextProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty TextWrappingProperty;
    public double DropDownHeight { get; public set; }
    public double DropDownWidth { get; public set; }
    public bool IsOpen { get; public set; }
    public bool IsSpellCheckEnabled { get; public set; }
    public bool IsReadOnly { get; public set; }
    public string Text { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public TextWrapping TextWrapping { get; public set; }
    private static MultiLineTextEditor();
    public double get_DropDownHeight();
    public void set_DropDownHeight(double value);
    public double get_DropDownWidth();
    public void set_DropDownWidth(double value);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    private static void OnIsOpenChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsOpenChanged(bool oldValue, bool newValue);
    public bool get_IsSpellCheckEnabled();
    public void set_IsSpellCheckEnabled(bool value);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public string get_Text();
    public void set_Text(string value);
    private static void OnTextChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTextChanged(string oldValue, string newValue);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public TextWrapping get_TextWrapping();
    public void set_TextWrapping(TextWrapping value);
    public virtual void OnApplyTemplate();
    private void OnKeyDown(object sender, KeyEventArgs e);
    private void OnMouseDownOutsideCapturedElement(object sender, MouseButtonEventArgs e);
    private void ResizeThumb_DragDelta(object sender, DragDeltaEventArgs e);
    private void CloseEditor();
    [CompilerGeneratedAttribute]
private void <OnIsOpenChanged>b__19_0();
}
public abstract class Xceed.Wpf.Toolkit.NumericUpDown`1 : UpDownBase`1<T> {
    public static DependencyProperty AutoMoveFocusProperty;
    public static DependencyProperty AutoSelectBehaviorProperty;
    public static DependencyProperty FormatStringProperty;
    public static DependencyProperty IncrementProperty;
    public static DependencyProperty MaxLengthProperty;
    public bool AutoMoveFocus { get; public set; }
    public AutoSelectBehavior AutoSelectBehavior { get; public set; }
    public string FormatString { get; public set; }
    public T Increment { get; public set; }
    public int MaxLength { get; public set; }
    private static NumericUpDown`1();
    public bool get_AutoMoveFocus();
    public void set_AutoMoveFocus(bool value);
    public AutoSelectBehavior get_AutoSelectBehavior();
    public void set_AutoSelectBehavior(AutoSelectBehavior value);
    public string get_FormatString();
    public void set_FormatString(string value);
    private static object OnCoerceFormatString(DependencyObject o, object baseValue);
    protected virtual string OnCoerceFormatString(string baseValue);
    private static void OnFormatStringChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnFormatStringChanged(string oldValue, string newValue);
    public T get_Increment();
    public void set_Increment(T value);
    private static void OnIncrementChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIncrementChanged(T oldValue, T newValue);
    private static object OnCoerceIncrement(DependencyObject d, object baseValue);
    protected virtual T OnCoerceIncrement(T baseValue);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    protected static decimal ParsePercent(string text, IFormatProvider cultureInfo);
}
[ObsoleteAttribute("Legacy implementation of MaskedTextBox. Use Xceed.Wpf.Toolkit.MaskedTextBox instead.", "False")]
public class Xceed.Wpf.Toolkit.Obselete.MaskedTextBox : TextBox {
    private bool _isSyncingTextAndValueProperties;
    private bool _isInitialized;
    private bool _convertExceptionOccurred;
    [CompilerGeneratedAttribute]
private MaskedTextProvider <MaskProvider>k__BackingField;
    public static DependencyProperty IncludePromptProperty;
    public static DependencyProperty IncludeLiteralsProperty;
    public static DependencyProperty MaskProperty;
    public static DependencyProperty PromptCharProperty;
    public static DependencyProperty SelectAllOnGotFocusProperty;
    public static DependencyProperty ValueProperty;
    public static DependencyProperty ValueTypeProperty;
    public static RoutedEvent ValueChangedEvent;
    protected MaskedTextProvider MaskProvider { get; protected set; }
    public bool IncludePrompt { get; public set; }
    public bool IncludeLiterals { get; public set; }
    public string Mask { get; public set; }
    public char PromptChar { get; public set; }
    public bool SelectAllOnGotFocus { get; public set; }
    public object Value { get; public set; }
    public Type ValueType { get; public set; }
    private static MaskedTextBox();
    [CompilerGeneratedAttribute]
protected MaskedTextProvider get_MaskProvider();
    [CompilerGeneratedAttribute]
protected void set_MaskProvider(MaskedTextProvider value);
    public bool get_IncludePrompt();
    public void set_IncludePrompt(bool value);
    private static void OnIncludePromptPropertyChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIncludePromptChanged(bool oldValue, bool newValue);
    public bool get_IncludeLiterals();
    public void set_IncludeLiterals(bool value);
    private static void OnIncludeLiteralsPropertyChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIncludeLiteralsChanged(bool oldValue, bool newValue);
    public string get_Mask();
    public void set_Mask(string value);
    private static void OnMaskPropertyChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMaskChanged(string oldValue, string newValue);
    public char get_PromptChar();
    public void set_PromptChar(char value);
    private static void OnPromptCharChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnPromptCharChanged(char oldValue, char newValue);
    public bool get_SelectAllOnGotFocus();
    public void set_SelectAllOnGotFocus(bool value);
    private static void OnTextChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTextChanged(string oldValue, string newValue);
    public object get_Value();
    public void set_Value(object value);
    private static void OnValueChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnValueChanged(object oldValue, object newValue);
    public Type get_ValueType();
    public void set_ValueType(Type value);
    private static void OnValueTypeChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnValueTypeChanged(Type oldValue, Type newValue);
    public virtual void OnApplyTemplate();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    public void add_ValueChanged(RoutedPropertyChangedEventHandler`1<object> value);
    public void remove_ValueChanged(RoutedPropertyChangedEventHandler`1<object> value);
    private void UpdateText();
    private void UpdateText(int position);
    private int GetNextCharacterPosition(int startPosition);
    private void UpdateMaskProvider(string mask);
    private object ConvertTextToValue(string text);
    private string ConvertValueToText(object value);
    private void SyncTextAndValueProperties(DependencyProperty p, object newValue);
    private void HandlePreviewTextInput(TextCompositionEventArgs e);
    private void HandlePreviewKeyDown(KeyEventArgs e);
    private bool HandleKeyDownDelete();
    private bool HandleKeyDownBack();
    private void InsertText(string text);
    private void RemoveTextFromStart(int endPosition);
    private void RemoveTextToEnd(int startPosition);
    private void RemoveText(int position, int length);
    private bool RemoveSelectedText();
    private void Paste(object sender, RoutedEventArgs e);
    private void CanCut(object sender, CanExecuteRoutedEventArgs e);
}
public enum Xceed.Wpf.Toolkit.OverlapBehavior : Enum {
    public int value__;
    public static OverlapBehavior Stack;
    public static OverlapBehavior Stretch;
    public static OverlapBehavior Hide;
    public static OverlapBehavior None;
}
public abstract class Xceed.Wpf.Toolkit.Panels.AnimationPanel : PanelBase {
    private static DependencyPropertyKey ChildStatePropertyKey;
    public static DependencyProperty DefaultAnimationRateProperty;
    public static DependencyProperty DefaultAnimatorProperty;
    public static DependencyProperty EnterAnimationRateProperty;
    public static DependencyProperty EnterAnimatorProperty;
    public static DependencyProperty EnterFromProperty;
    public static DependencyProperty ExitAnimationRateProperty;
    public static DependencyProperty ExitAnimatorProperty;
    public static DependencyProperty ExitToProperty;
    public static DependencyProperty LayoutAnimationRateProperty;
    public static DependencyProperty LayoutAnimatorProperty;
    public static DependencyProperty SwitchAnimationRateProperty;
    public static DependencyProperty SwitchAnimatorProperty;
    private static DependencyPropertyKey SwitchParentPropertyKey;
    public static DependencyProperty SwitchParentProperty;
    public static DependencyProperty SwitchTemplateProperty;
    public static DependencyProperty TemplateAnimationRateProperty;
    public static DependencyProperty TemplateAnimatorProperty;
    private Vector _physicalScrollOffset;
    private int _animatingChildCount;
    public static RoutedEvent AnimationBegunEvent;
    public static RoutedEvent AnimationCompletedEvent;
    public static RoutedEvent ChildEnteredEvent;
    public static RoutedEvent ChildEnteringEvent;
    public static RoutedEvent ChildExitedEvent;
    public static RoutedEvent ChildExitingEvent;
    public static RoutedEvent SwitchLayoutActivatedEvent;
    public static RoutedEvent SwitchLayoutDeactivatedEvent;
    private UIElementCollection _currentChildren;
    private Collection`1<FrameworkElement> _animatingGrandchildren;
    private SwitchPanel _switchParent;
    private List`1<UIElement> _exitingChildren;
    private BitVector32 _cacheBits;
    public AnimationRate DefaultAnimationRate { get; public set; }
    public IterativeAnimator DefaultAnimator { get; public set; }
    public AnimationRate EnterAnimationRate { get; public set; }
    public IterativeAnimator EnterAnimator { get; public set; }
    public AnimationRate ExitAnimationRate { get; public set; }
    public IterativeAnimator ExitAnimator { get; public set; }
    public AnimationRate LayoutAnimationRate { get; public set; }
    public IterativeAnimator LayoutAnimator { get; public set; }
    public AnimationRate SwitchAnimationRate { get; public set; }
    public IterativeAnimator SwitchAnimator { get; public set; }
    public SwitchPanel SwitchParent { get; }
    public DataTemplate SwitchTemplate { get; public set; }
    public AnimationRate TemplateAnimationRate { get; public set; }
    public IterativeAnimator TemplateAnimator { get; public set; }
    public Size DesiredSize { get; }
    public Size RenderSize { get; public set; }
    public bool IsActiveLayout { get; private set; }
    protected internal UIElementCollection InternalChildren { get; }
    protected int VisualChildrenCount { get; }
    protected PanelBase ChildrensParent { get; }
    internal int VisualChildrenCountInternal { get; }
    internal Vector PhysicalScrollOffset { get; internal set; }
    internal bool IsRemovingInternalChild { get; private set; }
    private int AnimatingChildCount { get; private set; }
    private bool EndSwitchOnAnimationCompleted { get; private set; }
    private bool HasArranged { get; private set; }
    protected bool HasLoaded { get; private set; }
    private bool IsSwitchInProgress { get; private set; }
    private ItemsControl ItemsOwner { get; }
    private List`1<UIElement> ExitingChildren { get; }
    private static AnimationPanel();
    private static ChildState GetChildState(DependencyObject d);
    private static void SetChildState(DependencyObject d, ChildState value);
    public AnimationRate get_DefaultAnimationRate();
    public void set_DefaultAnimationRate(AnimationRate value);
    private static bool ValidateDefaultAnimationRate(object value);
    public IterativeAnimator get_DefaultAnimator();
    public void set_DefaultAnimator(IterativeAnimator value);
    private static bool ValidateDefaultAnimator(object value);
    public AnimationRate get_EnterAnimationRate();
    public void set_EnterAnimationRate(AnimationRate value);
    public IterativeAnimator get_EnterAnimator();
    public void set_EnterAnimator(IterativeAnimator value);
    public static Nullable`1<Rect> GetEnterFrom(DependencyObject d);
    public static void SetEnterFrom(DependencyObject d, Nullable`1<Rect> value);
    public AnimationRate get_ExitAnimationRate();
    public void set_ExitAnimationRate(AnimationRate value);
    public IterativeAnimator get_ExitAnimator();
    public void set_ExitAnimator(IterativeAnimator value);
    public static Nullable`1<Rect> GetExitTo(DependencyObject d);
    public static void SetExitTo(DependencyObject d, Nullable`1<Rect> value);
    public AnimationRate get_LayoutAnimationRate();
    public void set_LayoutAnimationRate(AnimationRate value);
    public IterativeAnimator get_LayoutAnimator();
    public void set_LayoutAnimator(IterativeAnimator value);
    public AnimationRate get_SwitchAnimationRate();
    public void set_SwitchAnimationRate(AnimationRate value);
    public IterativeAnimator get_SwitchAnimator();
    public void set_SwitchAnimator(IterativeAnimator value);
    public SwitchPanel get_SwitchParent();
    protected internal void SetSwitchParent(SwitchPanel value);
    private static void OnSwitchParentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSwitchParentChanged(DependencyPropertyChangedEventArgs e);
    public DataTemplate get_SwitchTemplate();
    public void set_SwitchTemplate(DataTemplate value);
    private static void OnSwitchTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSwitchTemplateChanged(DependencyPropertyChangedEventArgs e);
    public AnimationRate get_TemplateAnimationRate();
    public void set_TemplateAnimationRate(AnimationRate value);
    public IterativeAnimator get_TemplateAnimator();
    public void set_TemplateAnimator(IterativeAnimator value);
    public Size get_DesiredSize();
    public Size get_RenderSize();
    public void set_RenderSize(Size value);
    public bool get_IsActiveLayout();
    private void set_IsActiveLayout(bool value);
    protected internal UIElementCollection get_InternalChildren();
    protected virtual int get_VisualChildrenCount();
    protected PanelBase get_ChildrensParent();
    internal int get_VisualChildrenCountInternal();
    internal Vector get_PhysicalScrollOffset();
    internal void set_PhysicalScrollOffset(Vector value);
    internal bool get_IsRemovingInternalChild();
    private void set_IsRemovingInternalChild(bool value);
    private int get_AnimatingChildCount();
    private void set_AnimatingChildCount(int value);
    private bool get_EndSwitchOnAnimationCompleted();
    private void set_EndSwitchOnAnimationCompleted(bool value);
    private bool get_HasArranged();
    private void set_HasArranged(bool value);
    protected bool get_HasLoaded();
    private void set_HasLoaded(bool value);
    private bool get_IsSwitchInProgress();
    private void set_IsSwitchInProgress(bool value);
    private ItemsControl get_ItemsOwner();
    private List`1<UIElement> get_ExitingChildren();
    public void add_AnimationBegun(RoutedEventHandler value);
    public void remove_AnimationBegun(RoutedEventHandler value);
    protected RoutedEventArgs RaiseAnimationBegunEvent();
    private static RoutedEventArgs RaiseAnimationBegunEvent(UIElement target);
    public void add_AnimationCompleted(RoutedEventHandler value);
    public void remove_AnimationCompleted(RoutedEventHandler value);
    protected RoutedEventArgs RaiseAnimationCompletedEvent();
    private static RoutedEventArgs RaiseAnimationCompletedEvent(UIElement target);
    public void add_ChildEntered(ChildEnteredEventHandler value);
    public void remove_ChildEntered(ChildEnteredEventHandler value);
    protected ChildEnteredEventArgs RaiseChildEnteredEvent(UIElement child, Rect arrangeRect);
    internal static ChildEnteredEventArgs RaiseChildEnteredEvent(UIElement target, UIElement child, Rect arrangeRect);
    public void add_ChildEntering(ChildEnteringEventHandler value);
    public void remove_ChildEntering(ChildEnteringEventHandler value);
    protected ChildEnteringEventArgs RaiseChildEnteringEvent(UIElement child, Nullable`1<Rect> EnterFrom, Rect ArrangeRect);
    private static ChildEnteringEventArgs RaiseChildEnteringEvent(UIElement target, UIElement child, Nullable`1<Rect> EnterFrom, Rect ArrangeRect);
    public void add_ChildExited(ChildExitedEventHandler value);
    public void remove_ChildExited(ChildExitedEventHandler value);
    protected ChildExitedEventArgs RaiseChildExitedEvent(UIElement child);
    private static ChildExitedEventArgs RaiseChildExitedEvent(UIElement target, UIElement child);
    public void add_ChildExiting(ChildExitingEventHandler value);
    public void remove_ChildExiting(ChildExitingEventHandler value);
    protected ChildExitingEventArgs RaiseChildExitingEvent(UIElement child, Nullable`1<Rect> exitTo, Rect arrangeRect);
    private static ChildExitingEventArgs RaiseChildExitingEvent(UIElement target, UIElement child, Nullable`1<Rect> exitTo, Rect arrangeRect);
    public void add_SwitchLayoutActivated(RoutedEventHandler value);
    public void remove_SwitchLayoutActivated(RoutedEventHandler value);
    protected RoutedEventArgs RaiseSwitchLayoutActivatedEvent();
    internal static RoutedEventArgs RaiseSwitchLayoutActivatedEvent(UIElement target);
    public void add_SwitchLayoutDeactivated(RoutedEventHandler value);
    public void remove_SwitchLayoutDeactivated(RoutedEventHandler value);
    protected RoutedEventArgs RaiseSwitchLayoutDeactivatedEvent();
    internal static RoutedEventArgs RaiseSwitchLayoutDeactivatedEvent(UIElement target);
    public void InvalidateArrange();
    public void InvalidateMeasure();
    public void InvalidateVisual();
    internal void ActivateLayout();
    internal void BeginChildExit(UIElement child);
    internal void BeginGrandchildAnimation(FrameworkElement grandchild, Rect currentRect, Rect placementRect);
    internal void DeactivateLayout();
    internal static UIElement FindAncestorChildOfAnimationPanel(DependencyObject element, AnimationPanel& panel);
    internal Dictionary`2<string, Rect> GetNewLocationsBasedOnTargetPlacement(SwitchPresenter presenter, UIElement parent);
    internal Visual GetVisualChildInternal(int index);
    internal void OnNotifyVisualChildAddedInternal(UIElement child);
    internal void OnNotifyVisualChildRemovedInternal(UIElement child);
    internal Size MeasureChildrenCore(UIElementCollection children, Size constraint);
    internal Size ArrangeChildrenCore(UIElementCollection children, Size finalSize);
    internal void OnSwitchParentVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    protected sealed virtual Size MeasureOverride(Size constraint);
    protected abstract virtual Size MeasureChildrenOverride(UIElementCollection children, Size constraint);
    protected sealed virtual Size ArrangeOverride(Size finalSize);
    protected abstract virtual Size ArrangeChildrenOverride(UIElementCollection children, Size finalSize);
    protected void ArrangeChild(UIElement child, Rect placementRect);
    protected void AddVisualChild(Visual child);
    protected virtual Visual GetVisualChild(int index);
    protected virtual void OnNotifyVisualChildAdded(UIElement child);
    protected virtual void OnNotifyVisualChildRemoved(UIElement child);
    protected virtual void OnSwitchLayoutActivated();
    protected virtual void OnSwitchLayoutDeactivated();
    protected virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    protected void RemoveVisualChild(Visual child);
    protected int FindChildFromVisual(Visual vis);
    private bool BeginChildAnimation(UIElement child, Rect placementRect);
    private void BeginChildEnter(UIElement child, ChildState state);
    private void EndChildEnter(UIElement child, ChildState state);
    private void EndChildExit(UIElement child, ChildState state);
    private ChildState EnsureChildState(UIElement child, Rect placementRect, Boolean& newStateCreated);
    internal AnimationRate GetEffectiveAnimationRate(AnimationType animationType);
    private IterativeAnimator GetEffectiveAnimator(AnimationType animationType);
    private void OnLoaded(object sender, RoutedEventArgs e);
    private void OnRendering(object sender, EventArgs e);
    private void UpdateExitingChildren();
    private void UpdateTrueArrange(UIElement child, ChildState state);
}
public class Xceed.Wpf.Toolkit.Panels.AnimatorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value);
}
public static class Xceed.Wpf.Toolkit.Panels.Animators : object {
    private static DoubleAnimator _backEaseIn;
    private static DoubleAnimator _backEaseInOut;
    private static DoubleAnimator _backEaseOut;
    private static DoubleAnimator _bounceEaseIn;
    private static DoubleAnimator _bounceEaseInOut;
    private static DoubleAnimator _bounceEaseOut;
    private static DoubleAnimator _circEaseIn;
    private static DoubleAnimator _circEaseInOut;
    private static DoubleAnimator _circEaseOut;
    private static DoubleAnimator _cubicEaseIn;
    private static DoubleAnimator _cubicEaseInOut;
    private static DoubleAnimator _cubicEaseOut;
    private static DoubleAnimator _elasticEaseIn;
    private static DoubleAnimator _elasticEaseInOut;
    private static DoubleAnimator _elasticEaseOut;
    private static DoubleAnimator _expoEaseIn;
    private static DoubleAnimator _expoEaseInOut;
    private static DoubleAnimator _expoEaseOut;
    private static DoubleAnimator _linear;
    private static DoubleAnimator _quadEaseIn;
    private static DoubleAnimator _quadEaseInOut;
    private static DoubleAnimator _quadEaseOut;
    private static DoubleAnimator _quartEaseIn;
    private static DoubleAnimator _quartEaseInOut;
    private static DoubleAnimator _quartEaseOut;
    private static DoubleAnimator _quintEaseIn;
    private static DoubleAnimator _quintEaseInOut;
    private static DoubleAnimator _quintEaseOut;
    private static DoubleAnimator _sineEaseIn;
    private static DoubleAnimator _sineEaseInOut;
    private static DoubleAnimator _sineEaseOut;
    public static DoubleAnimator BackEaseIn { get; }
    public static DoubleAnimator BackEaseInOut { get; }
    public static DoubleAnimator BackEaseOut { get; }
    public static DoubleAnimator BounceEaseIn { get; }
    public static DoubleAnimator BounceEaseInOut { get; }
    public static DoubleAnimator BounceEaseOut { get; }
    public static DoubleAnimator CircEaseIn { get; }
    public static DoubleAnimator CircEaseInOut { get; }
    public static DoubleAnimator CircEaseOut { get; }
    public static DoubleAnimator CubicEaseIn { get; }
    public static DoubleAnimator CubicEaseInOut { get; }
    public static DoubleAnimator CubicEaseOut { get; }
    public static DoubleAnimator ElasticEaseIn { get; }
    public static DoubleAnimator ElasticEaseInOut { get; }
    public static DoubleAnimator ElasticEaseOut { get; }
    public static DoubleAnimator ExpoEaseIn { get; }
    public static DoubleAnimator ExpoEaseInOut { get; }
    public static DoubleAnimator ExpoEaseOut { get; }
    public static DoubleAnimator Linear { get; }
    public static DoubleAnimator QuadEaseIn { get; }
    public static DoubleAnimator QuadEaseInOut { get; }
    public static DoubleAnimator QuadEaseOut { get; }
    public static DoubleAnimator QuartEaseIn { get; }
    public static DoubleAnimator QuartEaseInOut { get; }
    public static DoubleAnimator QuartEaseOut { get; }
    public static DoubleAnimator QuintEaseIn { get; }
    public static DoubleAnimator QuintEaseInOut { get; }
    public static DoubleAnimator QuintEaseOut { get; }
    public static DoubleAnimator SineEaseIn { get; }
    public static DoubleAnimator SineEaseInOut { get; }
    public static DoubleAnimator SineEaseOut { get; }
    public static DoubleAnimator get_BackEaseIn();
    public static DoubleAnimator get_BackEaseInOut();
    public static DoubleAnimator get_BackEaseOut();
    public static DoubleAnimator get_BounceEaseIn();
    public static DoubleAnimator get_BounceEaseInOut();
    public static DoubleAnimator get_BounceEaseOut();
    public static DoubleAnimator get_CircEaseIn();
    public static DoubleAnimator get_CircEaseInOut();
    public static DoubleAnimator get_CircEaseOut();
    public static DoubleAnimator get_CubicEaseIn();
    public static DoubleAnimator get_CubicEaseInOut();
    public static DoubleAnimator get_CubicEaseOut();
    public static DoubleAnimator get_ElasticEaseIn();
    public static DoubleAnimator get_ElasticEaseInOut();
    public static DoubleAnimator get_ElasticEaseOut();
    public static DoubleAnimator get_ExpoEaseIn();
    public static DoubleAnimator get_ExpoEaseInOut();
    public static DoubleAnimator get_ExpoEaseOut();
    public static DoubleAnimator get_Linear();
    public static DoubleAnimator get_QuadEaseIn();
    public static DoubleAnimator get_QuadEaseInOut();
    public static DoubleAnimator get_QuadEaseOut();
    public static DoubleAnimator get_QuartEaseIn();
    public static DoubleAnimator get_QuartEaseInOut();
    public static DoubleAnimator get_QuartEaseOut();
    public static DoubleAnimator get_QuintEaseIn();
    public static DoubleAnimator get_QuintEaseInOut();
    public static DoubleAnimator get_QuintEaseOut();
    public static DoubleAnimator get_SineEaseIn();
    public static DoubleAnimator get_SineEaseInOut();
    public static DoubleAnimator get_SineEaseOut();
}
public class Xceed.Wpf.Toolkit.Panels.ChildEnteredEventArgs : RoutedEventArgs {
    private Rect _arrangeRect;
    private UIElement _child;
    public Rect ArrangeRect { get; }
    public UIElement Child { get; }
    public ChildEnteredEventArgs(UIElement child, Rect arrangeRect);
    public Rect get_ArrangeRect();
    public UIElement get_Child();
}
public class Xceed.Wpf.Toolkit.Panels.ChildEnteredEventHandler : MulticastDelegate {
    public ChildEnteredEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ChildEnteredEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ChildEnteredEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.Panels.ChildEnteringEventArgs : RoutedEventArgs {
    private Rect _arrangeRect;
    private UIElement _child;
    private Nullable`1<Rect> _enterFrom;
    public Rect ArrangeRect { get; }
    public UIElement Child { get; }
    public Nullable`1<Rect> EnterFrom { get; public set; }
    public ChildEnteringEventArgs(UIElement child, Nullable`1<Rect> enterFrom, Rect arrangeRect);
    public Rect get_ArrangeRect();
    public UIElement get_Child();
    public Nullable`1<Rect> get_EnterFrom();
    public void set_EnterFrom(Nullable`1<Rect> value);
}
public class Xceed.Wpf.Toolkit.Panels.ChildEnteringEventHandler : MulticastDelegate {
    public ChildEnteringEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ChildEnteringEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ChildEnteringEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.Panels.ChildExitedEventArgs : RoutedEventArgs {
    private UIElement _child;
    public UIElement Child { get; }
    public ChildExitedEventArgs(UIElement child);
    public UIElement get_Child();
}
public class Xceed.Wpf.Toolkit.Panels.ChildExitedEventHandler : MulticastDelegate {
    public ChildExitedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ChildExitedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ChildExitedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.Panels.ChildExitingEventArgs : RoutedEventArgs {
    private Rect _arrangeRect;
    private UIElement _child;
    private Nullable`1<Rect> _exitTo;
    public Rect ArrangeRect { get; }
    public UIElement Child { get; }
    public Nullable`1<Rect> ExitTo { get; public set; }
    public ChildExitingEventArgs(UIElement child, Nullable`1<Rect> exitTo, Rect arrangeRect);
    public Rect get_ArrangeRect();
    public UIElement get_Child();
    public Nullable`1<Rect> get_ExitTo();
    public void set_ExitTo(Nullable`1<Rect> value);
}
public class Xceed.Wpf.Toolkit.Panels.ChildExitingEventHandler : MulticastDelegate {
    public ChildExitingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ChildExitingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ChildExitingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.Panels.DoubleAnimator : IterativeAnimator {
    private IterativeEquation`1<double> _equation;
    public DoubleAnimator(IterativeEquation`1<double> equation);
    public virtual Rect GetInitialChildPlacement(UIElement child, Rect currentPlacement, Rect targetPlacement, AnimationPanel activeLayout, AnimationRate& animationRate, Object& placementArgs, Boolean& isDone);
    public virtual Rect GetNextChildPlacement(UIElement child, TimeSpan currentTime, Rect currentPlacement, Rect targetPlacement, AnimationPanel activeLayout, AnimationRate animationRate, Object& placementArgs, Boolean& isDone);
}
[TypeConverterAttribute("Xceed.Wpf.Toolkit.Panels.AnimatorConverter")]
public abstract class Xceed.Wpf.Toolkit.Panels.IterativeAnimator : object {
    private static IterativeAnimator _default;
    public static IterativeAnimator Default { get; }
    private static IterativeAnimator();
    public static IterativeAnimator get_Default();
    public abstract virtual Rect GetInitialChildPlacement(UIElement child, Rect currentPlacement, Rect targetPlacement, AnimationPanel activeLayout, AnimationRate& animationRate, Object& placementArgs, Boolean& isDone);
    public abstract virtual Rect GetNextChildPlacement(UIElement child, TimeSpan currentTime, Rect currentPlacement, Rect targetPlacement, AnimationPanel activeLayout, AnimationRate animationRate, Object& placementArgs, Boolean& isDone);
}
public abstract class Xceed.Wpf.Toolkit.Panels.PanelBase : Panel {
}
public class Xceed.Wpf.Toolkit.Panels.RandomPanel : AnimationPanel {
    public static DependencyProperty MinimumWidthProperty;
    public static DependencyProperty MinimumHeightProperty;
    public static DependencyProperty MaximumWidthProperty;
    public static DependencyProperty MaximumHeightProperty;
    public static DependencyProperty SeedProperty;
    private static DependencyProperty ActualSizeProperty;
    private Random _random;
    public double MinimumWidth { get; public set; }
    public double MinimumHeight { get; public set; }
    public double MaximumWidth { get; public set; }
    public double MaximumHeight { get; public set; }
    public int Seed { get; public set; }
    private static RandomPanel();
    public double get_MinimumWidth();
    public void set_MinimumWidth(double value);
    private static void OnMinimumWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceMinimumWidth(DependencyObject d, object baseValue);
    public double get_MinimumHeight();
    public void set_MinimumHeight(double value);
    private static void OnMinimumHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceMinimumHeight(DependencyObject d, object baseValue);
    public double get_MaximumWidth();
    public void set_MaximumWidth(double value);
    private static void OnMaximumWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceMaximumWidth(DependencyObject d, object baseValue);
    public double get_MaximumHeight();
    public void set_MaximumHeight(double value);
    private static void OnMaximumHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceMaximumHeight(DependencyObject d, object baseValue);
    public int get_Seed();
    public void set_Seed(int value);
    private static void SeedChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private static Size GetActualSize(DependencyObject obj);
    private static void SetActualSize(DependencyObject obj, Size value);
    protected virtual Size MeasureChildrenOverride(UIElementCollection children, Size constraint);
    protected virtual Size ArrangeChildrenOverride(UIElementCollection children, Size finalSize);
}
internal static class Xceed.Wpf.Toolkit.Panels.ScrollHelper : object {
    public static bool ScrollLeastAmount(Rect physViewRect, Rect itemRect, Vector& newPhysOffset);
}
public class Xceed.Wpf.Toolkit.Panels.SwitchPanel : PanelBase {
    private static Vector ZeroVector;
    public static DependencyProperty AreLayoutSwitchesAnimatedProperty;
    private static DependencyPropertyKey ActiveLayoutPropertyKey;
    public static DependencyProperty ActiveLayoutProperty;
    public static DependencyProperty ActiveLayoutIndexProperty;
    private static DependencyPropertyKey ActiveSwitchTemplatePropertyKey;
    public static DependencyProperty ActiveSwitchTemplateProperty;
    public static DependencyProperty DefaultAnimationRateProperty;
    public static DependencyProperty DefaultAnimatorProperty;
    public static DependencyProperty EnterAnimationRateProperty;
    public static DependencyProperty EnterAnimatorProperty;
    public static DependencyProperty ExitAnimationRateProperty;
    public static DependencyProperty ExitAnimatorProperty;
    public static DependencyProperty LayoutAnimationRateProperty;
    public static DependencyProperty LayoutAnimatorProperty;
    private static DependencyPropertyKey LayoutsPropertyKey;
    public static DependencyProperty LayoutsProperty;
    public static DependencyProperty SwitchAnimationRateProperty;
    public static DependencyProperty SwitchAnimatorProperty;
    public static DependencyProperty SwitchTemplateProperty;
    public static DependencyProperty TemplateAnimationRateProperty;
    public static DependencyProperty TemplateAnimatorProperty;
    private List`1<UIElement> _exitingChildren;
    public static RoutedEvent ActiveLayoutChangedEvent;
    public static RoutedEvent SwitchAnimationBegunEvent;
    public static RoutedEvent SwitchAnimationCompletedEvent;
    internal AnimationPanel _currentLayoutPanel;
    private AnimationPanel _defaultLayoutCanvas;
    private Collection`1<SwitchPresenter> _presenters;
    private BitVector32 _cacheBits;
    private bool _allowHorizontal;
    private bool _allowVertical;
    private Vector _computedOffset;
    private Size _extent;
    private Vector _offset;
    private ScrollViewer _scrollOwner;
    private Size _viewport;
    public bool AreLayoutSwitchesAnimated { get; public set; }
    public AnimationPanel ActiveLayout { get; }
    public int ActiveLayoutIndex { get; public set; }
    public DataTemplate ActiveSwitchTemplate { get; }
    public AnimationRate DefaultAnimationRate { get; public set; }
    public IterativeAnimator DefaultAnimator { get; public set; }
    public AnimationRate EnterAnimationRate { get; public set; }
    public IterativeAnimator EnterAnimator { get; public set; }
    public AnimationRate ExitAnimationRate { get; public set; }
    public IterativeAnimator ExitAnimator { get; public set; }
    public AnimationRate LayoutAnimationRate { get; public set; }
    public IterativeAnimator LayoutAnimator { get; public set; }
    public ObservableCollection`1<AnimationPanel> Layouts { get; }
    public AnimationRate SwitchAnimationRate { get; public set; }
    public IterativeAnimator SwitchAnimator { get; public set; }
    public DataTemplate SwitchTemplate { get; public set; }
    public AnimationRate TemplateAnimationRate { get; public set; }
    public IterativeAnimator TemplateAnimator { get; public set; }
    protected int VisualChildrenCount { get; }
    internal List`1<UIElement> ExitingChildren { get; }
    internal UIElementCollection ChildrenInternal { get; }
    internal bool HasLoaded { get; internal set; }
    private bool IsScrollingPhysically { get; }
    public bool CanHorizontallyScroll { get; public set; }
    public bool CanVerticallyScroll { get; public set; }
    public double ExtentHeight { get; }
    public double ExtentWidth { get; }
    public double HorizontalOffset { get; }
    public ScrollViewer ScrollOwner { get; public set; }
    public double VerticalOffset { get; }
    public double ViewportHeight { get; }
    public double ViewportWidth { get; }
    private static SwitchPanel();
    public bool get_AreLayoutSwitchesAnimated();
    public void set_AreLayoutSwitchesAnimated(bool value);
    public AnimationPanel get_ActiveLayout();
    protected void SetActiveLayout(AnimationPanel value);
    private static void OnActiveLayoutChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnActiveLayoutChanged(DependencyPropertyChangedEventArgs e);
    public int get_ActiveLayoutIndex();
    public void set_ActiveLayoutIndex(int value);
    private static void OnActiveLayoutIndexChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnActiveLayoutIndexChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceActiveLayoutIndexValue(DependencyObject d, object value);
    public DataTemplate get_ActiveSwitchTemplate();
    protected void SetActiveSwitchTemplate(DataTemplate value);
    private static void OnActiveSwitchTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnActiveSwitchTemplateChanged(DependencyPropertyChangedEventArgs e);
    public AnimationRate get_DefaultAnimationRate();
    public void set_DefaultAnimationRate(AnimationRate value);
    public IterativeAnimator get_DefaultAnimator();
    public void set_DefaultAnimator(IterativeAnimator value);
    public AnimationRate get_EnterAnimationRate();
    public void set_EnterAnimationRate(AnimationRate value);
    public IterativeAnimator get_EnterAnimator();
    public void set_EnterAnimator(IterativeAnimator value);
    public AnimationRate get_ExitAnimationRate();
    public void set_ExitAnimationRate(AnimationRate value);
    public IterativeAnimator get_ExitAnimator();
    public void set_ExitAnimator(IterativeAnimator value);
    public AnimationRate get_LayoutAnimationRate();
    public void set_LayoutAnimationRate(AnimationRate value);
    public IterativeAnimator get_LayoutAnimator();
    public void set_LayoutAnimator(IterativeAnimator value);
    public ObservableCollection`1<AnimationPanel> get_Layouts();
    protected void SetLayouts(ObservableCollection`1<AnimationPanel> value);
    private static void OnLayoutsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnLayoutsChanged(DependencyPropertyChangedEventArgs e);
    public AnimationRate get_SwitchAnimationRate();
    public void set_SwitchAnimationRate(AnimationRate value);
    public IterativeAnimator get_SwitchAnimator();
    public void set_SwitchAnimator(IterativeAnimator value);
    public DataTemplate get_SwitchTemplate();
    public void set_SwitchTemplate(DataTemplate value);
    private static void OnSwitchTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSwitchTemplateChanged(DependencyPropertyChangedEventArgs e);
    public AnimationRate get_TemplateAnimationRate();
    public void set_TemplateAnimationRate(AnimationRate value);
    public IterativeAnimator get_TemplateAnimator();
    public void set_TemplateAnimator(IterativeAnimator value);
    protected virtual int get_VisualChildrenCount();
    internal List`1<UIElement> get_ExitingChildren();
    internal UIElementCollection get_ChildrenInternal();
    internal bool get_HasLoaded();
    internal void set_HasLoaded(bool value);
    private bool get_IsScrollingPhysically();
    public void add_ActiveLayoutChanged(RoutedEventHandler value);
    public void remove_ActiveLayoutChanged(RoutedEventHandler value);
    protected RoutedEventArgs RaiseActiveLayoutChangedEvent();
    internal static RoutedEventArgs RaiseActiveLayoutChangedEvent(UIElement target);
    public void add_SwitchAnimationBegun(RoutedEventHandler value);
    public void remove_SwitchAnimationBegun(RoutedEventHandler value);
    protected RoutedEventArgs RaiseSwitchAnimationBegunEvent();
    private static RoutedEventArgs RaiseSwitchAnimationBegunEvent(UIElement target);
    public void add_SwitchAnimationCompleted(RoutedEventHandler value);
    public void remove_SwitchAnimationCompleted(RoutedEventHandler value);
    protected RoutedEventArgs RaiseSwitchAnimationCompletedEvent();
    private static RoutedEventArgs RaiseSwitchAnimationCompletedEvent(UIElement target);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Visual GetVisualChild(int index);
    protected virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    internal void AddVisualChildInternal(Visual child);
    internal void BeginLayoutSwitch();
    internal void EndLayoutSwitch();
    internal Visual GetVisualChildInternal(int index);
    internal void OnVisualChildrenChangedInternal(DependencyObject visualAdded, DependencyObject visualRemoved);
    internal UIElement RegisterPresenter(SwitchPresenter presenter);
    internal void RemoveVisualChildInternal(Visual child);
    internal void UnregisterPresenter(SwitchPresenter presenter, DependencyObject container);
    internal void UpdateSwitchTemplate();
    private void OnLoaded(object sender, RoutedEventArgs e);
    private void LayoutsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void ResetScrollInfo();
    private void OnScrollChange();
    private void SetScrollingData(Size viewport, Size extent, Vector offset);
    private double ValidateInputOffset(double offset, string parameterName);
    private int FindChildFromVisual(Visual vis);
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual void LineDown();
    public sealed virtual void LineLeft();
    public sealed virtual void LineRight();
    public sealed virtual void LineUp();
    public sealed virtual Rect MakeVisible(Visual visual, Rect rectangle);
    public sealed virtual void MouseWheelDown();
    public sealed virtual void MouseWheelLeft();
    public sealed virtual void MouseWheelRight();
    public sealed virtual void MouseWheelUp();
    public sealed virtual void PageDown();
    public sealed virtual void PageLeft();
    public sealed virtual void PageRight();
    public sealed virtual void PageUp();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    public sealed virtual void SetHorizontalOffset(double offset);
    public sealed virtual void SetVerticalOffset(double offset);
    public sealed virtual double get_VerticalOffset();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_ViewportWidth();
    [CompilerGeneratedAttribute]
private void <OnActiveLayoutChanged>b__12_0();
}
public class Xceed.Wpf.Toolkit.Panels.SwitchPresenter : FrameworkElement {
    public static DependencyProperty DelaySwitchProperty;
    public static DependencyProperty DelayPriorityProperty;
    internal static DependencyProperty SwitchParentProperty;
    internal UIElement _switchRoot;
    internal Dictionary`2<string, FrameworkElement> _knownIDs;
    private ContentPresenter _contentPresenter;
    private bool _isMeasured;
    private DataTemplate _currentTemplate;
    public bool DelaySwitch { get; public set; }
    public DispatcherPriority DelayPriority { get; public set; }
    internal SwitchPanel SwitchParent { get; internal set; }
    protected int VisualChildrenCount { get; }
    private static SwitchPresenter();
    public bool get_DelaySwitch();
    public void set_DelaySwitch(bool value);
    public DispatcherPriority get_DelayPriority();
    public void set_DelayPriority(DispatcherPriority value);
    internal SwitchPanel get_SwitchParent();
    internal void set_SwitchParent(SwitchPanel value);
    private static void OnSwitchParentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSwitchParentChanged(DependencyPropertyChangedEventArgs e);
    private static void OnLoaded(object sender, RoutedEventArgs e);
    private static void OnUnloaded(object sender, RoutedEventArgs e);
    protected virtual int get_VisualChildrenCount();
    internal void RegisterID(string id, FrameworkElement element);
    internal void SwapTheTemplate(DataTemplate template, bool beginAnimation);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    protected virtual Visual GetVisualChild(int index);
    private void OnSwapTemplate(DelaySwitchParams data);
    private void DoSwapTemplate(DataTemplate template, bool beginAnimation);
    private void SwitchPresenter_Unloaded(object sender, RoutedEventArgs e);
    private void SwitchPresenter_Loaded(object sender, RoutedEventArgs e);
}
public static class Xceed.Wpf.Toolkit.Panels.SwitchTemplate : object {
    public static DependencyProperty IDProperty;
    private static SwitchTemplate();
    public static string GetID(DependencyObject d);
    public static void SetID(DependencyObject d, string value);
    private static void OnIDChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
public class Xceed.Wpf.Toolkit.Panels.WrapPanel : AnimationPanel {
    public static DependencyProperty OrientationProperty;
    private Orientation _orientation;
    public static DependencyProperty ItemWidthProperty;
    public static DependencyProperty ItemHeightProperty;
    public static DependencyProperty IsStackReversedProperty;
    public Orientation Orientation { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double ItemWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double ItemHeight { get; public set; }
    public bool IsChildOrderReversed { get; public set; }
    private static WrapPanel();
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    private static void OnOrientationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_ItemWidth();
    public void set_ItemWidth(double value);
    public double get_ItemHeight();
    public void set_ItemHeight(double value);
    public bool get_IsChildOrderReversed();
    public void set_IsChildOrderReversed(bool value);
    protected virtual Size MeasureChildrenOverride(UIElementCollection children, Size constraint);
    protected virtual Size ArrangeChildrenOverride(UIElementCollection children, Size finalSize);
    private void ArrangeLineOfChildren(Collection`1<UIElement> children, bool isHorizontal, double lineStack, double lineStackSum, double itemExtent, bool useItemExtent);
    private static void OnInvalidateMeasure(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool IsWidthHeightValid(object value);
}
public class Xceed.Wpf.Toolkit.Pie : ShapeBase {
    public static DependencyProperty EndAngleProperty;
    public static DependencyProperty ModeProperty;
    public static DependencyProperty SliceProperty;
    public static DependencyProperty StartAngleProperty;
    public static DependencyProperty SweepDirectionProperty;
    private Rect _rect;
    private BitVector32 _cacheBits;
    public double EndAngle { get; public set; }
    public PieMode Mode { get; public set; }
    public double Slice { get; public set; }
    public double StartAngle { get; public set; }
    public SweepDirection SweepDirection { get; public set; }
    public Transform GeometryTransform { get; }
    public Geometry RenderedGeometry { get; }
    protected Geometry DefiningGeometry { get; }
    private bool IsUpdatingEndAngle { get; private set; }
    private bool IsUpdatingMode { get; private set; }
    private bool IsUpdatingSlice { get; private set; }
    private bool IsUpdatingStartAngle { get; private set; }
    private bool IsUpdatingSweepDirection { get; private set; }
    private static Pie();
    public double get_EndAngle();
    public void set_EndAngle(double value);
    private static void OnEndAngleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnEndAngleChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceEndAngleValue(DependencyObject d, object value);
    public PieMode get_Mode();
    public void set_Mode(PieMode value);
    private static void OnModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnModeChanged(DependencyPropertyChangedEventArgs e);
    public double get_Slice();
    public void set_Slice(double value);
    private static void OnSliceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnSliceChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceSliceValue(DependencyObject d, object value);
    private static bool ValidateSlice(object value);
    public double get_StartAngle();
    public void set_StartAngle(double value);
    private static void OnStartAngleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnStartAngleChanged(DependencyPropertyChangedEventArgs e);
    public SweepDirection get_SweepDirection();
    public void set_SweepDirection(SweepDirection value);
    private static void OnSweepDirectionChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnSweepDirectionChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceSweepDirectionValue(DependencyObject d, object value);
    public virtual Transform get_GeometryTransform();
    public virtual Geometry get_RenderedGeometry();
    protected virtual Geometry get_DefiningGeometry();
    private bool get_IsUpdatingEndAngle();
    private void set_IsUpdatingEndAngle(bool value);
    private bool get_IsUpdatingMode();
    private void set_IsUpdatingMode(bool value);
    private bool get_IsUpdatingSlice();
    private void set_IsUpdatingSlice(bool value);
    private bool get_IsUpdatingStartAngle();
    private void set_IsUpdatingStartAngle(bool value);
    private bool get_IsUpdatingSweepDirection();
    private void set_IsUpdatingSweepDirection(bool value);
    internal virtual Size GetNaturalSize();
    internal virtual Rect GetDefiningGeometryBounds();
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual void OnRender(DrawingContext drawingContext);
}
public enum Xceed.Wpf.Toolkit.PieMode : Enum {
    public int value__;
    public static PieMode Manual;
    public static PieMode EndAngle;
    public static PieMode Slice;
}
public class Xceed.Wpf.Toolkit.PlainTextFormatter : object {
    public sealed virtual string GetText(FlowDocument document);
    public sealed virtual void SetText(FlowDocument document, string text);
}
internal class Xceed.Wpf.Toolkit.Primitives.CachedTextInfo : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CaretIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SelectionStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SelectionLength>k__BackingField;
    public string Text { get; private set; }
    public int CaretIndex { get; private set; }
    public int SelectionStart { get; private set; }
    public int SelectionLength { get; private set; }
    private CachedTextInfo(string text, int caretIndex, int selectionStart, int selectionLength);
    public CachedTextInfo(TextBox textBox);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public int get_CaretIndex();
    [CompilerGeneratedAttribute]
private void set_CaretIndex(int value);
    [CompilerGeneratedAttribute]
public int get_SelectionStart();
    [CompilerGeneratedAttribute]
private void set_SelectionStart(int value);
    [CompilerGeneratedAttribute]
public int get_SelectionLength();
    [CompilerGeneratedAttribute]
private void set_SelectionLength(int value);
    public sealed virtual object Clone();
}
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.Primitives.DateTimePickerBase : DateTimeUpDown {
    private static string PART_Popup;
    private Popup _popup;
    private Nullable`1<DateTime> _initialValue;
    public static DependencyProperty DropDownButtonContentProperty;
    public static DependencyProperty DropDownButtonDisabledContentProperty;
    public static DependencyProperty DropDownButtonHeightProperty;
    public static DependencyProperty DropDownButtonWidthProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty ShowDropDownButtonProperty;
    public object DropDownButtonContent { get; public set; }
    public object DropDownButtonDisabledContent { get; public set; }
    public double DropDownButtonHeight { get; public set; }
    public double DropDownButtonWidth { get; public set; }
    public bool IsOpen { get; public set; }
    public bool ShowDropDownButton { get; public set; }
    private static DateTimePickerBase();
    public object get_DropDownButtonContent();
    public void set_DropDownButtonContent(object value);
    public object get_DropDownButtonDisabledContent();
    public void set_DropDownButtonDisabledContent(object value);
    public double get_DropDownButtonHeight();
    public void set_DropDownButtonHeight(double value);
    public double get_DropDownButtonWidth();
    public void set_DropDownButtonWidth(double value);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    private static void OnIsOpenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsOpenChanged(bool oldValue, bool newValue);
    public bool get_ShowDropDownButton();
    public void set_ShowDropDownButton(bool value);
    public virtual void OnApplyTemplate();
    protected virtual void HandleKeyDown(object sender, KeyEventArgs e);
    private void OnMouseDownOutsideCapturedElement(object sender, MouseButtonEventArgs e);
    protected virtual void Popup_Opened(object sender, EventArgs e);
    protected void ClosePopup(bool isFocusOnTextBox);
}
public abstract class Xceed.Wpf.Toolkit.Primitives.DateTimeUpDownBase`1 : UpDownBase`1<T> {
    internal List`1<DateTimeInfo> _dateTimeInfoList;
    internal DateTimeInfo _selectedDateTimeInfo;
    internal bool _fireSelectionChangedEvent;
    internal bool _processTextChanged;
    public static DependencyProperty CurrentDateTimePartProperty;
    public static DependencyProperty StepProperty;
    public DateTimePart CurrentDateTimePart { get; public set; }
    public int Step { get; public set; }
    private static DateTimeUpDownBase`1();
    private static object OnCurrentDateTimePartCoerce(DependencyObject d, object baseValue);
    protected virtual object OnCurrentDateTimePartCoerce(object baseValue);
    public DateTimePart get_CurrentDateTimePart();
    public void set_CurrentDateTimePart(DateTimePart value);
    private static void OnCurrentDateTimePartChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCurrentDateTimePartChanged(DateTimePart oldValue, DateTimePart newValue);
    public int get_Step();
    public void set_Step(int value);
    private static void OnStepChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnStepChanged(int oldValue, int newValue);
    public virtual void OnApplyTemplate();
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    private void TextBox_SelectionChanged(object sender, RoutedEventArgs e);
    private void DateTimeUpDownBase_Loaded(object sender, RoutedEventArgs e);
    protected virtual void InitializeDateTimeInfoList(T value);
    protected virtual bool IsCurrentValueValid();
    protected virtual void PerformMouseSelection();
    protected virtual bool IsLowerThan(T value1, T value2);
    protected virtual bool IsGreaterThan(T value1, T value2);
    internal DateTimeInfo GetDateTimeInfo(int selectionStart);
    internal DateTimeInfo GetDateTimeInfo(DateTimePart part);
    internal virtual void Select(DateTimeInfo info);
    internal T CoerceValueMinMax(T value);
    internal void ValidateDefaultMinMax(T value);
    internal T GetClippedMinMaxValue(T value);
    protected internal virtual void PerformKeyboardSelection(int nextSelectionStart);
    private DateTimeInfo GetNextDateTimeInfo(int nextSelectionStart);
    private DateTimeInfo GetPreviousDateTimeInfo(int previousSelectionStart);
    private void InitSelection();
}
internal class Xceed.Wpf.Toolkit.Primitives.HsvColor : ValueType {
    public double H;
    public double S;
    public double V;
    public HsvColor(double h, double s, double v);
}
public abstract class Xceed.Wpf.Toolkit.Primitives.InputBase : Control {
    public static DependencyProperty AllowTextInputProperty;
    public static DependencyProperty CultureInfoProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty IsUndoEnabledProperty;
    public static DependencyProperty TextProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty WatermarkProperty;
    public static DependencyProperty WatermarkTemplateProperty;
    public bool AllowTextInput { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public bool IsReadOnly { get; public set; }
    public bool IsUndoEnabled { get; public set; }
    public string Text { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public object Watermark { get; public set; }
    public DataTemplate WatermarkTemplate { get; public set; }
    private static InputBase();
    public bool get_AllowTextInput();
    public void set_AllowTextInput(bool value);
    private static void OnAllowTextInputChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAllowTextInputChanged(bool oldValue, bool newValue);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    private static void OnCultureInfoChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCultureInfoChanged(CultureInfo oldValue, CultureInfo newValue);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    private static void OnReadOnlyChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnReadOnlyChanged(bool oldValue, bool newValue);
    public bool get_IsUndoEnabled();
    public void set_IsUndoEnabled(bool value);
    private static void OnIsUndoEnabledChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsUndoEnabledChanged(bool oldValue, bool newValue);
    public string get_Text();
    public void set_Text(string value);
    private static void OnTextChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTextChanged(string oldValue, string newValue);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public object get_Watermark();
    public void set_Watermark(object value);
    public DataTemplate get_WatermarkTemplate();
    public void set_WatermarkTemplate(DataTemplate value);
}
public class Xceed.Wpf.Toolkit.Primitives.ItemSelectionChangedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private bool <IsSelected>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Item>k__BackingField;
    public bool IsSelected { get; private set; }
    public object Item { get; private set; }
    public ItemSelectionChangedEventArgs(RoutedEvent routedEvent, object source, object item, bool isSelected);
    [CompilerGeneratedAttribute]
public bool get_IsSelected();
    [CompilerGeneratedAttribute]
private void set_IsSelected(bool value);
    [CompilerGeneratedAttribute]
public object get_Item();
    [CompilerGeneratedAttribute]
private void set_Item(object value);
}
public class Xceed.Wpf.Toolkit.Primitives.ItemSelectionChangedEventHandler : MulticastDelegate {
    public ItemSelectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ItemSelectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ItemSelectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.Primitives.ItemSelectionChangingEventArgs : CancelEventArgs {
    [CompilerGeneratedAttribute]
private bool <NewIsSelected>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Item>k__BackingField;
    public bool NewIsSelected { get; private set; }
    public object Item { get; private set; }
    public ItemSelectionChangingEventArgs(object item, bool isSelected);
    [CompilerGeneratedAttribute]
public bool get_NewIsSelected();
    [CompilerGeneratedAttribute]
private void set_NewIsSelected(bool value);
    [CompilerGeneratedAttribute]
public object get_Item();
    [CompilerGeneratedAttribute]
private void set_Item(object value);
}
public class Xceed.Wpf.Toolkit.Primitives.ItemSelectionChangingEventHandler : MulticastDelegate {
    public ItemSelectionChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ItemSelectionChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ItemSelectionChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Xceed.Wpf.Toolkit.Primitives.MouseWheelActiveTrigger : Enum {
    public int value__;
    public static MouseWheelActiveTrigger Focused;
    public static MouseWheelActiveTrigger FocusedMouseOver;
    public static MouseWheelActiveTrigger MouseOver;
    public static MouseWheelActiveTrigger Disabled;
}
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.Primitives.SelectAllSelector : Selector {
    private static string PART_SelectAllSelectorItem;
    private SelectAllSelectorItem _selectAllSelecotrItem;
    public static DependencyProperty AllItemsSelectedContentProperty;
    public static DependencyProperty IsAllItemsSelectedContentActiveProperty;
    public static DependencyProperty IsSelectAllActiveProperty;
    public static DependencyProperty SelectAllContentProperty;
    public string AllItemsSelectedContent { get; public set; }
    public bool IsAllItemsSelectedContentActive { get; public set; }
    public bool IsSelectAllActive { get; public set; }
    public object SelectAllContent { get; public set; }
    private static SelectAllSelector();
    public string get_AllItemsSelectedContent();
    public void set_AllItemsSelectedContent(string value);
    private static void OnAllItemsSelectedContentChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAllItemsSelectedContentChanged(string oldValue, string newValue);
    public bool get_IsAllItemsSelectedContentActive();
    public void set_IsAllItemsSelectedContentActive(bool value);
    private static void OnIsAllItemsSelectedContentActiveChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsAllItemsSelectedContentActiveChanged(bool oldValue, bool newValue);
    public bool get_IsSelectAllActive();
    public void set_IsSelectAllActive(bool value);
    private static void OnIsSelectAllActiveChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsSelectAllActiveChanged(bool oldValue, bool newValue);
    public object get_SelectAllContent();
    public void set_SelectAllContent(object value);
    protected virtual void OnSelectedItemsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    public virtual void OnApplyTemplate();
    public void SelectAll();
    public void UnSelectAll();
    private void UpdateSelectAllSelectorItem();
}
public class Xceed.Wpf.Toolkit.Primitives.SelectAllSelectorItem : SelectorItem {
    private bool _ignoreSelectorChanges;
    protected virtual void OnIsSelectedChanged(Nullable`1<bool> oldValue, Nullable`1<bool> newValue);
    internal void ModifyCurrentSelection(Nullable`1<bool> newSelection);
}
public class Xceed.Wpf.Toolkit.Primitives.Selector : ItemsControl {
    private bool _surpressItemSelectionChanged;
    private bool _ignoreSelectedItemChanged;
    private bool _ignoreSelectedValueChanged;
    private int _ignoreSelectedItemsCollectionChanged;
    private int _ignoreSelectedMemberPathValuesChanged;
    private IList _selectedItems;
    private IList _removedItems;
    private Object[] _internalSelectedItems;
    private ValueChangeHelper _selectedMemberPathValuesHelper;
    private ValueChangeHelper _valueMemberPathValuesHelper;
    public static DependencyProperty CommandProperty;
    public static DependencyProperty DelimiterProperty;
    public static DependencyProperty SelectedItemProperty;
    public static DependencyProperty SelectedItemsOverrideProperty;
    public static DependencyProperty SelectedMemberPathProperty;
    public static DependencyProperty SelectedValueProperty;
    public static DependencyProperty ValueMemberPathProperty;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnSelectedEvent;
    public static RoutedEvent ItemSelectionChangedEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<ItemSelectionChangingEventArgs> ItemSelectionChanging;
    [TypeConverterAttribute("System.Windows.Input.CommandConverter")]
public ICommand Command { get; public set; }
    public string Delimiter { get; public set; }
    public object SelectedItem { get; public set; }
    public IList SelectedItems { get; private set; }
    public IList SelectedItemsOverride { get; public set; }
    public string SelectedMemberPath { get; public set; }
    public string SelectedValue { get; public set; }
    public string ValueMemberPath { get; public set; }
    protected IEnumerable ItemsCollection { get; }
    private static Selector();
    public ICommand get_Command();
    public void set_Command(ICommand value);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    private static void OnDelimiterChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectedItemChanged(string oldValue, string newValue);
    public object get_SelectedItem();
    public void set_SelectedItem(object value);
    private static void OnSelectedItemChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnSelectedItemChanged(object oldValue, object newValue);
    public IList get_SelectedItems();
    private void set_SelectedItems(IList value);
    public IList get_SelectedItemsOverride();
    public void set_SelectedItemsOverride(IList value);
    private static void SelectedItemsOverrideChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnSelectedItemsOverrideChanged(IList oldValue, IList newValue);
    public string get_SelectedMemberPath();
    public void set_SelectedMemberPath(string value);
    private static void OnSelectedMemberPathChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectedMemberPathChanged(string oldValue, string newValue);
    public string get_SelectedValue();
    public void set_SelectedValue(string value);
    private static void OnSelectedValueChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectedValueChanged(string oldValue, string newValue);
    public string get_ValueMemberPath();
    public void set_ValueMemberPath(string value);
    private static void OnValueMemberPathChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnValueMemberPathChanged(string oldValue, string newValue);
    protected IEnumerable get_ItemsCollection();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    public virtual void EndInit();
    public void add_ItemSelectionChanged(ItemSelectionChangedEventHandler value);
    public void remove_ItemSelectionChanged(ItemSelectionChangedEventHandler value);
    protected object GetPathValue(object item, string propertyPath);
    protected object GetItemValue(object item);
    protected object ResolveItemByValue(string value);
    internal void UpdateFromList(List`1<string> selectedValues, Func`2<object, object> GetItemfunction);
    internal void UpdateSelectedItemsWithoutNotifications(List`1<object> selectedValues);
    private Nullable`1<bool> GetSelectedMemberPathValue(object item);
    private void SetSelectedMemberPathValue(object item, bool value);
    protected virtual void OnSelectedItemsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnItemSelectionChangedCore(RoutedEventArgs args, bool unselected);
    private void OnItemsSourceCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
    private void OnSelectedMemberPathValuesChanged();
    private void OnValueMemberPathValuesChanged();
    private void UpdateSelectedMemberPathValuesBindings();
    private void UpdateValueMemberPathValuesBindings();
    protected virtual void OnItemSelectionChanged(ItemSelectionChangedEventArgs args);
    [CompilerGeneratedAttribute]
public void add_ItemSelectionChanging(EventHandler`1<ItemSelectionChangingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ItemSelectionChanging(EventHandler`1<ItemSelectionChangingEventArgs> value);
    protected virtual void OnItemSelectionChanging(ItemSelectionChangingEventArgs args);
    private void UpdateSelectedValue();
    private void UpdateSelectedItem();
    private void UpdateFromSelectedMemberPathValues();
    internal void UpdateSelectedItems(IList selectedItems);
    private void UpdateFromSelectedItems();
    private void UpdateInternalSelectedItems();
    private void UpdateSelectorItem(object item, bool isSelected, bool raiseSelectionChangedEvent);
    private void RemoveUnavailableSelectedItems();
    private void AddAvailableRemovedItems();
    private void UpdateFromSelectedValue();
    public sealed virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_0(object s, RoutedEventArgs args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__10_1(object s, RoutedEventArgs args);
    [CompilerGeneratedAttribute]
private object <UpdateSelectedValue>b__87_0(object x);
}
public class Xceed.Wpf.Toolkit.Primitives.SelectorItem : ContentControl {
    private bool m_raiseSelectionChangedEvent;
    public static DependencyProperty IsSelectedProperty;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    public Nullable`1<bool> IsSelected { get; public set; }
    internal Selector ParentSelector { get; }
    private static SelectorItem();
    public Nullable`1<bool> get_IsSelected();
    public void set_IsSelected(Nullable`1<bool> value);
    private static void OnIsSelectedChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsSelectedChanged(Nullable`1<bool> oldValue, Nullable`1<bool> newValue);
    internal Selector get_ParentSelector();
    internal void SetIsSelected(bool isSelected, bool raiseSelectionChangedEvent);
}
public abstract class Xceed.Wpf.Toolkit.Primitives.ShapeBase : Shape {
    private Pen _pen;
    internal bool IsPenEmptyOrUndefined { get; }
    protected Geometry DefiningGeometry { get; }
    private static ShapeBase();
    internal bool get_IsPenEmptyOrUndefined();
    protected abstract virtual Geometry get_DefiningGeometry();
    internal virtual Rect GetDefiningGeometryBounds();
    internal virtual Size GetNaturalSize();
    internal Pen GetPen();
    internal double GetStrokeThickness();
    internal bool IsSizeEmptyOrUndefined(Size size);
    private static void OnStrokeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private Pen MakePen();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public abstract class Xceed.Wpf.Toolkit.Primitives.UpDownBase`1 : InputBase {
    internal static string PART_TextBox;
    internal static string PART_Spinner;
    internal bool _isTextChangedFromUI;
    private bool _isSyncingTextAndValueProperties;
    private bool _internalValueSet;
    [CompilerGeneratedAttribute]
private Spinner <Spinner>k__BackingField;
    [CompilerGeneratedAttribute]
private TextBox <TextBox>k__BackingField;
    public static DependencyProperty AllowSpinProperty;
    public static DependencyProperty ButtonSpinnerHeightProperty;
    public static DependencyProperty ButtonSpinnerLocationProperty;
    public static DependencyProperty ButtonSpinnerDownContentTemplateProperty;
    public static DependencyProperty ButtonSpinnerDownDisabledContentTemplateProperty;
    public static DependencyProperty ButtonSpinnerUpContentTemplateProperty;
    public static DependencyProperty ButtonSpinnerUpDisabledContentTemplateProperty;
    public static DependencyProperty ButtonSpinnerWidthProperty;
    public static DependencyProperty ClipValueToMinMaxProperty;
    public static DependencyProperty DisplayDefaultValueOnEmptyTextProperty;
    public static DependencyProperty DefaultValueProperty;
    public static DependencyProperty MaximumProperty;
    public static DependencyProperty MinimumProperty;
    public static DependencyProperty MouseWheelActiveTriggerProperty;
    [ObsoleteAttribute("Use MouseWheelActiveTrigger property instead")]
public static DependencyProperty MouseWheelActiveOnFocusProperty;
    public static DependencyProperty ShowButtonSpinnerProperty;
    public static DependencyProperty UpdateValueOnEnterKeyProperty;
    public static DependencyProperty ValueProperty;
    [CompilerGeneratedAttribute]
private InputValidationErrorEventHandler InputValidationError;
    [CompilerGeneratedAttribute]
private EventHandler`1<SpinEventArgs> Spinned;
    public static RoutedEvent ValueChangedEvent;
    protected Spinner Spinner { get; private set; }
    protected TextBox TextBox { get; private set; }
    public bool AllowSpin { get; public set; }
    public double ButtonSpinnerHeight { get; public set; }
    public Location ButtonSpinnerLocation { get; public set; }
    public DataTemplate ButtonSpinnerDownContentTemplate { get; public set; }
    public DataTemplate ButtonSpinnerDownDisabledContentTemplate { get; public set; }
    public DataTemplate ButtonSpinnerUpContentTemplate { get; public set; }
    public DataTemplate ButtonSpinnerUpDisabledContentTemplate { get; public set; }
    public double ButtonSpinnerWidth { get; public set; }
    public bool ClipValueToMinMax { get; public set; }
    public bool DisplayDefaultValueOnEmptyText { get; public set; }
    public T DefaultValue { get; public set; }
    public T Maximum { get; public set; }
    public T Minimum { get; public set; }
    public MouseWheelActiveTrigger MouseWheelActiveTrigger { get; public set; }
    [ObsoleteAttribute("Use MouseWheelActiveTrigger property instead")]
public bool MouseWheelActiveOnFocus { get; public set; }
    public bool ShowButtonSpinner { get; public set; }
    public bool UpdateValueOnEnterKey { get; public set; }
    public T Value { get; public set; }
    private static UpDownBase`1();
    [CompilerGeneratedAttribute]
protected Spinner get_Spinner();
    [CompilerGeneratedAttribute]
private void set_Spinner(Spinner value);
    [CompilerGeneratedAttribute]
protected TextBox get_TextBox();
    [CompilerGeneratedAttribute]
private void set_TextBox(TextBox value);
    public bool get_AllowSpin();
    public void set_AllowSpin(bool value);
    public double get_ButtonSpinnerHeight();
    public void set_ButtonSpinnerHeight(double value);
    public Location get_ButtonSpinnerLocation();
    public void set_ButtonSpinnerLocation(Location value);
    public DataTemplate get_ButtonSpinnerDownContentTemplate();
    public void set_ButtonSpinnerDownContentTemplate(DataTemplate value);
    public DataTemplate get_ButtonSpinnerDownDisabledContentTemplate();
    public void set_ButtonSpinnerDownDisabledContentTemplate(DataTemplate value);
    public DataTemplate get_ButtonSpinnerUpContentTemplate();
    public void set_ButtonSpinnerUpContentTemplate(DataTemplate value);
    public DataTemplate get_ButtonSpinnerUpDisabledContentTemplate();
    public void set_ButtonSpinnerUpDisabledContentTemplate(DataTemplate value);
    public double get_ButtonSpinnerWidth();
    public void set_ButtonSpinnerWidth(double value);
    public bool get_ClipValueToMinMax();
    public void set_ClipValueToMinMax(bool value);
    public bool get_DisplayDefaultValueOnEmptyText();
    public void set_DisplayDefaultValueOnEmptyText(bool value);
    private static void OnDisplayDefaultValueOnEmptyTextChanged(DependencyObject source, DependencyPropertyChangedEventArgs args);
    private void OnDisplayDefaultValueOnEmptyTextChanged(bool oldValue, bool newValue);
    public T get_DefaultValue();
    public void set_DefaultValue(T value);
    private static void OnDefaultValueChanged(DependencyObject source, DependencyPropertyChangedEventArgs args);
    private void OnDefaultValueChanged(T oldValue, T newValue);
    public T get_Maximum();
    public void set_Maximum(T value);
    private static void OnMaximumChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMaximumChanged(T oldValue, T newValue);
    private static object OnCoerceMaximum(DependencyObject d, object baseValue);
    protected virtual T OnCoerceMaximum(T baseValue);
    public T get_Minimum();
    public void set_Minimum(T value);
    private static void OnMinimumChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMinimumChanged(T oldValue, T newValue);
    private static object OnCoerceMinimum(DependencyObject d, object baseValue);
    protected virtual T OnCoerceMinimum(T baseValue);
    public MouseWheelActiveTrigger get_MouseWheelActiveTrigger();
    public void set_MouseWheelActiveTrigger(MouseWheelActiveTrigger value);
    public bool get_MouseWheelActiveOnFocus();
    public void set_MouseWheelActiveOnFocus(bool value);
    private static void OnMouseWheelActiveOnFocusChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    public bool get_ShowButtonSpinner();
    public void set_ShowButtonSpinner(bool value);
    public bool get_UpdateValueOnEnterKey();
    public void set_UpdateValueOnEnterKey(bool value);
    private static void OnUpdateValueOnEnterKeyChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnUpdateValueOnEnterKeyChanged(bool oldValue, bool newValue);
    public T get_Value();
    public void set_Value(T value);
    private void SetValueInternal(T value);
    private static object OnCoerceValue(DependencyObject o, object basevalue);
    protected virtual object OnCoerceValue(object newValue);
    private static void OnValueChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnValueChanged(T oldValue, T newValue);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    public virtual void OnApplyTemplate();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnTextChanged(string oldValue, string newValue);
    protected virtual void OnCultureInfoChanged(CultureInfo oldValue, CultureInfo newValue);
    protected virtual void OnReadOnlyChanged(bool oldValue, bool newValue);
    private void TextBox_PreviewMouseDown(object sender, RoutedEventArgs e);
    private void HandleClickOutsideOfControlWithMouseCapture(object sender, RoutedEventArgs e);
    private void OnSpinnerSpin(object sender, SpinEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_InputValidationError(InputValidationErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InputValidationError(InputValidationErrorEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Spinned(EventHandler`1<SpinEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Spinned(EventHandler`1<SpinEventArgs> value);
    public void add_ValueChanged(RoutedPropertyChangedEventHandler`1<object> value);
    public void remove_ValueChanged(RoutedPropertyChangedEventHandler`1<object> value);
    protected virtual void OnSpin(SpinEventArgs e);
    protected virtual void RaiseValueChangedEvent(T oldValue, T newValue);
    protected virtual void OnInitialized(EventArgs e);
    internal void DoDecrement();
    internal void DoIncrement();
    private void TextBox_TextChanged(object sender, TextChangedEventArgs e);
    private void UpDownBase_IsKeyboardFocusWithinChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void RaiseInputValidationError(Exception e);
    public virtual bool CommitInput();
    protected bool SyncTextAndValueProperties(bool updateValueFromText, string text);
    private bool SyncTextAndValueProperties(bool updateValueFromText, string text, bool forceTextUpdate);
    protected abstract virtual T ConvertTextToValue(string text);
    protected abstract virtual string ConvertValueToText();
    protected abstract virtual void OnIncrement();
    protected abstract virtual void OnDecrement();
    protected abstract virtual void SetValidSpinDirection();
    [CompilerGeneratedAttribute]
private void <TextBox_PreviewMouseDown>b__112_0();
}
public class Xceed.Wpf.Toolkit.Primitives.ValueRangeTextBox : AutoSelectTextBox {
    public static DependencyProperty BeepOnErrorProperty;
    public static DependencyProperty FormatProviderProperty;
    public static DependencyProperty MinValueProperty;
    public static DependencyProperty MaxValueProperty;
    public static DependencyProperty NullValueProperty;
    public static DependencyProperty ValueProperty;
    public static DependencyProperty ValueDataTypeProperty;
    private static DependencyPropertyKey HasValidationErrorPropertyKey;
    public static DependencyProperty HasValidationErrorProperty;
    private static DependencyPropertyKey HasParsingErrorPropertyKey;
    public static DependencyProperty HasParsingErrorProperty;
    private static DependencyPropertyKey IsValueOutOfRangePropertyKey;
    public static DependencyProperty IsValueOutOfRangeProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<QueryTextFromValueEventArgs> QueryTextFromValue;
    [CompilerGeneratedAttribute]
private EventHandler`1<QueryValueFromTextEventArgs> QueryValueFromText;
    private BitVector32 m_flags;
    private CachedTextInfo m_imePreCompositionCachedTextInfo;
    public bool BeepOnError { get; public set; }
    public IFormatProvider FormatProvider { get; public set; }
    public object MinValue { get; public set; }
    public object MaxValue { get; public set; }
    public object NullValue { get; public set; }
    public object Value { get; public set; }
    public Type ValueDataType { get; public set; }
    public bool HasValidationError { get; }
    public bool HasParsingError { get; }
    public bool IsValueOutOfRange { get; }
    internal bool IsInValueChanged { get; private set; }
    internal bool IsForcingValue { get; private set; }
    internal bool IsForcingText { get; private set; }
    internal bool IsNumericValueDataType { get; private set; }
    internal bool IsTextReadyToBeParsed { get; }
    internal bool IsInIMEComposition { get; }
    private bool IsFinalizingInitialization { get; private set; }
    private static ValueRangeTextBox();
    private static object AcceptsReturnCoerceValueCallback(DependencyObject sender, object value);
    private static object AcceptsTabCoerceValueCallback(DependencyObject sender, object value);
    public bool get_BeepOnError();
    public void set_BeepOnError(bool value);
    public IFormatProvider get_FormatProvider();
    public void set_FormatProvider(IFormatProvider value);
    private static void FormatProviderPropertyChangedCallback(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    internal virtual void OnFormatProviderChanged();
    public object get_MinValue();
    public void set_MinValue(object value);
    private static object MinValueCoerceValueCallback(DependencyObject sender, object value);
    public object get_MaxValue();
    public void set_MaxValue(object value);
    private static object MaxValueCoerceValueCallback(DependencyObject sender, object value);
    public object get_NullValue();
    public void set_NullValue(object value);
    private static object NullValueCoerceValueCallback(DependencyObject sender, object value);
    private static void NullValuePropertyChangedCallback(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    public object get_Value();
    public void set_Value(object value);
    private static object ValueCoerceValueCallback(object sender, object value);
    private static void ValuePropertyChangedCallback(object sender, DependencyPropertyChangedEventArgs e);
    public Type get_ValueDataType();
    public void set_ValueDataType(Type value);
    private static object ValueDataTypeCoerceValueCallback(DependencyObject sender, object value);
    private static void ValueDataTypePropertyChangedCallback(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    internal virtual void ValidateDataType(Type type);
    private void ConvertValuesToDataType(Type type);
    private static object TextCoerceValueCallback(object sender, object value);
    protected virtual void OnTextChanged(TextChangedEventArgs e);
    public bool get_HasValidationError();
    private void SetHasValidationError(bool value);
    public bool get_HasParsingError();
    internal void SetHasParsingError(bool value);
    public bool get_IsValueOutOfRange();
    private void SetIsValueOutOfRange(bool value);
    internal bool get_IsInValueChanged();
    private void set_IsInValueChanged(bool value);
    internal bool get_IsForcingValue();
    private void set_IsForcingValue(bool value);
    internal bool get_IsForcingText();
    private void set_IsForcingText(bool value);
    internal bool get_IsNumericValueDataType();
    private void set_IsNumericValueDataType(bool value);
    internal virtual bool get_IsTextReadyToBeParsed();
    internal bool get_IsInIMEComposition();
    private bool get_IsFinalizingInitialization();
    private void set_IsFinalizingInitialization(bool value);
    [CompilerGeneratedAttribute]
public void add_QueryTextFromValue(EventHandler`1<QueryTextFromValueEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_QueryTextFromValue(EventHandler`1<QueryTextFromValueEventArgs> value);
    internal string GetTextFromValue(object value);
    protected virtual string QueryTextFromValueCore(object value);
    private void OnQueryTextFromValue(QueryTextFromValueEventArgs e);
    [CompilerGeneratedAttribute]
public void add_QueryValueFromText(EventHandler`1<QueryValueFromTextEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_QueryValueFromText(EventHandler`1<QueryValueFromTextEventArgs> value);
    internal object GetValueFromText(string text, Boolean& hasParsingError);
    protected virtual bool QueryValueFromTextCore(string text, Object& value);
    private void OnQueryValueFromText(QueryValueFromTextEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void ValidateValue(object value);
    internal static bool IsNumericType(Type type);
    internal void StartIMEComposition();
    internal void EndIMEComposition();
    internal virtual void OnIMECompositionEnded(CachedTextInfo cachedTextInfo);
    internal virtual void RefreshConversionHelpers();
    internal IFormatProvider GetActiveFormatProvider();
    internal CultureInfo GetCultureInfo();
    internal virtual string GetCurrentText();
    internal virtual string GetParsableText();
    internal void ForceText(string text, bool preserveCaret);
    internal bool IsValueNull(object value);
    internal void ForceValue(object value);
    internal void RefreshCurrentText(bool preserveCurrentCaretPosition);
    internal void RefreshValue();
    internal virtual bool GetIsEditTextEmpty();
    private static object ConvertValueToDataType(object value, Type type);
    private void PlayBeep();
    private void CanEnterLineBreak(object sender, CanExecuteRoutedEventArgs e);
    private void CanEnterParagraphBreak(object sender, CanExecuteRoutedEventArgs e);
    private void ValidateValueInRange(object minValue, object maxValue, object value);
    protected virtual void OnInitialized(EventArgs e);
}
public class Xceed.Wpf.Toolkit.Primitives.WindowContainer : Canvas {
    private Brush _defaultBackgroundBrush;
    private bool _isModalBackgroundApplied;
    public static DependencyProperty ModalBackgroundBrushProperty;
    public Brush ModalBackgroundBrush { get; public set; }
    private static WindowContainer();
    private void WindowContainer_Loaded(object sender, RoutedEventArgs e);
    public Brush get_ModalBackgroundBrush();
    public void set_ModalBackgroundBrush(Brush value);
    private static void OnModalBackgroundBrushChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnModalBackgroundBrushChanged(Brush oldValue, Brush newValue);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    private void Child_LeftChanged(object sender, EventArgs e);
    private void Child_TopChanged(object sender, EventArgs e);
    private void Child_PreviewMouseLeftButtonDown(object sender, RoutedEventArgs e);
    private void Child_IsModalChanged(object sender, EventArgs e);
    private void Child_IsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void Child_IsKeyboardFocusWithinChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void WindowContainer_LayoutUpdated(object sender, EventArgs e);
    private void WindowContainer_SizeChanged(object sender, SizeChangedEventArgs e);
    private void ExpandWindowControl(WindowControl windowControl);
    private void SetChildPos(WindowControl windowControl);
    private void CenterChild(WindowControl windowControl);
    private void SetNextActiveWindow(WindowControl windowControl);
    private void BringToFront(WindowControl windowControl);
    private void SetActiveWindow(WindowControl windowControl);
    private bool IsModalWindow(WindowControl windowControl);
    private WindowControl GetModalWindow();
    private double GetRestrictedLeft(WindowControl windowControl);
    private double GetRestrictedTop(WindowControl windowControl);
    private void SetModalBackground();
    [CompilerGeneratedAttribute]
private bool <GetModalWindow>b__28_1(WindowControl x);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.Primitives.WindowControl : ContentControl {
    public static ComponentResourceKey DefaultCloseButtonStyleKey;
    private static string PART_HeaderThumb;
    private static string PART_Icon;
    private static string PART_CloseButton;
    private static string PART_ToolWindowCloseButton;
    private static string PART_BlockMouseInputsBorder;
    private static string PART_HeaderGrid;
    private Thumb _headerThumb;
    private Image _icon;
    private Button _closeButton;
    private Button _windowToolboxCloseButton;
    private bool _setIsActiveInternal;
    internal Border _windowBlockMouseInputsPanel;
    public static DependencyProperty CaptionProperty;
    public static DependencyProperty CaptionFontSizeProperty;
    public static DependencyProperty CaptionForegroundProperty;
    public static DependencyProperty CaptionShadowBrushProperty;
    public static DependencyProperty CaptionIconProperty;
    public static DependencyProperty CloseButtonStyleProperty;
    public static DependencyProperty CloseButtonVisibilityProperty;
    public static DependencyProperty IsActiveProperty;
    public static DependencyProperty LeftProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> LeftChanged;
    public static DependencyProperty TopProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> TopChanged;
    public static DependencyProperty WindowBackgroundProperty;
    public static DependencyProperty WindowBorderBrushProperty;
    public static DependencyProperty WindowBorderThicknessProperty;
    public static DependencyProperty WindowInactiveBackgroundProperty;
    public static DependencyProperty WindowOpacityProperty;
    public static DependencyProperty WindowStyleProperty;
    public static DependencyProperty WindowThicknessProperty;
    [CompilerGeneratedAttribute]
private bool <IsStartupPositionInitialized>k__BackingField;
    private bool _IsBlockMouseInputsPanelActive;
    public static RoutedEvent ActivatedEvent;
    public static RoutedEvent HeaderMouseLeftButtonClickedEvent;
    public static RoutedEvent HeaderMouseRightButtonClickedEvent;
    public static RoutedEvent HeaderMouseLeftButtonDoubleClickedEvent;
    public static RoutedEvent HeaderDragDeltaEvent;
    public static RoutedEvent HeaderIconClickedEvent;
    public static RoutedEvent HeaderIconDoubleClickedEvent;
    public static RoutedEvent CloseButtonClickedEvent;
    public string Caption { get; public set; }
    public double CaptionFontSize { get; public set; }
    public Brush CaptionForeground { get; public set; }
    public Brush CaptionShadowBrush { get; public set; }
    public ImageSource CaptionIcon { get; public set; }
    public Style CloseButtonStyle { get; public set; }
    public Visibility CloseButtonVisibility { get; public set; }
    public bool IsActive { get; public set; }
    public double Left { get; public set; }
    public double Top { get; public set; }
    public Brush WindowBackground { get; public set; }
    public Brush WindowBorderBrush { get; public set; }
    public Thickness WindowBorderThickness { get; public set; }
    public Brush WindowInactiveBackground { get; public set; }
    public double WindowOpacity { get; public set; }
    public WindowStyle WindowStyle { get; public set; }
    public Thickness WindowThickness { get; public set; }
    internal bool IsStartupPositionInitialized { get; internal set; }
    internal bool IsBlockMouseInputsPanelActive { get; internal set; }
    internal bool AllowPublicIsActiveChange { get; }
    private static WindowControl();
    public string get_Caption();
    public void set_Caption(string value);
    public double get_CaptionFontSize();
    public void set_CaptionFontSize(double value);
    public Brush get_CaptionForeground();
    public void set_CaptionForeground(Brush value);
    public Brush get_CaptionShadowBrush();
    public void set_CaptionShadowBrush(Brush value);
    public ImageSource get_CaptionIcon();
    public void set_CaptionIcon(ImageSource value);
    public Style get_CloseButtonStyle();
    public void set_CloseButtonStyle(Style value);
    public Visibility get_CloseButtonVisibility();
    public void set_CloseButtonVisibility(Visibility value);
    private static object OnCoerceCloseButtonVisibility(DependencyObject d, object basevalue);
    protected virtual object OnCoerceCloseButtonVisibility(Visibility newValue);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    private static object OnCoerceIsActive(DependencyObject d, object basevalue);
    private static void OnIsActiveChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsActiveChanged(bool oldValue, bool newValue);
    internal void SetIsActiveInternal(bool isActive);
    public double get_Left();
    public void set_Left(double value);
    private static object OnCoerceLeft(DependencyObject d, object basevalue);
    private object OnCoerceLeft(object newValue);
    private static void OnLeftPropertyChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_LeftChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_LeftChanged(EventHandler`1<EventArgs> value);
    protected virtual void OnLeftPropertyChanged(double oldValue, double newValue);
    public double get_Top();
    public void set_Top(double value);
    private static object OnCoerceTop(DependencyObject d, object basevalue);
    private object OnCoerceTop(object newValue);
    private static void OnTopPropertyChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_TopChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_TopChanged(EventHandler`1<EventArgs> value);
    protected virtual void OnTopPropertyChanged(double oldValue, double newValue);
    public Brush get_WindowBackground();
    public void set_WindowBackground(Brush value);
    public Brush get_WindowBorderBrush();
    public void set_WindowBorderBrush(Brush value);
    public Thickness get_WindowBorderThickness();
    public void set_WindowBorderThickness(Thickness value);
    public Brush get_WindowInactiveBackground();
    public void set_WindowInactiveBackground(Brush value);
    public double get_WindowOpacity();
    public void set_WindowOpacity(double value);
    public WindowStyle get_WindowStyle();
    public void set_WindowStyle(WindowStyle value);
    private static object OnCoerceWindowStyle(DependencyObject d, object basevalue);
    protected virtual object OnCoerceWindowStyle(WindowStyle newValue);
    private static void OnWindowStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnWindowStyleChanged(WindowStyle oldValue, WindowStyle newValue);
    public Thickness get_WindowThickness();
    public void set_WindowThickness(Thickness value);
    [CompilerGeneratedAttribute]
internal bool get_IsStartupPositionInitialized();
    [CompilerGeneratedAttribute]
internal void set_IsStartupPositionInitialized(bool value);
    internal bool get_IsBlockMouseInputsPanelActive();
    internal void set_IsBlockMouseInputsPanelActive(bool value);
    internal virtual bool get_AllowPublicIsActiveChange();
    public virtual void OnApplyTemplate();
    public void add_Activated(RoutedEventHandler value);
    public void remove_Activated(RoutedEventHandler value);
    public void add_HeaderMouseLeftButtonClicked(MouseButtonEventHandler value);
    public void remove_HeaderMouseLeftButtonClicked(MouseButtonEventHandler value);
    public void add_HeaderMouseRightButtonClicked(MouseButtonEventHandler value);
    public void remove_HeaderMouseRightButtonClicked(MouseButtonEventHandler value);
    public void add_HeaderMouseLeftButtonDoubleClicked(MouseButtonEventHandler value);
    public void remove_HeaderMouseLeftButtonDoubleClicked(MouseButtonEventHandler value);
    public void add_HeaderDragDelta(DragDeltaEventHandler value);
    public void remove_HeaderDragDelta(DragDeltaEventHandler value);
    public void add_HeaderIconClicked(MouseButtonEventHandler value);
    public void remove_HeaderIconClicked(MouseButtonEventHandler value);
    public void add_HeaderIconDoubleClicked(MouseButtonEventHandler value);
    public void remove_HeaderIconDoubleClicked(MouseButtonEventHandler value);
    public void add_CloseButtonClicked(RoutedEventHandler value);
    public void remove_CloseButtonClicked(RoutedEventHandler value);
    private void HeaderPreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void HeaderPreviewMouseRightButtonDown(object sender, MouseButtonEventArgs e);
    private void HeaderThumbDragDelta(object sender, DragDeltaEventArgs e);
    private void IconMouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void Close(object sender, RoutedEventArgs e);
    internal virtual void UpdateBlockMouseInputsPanel();
    internal double GetHeaderHeight();
}
public class Xceed.Wpf.Toolkit.PrimitiveTypeCollectionControl : ContentControl {
    private bool _surpressTextChanged;
    private bool _conversionFailed;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty ItemsSourceProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty ItemsSourceTypeProperty;
    public static DependencyProperty ItemTypeProperty;
    public static DependencyProperty TextProperty;
    public bool IsOpen { get; public set; }
    public IList ItemsSource { get; public set; }
    public bool IsReadOnly { get; public set; }
    public Type ItemsSourceType { get; public set; }
    public Type ItemType { get; public set; }
    public string Text { get; public set; }
    private static PrimitiveTypeCollectionControl();
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    private static void OnIsOpenChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsOpenChanged(bool oldValue, bool newValue);
    public IList get_ItemsSource();
    public void set_ItemsSource(IList value);
    private static void OnItemsSourceChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemsSourceChanged(IList oldValue, IList newValue);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public Type get_ItemsSourceType();
    public void set_ItemsSourceType(Type value);
    public Type get_ItemType();
    public void set_ItemType(Type value);
    public string get_Text();
    public void set_Text(string value);
    private static void OnTextChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTextChanged(string oldValue, string newValue);
    private void PersistChanges();
    private IList ComputeItems();
    private IList ComputeItemsSource();
    private IList CreateItemsSource();
    private void SetText(IEnumerable collection);
}
[AttributeUsageAttribute("4")]
public class Xceed.Wpf.Toolkit.PropertyGrid.Attributes.CategoryOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CategoryValue>k__BackingField;
    public int Order { get; public set; }
    public string Category { get; }
    public string CategoryValue { get; private set; }
    public object TypeId { get; }
    public CategoryOrderAttribute(string categoryName, int order);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    public virtual string get_Category();
    [CompilerGeneratedAttribute]
public string get_CategoryValue();
    [CompilerGeneratedAttribute]
private void set_CategoryValue(string value);
    public virtual object get_TypeId();
}
[AttributeUsageAttribute("4")]
public class Xceed.Wpf.Toolkit.PropertyGrid.Attributes.CategoryPropertyOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CategoryPropertyOrderEnum <CategoryPropertyOrder>k__BackingField;
    public CategoryPropertyOrderEnum CategoryPropertyOrder { get; private set; }
    public CategoryPropertyOrderAttribute(CategoryPropertyOrderEnum categoryPropertyOrder);
    [CompilerGeneratedAttribute]
public CategoryPropertyOrderEnum get_CategoryPropertyOrder();
    [CompilerGeneratedAttribute]
private void set_CategoryPropertyOrder(CategoryPropertyOrderEnum value);
}
public enum Xceed.Wpf.Toolkit.PropertyGrid.Attributes.CategoryPropertyOrderEnum : Enum {
    public int value__;
    public static CategoryPropertyOrderEnum Alphabetical;
    public static CategoryPropertyOrderEnum Declaration;
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Attributes.ExpandableObjectAttribute : Attribute {
}
public interface Xceed.Wpf.Toolkit.PropertyGrid.Attributes.IItemsSource {
    public abstract virtual ItemCollection GetValues();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Attributes.Item : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string DisplayName { get; public set; }
    public object Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Attributes.ItemCollection : List`1<Item> {
    public void Add(object value);
    public void Add(object value, string displayName);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Attributes.ItemsSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; public set; }
    public ItemsSourceAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
}
[AttributeUsageAttribute("128")]
public class Xceed.Wpf.Toolkit.PropertyGrid.Attributes.NewItemTypesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private IList`1<Type> <Types>k__BackingField;
    public IList`1<Type> Types { get; public set; }
    public NewItemTypesAttribute(Type[] types);
    [CompilerGeneratedAttribute]
public IList`1<Type> get_Types();
    [CompilerGeneratedAttribute]
public void set_Types(IList`1<Type> value);
}
[AttributeUsageAttribute("128")]
public class Xceed.Wpf.Toolkit.PropertyGrid.Attributes.PropertyOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private UsageContextEnum <UsageContext>k__BackingField;
    public int Order { get; public set; }
    public UsageContextEnum UsageContext { get; public set; }
    public object TypeId { get; }
    public PropertyOrderAttribute(int order);
    public PropertyOrderAttribute(int order, UsageContextEnum usageContext);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public UsageContextEnum get_UsageContext();
    [CompilerGeneratedAttribute]
public void set_UsageContext(UsageContextEnum value);
    public virtual object get_TypeId();
}
public enum Xceed.Wpf.Toolkit.PropertyGrid.Attributes.UsageContextEnum : Enum {
    public int value__;
    public static UsageContextEnum Alphabetical;
    public static UsageContextEnum Categorized;
    public static UsageContextEnum Both;
}
public class Xceed.Wpf.Toolkit.PropertyGrid.CategoryGroupStyleSelector : StyleSelector {
    [CompilerGeneratedAttribute]
private Style <SingleDefaultCategoryItemGroupStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private Style <ItemGroupStyle>k__BackingField;
    public Style SingleDefaultCategoryItemGroupStyle { get; public set; }
    public Style ItemGroupStyle { get; public set; }
    [CompilerGeneratedAttribute]
public Style get_SingleDefaultCategoryItemGroupStyle();
    [CompilerGeneratedAttribute]
public void set_SingleDefaultCategoryItemGroupStyle(Style value);
    [CompilerGeneratedAttribute]
public Style get_ItemGroupStyle();
    [CompilerGeneratedAttribute]
public void set_ItemGroupStyle(Style value);
    public virtual Style SelectStyle(object item, DependencyObject container);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Commands.PropertyGridCommands : object {
    private static RoutedCommand _clearFilterCommand;
    public static RoutedCommand ClearFilter { get; }
    private static PropertyGridCommands();
    public static RoutedCommand get_ClearFilter();
}
public static class Xceed.Wpf.Toolkit.PropertyGrid.Commands.PropertyItemCommands : object {
    private static RoutedCommand _resetValueCommand;
    public static RoutedCommand ResetValue { get; }
    private static PropertyItemCommands();
    public static RoutedCommand get_ResetValue();
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.CommonPropertyExceptionValidationRule : ValidationRule {
    private TypeConverter _propertyTypeConverter;
    private Type _type;
    internal CommonPropertyExceptionValidationRule(Type type);
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
}
internal abstract class Xceed.Wpf.Toolkit.PropertyGrid.ContainerHelperBase : object {
    protected IPropertyContainer PropertyContainer;
    internal static DependencyProperty IsGeneratedProperty;
    [CompilerGeneratedAttribute]
private ItemsControl <ChildrenItemsControl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCleaning>k__BackingField;
    public IList Properties { get; }
    internal ItemsControl ChildrenItemsControl { get; internal set; }
    internal bool IsCleaning { get; private set; }
    public ContainerHelperBase(IPropertyContainer propertyContainer);
    private static ContainerHelperBase();
    internal static bool GetIsGenerated(DependencyObject obj);
    internal static void SetIsGenerated(DependencyObject obj, bool value);
    public abstract virtual IList get_Properties();
    [CompilerGeneratedAttribute]
internal ItemsControl get_ChildrenItemsControl();
    [CompilerGeneratedAttribute]
internal void set_ChildrenItemsControl(ItemsControl value);
    [CompilerGeneratedAttribute]
internal bool get_IsCleaning();
    [CompilerGeneratedAttribute]
private void set_IsCleaning(bool value);
    public virtual void ClearHelper();
    public virtual void PrepareChildrenPropertyItem(PropertyItemBase propertyItem, object item);
    public virtual void ClearChildrenPropertyItem(PropertyItemBase propertyItem, object item);
    protected FrameworkElement GenerateCustomEditingElement(Type definitionKey, PropertyItemBase propertyItem);
    protected FrameworkElement GenerateCustomEditingElement(object definitionKey, PropertyItemBase propertyItem);
    protected FrameworkElement CreateCustomEditor(EditorDefinitionBase customEditor, PropertyItemBase propertyItem);
    protected virtual void OnPropertyContainerPropertyChanged(object sender, PropertyChangedEventArgs e);
    protected virtual void OnCategorizationChanged();
    protected virtual void OnFilterChanged();
    protected virtual void OnAutoGeneratePropertiesChanged();
    protected virtual void OnHideInheritedPropertiesChanged();
    protected virtual void OnEditorDefinitionsChanged();
    protected virtual void OnPropertyDefinitionsChanged();
    public virtual void OnEndInit();
    public abstract virtual PropertyItemBase ContainerFromItem(object item);
    public abstract virtual object ItemFromContainer(PropertyItemBase container);
    public abstract virtual Binding CreateChildrenDefaultBinding(PropertyItemBase propertyItem);
    public virtual void NotifyEditorDefinitionsCollectionChanged();
    public virtual void NotifyPropertyDefinitionsCollectionChanged();
    public abstract virtual void UpdateValuesFromSource();
    protected internal virtual void SetPropertiesExpansion(bool isExpanded);
    protected internal virtual void SetPropertiesExpansion(string propertyName, bool isExpanded);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Converters.EditorTimeSpanConverter : object {
    [CompilerGeneratedAttribute]
private bool <AllowNulls>k__BackingField;
    public bool AllowNulls { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowNulls();
    [CompilerGeneratedAttribute]
public void set_AllowNulls(bool value);
    private sealed virtual override object System.Windows.Data.IValueConverter.Convert(object value, Type targetType, object parameter, CultureInfo culture);
    private sealed virtual override object System.Windows.Data.IValueConverter.ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Converters.ExpandableObjectMarginConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Converters.IsDefaultCategoryConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Converters.IsStringEmptyConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.Converters.ListConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Converters.ObjectToUIElementConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Converters.PropertyItemEditorConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
    private bool IsPropertySetLocally(object editor, DependencyProperty dp);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Converters.PropertyNameTextTrimmingConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Converters.SelectedObjectConverter : object {
    private static string ValidParameterMessage;
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    private bool CompareParam(object parameter, string parameterValue);
    private object ConvertToType(object value, CultureInfo culture);
    private object ConvertToTypeName(object value, CultureInfo culture);
    private object ConvertToSelectedObjectName(object value, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.CustomPropertyItem : PropertyItemBase {
    public static DependencyProperty CategoryProperty;
    private int _categoryOrder;
    public static DependencyProperty PropertyOrderProperty;
    public static DependencyProperty ValueProperty;
    public string Category { get; public set; }
    public int CategoryOrder { get; public set; }
    public int PropertyOrder { get; public set; }
    public object Value { get; public set; }
    internal CustomPropertyItem(bool isPropertyGridCategorized, bool isSortedAlphabetically);
    private static CustomPropertyItem();
    public string get_Category();
    public void set_Category(string value);
    public int get_CategoryOrder();
    public void set_CategoryOrder(int value);
    public int get_PropertyOrder();
    public void set_PropertyOrder(int value);
    public object get_Value();
    public void set_Value(object value);
    private static object OnCoerceValueChanged(DependencyObject o, object baseValue);
    protected virtual object OnCoerceValueChanged(object baseValue);
    private static void OnValueChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnValueChanged(object oldValue, object newValue);
    protected virtual Type GetPropertyItemType();
    protected virtual void OnEditorChanged(FrameworkElement oldValue, FrameworkElement newValue);
}
public abstract class Xceed.Wpf.Toolkit.PropertyGrid.DefinitionBase : DependencyObject {
    private bool _isLocked;
    internal bool IsLocked { get; }
    internal bool get_IsLocked();
    internal void ThrowIfLocked(Expression`1<Func`1<TMember>> propertyExpression);
    internal virtual void Lock();
}
public abstract class Xceed.Wpf.Toolkit.PropertyGrid.DefinitionCollectionBase`1 : ObservableCollection`1<T> {
    protected virtual void InsertItem(int index, T item);
    protected virtual void SetItem(int index, T item);
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.DescriptorPropertyDefinition : DescriptorPropertyDefinitionBase {
    private object _selectedObject;
    private PropertyDescriptor _propertyDescriptor;
    private DependencyPropertyDescriptor _dpDescriptor;
    private static Dictionary`2<string, Type> _dictEditorTypeName;
    internal PropertyDescriptor PropertyDescriptor { get; }
    private object SelectedObject { get; }
    internal DescriptorPropertyDefinition(PropertyDescriptor propertyDescriptor, object selectedObject, IPropertyContainer propertyContainer);
    private static DescriptorPropertyDefinition();
    internal virtual PropertyDescriptor get_PropertyDescriptor();
    private object get_SelectedObject();
    internal virtual ObjectContainerHelperBase CreateContainerHelper(IPropertyContainer parent);
    internal virtual void OnValueChanged(object oldValue, object newValue);
    protected virtual void CreateValueBinding();
    protected virtual bool ComputeIsReadOnly();
    internal virtual ITypeEditor CreateDefaultEditor(PropertyItem propertyItem);
    protected virtual bool ComputeCanResetValue();
    protected virtual object ComputeAdvancedOptionsTooltip();
    protected virtual string ComputeCategory();
    protected virtual string ComputeCategoryValue();
    protected virtual bool ComputeExpandableAttribute();
    protected virtual object ComputeDefaultValueAttribute();
    protected virtual bool ComputeIsExpandable();
    protected virtual IList`1<Type> ComputeNewItemTypes();
    protected virtual string ComputeDescription();
    protected virtual int ComputeDisplayOrder(bool isPropertyGridCategorized);
    protected virtual void ResetValue();
    internal virtual ITypeEditor CreateAttributeEditor();
    private T GetAttribute();
    private void Init(PropertyDescriptor propertyDescriptor, object selectedObject);
}
internal abstract class Xceed.Wpf.Toolkit.PropertyGrid.DescriptorPropertyDefinitionBase : DependencyObject {
    private string _category;
    private string _categoryValue;
    private string _description;
    private string _displayName;
    private object _defaultValue;
    private int _displayOrder;
    private bool _expandableAttribute;
    private bool _isReadOnly;
    private IList`1<Type> _newItemTypes;
    private IEnumerable`1<CommandBinding> _commandBindings;
    [CompilerGeneratedAttribute]
private EventHandler ContainerHelperInvalidated;
    public static DependencyProperty AdvancedOptionsIconProperty;
    public static DependencyProperty AdvancedOptionsTooltipProperty;
    public static DependencyProperty IsExpandableProperty;
    [CompilerGeneratedAttribute]
private bool <IsPropertyGridCategorized>k__BackingField;
    public static DependencyProperty ValueProperty;
    internal PropertyDescriptor PropertyDescriptor { get; }
    public ImageSource AdvancedOptionsIcon { get; public set; }
    public object AdvancedOptionsTooltip { get; public set; }
    public bool IsExpandable { get; public set; }
    public string Category { get; internal set; }
    public string CategoryValue { get; internal set; }
    public IEnumerable`1<CommandBinding> CommandBindings { get; }
    public string DisplayName { get; internal set; }
    public object DefaultValue { get; public set; }
    public string Description { get; internal set; }
    public int DisplayOrder { get; internal set; }
    public bool IsReadOnly { get; }
    public IList`1<Type> NewItemTypes { get; }
    public string PropertyName { get; }
    public Type PropertyType { get; }
    internal bool ExpandableAttribute { get; internal set; }
    internal bool IsPropertyGridCategorized { get; internal set; }
    public object Value { get; public set; }
    internal DescriptorPropertyDefinitionBase(bool isPropertyGridCategorized);
    private static DescriptorPropertyDefinitionBase();
    internal abstract virtual PropertyDescriptor get_PropertyDescriptor();
    protected virtual string ComputeCategory();
    protected virtual string ComputeCategoryValue();
    protected virtual string ComputeDescription();
    protected virtual int ComputeDisplayOrder(bool isPropertyGridCategorized);
    protected virtual bool ComputeExpandableAttribute();
    protected virtual object ComputeDefaultValueAttribute();
    protected abstract virtual bool ComputeIsExpandable();
    protected virtual IList`1<Type> ComputeNewItemTypes();
    protected virtual bool ComputeIsReadOnly();
    protected virtual bool ComputeCanResetValue();
    protected virtual object ComputeAdvancedOptionsTooltip();
    protected virtual void ResetValue();
    protected abstract virtual void CreateValueBinding();
    internal abstract virtual ObjectContainerHelperBase CreateContainerHelper(IPropertyContainer parent);
    internal void RaiseContainerHelperInvalidated();
    internal virtual ITypeEditor CreateDefaultEditor(PropertyItem propertyItem);
    internal virtual ITypeEditor CreateAttributeEditor();
    internal void UpdateAdvanceOptionsForItem(DependencyObject dependencyObject, DependencyPropertyDescriptor dpDescriptor, Object& tooltip);
    internal void UpdateAdvanceOptions();
    internal void UpdateIsExpandable();
    internal void UpdateValueFromSource();
    internal object ComputeDescriptionForItem(object item);
    internal object ComputeNewItemTypesForItem(object item);
    internal object ComputeDisplayOrderForItem(object item);
    internal object ComputeExpandableAttributeForItem(object item);
    internal int ComputeDisplayOrderInternal(bool isPropertyGridCategorized);
    internal object GetValueInstance(object sourceObject);
    internal object ComputeDefaultValueAttributeForItem(object item);
    private static void ExecuteResetValueCommand(object sender, ExecutedRoutedEventArgs e);
    private static void CanExecuteResetValueCommand(object sender, CanExecuteRoutedEventArgs e);
    private string ComputeDisplayName();
    private void ValidatePropertyOrderAttributes(List`1<PropertyOrderAttribute> list);
    [CompilerGeneratedAttribute]
public void add_ContainerHelperInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ContainerHelperInvalidated(EventHandler value);
    public ImageSource get_AdvancedOptionsIcon();
    public void set_AdvancedOptionsIcon(ImageSource value);
    public object get_AdvancedOptionsTooltip();
    public void set_AdvancedOptionsTooltip(object value);
    public bool get_IsExpandable();
    public void set_IsExpandable(bool value);
    public string get_Category();
    internal void set_Category(string value);
    public string get_CategoryValue();
    internal void set_CategoryValue(string value);
    public IEnumerable`1<CommandBinding> get_CommandBindings();
    public string get_DisplayName();
    internal void set_DisplayName(string value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    public string get_Description();
    internal void set_Description(string value);
    public int get_DisplayOrder();
    internal void set_DisplayOrder(int value);
    public bool get_IsReadOnly();
    public IList`1<Type> get_NewItemTypes();
    public string get_PropertyName();
    public Type get_PropertyType();
    internal bool get_ExpandableAttribute();
    internal void set_ExpandableAttribute(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsPropertyGridCategorized();
    [CompilerGeneratedAttribute]
internal void set_IsPropertyGridCategorized(bool value);
    public object get_Value();
    public void set_Value(object value);
    private static void OnValueChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    internal virtual void OnValueChanged(object oldValue, object newValue);
    public virtual void InitProperties();
}
[ObsoleteAttribute("Use EditorTemplateDefinition instead of EditorDefinition.  (XAML Ex: <t:EditorTemplateDefinition TargetProperties="FirstName,LastName" .../> OR <t:EditorTemplateDefinition TargetProperties="{x:Type l:MyType}" .../> )")]
public class Xceed.Wpf.Toolkit.PropertyGrid.EditorDefinition : EditorTemplateDefinition {
    private static string UsageEx;
    [CompilerGeneratedAttribute]
private DataTemplate <EditorTemplate>k__BackingField;
    private PropertyDefinitionCollection _properties;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    public DataTemplate EditorTemplate { get; public set; }
    public PropertyDefinitionCollection PropertiesDefinitions { get; public set; }
    public Type TargetType { get; public set; }
    [CompilerGeneratedAttribute]
public DataTemplate get_EditorTemplate();
    [CompilerGeneratedAttribute]
public void set_EditorTemplate(DataTemplate value);
    public PropertyDefinitionCollection get_PropertiesDefinitions();
    public void set_PropertiesDefinitions(PropertyDefinitionCollection value);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(Type value);
    internal virtual void Lock();
}
public abstract class Xceed.Wpf.Toolkit.PropertyGrid.EditorDefinitionBase : PropertyDefinitionBase {
    internal FrameworkElement GenerateEditingElementInternal(PropertyItemBase propertyItem);
    protected virtual FrameworkElement GenerateEditingElement(PropertyItemBase propertyItem);
    internal void UpdateProperty(FrameworkElement element, DependencyProperty elementProp, DependencyProperty definitionProperty);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.EditorDefinitionCollection : PropertyDefinitionBaseCollection`1<EditorDefinitionBase> {
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.ByteUpDownEditor : NumericUpDownEditor`2<ByteUpDown, Nullable`1<byte>> {
    protected virtual ByteUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.CheckBoxEditor : TypeEditor`1<CheckBox> {
    protected virtual CheckBox CreateEditor();
    protected virtual void SetValueDependencyProperty();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.CollectionEditor : TypeEditor`1<CollectionControlButton> {
    protected virtual void SetValueDependencyProperty();
    protected virtual CollectionControlButton CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
    private PropertyGrid GetParentPropertyGrid(FrameworkElement element);
    private void Editor_CollectionUpdated(object sender, RoutedEventArgs e);
    protected virtual void ResolveValueBinding(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.ColorEditor : TypeEditor`1<ColorPicker> {
    protected virtual ColorPicker CreateEditor();
    protected virtual void SetValueDependencyProperty();
}
public abstract class Xceed.Wpf.Toolkit.PropertyGrid.Editors.ComboBoxEditor : TypeEditor`1<ComboBox> {
    protected virtual void SetValueDependencyProperty();
    protected virtual ComboBox CreateEditor();
    protected virtual void ResolveValueBinding(PropertyItem propertyItem);
    protected abstract virtual IEnumerable CreateItemsSource(PropertyItem propertyItem);
    private void SetItemsSource(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.DateTimeUpDownEditor : UpDownEditor`2<DateTimeUpDown, Nullable`1<DateTime>> {
    protected virtual DateTimeUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.DecimalUpDownEditor : NumericUpDownEditor`2<DecimalUpDown, Nullable`1<decimal>> {
    protected virtual DecimalUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.DoubleUpDownEditor : NumericUpDownEditor`2<DoubleUpDown, Nullable`1<double>> {
    protected virtual DoubleUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.EnumCheckComboBoxEditor : TypeEditor`1<CheckComboBox> {
    protected virtual void SetValueDependencyProperty();
    protected virtual CheckComboBox CreateEditor();
    protected virtual void ResolveValueBinding(PropertyItem propertyItem);
    private void SetItemsSource(PropertyItem propertyItem);
    protected IEnumerable CreateItemsSource(PropertyItem propertyItem);
    protected virtual IValueConverter CreateValueConverter();
    private static Object[] GetValues(Type enumType);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.EnumComboBoxEditor : ComboBoxEditor {
    protected virtual IEnumerable CreateItemsSource(PropertyItem propertyItem);
    private static Object[] GetValues(Type enumType);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.FontComboBoxEditor : ComboBoxEditor {
    protected virtual IEnumerable CreateItemsSource(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.IntegerUpDownEditor : NumericUpDownEditor`2<IntegerUpDown, Nullable`1<int>> {
    protected virtual IntegerUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.ItemsSourceAttributeEditor : TypeEditor`1<ComboBox> {
    private ItemsSourceAttribute _attribute;
    public ItemsSourceAttributeEditor(ItemsSourceAttribute attribute);
    protected virtual void SetValueDependencyProperty();
    protected virtual ComboBox CreateEditor();
    protected virtual void ResolveValueBinding(PropertyItem propertyItem);
    protected virtual void SetControlProperties(PropertyItem propertyItem);
    private void SetItemsSource();
    private IEnumerable CreateItemsSource();
}
public interface Xceed.Wpf.Toolkit.PropertyGrid.Editors.ITypeEditor {
    public abstract virtual FrameworkElement ResolveEditor(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.LongUpDownEditor : NumericUpDownEditor`2<LongUpDown, Nullable`1<long>> {
    protected virtual LongUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.MaskedTextBoxEditor : TypeEditor`1<MaskedTextBox> {
    [CompilerGeneratedAttribute]
private string <Mask>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ValueDataType>k__BackingField;
    public string Mask { get; public set; }
    public Type ValueDataType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Mask();
    [CompilerGeneratedAttribute]
public void set_Mask(string value);
    [CompilerGeneratedAttribute]
public Type get_ValueDataType();
    [CompilerGeneratedAttribute]
public void set_ValueDataType(Type value);
    protected virtual MaskedTextBox CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
    protected virtual void SetValueDependencyProperty();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.NumericUpDownEditor`2 : UpDownEditor`2<TEditor, TType> {
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PasswordEditor : TypeEditor`1<WatermarkPasswordBox> {
    protected virtual WatermarkPasswordBox CreateEditor();
    protected virtual void SetValueDependencyProperty();
    protected virtual IValueConverter CreateValueConverter();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PasswordToStringConverter : object {
    private WatermarkPasswordBox _editor;
    public PasswordToStringConverter(WatermarkPasswordBox editor);
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PrimitiveTypeCollectionEditor : TypeEditor`1<PrimitiveTypeCollectionControl> {
    protected virtual void SetValueDependencyProperty();
    protected virtual PrimitiveTypeCollectionControl CreateEditor();
    protected virtual void ResolveValueBinding(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorByteUpDown : ByteUpDown {
    private static PropertyGridEditorByteUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorCheckBox : CheckBox {
    private static PropertyGridEditorCheckBox();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorCollectionControl : CollectionControlButton {
    private static PropertyGridEditorCollectionControl();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorColorPicker : ColorPicker {
    private static PropertyGridEditorColorPicker();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorComboBox : ComboBox {
    private static PropertyGridEditorComboBox();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorDateTimeUpDown : DateTimeUpDown {
    private static PropertyGridEditorDateTimeUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorDecimalUpDown : DecimalUpDown {
    private static PropertyGridEditorDecimalUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorDoubleUpDown : DoubleUpDown {
    private static PropertyGridEditorDoubleUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorEnumCheckComboBox : CheckComboBox {
    private static PropertyGridEditorEnumCheckComboBox();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorIntegerUpDown : IntegerUpDown {
    private static PropertyGridEditorIntegerUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorLongUpDown : LongUpDown {
    private static PropertyGridEditorLongUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorMaskedTextBox : MaskedTextBox {
    private static PropertyGridEditorMaskedTextBox();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorPrimitiveTypeCollectionControl : PrimitiveTypeCollectionControl {
    private static PropertyGridEditorPrimitiveTypeCollectionControl();
}
[CLSCompliantAttribute("False")]
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorSByteUpDown : SByteUpDown {
    private static PropertyGridEditorSByteUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorShortUpDown : ShortUpDown {
    private static PropertyGridEditorShortUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorSingleUpDown : SingleUpDown {
    private static PropertyGridEditorSingleUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorTextBlock : TextBlock {
    private static PropertyGridEditorTextBlock();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorTextBox : WatermarkTextBox {
    private static PropertyGridEditorTextBox();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorTimeSpanUpDown : TimeSpanUpDown {
    private static PropertyGridEditorTimeSpanUpDown();
}
[CLSCompliantAttribute("False")]
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorUIntegerUpDown : UIntegerUpDown {
    private static PropertyGridEditorUIntegerUpDown();
}
[CLSCompliantAttribute("False")]
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorULongUpDown : ULongUpDown {
    private static PropertyGridEditorULongUpDown();
}
[CLSCompliantAttribute("False")]
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorUShortUpDown : UShortUpDown {
    private static PropertyGridEditorUShortUpDown();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.PropertyGridEditorWatermarkPasswordBox : WatermarkPasswordBox {
    private static PropertyGridEditorWatermarkPasswordBox();
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.Editors.SByteUpDownEditor : NumericUpDownEditor`2<SByteUpDown, Nullable`1<sbyte>> {
    protected virtual SByteUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.ShortUpDownEditor : NumericUpDownEditor`2<ShortUpDown, Nullable`1<short>> {
    protected virtual ShortUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.SingleUpDownEditor : NumericUpDownEditor`2<SingleUpDown, Nullable`1<float>> {
    protected virtual SingleUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.SourceComboBoxEditor : ComboBoxEditor {
    internal static string ComboBoxNullValue;
    private ICollection _collection;
    private TypeConverter _typeConverter;
    public SourceComboBoxEditor(ICollection collection, TypeConverter typeConverter);
    private static SourceComboBoxEditor();
    protected virtual IEnumerable CreateItemsSource(PropertyItem propertyItem);
    protected virtual IValueConverter CreateValueConverter();
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.Editors.SourceComboBoxEditorMultiStringConverter : object {
    private Type enumType;
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
    private static IEnumerable`1<Enum> GetFlags(Enum input);
    [CompilerGeneratedAttribute]
private object <ConvertBack>b__2_1(string x);
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.Editors.SourceComboBoxEditorNullableConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.Editors.SourceComboBoxEditorStringConverter : object {
    private TypeConverter _typeConverter;
    internal SourceComboBoxEditorStringConverter(TypeConverter typeConverter);
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.TextBlockEditor : TypeEditor`1<TextBlock> {
    private TypeConverter _typeConverter;
    public TextBlockEditor(TypeConverter typeConverter);
    protected virtual TextBlock CreateEditor();
    protected virtual void SetValueDependencyProperty();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.TextBoxEditor : TypeEditor`1<WatermarkTextBox> {
    protected virtual WatermarkTextBox CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
    protected virtual void SetValueDependencyProperty();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.TimeSpanUpDownEditor : UpDownEditor`2<TimeSpanUpDown, Nullable`1<TimeSpan>> {
    protected virtual TimeSpanUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public abstract class Xceed.Wpf.Toolkit.PropertyGrid.Editors.TypeEditor`1 : object {
    [CompilerGeneratedAttribute]
private T <Editor>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyProperty <ValueProperty>k__BackingField;
    protected T Editor { get; protected set; }
    protected DependencyProperty ValueProperty { get; protected set; }
    [CompilerGeneratedAttribute]
protected T get_Editor();
    [CompilerGeneratedAttribute]
protected void set_Editor(T value);
    [CompilerGeneratedAttribute]
protected DependencyProperty get_ValueProperty();
    [CompilerGeneratedAttribute]
protected void set_ValueProperty(DependencyProperty value);
    public virtual FrameworkElement ResolveEditor(PropertyItem propertyItem);
    protected virtual T CreateEditor();
    protected virtual IValueConverter CreateValueConverter();
    protected virtual void ResolveValueBinding(PropertyItem propertyItem);
    protected virtual void SetControlProperties(PropertyItem propertyItem);
    protected abstract virtual void SetValueDependencyProperty();
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.Editors.UIntegerUpDownEditor : NumericUpDownEditor`2<UIntegerUpDown, Nullable`1<UInt32>> {
    protected virtual UIntegerUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.Editors.ULongUpDownEditor : NumericUpDownEditor`2<ULongUpDown, Nullable`1<ulong>> {
    protected virtual ULongUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.Editors.UpDownEditor`2 : TypeEditor`1<TEditor> {
    protected virtual void SetValueDependencyProperty();
    internal void SetMinMaxFromRangeAttribute(PropertyDescriptor propertyDescriptor, TypeConverter converter);
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.Editors.UShortUpDownEditor : NumericUpDownEditor`2<UShortUpDown, Nullable`1<ushort>> {
    protected virtual UShortUpDown CreateEditor();
    protected virtual void SetControlProperties(PropertyItem propertyItem);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.EditorTemplateDefinition : EditorDefinitionBase {
    public static DependencyProperty EditingTemplateProperty;
    public DataTemplate EditingTemplate { get; public set; }
    private static EditorTemplateDefinition();
    public DataTemplate get_EditingTemplate();
    public void set_EditingTemplate(DataTemplate value);
    protected sealed virtual FrameworkElement GenerateEditingElement(PropertyItemBase propertyItem);
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.FilterInfo : ValueType {
    public string InputString;
    public Predicate`1<object> Predicate;
}
internal interface Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer {
    public ContainerHelperBase ContainerHelper { get; }
    public Style PropertyContainerStyle { get; }
    public EditorDefinitionCollection EditorDefinitions { get; }
    public PropertyDefinitionCollection PropertyDefinitions { get; }
    public bool IsCategorized { get; }
    public bool IsSortedAlphabetically { get; }
    public bool AutoGenerateProperties { get; }
    public bool HideInheritedProperties { get; }
    public FilterInfo FilterInfo { get; }
    public abstract virtual ContainerHelperBase get_ContainerHelper();
    public abstract virtual Style get_PropertyContainerStyle();
    public abstract virtual EditorDefinitionCollection get_EditorDefinitions();
    public abstract virtual PropertyDefinitionCollection get_PropertyDefinitions();
    public abstract virtual bool get_IsCategorized();
    public abstract virtual bool get_IsSortedAlphabetically();
    public abstract virtual bool get_AutoGenerateProperties();
    public abstract virtual bool get_HideInheritedProperties();
    public abstract virtual FilterInfo get_FilterInfo();
    public abstract virtual Nullable`1<bool> IsPropertyVisible(PropertyDescriptor pd);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.IsPropertyBrowsableArgs : PropertyArgs {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsBrowsable>k__BackingField;
    public Nullable`1<bool> IsBrowsable { get; public set; }
    public IsPropertyBrowsableArgs(PropertyDescriptor pd);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsBrowsable();
    [CompilerGeneratedAttribute]
public void set_IsBrowsable(Nullable`1<bool> value);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.IsPropertyBrowsableHandler : MulticastDelegate {
    public IsPropertyBrowsableHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, IsPropertyBrowsableArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, IsPropertyBrowsableArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.ObjectContainerHelper : ObjectContainerHelperBase {
    private object _selectedObject;
    private object SelectedObject { get; }
    public ObjectContainerHelper(IPropertyContainer propertyContainer, object selectedObject);
    private object get_SelectedObject();
    protected virtual string GetDefaultPropertyName();
    protected virtual void GenerateSubPropertiesCore(Action`1<IEnumerable`1<PropertyItem>> updatePropertyItemsCallback);
    private PropertyItem CreatePropertyItem(PropertyDescriptor property, PropertyDefinition propertyDef);
    private int GetCategoryOrder(object categoryValue);
}
internal abstract class Xceed.Wpf.Toolkit.PropertyGrid.ObjectContainerHelperBase : ContainerHelperBase {
    private bool _isPreparingItemFlag;
    private PropertyItemCollection _propertyItemCollection;
    [CompilerGeneratedAttribute]
private EventHandler ObjectsGenerated;
    public IList Properties { get; }
    private PropertyItem DefaultProperty { get; }
    protected PropertyItemCollection PropertyItems { get; }
    public ObjectContainerHelperBase(IPropertyContainer propertyContainer);
    public virtual IList get_Properties();
    private PropertyItem get_DefaultProperty();
    protected PropertyItemCollection get_PropertyItems();
    public virtual PropertyItemBase ContainerFromItem(object item);
    public virtual object ItemFromContainer(PropertyItemBase container);
    public virtual void UpdateValuesFromSource();
    public void GenerateProperties();
    protected virtual void OnFilterChanged();
    protected virtual void OnCategorizationChanged();
    protected virtual void OnAutoGeneratePropertiesChanged();
    protected virtual void OnHideInheritedPropertiesChanged();
    protected virtual void OnEditorDefinitionsChanged();
    protected virtual void OnPropertyDefinitionsChanged();
    protected internal virtual void SetPropertiesExpansion(bool isExpanded);
    protected internal virtual void SetPropertiesExpansion(string propertyName, bool isExpanded);
    private void UpdateFilter();
    private void UpdateCategorization(bool updateSubPropertiesCategorization);
    private GroupDescription ComputeCategoryGroupDescription();
    private string GetCategoryGroupingPropertyName();
    private void OnChildrenPropertyChanged(object sender, PropertyChangedEventArgs e);
    protected abstract virtual string GetDefaultPropertyName();
    protected abstract virtual void GenerateSubPropertiesCore(Action`1<IEnumerable`1<PropertyItem>> updatePropertyItemsCallback);
    private void RegenerateProperties();
    protected internal virtual void UpdatePropertyItemsCallback(IEnumerable`1<PropertyItem> subProperties);
    protected static List`1<PropertyDescriptor> GetPropertyDescriptors(object instance, bool hideInheritedProperties);
    protected bool GetWillRefreshPropertyGrid(PropertyDescriptor propertyDescriptor);
    internal void InitializeDescriptorDefinition(DescriptorPropertyDefinitionBase descriptorDef, PropertyDefinition propertyDefinition);
    private void InitializePropertyItem(PropertyItem propertyItem);
    private object GetTypeDefaultValue(Type type);
    private void SetupDefinitionBinding(PropertyItem propertyItem, DependencyProperty itemProperty, DescriptorPropertyDefinitionBase pd, Expression`1<Func`1<T>> definitionProperty, BindingMode bindingMode);
    internal FrameworkElement GenerateChildrenEditorElement(PropertyItem propertyItem);
    internal PropertyDefinition GetPropertyDefinition(PropertyDescriptor descriptor);
    public virtual void PrepareChildrenPropertyItem(PropertyItemBase propertyItem, object item);
    public virtual void ClearChildrenPropertyItem(PropertyItemBase propertyItem, object item);
    public virtual Binding CreateChildrenDefaultBinding(PropertyItemBase propertyItem);
    protected static string GetDefaultPropertyName(object instance);
    private static bool IsItemOrderingProperty(string propertyName);
    [CompilerGeneratedAttribute]
internal void add_ObjectsGenerated(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ObjectsGenerated(EventHandler value);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private PropertyDescriptor <PropertyDescriptor>k__BackingField;
    public PropertyDescriptor PropertyDescriptor { get; private set; }
    public PropertyArgs(PropertyDescriptor pd);
    [CompilerGeneratedAttribute]
public PropertyDescriptor get_PropertyDescriptor();
    [CompilerGeneratedAttribute]
private void set_PropertyDescriptor(PropertyDescriptor value);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyDefinition : PropertyDefinitionBase {
    private string _name;
    private Nullable`1<bool> _isBrowsable;
    private Nullable`1<bool> _isExpandable;
    private string _displayName;
    private string _description;
    private string _category;
    private Nullable`1<int> _displayOrder;
    [ObsoleteAttribute("Use 'TargetProperties' instead of 'Name'")]
public string Name { get; public set; }
    public string Category { get; public set; }
    public string DisplayName { get; public set; }
    public string Description { get; public set; }
    public Nullable`1<int> DisplayOrder { get; public set; }
    public Nullable`1<bool> IsBrowsable { get; public set; }
    public Nullable`1<bool> IsExpandable { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Category();
    public void set_Category(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_Description();
    public void set_Description(string value);
    public Nullable`1<int> get_DisplayOrder();
    public void set_DisplayOrder(Nullable`1<int> value);
    public Nullable`1<bool> get_IsBrowsable();
    public void set_IsBrowsable(Nullable`1<bool> value);
    public Nullable`1<bool> get_IsExpandable();
    public void set_IsExpandable(Nullable`1<bool> value);
    internal virtual void Lock();
}
public abstract class Xceed.Wpf.Toolkit.PropertyGrid.PropertyDefinitionBase : DefinitionBase {
    private IList _targetProperties;
    private PropertyDefinitionCollection _propertyDefinitions;
    [TypeConverterAttribute("Xceed.Wpf.Toolkit.PropertyGrid.Converters.ListConverter")]
public IList TargetProperties { get; public set; }
    public PropertyDefinitionCollection PropertyDefinitions { get; public set; }
    public IList get_TargetProperties();
    public void set_TargetProperties(IList value);
    public PropertyDefinitionCollection get_PropertyDefinitions();
    public void set_PropertyDefinitions(PropertyDefinitionCollection value);
    internal virtual void Lock();
}
[DefaultMemberAttribute("Item")]
public abstract class Xceed.Wpf.Toolkit.PropertyGrid.PropertyDefinitionBaseCollection`1 : DefinitionCollectionBase`1<T> {
    public T Item { get; }
    public virtual T get_Item(object propertyId);
    internal T GetRecursiveBaseTypes(Type type);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyDefinitionCollection : PropertyDefinitionBaseCollection`1<PropertyDefinition> {
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[StyleTypedPropertyAttribute]
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyGrid : Control {
    private static string PART_DragThumb;
    internal static string PART_PropertyItemsControl;
    private static ComponentResourceKey SelectedObjectAdvancedOptionsMenuKey;
    private Thumb _dragThumb;
    private bool _hasPendingSelectedObjectChanged;
    private int _initializationCount;
    private ContainerHelperBase _containerHelper;
    private WeakEventListener`1<NotifyCollectionChangedEventArgs> _propertyDefinitionsListener;
    private WeakEventListener`1<NotifyCollectionChangedEventArgs> _editorDefinitionsListener;
    public static DependencyProperty AdvancedOptionsMenuProperty;
    public static DependencyProperty AutoGeneratePropertiesProperty;
    public static DependencyProperty CategoryGroupHeaderTemplateProperty;
    public static DependencyProperty ShowDescriptionByTooltipProperty;
    public static DependencyProperty ShowSummaryProperty;
    public static DependencyProperty EditorDefinitionsProperty;
    public static DependencyProperty FilterProperty;
    public static DependencyProperty FilterWatermarkProperty;
    public static DependencyProperty HideInheritedPropertiesProperty;
    public static DependencyProperty IsCategorizedProperty;
    public static DependencyProperty IsMiscCategoryLabelHiddenProperty;
    public static DependencyProperty IsScrollingToTopAfterRefreshProperty;
    public static DependencyProperty IsVirtualizingProperty;
    public static DependencyProperty NameColumnWidthProperty;
    public static DependencyProperty PropertyNameLeftPaddingProperty;
    public static DependencyProperty PropertyNameTextWrappingProperty;
    public static DependencyProperty PropertyContainerStyleProperty;
    public static DependencyProperty PropertyDefinitionsProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty SelectedObjectProperty;
    public static DependencyProperty SelectedObjectTypeProperty;
    public static DependencyProperty SelectedObjectTypeNameProperty;
    public static DependencyProperty SelectedObjectNameProperty;
    private static DependencyPropertyKey SelectedPropertyItemPropertyKey;
    public static DependencyProperty SelectedPropertyItemProperty;
    public static DependencyProperty SelectedPropertyProperty;
    public static DependencyProperty ShowAdvancedOptionsProperty;
    public static DependencyProperty ShowHorizontalScrollBarProperty;
    public static DependencyProperty ShowPreviewProperty;
    public static DependencyProperty ShowSearchBoxProperty;
    public static DependencyProperty ShowSortOptionsProperty;
    public static DependencyProperty ShowTitleProperty;
    public static DependencyProperty UpdateTextBoxSourceOnEnterKeyProperty;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public static RoutedEvent PropertyValueChangedEvent;
    public static RoutedEvent SelectedPropertyItemChangedEvent;
    public static RoutedEvent SelectedObjectChangedEvent;
    [CompilerGeneratedAttribute]
private IsPropertyBrowsableHandler IsPropertyBrowsable;
    public static RoutedEvent PreparePropertyItemEvent;
    public static RoutedEvent ClearPropertyItemEvent;
    public static RoutedEvent PropertiesGeneratedEvent;
    public ContextMenu AdvancedOptionsMenu { get; public set; }
    public bool AutoGenerateProperties { get; public set; }
    public DataTemplate CategoryGroupHeaderTemplate { get; public set; }
    public bool ShowDescriptionByTooltip { get; public set; }
    public bool ShowSummary { get; public set; }
    public EditorDefinitionCollection EditorDefinitions { get; public set; }
    public string Filter { get; public set; }
    public string FilterWatermark { get; public set; }
    public bool HideInheritedProperties { get; public set; }
    public bool IsCategorized { get; public set; }
    public bool IsMiscCategoryLabelHidden { get; public set; }
    public bool IsScrollingToTopAfterRefresh { get; public set; }
    public bool IsVirtualizing { get; public set; }
    public double NameColumnWidth { get; public set; }
    public double PropertyNameLeftPadding { get; public set; }
    public TextWrapping PropertyNameTextWrapping { get; public set; }
    public IList Properties { get; }
    public Style PropertyContainerStyle { get; public set; }
    public PropertyDefinitionCollection PropertyDefinitions { get; public set; }
    public bool IsReadOnly { get; public set; }
    public object SelectedObject { get; public set; }
    public Type SelectedObjectType { get; public set; }
    public string SelectedObjectTypeName { get; public set; }
    public string SelectedObjectName { get; public set; }
    public PropertyItemBase SelectedPropertyItem { get; internal set; }
    public object SelectedProperty { get; public set; }
    public bool ShowAdvancedOptions { get; public set; }
    public bool ShowHorizontalScrollBar { get; public set; }
    public bool ShowPreview { get; public set; }
    public bool ShowSearchBox { get; public set; }
    public bool ShowSortOptions { get; public set; }
    public bool ShowTitle { get; public set; }
    public bool UpdateTextBoxSourceOnEnterKey { get; public set; }
    private FilterInfo Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.FilterInfo { get; }
    private ContainerHelperBase Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.ContainerHelper { get; }
    private bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.IsSortedAlphabetically { get; }
    private static PropertyGrid();
    public ContextMenu get_AdvancedOptionsMenu();
    public void set_AdvancedOptionsMenu(ContextMenu value);
    public sealed virtual bool get_AutoGenerateProperties();
    public void set_AutoGenerateProperties(bool value);
    public DataTemplate get_CategoryGroupHeaderTemplate();
    public void set_CategoryGroupHeaderTemplate(DataTemplate value);
    public bool get_ShowDescriptionByTooltip();
    public void set_ShowDescriptionByTooltip(bool value);
    public bool get_ShowSummary();
    public void set_ShowSummary(bool value);
    public sealed virtual EditorDefinitionCollection get_EditorDefinitions();
    public void set_EditorDefinitions(EditorDefinitionCollection value);
    private static void OnEditorDefinitionsChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnEditorDefinitionsChanged(EditorDefinitionCollection oldValue, EditorDefinitionCollection newValue);
    private void OnEditorDefinitionsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    public string get_Filter();
    public void set_Filter(string value);
    private static void OnFilterChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnFilterChanged(string oldValue, string newValue);
    public string get_FilterWatermark();
    public void set_FilterWatermark(string value);
    public sealed virtual bool get_HideInheritedProperties();
    public void set_HideInheritedProperties(bool value);
    public sealed virtual bool get_IsCategorized();
    public void set_IsCategorized(bool value);
    private static void OnIsCategorizedChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsCategorizedChanged(bool oldValue, bool newValue);
    public bool get_IsMiscCategoryLabelHidden();
    public void set_IsMiscCategoryLabelHidden(bool value);
    public bool get_IsScrollingToTopAfterRefresh();
    public void set_IsScrollingToTopAfterRefresh(bool value);
    public bool get_IsVirtualizing();
    public void set_IsVirtualizing(bool value);
    private static void OnIsVirtualizingChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsVirtualizingChanged(bool oldValue, bool newValue);
    public double get_NameColumnWidth();
    public void set_NameColumnWidth(double value);
    private static void OnNameColumnWidthChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnNameColumnWidthChanged(double oldValue, double newValue);
    public double get_PropertyNameLeftPadding();
    public void set_PropertyNameLeftPadding(double value);
    public TextWrapping get_PropertyNameTextWrapping();
    public void set_PropertyNameTextWrapping(TextWrapping value);
    public IList get_Properties();
    public sealed virtual Style get_PropertyContainerStyle();
    public void set_PropertyContainerStyle(Style value);
    private static void OnPropertyContainerStyleChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnPropertyContainerStyleChanged(Style oldValue, Style newValue);
    public sealed virtual PropertyDefinitionCollection get_PropertyDefinitions();
    public void set_PropertyDefinitions(PropertyDefinitionCollection value);
    private static void OnPropertyDefinitionsChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnPropertyDefinitionsChanged(PropertyDefinitionCollection oldValue, PropertyDefinitionCollection newValue);
    private void OnPropertyDefinitionsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    private static void OnIsReadOnlyChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsReadOnlyChanged(bool oldValue, bool newValue);
    public object get_SelectedObject();
    public void set_SelectedObject(object value);
    private static void OnSelectedObjectChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectedObjectChanged(object oldValue, object newValue);
    public Type get_SelectedObjectType();
    public void set_SelectedObjectType(Type value);
    private static void OnSelectedObjectTypeChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectedObjectTypeChanged(Type oldValue, Type newValue);
    public string get_SelectedObjectTypeName();
    public void set_SelectedObjectTypeName(string value);
    public string get_SelectedObjectName();
    public void set_SelectedObjectName(string value);
    private static object OnCoerceSelectedObjectName(DependencyObject o, object baseValue);
    private static void OnSelectedObjectNameChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void SelectedObjectNameChanged(string oldValue, string newValue);
    public PropertyItemBase get_SelectedPropertyItem();
    internal void set_SelectedPropertyItem(PropertyItemBase value);
    private static void OnSelectedPropertyItemChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectedPropertyItemChanged(PropertyItemBase oldValue, PropertyItemBase newValue);
    public object get_SelectedProperty();
    public void set_SelectedProperty(object value);
    private static void OnSelectedPropertyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    private void OnSelectedPropertyChanged(object oldValue, object newValue);
    public bool get_ShowAdvancedOptions();
    public void set_ShowAdvancedOptions(bool value);
    public bool get_ShowHorizontalScrollBar();
    public void set_ShowHorizontalScrollBar(bool value);
    public bool get_ShowPreview();
    public void set_ShowPreview(bool value);
    public bool get_ShowSearchBox();
    public void set_ShowSearchBox(bool value);
    public bool get_ShowSortOptions();
    public void set_ShowSortOptions(bool value);
    public bool get_ShowTitle();
    public void set_ShowTitle(bool value);
    public bool get_UpdateTextBoxSourceOnEnterKey();
    public void set_UpdateTextBoxSourceOnEnterKey(bool value);
    public virtual void OnApplyTemplate();
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private void OnItemSelectionChanged(object sender, RoutedEventArgs args);
    private void OnPreparePropertyItemInternal(object sender, PropertyItemEventArgs args);
    private void OnClearPropertyItemInternal(object sender, PropertyItemEventArgs args);
    private void DragThumb_DragDelta(object sender, DragDeltaEventArgs e);
    private void DragThumb_MouseWheel(object sender, MouseWheelEventArgs e);
    private void PropertyGrid_PropertyValueChanged(object sender, PropertyValueChangedEventArgs e);
    private void ClearFilter(object sender, ExecutedRoutedEventArgs e);
    private void CanClearFilter(object sender, CanExecuteRoutedEventArgs e);
    public double GetScrollPosition();
    public void ScrollToPosition(double position);
    public void ScrollToTop();
    public void ScrollToBottom();
    public void CollapseAllProperties();
    public void ExpandAllProperties();
    public void ExpandProperty(string propertyName);
    public void CollapseProperty(string propertyName);
    private ScrollViewer GetScrollViewer();
    private void RebuildPropertyItemEditor(PropertyItem propertyItem);
    private void UpdateContainerHelper();
    private void SetContainerHelper(ContainerHelperBase containerHelper);
    private void FinalizeUpdateContainerHelper(ItemsControl childrenItemsControl);
    private void UpdateThumb();
    protected virtual Predicate`1<object> CreateFilter(string filter);
    public void Update();
    private void ObjectContainerHelper_ObjectsGenerated(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public void add_PropertyValueChanged(PropertyValueChangedEventHandler value);
    public void remove_PropertyValueChanged(PropertyValueChangedEventHandler value);
    public void add_SelectedPropertyItemChanged(RoutedPropertyChangedEventHandler`1<PropertyItemBase> value);
    public void remove_SelectedPropertyItemChanged(RoutedPropertyChangedEventHandler`1<PropertyItemBase> value);
    public void add_SelectedObjectChanged(RoutedPropertyChangedEventHandler`1<object> value);
    public void remove_SelectedObjectChanged(RoutedPropertyChangedEventHandler`1<object> value);
    [CompilerGeneratedAttribute]
public void add_IsPropertyBrowsable(IsPropertyBrowsableHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsPropertyBrowsable(IsPropertyBrowsableHandler value);
    public void add_PreparePropertyItem(PropertyItemEventHandler value);
    public void remove_PreparePropertyItem(PropertyItemEventHandler value);
    public static void AddPreparePropertyItemHandler(UIElement element, PropertyItemEventHandler handler);
    public static void RemovePreparePropertyItemHandler(UIElement element, PropertyItemEventHandler handler);
    internal static void RaisePreparePropertyItemEvent(UIElement source, PropertyItemBase propertyItem, object item);
    public void add_ClearPropertyItem(PropertyItemEventHandler value);
    public void remove_ClearPropertyItem(PropertyItemEventHandler value);
    public void add_PropertiesGenerated(RoutedEventHandler value);
    public void remove_PropertiesGenerated(RoutedEventHandler value);
    public static void AddClearPropertyItemHandler(UIElement element, PropertyItemEventHandler handler);
    public static void RemoveClearPropertyItemHandler(UIElement element, PropertyItemEventHandler handler);
    internal static void RaiseClearPropertyItemEvent(UIElement source, PropertyItemBase propertyItem, object item);
    public virtual void BeginInit();
    public virtual void EndInit();
    private sealed virtual override FilterInfo Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_FilterInfo();
    private sealed virtual override ContainerHelperBase Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_ContainerHelper();
    private sealed virtual override bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_IsSortedAlphabetically();
    private sealed virtual override Nullable`1<bool> Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.IsPropertyVisible(PropertyDescriptor pd);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyGridContextMenu : ContextMenu {
    protected virtual void OnOpened(RoutedEventArgs e);
}
internal class Xceed.Wpf.Toolkit.PropertyGrid.PropertyGridUtilities : object {
    internal static T GetAttribute(PropertyDescriptor property);
    internal static ITypeEditor CreateDefaultEditor(Type propertyType, TypeConverter typeConverter, PropertyItem propertyItem);
}
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyItem : CustomPropertyItem {
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty IsInvalidProperty;
    [CompilerGeneratedAttribute]
private PropertyDescriptor <PropertyDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private DescriptorPropertyDefinitionBase <DescriptorDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    public bool IsReadOnly { get; public set; }
    public bool IsInvalid { get; internal set; }
    public PropertyDescriptor PropertyDescriptor { get; internal set; }
    public string PropertyName { get; }
    public Type PropertyType { get; }
    internal DescriptorPropertyDefinitionBase DescriptorDefinition { get; private set; }
    public object Instance { get; internal set; }
    internal PropertyItem(DescriptorPropertyDefinitionBase definition);
    private static PropertyItem();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    private static void OnIsReadOnlyChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsReadOnlyChanged(bool oldValue, bool newValue);
    public bool get_IsInvalid();
    internal void set_IsInvalid(bool value);
    private static void OnIsInvalidChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsInvalidChanged(bool oldValue, bool newValue);
    [CompilerGeneratedAttribute]
public PropertyDescriptor get_PropertyDescriptor();
    [CompilerGeneratedAttribute]
internal void set_PropertyDescriptor(PropertyDescriptor value);
    public string get_PropertyName();
    public Type get_PropertyType();
    [CompilerGeneratedAttribute]
internal DescriptorPropertyDefinitionBase get_DescriptorDefinition();
    [CompilerGeneratedAttribute]
private void set_DescriptorDefinition(DescriptorPropertyDefinitionBase value);
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
internal void set_Instance(object value);
    protected virtual string GetPropertyItemName();
    protected virtual Type GetPropertyItemType();
    protected virtual void OnIsExpandedChanged(bool oldValue, bool newValue);
    protected virtual object OnCoerceValueChanged(object baseValue);
    protected virtual void OnValueChanged(object oldValue, object newValue);
    internal void SetRedInvalidBorder(BindingExpression be);
    internal void RebuildEditor();
    private void OnDefinitionContainerHelperInvalidated(object sender, EventArgs e);
    private void Init(DescriptorPropertyDefinitionBase definition);
    private void GenerateExpandedPropertyItems();
    private void PropertyItem_Loaded(object sender, RoutedEventArgs e);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public abstract class Xceed.Wpf.Toolkit.PropertyGrid.PropertyItemBase : Control {
    internal static string PART_ValueContainer;
    private ContentControl _valueContainer;
    private ContainerHelperBase _containerHelper;
    private IPropertyContainer _parentNode;
    internal bool _isPropertyGridCategorized;
    internal bool _isSortedAlphabetically;
    public static DependencyProperty AdvancedOptionsIconProperty;
    public static DependencyProperty AdvancedOptionsTooltipProperty;
    public static DependencyProperty DescriptionProperty;
    public static DependencyProperty DisplayNameProperty;
    public static DependencyProperty EditorProperty;
    public static DependencyProperty HighlightedTextProperty;
    public static DependencyProperty IsExpandedProperty;
    public static DependencyProperty IsExpandableProperty;
    public static DependencyProperty IsSelectedProperty;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    public static DependencyProperty WillRefreshPropertyGridProperty;
    internal static RoutedEvent ItemSelectionChangedEvent;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public ImageSource AdvancedOptionsIcon { get; public set; }
    public object AdvancedOptionsTooltip { get; public set; }
    public string Description { get; public set; }
    public string DisplayName { get; public set; }
    public FrameworkElement Editor { get; public set; }
    public string HighlightedText { get; public set; }
    public bool IsExpanded { get; public set; }
    public bool IsExpandable { get; public set; }
    public bool IsSelected { get; public set; }
    public FrameworkElement ParentElement { get; }
    internal IPropertyContainer ParentNode { get; internal set; }
    internal ContentControl ValueContainer { get; }
    public int Level { get; internal set; }
    public IList Properties { get; }
    public Style PropertyContainerStyle { get; }
    internal ContainerHelperBase ContainerHelper { get; internal set; }
    public bool WillRefreshPropertyGrid { get; public set; }
    private Style Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.PropertyContainerStyle { get; }
    private EditorDefinitionCollection Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.EditorDefinitions { get; }
    private PropertyDefinitionCollection Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.PropertyDefinitions { get; }
    private ContainerHelperBase Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.ContainerHelper { get; }
    private bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.IsCategorized { get; }
    private bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.IsSortedAlphabetically { get; }
    private bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.AutoGenerateProperties { get; }
    private bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.HideInheritedProperties { get; }
    private FilterInfo Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.FilterInfo { get; }
    private static PropertyItemBase();
    public ImageSource get_AdvancedOptionsIcon();
    public void set_AdvancedOptionsIcon(ImageSource value);
    public object get_AdvancedOptionsTooltip();
    public void set_AdvancedOptionsTooltip(object value);
    public string get_Description();
    public void set_Description(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public FrameworkElement get_Editor();
    public void set_Editor(FrameworkElement value);
    private static void OnEditorChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnEditorChanged(FrameworkElement oldValue, FrameworkElement newValue);
    public string get_HighlightedText();
    public void set_HighlightedText(string value);
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    private static void OnIsExpandedChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsExpandedChanged(bool oldValue, bool newValue);
    public bool get_IsExpandable();
    public void set_IsExpandable(bool value);
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    private static void OnIsSelectedChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsSelectedChanged(bool oldValue, bool newValue);
    public FrameworkElement get_ParentElement();
    internal IPropertyContainer get_ParentNode();
    internal void set_ParentNode(IPropertyContainer value);
    internal ContentControl get_ValueContainer();
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
internal void set_Level(int value);
    public IList get_Properties();
    public Style get_PropertyContainerStyle();
    internal ContainerHelperBase get_ContainerHelper();
    internal void set_ContainerHelper(ContainerHelperBase value);
    public bool get_WillRefreshPropertyGrid();
    public void set_WillRefreshPropertyGrid(bool value);
    private void RaiseItemSelectionChangedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    internal void RaisePropertyChanged(Expression`1<Func`1<TMember>> propertyExpression);
    internal void RaisePropertyChanged(string name);
    private void OnPreparePropertyItemInternal(object sender, PropertyItemEventArgs args);
    private void OnClearPropertyItemInternal(object sender, PropertyItemEventArgs args);
    private void PropertyItemBase_RequestBringIntoView(object sender, RequestBringIntoViewEventArgs e);
    protected virtual Type GetPropertyItemType();
    protected virtual string GetPropertyItemName();
    public virtual void OnApplyTemplate();
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    private void PropertyItemBase_GotFocus(object sender, RoutedEventArgs e);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private PropertyDefinitionCollection GetPropertItemPropertyDefinitions();
    private sealed virtual override Style Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_PropertyContainerStyle();
    private sealed virtual override EditorDefinitionCollection Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_EditorDefinitions();
    private sealed virtual override PropertyDefinitionCollection Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_PropertyDefinitions();
    private sealed virtual override ContainerHelperBase Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_ContainerHelper();
    private sealed virtual override bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_IsCategorized();
    private sealed virtual override bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_IsSortedAlphabetically();
    private sealed virtual override bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_AutoGenerateProperties();
    private sealed virtual override bool Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_HideInheritedProperties();
    private sealed virtual override FilterInfo Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.get_FilterInfo();
    private sealed virtual override Nullable`1<bool> Xceed.Wpf.Toolkit.PropertyGrid.IPropertyContainer.IsPropertyVisible(PropertyDescriptor pd);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyItemCollection : ReadOnlyObservableCollection`1<PropertyItem> {
    internal static string CategoryPropertyName;
    internal static string CategoryOrderPropertyName;
    internal static string PropertyOrderPropertyName;
    internal static string DisplayNamePropertyName;
    private bool _preventNotification;
    [CompilerGeneratedAttribute]
private ObservableCollection`1<PropertyItem> <EditableCollection>k__BackingField;
    internal Predicate`1<object> FilterPredicate { get; internal set; }
    public ObservableCollection`1<PropertyItem> EditableCollection { get; private set; }
    private static PropertyItemCollection();
    public PropertyItemCollection(ObservableCollection`1<PropertyItem> editableCollection);
    internal Predicate`1<object> get_FilterPredicate();
    internal void set_FilterPredicate(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public ObservableCollection`1<PropertyItem> get_EditableCollection();
    [CompilerGeneratedAttribute]
private void set_EditableCollection(ObservableCollection`1<PropertyItem> value);
    private ICollectionView GetDefaultView();
    public void GroupBy(string name);
    public void SortBy(string name, ListSortDirection sortDirection);
    public void Filter(string text);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs args);
    internal void UpdateItems(IEnumerable`1<PropertyItem> newItems);
    internal void UpdateCategorization(GroupDescription groupDescription, bool isPropertyGridCategorized, bool sortAlphabetically);
    internal void RefreshView();
    internal static Predicate`1<object> CreateFilter(string text, IList`1<PropertyItem> PropertyItems, IPropertyContainer propertyContainer);
    private static void ClearFilterSubItems(IList items);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyItemEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private PropertyItemBase <PropertyItem>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Item>k__BackingField;
    public PropertyItemBase PropertyItem { get; private set; }
    public object Item { get; private set; }
    public PropertyItemEventArgs(RoutedEvent routedEvent, object source, PropertyItemBase propertyItem, object item);
    [CompilerGeneratedAttribute]
public PropertyItemBase get_PropertyItem();
    [CompilerGeneratedAttribute]
private void set_PropertyItem(PropertyItemBase value);
    [CompilerGeneratedAttribute]
public object get_Item();
    [CompilerGeneratedAttribute]
private void set_Item(object value);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyItemEventHandler : MulticastDelegate {
    public PropertyItemEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyItemEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyItemEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyItemsControl : ItemsControl {
    internal static RoutedEvent PreparePropertyItemEvent;
    internal static RoutedEvent ClearPropertyItemEvent;
    private static PropertyItemsControl();
    internal void add_PreparePropertyItem(PropertyItemEventHandler value);
    internal void remove_PreparePropertyItem(PropertyItemEventHandler value);
    private void RaisePreparePropertyItemEvent(PropertyItemBase propertyItem, object item);
    internal void add_ClearPropertyItem(PropertyItemEventHandler value);
    internal void remove_ClearPropertyItem(PropertyItemEventHandler value);
    private void RaiseClearPropertyItemEvent(PropertyItemBase propertyItem, object item);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    private void PropertyItemsControl_Initialized(object sender, EventArgs e);
    private void SetVirtualizingWhenGrouping();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyValueChangedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private object <NewValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OldValue>k__BackingField;
    public object NewValue { get; public set; }
    public object OldValue { get; public set; }
    public PropertyValueChangedEventArgs(RoutedEvent routedEvent, object source, object oldValue, object newValue);
    [CompilerGeneratedAttribute]
public object get_NewValue();
    [CompilerGeneratedAttribute]
public void set_NewValue(object value);
    [CompilerGeneratedAttribute]
public object get_OldValue();
    [CompilerGeneratedAttribute]
public void set_OldValue(object value);
}
public class Xceed.Wpf.Toolkit.PropertyGrid.PropertyValueChangedEventHandler : MulticastDelegate {
    public PropertyValueChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyValueChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyValueChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class Xceed.Wpf.Toolkit.PropertyGrid.StringConstants : object {
    public static string Local { get; }
    public static string Resource { get; }
    public static string Databinding { get; }
    public static string Inheritance { get; }
    public static string StyleSetter { get; }
    public static string Default { get; }
    public static string get_Local();
    public static string get_Resource();
    public static string get_Databinding();
    public static string get_Inheritance();
    public static string get_StyleSetter();
    public static string get_Default();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.TargetPropertyType : object {
    private Type _type;
    private bool _sealed;
    public Type Type { get; public set; }
    public Type get_Type();
    public void set_Type(Type value);
    internal void Seal();
}
public class Xceed.Wpf.Toolkit.PropertyGrid.TrimmedTextBlock : TextBlock {
    public static DependencyProperty IsTextTrimmedProperty;
    public static DependencyProperty HighlightedBrushProperty;
    public static DependencyProperty HighlightedTextProperty;
    public bool IsTextTrimmed { get; private set; }
    public Brush HighlightedBrush { get; public set; }
    public string HighlightedText { get; public set; }
    private static TrimmedTextBlock();
    public bool get_IsTextTrimmed();
    private void set_IsTextTrimmed(bool value);
    private static void OnIsTextTrimmedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnIsTextTrimmedChanged(bool oldValue, bool newValue);
    public Brush get_HighlightedBrush();
    public void set_HighlightedBrush(Brush value);
    public string get_HighlightedText();
    public void set_HighlightedText(string value);
    private static void HighlightedTextChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    protected virtual void HighlightedTextChanged(string oldValue, string newValue);
    private void TrimmedTextBlock_SizeChanged(object sender, SizeChangedEventArgs e);
    private bool GetIsTextTrimmed(TextBlock textBlock);
}
public class Xceed.Wpf.Toolkit.QueryMoveFocusEventArgs : RoutedEventArgs {
    private FocusNavigationDirection m_navigationDirection;
    private bool m_reachedMaxLength;
    private bool m_canMove;
    public FocusNavigationDirection FocusNavigationDirection { get; }
    public bool ReachedMaxLength { get; }
    public bool CanMoveFocus { get; public set; }
    internal QueryMoveFocusEventArgs(FocusNavigationDirection direction, bool reachedMaxLength);
    public FocusNavigationDirection get_FocusNavigationDirection();
    public bool get_ReachedMaxLength();
    public bool get_CanMoveFocus();
    public void set_CanMoveFocus(bool value);
}
public class Xceed.Wpf.Toolkit.QueryMoveFocusEventHandler : MulticastDelegate {
    public QueryMoveFocusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryMoveFocusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryMoveFocusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.RangeSlider : Control {
    private static string PART_LowerRange;
    private static string PART_Range;
    private static string PART_HigherRange;
    private static string PART_HigherSlider;
    private static string PART_LowerSlider;
    private static string PART_Track;
    private RepeatButton _lowerRange;
    private RepeatButton _higherRange;
    private Slider _lowerSlider;
    private Slider _higherSlider;
    private Track _lowerTrack;
    private Track _higherTrack;
    private Nullable`1<double> _deferredUpdateValue;
    public static DependencyProperty AutoToolTipPlacementProperty;
    public static DependencyProperty AutoToolTipPrecisionProperty;
    public static DependencyProperty HigherRangeBackgroundProperty;
    public static DependencyProperty HigherRangeStyleProperty;
    private static DependencyPropertyKey HigherRangeWidthPropertyKey;
    public static DependencyProperty HigherRangeWidthProperty;
    public static DependencyProperty HigherThumbBackgroundProperty;
    public static DependencyProperty HigherValueProperty;
    public static DependencyProperty IsDeferredUpdateValuesProperty;
    public static DependencyProperty IsSnapToTickEnabledProperty;
    public static DependencyProperty LowerRangeBackgroundProperty;
    public static DependencyProperty LowerRangeStyleProperty;
    private static DependencyPropertyKey LowerRangeWidthPropertyKey;
    public static DependencyProperty LowerRangeWidthProperty;
    public static DependencyProperty LowerThumbBackgroundProperty;
    public static DependencyProperty LowerValueProperty;
    public static DependencyProperty MaximumProperty;
    public static DependencyProperty MinimumProperty;
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty RangeBackgroundProperty;
    public static DependencyProperty RangeStyleProperty;
    private static DependencyPropertyKey RangeWidthPropertyKey;
    public static DependencyProperty RangeWidthProperty;
    private static DependencyProperty StepProperty;
    public static DependencyProperty TickFrequencyProperty;
    public static DependencyProperty TickPlacementProperty;
    public static RoutedEvent LowerValueChangedEvent;
    public static RoutedEvent HigherValueChangedEvent;
    public AutoToolTipPlacement AutoToolTipPlacement { get; public set; }
    public int AutoToolTipPrecision { get; public set; }
    public Brush HigherRangeBackground { get; public set; }
    public Style HigherRangeStyle { get; public set; }
    public double HigherRangeWidth { get; private set; }
    public Brush HigherThumbBackground { get; public set; }
    public double HigherValue { get; public set; }
    public bool IsDeferredUpdateValues { get; public set; }
    public bool IsSnapToTickEnabled { get; public set; }
    public Brush LowerRangeBackground { get; public set; }
    public Style LowerRangeStyle { get; public set; }
    public double LowerRangeWidth { get; private set; }
    public Brush LowerThumbBackground { get; public set; }
    public double LowerValue { get; public set; }
    public double Maximum { get; public set; }
    public double Minimum { get; public set; }
    public Orientation Orientation { get; public set; }
    public Brush RangeBackground { get; public set; }
    public Style RangeStyle { get; public set; }
    public double RangeWidth { get; private set; }
    public double Step { get; public set; }
    public double TickFrequency { get; public set; }
    public TickPlacement TickPlacement { get; public set; }
    private static RangeSlider();
    public AutoToolTipPlacement get_AutoToolTipPlacement();
    public void set_AutoToolTipPlacement(AutoToolTipPlacement value);
    private static void OnAutoToolTipPlacementChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAutoToolTipPlacementChanged(AutoToolTipPlacement oldValue, AutoToolTipPlacement newValue);
    public int get_AutoToolTipPrecision();
    public void set_AutoToolTipPrecision(int value);
    public Brush get_HigherRangeBackground();
    public void set_HigherRangeBackground(Brush value);
    public Style get_HigherRangeStyle();
    public void set_HigherRangeStyle(Style value);
    public double get_HigherRangeWidth();
    private void set_HigherRangeWidth(double value);
    public Brush get_HigherThumbBackground();
    public void set_HigherThumbBackground(Brush value);
    public double get_HigherValue();
    public void set_HigherValue(double value);
    private static object OnCoerceHigherValueChanged(DependencyObject d, object basevalue);
    private static void OnHigherValueChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnHigherValueChanged(double oldValue, double newValue);
    public bool get_IsDeferredUpdateValues();
    public void set_IsDeferredUpdateValues(bool value);
    public bool get_IsSnapToTickEnabled();
    public void set_IsSnapToTickEnabled(bool value);
    public Brush get_LowerRangeBackground();
    public void set_LowerRangeBackground(Brush value);
    public Style get_LowerRangeStyle();
    public void set_LowerRangeStyle(Style value);
    public double get_LowerRangeWidth();
    private void set_LowerRangeWidth(double value);
    public Brush get_LowerThumbBackground();
    public void set_LowerThumbBackground(Brush value);
    public double get_LowerValue();
    public void set_LowerValue(double value);
    private static object OnCoerceLowerValueChanged(DependencyObject d, object basevalue);
    private static void OnLowerValueChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnLowerValueChanged(double oldValue, double newValue);
    public double get_Maximum();
    public void set_Maximum(double value);
    private static void OnMaximumChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnMaximumChanged(double oldValue, double newValue);
    public double get_Minimum();
    public void set_Minimum(double value);
    private static void OnMinimumChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnMinimumChanged(double oldValue, double newValue);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    private static void OnOrientationChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    protected virtual void OnOrientationChanged(Orientation oldValue, Orientation newValue);
    public Brush get_RangeBackground();
    public void set_RangeBackground(Brush value);
    public Style get_RangeStyle();
    public void set_RangeStyle(Style value);
    public double get_RangeWidth();
    private void set_RangeWidth(double value);
    public double get_Step();
    public void set_Step(double value);
    private static object CoerceStep(DependencyObject sender, object value);
    public double get_TickFrequency();
    public void set_TickFrequency(double value);
    private static void OnTickFrequencyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnTickFrequencyChanged(double oldValue, double newValue);
    public TickPlacement get_TickPlacement();
    public void set_TickPlacement(TickPlacement value);
    private static void OnTickPlacementChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTickPlacementChanged(TickPlacement oldValue, TickPlacement newValue);
    public virtual void OnApplyTemplate();
    public virtual string ToString();
    internal static double GetThumbWidth(Slider slider);
    internal static double GetThumbHeight(Slider slider);
    private void AdjustView(bool isHigherValueChanged);
    private void SetSlidersMargins();
    private CoercedValues GetCoercedValues();
    private void SetLowerSliderValues(double value, Nullable`1<double> minimum, Nullable`1<double> maximum);
    private void SetHigherSliderValues(double value, Nullable`1<double> minimum, Nullable`1<double> maximum);
    private void SetSliderValues(Slider slider, RoutedPropertyChangedEventHandler`1<double> handler, double value, Nullable`1<double> minimum, Nullable`1<double> maximum);
    private void UpdateHigherValue(Nullable`1<double> value);
    private void UpdateLowerValue(Nullable`1<double> value);
    public void add_LowerValueChanged(RoutedEventHandler value);
    public void remove_LowerValueChanged(RoutedEventHandler value);
    public void add_HigherValueChanged(RoutedEventHandler value);
    public void remove_HigherValueChanged(RoutedEventHandler value);
    private void LowerRange_Click(object sender, RoutedEventArgs e);
    private void HigherRange_Click(object sender, RoutedEventArgs e);
    private void RangeSlider_SizeChanged(object sender, SizeChangedEventArgs e);
    private void Slider_Loaded(object sender, RoutedEventArgs e);
    private void LowerSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs`1<double> e);
    private void HigherSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs`1<double> e);
    private void HigherSlider_DragCompleted(object sender, DragCompletedEventArgs e);
    private void LowerSlider_DragCompleted(object sender, DragCompletedEventArgs e);
}
public class Xceed.Wpf.Toolkit.RichTextBox : RichTextBox {
    private bool _preventDocumentUpdate;
    private bool _preventTextUpdate;
    public static DependencyProperty TextProperty;
    public static DependencyProperty TextFormatterProperty;
    public string Text { get; public set; }
    public ITextFormatter TextFormatter { get; public set; }
    public RichTextBox(FlowDocument document);
    private static RichTextBox();
    public string get_Text();
    public void set_Text(string value);
    private static void OnTextPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceTextProperty(DependencyObject d, object value);
    public ITextFormatter get_TextFormatter();
    public void set_TextFormatter(ITextFormatter value);
    private static void OnTextFormatterPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTextFormatterPropertyChanged(ITextFormatter oldValue, ITextFormatter newValue);
    protected virtual void OnTextChanged(TextChangedEventArgs e);
    private void UpdateTextFromDocument();
    private void UpdateDocumentFromText();
    public void Clear();
    public virtual void BeginInit();
    public virtual void EndInit();
}
public class Xceed.Wpf.Toolkit.RichTextBoxFormatBar : Control {
    private ComboBox _cmbFontFamilies;
    private ComboBox _cmbFontSizes;
    private ColorPicker _cmbFontBackgroundColor;
    private ColorPicker _cmbFontColor;
    private ToggleButton _btnNumbers;
    private ToggleButton _btnBullets;
    private ToggleButton _btnBold;
    private ToggleButton _btnItalic;
    private ToggleButton _btnUnderline;
    private ToggleButton _btnAlignLeft;
    private ToggleButton _btnAlignCenter;
    private ToggleButton _btnAlignRight;
    private Thumb _dragWidget;
    private bool _waitingForMouseOver;
    public static DependencyProperty TargetProperty;
    public static Double[] FontSizes { get; }
    public RichTextBox Target { get; public set; }
    public bool PreventDisplayFadeOut { get; }
    private static RichTextBoxFormatBar();
    public static Double[] get_FontSizes();
    private void FontFamily_SelectionChanged(object sender, SelectionChangedEventArgs e);
    private void FontSize_SelectionChanged(object sender, SelectionChangedEventArgs e);
    private void FontColor_SelectedColorChanged(object sender, RoutedPropertyChangedEventArgs`1<Nullable`1<Color>> e);
    private void FontBackgroundColor_SelectedColorChanged(object sender, RoutedPropertyChangedEventArgs`1<Nullable`1<Color>> e);
    private void Bullets_Clicked(object sender, RoutedEventArgs e);
    private void Numbers_Clicked(object sender, RoutedEventArgs e);
    private void DragWidget_DragDelta(object sender, DragDeltaEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    public virtual void OnApplyTemplate();
    private void GetTemplateComponent(T& partMember, string partName);
    private void UpdateToggleButtonState();
    private void UpdateItemCheckedState(ToggleButton button, DependencyProperty formattingProperty, object expectedValue);
    private void UpdateSelectedFontFamily();
    private void UpdateSelectedFontSize();
    private void UpdateFontColor();
    private void UpdateFontBackgroundColor();
    private void UpdateSelectionListType();
    private bool BothSelectionListsAreChecked();
    private void ApplyPropertyValueToSelectedText(DependencyProperty formattingProperty, object value);
    private void ProcessMove(DragDeltaEventArgs e);
    public sealed virtual RichTextBox get_Target();
    public sealed virtual void set_Target(RichTextBox value);
    private static void OnRichTextBoxPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public sealed virtual bool get_PreventDisplayFadeOut();
    public sealed virtual void Update();
}
public class Xceed.Wpf.Toolkit.RichTextBoxFormatBarManager : DependencyObject {
    private RichTextBox _richTextBox;
    private UIElementAdorner`1<Control> _adorner;
    private IRichTextBoxFormatBar _toolbar;
    private Window _parentWindow;
    private static double _hideAdornerDistance;
    public static DependencyProperty FormatBarProperty;
    public bool IsAdornerVisible { get; }
    private static RichTextBoxFormatBarManager();
    public static void SetFormatBar(UIElement element, IRichTextBoxFormatBar value);
    public static IRichTextBoxFormatBar GetFormatBar(UIElement element);
    private static void OnFormatBarPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsAdornerVisible();
    private void RichTextBox_MouseButtonUp(object sender, MouseButtonEventArgs e);
    private void OnPreviewMouseMoveParentWindow(object sender, MouseEventArgs e);
    private void RichTextBox_TextChanged(object sender, TextChangedEventArgs e);
    private void AttachFormatBarToRichtextBox(RichTextBox richTextBox, IRichTextBoxFormatBar formatBar);
    private void ShowAdorner();
    private void PositionFormatBar(Control adorningEditor);
    private bool VerifyAdornerLayer();
    private void HideAdorner();
}
public class Xceed.Wpf.Toolkit.RtfFormatter : object {
    public sealed virtual string GetText(FlowDocument document);
    public sealed virtual void SetText(FlowDocument document, string text);
}
[CLSCompliantAttribute("False")]
public class Xceed.Wpf.Toolkit.SByteUpDown : CommonNumericUpDown`1<sbyte> {
    private static SByteUpDown();
    protected virtual sbyte IncrementValue(sbyte value, sbyte increment);
    protected virtual sbyte DecrementValue(sbyte value, sbyte increment);
}
public class Xceed.Wpf.Toolkit.ShortUpDown : CommonNumericUpDown`1<short> {
    private static ShortUpDown();
    protected virtual short IncrementValue(short value, short increment);
    protected virtual short DecrementValue(short value, short increment);
}
public class Xceed.Wpf.Toolkit.SingleUpDown : CommonNumericUpDown`1<float> {
    public static DependencyProperty AllowInputSpecialValuesProperty;
    public AllowedSpecialValues AllowInputSpecialValues { get; public set; }
    private static SingleUpDown();
    public AllowedSpecialValues get_AllowInputSpecialValues();
    public void set_AllowInputSpecialValues(AllowedSpecialValues value);
    protected virtual Nullable`1<float> OnCoerceIncrement(Nullable`1<float> baseValue);
    protected virtual Nullable`1<float> OnCoerceMaximum(Nullable`1<float> baseValue);
    protected virtual Nullable`1<float> OnCoerceMinimum(Nullable`1<float> baseValue);
    protected virtual float IncrementValue(float value, float increment);
    protected virtual float DecrementValue(float value, float increment);
    protected virtual void SetValidSpinDirection();
    protected virtual Nullable`1<float> ConvertTextToValue(string text);
}
public enum Xceed.Wpf.Toolkit.SpinDirection : Enum {
    public int value__;
    public static SpinDirection Increase;
    public static SpinDirection Decrease;
}
public class Xceed.Wpf.Toolkit.SpinEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private SpinDirection <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsingMouseWheel>k__BackingField;
    public SpinDirection Direction { get; private set; }
    public bool UsingMouseWheel { get; private set; }
    public SpinEventArgs(SpinDirection direction);
    public SpinEventArgs(RoutedEvent routedEvent, SpinDirection direction);
    public SpinEventArgs(SpinDirection direction, bool usingMouseWheel);
    public SpinEventArgs(RoutedEvent routedEvent, SpinDirection direction, bool usingMouseWheel);
    [CompilerGeneratedAttribute]
public SpinDirection get_Direction();
    [CompilerGeneratedAttribute]
private void set_Direction(SpinDirection value);
    [CompilerGeneratedAttribute]
public bool get_UsingMouseWheel();
    [CompilerGeneratedAttribute]
private void set_UsingMouseWheel(bool value);
}
public abstract class Xceed.Wpf.Toolkit.Spinner : Control {
    public static DependencyProperty ValidSpinDirectionProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<SpinEventArgs> Spin;
    public static RoutedEvent SpinnerSpinEvent;
    public ValidSpinDirections ValidSpinDirection { get; public set; }
    private static Spinner();
    public ValidSpinDirections get_ValidSpinDirection();
    public void set_ValidSpinDirection(ValidSpinDirections value);
    private static void OnValidSpinDirectionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_Spin(EventHandler`1<SpinEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Spin(EventHandler`1<SpinEventArgs> value);
    public void add_SpinnerSpin(RoutedEventHandler value);
    public void remove_SpinnerSpin(RoutedEventHandler value);
    protected virtual void OnSpin(SpinEventArgs e);
    protected virtual void OnValidSpinDirectionChanged(ValidSpinDirections oldValue, ValidSpinDirections newValue);
}
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.SplitButton : DropDownButton {
    private static string PART_ActionButton;
    public static DependencyProperty DropDownTooltipProperty;
    public object DropDownTooltip { get; public set; }
    private static SplitButton();
    public object get_DropDownTooltip();
    public void set_DropDownTooltip(object value);
    private static void OnDropDownTooltipChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDropDownTooltipChanged(object oldValue, object newValue);
    public virtual void OnApplyTemplate();
}
public static class Xceed.Wpf.Toolkit.Themes.ResourceKeys : object {
    public static ComponentResourceKey ControlNormalBackgroundKey;
    public static ComponentResourceKey ControlDisabledBackgroundKey;
    public static ComponentResourceKey ControlNormalBorderKey;
    public static ComponentResourceKey ControlMouseOverBorderKey;
    public static ComponentResourceKey ControlSelectedBorderKey;
    public static ComponentResourceKey ControlFocusedBorderKey;
    public static ComponentResourceKey ButtonNormalOuterBorderKey;
    public static ComponentResourceKey ButtonNormalInnerBorderKey;
    public static ComponentResourceKey ButtonNormalBackgroundKey;
    public static ComponentResourceKey ButtonMouseOverBackgroundKey;
    public static ComponentResourceKey ButtonMouseOverOuterBorderKey;
    public static ComponentResourceKey ButtonMouseOverInnerBorderKey;
    public static ComponentResourceKey ButtonPressedOuterBorderKey;
    public static ComponentResourceKey ButtonPressedInnerBorderKey;
    public static ComponentResourceKey ButtonPressedBackgroundKey;
    public static ComponentResourceKey ButtonFocusedOuterBorderKey;
    public static ComponentResourceKey ButtonFocusedInnerBorderKey;
    public static ComponentResourceKey ButtonFocusedBackgroundKey;
    public static ComponentResourceKey ButtonDisabledOuterBorderKey;
    public static ComponentResourceKey ButtonInnerBorderDisabledKey;
    public static ComponentResourceKey GlyphNormalForegroundKey;
    public static ComponentResourceKey GlyphDisabledForegroundKey;
    public static ComponentResourceKey SpinButtonCornerRadiusKey;
    public static ComponentResourceKey SpinnerButtonStyleKey;
    private static ResourceKeys();
}
public class Xceed.Wpf.Toolkit.TimeItem : object {
    [CompilerGeneratedAttribute]
private string <Display>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Time>k__BackingField;
    public string Display { get; public set; }
    public TimeSpan Time { get; public set; }
    public TimeItem(string display, TimeSpan time);
    [CompilerGeneratedAttribute]
public string get_Display();
    [CompilerGeneratedAttribute]
public void set_Display(string value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(TimeSpan value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Xceed.Wpf.Toolkit.TimelinePanel : Panel {
    private List`1<DateElement> _visibleElements;
    public static DependencyProperty BeginDateProperty;
    public static DependencyProperty EndDateProperty;
    public static DependencyProperty OverlapBehaviorProperty;
    public static DependencyProperty KeepOriginalOrderForOverlapProperty;
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty UnitTimeSpanProperty;
    public static DependencyProperty UnitSizeProperty;
    public static DependencyProperty DateProperty;
    public static DependencyProperty DateEndProperty;
    private bool _allowHorizontal;
    private bool _allowVertical;
    private Vector _computedOffset;
    private Size _extent;
    private Vector _offset;
    private ScrollViewer _scrollOwner;
    private Size _viewport;
    private Size _physicalViewport;
    public DateTime BeginDate { get; public set; }
    public DateTime EndDate { get; public set; }
    public OverlapBehavior OverlapBehavior { get; public set; }
    public bool KeepOriginalOrderForOverlap { get; public set; }
    public Orientation Orientation { get; public set; }
    public TimeSpan UnitTimeSpan { get; public set; }
    public double UnitSize { get; public set; }
    public List`1<DateElement> VisibleElements { get; }
    public bool CanHorizontallyScroll { get; public set; }
    public bool CanVerticallyScroll { get; public set; }
    public double ExtentHeight { get; }
    public double ExtentWidth { get; }
    public double HorizontalOffset { get; }
    public ScrollViewer ScrollOwner { get; public set; }
    public double VerticalOffset { get; }
    public double ViewportHeight { get; }
    public double ViewportWidth { get; }
    private bool IsScrolling { get; }
    private static TimelinePanel();
    public DateTime get_BeginDate();
    public void set_BeginDate(DateTime value);
    public DateTime get_EndDate();
    public void set_EndDate(DateTime value);
    public OverlapBehavior get_OverlapBehavior();
    public void set_OverlapBehavior(OverlapBehavior value);
    public bool get_KeepOriginalOrderForOverlap();
    public void set_KeepOriginalOrderForOverlap(bool value);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    public TimeSpan get_UnitTimeSpan();
    public void set_UnitTimeSpan(TimeSpan value);
    public double get_UnitSize();
    public void set_UnitSize(double value);
    public static DateTime GetDate(DependencyObject obj);
    public static void SetDate(DependencyObject obj, DateTime value);
    public static DateTime GetDateEnd(DependencyObject obj);
    public static void SetDateEnd(DependencyObject obj, DateTime value);
    public List`1<DateElement> get_VisibleElements();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    private void ResetScrollInfo();
    private void SetScrollingData(Size viewport, Size extent, Vector offset);
    private double ValidateInputOffset(double offset, string parameterName);
    private void OnScrollChange();
    private double CalculateTimelineOffset(DateTime d, double finalWidth);
    private static int CompareElementsByLeft(DateElement a, DateElement b);
    private static int CompareElementsByTop(DateElement a, DateElement b);
    private void LayoutItems(UIElementCollection children, Size availableSize);
    private static bool AreVirtuallyEqual(double d1, double d2);
    private static bool AreVirtuallyEqual(Size s1, Size s2);
    private static bool AreVirtuallyEqual(Vector v1, Vector v2);
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual void LineDown();
    public sealed virtual void LineLeft();
    public sealed virtual void LineRight();
    public sealed virtual void LineUp();
    public sealed virtual Rect MakeVisible(Visual visual, Rect rectangle);
    public sealed virtual void MouseWheelDown();
    public sealed virtual void MouseWheelLeft();
    public sealed virtual void MouseWheelRight();
    public sealed virtual void MouseWheelUp();
    public sealed virtual void PageDown();
    public sealed virtual void PageLeft();
    public sealed virtual void PageRight();
    public sealed virtual void PageUp();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    public sealed virtual void SetHorizontalOffset(double offset);
    public sealed virtual void SetVerticalOffset(double offset);
    public sealed virtual double get_VerticalOffset();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_ViewportWidth();
    private bool get_IsScrolling();
}
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.TimePicker : DateTimePickerBase {
    private static string PART_TimeListItems;
    private ListBox _timeListBox;
    private bool _isListBoxInvalid;
    internal static TimeSpan EndTimeDefaultValue;
    internal static TimeSpan StartTimeDefaultValue;
    internal static TimeSpan TimeIntervalDefaultValue;
    public static DependencyProperty EndTimeProperty;
    public static DependencyProperty TimeListItemsStyleProperty;
    public static DependencyProperty MaxDropDownHeightProperty;
    public static DependencyProperty StartTimeProperty;
    public static DependencyProperty TimeIntervalProperty;
    public TimeSpan EndTime { get; public set; }
    public Style TimeListItemsStyle { get; public set; }
    public double MaxDropDownHeight { get; public set; }
    public TimeSpan StartTime { get; public set; }
    public TimeSpan TimeInterval { get; public set; }
    private static TimePicker();
    private static object OnCoerceEndTime(DependencyObject o, object value);
    private static void OnEndTimeChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual TimeSpan OnCoerceEndTime(TimeSpan value);
    protected virtual void OnEndTimeChanged(TimeSpan oldValue, TimeSpan newValue);
    public TimeSpan get_EndTime();
    public void set_EndTime(TimeSpan value);
    protected virtual void OnFormatChanged(DateTimeFormat oldValue, DateTimeFormat newValue);
    public Style get_TimeListItemsStyle();
    public void set_TimeListItemsStyle(Style value);
    private static void OnTimeListItemsStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTimeListItemsStyleChanged(DependencyPropertyChangedEventArgs e);
    public double get_MaxDropDownHeight();
    public void set_MaxDropDownHeight(double value);
    private static void OnMaxDropDownHeightChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMaxDropDownHeightChanged(double oldValue, double newValue);
    private static object OnCoerceStartTime(DependencyObject o, object value);
    private static void OnStartTimeChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual TimeSpan OnCoerceStartTime(TimeSpan value);
    protected virtual void OnStartTimeChanged(TimeSpan oldValue, TimeSpan newValue);
    public TimeSpan get_StartTime();
    public void set_StartTime(TimeSpan value);
    public TimeSpan get_TimeInterval();
    public void set_TimeInterval(TimeSpan value);
    private static object OnCoerceTimeInterval(DependencyObject o, object value);
    private static void OnTimeIntervalChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual TimeSpan OnCoerceTimeInterval(TimeSpan value);
    protected virtual void OnTimeIntervalChanged(TimeSpan oldValue, TimeSpan newValue);
    protected virtual void OnFormatStringChanged(string oldValue, string newValue);
    protected virtual void OnMaximumChanged(Nullable`1<DateTime> oldValue, Nullable`1<DateTime> newValue);
    protected virtual void OnMinimumChanged(Nullable`1<DateTime> oldValue, Nullable`1<DateTime> newValue);
    protected virtual void OnValueChanged(Nullable`1<DateTime> oldValue, Nullable`1<DateTime> newValue);
    protected virtual void Popup_Opened(object sender, EventArgs e);
    public virtual void OnApplyTemplate();
    internal void UpdateTempValue(Nullable`1<DateTime> newDate);
    private void TimeListBox_SelectionChanged(object sender, SelectionChangedEventArgs e);
    private void TextBoxSpinner_GotKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    private void TimeListBox_MouseUp(object sender, MouseButtonEventArgs e);
    private void ValidateTime(TimeSpan time);
    public IEnumerable GenerateTimeListItemsSource();
    protected virtual TimeItem CreateTimeItem(TimeSpan time);
    private void UpdateListBoxSelectedItem();
    private void InvalidateListBoxItems();
    private void UpdateListBoxItems();
    private TimeItem GetNearestTimeItem(TimeSpan time);
}
public class Xceed.Wpf.Toolkit.TimeSpanUpDown : DateTimeUpDownBase`1<Nullable`1<TimeSpan>> {
    private static int HoursInDay;
    private static int MinutesInDay;
    private static int MinutesInHour;
    private static int SecondsInDay;
    private static int SecondsInHour;
    private static int SecondsInMinute;
    private static int MilliSecondsInDay;
    private static int MilliSecondsInHour;
    private static int MilliSecondsInMinute;
    private static int MilliSecondsInSecond;
    private int _defaultFractionalSecondsDigitsCount;
    public static DependencyProperty FractionalSecondsDigitsCountProperty;
    public static DependencyProperty ShowDaysProperty;
    public static DependencyProperty ShowHoursProperty;
    public static DependencyProperty ShowSecondsProperty;
    public int FractionalSecondsDigitsCount { get; public set; }
    public bool ShowDays { get; public set; }
    public bool ShowHours { get; public set; }
    public bool ShowSeconds { get; public set; }
    private static TimeSpanUpDown();
    public int get_FractionalSecondsDigitsCount();
    public void set_FractionalSecondsDigitsCount(int value);
    private static object OnCoerceFractionalSecondsDigitsCount(DependencyObject o, object value);
    private static void OnFractionalSecondsDigitsCountChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnFractionalSecondsDigitsCountChanged(int oldValue, int newValue);
    public bool get_ShowDays();
    public void set_ShowDays(bool value);
    private static void OnShowDaysChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnShowDaysChanged(bool oldValue, bool newValue);
    public bool get_ShowHours();
    public void set_ShowHours(bool value);
    private static void OnShowHoursChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnShowHoursChanged(bool oldValue, bool newValue);
    public bool get_ShowSeconds();
    public void set_ShowSeconds(bool value);
    private static void OnShowSecondsChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnShowSecondsChanged(bool oldValue, bool newValue);
    public virtual bool CommitInput();
    protected virtual void OnCultureInfoChanged(CultureInfo oldValue, CultureInfo newValue);
    protected virtual void OnCurrentDateTimePartChanged(DateTimePart oldValue, DateTimePart newValue);
    protected virtual void SetValidSpinDirection();
    protected virtual void OnIncrement();
    protected virtual void OnDecrement();
    protected virtual string ConvertValueToText();
    protected virtual Nullable`1<TimeSpan> ConvertTextToValue(string text);
    protected virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnTextChanged(string previousValue, string currentValue);
    protected virtual void OnValueChanged(Nullable`1<TimeSpan> oldValue, Nullable`1<TimeSpan> newValue);
    protected virtual void PerformMouseSelection();
    protected virtual void InitializeDateTimeInfoList(Nullable`1<TimeSpan> value);
    protected virtual bool IsLowerThan(Nullable`1<TimeSpan> value1, Nullable`1<TimeSpan> value2);
    protected virtual bool IsGreaterThan(Nullable`1<TimeSpan> value1, Nullable`1<TimeSpan> value2);
    protected virtual object OnCurrentDateTimePartCoerce(object baseValue);
    internal virtual void Select(DateTimeInfo info);
    private string ParseValueIntoTimeSpanInfo(Nullable`1<TimeSpan> value, bool modifyInfo);
    private Nullable`1<TimeSpan> UpdateTimeSpan(Nullable`1<TimeSpan> currentValue, int value);
    private void Increment(int step);
    private bool IsNumber(string str);
    private void UpdateValue();
    private Nullable`1<TimeSpan> ResetToLastValidValue();
    private void OnPasting(object sender, DataObjectPastingEventArgs e);
    [CompilerGeneratedAttribute]
private bool <CommitInput>b__38_0(DateTimeInfo x);
}
[CLSCompliantAttribute("False")]
public class Xceed.Wpf.Toolkit.UIntegerUpDown : CommonNumericUpDown`1<UInt32> {
    private static UIntegerUpDown();
    protected virtual UInt32 IncrementValue(UInt32 value, UInt32 increment);
    protected virtual UInt32 DecrementValue(UInt32 value, UInt32 increment);
}
[CLSCompliantAttribute("False")]
public class Xceed.Wpf.Toolkit.ULongUpDown : CommonNumericUpDown`1<ulong> {
    private static ULongUpDown();
    protected virtual ulong IncrementValue(ulong value, ulong increment);
    protected virtual ulong DecrementValue(ulong value, ulong increment);
}
[CLSCompliantAttribute("False")]
public class Xceed.Wpf.Toolkit.UShortUpDown : CommonNumericUpDown`1<ushort> {
    private static UShortUpDown();
    protected virtual ushort IncrementValue(ushort value, ushort increment);
    protected virtual ushort DecrementValue(ushort value, ushort increment);
}
[FlagsAttribute]
public enum Xceed.Wpf.Toolkit.ValidSpinDirections : Enum {
    public int value__;
    public static ValidSpinDirections None;
    public static ValidSpinDirections Increase;
    public static ValidSpinDirections Decrease;
}
internal static class Xceed.Wpf.Toolkit.VisualStates : object {
    public static string GroupBusyStatus;
    public static string StateBusy;
    public static string StateIdle;
    public static string GroupVisibility;
    public static string StateVisible;
    public static string StateHidden;
    public static string MessageBoxButtonsGroup;
    public static string OK;
    public static string OKCancel;
    public static string YesNo;
    public static string YesNoCancel;
}
public class Xceed.Wpf.Toolkit.WatermarkComboBox : ComboBox {
    public static DependencyProperty WatermarkProperty;
    public static DependencyProperty WatermarkTemplateProperty;
    public static DependencyProperty WatermarkBackgroundProperty;
    public object Watermark { get; public set; }
    public DataTemplate WatermarkTemplate { get; public set; }
    public Brush WatermarkBackground { get; public set; }
    private static WatermarkComboBox();
    public object get_Watermark();
    public void set_Watermark(object value);
    public DataTemplate get_WatermarkTemplate();
    public void set_WatermarkTemplate(DataTemplate value);
    public Brush get_WatermarkBackground();
    public void set_WatermarkBackground(Brush value);
}
public class Xceed.Wpf.Toolkit.WatermarkPasswordBox : WatermarkTextBox {
    private int _newCaretIndex;
    public static DependencyProperty PasswordCharProperty;
    [CompilerGeneratedAttribute]
private SecureString <SecurePassword>k__BackingField;
    public static RoutedEvent PasswordChangedEvent;
    public string Password { get; public set; }
    public char PasswordChar { get; public set; }
    public SecureString SecurePassword { get; private set; }
    private static WatermarkPasswordBox();
    [SecuritySafeCriticalAttribute]
public string get_Password();
    public void set_Password(string value);
    public char get_PasswordChar();
    public void set_PasswordChar(char value);
    private static void OnPasswordCharChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnPasswordCharChanged(char oldValue, char newValue);
    [CompilerGeneratedAttribute]
public SecureString get_SecurePassword();
    [CompilerGeneratedAttribute]
private void set_SecurePassword(SecureString value);
    [SecuritySafeCriticalAttribute]
protected virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    [SecuritySafeCriticalAttribute]
protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnTextChanged(TextChangedEventArgs e);
    public void add_PasswordChanged(RoutedEventHandler value);
    public void remove_PasswordChanged(RoutedEventHandler value);
    [SecuritySafeCriticalAttribute]
private void OnPaste(object sender, DataObjectPastingEventArgs e);
    private void OnPreviewCanExecuteCommand(object sender, CanExecuteRoutedEventArgs e);
    [SecurityCriticalAttribute]
private void PasswordInsert(string text, int index);
    [SecurityCriticalAttribute]
private void PasswordRemove(int index);
    private void SetPassword(string password, int caretIndex);
    private void SyncTextPassword(int nextCarretIndex);
}
public class Xceed.Wpf.Toolkit.WatermarkTextBox : AutoSelectTextBox {
    public static DependencyProperty KeepWatermarkOnGotFocusProperty;
    public static DependencyProperty WatermarkProperty;
    public static DependencyProperty WatermarkTemplateProperty;
    public bool KeepWatermarkOnGotFocus { get; public set; }
    public object Watermark { get; public set; }
    public DataTemplate WatermarkTemplate { get; public set; }
    private static WatermarkTextBox();
    public bool get_KeepWatermarkOnGotFocus();
    public void set_KeepWatermarkOnGotFocus(bool value);
    public object get_Watermark();
    public void set_Watermark(object value);
    public DataTemplate get_WatermarkTemplate();
    public void set_WatermarkTemplate(DataTemplate value);
}
public enum Xceed.Wpf.Toolkit.WindowStartupLocation : Enum {
    public int value__;
    public static WindowStartupLocation Center;
    public static WindowStartupLocation Manual;
}
public enum Xceed.Wpf.Toolkit.WindowState : Enum {
    public int value__;
    public static WindowState Closed;
    public static WindowState Open;
}
public class Xceed.Wpf.Toolkit.Wizard : ItemsControl {
    private Nullable`1<bool> _dialogResult;
    public static DependencyProperty BackButtonContentProperty;
    public static DependencyProperty BackButtonVisibilityProperty;
    public static DependencyProperty CanCancelProperty;
    public static DependencyProperty CancelButtonClosesWindowProperty;
    public static DependencyProperty CancelButtonContentProperty;
    public static DependencyProperty CancelButtonVisibilityProperty;
    public static DependencyProperty CanFinishProperty;
    public static DependencyProperty CanHelpProperty;
    public static DependencyProperty CanSelectNextPageProperty;
    public static DependencyProperty CanSelectPreviousPageProperty;
    public static DependencyProperty CurrentPageProperty;
    public static DependencyProperty ExteriorPanelMinWidthProperty;
    public static DependencyProperty FinishButtonClosesWindowProperty;
    public static DependencyProperty FinishButtonContentProperty;
    public static DependencyProperty FinishButtonVisibilityProperty;
    public static DependencyProperty HelpButtonContentProperty;
    public static DependencyProperty HelpButtonVisibilityProperty;
    public static DependencyProperty NextButtonContentProperty;
    public static DependencyProperty NextButtonVisibilityProperty;
    public static RoutedEvent CancelEvent;
    public static RoutedEvent PageChangedEvent;
    public static RoutedEvent FinishEvent;
    public static RoutedEvent HelpEvent;
    public static RoutedEvent NextEvent;
    public static RoutedEvent PreviousEvent;
    public object BackButtonContent { get; public set; }
    public Visibility BackButtonVisibility { get; public set; }
    public bool CanCancel { get; public set; }
    public bool CancelButtonClosesWindow { get; public set; }
    public object CancelButtonContent { get; public set; }
    public Visibility CancelButtonVisibility { get; public set; }
    public bool CanFinish { get; public set; }
    public bool CanHelp { get; public set; }
    public bool CanSelectNextPage { get; public set; }
    public bool CanSelectPreviousPage { get; public set; }
    public WizardPage CurrentPage { get; public set; }
    public double ExteriorPanelMinWidth { get; public set; }
    public bool FinishButtonClosesWindow { get; public set; }
    public object FinishButtonContent { get; public set; }
    public Visibility FinishButtonVisibility { get; public set; }
    public object HelpButtonContent { get; public set; }
    public Visibility HelpButtonVisibility { get; public set; }
    public object NextButtonContent { get; public set; }
    public Visibility NextButtonVisibility { get; public set; }
    private static Wizard();
    public object get_BackButtonContent();
    public void set_BackButtonContent(object value);
    public Visibility get_BackButtonVisibility();
    public void set_BackButtonVisibility(Visibility value);
    public bool get_CanCancel();
    public void set_CanCancel(bool value);
    public bool get_CancelButtonClosesWindow();
    public void set_CancelButtonClosesWindow(bool value);
    public object get_CancelButtonContent();
    public void set_CancelButtonContent(object value);
    public Visibility get_CancelButtonVisibility();
    public void set_CancelButtonVisibility(Visibility value);
    public bool get_CanFinish();
    public void set_CanFinish(bool value);
    public bool get_CanHelp();
    public void set_CanHelp(bool value);
    public bool get_CanSelectNextPage();
    public void set_CanSelectNextPage(bool value);
    public bool get_CanSelectPreviousPage();
    public void set_CanSelectPreviousPage(bool value);
    public WizardPage get_CurrentPage();
    public void set_CurrentPage(WizardPage value);
    private static void OnCurrentPageChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCurrentPageChanged(WizardPage oldValue, WizardPage newValue);
    public double get_ExteriorPanelMinWidth();
    public void set_ExteriorPanelMinWidth(double value);
    public bool get_FinishButtonClosesWindow();
    public void set_FinishButtonClosesWindow(bool value);
    public object get_FinishButtonContent();
    public void set_FinishButtonContent(object value);
    public Visibility get_FinishButtonVisibility();
    public void set_FinishButtonVisibility(Visibility value);
    public object get_HelpButtonContent();
    public void set_HelpButtonContent(object value);
    public Visibility get_HelpButtonVisibility();
    public void set_HelpButtonVisibility(Visibility value);
    public object get_NextButtonContent();
    public void set_NextButtonContent(object value);
    public Visibility get_NextButtonVisibility();
    public void set_NextButtonVisibility(Visibility value);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private void ExecuteCancelWizard(object sender, ExecutedRoutedEventArgs e);
    private void CanExecuteCancelWizard(object sender, CanExecuteRoutedEventArgs e);
    private void ExecuteFinishWizard(object sender, ExecutedRoutedEventArgs e);
    private void CanExecuteFinishWizard(object sender, CanExecuteRoutedEventArgs e);
    private void ExecuteRequestHelp(object sender, ExecutedRoutedEventArgs e);
    private void CanExecuteRequestHelp(object sender, CanExecuteRoutedEventArgs e);
    private void ExecuteSelectNextPage(object sender, ExecutedRoutedEventArgs e);
    private void CanExecuteSelectNextPage(object sender, CanExecuteRoutedEventArgs e);
    private void ExecuteSelectPreviousPage(object sender, ExecutedRoutedEventArgs e);
    private void CanExecuteSelectPreviousPage(object sender, CanExecuteRoutedEventArgs e);
    public void add_Cancel(RoutedEventHandler value);
    public void remove_Cancel(RoutedEventHandler value);
    public void add_PageChanged(RoutedEventHandler value);
    public void remove_PageChanged(RoutedEventHandler value);
    public void add_Finish(CancelRoutedEventHandler value);
    public void remove_Finish(CancelRoutedEventHandler value);
    public void add_Help(RoutedEventHandler value);
    public void remove_Help(RoutedEventHandler value);
    public void add_Next(NextRoutedEventHandler value);
    public void remove_Next(NextRoutedEventHandler value);
    public void add_Previous(PreviousRoutedEventHandler value);
    public void remove_Previous(PreviousRoutedEventHandler value);
    private void CloseParentWindow(bool dialogResult);
    private void Window_Closing(object sender, CancelEventArgs e);
    private bool NextPageExists();
    private bool PreviousPageExists();
    private void RaiseRoutedEvent(RoutedEvent routedEvent);
}
public static class Xceed.Wpf.Toolkit.WizardCommands : object {
    private static RoutedCommand _cancelCommand;
    private static RoutedCommand _finishCommand;
    private static RoutedCommand _helpCommand;
    private static RoutedCommand _nextPageCommand;
    private static RoutedCommand _previousPageCommand;
    private static RoutedCommand _selectPageCommand;
    public static RoutedCommand Cancel { get; }
    public static RoutedCommand Finish { get; }
    public static RoutedCommand Help { get; }
    public static RoutedCommand NextPage { get; }
    public static RoutedCommand PreviousPage { get; }
    public static RoutedCommand SelectPage { get; }
    private static WizardCommands();
    public static RoutedCommand get_Cancel();
    public static RoutedCommand get_Finish();
    public static RoutedCommand get_Help();
    public static RoutedCommand get_NextPage();
    public static RoutedCommand get_PreviousPage();
    public static RoutedCommand get_SelectPage();
}
public class Xceed.Wpf.Toolkit.WizardPage : ContentControl {
    public static DependencyProperty BackButtonVisibilityProperty;
    public static DependencyProperty CanCancelProperty;
    public static DependencyProperty CancelButtonVisibilityProperty;
    public static DependencyProperty CanFinishProperty;
    public static DependencyProperty CanHelpProperty;
    public static DependencyProperty CanSelectNextPageProperty;
    public static DependencyProperty CanSelectPreviousPageProperty;
    public static DependencyProperty DescriptionProperty;
    public static DependencyProperty ExteriorPanelBackgroundProperty;
    public static DependencyProperty ExteriorPanelContentProperty;
    public static DependencyProperty FinishButtonVisibilityProperty;
    public static DependencyProperty HeaderBackgroundProperty;
    public static DependencyProperty HeaderImageProperty;
    public static DependencyProperty HelpButtonVisibilityProperty;
    public static DependencyProperty NextButtonVisibilityProperty;
    public static DependencyProperty NextPageProperty;
    public static DependencyProperty PageTypeProperty;
    public static DependencyProperty PreviousPageProperty;
    public static DependencyProperty TitleProperty;
    public static RoutedEvent EnterEvent;
    public static RoutedEvent LeaveEvent;
    public WizardPageButtonVisibility BackButtonVisibility { get; public set; }
    public Nullable`1<bool> CanCancel { get; public set; }
    public WizardPageButtonVisibility CancelButtonVisibility { get; public set; }
    public Nullable`1<bool> CanFinish { get; public set; }
    public Nullable`1<bool> CanHelp { get; public set; }
    public Nullable`1<bool> CanSelectNextPage { get; public set; }
    public Nullable`1<bool> CanSelectPreviousPage { get; public set; }
    public string Description { get; public set; }
    public Brush ExteriorPanelBackground { get; public set; }
    public object ExteriorPanelContent { get; public set; }
    public WizardPageButtonVisibility FinishButtonVisibility { get; public set; }
    public Brush HeaderBackground { get; public set; }
    public ImageSource HeaderImage { get; public set; }
    public WizardPageButtonVisibility HelpButtonVisibility { get; public set; }
    public WizardPageButtonVisibility NextButtonVisibility { get; public set; }
    public WizardPage NextPage { get; public set; }
    public WizardPageType PageType { get; public set; }
    public WizardPage PreviousPage { get; public set; }
    public string Title { get; public set; }
    private static WizardPage();
    public WizardPageButtonVisibility get_BackButtonVisibility();
    public void set_BackButtonVisibility(WizardPageButtonVisibility value);
    public Nullable`1<bool> get_CanCancel();
    public void set_CanCancel(Nullable`1<bool> value);
    public WizardPageButtonVisibility get_CancelButtonVisibility();
    public void set_CancelButtonVisibility(WizardPageButtonVisibility value);
    public Nullable`1<bool> get_CanFinish();
    public void set_CanFinish(Nullable`1<bool> value);
    public Nullable`1<bool> get_CanHelp();
    public void set_CanHelp(Nullable`1<bool> value);
    public Nullable`1<bool> get_CanSelectNextPage();
    public void set_CanSelectNextPage(Nullable`1<bool> value);
    public Nullable`1<bool> get_CanSelectPreviousPage();
    public void set_CanSelectPreviousPage(Nullable`1<bool> value);
    public string get_Description();
    public void set_Description(string value);
    public Brush get_ExteriorPanelBackground();
    public void set_ExteriorPanelBackground(Brush value);
    public object get_ExteriorPanelContent();
    public void set_ExteriorPanelContent(object value);
    public WizardPageButtonVisibility get_FinishButtonVisibility();
    public void set_FinishButtonVisibility(WizardPageButtonVisibility value);
    public Brush get_HeaderBackground();
    public void set_HeaderBackground(Brush value);
    public ImageSource get_HeaderImage();
    public void set_HeaderImage(ImageSource value);
    public WizardPageButtonVisibility get_HelpButtonVisibility();
    public void set_HelpButtonVisibility(WizardPageButtonVisibility value);
    public WizardPageButtonVisibility get_NextButtonVisibility();
    public void set_NextButtonVisibility(WizardPageButtonVisibility value);
    public WizardPage get_NextPage();
    public void set_NextPage(WizardPage value);
    public WizardPageType get_PageType();
    public void set_PageType(WizardPageType value);
    public WizardPage get_PreviousPage();
    public void set_PreviousPage(WizardPage value);
    public string get_Title();
    public void set_Title(string value);
    private void WizardPage_Unloaded(object sender, RoutedEventArgs e);
    private void WizardPage_Loaded(object sender, RoutedEventArgs e);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    public void add_Enter(RoutedEventHandler value);
    public void remove_Enter(RoutedEventHandler value);
    public void add_Leave(RoutedEventHandler value);
    public void remove_Leave(RoutedEventHandler value);
}
public enum Xceed.Wpf.Toolkit.WizardPageButtonVisibility : Enum {
    public int value__;
    public static WizardPageButtonVisibility Inherit;
    public static WizardPageButtonVisibility Collapsed;
    public static WizardPageButtonVisibility Hidden;
    public static WizardPageButtonVisibility Visible;
}
public enum Xceed.Wpf.Toolkit.WizardPageType : Enum {
    public int value__;
    public static WizardPageType Blank;
    public static WizardPageType Exterior;
    public static WizardPageType Interior;
}
public class Xceed.Wpf.Toolkit.XamlFormatter : object {
    public sealed virtual string GetText(FlowDocument document);
    public sealed virtual void SetText(FlowDocument document, string text);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.Toolkit.Zoombox.Zoombox : ContentControl {
    private static string PART_VerticalScrollBar;
    private static string PART_HorizontalScrollBar;
    private bool _isUpdatingVisualTree;
    private bool _isUsingDefaultViewFinder;
    public static DependencyProperty AnimationAccelerationRatioProperty;
    public static DependencyProperty AnimationDecelerationRatioProperty;
    public static DependencyProperty AnimationDurationProperty;
    private static DependencyPropertyKey AreDragModifiersActivePropertyKey;
    public static DependencyProperty AreDragModifiersActiveProperty;
    private static DependencyPropertyKey AreRelativeZoomModifiersActivePropertyKey;
    public static DependencyProperty AreRelativeZoomModifiersActiveProperty;
    private static DependencyPropertyKey AreZoomModifiersActivePropertyKey;
    public static DependencyProperty AreZoomModifiersActiveProperty;
    private static DependencyPropertyKey AreZoomToSelectionModifiersActivePropertyKey;
    public static DependencyProperty AreZoomToSelectionModifiersActiveProperty;
    public static DependencyProperty AutoWrapContentWithViewboxProperty;
    private UIElement _trueContent;
    private static DependencyPropertyKey CurrentViewPropertyKey;
    public static DependencyProperty CurrentViewProperty;
    private static DependencyPropertyKey CurrentViewIndexPropertyKey;
    public static DependencyProperty CurrentViewIndexProperty;
    public static DependencyProperty DragModifiersProperty;
    public static DependencyProperty DragOnPreviewProperty;
    private static DependencyPropertyKey EffectiveViewStackModePropertyKey;
    public static DependencyProperty EffectiveViewStackModeProperty;
    private static DependencyPropertyKey HasBackStackPropertyKey;
    public static DependencyProperty HasBackStackProperty;
    private static DependencyPropertyKey HasForwardStackPropertyKey;
    public static DependencyProperty HasForwardStackProperty;
    public static DependencyProperty IsAnimatedProperty;
    private static DependencyPropertyKey IsDraggingContentPropertyKey;
    public static DependencyProperty IsDraggingContentProperty;
    private static DependencyPropertyKey IsSelectingRegionPropertyKey;
    public static DependencyProperty IsSelectingRegionProperty;
    public static DependencyProperty IsUsingScrollBarsProperty;
    public static DependencyProperty MaxScaleProperty;
    public static DependencyProperty MinScaleProperty;
    public static DependencyProperty NavigateOnPreviewProperty;
    public static DependencyProperty PanDistanceProperty;
    public static DependencyProperty PositionProperty;
    public static DependencyProperty RelativeZoomModifiersProperty;
    public static DependencyProperty ScaleProperty;
    private static DependencyPropertyKey ViewFinderPropertyKey;
    public static DependencyProperty ViewFinderProperty;
    public static DependencyProperty ViewFinderVisibilityProperty;
    private static DependencyPropertyKey ViewportPropertyKey;
    public static DependencyProperty ViewportProperty;
    private static DependencyPropertyKey ViewStackCountPropertyKey;
    public static DependencyProperty ViewStackCountProperty;
    public static DependencyProperty ViewStackIndexProperty;
    public static DependencyProperty ViewStackModeProperty;
    public static DependencyProperty ViewStackSourceProperty;
    public static DependencyProperty ZoomModifiersProperty;
    public static DependencyProperty ZoomOnPreviewProperty;
    public static DependencyProperty ZoomOriginProperty;
    public static DependencyProperty ZoomPercentageProperty;
    public static DependencyProperty ZoomOnProperty;
    public static DependencyProperty ZoomToSelectionModifiersProperty;
    public static DependencyProperty KeepContentInBoundsProperty;
    public static RoutedEvent AnimationBeginningEvent;
    public static RoutedEvent AnimationCompletedEvent;
    public static RoutedEvent CurrentViewChangedEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<ScrollEventArgs> Scroll;
    public static RoutedEvent ViewStackIndexChangedEvent;
    public static RoutedUICommand Back;
    public static RoutedUICommand Center;
    public static RoutedUICommand Fill;
    public static RoutedUICommand Fit;
    public static RoutedUICommand Forward;
    public static RoutedUICommand Home;
    public static RoutedUICommand PanDown;
    public static RoutedUICommand PanLeft;
    public static RoutedUICommand PanRight;
    public static RoutedUICommand PanUp;
    public static RoutedUICommand Refocus;
    public static RoutedUICommand ZoomIn;
    public static RoutedUICommand ZoomOut;
    private static int MOUSE_WHEEL_DELTA;
    private ContentPresenter _contentPresenter;
    private ScrollBar _verticalScrollBar;
    private ScrollBar _horizontalScrollBar;
    private UIElement _content;
    private DragAdorner _dragAdorner;
    private ZoomboxViewStack _viewStack;
    private ZoomboxViewFinderDisplay _viewFinderDisplay;
    private Rect _resizeViewportBounds;
    private Point _resizeAnchorPoint;
    private Point _resizeDraggingPoint;
    private Point _originPoint;
    private double _viewboxFactor;
    private double _relativeScale;
    private Point _relativePosition;
    private Point _basePosition;
    private DateTime _lastStackAddition;
    private int _lastViewIndex;
    private BitVector32 _cacheBits;
    public double AnimationAccelerationRatio { get; public set; }
    public double AnimationDecelerationRatio { get; public set; }
    public Duration AnimationDuration { get; public set; }
    public bool AreDragModifiersActive { get; }
    public bool AreRelativeZoomModifiersActive { get; }
    public bool AreZoomModifiersActive { get; }
    public bool AreZoomToSelectionModifiersActive { get; }
    public bool AutoWrapContentWithViewbox { get; public set; }
    public ZoomboxView CurrentView { get; }
    public int CurrentViewIndex { get; }
    [TypeConverterAttribute("Xceed.Wpf.Toolkit.Core.Input.KeyModifierCollectionConverter")]
public KeyModifierCollection DragModifiers { get; public set; }
    public bool DragOnPreview { get; public set; }
    public ZoomboxViewStackMode EffectiveViewStackMode { get; }
    public bool HasBackStack { get; }
    public bool HasForwardStack { get; }
    public bool IsAnimated { get; public set; }
    public bool IsDraggingContent { get; }
    public bool IsSelectingRegion { get; }
    public bool IsUsingScrollBars { get; public set; }
    public double MaxScale { get; public set; }
    public double MinScale { get; public set; }
    public bool NavigateOnPreview { get; public set; }
    public double PanDistance { get; public set; }
    public Point Position { get; public set; }
    [TypeConverterAttribute("Xceed.Wpf.Toolkit.Core.Input.KeyModifierCollectionConverter")]
public KeyModifierCollection RelativeZoomModifiers { get; public set; }
    public double Scale { get; public set; }
    public FrameworkElement ViewFinder { get; public set; }
    public Rect Viewport { get; }
    public int ViewStackCount { get; }
    public int ViewStackIndex { get; public set; }
    public ZoomboxViewStackMode ViewStackMode { get; public set; }
    [BindableAttribute("True")]
public IEnumerable ViewStackSource { get; public set; }
    [TypeConverterAttribute("Xceed.Wpf.Toolkit.Core.Input.KeyModifierCollectionConverter")]
public KeyModifierCollection ZoomModifiers { get; public set; }
    public bool ZoomOnPreview { get; public set; }
    public Point ZoomOrigin { get; public set; }
    public double ZoomPercentage { get; public set; }
    public ZoomboxZoomOn ZoomOn { get; public set; }
    [TypeConverterAttribute("Xceed.Wpf.Toolkit.Core.Input.KeyModifierCollectionConverter")]
public KeyModifierCollection ZoomToSelectionModifiers { get; public set; }
    public bool KeepContentInBounds { get; public set; }
    public ZoomboxViewStack ViewStack { get; }
    internal bool HasArrangedContentPresenter { get; internal set; }
    internal bool IsUpdatingView { get; internal set; }
    private Vector ContentOffset { get; }
    private Rect ContentRect { get; }
    private bool HasRenderedFirstView { get; private set; }
    private bool HasUIPermission { get; }
    private bool IsContentWrapped { get; private set; }
    private bool IsDraggingViewport { get; private set; }
    private bool IsMonitoringInput { get; private set; }
    private bool IsResizingViewport { get; private set; }
    private bool IsUpdatingViewport { get; private set; }
    private bool RefocusViewOnFirstRender { get; private set; }
    private Rect ViewFinderDisplayRect { get; }
    private static Zoombox();
    public double get_AnimationAccelerationRatio();
    public void set_AnimationAccelerationRatio(double value);
    private static bool ValidateAccelerationRatio(object value);
    public double get_AnimationDecelerationRatio();
    public void set_AnimationDecelerationRatio(double value);
    private static bool ValidateDecelerationRatio(object value);
    public Duration get_AnimationDuration();
    public void set_AnimationDuration(Duration value);
    public bool get_AreDragModifiersActive();
    private void SetAreDragModifiersActive(bool value);
    public bool get_AreRelativeZoomModifiersActive();
    private void SetAreRelativeZoomModifiersActive(bool value);
    public bool get_AreZoomModifiersActive();
    private void SetAreZoomModifiersActive(bool value);
    public bool get_AreZoomToSelectionModifiersActive();
    private void SetAreZoomToSelectionModifiersActive(bool value);
    public bool get_AutoWrapContentWithViewbox();
    public void set_AutoWrapContentWithViewbox(bool value);
    private static void OnAutoWrapContentWithViewboxChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    private static object CoerceContentValue(DependencyObject d, object value);
    private object CoerceContentValue(object value);
    public ZoomboxView get_CurrentView();
    private void SetCurrentView(ZoomboxView value);
    private static void OnCurrentViewChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    public int get_CurrentViewIndex();
    internal void SetCurrentViewIndex(int value);
    public KeyModifierCollection get_DragModifiers();
    public void set_DragModifiers(KeyModifierCollection value);
    private static KeyModifierCollection GetDefaultDragModifiers();
    public bool get_DragOnPreview();
    public void set_DragOnPreview(bool value);
    public ZoomboxViewStackMode get_EffectiveViewStackMode();
    private void SetEffectiveViewStackMode(ZoomboxViewStackMode value);
    public bool get_HasBackStack();
    public bool get_HasForwardStack();
    public bool get_IsAnimated();
    public void set_IsAnimated(bool value);
    private static object CoerceIsAnimatedValue(DependencyObject d, object value);
    public bool get_IsDraggingContent();
    private void SetIsDraggingContent(bool value);
    public bool get_IsSelectingRegion();
    private void SetIsSelectingRegion(bool value);
    public bool get_IsUsingScrollBars();
    public void set_IsUsingScrollBars(bool value);
    public double get_MaxScale();
    public void set_MaxScale(double value);
    private static void OnMaxScaleChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    private static object CoerceMaxScaleValue(DependencyObject d, object value);
    public double get_MinScale();
    public void set_MinScale(double value);
    private static void OnMinScaleChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    private static object CoerceMinScaleValue(DependencyObject d, object value);
    public bool get_NavigateOnPreview();
    public void set_NavigateOnPreview(bool value);
    public double get_PanDistance();
    public void set_PanDistance(double value);
    public Point get_Position();
    public void set_Position(Point value);
    private static void OnPositionChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    public KeyModifierCollection get_RelativeZoomModifiers();
    public void set_RelativeZoomModifiers(KeyModifierCollection value);
    private static KeyModifierCollection GetDefaultRelativeZoomModifiers();
    public double get_Scale();
    public void set_Scale(double value);
    private static void OnScaleChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    private static object CoerceScaleValue(DependencyObject d, object value);
    public FrameworkElement get_ViewFinder();
    public void set_ViewFinder(FrameworkElement value);
    private static void OnViewFinderChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnViewFinderChanged(DependencyPropertyChangedEventArgs e);
    public static Visibility GetViewFinderVisibility(DependencyObject d);
    public static void SetViewFinderVisibility(DependencyObject d, Visibility value);
    public Rect get_Viewport();
    private static void OnViewportChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    public int get_ViewStackCount();
    internal void SetViewStackCount(int value);
    private static void OnViewStackCountChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnViewStackCountChanged(DependencyPropertyChangedEventArgs e);
    public int get_ViewStackIndex();
    public void set_ViewStackIndex(int value);
    private static void OnViewStackIndexChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnViewStackIndexChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceViewStackIndexValue(DependencyObject d, object value);
    public ZoomboxViewStackMode get_ViewStackMode();
    public void set_ViewStackMode(ZoomboxViewStackMode value);
    private static void OnViewStackModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnViewStackModeChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceViewStackModeValue(DependencyObject d, object value);
    public IEnumerable get_ViewStackSource();
    public void set_ViewStackSource(IEnumerable value);
    private static void OnViewStackSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public KeyModifierCollection get_ZoomModifiers();
    public void set_ZoomModifiers(KeyModifierCollection value);
    private static KeyModifierCollection GetDefaultZoomModifiers();
    public bool get_ZoomOnPreview();
    public void set_ZoomOnPreview(bool value);
    public Point get_ZoomOrigin();
    public void set_ZoomOrigin(Point value);
    public double get_ZoomPercentage();
    public void set_ZoomPercentage(double value);
    public ZoomboxZoomOn get_ZoomOn();
    public void set_ZoomOn(ZoomboxZoomOn value);
    public KeyModifierCollection get_ZoomToSelectionModifiers();
    public void set_ZoomToSelectionModifiers(KeyModifierCollection value);
    private static KeyModifierCollection GetDefaultZoomToSelectionModifiers();
    public bool get_KeepContentInBounds();
    public void set_KeepContentInBounds(bool value);
    private static void OnKeepContentInBoundsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnKeepContentInBoundsChanged(DependencyPropertyChangedEventArgs e);
    public ZoomboxViewStack get_ViewStack();
    internal bool get_HasArrangedContentPresenter();
    internal void set_HasArrangedContentPresenter(bool value);
    internal bool get_IsUpdatingView();
    internal void set_IsUpdatingView(bool value);
    private Vector get_ContentOffset();
    private Rect get_ContentRect();
    private bool get_HasRenderedFirstView();
    private void set_HasRenderedFirstView(bool value);
    private bool get_HasUIPermission();
    private bool get_IsContentWrapped();
    private void set_IsContentWrapped(bool value);
    private bool get_IsDraggingViewport();
    private void set_IsDraggingViewport(bool value);
    private bool get_IsMonitoringInput();
    private void set_IsMonitoringInput(bool value);
    private bool get_IsResizingViewport();
    private void set_IsResizingViewport(bool value);
    private bool get_IsUpdatingViewport();
    private void set_IsUpdatingViewport(bool value);
    private bool get_RefocusViewOnFirstRender();
    private void set_RefocusViewOnFirstRender(bool value);
    private Rect get_ViewFinderDisplayRect();
    public void add_AnimationBeginning(RoutedEventHandler value);
    public void remove_AnimationBeginning(RoutedEventHandler value);
    public void add_AnimationCompleted(RoutedEventHandler value);
    public void remove_AnimationCompleted(RoutedEventHandler value);
    public void add_CurrentViewChanged(ZoomboxViewChangedEventHandler value);
    public void remove_CurrentViewChanged(ZoomboxViewChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Scroll(EventHandler`1<ScrollEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Scroll(EventHandler`1<ScrollEventArgs> value);
    public void add_ViewStackIndexChanged(IndexChangedEventHandler value);
    public void remove_ViewStackIndexChanged(IndexChangedEventHandler value);
    private void CanGoBack(object sender, CanExecuteRoutedEventArgs e);
    private void GoBack(object sender, ExecutedRoutedEventArgs e);
    private void CenterContent(object sender, ExecutedRoutedEventArgs e);
    private void FillToBounds(object sender, ExecutedRoutedEventArgs e);
    private void FitToBounds(object sender, ExecutedRoutedEventArgs e);
    private void CanGoForward(object sender, CanExecuteRoutedEventArgs e);
    private void GoForward(object sender, ExecutedRoutedEventArgs e);
    private void CanGoHome(object sender, CanExecuteRoutedEventArgs e);
    private void GoHome(object sender, ExecutedRoutedEventArgs e);
    private void PanDownExecuted(object sender, ExecutedRoutedEventArgs e);
    private void PanLeftExecuted(object sender, ExecutedRoutedEventArgs e);
    private void PanRightExecuted(object sender, ExecutedRoutedEventArgs e);
    private void PanUpExecuted(object sender, ExecutedRoutedEventArgs e);
    private void CanRefocusView(object sender, CanExecuteRoutedEventArgs e);
    private void RefocusView(object sender, ExecutedRoutedEventArgs e);
    private void ZoomInExecuted(object sender, ExecutedRoutedEventArgs e);
    private void ZoomOutExecuted(object sender, ExecutedRoutedEventArgs e);
    public void CenterContent();
    public void FillToBounds();
    public void FitToBounds();
    public void GoBack();
    public void GoForward();
    public void GoHome();
    public virtual void OnApplyTemplate();
    public void RefocusView();
    public void Zoom(double percentage);
    public void Zoom(double percentage, Point relativeTo);
    public void ZoomTo(Point position);
    public void ZoomTo(Rect region);
    public void ZoomTo(double scale);
    public void ZoomTo(double scale, Point relativeTo);
    public void ZoomTo(ZoomboxView view);
    internal void UpdateStackProperties();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual void OnContentChanged(object oldContent, object newContent);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void OnRender(DrawingContext drawingContext);
    private static void RefocusView(DependencyObject o, DependencyPropertyChangedEventArgs e);
    private void AttachToVisualTree();
    private void CreateVisualBrushForViewFinder(Visual visual);
    private void ContentPresenterFirstArranged(object sender, EventArgs e);
    private void DetachFromVisualTree();
    private void Zoombox_Loaded(object sender, RoutedEventArgs e);
    private void VerticalScrollBar_Scroll(object sender, ScrollEventArgs e);
    private void HorizontalScrollBar_Scroll(object sender, ScrollEventArgs e);
    private void DragDisplayViewport(DragDeltaEventArgs e, bool end);
    private void InitCommands();
    private void MonitorInput();
    private void OnContentSizeChanged(object sender, SizeChangedEventArgs e);
    private void OnDrag(DragDeltaEventArgs e, bool end);
    private void OnLayoutUpdated(object sender, EventArgs e);
    private void OnSelectRegion(DragDeltaEventArgs e, bool end);
    private void OnSizeChanged(object sender, SizeChangedEventArgs e);
    private void SetScrollBars();
    private void PreProcessInput();
    private void PreProcessInput(object sender, NotifyInputEventArgs e);
    private void ProcessMouseLeftButtonDown(MouseButtonEventArgs e);
    private void ProcessMouseLeftButtonUp(MouseButtonEventArgs e);
    private void ProcessMouseMove(MouseEventArgs e);
    private void ProcessMouseWheelZoom(MouseWheelEventArgs e);
    private void ProcessNavigationButton(RoutedEventArgs e);
    private void ResizeDisplayViewport(DragDeltaEventArgs e, ResizeEdge relativeTo);
    private void UpdateKeyModifierTriggerProperties();
    private void UpdateView(ZoomboxView view, bool allowAnimation, bool allowStackAddition);
    private void UpdateView(ZoomboxView view, bool allowAnimation, bool allowStackAddition, int stackIndex);
    private bool IsGreaterThanOrClose(double value1, double value2);
    private Rect CalculateFillRect();
    private void CalculatePositionAndScale(Rect region, Point& newRelativePosition, Double& newRelativeScale);
    private void UpdateViewFinderDisplayContentBounds();
    private void UpdateViewboxFactor();
    private void UpdateViewport();
    private void UpdateViewport(object sender, EventArgs e);
    private void ViewFinderDisplayBeginCapture(object sender, MouseButtonEventArgs e);
    private void ViewFinderDisplayEndCapture(object sender, MouseButtonEventArgs e);
    private void ViewFinderDisplayMouseMove(object sender, MouseEventArgs e);
    private void ZoomAnimationCompleted(object sender, EventArgs e);
    private void VerticalValueAnimation_Completed(object sender, EventArgs e);
    private void HorizontalValueAnimation_Completed(object sender, EventArgs e);
    private void ZoomTo(double scale, bool allowStackAddition);
    private void ZoomTo(double scale, Point relativeTo, bool restrictRelativePointToContent, bool allowStackAddition);
    private Point GetZoomRelativePoint();
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseMove(MouseEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
}
public class Xceed.Wpf.Toolkit.Zoombox.ZoomboxCursors : object {
    private static Cursor _zoom;
    private static Cursor _zoomRelative;
    public static Cursor Zoom { get; }
    public static Cursor ZoomRelative { get; }
    private static ZoomboxCursors();
    public static Cursor get_Zoom();
    public static Cursor get_ZoomRelative();
}
[TypeConverterAttribute("Xceed.Wpf.Toolkit.Zoombox.ZoomboxViewConverter")]
public class Xceed.Wpf.Toolkit.Zoombox.ZoomboxView : object {
    private static ZoomboxView _empty;
    private static ZoomboxView _fill;
    private static ZoomboxView _fit;
    private static ZoomboxView _center;
    private double _kindHeight;
    private double _x;
    private double _y;
    private double _scaleWidth;
    public static ZoomboxView Empty { get; }
    public static ZoomboxView Fill { get; }
    public static ZoomboxView Fit { get; }
    public static ZoomboxView Center { get; }
    public ZoomboxViewKind ViewKind { get; }
    public Point Position { get; public set; }
    public double Scale { get; public set; }
    public Rect Region { get; public set; }
    public ZoomboxView(double scale);
    public ZoomboxView(Point position);
    public ZoomboxView(double scale, Point position);
    public ZoomboxView(Rect region);
    public ZoomboxView(double x, double y);
    public ZoomboxView(double scale, double x, double y);
    public ZoomboxView(double x, double y, double width, double height);
    private ZoomboxView(ZoomboxViewKind viewType);
    private static ZoomboxView();
    public static ZoomboxView get_Empty();
    public static ZoomboxView get_Fill();
    public static ZoomboxView get_Fit();
    public static ZoomboxView get_Center();
    public ZoomboxViewKind get_ViewKind();
    public Point get_Position();
    public void set_Position(Point value);
    public double get_Scale();
    public void set_Scale(double value);
    public Rect get_Region();
    public void set_Region(Rect value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string ToString();
    public static bool op_Equality(ZoomboxView v1, ZoomboxView v2);
    public static bool op_Inequality(ZoomboxView v1, ZoomboxView v2);
}
public class Xceed.Wpf.Toolkit.Zoombox.ZoomboxViewChangedEventArgs : PropertyChangedEventArgs`1<ZoomboxView> {
    private int _newViewStackIndex;
    private int _oldViewStackIndex;
    public int NewViewStackIndex { get; }
    public int OldViewStackIndex { get; }
    public bool IsNewViewFromStack { get; }
    public bool IsOldViewFromStack { get; }
    public ZoomboxViewChangedEventArgs(ZoomboxView oldView, ZoomboxView newView, int oldViewStackIndex, int newViewStackIndex);
    public int get_NewViewStackIndex();
    public int get_OldViewStackIndex();
    public bool get_IsNewViewFromStack();
    public bool get_IsOldViewFromStack();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class Xceed.Wpf.Toolkit.Zoombox.ZoomboxViewChangedEventHandler : MulticastDelegate {
    public ZoomboxViewChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ZoomboxViewChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ZoomboxViewChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Xceed.Wpf.Toolkit.Zoombox.ZoomboxViewConverter : TypeConverter {
    private static ZoomboxViewConverter _converter;
    internal static ZoomboxViewConverter Converter { get; }
    internal static ZoomboxViewConverter get_Converter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public class Xceed.Wpf.Toolkit.Zoombox.ZoomboxViewException : Exception {
    public ZoomboxViewException(string message);
}
public class Xceed.Wpf.Toolkit.Zoombox.ZoomboxViewFinderDisplay : FrameworkElement {
    public static DependencyProperty BackgroundProperty;
    private static DependencyPropertyKey ContentBoundsPropertyKey;
    public static DependencyProperty ContentBoundsProperty;
    public static DependencyProperty ShadowBrushProperty;
    public static DependencyProperty ViewportBrushProperty;
    public static DependencyProperty ViewportPenProperty;
    public static DependencyProperty ViewportRectProperty;
    private static DependencyPropertyKey VisualBrushPropertyKey;
    public static DependencyProperty VisualBrushProperty;
    private Size _availableSize;
    private double _scale;
    public Brush Background { get; public set; }
    internal Rect ContentBounds { get; internal set; }
    public Brush ShadowBrush { get; public set; }
    public Brush ViewportBrush { get; public set; }
    public Pen ViewportPen { get; public set; }
    public Rect ViewportRect { get; public set; }
    internal VisualBrush VisualBrush { get; internal set; }
    internal Size AvailableSize { get; }
    internal double Scale { get; internal set; }
    private static ZoomboxViewFinderDisplay();
    public Brush get_Background();
    public void set_Background(Brush value);
    internal Rect get_ContentBounds();
    internal void set_ContentBounds(Rect value);
    public Brush get_ShadowBrush();
    public void set_ShadowBrush(Brush value);
    public Brush get_ViewportBrush();
    public void set_ViewportBrush(Brush value);
    public Pen get_ViewportPen();
    public void set_ViewportPen(Pen value);
    public Rect get_ViewportRect();
    public void set_ViewportRect(Rect value);
    internal VisualBrush get_VisualBrush();
    internal void set_VisualBrush(VisualBrush value);
    internal Size get_AvailableSize();
    internal double get_Scale();
    internal void set_Scale(double value);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual void OnRender(DrawingContext dc);
}
public enum Xceed.Wpf.Toolkit.Zoombox.ZoomboxViewKind : Enum {
    public int value__;
    public static ZoomboxViewKind Absolute;
    public static ZoomboxViewKind Fit;
    public static ZoomboxViewKind Fill;
    public static ZoomboxViewKind Center;
    public static ZoomboxViewKind Empty;
    public static ZoomboxViewKind Region;
}
public class Xceed.Wpf.Toolkit.Zoombox.ZoomboxViewStack : Collection`1<ZoomboxView> {
    private IEnumerable _source;
    private WeakReference _zoomboxRef;
    private BitVector32 _cacheBits;
    public ZoomboxView SelectedView { get; }
    internal bool AreViewsFromSource { get; internal set; }
    internal IEnumerable Source { get; }
    private bool IsChangeFromSource { get; private set; }
    private bool IsMovingViews { get; private set; }
    private bool IsResettingViews { get; private set; }
    private bool IsSettingInitialViewAfterClear { get; private set; }
    private Zoombox Zoombox { get; }
    public ZoomboxViewStack(Zoombox zoombox);
    public ZoomboxView get_SelectedView();
    internal bool get_AreViewsFromSource();
    internal void set_AreViewsFromSource(bool value);
    internal IEnumerable get_Source();
    private bool get_IsChangeFromSource();
    private void set_IsChangeFromSource(bool value);
    private bool get_IsMovingViews();
    private void set_IsMovingViews(bool value);
    private bool get_IsResettingViews();
    private void set_IsResettingViews(bool value);
    private bool get_IsSettingInitialViewAfterClear();
    private void set_IsSettingInitialViewAfterClear(bool value);
    private Zoombox get_Zoombox();
    internal void ClearViewStackSource();
    internal void PushView(ZoomboxView view);
    internal void SetViewStackSource(IEnumerable source);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, ZoomboxView view);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, ZoomboxView view);
    private static ZoomboxView GetViewFromSourceItem(object item);
    private void InsertViews(int index, IList newItems);
    private void MonitorSource(bool monitor);
    private void MoveViews(int oldIndex, int newIndex, IList movedItems);
    private void OnSourceCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void ResetViews();
    private void RemoveViews(int index, IList removedItems);
    private void VerifyStackModification();
    public sealed virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
}
public enum Xceed.Wpf.Toolkit.Zoombox.ZoomboxViewStackMode : Enum {
    public int value__;
    public static ZoomboxViewStackMode Auto;
    public static ZoomboxViewStackMode Default;
    public static ZoomboxViewStackMode Disabled;
    public static ZoomboxViewStackMode Manual;
}
public enum Xceed.Wpf.Toolkit.Zoombox.ZoomboxZoomOn : Enum {
    public int value__;
    public static ZoomboxZoomOn Content;
    public static ZoomboxZoomOn View;
}
