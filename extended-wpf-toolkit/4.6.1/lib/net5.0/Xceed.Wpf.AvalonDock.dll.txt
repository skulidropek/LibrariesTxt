internal static class _XceedVersionInfo : object {
    public static string BaseVersion;
    public static string Version;
    public static string PublicKeyToken;
}
internal static class _XceedVersionInfoCommon : object {
    public static string Build;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class Microsoft.Windows.Shell.SystemCommands : object {
    [CompilerGeneratedAttribute]
private static RoutedCommand <CloseWindowCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private static RoutedCommand <MaximizeWindowCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private static RoutedCommand <MinimizeWindowCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private static RoutedCommand <RestoreWindowCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private static RoutedCommand <ShowSystemMenuCommand>k__BackingField;
    public static RoutedCommand CloseWindowCommand { get; private set; }
    public static RoutedCommand MaximizeWindowCommand { get; private set; }
    public static RoutedCommand MinimizeWindowCommand { get; private set; }
    public static RoutedCommand RestoreWindowCommand { get; private set; }
    public static RoutedCommand ShowSystemMenuCommand { get; private set; }
    private static SystemCommands();
    [CompilerGeneratedAttribute]
public static RoutedCommand get_CloseWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_CloseWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_MaximizeWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_MaximizeWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_MinimizeWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_MinimizeWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_RestoreWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_RestoreWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_ShowSystemMenuCommand();
    [CompilerGeneratedAttribute]
private static void set_ShowSystemMenuCommand(RoutedCommand value);
    private static void _PostSystemCommand(Window window, SC command);
    public static void CloseWindow(Window window);
    public static void MaximizeWindow(Window window);
    public static void MinimizeWindow(Window window);
    public static void RestoreWindow(Window window);
    public static void ShowSystemMenu(Window window, Point screenLocation);
    internal static void ShowSystemMenuPhysicalCoordinates(Window window, Point physicalScreenLocation);
}
public class Microsoft.Windows.Shell.SystemParameters2 : object {
    [ThreadStaticAttribute]
private static SystemParameters2 _threadLocalSingleton;
    private MessageWindow _messageHwnd;
    private bool _isGlassEnabled;
    private Color _glassColor;
    private SolidColorBrush _glassColorBrush;
    private Thickness _windowResizeBorderThickness;
    private Thickness _windowNonClientFrameThickness;
    private double _captionHeight;
    private Size _smallIconSize;
    private string _uxThemeName;
    private string _uxThemeColor;
    private bool _isHighContrast;
    private CornerRadius _windowCornerRadius;
    private Rect _captionButtonLocation;
    private Dictionary`2<WM, List`1<_SystemMetricUpdate>> _UpdateTable;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public static SystemParameters2 Current { get; }
    public bool IsGlassEnabled { get; private set; }
    public Color WindowGlassColor { get; private set; }
    public SolidColorBrush WindowGlassBrush { get; private set; }
    public Thickness WindowResizeBorderThickness { get; private set; }
    public Thickness WindowNonClientFrameThickness { get; private set; }
    public double WindowCaptionHeight { get; private set; }
    public Size SmallIconSize { get; private set; }
    public string UxThemeName { get; private set; }
    public string UxThemeColor { get; private set; }
    public bool HighContrast { get; private set; }
    public CornerRadius WindowCornerRadius { get; private set; }
    public Rect WindowCaptionButtonsLocation { get; private set; }
    private void _InitializeIsGlassEnabled();
    private void _UpdateIsGlassEnabled(IntPtr wParam, IntPtr lParam);
    private void _InitializeGlassColor();
    private void _UpdateGlassColor(IntPtr wParam, IntPtr lParam);
    private void _InitializeCaptionHeight();
    private void _UpdateCaptionHeight(IntPtr wParam, IntPtr lParam);
    private void _InitializeWindowResizeBorderThickness();
    private void _UpdateWindowResizeBorderThickness(IntPtr wParam, IntPtr lParam);
    private void _InitializeWindowNonClientFrameThickness();
    private void _UpdateWindowNonClientFrameThickness(IntPtr wParam, IntPtr lParam);
    private void _InitializeSmallIconSize();
    private void _UpdateSmallIconSize(IntPtr wParam, IntPtr lParam);
    private void _LegacyInitializeCaptionButtonLocation();
    private void _InitializeCaptionButtonLocation();
    private void _UpdateCaptionButtonLocation(IntPtr wParam, IntPtr lParam);
    private void _InitializeHighContrast();
    private void _UpdateHighContrast(IntPtr wParam, IntPtr lParam);
    private void _InitializeThemeInfo();
    private void _UpdateThemeInfo(IntPtr wParam, IntPtr lParam);
    private void _InitializeWindowCornerRadius();
    private void _UpdateWindowCornerRadius(IntPtr wParam, IntPtr lParam);
    public static SystemParameters2 get_Current();
    private IntPtr _WndProc(IntPtr hwnd, WM msg, IntPtr wParam, IntPtr lParam);
    public bool get_IsGlassEnabled();
    private void set_IsGlassEnabled(bool value);
    public Color get_WindowGlassColor();
    private void set_WindowGlassColor(Color value);
    public SolidColorBrush get_WindowGlassBrush();
    private void set_WindowGlassBrush(SolidColorBrush value);
    public Thickness get_WindowResizeBorderThickness();
    private void set_WindowResizeBorderThickness(Thickness value);
    public Thickness get_WindowNonClientFrameThickness();
    private void set_WindowNonClientFrameThickness(Thickness value);
    public double get_WindowCaptionHeight();
    private void set_WindowCaptionHeight(double value);
    public Size get_SmallIconSize();
    private void set_SmallIconSize(Size value);
    public string get_UxThemeName();
    private void set_UxThemeName(string value);
    public string get_UxThemeColor();
    private void set_UxThemeColor(string value);
    public bool get_HighContrast();
    private void set_HighContrast(bool value);
    public CornerRadius get_WindowCornerRadius();
    private void set_WindowCornerRadius(CornerRadius value);
    public Rect get_WindowCaptionButtonsLocation();
    private void set_WindowCaptionButtonsLocation(Rect value);
    private void _NotifyPropertyChanged(string propertyName);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__37_0(object sender, EventArgs e);
}
public class Microsoft.Windows.Shell.WindowChrome : Freezable {
    public static DependencyProperty WindowChromeProperty;
    public static DependencyProperty IsHitTestVisibleInChromeProperty;
    public static DependencyProperty CaptionHeightProperty;
    public static DependencyProperty ResizeBorderThicknessProperty;
    public static DependencyProperty GlassFrameThicknessProperty;
    public static DependencyProperty CornerRadiusProperty;
    [CompilerGeneratedAttribute]
private bool <ShowSystemMenu>k__BackingField;
    private static List`1<_SystemParameterBoundProperty> _BoundProperties;
    [CompilerGeneratedAttribute]
private EventHandler PropertyChangedThatRequiresRepaint;
    public static Thickness GlassFrameCompleteThickness { get; }
    public double CaptionHeight { get; public set; }
    public Thickness ResizeBorderThickness { get; public set; }
    public Thickness GlassFrameThickness { get; public set; }
    public CornerRadius CornerRadius { get; public set; }
    public bool ShowSystemMenu { get; public set; }
    private static WindowChrome();
    public static Thickness get_GlassFrameCompleteThickness();
    private static void _OnChromeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public static WindowChrome GetWindowChrome(Window window);
    public static void SetWindowChrome(Window window, WindowChrome chrome);
    public static bool GetIsHitTestVisibleInChrome(IInputElement inputElement);
    public static void SetIsHitTestVisibleInChrome(IInputElement inputElement, bool hitTestVisible);
    public double get_CaptionHeight();
    public void set_CaptionHeight(double value);
    public Thickness get_ResizeBorderThickness();
    public void set_ResizeBorderThickness(Thickness value);
    private static object _CoerceGlassFrameThickness(Thickness thickness);
    public Thickness get_GlassFrameThickness();
    public void set_GlassFrameThickness(Thickness value);
    public CornerRadius get_CornerRadius();
    public void set_CornerRadius(CornerRadius value);
    [CompilerGeneratedAttribute]
public bool get_ShowSystemMenu();
    [CompilerGeneratedAttribute]
public void set_ShowSystemMenu(bool value);
    protected virtual Freezable CreateInstanceCore();
    private void _OnPropertyChangedThatRequiresRepaint();
    [CompilerGeneratedAttribute]
internal void add_PropertyChangedThatRequiresRepaint(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PropertyChangedThatRequiresRepaint(EventHandler value);
}
internal class Microsoft.Windows.Shell.WindowChromeWorker : DependencyObject {
    private static SWP _SwpFlags;
    private List`1<KeyValuePair`2<WM, MessageHandler>> _messageTable;
    private Window _window;
    private IntPtr _hwnd;
    private HwndSource _hwndSource;
    private bool _isHooked;
    private bool _isFixedUp;
    private bool _isUserResizing;
    private bool _hasUserMovedWindow;
    private Point _windowPosAtStartOfUserMove;
    private int _blackGlassFixupAttemptCount;
    private WindowChrome _chromeInfo;
    private WindowState _lastRoundingState;
    private WindowState _lastMenuState;
    private bool _isGlassEnabled;
    public static DependencyProperty WindowChromeWorkerProperty;
    private static HT[0...,0...] _HitTestBorders;
    private bool _IsWindowDocked { get; }
    private static WindowChromeWorker();
    public void SetWindowChrome(WindowChrome newChrome);
    private void _OnChromePropertyChangedThatRequiresRepaint(object sender, EventArgs e);
    private static void _OnChromeWorkerChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void _SetWindow(Window window);
    private void _UnsetWindow(object sender, EventArgs e);
    public static WindowChromeWorker GetWindowChromeWorker(Window window);
    public static void SetWindowChromeWorker(Window window, WindowChromeWorker chrome);
    private void _OnWindowPropertyChangedThatRequiresTemplateFixup(object sender, EventArgs e);
    private void _ApplyNewCustomChrome();
    private void _FixupFrameworkIssues();
    private void _FixupWindows7Issues();
    private void _FixupRestoreBounds(object sender, EventArgs e);
    private RECT _GetAdjustedWindowRect(RECT rcWindow);
    private bool get__IsWindowDocked();
    private IntPtr _WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleSetTextOrIcon(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleNCActivate(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleNCCalcSize(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleNCHitTest(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleNCRButtonUp(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleSize(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleWindowPosChanged(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleDwmCompositionChanged(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleSettingChange(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleEnterSizeMove(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleExitSizeMove(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleMove(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private bool _ModifyStyle(WS removeStyle, WS addStyle);
    private WindowState _GetHwndState();
    private Rect _GetWindowRect();
    private void _UpdateSystemMenu(Nullable`1<WindowState> assumeState);
    private void _UpdateFrameState(bool force);
    private void _ClearRoundingRegion();
    private void _SetRoundingRegion(Nullable`1<WINDOWPOS> wp);
    private static IntPtr _CreateRoundRectRgn(Rect region, double radius);
    private static void _CreateAndCombineRoundRectRgn(IntPtr hrgnSource, Rect region, double radius);
    private static bool _IsUniform(CornerRadius cornerRadius);
    private void _ExtendGlassFrame();
    private HT _HitTestNca(Rect windowPosition, Point mousePosition);
    private void _RestoreStandardChromeState(bool isClosing);
    private void _UnhookCustomChrome();
    private void _RestoreFrameworkIssueFixups();
    private void _RestoreGlassFrame();
    private void _RestoreHrgn();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <_SetWindow>b__21_0(object sender, EventArgs e);
}
internal enum Standard.AC : Enum {
    public byte value__;
    public static AC SRC_OVER;
    public static AC SRC_ALPHA;
}
internal enum Standard.APPDOCLISTTYPE : Enum {
    public int value__;
    public static APPDOCLISTTYPE ADLT_RECENT;
    public static APPDOCLISTTYPE ADLT_FREQUENT;
}
internal static class Standard.Assert : object {
    private static void _Break();
    [ConditionalAttribute("DEBUG")]
public static void Evaluate(EvaluateFunction argument);
    [ObsoleteAttribute("Use Assert.AreEqual instead of Assert.Equals", "False")]
[ConditionalAttribute("DEBUG")]
public static void Equals(T expected, T actual);
    [ConditionalAttribute("DEBUG")]
public static void AreEqual(T expected, T actual);
    [ConditionalAttribute("DEBUG")]
public static void AreNotEqual(T notExpected, T actual);
    [ConditionalAttribute("DEBUG")]
public static void Implies(bool condition, bool result);
    [ConditionalAttribute("DEBUG")]
public static void Implies(bool condition, ImplicationFunction result);
    [ConditionalAttribute("DEBUG")]
public static void IsNeitherNullNorEmpty(string value);
    [ConditionalAttribute("DEBUG")]
public static void IsNeitherNullNorWhitespace(string value);
    [ConditionalAttribute("DEBUG")]
public static void IsNotNull(T value);
    [ConditionalAttribute("DEBUG")]
public static void IsDefault(T value);
    [ConditionalAttribute("DEBUG")]
public static void IsNotDefault(T value);
    [ConditionalAttribute("DEBUG")]
public static void IsFalse(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void IsFalse(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail();
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
public static void IsNull(T item);
    [ConditionalAttribute("DEBUG")]
public static void BoundedDoubleInc(double lowerBoundInclusive, double value, double upperBoundInclusive);
    [ConditionalAttribute("DEBUG")]
public static void BoundedInteger(int lowerBoundInclusive, int value, int upperBoundExclusive);
    [ConditionalAttribute("DEBUG")]
public static void IsApartmentState(ApartmentState expectedState);
    [ConditionalAttribute("DEBUG")]
public static void NullableIsNotNull(Nullable`1<T> value);
    [ConditionalAttribute("DEBUG")]
public static void NullableIsNull(Nullable`1<T> value);
    [ConditionalAttribute("DEBUG")]
public static void IsNotOnMainThread();
}
internal enum Standard.BI : Enum {
    public int value__;
    public static BI RGB;
}
internal class Standard.BITMAPINFO : ValueType {
    public BITMAPINFOHEADER bmiHeader;
    public RGBQUAD bmiColors;
}
internal class Standard.BITMAPINFOHEADER : ValueType {
    public int biSize;
    public int biWidth;
    public int biHeight;
    public short biPlanes;
    public short biBitCount;
    public BI biCompression;
    public int biSizeImage;
    public int biXPelsPerMeter;
    public int biYPelsPerMeter;
    public int biClrUsed;
    public int biClrImportant;
}
internal class Standard.BLENDFUNCTION : ValueType {
    public AC BlendOp;
    public byte BlendFlags;
    public byte SourceConstantAlpha;
    public AC AlphaFormat;
}
internal class Standard.CHANGEFILTERSTRUCT : ValueType {
    public UInt32 cbSize;
    public MSGFLTINFO ExtStatus;
}
internal static class Standard.CLSID : object {
    public static string TaskbarList;
    public static string EnumerableObjectCollection;
    public static string ShellLink;
    public static string DestinationList;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
    public static T CoCreateInstance(string clsid);
}
internal enum Standard.CombineRgnResult : Enum {
    public int value__;
    public static CombineRgnResult ERROR;
    public static CombineRgnResult NULLREGION;
    public static CombineRgnResult SIMPLEREGION;
    public static CombineRgnResult COMPLEXREGION;
}
internal class Standard.CREATESTRUCT : ValueType {
    public IntPtr lpCreateParams;
    public IntPtr hInstance;
    public IntPtr hMenu;
    public IntPtr hwndParent;
    public int cy;
    public int cx;
    public int y;
    public int x;
    public WS style;
    public string lpszName;
    public string lpszClass;
    public WS_EX dwExStyle;
}
[FlagsAttribute]
internal enum Standard.CS : Enum {
    public UInt32 value__;
    public static CS VREDRAW;
    public static CS HREDRAW;
    public static CS DBLCLKS;
    public static CS OWNDC;
    public static CS CLASSDC;
    public static CS PARENTDC;
    public static CS NOCLOSE;
    public static CS SAVEBITS;
    public static CS BYTEALIGNCLIENT;
    public static CS BYTEALIGNWINDOW;
    public static CS GLOBALCLASS;
    public static CS IME;
    public static CS DROPSHADOW;
}
internal enum Standard.DeviceCap : Enum {
    public int value__;
    public static DeviceCap BITSPIXEL;
    public static DeviceCap PLANES;
    public static DeviceCap LOGPIXELSX;
    public static DeviceCap LOGPIXELSY;
}
internal enum Standard.DOGIF : Enum {
    public int value__;
    public static DOGIF DEFAULT;
    public static DOGIF TRAVERSE_LINK;
    public static DOGIF NO_HDROP;
    public static DOGIF NO_URL;
    public static DOGIF ONLY_IF_ONE;
}
internal static class Standard.DoubleUtilities : object {
    private static double Epsilon;
    public static bool AreClose(double value1, double value2);
    public static bool LessThan(double value1, double value2);
    public static bool GreaterThan(double value1, double value2);
    public static bool LessThanOrClose(double value1, double value2);
    public static bool GreaterThanOrClose(double value1, double value2);
    public static bool IsFinite(double value);
    public static bool IsValidSize(double value);
}
internal static class Standard.DpiHelper : object {
    private static Matrix _transformToDevice;
    private static Matrix _transformToDip;
    private static DpiHelper();
    public static Point LogicalPixelsToDevice(Point logicalPoint);
    public static Point DevicePixelsToLogical(Point devicePoint);
    public static Rect LogicalRectToDevice(Rect logicalRectangle);
    public static Rect DeviceRectToLogical(Rect deviceRectangle);
    public static Size LogicalSizeToDevice(Size logicalSize);
    public static Size DeviceSizeToLogical(Size deviceSize);
}
internal enum Standard.DWM_SIT : Enum {
    public int value__;
    public static DWM_SIT None;
    public static DWM_SIT DISPLAYFRAME;
}
internal class Standard.DWM_TIMING_INFO : ValueType {
    public int cbSize;
    public UNSIGNED_RATIO rateRefresh;
    public ulong qpcRefreshPeriod;
    public UNSIGNED_RATIO rateCompose;
    public ulong qpcVBlank;
    public ulong cRefresh;
    public UInt32 cDXRefresh;
    public ulong qpcCompose;
    public ulong cFrame;
    public UInt32 cDXPresent;
    public ulong cRefreshFrame;
    public ulong cFrameSubmitted;
    public UInt32 cDXPresentSubmitted;
    public ulong cFrameConfirmed;
    public UInt32 cDXPresentConfirmed;
    public ulong cRefreshConfirmed;
    public UInt32 cDXRefreshConfirmed;
    public ulong cFramesLate;
    public UInt32 cFramesOutstanding;
    public ulong cFrameDisplayed;
    public ulong qpcFrameDisplayed;
    public ulong cRefreshFrameDisplayed;
    public ulong cFrameComplete;
    public ulong qpcFrameComplete;
    public ulong cFramePending;
    public ulong qpcFramePending;
    public ulong cFramesDisplayed;
    public ulong cFramesComplete;
    public ulong cFramesPending;
    public ulong cFramesAvailable;
    public ulong cFramesDropped;
    public ulong cFramesMissed;
    public ulong cRefreshNextDisplayed;
    public ulong cRefreshNextPresented;
    public ulong cRefreshesDisplayed;
    public ulong cRefreshesPresented;
    public ulong cRefreshStarted;
    public ulong cPixelsReceived;
    public ulong cPixelsDrawn;
    public ulong cBuffersEmpty;
}
internal enum Standard.DWMFLIP3D : Enum {
    public int value__;
    public static DWMFLIP3D DEFAULT;
    public static DWMFLIP3D EXCLUDEBELOW;
    public static DWMFLIP3D EXCLUDEABOVE;
}
internal enum Standard.DWMNCRP : Enum {
    public int value__;
    public static DWMNCRP USEWINDOWSTYLE;
    public static DWMNCRP DISABLED;
    public static DWMNCRP ENABLED;
}
internal enum Standard.DWMWA : Enum {
    public int value__;
    public static DWMWA NCRENDERING_ENABLED;
    public static DWMWA NCRENDERING_POLICY;
    public static DWMWA TRANSITIONS_FORCEDISABLED;
    public static DWMWA ALLOW_NCPAINT;
    public static DWMWA CAPTION_BUTTON_BOUNDS;
    public static DWMWA NONCLIENT_RTL_LAYOUT;
    public static DWMWA FORCE_ICONIC_REPRESENTATION;
    public static DWMWA FLIP3D_POLICY;
    public static DWMWA EXTENDED_FRAME_BOUNDS;
    public static DWMWA HAS_ICONIC_BITMAP;
    public static DWMWA DISALLOW_PEEK;
    public static DWMWA EXCLUDED_FROM_PEEK;
}
[FlagsAttribute]
internal enum Standard.ErrorModes : Enum {
    public int value__;
    public static ErrorModes Default;
    public static ErrorModes FailCriticalErrors;
    public static ErrorModes NoGpFaultErrorBox;
    public static ErrorModes NoAlignmentFaultExcept;
    public static ErrorModes NoOpenFileErrorBox;
}
internal enum Standard.Facility : Enum {
    public int value__;
    public static Facility Null;
    public static Facility Rpc;
    public static Facility Dispatch;
    public static Facility Storage;
    public static Facility Itf;
    public static Facility Win32;
    public static Facility Windows;
    public static Facility Control;
    public static Facility Ese;
    public static Facility WinCodec;
}
internal enum Standard.FO : Enum {
    public int value__;
    public static FO MOVE;
    public static FO COPY;
    public static FO DELETE;
    public static FO RENAME;
}
internal enum Standard.FOF : Enum {
    public ushort value__;
    public static FOF MULTIDESTFILES;
    public static FOF CONFIRMMOUSE;
    public static FOF SILENT;
    public static FOF RENAMEONCOLLISION;
    public static FOF NOCONFIRMATION;
    public static FOF WANTMAPPINGHANDLE;
    public static FOF ALLOWUNDO;
    public static FOF FILESONLY;
    public static FOF SIMPLEPROGRESS;
    public static FOF NOCONFIRMMKDIR;
    public static FOF NOERRORUI;
    public static FOF NOCOPYSECURITYATTRIBS;
    public static FOF NORECURSION;
    public static FOF NO_CONNECTED_ELEMENTS;
    public static FOF WANTNUKEWARNING;
    public static FOF NORECURSEREPARSE;
}
internal enum Standard.GCLP : Enum {
    public int value__;
    public static GCLP HBRBACKGROUND;
}
internal enum Standard.GPS : Enum {
    public int value__;
    public static GPS DEFAULT;
    public static GPS HANDLERPROPERTIESONLY;
    public static GPS READWRITE;
    public static GPS TEMPORARY;
    public static GPS FASTPROPERTIESONLY;
    public static GPS OPENSLOWITEM;
    public static GPS DELAYCREATION;
    public static GPS BESTEFFORT;
    public static GPS NO_OPLOCK;
    public static GPS MASK_VALID;
}
internal enum Standard.GWL : Enum {
    public int value__;
    public static GWL WNDPROC;
    public static GWL HINSTANCE;
    public static GWL HWNDPARENT;
    public static GWL STYLE;
    public static GWL EXSTYLE;
    public static GWL USERDATA;
    public static GWL ID;
}
[FlagsAttribute]
internal enum Standard.HCF : Enum {
    public int value__;
    public static HCF HIGHCONTRASTON;
    public static HCF AVAILABLE;
    public static HCF HOTKEYACTIVE;
    public static HCF CONFIRMHOTKEY;
    public static HCF HOTKEYSOUND;
    public static HCF INDICATOR;
    public static HCF HOTKEYAVAILABLE;
}
internal class Standard.HIGHCONTRAST : ValueType {
    public int cbSize;
    public HCF dwFlags;
    public IntPtr lpszDefaultScheme;
}
internal class Standard.HRESULT : ValueType {
    private UInt32 _value;
    public static HRESULT S_OK;
    public static HRESULT S_FALSE;
    public static HRESULT E_PENDING;
    public static HRESULT E_NOTIMPL;
    public static HRESULT E_NOINTERFACE;
    public static HRESULT E_POINTER;
    public static HRESULT E_ABORT;
    public static HRESULT E_FAIL;
    public static HRESULT E_UNEXPECTED;
    public static HRESULT STG_E_INVALIDFUNCTION;
    public static HRESULT REGDB_E_CLASSNOTREG;
    public static HRESULT DESTS_E_NO_MATCHING_ASSOC_HANDLER;
    public static HRESULT DESTS_E_NORECDOCS;
    public static HRESULT DESTS_E_NOTALLCLEARED;
    public static HRESULT E_ACCESSDENIED;
    public static HRESULT E_OUTOFMEMORY;
    public static HRESULT E_INVALIDARG;
    public static HRESULT INTSAFE_E_ARITHMETIC_OVERFLOW;
    public static HRESULT COR_E_OBJECTDISPOSED;
    public static HRESULT WC_E_GREATERTHAN;
    public static HRESULT WC_E_SYNTAX;
    public Facility Facility { get; }
    public int Code { get; }
    public bool Succeeded { get; }
    public bool Failed { get; }
    public HRESULT(UInt32 i);
    private static HRESULT();
    public static HRESULT Make(bool severe, Facility facility, int code);
    public Facility get_Facility();
    public static Facility GetFacility(int errorCode);
    public int get_Code();
    public static int GetCode(int error);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HRESULT hrLeft, HRESULT hrRight);
    public static bool op_Inequality(HRESULT hrLeft, HRESULT hrRight);
    public bool get_Succeeded();
    public bool get_Failed();
    public void ThrowIfFailed();
    public void ThrowIfFailed(string message);
    public static void ThrowLastError();
}
internal enum Standard.HT : Enum {
    public int value__;
    public static HT ERROR;
    public static HT TRANSPARENT;
    public static HT NOWHERE;
    public static HT CLIENT;
    public static HT CAPTION;
    public static HT SYSMENU;
    public static HT GROWBOX;
    public static HT SIZE;
    public static HT MENU;
    public static HT HSCROLL;
    public static HT VSCROLL;
    public static HT MINBUTTON;
    public static HT MAXBUTTON;
    public static HT LEFT;
    public static HT RIGHT;
    public static HT TOP;
    public static HT TOPLEFT;
    public static HT TOPRIGHT;
    public static HT BOTTOM;
    public static HT BOTTOMLEFT;
    public static HT BOTTOMRIGHT;
    public static HT BORDER;
    public static HT REDUCE;
    public static HT ZOOM;
    public static HT SIZEFIRST;
    public static HT SIZELAST;
    public static HT OBJECT;
    public static HT CLOSE;
    public static HT HELP;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("12337d35-94c6-48a0-bce7-6a9c69d4d600")]
internal interface Standard.IApplicationDestinations {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual void RemoveDestination(object punk);
    public abstract virtual void RemoveAllDestinations();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("3c594f9f-9f30-47a1-979a-c9e83d3d0a06")]
internal interface Standard.IApplicationDocumentLists {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object GetList(APPDOCLISTTYPE listtype, UInt32 cItemsDesired, Guid& riid);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("6332debf-87b5-4670-90c0-5e57b408a49e")]
internal interface Standard.ICustomDestinationList {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object BeginList(UInt32& pcMaxSlots, Guid& riid);
    public abstract virtual HRESULT AppendCategory(string pszCategory, IObjectArray poa);
    public abstract virtual void AppendKnownCategory(KDC category);
    public abstract virtual HRESULT AddUserTasks(IObjectArray poa);
    public abstract virtual void CommitList();
    public abstract virtual object GetRemovedDestinations(Guid& riid);
    public abstract virtual void DeleteList(string pszAppID);
    public abstract virtual void AbortList();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F2-0000-0000-C000-000000000046")]
internal interface Standard.IEnumIDList {
    public abstract virtual HRESULT Next(UInt32 celt, IntPtr& rgelt, Int32& pceltFetched);
    public abstract virtual HRESULT Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumIDList& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("2c1c7e2e-2d0e-4059-831e-1e6f82335c2e")]
internal interface Standard.IEnumObjects {
    public abstract virtual void Next(UInt32 celt, Guid& riid, Object[] rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual IEnumObjects Clone();
}
internal static class Standard.IID : object {
    public static string EnumIdList;
    public static string EnumObjects;
    public static string HtmlDocument2;
    public static string ModalWindow;
    public static string ObjectArray;
    public static string ObjectCollection;
    public static string PropertyNotifySink;
    public static string PropertyStore;
    public static string ServiceProvider;
    public static string ShellFolder;
    public static string ShellLink;
    public static string ShellItem;
    public static string ShellItem2;
    public static string ShellItemArray;
    public static string TaskbarList;
    public static string TaskbarList2;
    public static string Unknown;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
    public static string CustomDestinationList;
    public static string ObjectWithAppUserModelId;
    public static string ObjectWithProgId;
    public static string TaskbarList3;
    public static string TaskbarList4;
}
internal class Standard.INPUT : ValueType {
    public UInt32 type;
    public MOUSEINPUT mi;
}
internal enum Standard.INPUT_TYPE : Enum {
    public UInt32 value__;
    public static INPUT_TYPE MOUSE;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
internal interface Standard.IObjectArray {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
internal interface Standard.IObjectCollection {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
    public abstract virtual void AddObject(object punk);
    public abstract virtual void AddFromArray(IObjectArray poaSource);
    public abstract virtual void RemoveObjectAt(UInt32 uiIndex);
    public abstract virtual void Clear();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("36db0196-9665-46d1-9ba7-d3709eecf9ed")]
internal interface Standard.IObjectWithAppUserModelId {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual string GetAppID();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("71e806fb-8dee-46fc-bf8c-7748a8a1ae13")]
internal interface Standard.IObjectWithProgId {
    public abstract virtual void SetProgID(string pszProgID);
    public abstract virtual string GetProgID();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")]
internal interface Standard.IPropertyStore {
    public abstract virtual UInt32 GetCount();
    public abstract virtual PKEY GetAt(UInt32 iProp);
    public abstract virtual void GetValue(PKEY& pkey, PROPVARIANT pv);
    public abstract virtual void SetValue(PKEY& pkey, PROPVARIANT pv);
    public abstract virtual void Commit();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214E6-0000-0000-C000-000000000046")]
internal interface Standard.IShellFolder {
    public abstract virtual void ParseDisplayName(IntPtr hwnd, IBindCtx pbc, string pszDisplayName, Int32& pchEaten, IntPtr& ppidl, UInt32& pdwAttributes);
    public abstract virtual IEnumIDList EnumObjects(IntPtr hwnd, SHCONTF grfFlags);
    public abstract virtual object BindToObject(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual object BindToStorage(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual HRESULT CompareIDs(IntPtr lParam, IntPtr pidl1, IntPtr pidl2);
    public abstract virtual object CreateViewObject(IntPtr hwndOwner, Guid& riid);
    public abstract virtual void GetAttributesOf(UInt32 cidl, IntPtr apidl, SFGAO& rgfInOut);
    public abstract virtual object GetUIObjectOf(IntPtr hwndOwner, UInt32 cidl, IntPtr apidl, Guid& riid, UInt32& rgfReserved);
    public abstract virtual void GetDisplayNameOf(IntPtr pidl, SHGDN uFlags, IntPtr& pName);
    public abstract virtual void SetNameOf(IntPtr hwnd, IntPtr pidl, string pszName, SHGDN uFlags, IntPtr& ppidlOut);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("43826d1e-e718-42ee-bc55-a1e261c37bfe")]
internal interface Standard.IShellItem {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual SFGAO GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("7e9fb0d3-919f-4307-ab2e-9b1860310c93")]
internal interface Standard.IShellItem2 {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual SFGAO GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
    public abstract virtual object GetPropertyStore(GPS flags, Guid& riid);
    public abstract virtual object GetPropertyStoreWithCreateObject(GPS flags, object punkCreateObject, Guid& riid);
    public abstract virtual object GetPropertyStoreForKeys(IntPtr rgKeys, UInt32 cKeys, GPS flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(IntPtr keyType, Guid& riid);
    public abstract virtual void Update(IBindCtx pbc);
    public abstract virtual PROPVARIANT GetProperty(IntPtr key);
    public abstract virtual Guid GetCLSID(IntPtr key);
    public abstract virtual FILETIME GetFileTime(IntPtr key);
    public abstract virtual int GetInt32(IntPtr key);
    public abstract virtual string GetString(IntPtr key);
    public abstract virtual UInt32 GetUInt32(IntPtr key);
    public abstract virtual ulong GetUInt64(IntPtr key);
    public abstract virtual void GetBool(IntPtr key);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B63EA76D-1F85-456F-A19C-48159EFA858B")]
internal interface Standard.IShellItemArray {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& rbhid, Guid& riid);
    public abstract virtual object GetPropertyStore(int flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(PKEY& keyType, Guid& riid);
    public abstract virtual UInt32 GetAttributes(SIATTRIBFLAGS dwAttribFlags, UInt32 sfgaoMask);
    public abstract virtual UInt32 GetCount();
    public abstract virtual IShellItem GetItemAt(UInt32 dwIndex);
    public abstract virtual object EnumItems();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F9-0000-0000-C000-000000000046")]
internal interface Standard.IShellLinkW {
    public abstract virtual void GetPath(StringBuilder pszFile, int cchMaxPath, WIN32_FIND_DATAW pfd, SLGP fFlags);
    public abstract virtual void GetIDList(IntPtr& ppidl);
    public abstract virtual void SetIDList(IntPtr pidl);
    public abstract virtual void GetDescription(StringBuilder pszFile, int cchMaxName);
    public abstract virtual void SetDescription(string pszName);
    public abstract virtual void GetWorkingDirectory(StringBuilder pszDir, int cchMaxPath);
    public abstract virtual void SetWorkingDirectory(string pszDir);
    public abstract virtual void GetArguments(StringBuilder pszArgs, int cchMaxPath);
    public abstract virtual void SetArguments(string pszArgs);
    public abstract virtual short GetHotKey();
    public abstract virtual void SetHotKey(short wHotKey);
    public abstract virtual UInt32 GetShowCmd();
    public abstract virtual void SetShowCmd(UInt32 iShowCmd);
    public abstract virtual void GetIconLocation(StringBuilder pszIconPath, int cchIconPath, Int32& piIcon);
    public abstract virtual void SetIconLocation(string pszIconPath, int iIcon);
    public abstract virtual void SetRelativePath(string pszPathRel, UInt32 dwReserved);
    public abstract virtual void Resolve(IntPtr hwnd, UInt32 fFlags);
    public abstract virtual void SetPath(string pszFile);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("56FDF342-FD6D-11d0-958A-006097C9A090")]
internal interface Standard.ITaskbarList {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("602D4995-B13A-429b-A66E-1935E44F4317")]
internal interface Standard.ITaskbarList2 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
internal interface Standard.ITaskbarList3 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IntPtr hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
internal interface Standard.ITaskbarList4 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IntPtr hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
    public abstract virtual void SetTabProperties(IntPtr hwndTab, STPF stpFlags);
}
internal enum Standard.KDC : Enum {
    public int value__;
    public static KDC FREQUENT;
    public static KDC RECENT;
}
internal class Standard.LOGFONT : ValueType {
    public int lfHeight;
    public int lfWidth;
    public int lfEscapement;
    public int lfOrientation;
    public int lfWeight;
    public byte lfItalic;
    public byte lfUnderline;
    public byte lfStrikeOut;
    public byte lfCharSet;
    public byte lfOutPrecision;
    public byte lfClipPrecision;
    public byte lfQuality;
    public byte lfPitchAndFamily;
    public string lfFaceName;
}
internal class Standard.ManagedIStream : object {
    private static int STGTY_STREAM;
    private static int STGM_READWRITE;
    private static int LOCK_EXCLUSIVE;
    private Stream _source;
    public ManagedIStream(Stream source);
    private void _Validate();
    [ObsoleteAttribute("The method is not implemented", "True")]
public sealed virtual void Clone(IStream& ppstm);
    public sealed virtual void Commit(int grfCommitFlags);
    public sealed virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    [ObsoleteAttribute("The method is not implemented", "True")]
public sealed virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    [ObsoleteAttribute("The method is not implemented", "True")]
public sealed virtual void Revert();
    public sealed virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public sealed virtual void SetSize(long libNewSize);
    public sealed virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    [ObsoleteAttribute("The method is not implemented", "True")]
public sealed virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public sealed virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public sealed virtual void Dispose();
}
internal class Standard.MARGINS : ValueType {
    public int cxLeftWidth;
    public int cxRightWidth;
    public int cyTopHeight;
    public int cyBottomHeight;
}
internal class Standard.MessageHandler : MulticastDelegate {
    public MessageHandler(object object, IntPtr method);
    public virtual IntPtr Invoke(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
internal class Standard.MessageWindow : DispatcherObject {
    private static WndProc s_WndProc;
    private static Dictionary`2<IntPtr, MessageWindow> s_windowLookup;
    private WndProc _wndProcCallback;
    private string _className;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private IntPtr <Handle>k__BackingField;
    public IntPtr Handle { get; private set; }
    public MessageWindow(CS classStyle, WS style, WS_EX exStyle, Rect location, string name, WndProc callback);
    private static MessageWindow();
    [CompilerGeneratedAttribute]
public IntPtr get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(IntPtr value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void _Dispose(bool disposing, bool isHwndBeingDestroyed);
    private static IntPtr _WndProc(IntPtr hwnd, WM msg, IntPtr wParam, IntPtr lParam);
    private static object _DestroyWindow(IntPtr hwnd, string className);
}
[FlagsAttribute]
internal enum Standard.MF : Enum {
    public UInt32 value__;
    public static MF DOES_NOT_EXIST;
    public static MF ENABLED;
    public static MF BYCOMMAND;
    public static MF GRAYED;
    public static MF DISABLED;
}
internal class Standard.MINMAXINFO : ValueType {
    public POINT ptReserved;
    public POINT ptMaxSize;
    public POINT ptMaxPosition;
    public POINT ptMinTrackSize;
    public POINT ptMaxTrackSize;
}
internal class Standard.MONITORINFO : object {
    public int cbSize;
    public RECT rcMonitor;
    public RECT rcWork;
    public int dwFlags;
}
internal enum Standard.MOUSEEVENTF : Enum {
    public int value__;
    public static MOUSEEVENTF LEFTDOWN;
    public static MOUSEEVENTF LEFTUP;
}
internal class Standard.MOUSEINPUT : ValueType {
    public int dx;
    public int dy;
    public int mouseData;
    public int dwFlags;
    public int time;
    public IntPtr dwExtraInfo;
}
internal enum Standard.MSGFLT : Enum {
    public int value__;
    public static MSGFLT RESET;
    public static MSGFLT ALLOW;
    public static MSGFLT DISALLOW;
}
internal enum Standard.MSGFLTINFO : Enum {
    public int value__;
    public static MSGFLTINFO NONE;
    public static MSGFLTINFO ALREADYALLOWED_FORWND;
    public static MSGFLTINFO ALREADYDISALLOWED_FORWND;
    public static MSGFLTINFO ALLOWED_HIGHER;
}
internal static class Standard.NativeMethods : object {
    private static bool _AdjustWindowRectEx(RECT& lpRect, WS dwStyle, bool bMenu, WS_EX dwExStyle);
    public static RECT AdjustWindowRectEx(RECT lpRect, WS dwStyle, bool bMenu, WS_EX dwExStyle);
    private static bool _ChangeWindowMessageFilter(WM message, MSGFLT dwFlag);
    private static bool _ChangeWindowMessageFilterEx(IntPtr hwnd, WM message, MSGFLT action, CHANGEFILTERSTRUCT& pChangeFilterStruct);
    public static HRESULT ChangeWindowMessageFilterEx(IntPtr hwnd, WM message, MSGFLT action, MSGFLTINFO& filterInfo);
    public static CombineRgnResult CombineRgn(IntPtr hrgnDest, IntPtr hrgnSrc1, IntPtr hrgnSrc2, RGN fnCombineMode);
    private static IntPtr _CommandLineToArgvW(string cmdLine, Int32& numArgs);
    public static String[] CommandLineToArgvW(string cmdLine);
    private static SafeHBITMAP _CreateDIBSection(SafeDC hdc, BITMAPINFO& bitmapInfo, int iUsage, IntPtr& ppvBits, IntPtr hSection, int dwOffset);
    private static SafeHBITMAP _CreateDIBSectionIntPtr(IntPtr hdc, BITMAPINFO& bitmapInfo, int iUsage, IntPtr& ppvBits, IntPtr hSection, int dwOffset);
    public static SafeHBITMAP CreateDIBSection(SafeDC hdc, BITMAPINFO& bitmapInfo, IntPtr& ppvBits, IntPtr hSection, int dwOffset);
    private static IntPtr _CreateRoundRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidthEllipse, int nHeightEllipse);
    public static IntPtr CreateRoundRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidthEllipse, int nHeightEllipse);
    private static IntPtr _CreateRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
    public static IntPtr CreateRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
    private static IntPtr _CreateRectRgnIndirect(RECT& lprc);
    public static IntPtr CreateRectRgnIndirect(RECT lprc);
    public static IntPtr CreateSolidBrush(int crColor);
    private static IntPtr _CreateWindowEx(WS_EX dwExStyle, string lpClassName, string lpWindowName, WS dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    public static IntPtr CreateWindowEx(WS_EX dwExStyle, string lpClassName, string lpWindowName, WS dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    public static IntPtr DefWindowProc(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    public static bool DeleteObject(IntPtr hObject);
    public static bool DestroyIcon(IntPtr handle);
    public static bool DestroyWindow(IntPtr hwnd);
    public static bool IsWindow(IntPtr hwnd);
    public static void DwmExtendFrameIntoClientArea(IntPtr hwnd, MARGINS& pMarInset);
    private static bool _DwmIsCompositionEnabled();
    private static HRESULT _DwmGetColorizationColor(UInt32& pcrColorization, Boolean& pfOpaqueBlend);
    public static bool DwmGetColorizationColor(UInt32& pcrColorization, Boolean& pfOpaqueBlend);
    public static bool DwmIsCompositionEnabled();
    public static bool DwmDefWindowProc(IntPtr hwnd, WM msg, IntPtr wParam, IntPtr lParam, IntPtr& plResult);
    private static void _DwmSetWindowAttribute(IntPtr hwnd, DWMWA dwAttribute, Int32& pvAttribute, int cbAttribute);
    public static void DwmSetWindowAttributeFlip3DPolicy(IntPtr hwnd, DWMFLIP3D flip3dPolicy);
    public static void DwmSetWindowAttributeDisallowPeek(IntPtr hwnd, bool disallowPeek);
    private static int _EnableMenuItem(IntPtr hMenu, SC uIDEnableItem, MF uEnable);
    public static MF EnableMenuItem(IntPtr hMenu, SC uIDEnableItem, MF uEnable);
    private static bool _RemoveMenu(IntPtr hMenu, UInt32 uPosition, UInt32 uFlags);
    public static void RemoveMenu(IntPtr hMenu, SC uPosition, MF uFlags);
    private static bool _DrawMenuBar(IntPtr hWnd);
    public static void DrawMenuBar(IntPtr hWnd);
    public static bool FindClose(IntPtr handle);
    public static SafeFindHandle FindFirstFileW(string lpFileName, WIN32_FIND_DATAW lpFindFileData);
    public static bool FindNextFileW(SafeFindHandle hndFindFile, WIN32_FIND_DATAW lpFindFileData);
    private static bool _GetClientRect(IntPtr hwnd, RECT& lpRect);
    public static RECT GetClientRect(IntPtr hwnd);
    private static HRESULT _GetCurrentThemeName(StringBuilder pszThemeFileName, int dwMaxNameChars, StringBuilder pszColorBuff, int cchMaxColorChars, StringBuilder pszSizeBuff, int cchMaxSizeChars);
    public static void GetCurrentThemeName(String& themeFileName, String& color, String& size);
    public static bool IsThemeActive();
    [ObsoleteAttribute("Use SafeDC.GetDC instead.", "True")]
public static void GetDC();
    public static int GetDeviceCaps(SafeDC hdc, DeviceCap nIndex);
    private static int _GetModuleFileName(IntPtr hModule, StringBuilder lpFilename, int nSize);
    public static string GetModuleFileName(IntPtr hModule);
    private static IntPtr _GetModuleHandle(string lpModuleName);
    public static IntPtr GetModuleHandle(string lpModuleName);
    private static bool _GetMonitorInfo(IntPtr hMonitor, MONITORINFO lpmi);
    public static MONITORINFO GetMonitorInfo(IntPtr hMonitor);
    private static IntPtr _GetStockObject(StockObject fnObject);
    public static IntPtr GetStockObject(StockObject fnObject);
    public static IntPtr GetSystemMenu(IntPtr hWnd, bool bRevert);
    public static int GetSystemMetrics(SM nIndex);
    public static IntPtr GetWindowLongPtr(IntPtr hwnd, GWL nIndex);
    public static void SetWindowThemeAttribute(IntPtr hwnd, WINDOWTHEMEATTRIBUTETYPE eAttribute, WTA_OPTIONS& pvAttribute, UInt32 cbAttribute);
    private static int GetWindowLongPtr32(IntPtr hWnd, GWL nIndex);
    private static IntPtr GetWindowLongPtr64(IntPtr hWnd, GWL nIndex);
    private static bool GetWindowPlacement(IntPtr hwnd, WINDOWPLACEMENT lpwndpl);
    public static WINDOWPLACEMENT GetWindowPlacement(IntPtr hwnd);
    private static bool _GetWindowRect(IntPtr hWnd, RECT& lpRect);
    public static RECT GetWindowRect(IntPtr hwnd);
    public static Status GdipCreateBitmapFromStream(IStream stream, IntPtr& bitmap);
    public static Status GdipCreateHBITMAPFromBitmap(IntPtr bitmap, IntPtr& hbmReturn, int background);
    public static Status GdipCreateHICONFromBitmap(IntPtr bitmap, IntPtr& hbmReturn);
    public static Status GdipDisposeImage(IntPtr image);
    public static Status GdipImageForceValidation(IntPtr image);
    public static Status GdiplusStartup(IntPtr& token, StartupInput input, StartupOutput& output);
    public static Status GdiplusShutdown(IntPtr token);
    public static bool IsWindowVisible(IntPtr hwnd);
    private static IntPtr _LocalFree(IntPtr hMem);
    public static IntPtr MonitorFromWindow(IntPtr hwnd, UInt32 dwFlags);
    private static bool _PostMessage(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    public static void PostMessage(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    private static short _RegisterClassEx(WNDCLASSEX& lpwcx);
    public static short RegisterClassEx(WNDCLASSEX& lpwcx);
    private static UInt32 _RegisterWindowMessage(string lpString);
    public static WM RegisterWindowMessage(string lpString);
    private static IntPtr _SetActiveWindow(IntPtr hWnd);
    public static IntPtr SetActiveWindow(IntPtr hwnd);
    public static IntPtr SetClassLongPtr(IntPtr hwnd, GCLP nIndex, IntPtr dwNewLong);
    private static int SetClassLongPtr32(IntPtr hWnd, GCLP nIndex, int dwNewLong);
    private static IntPtr SetClassLongPtr64(IntPtr hWnd, GCLP nIndex, IntPtr dwNewLong);
    public static ErrorModes SetErrorMode(ErrorModes newMode);
    private static bool _SetProcessWorkingSetSize(IntPtr hProcess, IntPtr dwMinimiumWorkingSetSize, IntPtr dwMaximumWorkingSetSize);
    public static void SetProcessWorkingSetSize(IntPtr hProcess, int dwMinimumWorkingSetSize, int dwMaximumWorkingSetSize);
    public static IntPtr SetWindowLongPtr(IntPtr hwnd, GWL nIndex, IntPtr dwNewLong);
    private static int SetWindowLongPtr32(IntPtr hWnd, GWL nIndex, int dwNewLong);
    private static IntPtr SetWindowLongPtr64(IntPtr hWnd, GWL nIndex, IntPtr dwNewLong);
    private static int _SetWindowRgn(IntPtr hWnd, IntPtr hRgn, bool bRedraw);
    public static void SetWindowRgn(IntPtr hWnd, IntPtr hRgn, bool bRedraw);
    private static bool _SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, SWP uFlags);
    public static bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, SWP uFlags);
    public static Win32Error SHFileOperation(SHFILEOPSTRUCT& lpFileOp);
    public static bool ShowWindow(IntPtr hwnd, SW nCmdShow);
    private static bool _SystemParametersInfo_String(SPI uiAction, int uiParam, string pvParam, SPIF fWinIni);
    private static bool _SystemParametersInfo_NONCLIENTMETRICS(SPI uiAction, int uiParam, NONCLIENTMETRICS& pvParam, SPIF fWinIni);
    private static bool _SystemParametersInfo_HIGHCONTRAST(SPI uiAction, int uiParam, HIGHCONTRAST& pvParam, SPIF fWinIni);
    public static void SystemParametersInfo(SPI uiAction, int uiParam, string pvParam, SPIF fWinIni);
    public static NONCLIENTMETRICS SystemParameterInfo_GetNONCLIENTMETRICS();
    public static HIGHCONTRAST SystemParameterInfo_GetHIGHCONTRAST();
    public static UInt32 TrackPopupMenuEx(IntPtr hmenu, UInt32 fuFlags, int x, int y, IntPtr hwnd, IntPtr lptpm);
    private static IntPtr _SelectObject(SafeDC hdc, IntPtr hgdiobj);
    public static IntPtr SelectObject(SafeDC hdc, IntPtr hgdiobj);
    private static IntPtr _SelectObjectSafeHBITMAP(SafeDC hdc, SafeHBITMAP hgdiobj);
    public static IntPtr SelectObject(SafeDC hdc, SafeHBITMAP hgdiobj);
    public static int SendInput(int nInputs, INPUT& pInputs, int cbSize);
    public static IntPtr SendMessage(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    private static bool _UnregisterClassAtom(IntPtr lpClassName, IntPtr hInstance);
    private static bool _UnregisterClassName(string lpClassName, IntPtr hInstance);
    public static void UnregisterClass(short atom, IntPtr hinstance);
    public static void UnregisterClass(string lpClassName, IntPtr hInstance);
    private static bool _UpdateLayeredWindow(IntPtr hwnd, SafeDC hdcDst, POINT& pptDst, SIZE& psize, SafeDC hdcSrc, POINT& pptSrc, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    private static bool _UpdateLayeredWindowIntPtr(IntPtr hwnd, IntPtr hdcDst, IntPtr pptDst, IntPtr psize, IntPtr hdcSrc, IntPtr pptSrc, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    public static void UpdateLayeredWindow(IntPtr hwnd, SafeDC hdcDst, POINT& pptDst, SIZE& psize, SafeDC hdcSrc, POINT& pptSrc, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    public static void UpdateLayeredWindow(IntPtr hwnd, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    private static void _SHAddToRecentDocs_String(SHARD uFlags, string pv);
    private static void _SHAddToRecentDocs_ShellLink(SHARD uFlags, IShellLinkW pv);
    public static void SHAddToRecentDocs(string path);
    public static void SHAddToRecentDocs(IShellLinkW shellLink);
    private static HRESULT _DwmGetCompositionTimingInfo(IntPtr hwnd, DWM_TIMING_INFO& pTimingInfo);
    public static Nullable`1<DWM_TIMING_INFO> DwmGetCompositionTimingInfo(IntPtr hwnd);
    public static void DwmInvalidateIconicBitmaps(IntPtr hwnd);
    public static void DwmSetIconicThumbnail(IntPtr hwnd, IntPtr hbmp, DWM_SIT dwSITFlags);
    public static void DwmSetIconicLivePreviewBitmap(IntPtr hwnd, IntPtr hbmp, RefPOINT pptClient, DWM_SIT dwSITFlags);
    public static void SHGetItemFromDataObject(IDataObject pdtobj, DOGIF dwFlags, Guid& riid, Object& ppv);
    public static HRESULT SHCreateItemFromParsingName(string pszPath, IBindCtx pbc, Guid& riid, Object& ppv);
    public static bool Shell_NotifyIcon(NIM dwMessage, NOTIFYICONDATA lpdata);
    public static void SetCurrentProcessExplicitAppUserModelID(string AppID);
    public static HRESULT GetCurrentProcessExplicitAppUserModelID(String& AppID);
}
[FlagsAttribute]
internal enum Standard.NIF : Enum {
    public UInt32 value__;
    public static NIF MESSAGE;
    public static NIF ICON;
    public static NIF TIP;
    public static NIF STATE;
    public static NIF INFO;
    public static NIF GUID;
    public static NIF REALTIME;
    public static NIF SHOWTIP;
    public static NIF XP_MASK;
    public static NIF VISTA_MASK;
}
internal enum Standard.NIIF : Enum {
    public int value__;
    public static NIIF NONE;
    public static NIIF INFO;
    public static NIIF WARNING;
    public static NIIF ERROR;
    public static NIIF USER;
    public static NIIF NOSOUND;
    public static NIIF LARGE_ICON;
    public static NIIF NIIF_RESPECT_QUIET_TIME;
    public static NIIF XP_ICON_MASK;
}
internal enum Standard.NIM : Enum {
    public UInt32 value__;
    public static NIM ADD;
    public static NIM MODIFY;
    public static NIM DELETE;
    public static NIM SETFOCUS;
    public static NIM SETVERSION;
}
internal class Standard.NONCLIENTMETRICS : ValueType {
    public int cbSize;
    public int iBorderWidth;
    public int iScrollWidth;
    public int iScrollHeight;
    public int iCaptionWidth;
    public int iCaptionHeight;
    public LOGFONT lfCaptionFont;
    public int iSmCaptionWidth;
    public int iSmCaptionHeight;
    public LOGFONT lfSmCaptionFont;
    public int iMenuWidth;
    public int iMenuHeight;
    public LOGFONT lfMenuFont;
    public LOGFONT lfStatusFont;
    public LOGFONT lfMessageFont;
    public int iPaddedBorderWidth;
    public static NONCLIENTMETRICS VistaMetricsStruct { get; }
    public static NONCLIENTMETRICS XPMetricsStruct { get; }
    public static NONCLIENTMETRICS get_VistaMetricsStruct();
    public static NONCLIENTMETRICS get_XPMetricsStruct();
}
internal class Standard.NOTIFYICONDATA : object {
    public int cbSize;
    public IntPtr hWnd;
    public int uID;
    public NIF uFlags;
    public int uCallbackMessage;
    public IntPtr hIcon;
    public Char[] szTip;
    public UInt32 dwState;
    public UInt32 dwStateMask;
    public Char[] szInfo;
    public UInt32 uVersion;
    public Char[] szInfoTitle;
    public UInt32 dwInfoFlags;
    public Guid guidItem;
    private IntPtr hBalloonIcon;
}
internal enum Standard.OLECMDEXECOPT : Enum {
    public int value__;
    public static OLECMDEXECOPT DODEFAULT;
    public static OLECMDEXECOPT PROMPTUSER;
    public static OLECMDEXECOPT DONTPROMPTUSER;
    public static OLECMDEXECOPT SHOWHELP;
}
internal enum Standard.OLECMDF : Enum {
    public int value__;
    public static OLECMDF SUPPORTED;
    public static OLECMDF ENABLED;
    public static OLECMDF LATCHED;
    public static OLECMDF NINCHED;
    public static OLECMDF INVISIBLE;
    public static OLECMDF DEFHIDEONCTXTMENU;
}
internal enum Standard.OLECMDID : Enum {
    public int value__;
    public static OLECMDID OPEN;
    public static OLECMDID NEW;
    public static OLECMDID SAVE;
    public static OLECMDID SAVEAS;
    public static OLECMDID SAVECOPYAS;
    public static OLECMDID PRINT;
    public static OLECMDID PRINTPREVIEW;
    public static OLECMDID PAGESETUP;
    public static OLECMDID SPELL;
    public static OLECMDID PROPERTIES;
    public static OLECMDID CUT;
    public static OLECMDID COPY;
    public static OLECMDID PASTE;
    public static OLECMDID PASTESPECIAL;
    public static OLECMDID UNDO;
    public static OLECMDID REDO;
    public static OLECMDID SELECTALL;
    public static OLECMDID CLEARSELECTION;
    public static OLECMDID ZOOM;
    public static OLECMDID GETZOOMRANGE;
    public static OLECMDID UPDATECOMMANDS;
    public static OLECMDID REFRESH;
    public static OLECMDID STOP;
    public static OLECMDID HIDETOOLBARS;
    public static OLECMDID SETPROGRESSMAX;
    public static OLECMDID SETPROGRESSPOS;
    public static OLECMDID SETPROGRESSTEXT;
    public static OLECMDID SETTITLE;
    public static OLECMDID SETDOWNLOADSTATE;
    public static OLECMDID STOPDOWNLOAD;
    public static OLECMDID ONTOOLBARACTIVATED;
    public static OLECMDID FIND;
    public static OLECMDID DELETE;
    public static OLECMDID HTTPEQUIV;
    public static OLECMDID HTTPEQUIV_DONE;
    public static OLECMDID ENABLE_INTERACTION;
    public static OLECMDID ONUNLOAD;
    public static OLECMDID PROPERTYBAG2;
    public static OLECMDID PREREFRESH;
    public static OLECMDID SHOWSCRIPTERROR;
    public static OLECMDID SHOWMESSAGE;
    public static OLECMDID SHOWFIND;
    public static OLECMDID SHOWPAGESETUP;
    public static OLECMDID SHOWPRINT;
    public static OLECMDID CLOSE;
    public static OLECMDID ALLOWUILESSSAVEAS;
    public static OLECMDID DONTDOWNLOADCSS;
    public static OLECMDID UPDATEPAGESTATUS;
    public static OLECMDID PRINT2;
    public static OLECMDID PRINTPREVIEW2;
    public static OLECMDID SETPRINTTEMPLATE;
    public static OLECMDID GETPRINTTEMPLATE;
    public static OLECMDID PAGEACTIONBLOCKED;
    public static OLECMDID PAGEACTIONUIQUERY;
    public static OLECMDID FOCUSVIEWCONTROLS;
    public static OLECMDID FOCUSVIEWCONTROLSQUERY;
    public static OLECMDID SHOWPAGEACTIONMENU;
}
internal class Standard.PKEY : ValueType {
    private Guid _fmtid;
    private UInt32 _pid;
    public static PKEY Title;
    public static PKEY AppUserModel_ID;
    public static PKEY AppUserModel_IsDestListSeparator;
    public static PKEY AppUserModel_RelaunchCommand;
    public static PKEY AppUserModel_RelaunchDisplayNameResource;
    public static PKEY AppUserModel_RelaunchIconResource;
    public PKEY(Guid fmtid, UInt32 pid);
    private static PKEY();
}
internal class Standard.POINT : ValueType {
    public int x;
    public int y;
}
internal class Standard.PROPVARIANT : object {
    private ushort vt;
    private IntPtr pointerVal;
    private byte byteVal;
    private long longVal;
    private short boolVal;
    public VarEnum VarType { get; }
    public VarEnum get_VarType();
    public string GetValue();
    public void SetValue(bool f);
    public void SetValue(string val);
    public void Clear();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Dispose(bool disposing);
}
internal enum Standard.READYSTATE : Enum {
    public int value__;
    public static READYSTATE UNINITIALIZED;
    public static READYSTATE LOADING;
    public static READYSTATE LOADED;
    public static READYSTATE INTERACTIVE;
    public static READYSTATE COMPLETE;
}
internal class Standard.RECT : ValueType {
    private int _left;
    private int _top;
    private int _right;
    private int _bottom;
    public int Left { get; public set; }
    public int Right { get; public set; }
    public int Top { get; public set; }
    public int Bottom { get; public set; }
    public int Width { get; }
    public int Height { get; }
    public POINT Position { get; }
    public SIZE Size { get; }
    public void Offset(int dx, int dy);
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public int get_Width();
    public int get_Height();
    public POINT get_Position();
    public SIZE get_Size();
    public static RECT Union(RECT rect1, RECT rect2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Standard.RefPOINT : object {
    public int x;
    public int y;
}
internal class Standard.RefRECT : object {
    private int _left;
    private int _top;
    private int _right;
    private int _bottom;
    public int Width { get; }
    public int Height { get; }
    public int Left { get; public set; }
    public int Right { get; public set; }
    public int Top { get; public set; }
    public int Bottom { get; public set; }
    public RefRECT(int left, int top, int right, int bottom);
    public int get_Width();
    public int get_Height();
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public void Offset(int dx, int dy);
}
internal class Standard.RGBQUAD : ValueType {
    public byte rgbBlue;
    public byte rgbGreen;
    public byte rgbRed;
    public byte rgbReserved;
}
internal enum Standard.RGN : Enum {
    public int value__;
    public static RGN AND;
    public static RGN OR;
    public static RGN XOR;
    public static RGN DIFF;
    public static RGN COPY;
}
internal class Standard.SafeConnectionPointCookie : SafeHandleZeroOrMinusOneIsInvalid {
    private IConnectionPoint _cp;
    public SafeConnectionPointCookie(IConnectionPointContainer target, object sink, Guid eventId);
    public void Disconnect();
    protected virtual bool ReleaseHandle();
}
internal class Standard.SafeDC : SafeHandleZeroOrMinusOneIsInvalid {
    private Nullable`1<IntPtr> _hwnd;
    private bool _created;
    unknown IntPtr Hwnd {public set; }
    public void set_Hwnd(IntPtr value);
    protected virtual bool ReleaseHandle();
    public static SafeDC CreateDC(string deviceName);
    public static SafeDC CreateCompatibleDC(SafeDC hdc);
    public static SafeDC GetDC(IntPtr hwnd);
    public static SafeDC GetDesktop();
    public static SafeDC WrapDC(IntPtr hdc);
}
internal class Standard.SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Standard.SafeGdiplusStartupToken : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
    public static SafeGdiplusStartupToken Startup();
}
internal class Standard.SafeHBITMAP : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal enum Standard.SC : Enum {
    public int value__;
    public static SC SIZE;
    public static SC MOVE;
    public static SC MINIMIZE;
    public static SC MAXIMIZE;
    public static SC NEXTWINDOW;
    public static SC PREVWINDOW;
    public static SC CLOSE;
    public static SC VSCROLL;
    public static SC HSCROLL;
    public static SC MOUSEMENU;
    public static SC KEYMENU;
    public static SC ARRANGE;
    public static SC RESTORE;
    public static SC TASKLIST;
    public static SC SCREENSAVE;
    public static SC HOTKEY;
    public static SC DEFAULT;
    public static SC MONITORPOWER;
    public static SC CONTEXTHELP;
    public static SC SEPARATOR;
    public static SC F_ISSECURE;
    public static SC ICON;
    public static SC ZOOM;
}
[FlagsAttribute]
internal enum Standard.SFGAO : Enum {
    public UInt32 value__;
    public static SFGAO CANCOPY;
    public static SFGAO CANMOVE;
    public static SFGAO CANLINK;
    public static SFGAO STORAGE;
    public static SFGAO CANRENAME;
    public static SFGAO CANDELETE;
    public static SFGAO HASPROPSHEET;
    public static SFGAO DROPTARGET;
    public static SFGAO CAPABILITYMASK;
    public static SFGAO ENCRYPTED;
    public static SFGAO ISSLOW;
    public static SFGAO GHOSTED;
    public static SFGAO LINK;
    public static SFGAO SHARE;
    public static SFGAO READONLY;
    public static SFGAO HIDDEN;
    public static SFGAO DISPLAYATTRMASK;
    public static SFGAO FILESYSANCESTOR;
    public static SFGAO FOLDER;
    public static SFGAO FILESYSTEM;
    public static SFGAO HASSUBFOLDER;
    public static SFGAO CONTENTSMASK;
    public static SFGAO VALIDATE;
    public static SFGAO REMOVABLE;
    public static SFGAO COMPRESSED;
    public static SFGAO BROWSABLE;
    public static SFGAO NONENUMERATED;
    public static SFGAO NEWCONTENT;
    public static SFGAO CANMONIKER;
    public static SFGAO HASSTORAGE;
    public static SFGAO STREAM;
    public static SFGAO STORAGEANCESTOR;
    public static SFGAO STORAGECAPMASK;
    public static SFGAO PKEYSFGAOMASK;
}
internal enum Standard.SHARD : Enum {
    public int value__;
    public static SHARD PIDL;
    public static SHARD PATHA;
    public static SHARD PATHW;
    public static SHARD APPIDINFO;
    public static SHARD APPIDINFOIDLIST;
    public static SHARD LINK;
    public static SHARD APPIDINFOLINK;
}
internal class Standard.SHARDAPPIDINFO : object {
    private object psi;
    private string pszAppID;
}
internal class Standard.SHARDAPPIDINFOIDLIST : object {
    private IntPtr pidl;
    private string pszAppID;
}
internal class Standard.SHARDAPPIDINFOLINK : object {
    private IntPtr psl;
    private string pszAppID;
}
internal enum Standard.SHCONTF : Enum {
    public int value__;
    public static SHCONTF CHECKING_FOR_CHILDREN;
    public static SHCONTF FOLDERS;
    public static SHCONTF NONFOLDERS;
    public static SHCONTF INCLUDEHIDDEN;
    public static SHCONTF INIT_ON_FIRST_NEXT;
    public static SHCONTF NETPRINTERSRCH;
    public static SHCONTF SHAREABLE;
    public static SHCONTF STORAGE;
    public static SHCONTF NAVIGATION_ENUM;
    public static SHCONTF FASTITEMS;
    public static SHCONTF FLATLIST;
    public static SHCONTF ENABLE_ASYNC;
}
internal class Standard.SHFILEOPSTRUCT : ValueType {
    public IntPtr hwnd;
    public FO wFunc;
    public string pFrom;
    public string pTo;
    public FOF fFlags;
    public int fAnyOperationsAborted;
    public IntPtr hNameMappings;
    public string lpszProgressTitle;
}
[FlagsAttribute]
internal enum Standard.SHGDN : Enum {
    public int value__;
    public static SHGDN SHGDN_NORMAL;
    public static SHGDN SHGDN_INFOLDER;
    public static SHGDN SHGDN_FOREDITING;
    public static SHGDN SHGDN_FORADDRESSBAR;
    public static SHGDN SHGDN_FORPARSING;
}
internal enum Standard.SIATTRIBFLAGS : Enum {
    public int value__;
    public static SIATTRIBFLAGS AND;
    public static SIATTRIBFLAGS OR;
    public static SIATTRIBFLAGS APPCOMPAT;
}
internal enum Standard.SICHINT : Enum {
    public UInt32 value__;
    public static SICHINT DISPLAY;
    public static SICHINT ALLFIELDS;
    public static SICHINT CANONICAL;
    public static SICHINT TEST_FILESYSPATH_IF_NOT_EQUAL;
}
internal enum Standard.SIGDN : Enum {
    public UInt32 value__;
    public static SIGDN NORMALDISPLAY;
    public static SIGDN PARENTRELATIVEPARSING;
    public static SIGDN DESKTOPABSOLUTEPARSING;
    public static SIGDN PARENTRELATIVEEDITING;
    public static SIGDN DESKTOPABSOLUTEEDITING;
    public static SIGDN FILESYSPATH;
    public static SIGDN URL;
    public static SIGDN PARENTRELATIVEFORADDRESSBAR;
    public static SIGDN PARENTRELATIVE;
}
internal class Standard.SIZE : ValueType {
    public int cx;
    public int cy;
}
[FlagsAttribute]
internal enum Standard.SLGP : Enum {
    public int value__;
    public static SLGP SHORTPATH;
    public static SLGP UNCPRIORITY;
    public static SLGP RAWPATH;
}
internal enum Standard.SM : Enum {
    public int value__;
    public static SM CXSCREEN;
    public static SM CYSCREEN;
    public static SM CXVSCROLL;
    public static SM CYHSCROLL;
    public static SM CYCAPTION;
    public static SM CXBORDER;
    public static SM CYBORDER;
    public static SM CXFIXEDFRAME;
    public static SM CYFIXEDFRAME;
    public static SM CYVTHUMB;
    public static SM CXHTHUMB;
    public static SM CXICON;
    public static SM CYICON;
    public static SM CXCURSOR;
    public static SM CYCURSOR;
    public static SM CYMENU;
    public static SM CXFULLSCREEN;
    public static SM CYFULLSCREEN;
    public static SM CYKANJIWINDOW;
    public static SM MOUSEPRESENT;
    public static SM CYVSCROLL;
    public static SM CXHSCROLL;
    public static SM DEBUG;
    public static SM SWAPBUTTON;
    public static SM CXMIN;
    public static SM CYMIN;
    public static SM CXSIZE;
    public static SM CYSIZE;
    public static SM CXFRAME;
    public static SM CXSIZEFRAME;
    public static SM CYFRAME;
    public static SM CYSIZEFRAME;
    public static SM CXMINTRACK;
    public static SM CYMINTRACK;
    public static SM CXDOUBLECLK;
    public static SM CYDOUBLECLK;
    public static SM CXICONSPACING;
    public static SM CYICONSPACING;
    public static SM MENUDROPALIGNMENT;
    public static SM PENWINDOWS;
    public static SM DBCSENABLED;
    public static SM CMOUSEBUTTONS;
    public static SM SECURE;
    public static SM CXEDGE;
    public static SM CYEDGE;
    public static SM CXMINSPACING;
    public static SM CYMINSPACING;
    public static SM CXSMICON;
    public static SM CYSMICON;
    public static SM CYSMCAPTION;
    public static SM CXSMSIZE;
    public static SM CYSMSIZE;
    public static SM CXMENUSIZE;
    public static SM CYMENUSIZE;
    public static SM ARRANGE;
    public static SM CXMINIMIZED;
    public static SM CYMINIMIZED;
    public static SM CXMAXTRACK;
    public static SM CYMAXTRACK;
    public static SM CXMAXIMIZED;
    public static SM CYMAXIMIZED;
    public static SM NETWORK;
    public static SM CLEANBOOT;
    public static SM CXDRAG;
    public static SM CYDRAG;
    public static SM SHOWSOUNDS;
    public static SM CXMENUCHECK;
    public static SM CYMENUCHECK;
    public static SM SLOWMACHINE;
    public static SM MIDEASTENABLED;
    public static SM MOUSEWHEELPRESENT;
    public static SM XVIRTUALSCREEN;
    public static SM YVIRTUALSCREEN;
    public static SM CXVIRTUALSCREEN;
    public static SM CYVIRTUALSCREEN;
    public static SM CMONITORS;
    public static SM SAMEDISPLAYFORMAT;
    public static SM IMMENABLED;
    public static SM CXFOCUSBORDER;
    public static SM CYFOCUSBORDER;
    public static SM TABLETPC;
    public static SM MEDIACENTER;
    public static SM REMOTESESSION;
    public static SM REMOTECONTROL;
}
internal enum Standard.SPI : Enum {
    public int value__;
    public static SPI GETBEEP;
    public static SPI SETBEEP;
    public static SPI GETMOUSE;
    public static SPI SETMOUSE;
    public static SPI GETBORDER;
    public static SPI SETBORDER;
    public static SPI GETKEYBOARDSPEED;
    public static SPI SETKEYBOARDSPEED;
    public static SPI LANGDRIVER;
    public static SPI ICONHORIZONTALSPACING;
    public static SPI GETSCREENSAVETIMEOUT;
    public static SPI SETSCREENSAVETIMEOUT;
    public static SPI GETSCREENSAVEACTIVE;
    public static SPI SETSCREENSAVEACTIVE;
    public static SPI GETGRIDGRANULARITY;
    public static SPI SETGRIDGRANULARITY;
    public static SPI SETDESKWALLPAPER;
    public static SPI SETDESKPATTERN;
    public static SPI GETKEYBOARDDELAY;
    public static SPI SETKEYBOARDDELAY;
    public static SPI ICONVERTICALSPACING;
    public static SPI GETICONTITLEWRAP;
    public static SPI SETICONTITLEWRAP;
    public static SPI GETMENUDROPALIGNMENT;
    public static SPI SETMENUDROPALIGNMENT;
    public static SPI SETDOUBLECLKWIDTH;
    public static SPI SETDOUBLECLKHEIGHT;
    public static SPI GETICONTITLELOGFONT;
    public static SPI SETDOUBLECLICKTIME;
    public static SPI SETMOUSEBUTTONSWAP;
    public static SPI SETICONTITLELOGFONT;
    public static SPI GETFASTTASKSWITCH;
    public static SPI SETFASTTASKSWITCH;
    public static SPI SETDRAGFULLWINDOWS;
    public static SPI GETDRAGFULLWINDOWS;
    public static SPI GETNONCLIENTMETRICS;
    public static SPI SETNONCLIENTMETRICS;
    public static SPI GETMINIMIZEDMETRICS;
    public static SPI SETMINIMIZEDMETRICS;
    public static SPI GETICONMETRICS;
    public static SPI SETICONMETRICS;
    public static SPI SETWORKAREA;
    public static SPI GETWORKAREA;
    public static SPI SETPENWINDOWS;
    public static SPI GETHIGHCONTRAST;
    public static SPI SETHIGHCONTRAST;
    public static SPI GETKEYBOARDPREF;
    public static SPI SETKEYBOARDPREF;
    public static SPI GETSCREENREADER;
    public static SPI SETSCREENREADER;
    public static SPI GETANIMATION;
    public static SPI SETANIMATION;
    public static SPI GETFONTSMOOTHING;
    public static SPI SETFONTSMOOTHING;
    public static SPI SETDRAGWIDTH;
    public static SPI SETDRAGHEIGHT;
    public static SPI SETHANDHELD;
    public static SPI GETLOWPOWERTIMEOUT;
    public static SPI GETPOWEROFFTIMEOUT;
    public static SPI SETLOWPOWERTIMEOUT;
    public static SPI SETPOWEROFFTIMEOUT;
    public static SPI GETLOWPOWERACTIVE;
    public static SPI GETPOWEROFFACTIVE;
    public static SPI SETLOWPOWERACTIVE;
    public static SPI SETPOWEROFFACTIVE;
    public static SPI SETCURSORS;
    public static SPI SETICONS;
    public static SPI GETDEFAULTINPUTLANG;
    public static SPI SETDEFAULTINPUTLANG;
    public static SPI SETLANGTOGGLE;
    public static SPI GETWINDOWSEXTENSION;
    public static SPI SETMOUSETRAILS;
    public static SPI GETMOUSETRAILS;
    public static SPI SETSCREENSAVERRUNNING;
    public static SPI SCREENSAVERRUNNING;
    public static SPI GETFILTERKEYS;
    public static SPI SETFILTERKEYS;
    public static SPI GETTOGGLEKEYS;
    public static SPI SETTOGGLEKEYS;
    public static SPI GETMOUSEKEYS;
    public static SPI SETMOUSEKEYS;
    public static SPI GETSHOWSOUNDS;
    public static SPI SETSHOWSOUNDS;
    public static SPI GETSTICKYKEYS;
    public static SPI SETSTICKYKEYS;
    public static SPI GETACCESSTIMEOUT;
    public static SPI SETACCESSTIMEOUT;
    public static SPI GETSERIALKEYS;
    public static SPI SETSERIALKEYS;
    public static SPI GETSOUNDSENTRY;
    public static SPI SETSOUNDSENTRY;
    public static SPI GETSNAPTODEFBUTTON;
    public static SPI SETSNAPTODEFBUTTON;
    public static SPI GETMOUSEHOVERWIDTH;
    public static SPI SETMOUSEHOVERWIDTH;
    public static SPI GETMOUSEHOVERHEIGHT;
    public static SPI SETMOUSEHOVERHEIGHT;
    public static SPI GETMOUSEHOVERTIME;
    public static SPI SETMOUSEHOVERTIME;
    public static SPI GETWHEELSCROLLLINES;
    public static SPI SETWHEELSCROLLLINES;
    public static SPI GETMENUSHOWDELAY;
    public static SPI SETMENUSHOWDELAY;
    public static SPI GETWHEELSCROLLCHARS;
    public static SPI SETWHEELSCROLLCHARS;
    public static SPI GETSHOWIMEUI;
    public static SPI SETSHOWIMEUI;
    public static SPI GETMOUSESPEED;
    public static SPI SETMOUSESPEED;
    public static SPI GETSCREENSAVERRUNNING;
    public static SPI GETDESKWALLPAPER;
    public static SPI GETAUDIODESCRIPTION;
    public static SPI SETAUDIODESCRIPTION;
    public static SPI GETSCREENSAVESECURE;
    public static SPI SETSCREENSAVESECURE;
    public static SPI GETHUNGAPPTIMEOUT;
    public static SPI SETHUNGAPPTIMEOUT;
    public static SPI GETWAITTOKILLTIMEOUT;
    public static SPI SETWAITTOKILLTIMEOUT;
    public static SPI GETWAITTOKILLSERVICETIMEOUT;
    public static SPI SETWAITTOKILLSERVICETIMEOUT;
    public static SPI GETMOUSEDOCKTHRESHOLD;
    public static SPI SETMOUSEDOCKTHRESHOLD;
    public static SPI GETPENDOCKTHRESHOLD;
    public static SPI SETPENDOCKTHRESHOLD;
    public static SPI GETWINARRANGING;
    public static SPI SETWINARRANGING;
    public static SPI GETMOUSEDRAGOUTTHRESHOLD;
    public static SPI SETMOUSEDRAGOUTTHRESHOLD;
    public static SPI GETPENDRAGOUTTHRESHOLD;
    public static SPI SETPENDRAGOUTTHRESHOLD;
    public static SPI GETMOUSESIDEMOVETHRESHOLD;
    public static SPI SETMOUSESIDEMOVETHRESHOLD;
    public static SPI GETPENSIDEMOVETHRESHOLD;
    public static SPI SETPENSIDEMOVETHRESHOLD;
    public static SPI GETDRAGFROMMAXIMIZE;
    public static SPI SETDRAGFROMMAXIMIZE;
    public static SPI GETSNAPSIZING;
    public static SPI SETSNAPSIZING;
    public static SPI GETDOCKMOVING;
    public static SPI SETDOCKMOVING;
    public static SPI GETACTIVEWINDOWTRACKING;
    public static SPI SETACTIVEWINDOWTRACKING;
    public static SPI GETMENUANIMATION;
    public static SPI SETMENUANIMATION;
    public static SPI GETCOMBOBOXANIMATION;
    public static SPI SETCOMBOBOXANIMATION;
    public static SPI GETLISTBOXSMOOTHSCROLLING;
    public static SPI SETLISTBOXSMOOTHSCROLLING;
    public static SPI GETGRADIENTCAPTIONS;
    public static SPI SETGRADIENTCAPTIONS;
    public static SPI GETKEYBOARDCUES;
    public static SPI SETKEYBOARDCUES;
    public static SPI GETMENUUNDERLINES;
    public static SPI SETMENUUNDERLINES;
    public static SPI GETACTIVEWNDTRKZORDER;
    public static SPI SETACTIVEWNDTRKZORDER;
    public static SPI GETHOTTRACKING;
    public static SPI SETHOTTRACKING;
    public static SPI GETMENUFADE;
    public static SPI SETMENUFADE;
    public static SPI GETSELECTIONFADE;
    public static SPI SETSELECTIONFADE;
    public static SPI GETTOOLTIPANIMATION;
    public static SPI SETTOOLTIPANIMATION;
    public static SPI GETTOOLTIPFADE;
    public static SPI SETTOOLTIPFADE;
    public static SPI GETCURSORSHADOW;
    public static SPI SETCURSORSHADOW;
    public static SPI GETMOUSESONAR;
    public static SPI SETMOUSESONAR;
    public static SPI GETMOUSECLICKLOCK;
    public static SPI SETMOUSECLICKLOCK;
    public static SPI GETMOUSEVANISH;
    public static SPI SETMOUSEVANISH;
    public static SPI GETFLATMENU;
    public static SPI SETFLATMENU;
    public static SPI GETDROPSHADOW;
    public static SPI SETDROPSHADOW;
    public static SPI GETBLOCKSENDINPUTRESETS;
    public static SPI SETBLOCKSENDINPUTRESETS;
    public static SPI GETUIEFFECTS;
    public static SPI SETUIEFFECTS;
    public static SPI GETDISABLEOVERLAPPEDCONTENT;
    public static SPI SETDISABLEOVERLAPPEDCONTENT;
    public static SPI GETCLIENTAREAANIMATION;
    public static SPI SETCLIENTAREAANIMATION;
    public static SPI GETCLEARTYPE;
    public static SPI SETCLEARTYPE;
    public static SPI GETSPEECHRECOGNITION;
    public static SPI SETSPEECHRECOGNITION;
    public static SPI GETFOREGROUNDLOCKTIMEOUT;
    public static SPI SETFOREGROUNDLOCKTIMEOUT;
    public static SPI GETACTIVEWNDTRKTIMEOUT;
    public static SPI SETACTIVEWNDTRKTIMEOUT;
    public static SPI GETFOREGROUNDFLASHCOUNT;
    public static SPI SETFOREGROUNDFLASHCOUNT;
    public static SPI GETCARETWIDTH;
    public static SPI SETCARETWIDTH;
    public static SPI GETMOUSECLICKLOCKTIME;
    public static SPI SETMOUSECLICKLOCKTIME;
    public static SPI GETFONTSMOOTHINGTYPE;
    public static SPI SETFONTSMOOTHINGTYPE;
    public static SPI GETFONTSMOOTHINGCONTRAST;
    public static SPI SETFONTSMOOTHINGCONTRAST;
    public static SPI GETFOCUSBORDERWIDTH;
    public static SPI SETFOCUSBORDERWIDTH;
    public static SPI GETFOCUSBORDERHEIGHT;
    public static SPI SETFOCUSBORDERHEIGHT;
    public static SPI GETFONTSMOOTHINGORIENTATION;
    public static SPI SETFONTSMOOTHINGORIENTATION;
    public static SPI GETMINIMUMHITRADIUS;
    public static SPI SETMINIMUMHITRADIUS;
    public static SPI GETMESSAGEDURATION;
    public static SPI SETMESSAGEDURATION;
}
[FlagsAttribute]
internal enum Standard.SPIF : Enum {
    public int value__;
    public static SPIF None;
    public static SPIF UPDATEINIFILE;
    public static SPIF SENDCHANGE;
    public static SPIF SENDWININICHANGE;
}
internal class Standard.StartupInput : object {
    public int GdiplusVersion;
    public IntPtr DebugEventCallback;
    public bool SuppressBackgroundThread;
    public bool SuppressExternalCodecs;
}
internal class Standard.StartupOutput : ValueType {
    public IntPtr hook;
    public IntPtr unhook;
}
[FlagsAttribute]
internal enum Standard.STATE_SYSTEM : Enum {
    public int value__;
    public static STATE_SYSTEM UNAVAILABLE;
    public static STATE_SYSTEM SELECTED;
    public static STATE_SYSTEM FOCUSED;
    public static STATE_SYSTEM PRESSED;
    public static STATE_SYSTEM CHECKED;
    public static STATE_SYSTEM MIXED;
    public static STATE_SYSTEM INDETERMINATE;
    public static STATE_SYSTEM READONLY;
    public static STATE_SYSTEM HOTTRACKED;
    public static STATE_SYSTEM DEFAULT;
    public static STATE_SYSTEM EXPANDED;
    public static STATE_SYSTEM COLLAPSED;
    public static STATE_SYSTEM BUSY;
    public static STATE_SYSTEM FLOATING;
    public static STATE_SYSTEM MARQUEED;
    public static STATE_SYSTEM ANIMATED;
    public static STATE_SYSTEM INVISIBLE;
    public static STATE_SYSTEM OFFSCREEN;
    public static STATE_SYSTEM SIZEABLE;
    public static STATE_SYSTEM MOVEABLE;
    public static STATE_SYSTEM SELFVOICING;
    public static STATE_SYSTEM FOCUSABLE;
    public static STATE_SYSTEM SELECTABLE;
    public static STATE_SYSTEM LINKED;
    public static STATE_SYSTEM TRAVERSED;
    public static STATE_SYSTEM MULTISELECTABLE;
    public static STATE_SYSTEM EXTSELECTABLE;
    public static STATE_SYSTEM ALERT_LOW;
    public static STATE_SYSTEM ALERT_MEDIUM;
    public static STATE_SYSTEM ALERT_HIGH;
    public static STATE_SYSTEM PROTECTED;
    public static STATE_SYSTEM VALID;
}
internal enum Standard.Status : Enum {
    public int value__;
    public static Status Ok;
    public static Status GenericError;
    public static Status InvalidParameter;
    public static Status OutOfMemory;
    public static Status ObjectBusy;
    public static Status InsufficientBuffer;
    public static Status NotImplemented;
    public static Status Win32Error;
    public static Status WrongState;
    public static Status Aborted;
    public static Status FileNotFound;
    public static Status ValueOverflow;
    public static Status AccessDenied;
    public static Status UnknownImageFormat;
    public static Status FontFamilyNotFound;
    public static Status FontStyleNotFound;
    public static Status NotTrueTypeFont;
    public static Status UnsupportedGdiplusVersion;
    public static Status GdiplusNotInitialized;
    public static Status PropertyNotFound;
    public static Status PropertyNotSupported;
    public static Status ProfileNotFound;
}
internal enum Standard.StockObject : Enum {
    public int value__;
    public static StockObject WHITE_BRUSH;
    public static StockObject LTGRAY_BRUSH;
    public static StockObject GRAY_BRUSH;
    public static StockObject DKGRAY_BRUSH;
    public static StockObject BLACK_BRUSH;
    public static StockObject NULL_BRUSH;
    public static StockObject HOLLOW_BRUSH;
    public static StockObject WHITE_PEN;
    public static StockObject BLACK_PEN;
    public static StockObject NULL_PEN;
    public static StockObject SYSTEM_FONT;
    public static StockObject DEFAULT_PALETTE;
}
[FlagsAttribute]
internal enum Standard.STPF : Enum {
    public int value__;
    public static STPF NONE;
    public static STPF USEAPPTHUMBNAILALWAYS;
    public static STPF USEAPPTHUMBNAILWHENACTIVE;
    public static STPF USEAPPPEEKALWAYS;
    public static STPF USEAPPPEEKWHENACTIVE;
}
internal static class Standard.STR_GPS : object {
    public static string HANDLERPROPERTIESONLY;
    public static string FASTPROPERTIESONLY;
    public static string OPENSLOWITEM;
    public static string DELAYCREATION;
    public static string BESTEFFORT;
    public static string NO_OPLOCK;
}
internal enum Standard.SW : Enum {
    public int value__;
    public static SW HIDE;
    public static SW SHOWNORMAL;
    public static SW NORMAL;
    public static SW SHOWMINIMIZED;
    public static SW SHOWMAXIMIZED;
    public static SW MAXIMIZE;
    public static SW SHOWNOACTIVATE;
    public static SW SHOW;
    public static SW MINIMIZE;
    public static SW SHOWMINNOACTIVE;
    public static SW SHOWNA;
    public static SW RESTORE;
    public static SW SHOWDEFAULT;
    public static SW FORCEMINIMIZE;
}
[FlagsAttribute]
internal enum Standard.SWP : Enum {
    public int value__;
    public static SWP ASYNCWINDOWPOS;
    public static SWP DEFERERASE;
    public static SWP DRAWFRAME;
    public static SWP FRAMECHANGED;
    public static SWP HIDEWINDOW;
    public static SWP NOACTIVATE;
    public static SWP NOCOPYBITS;
    public static SWP NOMOVE;
    public static SWP NOOWNERZORDER;
    public static SWP NOREDRAW;
    public static SWP NOREPOSITION;
    public static SWP NOSENDCHANGING;
    public static SWP NOSIZE;
    public static SWP NOZORDER;
    public static SWP SHOWWINDOW;
}
internal enum Standard.TBPF : Enum {
    public int value__;
    public static TBPF NOPROGRESS;
    public static TBPF INDETERMINATE;
    public static TBPF NORMAL;
    public static TBPF ERROR;
    public static TBPF PAUSED;
}
[FlagsAttribute]
internal enum Standard.THB : Enum {
    public UInt32 value__;
    public static THB BITMAP;
    public static THB ICON;
    public static THB TOOLTIP;
    public static THB FLAGS;
}
[FlagsAttribute]
internal enum Standard.THBF : Enum {
    public UInt32 value__;
    public static THBF ENABLED;
    public static THBF DISABLED;
    public static THBF DISMISSONCLICK;
    public static THBF NOBACKGROUND;
    public static THBF HIDDEN;
    public static THBF NONINTERACTIVE;
}
internal class Standard.THUMBBUTTON : ValueType {
    public static int THBN_CLICKED;
    public THB dwMask;
    public UInt32 iId;
    public UInt32 iBitmap;
    public IntPtr hIcon;
    public string szTip;
    public THBF dwFlags;
}
internal class Standard.TITLEBARINFO : ValueType {
    public int cbSize;
    public RECT rcTitleBar;
    public STATE_SYSTEM rgstate_TitleBar;
    public STATE_SYSTEM rgstate_Reserved;
    public STATE_SYSTEM rgstate_MinimizeButton;
    public STATE_SYSTEM rgstate_MaximizeButton;
    public STATE_SYSTEM rgstate_HelpButton;
    public STATE_SYSTEM rgstate_CloseButton;
}
internal class Standard.TITLEBARINFOEX : ValueType {
    public int cbSize;
    public RECT rcTitleBar;
    public STATE_SYSTEM rgstate_TitleBar;
    public STATE_SYSTEM rgstate_Reserved;
    public STATE_SYSTEM rgstate_MinimizeButton;
    public STATE_SYSTEM rgstate_MaximizeButton;
    public STATE_SYSTEM rgstate_HelpButton;
    public STATE_SYSTEM rgstate_CloseButton;
    public RECT rgrect_TitleBar;
    public RECT rgrect_Reserved;
    public RECT rgrect_MinimizeButton;
    public RECT rgrect_MaximizeButton;
    public RECT rgrect_HelpButton;
    public RECT rgrect_CloseButton;
}
internal enum Standard.ULW : Enum {
    public int value__;
    public static ULW ALPHA;
    public static ULW COLORKEY;
    public static ULW OPAQUE;
}
internal class Standard.UNSIGNED_RATIO : ValueType {
    public UInt32 uiNumerator;
    public UInt32 uiDenominator;
}
internal static class Standard.Utility : object {
    private static Version _osVersion;
    private static Version _presentationFrameworkVersion;
    private static int s_bitDepth;
    public static bool IsOSVistaOrNewer { get; }
    public static bool IsOSWindows7OrNewer { get; }
    public static bool IsOSWindows8OrNewer { get; }
    public static bool IsPresentationFrameworkVersionLessThan4 { get; }
    private static Utility();
    private static bool _MemCmp(IntPtr left, IntPtr right, long cb);
    public static int RGB(Color c);
    public static Color ColorFromArgbDword(UInt32 color);
    public static int GET_X_LPARAM(IntPtr lParam);
    public static int GET_Y_LPARAM(IntPtr lParam);
    public static int HIWORD(int i);
    public static int LOWORD(int i);
    public static bool AreStreamsEqual(Stream left, Stream right);
    public static bool GuidTryParse(string guidString, Guid& guid);
    public static bool IsFlagSet(int value, int mask);
    public static bool IsFlagSet(UInt32 value, UInt32 mask);
    public static bool IsFlagSet(long value, long mask);
    public static bool IsFlagSet(ulong value, ulong mask);
    public static bool get_IsOSVistaOrNewer();
    public static bool get_IsOSWindows7OrNewer();
    public static bool get_IsOSWindows8OrNewer();
    public static bool get_IsPresentationFrameworkVersionLessThan4();
    public static IntPtr GenerateHICON(ImageSource image, Size dimensions);
    public static BitmapFrame GetBestMatch(IList`1<BitmapFrame> frames, int width, int height);
    private static int _MatchImage(BitmapFrame frame, int bitDepth, int width, int height, int bpp);
    private static int _WeightedAbs(int valueHave, int valueWant, bool fPunish);
    private static BitmapFrame _GetBestMatch(IList`1<BitmapFrame> frames, int bitDepth, int width, int height);
    private static int _GetBitDepth();
    public static void SafeDeleteFile(string path);
    public static void SafeDeleteObject(IntPtr& gdiObject);
    public static void SafeDestroyIcon(IntPtr& hicon);
    public static void SafeDestroyWindow(IntPtr& hwnd);
    public static void SafeDispose(T& disposable);
    public static void SafeDisposeImage(IntPtr& gdipImage);
    public static void SafeCoTaskMemFree(IntPtr& ptr);
    public static void SafeFreeHGlobal(IntPtr& hglobal);
    public static void SafeRelease(T& comObject);
    public static void GeneratePropertyString(StringBuilder source, string propertyName, string value);
    [ObsoleteAttribute]
public static string GenerateToString(T object);
    public static void CopyStream(Stream destination, Stream source);
    public static string HashStreamMD5(Stream stm);
    public static void EnsureDirectory(string path);
    public static bool MemCmp(Byte[] left, Byte[] right, int cb);
    public static string UrlDecode(string url);
    public static string UrlEncode(string url);
    private static bool _UrlEncodeIsSafe(byte b);
    private static bool _IsAsciiAlphaNumeric(byte b);
    private static byte _IntToHex(int n);
    private static int _HexToInt(char h);
    public static void AddDependencyPropertyChangeListener(object component, DependencyProperty property, EventHandler listener);
    public static void RemoveDependencyPropertyChangeListener(object component, DependencyProperty property, EventHandler listener);
    public static bool IsThicknessNonNegative(Thickness thickness);
    public static bool IsCornerRadiusValid(CornerRadius cornerRadius);
    public static bool IsDoubleFiniteAndNonNegative(double d);
}
internal static class Standard.Verify : object {
    [DebuggerStepThroughAttribute]
public static void IsApartmentState(ApartmentState requiredState, string message);
    [DebuggerStepThroughAttribute]
public static void IsNeitherNullNorEmpty(string value, string name);
    [DebuggerStepThroughAttribute]
public static void IsNeitherNullNorWhitespace(string value, string name);
    [DebuggerStepThroughAttribute]
public static void IsNotDefault(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void IsNotNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void IsNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void PropertyIsNotNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void PropertyIsNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void IsTrue(bool statement, string name);
    [DebuggerStepThroughAttribute]
public static void IsTrue(bool statement, string name, string message);
    [DebuggerStepThroughAttribute]
public static void AreEqual(T expected, T actual, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void AreNotEqual(T notExpected, T actual, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void UriIsAbsolute(Uri uri, string parameterName);
    [DebuggerStepThroughAttribute]
public static void BoundedInteger(int lowerBoundInclusive, int value, int upperBoundExclusive, string parameterName);
    [DebuggerStepThroughAttribute]
public static void BoundedDoubleInc(double lowerBoundInclusive, double value, double upperBoundInclusive, string message, string parameter);
    [DebuggerStepThroughAttribute]
public static void TypeSupportsInterface(Type type, Type interfaceType, string parameterName);
    [DebuggerStepThroughAttribute]
public static void FileExists(string filePath, string parameterName);
    [DebuggerStepThroughAttribute]
internal static void ImplementsInterface(object parameter, Type interfaceType, string parameterName);
}
[BestFitMappingAttribute("False")]
internal class Standard.WIN32_FIND_DATAW : object {
    public FileAttributes dwFileAttributes;
    public FILETIME ftCreationTime;
    public FILETIME ftLastAccessTime;
    public FILETIME ftLastWriteTime;
    public int nFileSizeHigh;
    public int nFileSizeLow;
    public int dwReserved0;
    public int dwReserved1;
    public string cFileName;
    public string cAlternateFileName;
}
internal class Standard.Win32Error : ValueType {
    private int _value;
    public static Win32Error ERROR_SUCCESS;
    public static Win32Error ERROR_INVALID_FUNCTION;
    public static Win32Error ERROR_FILE_NOT_FOUND;
    public static Win32Error ERROR_PATH_NOT_FOUND;
    public static Win32Error ERROR_TOO_MANY_OPEN_FILES;
    public static Win32Error ERROR_ACCESS_DENIED;
    public static Win32Error ERROR_INVALID_HANDLE;
    public static Win32Error ERROR_OUTOFMEMORY;
    public static Win32Error ERROR_NO_MORE_FILES;
    public static Win32Error ERROR_SHARING_VIOLATION;
    public static Win32Error ERROR_INVALID_PARAMETER;
    public static Win32Error ERROR_INSUFFICIENT_BUFFER;
    public static Win32Error ERROR_NESTING_NOT_ALLOWED;
    public static Win32Error ERROR_KEY_DELETED;
    public static Win32Error ERROR_NOT_FOUND;
    public static Win32Error ERROR_NO_MATCH;
    public static Win32Error ERROR_BAD_DEVICE;
    public static Win32Error ERROR_CANCELLED;
    public static Win32Error ERROR_CLASS_ALREADY_EXISTS;
    public static Win32Error ERROR_INVALID_DATATYPE;
    public Win32Error(int i);
    private static Win32Error();
    public static HRESULT op_Explicit(Win32Error error);
    public HRESULT ToHRESULT();
    public static Win32Error GetLastError();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Win32Error errLeft, Win32Error errRight);
    public static bool op_Inequality(Win32Error errLeft, Win32Error errRight);
}
internal static class Standard.Win32Value : object {
    public static UInt32 MAX_PATH;
    public static UInt32 INFOTIPSIZE;
    public static UInt32 TRUE;
    public static UInt32 FALSE;
    public static UInt32 sizeof_WCHAR;
    public static UInt32 sizeof_CHAR;
    public static UInt32 sizeof_BOOL;
}
internal class Standard.WINDOWPLACEMENT : object {
    public int length;
    public int flags;
    public SW showCmd;
    public POINT ptMinPosition;
    public POINT ptMaxPosition;
    public RECT rcNormalPosition;
}
internal class Standard.WINDOWPOS : ValueType {
    public IntPtr hwnd;
    public IntPtr hwndInsertAfter;
    public int x;
    public int y;
    public int cx;
    public int cy;
    public int flags;
}
internal enum Standard.WINDOWTHEMEATTRIBUTETYPE : Enum {
    public UInt32 value__;
    public static WINDOWTHEMEATTRIBUTETYPE WTA_NONCLIENT;
}
internal enum Standard.WM : Enum {
    public int value__;
    public static WM NULL;
    public static WM CREATE;
    public static WM DESTROY;
    public static WM MOVE;
    public static WM SIZE;
    public static WM ACTIVATE;
    public static WM SETFOCUS;
    public static WM KILLFOCUS;
    public static WM ENABLE;
    public static WM SETREDRAW;
    public static WM SETTEXT;
    public static WM GETTEXT;
    public static WM GETTEXTLENGTH;
    public static WM PAINT;
    public static WM CLOSE;
    public static WM QUERYENDSESSION;
    public static WM QUIT;
    public static WM QUERYOPEN;
    public static WM ERASEBKGND;
    public static WM SYSCOLORCHANGE;
    public static WM SHOWWINDOW;
    public static WM CTLCOLOR;
    public static WM WININICHANGE;
    public static WM SETTINGCHANGE;
    public static WM ACTIVATEAPP;
    public static WM SETCURSOR;
    public static WM MOUSEACTIVATE;
    public static WM CHILDACTIVATE;
    public static WM QUEUESYNC;
    public static WM GETMINMAXINFO;
    public static WM WINDOWPOSCHANGING;
    public static WM WINDOWPOSCHANGED;
    public static WM CONTEXTMENU;
    public static WM STYLECHANGING;
    public static WM STYLECHANGED;
    public static WM DISPLAYCHANGE;
    public static WM GETICON;
    public static WM SETICON;
    public static WM NCCREATE;
    public static WM NCDESTROY;
    public static WM NCCALCSIZE;
    public static WM NCHITTEST;
    public static WM NCPAINT;
    public static WM NCACTIVATE;
    public static WM GETDLGCODE;
    public static WM SYNCPAINT;
    public static WM NCMOUSEMOVE;
    public static WM NCLBUTTONDOWN;
    public static WM NCLBUTTONUP;
    public static WM NCLBUTTONDBLCLK;
    public static WM NCRBUTTONDOWN;
    public static WM NCRBUTTONUP;
    public static WM NCRBUTTONDBLCLK;
    public static WM NCMBUTTONDOWN;
    public static WM NCMBUTTONUP;
    public static WM NCMBUTTONDBLCLK;
    public static WM SYSKEYDOWN;
    public static WM SYSKEYUP;
    public static WM SYSCHAR;
    public static WM SYSDEADCHAR;
    public static WM COMMAND;
    public static WM SYSCOMMAND;
    public static WM MOUSEMOVE;
    public static WM LBUTTONDOWN;
    public static WM LBUTTONUP;
    public static WM LBUTTONDBLCLK;
    public static WM RBUTTONDOWN;
    public static WM RBUTTONUP;
    public static WM RBUTTONDBLCLK;
    public static WM MBUTTONDOWN;
    public static WM MBUTTONUP;
    public static WM MBUTTONDBLCLK;
    public static WM MOUSEWHEEL;
    public static WM XBUTTONDOWN;
    public static WM XBUTTONUP;
    public static WM XBUTTONDBLCLK;
    public static WM MOUSEHWHEEL;
    public static WM PARENTNOTIFY;
    public static WM CAPTURECHANGED;
    public static WM POWERBROADCAST;
    public static WM DEVICECHANGE;
    public static WM ENTERSIZEMOVE;
    public static WM EXITSIZEMOVE;
    public static WM IME_SETCONTEXT;
    public static WM IME_NOTIFY;
    public static WM IME_CONTROL;
    public static WM IME_COMPOSITIONFULL;
    public static WM IME_SELECT;
    public static WM IME_CHAR;
    public static WM IME_REQUEST;
    public static WM IME_KEYDOWN;
    public static WM IME_KEYUP;
    public static WM NCMOUSELEAVE;
    public static WM TABLET_DEFBASE;
    public static WM TABLET_ADDED;
    public static WM TABLET_DELETED;
    public static WM TABLET_FLICK;
    public static WM TABLET_QUERYSYSTEMGESTURESTATUS;
    public static WM CUT;
    public static WM COPY;
    public static WM PASTE;
    public static WM CLEAR;
    public static WM UNDO;
    public static WM RENDERFORMAT;
    public static WM RENDERALLFORMATS;
    public static WM DESTROYCLIPBOARD;
    public static WM DRAWCLIPBOARD;
    public static WM PAINTCLIPBOARD;
    public static WM VSCROLLCLIPBOARD;
    public static WM SIZECLIPBOARD;
    public static WM ASKCBFORMATNAME;
    public static WM CHANGECBCHAIN;
    public static WM HSCROLLCLIPBOARD;
    public static WM QUERYNEWPALETTE;
    public static WM PALETTEISCHANGING;
    public static WM PALETTECHANGED;
    public static WM HOTKEY;
    public static WM PRINT;
    public static WM PRINTCLIENT;
    public static WM APPCOMMAND;
    public static WM THEMECHANGED;
    public static WM DWMCOMPOSITIONCHANGED;
    public static WM DWMNCRENDERINGCHANGED;
    public static WM DWMCOLORIZATIONCOLORCHANGED;
    public static WM DWMWINDOWMAXIMIZEDCHANGE;
    public static WM GETTITLEBARINFOEX;
    public static WM DWMSENDICONICTHUMBNAIL;
    public static WM DWMSENDICONICLIVEPREVIEWBITMAP;
    public static WM USER;
    public static WM TRAYMOUSEMESSAGE;
    public static WM APP;
}
internal class Standard.WNDCLASSEX : ValueType {
    public int cbSize;
    public CS style;
    public WndProc lpfnWndProc;
    public int cbClsExtra;
    public int cbWndExtra;
    public IntPtr hInstance;
    public IntPtr hIcon;
    public IntPtr hCursor;
    public IntPtr hbrBackground;
    public string lpszMenuName;
    public string lpszClassName;
    public IntPtr hIconSm;
}
internal class Standard.WndProc : MulticastDelegate {
    public WndProc(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
internal class Standard.WndProcHook : MulticastDelegate {
    public WndProcHook(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
[FlagsAttribute]
internal enum Standard.WS : Enum {
    public UInt32 value__;
    public static WS OVERLAPPED;
    public static WS POPUP;
    public static WS CHILD;
    public static WS MINIMIZE;
    public static WS VISIBLE;
    public static WS DISABLED;
    public static WS CLIPSIBLINGS;
    public static WS CLIPCHILDREN;
    public static WS MAXIMIZE;
    public static WS BORDER;
    public static WS DLGFRAME;
    public static WS VSCROLL;
    public static WS HSCROLL;
    public static WS SYSMENU;
    public static WS THICKFRAME;
    public static WS GROUP;
    public static WS TABSTOP;
    public static WS MINIMIZEBOX;
    public static WS MAXIMIZEBOX;
    public static WS CAPTION;
    public static WS TILED;
    public static WS ICONIC;
    public static WS SIZEBOX;
    public static WS TILEDWINDOW;
    public static WS OVERLAPPEDWINDOW;
    public static WS POPUPWINDOW;
    public static WS CHILDWINDOW;
}
[FlagsAttribute]
internal enum Standard.WS_EX : Enum {
    public UInt32 value__;
    public static WS_EX None;
    public static WS_EX DLGMODALFRAME;
    public static WS_EX NOPARENTNOTIFY;
    public static WS_EX TOPMOST;
    public static WS_EX ACCEPTFILES;
    public static WS_EX TRANSPARENT;
    public static WS_EX MDICHILD;
    public static WS_EX TOOLWINDOW;
    public static WS_EX WINDOWEDGE;
    public static WS_EX CLIENTEDGE;
    public static WS_EX CONTEXTHELP;
    public static WS_EX RIGHT;
    public static WS_EX LEFT;
    public static WS_EX RTLREADING;
    public static WS_EX LTRREADING;
    public static WS_EX LEFTSCROLLBAR;
    public static WS_EX RIGHTSCROLLBAR;
    public static WS_EX CONTROLPARENT;
    public static WS_EX STATICEDGE;
    public static WS_EX APPWINDOW;
    public static WS_EX LAYERED;
    public static WS_EX NOINHERITLAYOUT;
    public static WS_EX LAYOUTRTL;
    public static WS_EX COMPOSITED;
    public static WS_EX NOACTIVATE;
    public static WS_EX OVERLAPPEDWINDOW;
    public static WS_EX PALETTEWINDOW;
}
internal class Standard.WTA_OPTIONS : ValueType {
    public static UInt32 Size;
    public WTNCA dwFlags;
    public WTNCA dwMask;
}
[FlagsAttribute]
internal enum Standard.WTNCA : Enum {
    public UInt32 value__;
    public static WTNCA NODRAWCAPTION;
    public static WTNCA NODRAWICON;
    public static WTNCA NOSYSMENU;
    public static WTNCA NOMIRRORHELP;
    public static WTNCA VALIDBITS;
}
internal enum Standard.WVR : Enum {
    public int value__;
    public static WVR ALIGNTOP;
    public static WVR ALIGNLEFT;
    public static WVR ALIGNBOTTOM;
    public static WVR ALIGNRIGHT;
    public static WVR HREDRAW;
    public static WVR VREDRAW;
    public static WVR VALIDRECTS;
    public static WVR REDRAW;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
internal class Xceed.Utils.Exceptions.ThrowException : object {
    public static void ThrowArgumentException(string message, string paramName, Exception innerExcept);
    public static void ThrowArgumentOutOfRangeException(string paramName, object value, string message);
    public static void ThrowLicenseException(Type type, object instance, string message);
}
internal class Xceed.Wpf.AvalonDock.Commands.RelayCommand : object {
    private Action`1<object> _execute;
    private Predicate`1<object> _canExecute;
    public RelayCommand(Action`1<object> execute);
    public RelayCommand(Action`1<object> execute, Predicate`1<object> canExecute);
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public sealed virtual void Execute(object parameter);
}
public class Xceed.Wpf.AvalonDock.Controls.AnchorablePaneControlOverlayArea : OverlayArea {
    private LayoutAnchorablePaneControl _anchorablePaneControl;
    internal AnchorablePaneControlOverlayArea(IOverlayWindow overlayWindow, LayoutAnchorablePaneControl anchorablePaneControl);
}
internal class Xceed.Wpf.AvalonDock.Controls.AnchorablePaneDropTarget : DropTarget`1<LayoutAnchorablePaneControl> {
    private LayoutAnchorablePaneControl _targetPane;
    private int _tabIndex;
    internal AnchorablePaneDropTarget(LayoutAnchorablePaneControl paneControl, Rect detectionRect, DropTargetType type);
    internal AnchorablePaneDropTarget(LayoutAnchorablePaneControl paneControl, Rect detectionRect, DropTargetType type, int tabIndex);
    protected virtual void Drop(LayoutAnchorableFloatingWindow floatingWindow);
    public virtual Geometry GetPreviewPath(OverlayWindow overlayWindow, LayoutFloatingWindow floatingWindowModel);
}
public class Xceed.Wpf.AvalonDock.Controls.AnchorablePaneTabPanel : Panel {
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
}
public class Xceed.Wpf.AvalonDock.Controls.AnchorablePaneTitle : Control {
    private bool _isMouseDown;
    public static DependencyProperty ModelProperty;
    private static DependencyPropertyKey LayoutItemPropertyKey;
    public static DependencyProperty LayoutItemProperty;
    public LayoutAnchorable Model { get; public set; }
    public LayoutItem LayoutItem { get; }
    private static AnchorablePaneTitle();
    public LayoutAnchorable get_Model();
    public void set_Model(LayoutAnchorable value);
    private static void _OnModelChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    protected virtual void OnModelChanged(DependencyPropertyChangedEventArgs e);
    public LayoutItem get_LayoutItem();
    protected void SetLayoutItem(LayoutItem value);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    private void OnHide();
    private void OnToggleAutoHide();
}
internal class Xceed.Wpf.AvalonDock.Controls.AutoHideWindowManager : object {
    private DockingManager _manager;
    private WeakReference _currentAutohiddenAnchor;
    private DispatcherTimer _closingTimer;
    private DispatcherTimer _closeTimer;
    internal AutoHideWindowManager(DockingManager manager);
    internal void UpdateCloseTimerInterval(int newValue);
    public void ShowAutoHideWindow(LayoutAnchorControl anchor);
    public void HideAutoWindow(LayoutAnchorControl anchor);
    private void SetupClosingTimer();
    private void StartClosingTimer();
    private void StopClosingTimer();
    private void SetupCloseTimer();
    private void StartCloseTimer();
    private void StopCloseTimer();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <SetupClosingTimer>b__8_0(object s, EventArgs e);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <SetupCloseTimer>b__11_0(object s, EventArgs e);
}
internal class Xceed.Wpf.AvalonDock.Controls.BindingHelper : object {
    public static void RebindInactiveBindings(DependencyObject dependencyObject);
}
public class Xceed.Wpf.AvalonDock.Controls.ContextMenuEx : ContextMenu {
    private static ContextMenuEx();
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void OnOpened(RoutedEventArgs e);
}
internal class Xceed.Wpf.AvalonDock.Controls.DockingManagerDropTarget : DropTarget`1<DockingManager> {
    private DockingManager _manager;
    internal DockingManagerDropTarget(DockingManager manager, Rect detectionRect, DropTargetType type);
    protected virtual void Drop(LayoutAnchorableFloatingWindow floatingWindow);
    public virtual Geometry GetPreviewPath(OverlayWindow overlayWindow, LayoutFloatingWindow floatingWindowModel);
}
public class Xceed.Wpf.AvalonDock.Controls.DockingManagerOverlayArea : OverlayArea {
    private DockingManager _manager;
    internal DockingManagerOverlayArea(IOverlayWindow overlayWindow, DockingManager manager);
}
public class Xceed.Wpf.AvalonDock.Controls.DocumentPaneControlOverlayArea : OverlayArea {
    private LayoutDocumentPaneControl _documentPaneControl;
    internal DocumentPaneControlOverlayArea(IOverlayWindow overlayWindow, LayoutDocumentPaneControl documentPaneControl);
}
internal class Xceed.Wpf.AvalonDock.Controls.DocumentPaneDropAsAnchorableTarget : DropTarget`1<LayoutDocumentPaneControl> {
    private LayoutDocumentPaneControl _targetPane;
    private int _tabIndex;
    internal DocumentPaneDropAsAnchorableTarget(LayoutDocumentPaneControl paneControl, Rect detectionRect, DropTargetType type);
    internal DocumentPaneDropAsAnchorableTarget(LayoutDocumentPaneControl paneControl, Rect detectionRect, DropTargetType type, int tabIndex);
    protected virtual void Drop(LayoutAnchorableFloatingWindow floatingWindow);
    public virtual Geometry GetPreviewPath(OverlayWindow overlayWindow, LayoutFloatingWindow floatingWindowModel);
    private bool FindParentLayoutDocumentPane(ILayoutDocumentPane documentPane, LayoutDocumentPaneGroup& containerPaneGroup, LayoutPanel& containerPanel);
}
internal class Xceed.Wpf.AvalonDock.Controls.DocumentPaneDropTarget : DropTarget`1<LayoutDocumentPaneControl> {
    private LayoutDocumentPaneControl _targetPane;
    private int _tabIndex;
    internal DocumentPaneDropTarget(LayoutDocumentPaneControl paneControl, Rect detectionRect, DropTargetType type);
    internal DocumentPaneDropTarget(LayoutDocumentPaneControl paneControl, Rect detectionRect, DropTargetType type, int tabIndex);
    protected virtual void Drop(LayoutDocumentFloatingWindow floatingWindow);
    protected virtual void Drop(LayoutAnchorableFloatingWindow floatingWindow);
    public virtual Geometry GetPreviewPath(OverlayWindow overlayWindow, LayoutFloatingWindow floatingWindowModel);
}
internal class Xceed.Wpf.AvalonDock.Controls.DocumentPaneGroupDropTarget : DropTarget`1<LayoutDocumentPaneGroupControl> {
    private LayoutDocumentPaneGroupControl _targetPane;
    internal DocumentPaneGroupDropTarget(LayoutDocumentPaneGroupControl paneControl, Rect detectionRect, DropTargetType type);
    protected virtual void Drop(LayoutDocumentFloatingWindow floatingWindow);
    protected virtual void Drop(LayoutAnchorableFloatingWindow floatingWindow);
    public virtual Geometry GetPreviewPath(OverlayWindow overlayWindow, LayoutFloatingWindow floatingWindowModel);
}
public class Xceed.Wpf.AvalonDock.Controls.DocumentPaneTabPanel : Panel {
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnMouseLeave(MouseEventArgs e);
}
internal class Xceed.Wpf.AvalonDock.Controls.DragService : object {
    private DockingManager _manager;
    private LayoutFloatingWindowControl _floatingWindow;
    private List`1<IOverlayWindowHost> _overlayWindowHosts;
    private IOverlayWindowHost _currentHost;
    private IOverlayWindow _currentWindow;
    private List`1<IDropArea> _currentWindowAreas;
    private IDropTarget _currentDropTarget;
    public DragService(LayoutFloatingWindowControl floatingWindow);
    public void UpdateMouseLocation(Point dragPosition);
    public void Drop(Point dropLocation, Boolean& dropHandled);
    internal void Abort();
    private void GetOverlayWindowHosts();
    [CompilerGeneratedAttribute]
private void <Drop>b__9_0(IDropArea a);
    [CompilerGeneratedAttribute]
private void <Abort>b__10_0(IDropArea a);
    [CompilerGeneratedAttribute]
private bool <GetOverlayWindowHosts>b__11_0(Window w);
}
public class Xceed.Wpf.AvalonDock.Controls.DropArea`1 : object {
    private Rect _detectionRect;
    private DropAreaType _type;
    private T _element;
    public Rect DetectionRect { get; }
    public DropAreaType Type { get; }
    public T AreaElement { get; }
    internal DropArea`1(T areaElement, DropAreaType type);
    public sealed virtual Rect get_DetectionRect();
    public sealed virtual DropAreaType get_Type();
    public T get_AreaElement();
}
public enum Xceed.Wpf.AvalonDock.Controls.DropAreaType : Enum {
    public int value__;
    public static DropAreaType DockingManager;
    public static DropAreaType DocumentPane;
    public static DropAreaType DocumentPaneGroup;
    public static DropAreaType AnchorablePane;
}
public class Xceed.Wpf.AvalonDock.Controls.DropDownButton : ToggleButton {
    public static DependencyProperty DropDownContextMenuProperty;
    public static DependencyProperty DropDownContextMenuDataContextProperty;
    public ContextMenu DropDownContextMenu { get; public set; }
    public object DropDownContextMenuDataContext { get; public set; }
    private static DropDownButton();
    public ContextMenu get_DropDownContextMenu();
    public void set_DropDownContextMenu(ContextMenu value);
    private static void OnDropDownContextMenuChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDropDownContextMenuChanged(DependencyPropertyChangedEventArgs e);
    public object get_DropDownContextMenuDataContext();
    public void set_DropDownContextMenuDataContext(object value);
    protected virtual void OnClick();
    private void OnContextMenuClosed(object sender, RoutedEventArgs e);
    private void DropDownButton_Unloaded(object sender, RoutedEventArgs e);
}
public class Xceed.Wpf.AvalonDock.Controls.DropDownControlArea : UserControl {
    public static DependencyProperty DropDownContextMenuProperty;
    public static DependencyProperty DropDownContextMenuDataContextProperty;
    public ContextMenu DropDownContextMenu { get; public set; }
    public object DropDownContextMenuDataContext { get; public set; }
    private static DropDownControlArea();
    public ContextMenu get_DropDownContextMenu();
    public void set_DropDownContextMenu(ContextMenu value);
    public object get_DropDownContextMenuDataContext();
    public void set_DropDownContextMenuDataContext(object value);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
}
internal abstract class Xceed.Wpf.AvalonDock.Controls.DropTarget`1 : DropTargetBase {
    private Rect[] _detectionRect;
    private T _targetElement;
    private DropTargetType _type;
    public Rect[] DetectionRects { get; }
    public T TargetElement { get; }
    public DropTargetType Type { get; }
    protected DropTarget`1(T targetElement, Rect detectionRect, DropTargetType type);
    protected DropTarget`1(T targetElement, IEnumerable`1<Rect> detectionRects, DropTargetType type);
    public Rect[] get_DetectionRects();
    public T get_TargetElement();
    public sealed virtual DropTargetType get_Type();
    protected virtual void Drop(LayoutAnchorableFloatingWindow floatingWindow);
    protected virtual void Drop(LayoutDocumentFloatingWindow floatingWindow);
    public sealed virtual void Drop(LayoutFloatingWindow floatingWindow);
    public virtual bool HitTest(Point dragPoint);
    public abstract virtual Geometry GetPreviewPath(OverlayWindow overlayWindow, LayoutFloatingWindow floatingWindow);
    public sealed virtual void DragEnter();
    public sealed virtual void DragLeave();
}
internal abstract class Xceed.Wpf.AvalonDock.Controls.DropTargetBase : DependencyObject {
    public static DependencyProperty IsDraggingOverProperty;
    private static DropTargetBase();
    public static bool GetIsDraggingOver(DependencyObject d);
    public static void SetIsDraggingOver(DependencyObject d, bool value);
}
public enum Xceed.Wpf.AvalonDock.Controls.DropTargetType : Enum {
    public int value__;
    public static DropTargetType DockingManagerDockLeft;
    public static DropTargetType DockingManagerDockTop;
    public static DropTargetType DockingManagerDockRight;
    public static DropTargetType DockingManagerDockBottom;
    public static DropTargetType DocumentPaneDockLeft;
    public static DropTargetType DocumentPaneDockTop;
    public static DropTargetType DocumentPaneDockRight;
    public static DropTargetType DocumentPaneDockBottom;
    public static DropTargetType DocumentPaneDockInside;
    public static DropTargetType DocumentPaneGroupDockInside;
    public static DropTargetType AnchorablePaneDockLeft;
    public static DropTargetType AnchorablePaneDockTop;
    public static DropTargetType AnchorablePaneDockRight;
    public static DropTargetType AnchorablePaneDockBottom;
    public static DropTargetType AnchorablePaneDockInside;
    public static DropTargetType DocumentPaneDockAsAnchorableLeft;
    public static DropTargetType DocumentPaneDockAsAnchorableTop;
    public static DropTargetType DocumentPaneDockAsAnchorableRight;
    public static DropTargetType DocumentPaneDockAsAnchorableBottom;
}
[ExtensionAttribute]
public static class Xceed.Wpf.AvalonDock.Controls.Extentions : object {
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.Controls.Extentions/<FindVisualChildren>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> FindVisualChildren(DependencyObject depObj);
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.Controls.Extentions/<FindLogicalChildren>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> FindLogicalChildren(DependencyObject depObj);
    [ExtensionAttribute]
public static DependencyObject FindVisualTreeRoot(DependencyObject initial);
    [ExtensionAttribute]
public static T FindVisualAncestor(DependencyObject dependencyObject);
    [ExtensionAttribute]
public static T FindLogicalAncestor(DependencyObject dependencyObject);
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.Controls.Extentions/<FindLogicalAncestorsAndSelf>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<DependencyObject> FindLogicalAncestorsAndSelf(DependencyObject self);
}
internal class Xceed.Wpf.AvalonDock.Controls.FocusChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IntPtr <GotFocusWinHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <LostFocusWinHandle>k__BackingField;
    public IntPtr GotFocusWinHandle { get; private set; }
    public IntPtr LostFocusWinHandle { get; private set; }
    public FocusChangeEventArgs(IntPtr gotFocusWinHandle, IntPtr lostFocusWinHandle);
    [CompilerGeneratedAttribute]
public IntPtr get_GotFocusWinHandle();
    [CompilerGeneratedAttribute]
private void set_GotFocusWinHandle(IntPtr value);
    [CompilerGeneratedAttribute]
public IntPtr get_LostFocusWinHandle();
    [CompilerGeneratedAttribute]
private void set_LostFocusWinHandle(IntPtr value);
}
internal static class Xceed.Wpf.AvalonDock.Controls.FocusElementManager : object {
    private static List`1<DockingManager> _managers;
    private static FullWeakDictionary`2<ILayoutElement, IInputElement> _modelFocusedElement;
    private static WeakDictionary`2<ILayoutElement, IntPtr> _modelFocusedWindowHandle;
    private static WeakReference _lastFocusedElement;
    private static WindowHookHandler _windowHandler;
    private static DispatcherOperation _setFocusAsyncOperation;
    private static WeakReference _lastFocusedElementBeforeEnterMenuMode;
    private static FocusElementManager();
    internal static void SetupFocusManagement(DockingManager manager);
    internal static void FinalizeFocusManagement(DockingManager manager);
    internal static IInputElement GetLastFocusedElement(ILayoutElement model);
    internal static IntPtr GetLastWindowHandle(ILayoutElement model);
    internal static void SetFocusOnLastElement(ILayoutElement model);
    private static void Current_Exit(object sender, ExitEventArgs e);
    private static void manager_PreviewGotKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    private static void WindowFocusChanging(object sender, FocusChangeEventArgs e);
    private static void WindowActivating(object sender, WindowActivateEventArgs e);
    private static void InputManager_EnterMenuMode(object sender, EventArgs e);
    private static void InputManager_LeaveMenuMode(object sender, EventArgs e);
}
[DefaultMemberAttribute("Item")]
internal class Xceed.Wpf.AvalonDock.Controls.FullWeakDictionary`2 : object {
    private List`1<WeakReference> _keys;
    private List`1<WeakReference> _values;
    public V Item { get; public set; }
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool ContainsKey(K key);
    public void SetValue(K key, V value);
    public bool GetValue(K key, V& value);
    private void CollectGarbage();
}
public interface Xceed.Wpf.AvalonDock.Controls.IDropArea {
    public Rect DetectionRect { get; }
    public DropAreaType Type { get; }
    public abstract virtual Rect get_DetectionRect();
    public abstract virtual DropAreaType get_Type();
}
internal interface Xceed.Wpf.AvalonDock.Controls.IDropTarget {
    public DropTargetType Type { get; }
    public abstract virtual DropTargetType get_Type();
    public abstract virtual Geometry GetPreviewPath(OverlayWindow overlayWindow, LayoutFloatingWindow floatingWindow);
    public abstract virtual bool HitTest(Point dragPoint);
    public abstract virtual void Drop(LayoutFloatingWindow floatingWindow);
    public abstract virtual void DragEnter();
    public abstract virtual void DragLeave();
}
internal interface Xceed.Wpf.AvalonDock.Controls.IOverlayWindow {
    public abstract virtual IEnumerable`1<IDropTarget> GetTargets();
    public abstract virtual void DragEnter(LayoutFloatingWindowControl floatingWindow);
    public abstract virtual void DragLeave(LayoutFloatingWindowControl floatingWindow);
    public abstract virtual void DragEnter(IDropArea area);
    public abstract virtual void DragLeave(IDropArea area);
    public abstract virtual void DragEnter(IDropTarget target);
    public abstract virtual void DragLeave(IDropTarget target);
    public abstract virtual void DragDrop(IDropTarget target);
}
internal interface Xceed.Wpf.AvalonDock.Controls.IOverlayWindowArea {
    public Rect ScreenDetectionArea { get; }
    public abstract virtual Rect get_ScreenDetectionArea();
}
internal interface Xceed.Wpf.AvalonDock.Controls.IOverlayWindowDropTarget {
    public Rect ScreenDetectionArea { get; }
    public OverlayWindowDropTargetType Type { get; }
    public abstract virtual Rect get_ScreenDetectionArea();
    public abstract virtual OverlayWindowDropTargetType get_Type();
}
internal interface Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost {
    public DockingManager Manager { get; }
    public abstract virtual DockingManager get_Manager();
    public abstract virtual bool HitTest(Point dragPoint);
    public abstract virtual IOverlayWindow ShowOverlayWindow(LayoutFloatingWindowControl draggingWindow);
    public abstract virtual void HideOverlayWindow();
    public abstract virtual IEnumerable`1<IDropArea> GetDropAreas(LayoutFloatingWindowControl draggingWindow);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAnchorableControl : Control {
    public static DependencyProperty ModelProperty;
    private static DependencyPropertyKey LayoutItemPropertyKey;
    public static DependencyProperty LayoutItemProperty;
    public LayoutAnchorable Model { get; public set; }
    public LayoutItem LayoutItem { get; }
    private static LayoutAnchorableControl();
    public LayoutAnchorable get_Model();
    public void set_Model(LayoutAnchorable value);
    private static void OnModelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnModelChanged(DependencyPropertyChangedEventArgs e);
    private void Model_PropertyChanged(object sender, PropertyChangedEventArgs e);
    public LayoutItem get_LayoutItem();
    protected void SetLayoutItem(LayoutItem value);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAnchorableFloatingWindowControl : LayoutFloatingWindowControl {
    private LayoutAnchorableFloatingWindow _model;
    private OverlayWindow _overlayWindow;
    private List`1<IDropArea> _dropAreas;
    public static DependencyProperty SingleContentLayoutItemProperty;
    [CompilerGeneratedAttribute]
private ICommand <HideWindowCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommand <CloseWindowCommand>k__BackingField;
    public LayoutItem SingleContentLayoutItem { get; public set; }
    public ILayoutElement Model { get; }
    public ICommand HideWindowCommand { get; private set; }
    public ICommand CloseWindowCommand { get; private set; }
    private DockingManager Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.Manager { get; }
    private static LayoutAnchorableFloatingWindowControl();
    internal LayoutAnchorableFloatingWindowControl(LayoutAnchorableFloatingWindow model, bool isContentImmutable);
    internal LayoutAnchorableFloatingWindowControl(LayoutAnchorableFloatingWindow model);
    public LayoutItem get_SingleContentLayoutItem();
    public void set_SingleContentLayoutItem(LayoutItem value);
    private static void OnSingleContentLayoutItemChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSingleContentLayoutItemChanged(DependencyPropertyChangedEventArgs e);
    public virtual ILayoutElement get_Model();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void OnClosed(EventArgs e);
    protected virtual IntPtr FilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    internal virtual void UpdateThemeResources(Theme oldTheme);
    protected virtual bool CanClose(object parameter);
    protected virtual bool CanHide(object parameter);
    protected virtual void DoHide();
    private void _model_PropertyChanged(object sender, PropertyChangedEventArgs e);
    private void CreateOverlayWindow();
    private bool OpenContextMenu();
    private bool IsContextMenuOpen();
    private void LayoutAnchorableFloatingWindowControl_IsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
public ICommand get_HideWindowCommand();
    [CompilerGeneratedAttribute]
private void set_HideWindowCommand(ICommand value);
    private bool CanExecuteHideWindowCommand(object parameter);
    private void OnExecuteHideWindowCommand(object parameter);
    [CompilerGeneratedAttribute]
public ICommand get_CloseWindowCommand();
    [CompilerGeneratedAttribute]
private void set_CloseWindowCommand(ICommand value);
    private bool CanExecuteCloseWindowCommand(object parameter);
    private void OnExecuteCloseWindowCommand(object parameter);
    private sealed virtual override bool Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.HitTest(Point dragPoint);
    private sealed virtual override DockingManager Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.get_Manager();
    private sealed virtual override IOverlayWindow Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.ShowOverlayWindow(LayoutFloatingWindowControl draggingWindow);
    private sealed virtual override void Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.HideOverlayWindow();
    private sealed virtual override IEnumerable`1<IDropArea> Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.GetDropAreas(LayoutFloatingWindowControl draggingWindow);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(object p);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__4_1(object p);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_2(object p);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__4_3(object p);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAnchorableItem : LayoutItem {
    private LayoutAnchorable _anchorable;
    private ICommand _defaultHideCommand;
    private ICommand _defaultAutoHideCommand;
    private ICommand _defaultDockCommand;
    private ReentrantFlag _visibilityReentrantFlag;
    public static DependencyProperty HideCommandProperty;
    public static DependencyProperty AutoHideCommandProperty;
    public static DependencyProperty DockCommandProperty;
    public static DependencyProperty CanHideProperty;
    public ICommand HideCommand { get; public set; }
    public ICommand AutoHideCommand { get; public set; }
    public ICommand DockCommand { get; public set; }
    public bool CanHide { get; public set; }
    private static LayoutAnchorableItem();
    public ICommand get_HideCommand();
    public void set_HideCommand(ICommand value);
    private static void OnHideCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHideCommandChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceHideCommandValue(DependencyObject d, object value);
    private bool CanExecuteHideCommand(object parameter);
    private void ExecuteHideCommand(object parameter);
    public ICommand get_AutoHideCommand();
    public void set_AutoHideCommand(ICommand value);
    private static void OnAutoHideCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAutoHideCommandChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceAutoHideCommandValue(DependencyObject d, object value);
    private bool CanExecuteAutoHideCommand(object parameter);
    private void ExecuteAutoHideCommand(object parameter);
    public ICommand get_DockCommand();
    public void set_DockCommand(ICommand value);
    private static void OnDockCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDockCommandChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceDockCommandValue(DependencyObject d, object value);
    private bool CanExecuteDockCommand(object parameter);
    private void ExecuteDockCommand(object parameter);
    public bool get_CanHide();
    public void set_CanHide(bool value);
    private static void OnCanHideChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCanHideChanged(DependencyPropertyChangedEventArgs e);
    internal virtual void Attach(LayoutContent model);
    internal virtual void Detach();
    protected virtual bool CanExecuteDockAsDocumentCommand();
    protected virtual void Close();
    protected virtual void InitDefaultCommands();
    protected virtual void ClearDefaultCommands();
    protected virtual void ClearDefaultBindings();
    protected virtual void SetDefaultBindings();
    protected virtual void OnVisibilityChanged();
    private void _anchorable_IsVisibleChanged(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__43_0(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__43_1(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__43_2(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__43_3(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__43_4(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__43_5(object p);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAnchorablePaneControl : LayoutCachePaneControl {
    private LayoutAnchorablePane _model;
    public ILayoutElement Model { get; }
    private static LayoutAnchorablePaneControl();
    public LayoutAnchorablePaneControl(LayoutAnchorablePane model);
    public sealed virtual ILayoutElement get_Model();
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    private void OnLayoutUpdated(object sender, EventArgs e);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAnchorablePaneGroupControl : LayoutGridControl`1<ILayoutAnchorablePane> {
    private LayoutAnchorablePaneGroup _model;
    internal LayoutAnchorablePaneGroupControl(LayoutAnchorablePaneGroup model);
    protected virtual void OnFixChildrenDockLengths();
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAnchorableTabItem : Control {
    private static double MinDragBuffer;
    private static double MaxDragBuffer;
    private bool _isMouseDown;
    private Point _mouseDownPoint;
    private double _mouseLastChangePositionX;
    private Rect _parentAnchorableTabPanelScreenArea;
    private List`1<Rect> _otherTabsScreenArea;
    private List`1<TabItem> _otherTabs;
    private AnchorablePaneTabPanel _parentAnchorableTabPanel;
    private double _dragBuffer;
    public static DependencyProperty ModelProperty;
    private static DependencyPropertyKey LayoutItemPropertyKey;
    public static DependencyProperty LayoutItemProperty;
    public LayoutContent Model { get; public set; }
    public LayoutItem LayoutItem { get; }
    private static LayoutAnchorableTabItem();
    public LayoutContent get_Model();
    public void set_Model(LayoutContent value);
    private static void OnModelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnModelChanged(DependencyPropertyChangedEventArgs e);
    public LayoutItem get_LayoutItem();
    protected void SetLayoutItem(LayoutItem value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    private void UpdateDragDetails();
    [CompilerGeneratedAttribute]
private Rect <UpdateDragDetails>b__28_1(TabItem ti);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAnchorControl : Control {
    private LayoutAnchorable _model;
    private DispatcherTimer _openUpTimer;
    private static DependencyPropertyKey SidePropertyKey;
    public static DependencyProperty SideProperty;
    public ILayoutElement Model { get; }
    public AnchorSide Side { get; }
    private static LayoutAnchorControl();
    internal LayoutAnchorControl(LayoutAnchorable model);
    public sealed virtual ILayoutElement get_Model();
    public AnchorSide get_Side();
    protected void SetSide(AnchorSide value);
    private void _model_IsSelectedChanged(object sender, EventArgs e);
    private void _model_IsActiveChanged(object sender, EventArgs e);
    private void _openUpTimer_Tick(object sender, EventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAnchorGroupControl : Control {
    private ObservableCollection`1<LayoutAnchorControl> _childViews;
    private LayoutAnchorGroup _model;
    public ObservableCollection`1<LayoutAnchorControl> Children { get; }
    public ILayoutElement Model { get; }
    private static LayoutAnchorGroupControl();
    internal LayoutAnchorGroupControl(LayoutAnchorGroup model);
    public ObservableCollection`1<LayoutAnchorControl> get_Children();
    public sealed virtual ILayoutElement get_Model();
    private void CreateChildrenViews();
    private void OnModelChildrenCollectionChanged(NotifyCollectionChangedEventArgs e);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object s, NotifyCollectionChangedEventArgs e);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAnchorSideControl : Control {
    private LayoutAnchorSide _model;
    private ObservableCollection`1<LayoutAnchorGroupControl> _childViews;
    private static DependencyPropertyKey IsLeftSidePropertyKey;
    public static DependencyProperty IsLeftSideProperty;
    private static DependencyPropertyKey IsTopSidePropertyKey;
    public static DependencyProperty IsTopSideProperty;
    private static DependencyPropertyKey IsRightSidePropertyKey;
    public static DependencyProperty IsRightSideProperty;
    private static DependencyPropertyKey IsBottomSidePropertyKey;
    public static DependencyProperty IsBottomSideProperty;
    public ILayoutElement Model { get; }
    public ObservableCollection`1<LayoutAnchorGroupControl> Children { get; }
    public bool IsLeftSide { get; }
    public bool IsTopSide { get; }
    public bool IsRightSide { get; }
    public bool IsBottomSide { get; }
    private static LayoutAnchorSideControl();
    internal LayoutAnchorSideControl(LayoutAnchorSide model);
    public sealed virtual ILayoutElement get_Model();
    public ObservableCollection`1<LayoutAnchorGroupControl> get_Children();
    public bool get_IsLeftSide();
    protected void SetIsLeftSide(bool value);
    public bool get_IsTopSide();
    protected void SetIsTopSide(bool value);
    public bool get_IsRightSide();
    protected void SetIsRightSide(bool value);
    public bool get_IsBottomSide();
    protected void SetIsBottomSide(bool value);
    private void CreateChildrenViews();
    private void OnModelChildrenCollectionChanged(NotifyCollectionChangedEventArgs e);
    private void UpdateSide();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object s, NotifyCollectionChangedEventArgs e);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutAutoHideWindowControl : HwndHost {
    internal LayoutAnchorableControl _internalHost;
    private LayoutAnchorControl _anchor;
    private LayoutAnchorable _model;
    private HwndSource _internalHwndSource;
    private IntPtr parentWindowHandle;
    private ContentPresenter _internalHostPresenter;
    private Grid _internalGrid;
    private AnchorSide _side;
    private LayoutGridResizerControl _resizer;
    private DockingManager _manager;
    private Border _resizerGhost;
    private Window _resizerWindowHost;
    private Vector _initialStartPoint;
    public static DependencyProperty AnchorableStyleProperty;
    public static DependencyProperty BackgroundProperty;
    [CompilerGeneratedAttribute]
private bool <IsResizing>k__BackingField;
    public Style AnchorableStyle { get; public set; }
    public Brush Background { get; public set; }
    public ILayoutElement Model { get; }
    internal bool IsResizing { get; private set; }
    protected IEnumerator LogicalChildren { get; }
    internal bool IsWin32MouseOver { get; }
    private static LayoutAutoHideWindowControl();
    public Style get_AnchorableStyle();
    public void set_AnchorableStyle(Style value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public sealed virtual ILayoutElement get_Model();
    [CompilerGeneratedAttribute]
internal bool get_IsResizing();
    [CompilerGeneratedAttribute]
private void set_IsResizing(bool value);
    protected virtual HandleRef BuildWindowCore(HandleRef hwndParent);
    protected virtual void DestroyWindowCore(HandleRef hwnd);
    protected virtual bool HasFocusWithinCore();
    protected virtual IEnumerator get_LogicalChildren();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    internal void Show(LayoutAnchorControl anchor);
    internal void Hide();
    internal bool get_IsWin32MouseOver();
    private void _model_PropertyChanged(object sender, PropertyChangedEventArgs e);
    private void CreateInternalGrid();
    private void RemoveInternalGrid();
    private void ShowResizerOverlayWindow(LayoutGridResizerControl splitter);
    private void HideResizerOverlayWindow();
    private void OnResizerDragCompleted(object sender, DragCompletedEventArgs e);
    private void OnResizerDragDelta(object sender, DragDeltaEventArgs e);
    private void OnResizerDragStarted(object sender, DragStartedEventArgs e);
    [CompilerGeneratedAttribute]
private bool <get_IsWin32MouseOver>b__39_0(LayoutAnchorControl c);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutCachePaneControl : TabControl {
    private static LayoutCachePaneControl();
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutDocumentControl : Control {
    public static DependencyProperty ModelProperty;
    private static DependencyPropertyKey LayoutItemPropertyKey;
    public static DependencyProperty LayoutItemProperty;
    public LayoutContent Model { get; public set; }
    public LayoutItem LayoutItem { get; }
    private static LayoutDocumentControl();
    public LayoutContent get_Model();
    public void set_Model(LayoutContent value);
    private static void OnModelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnModelChanged(DependencyPropertyChangedEventArgs e);
    private void Model_PropertyChanged(object sender, PropertyChangedEventArgs e);
    public LayoutItem get_LayoutItem();
    protected void SetLayoutItem(LayoutItem value);
    protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    internal void SetResourcesFromObject(FrameworkElement current);
    private void SetIsActive();
    [CompilerGeneratedAttribute]
private void <SetResourcesFromObject>b__16_0(DictionaryEntry x);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutDocumentFloatingWindowControl : LayoutFloatingWindowControl {
    private LayoutDocumentFloatingWindow _model;
    public LayoutItem RootDocumentLayoutItem { get; }
    public ILayoutElement Model { get; }
    private static LayoutDocumentFloatingWindowControl();
    internal LayoutDocumentFloatingWindowControl(LayoutDocumentFloatingWindow model, bool isContentImmutable);
    internal LayoutDocumentFloatingWindowControl(LayoutDocumentFloatingWindow model);
    public LayoutItem get_RootDocumentLayoutItem();
    public virtual ILayoutElement get_Model();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual IntPtr FilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    protected virtual void OnClosed(EventArgs e);
    protected virtual bool CanClose(object parameter);
    private void _model_RootDocumentChanged(object sender, EventArgs e);
    private bool OpenContextMenu();
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutDocumentItem : LayoutItem {
    private LayoutDocument _document;
    public static DependencyProperty DescriptionProperty;
    public string Description { get; public set; }
    private static LayoutDocumentItem();
    public string get_Description();
    public void set_Description(string value);
    private static void OnDescriptionChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDescriptionChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void Close();
    protected virtual void OnVisibilityChanged();
    internal virtual void Attach(LayoutContent model);
    internal virtual void Detach();
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutDocumentPaneControl : LayoutCachePaneControl {
    private List`1<object> _logicalChildren;
    private LayoutDocumentPane _model;
    public ILayoutElement Model { get; }
    protected IEnumerator LogicalChildren { get; }
    private static LayoutDocumentPaneControl();
    internal LayoutDocumentPaneControl(LayoutDocumentPane model);
    public sealed virtual ILayoutElement get_Model();
    protected virtual IEnumerator get_LogicalChildren();
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    private void OnLayoutUpdated(object sender, EventArgs e);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutDocumentPaneGroupControl : LayoutGridControl`1<ILayoutDocumentPane> {
    private LayoutDocumentPaneGroup _model;
    internal LayoutDocumentPaneGroupControl(LayoutDocumentPaneGroup model);
    protected virtual void OnFixChildrenDockLengths();
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutDocumentTabItem : Control {
    private static double MinDragBuffer;
    private static double MaxDragBuffer;
    private List`1<Rect> _otherTabsScreenArea;
    private List`1<TabItem> _otherTabs;
    private Rect _parentDocumentTabPanelScreenArea;
    private Panel _parentTabPanel;
    private bool _isMouseDown;
    private Point _mouseDownPoint;
    private double _mouseLastChangePositionX;
    private double _dragBuffer;
    public static DependencyProperty ModelProperty;
    private static DependencyPropertyKey LayoutItemPropertyKey;
    public static DependencyProperty LayoutItemProperty;
    public LayoutContent Model { get; public set; }
    public LayoutItem LayoutItem { get; }
    private static LayoutDocumentTabItem();
    public LayoutContent get_Model();
    public void set_Model(LayoutContent value);
    private static void OnModelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnModelChanged(DependencyPropertyChangedEventArgs e);
    public LayoutItem get_LayoutItem();
    protected void SetLayoutItem(LayoutItem value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    private void UpdateDragDetails();
    private Panel GetParentPanel();
    private void StartDraggingFloatingWindowForContent();
    [CompilerGeneratedAttribute]
private Rect <UpdateDragDetails>b__29_1(TabItem ti);
}
public abstract class Xceed.Wpf.AvalonDock.Controls.LayoutFloatingWindowControl : Window {
    private ResourceDictionary currentThemeResourceDictionary;
    private bool _isInternalChange;
    private ILayoutElement _model;
    private bool _attachDrag;
    private HwndSource _hwndSrc;
    private HwndSourceHook _hwndSrcHook;
    private DragService _dragService;
    private bool _internalCloseFlag;
    private bool _isClosing;
    public static DependencyProperty IsContentImmutableProperty;
    private static DependencyPropertyKey IsDraggingPropertyKey;
    public static DependencyProperty IsDraggingProperty;
    [CompilerGeneratedAttribute]
private bool <KeepContentVisibleOnClose>k__BackingField;
    public static DependencyProperty IsMaximizedProperty;
    public static DependencyProperty ResizeBorderThicknessProperty;
    public ILayoutElement Model { get; }
    public bool IsContentImmutable { get; private set; }
    public bool IsDragging { get; }
    protected bool CloseInitiatedByUser { get; }
    internal bool KeepContentVisibleOnClose { get; internal set; }
    public bool IsMaximized { get; private set; }
    public Thickness ResizeBorderThickness { get; public set; }
    private static LayoutFloatingWindowControl();
    protected LayoutFloatingWindowControl(ILayoutElement model);
    protected LayoutFloatingWindowControl(ILayoutElement model, bool isContentImmutable);
    public abstract virtual ILayoutElement get_Model();
    public bool get_IsContentImmutable();
    private void set_IsContentImmutable(bool value);
    public bool get_IsDragging();
    protected void SetIsDragging(bool value);
    private static void OnIsDraggingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsDraggingChanged(DependencyPropertyChangedEventArgs e);
    protected bool get_CloseInitiatedByUser();
    [CompilerGeneratedAttribute]
internal bool get_KeepContentVisibleOnClose();
    [CompilerGeneratedAttribute]
internal void set_KeepContentVisibleOnClose(bool value);
    public bool get_IsMaximized();
    private void set_IsMaximized(bool value);
    protected virtual void OnStateChanged(EventArgs e);
    public Thickness get_ResizeBorderThickness();
    public void set_ResizeBorderThickness(Thickness value);
    protected virtual void OnClosing(CancelEventArgs e);
    protected virtual void OnClosed(EventArgs e);
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    internal virtual void UpdateThemeResources(Theme oldTheme);
    protected virtual bool CanClose(object parameter);
    protected virtual bool CanHide(object parameter);
    protected virtual void DoHide();
    internal void AttachDrag(bool onActivated);
    protected virtual IntPtr FilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    internal void InternalClose();
    internal void BringFocusOnDockingManager();
    internal bool IsClosing();
    private static object CoerceContentValue(DependencyObject sender, object content);
    private void LayoutFloatingWindowControl_IsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnLoaded(object sender, RoutedEventArgs e);
    private void OnUnloaded(object sender, RoutedEventArgs e);
    private void OnActivated(object sender, EventArgs e);
    private void UpdatePositionAndSizeOfPanes();
    private void UpdateMaximizedState(bool isMaximized);
    private void UpdateDragPosition();
    [CompilerGeneratedAttribute]
private void <InternalClose>b__51_0();
}
public abstract class Xceed.Wpf.AvalonDock.Controls.LayoutGridControl`1 : Grid {
    private LayoutPositionableGroup`1<T> _model;
    private Orientation _orientation;
    private bool _initialized;
    private Nullable`1<ChildrenTreeChange> _asyncRefreshCalled;
    private ReentrantFlag _fixingChildrenDockLengths;
    private Border _resizerGhost;
    private Window _resizerWindowHost;
    private Vector _initialStartPoint;
    public ILayoutElement Model { get; }
    public Orientation Orientation { get; }
    private bool AsyncRefreshCalled { get; }
    private static LayoutGridControl`1();
    internal LayoutGridControl`1(LayoutPositionableGroup`1<T> model, Orientation orientation);
    public sealed virtual ILayoutElement get_Model();
    public Orientation get_Orientation();
    private bool get_AsyncRefreshCalled();
    protected virtual void OnInitialized(EventArgs e);
    protected void FixChildrenDockLengths();
    protected abstract virtual void OnFixChildrenDockLengths();
    private void OnLayoutUpdated(object sender, EventArgs e);
    private void UpdateChildren();
    private void AttachPropertyChangeHandler();
    private void DetachPropertChangeHandler();
    private void OnChildModelPropertyChanged(object sender, PropertyChangedEventArgs e);
    private void UpdateRowColDefinitions();
    private void CreateSplitters();
    private void DetachOldSplitters();
    private void AttachNewSplitters();
    private void OnSplitterDragStarted(object sender, DragStartedEventArgs e);
    private void OnSplitterDragDelta(object sender, DragDeltaEventArgs e);
    private void OnSplitterDragCompleted(object sender, DragCompletedEventArgs e);
    private FrameworkElement GetNextVisibleChild(int index);
    private void ShowResizerOverlayWindow(LayoutGridResizerControl splitter);
    private void HideResizerOverlayWindow();
    [CompilerGeneratedAttribute]
private void <OnInitialized>b__16_0(object s, ChildrenTreeChangedEventArgs args);
    [CompilerGeneratedAttribute]
private void <OnInitialized>b__16_1();
    [CompilerGeneratedAttribute]
private void <ShowResizerOverlayWindow>b__32_0(object s, RoutedEventArgs e);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutGridResizerControl : Thumb {
    public static DependencyProperty BackgroundWhileDraggingProperty;
    public static DependencyProperty OpacityWhileDraggingProperty;
    public Brush BackgroundWhileDragging { get; public set; }
    public double OpacityWhileDragging { get; public set; }
    private static LayoutGridResizerControl();
    public Brush get_BackgroundWhileDragging();
    public void set_BackgroundWhileDragging(Brush value);
    public double get_OpacityWhileDragging();
    public void set_OpacityWhileDragging(double value);
}
public abstract class Xceed.Wpf.AvalonDock.Controls.LayoutItem : FrameworkElement {
    private ICommand _defaultCloseCommand;
    private ICommand _defaultFloatCommand;
    private ICommand _defaultDockAsDocumentCommand;
    private ICommand _defaultCloseAllButThisCommand;
    private ICommand _defaultCloseAllCommand;
    private ICommand _defaultActivateCommand;
    private ICommand _defaultNewVerticalTabGroupCommand;
    private ICommand _defaultNewHorizontalTabGroupCommand;
    private ICommand _defaultMoveToNextTabGroupCommand;
    private ICommand _defaultMoveToPreviousTabGroupCommand;
    internal ContentPresenter _view;
    private ReentrantFlag _isSelectedReentrantFlag;
    private ReentrantFlag _isActiveReentrantFlag;
    [CompilerGeneratedAttribute]
private LayoutContent <LayoutElement>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Model>k__BackingField;
    public static DependencyProperty TitleProperty;
    public static DependencyProperty IconSourceProperty;
    public static DependencyProperty ContentIdProperty;
    public static DependencyProperty IsSelectedProperty;
    public static DependencyProperty IsActiveProperty;
    public static DependencyProperty CanCloseProperty;
    public static DependencyProperty CanFloatProperty;
    public static DependencyProperty CloseCommandProperty;
    public static DependencyProperty FloatCommandProperty;
    public static DependencyProperty DockAsDocumentCommandProperty;
    public static DependencyProperty CloseAllButThisCommandProperty;
    public static DependencyProperty CloseAllCommandProperty;
    public static DependencyProperty ActivateCommandProperty;
    public static DependencyProperty NewVerticalTabGroupCommandProperty;
    public static DependencyProperty NewHorizontalTabGroupCommandProperty;
    public static DependencyProperty MoveToNextTabGroupCommandProperty;
    public static DependencyProperty MoveToPreviousTabGroupCommandProperty;
    public LayoutContent LayoutElement { get; private set; }
    public object Model { get; private set; }
    public ContentPresenter View { get; }
    public string Title { get; public set; }
    public ImageSource IconSource { get; public set; }
    public string ContentId { get; public set; }
    public bool IsSelected { get; public set; }
    public bool IsActive { get; public set; }
    public bool CanClose { get; public set; }
    public bool CanFloat { get; public set; }
    public ICommand CloseCommand { get; public set; }
    public ICommand FloatCommand { get; public set; }
    public ICommand DockAsDocumentCommand { get; public set; }
    public ICommand CloseAllButThisCommand { get; public set; }
    public ICommand CloseAllCommand { get; public set; }
    public ICommand ActivateCommand { get; public set; }
    public ICommand NewVerticalTabGroupCommand { get; public set; }
    public ICommand NewHorizontalTabGroupCommand { get; public set; }
    public ICommand MoveToNextTabGroupCommand { get; public set; }
    public ICommand MoveToPreviousTabGroupCommand { get; public set; }
    private static LayoutItem();
    [CompilerGeneratedAttribute]
public LayoutContent get_LayoutElement();
    [CompilerGeneratedAttribute]
private void set_LayoutElement(LayoutContent value);
    [CompilerGeneratedAttribute]
public object get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(object value);
    public ContentPresenter get_View();
    public string get_Title();
    public void set_Title(string value);
    private static void OnTitleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTitleChanged(DependencyPropertyChangedEventArgs e);
    public ImageSource get_IconSource();
    public void set_IconSource(ImageSource value);
    private static void OnIconSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIconSourceChanged(DependencyPropertyChangedEventArgs e);
    public string get_ContentId();
    public void set_ContentId(string value);
    private static void OnContentIdChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnContentIdChanged(DependencyPropertyChangedEventArgs e);
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    private static void OnIsSelectedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsSelectedChanged(DependencyPropertyChangedEventArgs e);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    private static void OnIsActiveChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsActiveChanged(DependencyPropertyChangedEventArgs e);
    public bool get_CanClose();
    public void set_CanClose(bool value);
    private static void OnCanCloseChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCanCloseChanged(DependencyPropertyChangedEventArgs e);
    public bool get_CanFloat();
    public void set_CanFloat(bool value);
    private static void OnCanFloatChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCanFloatChanged(DependencyPropertyChangedEventArgs e);
    public ICommand get_CloseCommand();
    public void set_CloseCommand(ICommand value);
    private static void OnCloseCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCloseCommandChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceCloseCommandValue(DependencyObject d, object value);
    private bool CanExecuteCloseCommand(object parameter);
    private void ExecuteCloseCommand(object parameter);
    protected abstract virtual void Close();
    public ICommand get_FloatCommand();
    public void set_FloatCommand(ICommand value);
    private static void OnFloatCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnFloatCommandChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceFloatCommandValue(DependencyObject d, object value);
    private bool CanExecuteFloatCommand(object anchorable);
    private void ExecuteFloatCommand(object parameter);
    protected virtual void Float();
    public ICommand get_DockAsDocumentCommand();
    public void set_DockAsDocumentCommand(ICommand value);
    private static void OnDockAsDocumentCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDockAsDocumentCommandChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceDockAsDocumentCommandValue(DependencyObject d, object value);
    protected virtual bool CanExecuteDockAsDocumentCommand();
    private bool CanExecuteDockAsDocumentCommand(object parameter);
    private void ExecuteDockAsDocumentCommand(object parameter);
    public ICommand get_CloseAllButThisCommand();
    public void set_CloseAllButThisCommand(ICommand value);
    private static void OnCloseAllButThisCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCloseAllButThisCommandChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceCloseAllButThisCommandValue(DependencyObject d, object value);
    private bool CanExecuteCloseAllButThisCommand(object parameter);
    private void ExecuteCloseAllButThisCommand(object parameter);
    public ICommand get_CloseAllCommand();
    public void set_CloseAllCommand(ICommand value);
    private static void OnCloseAllCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCloseAllCommandChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceCloseAllCommandValue(DependencyObject d, object value);
    private bool CanExecuteCloseAllCommand(object parameter);
    private void ExecuteCloseAllCommand(object parameter);
    public ICommand get_ActivateCommand();
    public void set_ActivateCommand(ICommand value);
    private static void OnActivateCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnActivateCommandChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceActivateCommandValue(DependencyObject d, object value);
    private bool CanExecuteActivateCommand(object parameter);
    private void ExecuteActivateCommand(object parameter);
    public ICommand get_NewVerticalTabGroupCommand();
    public void set_NewVerticalTabGroupCommand(ICommand value);
    private static void OnNewVerticalTabGroupCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnNewVerticalTabGroupCommandChanged(DependencyPropertyChangedEventArgs e);
    private bool CanExecuteNewVerticalTabGroupCommand(object parameter);
    private void ExecuteNewVerticalTabGroupCommand(object parameter);
    public ICommand get_NewHorizontalTabGroupCommand();
    public void set_NewHorizontalTabGroupCommand(ICommand value);
    private static void OnNewHorizontalTabGroupCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnNewHorizontalTabGroupCommandChanged(DependencyPropertyChangedEventArgs e);
    private bool CanExecuteNewHorizontalTabGroupCommand(object parameter);
    private void ExecuteNewHorizontalTabGroupCommand(object parameter);
    public ICommand get_MoveToNextTabGroupCommand();
    public void set_MoveToNextTabGroupCommand(ICommand value);
    private static void OnMoveToNextTabGroupCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMoveToNextTabGroupCommandChanged(DependencyPropertyChangedEventArgs e);
    private bool CanExecuteMoveToNextTabGroupCommand(object parameter);
    private void ExecuteMoveToNextTabGroupCommand(object parameter);
    public ICommand get_MoveToPreviousTabGroupCommand();
    public void set_MoveToPreviousTabGroupCommand(ICommand value);
    private static void OnMoveToPreviousTabGroupCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMoveToPreviousTabGroupCommandChanged(DependencyPropertyChangedEventArgs e);
    private bool CanExecuteMoveToPreviousTabGroupCommand(object parameter);
    private void ExecuteMoveToPreviousTabGroupCommand(object parameter);
    protected virtual void InitDefaultCommands();
    protected virtual void ClearDefaultCommands();
    protected virtual void ClearDefaultBindings();
    protected virtual void SetDefaultBindings();
    protected virtual void OnVisibilityChanged();
    internal virtual void Attach(LayoutContent model);
    internal virtual void Detach();
    internal void _ClearDefaultBindings();
    internal void _SetDefaultBindings();
    internal bool IsViewExists();
    private void LayoutElement_IsActiveChanged(object sender, EventArgs e);
    private void LayoutElement_IsSelectedChanged(object sender, EventArgs e);
    private static void OnToolTipChanged(DependencyObject s, DependencyPropertyChangedEventArgs e);
    private void OnToolTipChanged();
    private static void OnVisibilityChanged(DependencyObject s, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
private bool <CanExecuteCloseAllButThisCommand>b__104_0(LayoutContent d);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_0(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_1(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_2(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_3(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_4(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_5(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_6(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_7(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_8(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_9(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_10(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_11(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_12(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_13(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_14(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_15(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_16(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_17(object p);
    [CompilerGeneratedAttribute]
private void <InitDefaultCommands>b__156_18(object p);
    [CompilerGeneratedAttribute]
private bool <InitDefaultCommands>b__156_19(object p);
}
public class Xceed.Wpf.AvalonDock.Controls.LayoutPanelControl : LayoutGridControl`1<ILayoutPanelElement> {
    private LayoutPanel _model;
    internal LayoutPanelControl(LayoutPanel model);
    protected virtual void OnFixChildrenDockLengths();
}
public class Xceed.Wpf.AvalonDock.Controls.MenuItemEx : MenuItem {
    private bool _reentrantFlag;
    public static DependencyProperty IconTemplateProperty;
    public static DependencyProperty IconTemplateSelectorProperty;
    public DataTemplate IconTemplate { get; public set; }
    public DataTemplateSelector IconTemplateSelector { get; public set; }
    private static MenuItemEx();
    public DataTemplate get_IconTemplate();
    public void set_IconTemplate(DataTemplate value);
    private static void OnIconTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIconTemplateChanged(DependencyPropertyChangedEventArgs e);
    public DataTemplateSelector get_IconTemplateSelector();
    public void set_IconTemplateSelector(DataTemplateSelector value);
    private static void OnIconTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIconTemplateSelectorChanged(DependencyPropertyChangedEventArgs e);
    private static void OnIconPropertyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    private void UpdateIcon();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class Xceed.Wpf.AvalonDock.Controls.NavigatorWindow : Window {
    private static string PART_AnchorableListBox;
    private static string PART_DocumentListBox;
    private ResourceDictionary currentThemeResourceDictionary;
    private DockingManager _manager;
    private bool _isSelectingDocument;
    private ListBox _anchorableListBox;
    private ListBox _documentListBox;
    private bool _internalSetSelectedDocument;
    private bool _internalSetSelectedAnchorable;
    private static DependencyPropertyKey DocumentsPropertyKey;
    public static DependencyProperty DocumentsProperty;
    private static DependencyPropertyKey AnchorablesPropertyKey;
    public static DependencyProperty AnchorablesProperty;
    public static DependencyProperty SelectedDocumentProperty;
    public static DependencyProperty SelectedAnchorableProperty;
    public static DependencyProperty LayoutDocumentsLabelProperty;
    public static DependencyProperty LayoutAnchorablesLabelProperty;
    public LayoutDocumentItem[] Documents { get; }
    public IEnumerable`1<LayoutAnchorableItem> Anchorables { get; }
    public LayoutDocumentItem SelectedDocument { get; public set; }
    public LayoutAnchorableItem SelectedAnchorable { get; public set; }
    public string LayoutDocumentsLabel { get; public set; }
    public string LayoutAnchorablesLabel { get; public set; }
    private static NavigatorWindow();
    public NavigatorWindow(DockingManager manager);
    public LayoutDocumentItem[] get_Documents();
    public IEnumerable`1<LayoutAnchorableItem> get_Anchorables();
    public LayoutDocumentItem get_SelectedDocument();
    public void set_SelectedDocument(LayoutDocumentItem value);
    private static void OnSelectedDocumentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectedDocumentChanged(DependencyPropertyChangedEventArgs e);
    public LayoutAnchorableItem get_SelectedAnchorable();
    public void set_SelectedAnchorable(LayoutAnchorableItem value);
    private static void OnSelectedAnchorableChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectedAnchorableChanged(DependencyPropertyChangedEventArgs e);
    public string get_LayoutDocumentsLabel();
    public void set_LayoutDocumentsLabel(string value);
    public string get_LayoutAnchorablesLabel();
    public void set_LayoutAnchorablesLabel(string value);
    public virtual void OnApplyTemplate();
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnPreviewKeyUp(KeyEventArgs e);
    protected void SetAnchorables(IEnumerable`1<LayoutAnchorableItem> value);
    protected void SetDocuments(LayoutDocumentItem[] value);
    internal void UpdateThemeResources(Theme oldTheme);
    internal void SelectNextDocument();
    internal void SelectPreviousDocument();
    internal void SelectNextAnchorable();
    internal void SelectPreviousAnchorable();
    private void InternalSetSelectedAnchorable(LayoutAnchorableItem anchorableToSelect);
    private void InternalSetSelectedDocument(LayoutDocumentItem documentToSelect);
    private void FocusContent(LayoutItem layoutItem);
    private void OnLoaded(object sender, RoutedEventArgs e);
    private void OnUnloaded(object sender, RoutedEventArgs e);
    [CompilerGeneratedAttribute]
private LayoutAnchorableItem <.ctor>b__10_1(LayoutAnchorable d);
    [CompilerGeneratedAttribute]
private LayoutDocumentItem <.ctor>b__10_4(LayoutDocument d);
}
public abstract class Xceed.Wpf.AvalonDock.Controls.OverlayArea : object {
    private IOverlayWindow _overlayWindow;
    private Nullable`1<Rect> _screenDetectionArea;
    private Rect Xceed.Wpf.AvalonDock.Controls.IOverlayWindowArea.ScreenDetectionArea { get; }
    internal OverlayArea(IOverlayWindow overlayWindow);
    protected void SetScreenDetectionArea(Rect rect);
    private sealed virtual override Rect Xceed.Wpf.AvalonDock.Controls.IOverlayWindowArea.get_ScreenDetectionArea();
}
public class Xceed.Wpf.AvalonDock.Controls.OverlayWindow : Window {
    private ResourceDictionary currentThemeResourceDictionary;
    private Canvas _mainCanvasPanel;
    private Grid _gridDockingManagerDropTargets;
    private Grid _gridAnchorablePaneDropTargets;
    private Grid _gridDocumentPaneDropTargets;
    private Grid _gridDocumentPaneFullDropTargets;
    private FrameworkElement _dockingManagerDropTargetBottom;
    private FrameworkElement _dockingManagerDropTargetTop;
    private FrameworkElement _dockingManagerDropTargetLeft;
    private FrameworkElement _dockingManagerDropTargetRight;
    private FrameworkElement _anchorablePaneDropTargetBottom;
    private FrameworkElement _anchorablePaneDropTargetTop;
    private FrameworkElement _anchorablePaneDropTargetLeft;
    private FrameworkElement _anchorablePaneDropTargetRight;
    private FrameworkElement _anchorablePaneDropTargetInto;
    private FrameworkElement _documentPaneDropTargetBottom;
    private FrameworkElement _documentPaneDropTargetTop;
    private FrameworkElement _documentPaneDropTargetLeft;
    private FrameworkElement _documentPaneDropTargetRight;
    private FrameworkElement _documentPaneDropTargetInto;
    private FrameworkElement _documentPaneDropTargetBottomAsAnchorablePane;
    private FrameworkElement _documentPaneDropTargetTopAsAnchorablePane;
    private FrameworkElement _documentPaneDropTargetLeftAsAnchorablePane;
    private FrameworkElement _documentPaneDropTargetRightAsAnchorablePane;
    private FrameworkElement _documentPaneFullDropTargetBottom;
    private FrameworkElement _documentPaneFullDropTargetTop;
    private FrameworkElement _documentPaneFullDropTargetLeft;
    private FrameworkElement _documentPaneFullDropTargetRight;
    private FrameworkElement _documentPaneFullDropTargetInto;
    private Path _previewBox;
    private IOverlayWindowHost _host;
    private LayoutFloatingWindowControl _floatingWindow;
    private List`1<IDropArea> _visibleAreas;
    private static OverlayWindow();
    internal OverlayWindow(IOverlayWindowHost host);
    public virtual void OnApplyTemplate();
    protected virtual void OnClosing(CancelEventArgs e);
    internal void UpdateThemeResources(Theme oldTheme);
    internal void EnableDropTargets();
    internal void HideDropTargets();
    private void SetDropTargetIntoVisibility(ILayoutPositionableElement positionableElement);
    private List`1<LayoutContent> GetAllLayoutContents(object source);
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.Controls.OverlayWindow/<Xceed-Wpf-AvalonDock-Controls-IOverlayWindow-GetTargets>d__42")]
private sealed virtual override IEnumerable`1<IDropTarget> Xceed.Wpf.AvalonDock.Controls.IOverlayWindow.GetTargets();
    private sealed virtual override void Xceed.Wpf.AvalonDock.Controls.IOverlayWindow.DragEnter(LayoutFloatingWindowControl floatingWindow);
    private sealed virtual override void Xceed.Wpf.AvalonDock.Controls.IOverlayWindow.DragLeave(LayoutFloatingWindowControl floatingWindow);
    private sealed virtual override void Xceed.Wpf.AvalonDock.Controls.IOverlayWindow.DragEnter(IDropArea area);
    private sealed virtual override void Xceed.Wpf.AvalonDock.Controls.IOverlayWindow.DragLeave(IDropArea area);
    private sealed virtual override void Xceed.Wpf.AvalonDock.Controls.IOverlayWindow.DragEnter(IDropTarget target);
    private sealed virtual override void Xceed.Wpf.AvalonDock.Controls.IOverlayWindow.DragLeave(IDropTarget target);
    private sealed virtual override void Xceed.Wpf.AvalonDock.Controls.IOverlayWindow.DragDrop(IDropTarget target);
}
public class Xceed.Wpf.AvalonDock.Controls.OverlayWindowDropTarget : object {
    private IOverlayWindowArea _overlayArea;
    private Rect _screenDetectionArea;
    private OverlayWindowDropTargetType _type;
    private Rect Xceed.Wpf.AvalonDock.Controls.IOverlayWindowDropTarget.ScreenDetectionArea { get; }
    private OverlayWindowDropTargetType Xceed.Wpf.AvalonDock.Controls.IOverlayWindowDropTarget.Type { get; }
    internal OverlayWindowDropTarget(IOverlayWindowArea overlayArea, OverlayWindowDropTargetType targetType, FrameworkElement element);
    private sealed virtual override Rect Xceed.Wpf.AvalonDock.Controls.IOverlayWindowDropTarget.get_ScreenDetectionArea();
    private sealed virtual override OverlayWindowDropTargetType Xceed.Wpf.AvalonDock.Controls.IOverlayWindowDropTarget.get_Type();
}
public enum Xceed.Wpf.AvalonDock.Controls.OverlayWindowDropTargetType : Enum {
    public int value__;
    public static OverlayWindowDropTargetType DockingManagerDockLeft;
    public static OverlayWindowDropTargetType DockingManagerDockTop;
    public static OverlayWindowDropTargetType DockingManagerDockRight;
    public static OverlayWindowDropTargetType DockingManagerDockBottom;
    public static OverlayWindowDropTargetType DocumentPaneDockLeft;
    public static OverlayWindowDropTargetType DocumentPaneDockTop;
    public static OverlayWindowDropTargetType DocumentPaneDockRight;
    public static OverlayWindowDropTargetType DocumentPaneDockBottom;
    public static OverlayWindowDropTargetType DocumentPaneDockInside;
    public static OverlayWindowDropTargetType AnchorablePaneDockLeft;
    public static OverlayWindowDropTargetType AnchorablePaneDockTop;
    public static OverlayWindowDropTargetType AnchorablePaneDockRight;
    public static OverlayWindowDropTargetType AnchorablePaneDockBottom;
    public static OverlayWindowDropTargetType AnchorablePaneDockInside;
}
internal class Xceed.Wpf.AvalonDock.Controls.ReentrantFlag : object {
    private bool _flag;
    public bool CanEnter { get; }
    public bool get_CanEnter();
    public _ReentrantFlagHandler Enter();
}
[ExtensionAttribute]
internal static class Xceed.Wpf.AvalonDock.Controls.TransformExtensions : object {
    [ExtensionAttribute]
public static Point PointToScreenDPI(Visual visual, Point pt);
    [ExtensionAttribute]
public static Point PointToScreenDPIWithoutFlowDirection(FrameworkElement element, Point point);
    [ExtensionAttribute]
public static Rect GetScreenArea(FrameworkElement element);
    [ExtensionAttribute]
public static Point TransformToDeviceDPI(Visual visual, Point pt);
    [ExtensionAttribute]
public static Size TransformFromDeviceDPI(Visual visual, Size size);
    [ExtensionAttribute]
public static Point TransformFromDeviceDPI(Visual visual, Point pt);
    [ExtensionAttribute]
public static bool CanTransform(Visual visual);
    [ExtensionAttribute]
public static Size TransformActualSizeToAncestor(FrameworkElement element);
    [ExtensionAttribute]
public static Size TransformSizeToAncestor(FrameworkElement element, Size sizeToTransform);
    [ExtensionAttribute]
public static GeneralTransform TansformToAncestor(FrameworkElement element);
}
[DefaultMemberAttribute("Item")]
internal class Xceed.Wpf.AvalonDock.Controls.WeakDictionary`2 : object {
    private List`1<WeakReference> _keys;
    private List`1<V> _values;
    public V Item { get; public set; }
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool ContainsKey(K key);
    public void SetValue(K key, V value);
    public bool GetValue(K key, V& value);
    private void CollectGarbage();
}
internal class Xceed.Wpf.AvalonDock.Controls.WindowActivateEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IntPtr <HwndActivating>k__BackingField;
    public IntPtr HwndActivating { get; private set; }
    public WindowActivateEventArgs(IntPtr hwndActivating);
    [CompilerGeneratedAttribute]
public IntPtr get_HwndActivating();
    [CompilerGeneratedAttribute]
private void set_HwndActivating(IntPtr value);
}
internal class Xceed.Wpf.AvalonDock.Controls.WindowHookHandler : object {
    private IntPtr _windowHook;
    private HookProc _hookProc;
    private ReentrantFlag _insideActivateEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<FocusChangeEventArgs> FocusChanged;
    public void Attach();
    public void Detach();
    public int HookProc(int code, IntPtr wParam, IntPtr lParam);
    [CompilerGeneratedAttribute]
public void add_FocusChanged(EventHandler`1<FocusChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_FocusChanged(EventHandler`1<FocusChangeEventArgs> value);
}
public class Xceed.Wpf.AvalonDock.Converters.ActivateCommandLayoutItemFromLayoutModelConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.AvalonDock.Converters.AnchorableContextMenuAutoHideHeaderConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.AvalonDock.Converters.AnchorableContextMenuHideVisibilityConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
[ValueConversionAttribute("Xceed.Wpf.AvalonDock.Layout.AnchorSide", "System.Double")]
public class Xceed.Wpf.AvalonDock.Converters.AnchorSideToAngleConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[ValueConversionAttribute("Xceed.Wpf.AvalonDock.Layout.AnchorSide", "System.Windows.Controls.Orientation")]
public class Xceed.Wpf.AvalonDock.Converters.AnchorSideToOrientationConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.AvalonDock.Converters.AutoHideCommandLayoutItemFromLayoutModelConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[ValueConversionAttribute("System.Boolean", "System.Windows.Visibility")]
public class Xceed.Wpf.AvalonDock.Converters.BoolToVisibilityConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.AvalonDock.Converters.HideCommandLayoutItemFromLayoutModelConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[ValueConversionAttribute("System.Boolean", "System.Windows.Visibility")]
public class Xceed.Wpf.AvalonDock.Converters.InverseBoolToVisibilityConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.AvalonDock.Converters.LayoutItemFromLayoutModelConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.AvalonDock.Converters.NullToDoNothingConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class Xceed.Wpf.AvalonDock.Converters.UriSourceToBitmapImageConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[ContentPropertyAttribute("Layout")]
[TemplatePartAttribute]
public class Xceed.Wpf.AvalonDock.DockingManager : Control {
    private ResourceDictionary currentThemeResourceDictionary;
    private AutoHideWindowManager _autoHideWindowManager;
    private FrameworkElement _autohideArea;
    private List`1<LayoutFloatingWindowControl> _fwList;
    private OverlayWindow _overlayWindow;
    private List`1<IDropArea> _areas;
    private bool _insideInternalSetActiveContent;
    private List`1<LayoutItem> _layoutItems;
    private bool _suspendLayoutItemCreation;
    private DispatcherOperation _collectLayoutItemsOperations;
    private NavigatorWindow _navigatorWindow;
    internal bool SuspendDocumentsSourceBinding;
    internal bool SuspendAnchorablesSourceBinding;
    public static DependencyProperty AllowMovingFloatingWindowWithKeyboardProperty;
    public static DependencyProperty LayoutProperty;
    public static DependencyProperty LayoutUpdateStrategyProperty;
    public static DependencyProperty AnchorSideTemplateProperty;
    public static DependencyProperty AnchorGroupTemplateProperty;
    public static DependencyProperty AnchorTemplateProperty;
    public static DependencyProperty DocumentPaneControlStyleProperty;
    public static DependencyProperty AnchorablePaneControlStyleProperty;
    public static DependencyProperty DocumentHeaderTemplateProperty;
    public static DependencyProperty DocumentHeaderTemplateSelectorProperty;
    public static DependencyProperty DocumentTitleTemplateProperty;
    public static DependencyProperty DocumentTitleTemplateSelectorProperty;
    public static DependencyProperty AnchorableTitleTemplateProperty;
    public static DependencyProperty AnchorableTitleTemplateSelectorProperty;
    public static DependencyProperty AnchorableHeaderTemplateProperty;
    public static DependencyProperty AnchorableHeaderTemplateSelectorProperty;
    public static DependencyProperty LayoutRootPanelProperty;
    public static DependencyProperty RightSidePanelProperty;
    public static DependencyProperty LeftSidePanelProperty;
    public static DependencyProperty TopSidePanelProperty;
    public static DependencyProperty BottomSidePanelProperty;
    private List`1<WeakReference> _logicalChildren;
    private static DependencyPropertyKey AutoHideWindowPropertyKey;
    public static DependencyProperty AutoHideWindowProperty;
    public static DependencyProperty AutoHideWindowClosingTimerProperty;
    public static DependencyProperty LayoutItemTemplateProperty;
    public static DependencyProperty LayoutItemTemplateSelectorProperty;
    public static DependencyProperty DocumentsSourceProperty;
    public static DependencyProperty DocumentContextMenuProperty;
    public static DependencyProperty AnchorablesSourceProperty;
    public static DependencyProperty ActiveContentProperty;
    public static DependencyProperty AnchorableContextMenuProperty;
    public static DependencyProperty ThemeProperty;
    public static DependencyProperty GridSplitterWidthProperty;
    public static DependencyProperty GridSplitterHeightProperty;
    public static DependencyProperty DocumentPaneMenuItemHeaderTemplateProperty;
    public static DependencyProperty DocumentPaneMenuItemHeaderTemplateSelectorProperty;
    public static DependencyProperty IconContentTemplateProperty;
    public static DependencyProperty IconContentTemplateSelectorProperty;
    public static DependencyProperty LayoutItemContainerStyleProperty;
    public static DependencyProperty LayoutItemContainerStyleSelectorProperty;
    public static DependencyProperty ShowSystemMenuProperty;
    public static DependencyProperty AllowMixedOrientationProperty;
    [CompilerGeneratedAttribute]
private EventHandler LayoutChanged;
    [CompilerGeneratedAttribute]
private EventHandler LayoutChanging;
    [CompilerGeneratedAttribute]
private EventHandler`1<DocumentClosingEventArgs> DocumentClosing;
    [CompilerGeneratedAttribute]
private EventHandler`1<DocumentClosedEventArgs> DocumentClosed;
    [CompilerGeneratedAttribute]
private EventHandler ActiveContentChanged;
    public static RoutedEvent PreviewFloatEvent;
    public static RoutedEvent FloatedEvent;
    public static RoutedEvent PreviewDockEvent;
    public static RoutedEvent DockedEvent;
    public bool AllowMovingFloatingWindowWithKeyboard { get; private set; }
    public LayoutRoot Layout { get; public set; }
    public ILayoutUpdateStrategy LayoutUpdateStrategy { get; public set; }
    public ControlTemplate AnchorSideTemplate { get; public set; }
    public ControlTemplate AnchorGroupTemplate { get; public set; }
    public ControlTemplate AnchorTemplate { get; public set; }
    public Style DocumentPaneControlStyle { get; public set; }
    public Style AnchorablePaneControlStyle { get; public set; }
    public DataTemplate DocumentHeaderTemplate { get; public set; }
    public DataTemplateSelector DocumentHeaderTemplateSelector { get; public set; }
    public DataTemplate DocumentTitleTemplate { get; public set; }
    public DataTemplateSelector DocumentTitleTemplateSelector { get; public set; }
    public DataTemplate AnchorableTitleTemplate { get; public set; }
    public DataTemplateSelector AnchorableTitleTemplateSelector { get; public set; }
    public DataTemplate AnchorableHeaderTemplate { get; public set; }
    public DataTemplateSelector AnchorableHeaderTemplateSelector { get; public set; }
    public LayoutPanelControl LayoutRootPanel { get; public set; }
    public LayoutAnchorSideControl RightSidePanel { get; public set; }
    public LayoutAnchorSideControl LeftSidePanel { get; public set; }
    public LayoutAnchorSideControl TopSidePanel { get; public set; }
    public LayoutAnchorSideControl BottomSidePanel { get; public set; }
    protected IEnumerator LogicalChildren { get; }
    public IEnumerator LogicalChildrenPublic { get; }
    public LayoutAutoHideWindowControl AutoHideWindow { get; }
    public int AutoHideWindowClosingTimer { get; public set; }
    public IEnumerable`1<LayoutFloatingWindowControl> FloatingWindows { get; }
    public DataTemplate LayoutItemTemplate { get; public set; }
    public DataTemplateSelector LayoutItemTemplateSelector { get; public set; }
    public IEnumerable DocumentsSource { get; public set; }
    public ContextMenu DocumentContextMenu { get; public set; }
    public IEnumerable AnchorablesSource { get; public set; }
    public object ActiveContent { get; public set; }
    public ContextMenu AnchorableContextMenu { get; public set; }
    public Theme Theme { get; public set; }
    public double GridSplitterWidth { get; public set; }
    public double GridSplitterHeight { get; public set; }
    public DataTemplate DocumentPaneMenuItemHeaderTemplate { get; public set; }
    public DataTemplateSelector DocumentPaneMenuItemHeaderTemplateSelector { get; public set; }
    public DataTemplate IconContentTemplate { get; public set; }
    public DataTemplateSelector IconContentTemplateSelector { get; public set; }
    public Style LayoutItemContainerStyle { get; public set; }
    public StyleSelector LayoutItemContainerStyleSelector { get; public set; }
    public bool ShowSystemMenu { get; public set; }
    public bool AllowMixedOrientation { get; public set; }
    internal bool IsNavigatorWindowActive { get; }
    private DockingManager Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.Manager { get; }
    private static DockingManager();
    public bool get_AllowMovingFloatingWindowWithKeyboard();
    private void set_AllowMovingFloatingWindowWithKeyboard(bool value);
    public LayoutRoot get_Layout();
    public void set_Layout(LayoutRoot value);
    private static object CoerceLayoutValue(DependencyObject d, object value);
    private static void OnLayoutChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnLayoutChanged(LayoutRoot oldLayout, LayoutRoot newLayout);
    public ILayoutUpdateStrategy get_LayoutUpdateStrategy();
    public void set_LayoutUpdateStrategy(ILayoutUpdateStrategy value);
    public ControlTemplate get_AnchorSideTemplate();
    public void set_AnchorSideTemplate(ControlTemplate value);
    public ControlTemplate get_AnchorGroupTemplate();
    public void set_AnchorGroupTemplate(ControlTemplate value);
    public ControlTemplate get_AnchorTemplate();
    public void set_AnchorTemplate(ControlTemplate value);
    public Style get_DocumentPaneControlStyle();
    public void set_DocumentPaneControlStyle(Style value);
    private static void OnDocumentPaneControlStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDocumentPaneControlStyleChanged(DependencyPropertyChangedEventArgs e);
    public Style get_AnchorablePaneControlStyle();
    public void set_AnchorablePaneControlStyle(Style value);
    private static void OnAnchorablePaneControlStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAnchorablePaneControlStyleChanged(DependencyPropertyChangedEventArgs e);
    public DataTemplate get_DocumentHeaderTemplate();
    public void set_DocumentHeaderTemplate(DataTemplate value);
    private static void OnDocumentHeaderTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDocumentHeaderTemplateChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceDocumentHeaderTemplateValue(DependencyObject d, object value);
    public DataTemplateSelector get_DocumentHeaderTemplateSelector();
    public void set_DocumentHeaderTemplateSelector(DataTemplateSelector value);
    private static void OnDocumentHeaderTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDocumentHeaderTemplateSelectorChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceDocumentHeaderTemplateSelectorValue(DependencyObject d, object value);
    public DataTemplate get_DocumentTitleTemplate();
    public void set_DocumentTitleTemplate(DataTemplate value);
    private static void OnDocumentTitleTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDocumentTitleTemplateChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceDocumentTitleTemplateValue(DependencyObject d, object value);
    public DataTemplateSelector get_DocumentTitleTemplateSelector();
    public void set_DocumentTitleTemplateSelector(DataTemplateSelector value);
    private static void OnDocumentTitleTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDocumentTitleTemplateSelectorChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceDocumentTitleTemplateSelectorValue(DependencyObject d, object value);
    public DataTemplate get_AnchorableTitleTemplate();
    public void set_AnchorableTitleTemplate(DataTemplate value);
    private static void OnAnchorableTitleTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAnchorableTitleTemplateChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceAnchorableTitleTemplateValue(DependencyObject d, object value);
    public DataTemplateSelector get_AnchorableTitleTemplateSelector();
    public void set_AnchorableTitleTemplateSelector(DataTemplateSelector value);
    private static void OnAnchorableTitleTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAnchorableTitleTemplateSelectorChanged(DependencyPropertyChangedEventArgs e);
    public DataTemplate get_AnchorableHeaderTemplate();
    public void set_AnchorableHeaderTemplate(DataTemplate value);
    private static void OnAnchorableHeaderTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAnchorableHeaderTemplateChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceAnchorableHeaderTemplateValue(DependencyObject d, object value);
    public DataTemplateSelector get_AnchorableHeaderTemplateSelector();
    public void set_AnchorableHeaderTemplateSelector(DataTemplateSelector value);
    private static void OnAnchorableHeaderTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAnchorableHeaderTemplateSelectorChanged(DependencyPropertyChangedEventArgs e);
    public LayoutPanelControl get_LayoutRootPanel();
    public void set_LayoutRootPanel(LayoutPanelControl value);
    private static void OnLayoutRootPanelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnLayoutRootPanelChanged(DependencyPropertyChangedEventArgs e);
    public LayoutAnchorSideControl get_RightSidePanel();
    public void set_RightSidePanel(LayoutAnchorSideControl value);
    private static void OnRightSidePanelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnRightSidePanelChanged(DependencyPropertyChangedEventArgs e);
    public LayoutAnchorSideControl get_LeftSidePanel();
    public void set_LeftSidePanel(LayoutAnchorSideControl value);
    private static void OnLeftSidePanelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnLeftSidePanelChanged(DependencyPropertyChangedEventArgs e);
    public LayoutAnchorSideControl get_TopSidePanel();
    public void set_TopSidePanel(LayoutAnchorSideControl value);
    private static void OnTopSidePanelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTopSidePanelChanged(DependencyPropertyChangedEventArgs e);
    public LayoutAnchorSideControl get_BottomSidePanel();
    public void set_BottomSidePanel(LayoutAnchorSideControl value);
    private static void OnBottomSidePanelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnBottomSidePanelChanged(DependencyPropertyChangedEventArgs e);
    protected virtual IEnumerator get_LogicalChildren();
    public IEnumerator get_LogicalChildrenPublic();
    internal void InternalAddLogicalChild(object element);
    internal void InternalRemoveLogicalChild(object element);
    private void ClearLogicalChildrenList();
    public LayoutAutoHideWindowControl get_AutoHideWindow();
    protected void SetAutoHideWindow(LayoutAutoHideWindowControl value);
    private static void OnAutoHideWindowChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAutoHideWindowChanged(DependencyPropertyChangedEventArgs e);
    public int get_AutoHideWindowClosingTimer();
    public void set_AutoHideWindowClosingTimer(int value);
    private static void OnAutoHideWindowClosingTimerChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAutoHideWindowClosingTimerChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceAutoHideWindowClosingTimer(DependencyObject d, object value);
    public IEnumerable`1<LayoutFloatingWindowControl> get_FloatingWindows();
    public DataTemplate get_LayoutItemTemplate();
    public void set_LayoutItemTemplate(DataTemplate value);
    private static void OnLayoutItemTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnLayoutItemTemplateChanged(DependencyPropertyChangedEventArgs e);
    public DataTemplateSelector get_LayoutItemTemplateSelector();
    public void set_LayoutItemTemplateSelector(DataTemplateSelector value);
    private static void OnLayoutItemTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnLayoutItemTemplateSelectorChanged(DependencyPropertyChangedEventArgs e);
    public IEnumerable get_DocumentsSource();
    public void set_DocumentsSource(IEnumerable value);
    private static void OnDocumentsSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDocumentsSourceChanged(DependencyPropertyChangedEventArgs e);
    public ContextMenu get_DocumentContextMenu();
    public void set_DocumentContextMenu(ContextMenu value);
    public IEnumerable get_AnchorablesSource();
    public void set_AnchorablesSource(IEnumerable value);
    private static void OnAnchorablesSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAnchorablesSourceChanged(DependencyPropertyChangedEventArgs e);
    public object get_ActiveContent();
    public void set_ActiveContent(object value);
    private static void OnActiveContentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnActiveContentChanged(DependencyPropertyChangedEventArgs e);
    public ContextMenu get_AnchorableContextMenu();
    public void set_AnchorableContextMenu(ContextMenu value);
    public Theme get_Theme();
    public void set_Theme(Theme value);
    private static void OnThemeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnThemeChanged(DependencyPropertyChangedEventArgs e);
    public double get_GridSplitterWidth();
    public void set_GridSplitterWidth(double value);
    public double get_GridSplitterHeight();
    public void set_GridSplitterHeight(double value);
    public DataTemplate get_DocumentPaneMenuItemHeaderTemplate();
    public void set_DocumentPaneMenuItemHeaderTemplate(DataTemplate value);
    private static void OnDocumentPaneMenuItemHeaderTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDocumentPaneMenuItemHeaderTemplateChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceDocumentPaneMenuItemHeaderTemplateValue(DependencyObject d, object value);
    public DataTemplateSelector get_DocumentPaneMenuItemHeaderTemplateSelector();
    public void set_DocumentPaneMenuItemHeaderTemplateSelector(DataTemplateSelector value);
    private static void OnDocumentPaneMenuItemHeaderTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnDocumentPaneMenuItemHeaderTemplateSelectorChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceDocumentPaneMenuItemHeaderTemplateSelectorValue(DependencyObject d, object value);
    public DataTemplate get_IconContentTemplate();
    public void set_IconContentTemplate(DataTemplate value);
    public DataTemplateSelector get_IconContentTemplateSelector();
    public void set_IconContentTemplateSelector(DataTemplateSelector value);
    public Style get_LayoutItemContainerStyle();
    public void set_LayoutItemContainerStyle(Style value);
    private static void OnLayoutItemContainerStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnLayoutItemContainerStyleChanged(DependencyPropertyChangedEventArgs e);
    public StyleSelector get_LayoutItemContainerStyleSelector();
    public void set_LayoutItemContainerStyleSelector(StyleSelector value);
    private static void OnLayoutItemContainerStyleSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnLayoutItemContainerStyleSelectorChanged(DependencyPropertyChangedEventArgs e);
    public bool get_ShowSystemMenu();
    public void set_ShowSystemMenu(bool value);
    public bool get_AllowMixedOrientation();
    public void set_AllowMixedOrientation(bool value);
    internal bool get_IsNavigatorWindowActive();
    public virtual void OnApplyTemplate();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    public virtual NavigatorWindow CreateNavigatorWindow();
    public LayoutItem GetLayoutItemFromModel(LayoutContent content);
    public LayoutFloatingWindowControl CreateFloatingWindow(LayoutContent contentModel, bool isContentImmutable);
    internal UIElement CreateUIElementForModel(ILayoutElement model);
    internal void ShowAutoHideWindow(LayoutAnchorControl anchor);
    internal void HideAutoHideWindow(LayoutAnchorControl anchor);
    internal FrameworkElement GetAutoHideAreaElement();
    internal void StartDraggingFloatingWindowForContent(LayoutContent contentModel, bool startDrag);
    internal void StartDraggingFloatingWindowForPane(LayoutAnchorablePane paneModel);
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.DockingManager/<GetFloatingWindowsByZOrder>d__272")]
internal IEnumerable`1<LayoutFloatingWindowControl> GetFloatingWindowsByZOrder();
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.DockingManager/<GetWindowsByZOrder>d__273")]
internal IEnumerable`1<Window> GetWindowsByZOrder();
    internal void RemoveFloatingWindow(LayoutFloatingWindowControl floatingWindow);
    internal void _ExecuteCloseCommand(LayoutDocument document);
    internal void _ExecuteCloseAllButThisCommand(LayoutContent contentSelected);
    internal void _ExecuteCloseAllCommand(LayoutContent contentSelected);
    internal void _ExecuteCloseCommand(LayoutAnchorable anchorable);
    internal void _ExecuteHideCommand(LayoutAnchorable anchorable);
    internal void _ExecuteAutoHideCommand(LayoutAnchorable _anchorable);
    internal void _ExecuteFloatCommand(LayoutContent contentToFloat);
    internal void _ExecuteDockCommand(LayoutAnchorable anchorable);
    internal void _ExecuteDockAsDocumentCommand(LayoutContent content);
    internal void _ExecuteContentActivateCommand(LayoutContent content);
    protected internal virtual void ShowNavigatorWindow();
    private void OnLayoutRootPropertyChanged(object sender, PropertyChangedEventArgs e);
    private void OnLayoutRootUpdated(object sender, EventArgs e);
    private void OnLayoutChanging(LayoutRoot newLayout);
    private void DockingManager_Loaded(object sender, RoutedEventArgs e);
    private void DockingManager_Unloaded(object sender, RoutedEventArgs e);
    private void SetupAutoHideWindow();
    private void CreateOverlayWindow();
    private void DestroyOverlayWindow();
    private void AttachDocumentsSource(LayoutRoot layout, IEnumerable documentsSource);
    private void DocumentsSourceElementsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void DetachDocumentsSource(LayoutRoot layout, IEnumerable documentsSource);
    private void Close(LayoutContent contentToClose);
    private void AttachAnchorablesSource(LayoutRoot layout, IEnumerable anchorablesSource);
    private void anchorablesSourceElementsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void DetachAnchorablesSource(LayoutRoot layout, IEnumerable anchorablesSource);
    private void RemoveViewFromLogicalChild(LayoutContent layoutContent);
    private void InternalSetActiveContent(object activeContent);
    private void DetachLayoutItems();
    private void Layout_ElementRemoved(object sender, LayoutElementEventArgs e);
    private void Layout_ElementAdded(object sender, LayoutElementEventArgs e);
    private void CollectLayoutItemsDeleted();
    private void AttachLayoutItems();
    private void ApplyStyleToLayoutItem(LayoutItem layoutItem);
    private void CreateAnchorableLayoutItem(LayoutAnchorable contentToAttach);
    private void CreateDocumentLayoutItem(LayoutDocument contentToAttach);
    private void RemoveDocumentLayoutItem(LayoutDocument contentToRemove);
    private LayoutFloatingWindowControl CreateFloatingWindowForLayoutAnchorableWithoutParent(LayoutAnchorablePane paneModel, bool isContentImmutable);
    private LayoutFloatingWindowControl CreateFloatingWindowCore(LayoutContent contentModel, bool isContentImmutable);
    private void ShowInTaskbar(LayoutFloatingWindowControl fwc);
    private void RenameWindowTitleForMultipleDockingManagerRunningInstances(LayoutFloatingWindowControl fwc);
    private Size UpdateFloatingDimensions(ILayoutElementForFloatingWindow contentModel, Size currentSize);
    private void UpdateStarSize(LayoutContent contentModel);
    private void AnchorableContextMenu_Opened(object sender, RoutedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_LayoutChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LayoutChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_LayoutChanging(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LayoutChanging(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_DocumentClosing(EventHandler`1<DocumentClosingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DocumentClosing(EventHandler`1<DocumentClosingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DocumentClosed(EventHandler`1<DocumentClosedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DocumentClosed(EventHandler`1<DocumentClosedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ActiveContentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ActiveContentChanged(EventHandler value);
    private sealed virtual override bool Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.HitTest(Point dragPoint);
    private sealed virtual override DockingManager Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.get_Manager();
    private sealed virtual override IOverlayWindow Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.ShowOverlayWindow(LayoutFloatingWindowControl draggingWindow);
    private sealed virtual override void Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.HideOverlayWindow();
    private sealed virtual override IEnumerable`1<IDropArea> Xceed.Wpf.AvalonDock.Controls.IOverlayWindowHost.GetDropAreas(LayoutFloatingWindowControl draggingWindow);
    public void add_PreviewFloat(RoutedEventHandler value);
    public void remove_PreviewFloat(RoutedEventHandler value);
    protected virtual void RaisePreviewFloatEvent(LayoutContent layoutContent);
    public void add_Floated(RoutedEventHandler value);
    public void remove_Floated(RoutedEventHandler value);
    protected virtual void RaiseFloatedEvent(LayoutContent layoutContent);
    public void add_PreviewDock(RoutedEventHandler value);
    public void remove_PreviewDock(RoutedEventHandler value);
    protected internal virtual void RaisePreviewDockEvent(LayoutContent layoutContent);
    public void add_Docked(RoutedEventHandler value);
    public void remove_Docked(RoutedEventHandler value);
    protected internal virtual void RaiseDockedEvent(LayoutContent layoutContent);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool OnReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    [CompilerGeneratedAttribute]
private bool <DockingManager_Loaded>b__289_0(LayoutFloatingWindow fw);
    [CompilerGeneratedAttribute]
private void <CollectLayoutItemsDeleted>b__306_0();
    [CompilerGeneratedAttribute]
private bool <CollectLayoutItemsDeleted>b__306_1(LayoutItem item);
}
public class Xceed.Wpf.AvalonDock.DocumentClosedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private LayoutDocument <Document>k__BackingField;
    public LayoutDocument Document { get; private set; }
    public DocumentClosedEventArgs(LayoutDocument document);
    [CompilerGeneratedAttribute]
public LayoutDocument get_Document();
    [CompilerGeneratedAttribute]
private void set_Document(LayoutDocument value);
}
public class Xceed.Wpf.AvalonDock.DocumentClosingEventArgs : CancelEventArgs {
    [CompilerGeneratedAttribute]
private LayoutDocument <Document>k__BackingField;
    public LayoutDocument Document { get; private set; }
    public DocumentClosingEventArgs(LayoutDocument document);
    [CompilerGeneratedAttribute]
public LayoutDocument get_Document();
    [CompilerGeneratedAttribute]
private void set_Document(LayoutDocument value);
}
[ExtensionAttribute]
internal static class Xceed.Wpf.AvalonDock.Extensions : object {
    [ExtensionAttribute]
public static bool Contains(IEnumerable collection, object item);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> collection, Action`1<T> action);
    [ExtensionAttribute]
public static int IndexOf(T[] array, T value);
    [ExtensionAttribute]
public static V GetValueOrDefault(WeakReference wr);
}
[FlagsAttribute]
public enum Xceed.Wpf.AvalonDock.Layout.AnchorableShowStrategy : Enum {
    public byte value__;
    public static AnchorableShowStrategy Most;
    public static AnchorableShowStrategy Left;
    public static AnchorableShowStrategy Right;
    public static AnchorableShowStrategy Top;
    public static AnchorableShowStrategy Bottom;
}
public enum Xceed.Wpf.AvalonDock.Layout.AnchorSide : Enum {
    public int value__;
    public static AnchorSide Left;
    public static AnchorSide Top;
    public static AnchorSide Right;
    public static AnchorSide Bottom;
}
public enum Xceed.Wpf.AvalonDock.Layout.ChildrenTreeChange : Enum {
    public int value__;
    public static ChildrenTreeChange DirectChildrenChanged;
    public static ChildrenTreeChange TreeChanged;
}
public class Xceed.Wpf.AvalonDock.Layout.ChildrenTreeChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ChildrenTreeChange <Change>k__BackingField;
    public ChildrenTreeChange Change { get; private set; }
    public ChildrenTreeChangedEventArgs(ChildrenTreeChange change);
    [CompilerGeneratedAttribute]
public ChildrenTreeChange get_Change();
    [CompilerGeneratedAttribute]
private void set_Change(ChildrenTreeChange value);
}
[ExtensionAttribute]
public static class Xceed.Wpf.AvalonDock.Layout.Extensions : object {
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.Layout.Extensions/<Descendents>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<ILayoutElement> Descendents(ILayoutElement element);
    [ExtensionAttribute]
public static T FindParent(ILayoutElement element);
    [ExtensionAttribute]
public static ILayoutRoot GetRoot(ILayoutElement element);
    [ExtensionAttribute]
public static bool ContainsChildOfType(ILayoutContainer element);
    [ExtensionAttribute]
public static bool ContainsChildOfType(ILayoutContainer container);
    [ExtensionAttribute]
public static bool IsOfType(ILayoutContainer container);
    [ExtensionAttribute]
public static AnchorSide GetSide(ILayoutElement element);
    [ExtensionAttribute]
internal static void KeepInsideNearestMonitor(ILayoutElementForFloatingWindow paneInsideFloatingWindow);
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutAnchorablePane {
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutContainer {
    public IEnumerable`1<ILayoutElement> Children { get; }
    public int ChildrenCount { get; }
    public abstract virtual IEnumerable`1<ILayoutElement> get_Children();
    public abstract virtual int get_ChildrenCount();
    public abstract virtual void RemoveChild(ILayoutElement element);
    public abstract virtual void ReplaceChild(ILayoutElement oldElement, ILayoutElement newElement);
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutContentSelector {
    public int SelectedContentIndex { get; public set; }
    public LayoutContent SelectedContent { get; }
    public abstract virtual int get_SelectedContentIndex();
    public abstract virtual void set_SelectedContentIndex(int value);
    public abstract virtual LayoutContent get_SelectedContent();
    public abstract virtual int IndexOf(LayoutContent content);
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutControl {
    public ILayoutElement Model { get; }
    public abstract virtual ILayoutElement get_Model();
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutDocumentPane {
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutElement {
    public ILayoutContainer Parent { get; }
    public ILayoutRoot Root { get; }
    public abstract virtual ILayoutContainer get_Parent();
    public abstract virtual ILayoutRoot get_Root();
}
internal interface Xceed.Wpf.AvalonDock.Layout.ILayoutElementForFloatingWindow {
    public double FloatingWidth { get; public set; }
    public double FloatingHeight { get; public set; }
    public double FloatingLeft { get; public set; }
    public double FloatingTop { get; public set; }
    public bool IsMaximized { get; public set; }
    public abstract virtual double get_FloatingWidth();
    public abstract virtual void set_FloatingWidth(double value);
    public abstract virtual double get_FloatingHeight();
    public abstract virtual void set_FloatingHeight(double value);
    public abstract virtual double get_FloatingLeft();
    public abstract virtual void set_FloatingLeft(double value);
    public abstract virtual double get_FloatingTop();
    public abstract virtual void set_FloatingTop(double value);
    public abstract virtual bool get_IsMaximized();
    public abstract virtual void set_IsMaximized(bool value);
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutElementWithVisibility {
    public abstract virtual void ComputeVisibility();
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutGroup {
    public abstract virtual int IndexOfChild(ILayoutElement element);
    public abstract virtual void InsertChildAt(int index, ILayoutElement element);
    public abstract virtual void RemoveChildAt(int index);
    public abstract virtual void ReplaceChildAt(int index, ILayoutElement element);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChildrenCollectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChildrenCollectionChanged(EventHandler value);
}
internal interface Xceed.Wpf.AvalonDock.Layout.ILayoutInitialContainer {
    public ILayoutContainer InitialContainer { get; public set; }
    public string InitialContainerId { get; public set; }
    public abstract virtual ILayoutContainer get_InitialContainer();
    public abstract virtual void set_InitialContainer(ILayoutContainer value);
    public abstract virtual string get_InitialContainerId();
    public abstract virtual void set_InitialContainerId(string value);
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutOrientableGroup {
    public Orientation Orientation { get; public set; }
    public abstract virtual Orientation get_Orientation();
    public abstract virtual void set_Orientation(Orientation value);
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutPane {
    public abstract virtual void MoveChild(int oldIndex, int newIndex);
    public abstract virtual void RemoveChildAt(int childIndex);
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutPanelElement {
    public bool IsVisible { get; }
    public abstract virtual bool get_IsVisible();
}
internal interface Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable {
    public string Id { get; public set; }
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
}
internal interface Xceed.Wpf.AvalonDock.Layout.ILayoutPositionableElement {
    public GridLength DockWidth { get; public set; }
    public GridLength DockHeight { get; public set; }
    public double DockMinWidth { get; public set; }
    public double DockMinHeight { get; public set; }
    public bool AllowDuplicateContent { get; public set; }
    public bool IsVisible { get; }
    public abstract virtual GridLength get_DockWidth();
    public abstract virtual void set_DockWidth(GridLength value);
    public abstract virtual GridLength get_DockHeight();
    public abstract virtual void set_DockHeight(GridLength value);
    public abstract virtual double get_DockMinWidth();
    public abstract virtual void set_DockMinWidth(double value);
    public abstract virtual double get_DockMinHeight();
    public abstract virtual void set_DockMinHeight(double value);
    public abstract virtual bool get_AllowDuplicateContent();
    public abstract virtual void set_AllowDuplicateContent(bool value);
    public abstract virtual bool get_IsVisible();
}
internal interface Xceed.Wpf.AvalonDock.Layout.ILayoutPositionableElementWithActualSize {
    public double ActualWidth { get; public set; }
    public double ActualHeight { get; public set; }
    public abstract virtual double get_ActualWidth();
    public abstract virtual void set_ActualWidth(double value);
    public abstract virtual double get_ActualHeight();
    public abstract virtual void set_ActualHeight(double value);
}
internal interface Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer {
    public ILayoutContainer PreviousContainer { get; public set; }
    public string PreviousContainerId { get; public set; }
    public abstract virtual ILayoutContainer get_PreviousContainer();
    public abstract virtual void set_PreviousContainer(ILayoutContainer value);
    public abstract virtual string get_PreviousContainerId();
    public abstract virtual void set_PreviousContainerId(string value);
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutRoot {
    public DockingManager Manager { get; }
    public LayoutPanel RootPanel { get; }
    public LayoutAnchorSide TopSide { get; }
    public LayoutAnchorSide LeftSide { get; }
    public LayoutAnchorSide RightSide { get; }
    public LayoutAnchorSide BottomSide { get; }
    public LayoutContent ActiveContent { get; public set; }
    public ObservableCollection`1<LayoutFloatingWindow> FloatingWindows { get; }
    public ObservableCollection`1<LayoutAnchorable> Hidden { get; }
    public abstract virtual DockingManager get_Manager();
    public abstract virtual LayoutPanel get_RootPanel();
    public abstract virtual LayoutAnchorSide get_TopSide();
    public abstract virtual LayoutAnchorSide get_LeftSide();
    public abstract virtual LayoutAnchorSide get_RightSide();
    public abstract virtual LayoutAnchorSide get_BottomSide();
    public abstract virtual LayoutContent get_ActiveContent();
    public abstract virtual void set_ActiveContent(LayoutContent value);
    public abstract virtual ObservableCollection`1<LayoutFloatingWindow> get_FloatingWindows();
    public abstract virtual ObservableCollection`1<LayoutAnchorable> get_Hidden();
    public abstract virtual void CollectGarbage();
}
public interface Xceed.Wpf.AvalonDock.Layout.ILayoutUpdateStrategy {
    public abstract virtual bool BeforeInsertAnchorable(LayoutRoot layout, LayoutAnchorable anchorableToShow, ILayoutContainer destinationContainer);
    public abstract virtual void AfterInsertAnchorable(LayoutRoot layout, LayoutAnchorable anchorableShown);
    public abstract virtual bool BeforeInsertDocument(LayoutRoot layout, LayoutDocument documentToShow, ILayoutContainer destinationContainer);
    public abstract virtual void AfterInsertDocument(LayoutRoot layout, LayoutDocument documentShown);
}
public class Xceed.Wpf.AvalonDock.Layout.LayoutAnchorable : LayoutContent {
    private double _autohideWidth;
    private double _autohideMinWidth;
    private double _autohideHeight;
    private double _autohideMinHeight;
    private bool _canHide;
    private bool _canAutoHide;
    private bool _canDockAsTabbedDocument;
    private bool _canCloseValueBeforeInternalSet;
    [CompilerGeneratedAttribute]
private EventHandler IsVisibleChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<CancelEventArgs> Hiding;
    [CompilerGeneratedAttribute]
private EventHandler Hidden;
    public double AutoHideWidth { get; public set; }
    public double AutoHideMinWidth { get; public set; }
    public double AutoHideHeight { get; public set; }
    public double AutoHideMinHeight { get; public set; }
    public bool CanHide { get; public set; }
    public bool CanAutoHide { get; public set; }
    public bool CanDockAsTabbedDocument { get; public set; }
    public bool IsAutoHidden { get; }
    [XmlIgnoreAttribute]
public bool IsHidden { get; }
    [XmlIgnoreAttribute]
public bool IsVisible { get; public set; }
    public double get_AutoHideWidth();
    public void set_AutoHideWidth(double value);
    public double get_AutoHideMinWidth();
    public void set_AutoHideMinWidth(double value);
    public double get_AutoHideHeight();
    public void set_AutoHideHeight(double value);
    public double get_AutoHideMinHeight();
    public void set_AutoHideMinHeight(double value);
    public bool get_CanHide();
    public void set_CanHide(bool value);
    public bool get_CanAutoHide();
    public void set_CanAutoHide(bool value);
    public bool get_CanDockAsTabbedDocument();
    public void set_CanDockAsTabbedDocument(bool value);
    public bool get_IsAutoHidden();
    public bool get_IsHidden();
    public bool get_IsVisible();
    public void set_IsVisible(bool value);
    [CompilerGeneratedAttribute]
public void add_IsVisibleChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsVisibleChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Hiding(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Hiding(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Hidden(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Hidden(EventHandler value);
    protected virtual void OnParentChanged(ILayoutContainer oldValue, ILayoutContainer newValue);
    protected virtual void InternalDock();
    public virtual void ReadXml(XmlReader reader);
    public virtual void WriteXml(XmlWriter writer);
    public virtual void Close();
    public virtual void ConsoleDump(int tab);
    public void Hide(bool cancelable);
    public void Show();
    public void AddToLayout(DockingManager manager, AnchorableShowStrategy strategy);
    public void ToggleAutoHide();
    protected virtual void OnHiding(CancelEventArgs args);
    protected virtual void OnHidden();
    internal bool CloseAnchorable();
    internal void SetCanCloseInternal(bool canClose);
    internal void ResetCanCloseInternal();
    private void NotifyIsVisibleChanged();
    private void UpdateParentVisibility();
}
[ContentPropertyAttribute("RootPanel")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutAnchorableFloatingWindow : LayoutFloatingWindow {
    private LayoutAnchorablePaneGroup _rootPanel;
    private bool _isVisible;
    [CompilerGeneratedAttribute]
private EventHandler IsVisibleChanged;
    public bool IsSinglePane { get; }
    [XmlIgnoreAttribute]
public bool IsVisible { get; private set; }
    public LayoutAnchorablePaneGroup RootPanel { get; public set; }
    public ILayoutAnchorablePane SinglePane { get; }
    public IEnumerable`1<ILayoutElement> Children { get; }
    public int ChildrenCount { get; }
    public bool IsValid { get; }
    public bool get_IsSinglePane();
    public bool get_IsVisible();
    private void set_IsVisible(bool value);
    public LayoutAnchorablePaneGroup get_RootPanel();
    public void set_RootPanel(LayoutAnchorablePaneGroup value);
    public ILayoutAnchorablePane get_SinglePane();
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.Layout.LayoutAnchorableFloatingWindow/<get_Children>d__14")]
public virtual IEnumerable`1<ILayoutElement> get_Children();
    public virtual void RemoveChild(ILayoutElement element);
    public virtual void ReplaceChild(ILayoutElement oldElement, ILayoutElement newElement);
    public virtual int get_ChildrenCount();
    public virtual bool get_IsValid();
    public virtual void ReadXml(XmlReader reader);
    public virtual void ConsoleDump(int tab);
    private void _rootPanel_ChildrenTreeChanged(object sender, ChildrenTreeChangedEventArgs e);
    private void ComputeVisibility();
    [CompilerGeneratedAttribute]
public void add_IsVisibleChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsVisibleChanged(EventHandler value);
    private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutElementWithVisibility.ComputeVisibility();
}
[ContentPropertyAttribute("Children")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutAnchorablePane : LayoutPositionableGroup`1<LayoutAnchorable> {
    private int _selectedIndex;
    [XmlIgnoreAttribute]
private bool _autoFixSelectedContent;
    private string _name;
    private string _id;
    public bool CanHide { get; }
    public bool CanClose { get; }
    public bool IsHostedInFloatingWindow { get; }
    public string Name { get; public set; }
    public int SelectedContentIndex { get; public set; }
    public LayoutContent SelectedContent { get; }
    public bool IsDirectlyHostedInFloatingWindow { get; }
    private string Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable.Id { get; private set; }
    public LayoutAnchorablePane(LayoutAnchorable anchorable);
    public bool get_CanHide();
    public bool get_CanClose();
    public bool get_IsHostedInFloatingWindow();
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual int get_SelectedContentIndex();
    public sealed virtual void set_SelectedContentIndex(int value);
    public sealed virtual LayoutContent get_SelectedContent();
    protected virtual bool GetVisibility();
    protected virtual void ChildMoved(int oldIndex, int newIndex);
    protected virtual void OnChildrenCollectionChanged();
    protected virtual void OnParentChanged(ILayoutContainer oldValue, ILayoutContainer newValue);
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader);
    public virtual void ConsoleDump(int tab);
    public sealed virtual int IndexOf(LayoutContent content);
    public bool get_IsDirectlyHostedInFloatingWindow();
    internal void SetNextSelectedIndex();
    internal void UpdateIsDirectlyHostedInFloatingWindow();
    private void AutoFixSelectedContent();
    private void OnParentChildrenCollectionChanged(object sender, EventArgs e);
    private sealed virtual override string Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable.get_Id();
    private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable.set_Id(string value);
}
[ContentPropertyAttribute("Children")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutAnchorablePaneGroup : LayoutPositionableGroup`1<ILayoutAnchorablePane> {
    private Orientation _orientation;
    public Orientation Orientation { get; public set; }
    public LayoutAnchorablePaneGroup(LayoutAnchorablePane firstChild);
    public sealed virtual Orientation get_Orientation();
    public sealed virtual void set_Orientation(Orientation value);
    protected virtual bool GetVisibility();
    protected virtual void OnIsVisibleChanged();
    protected virtual void OnDockWidthChanged();
    protected virtual void OnDockHeightChanged();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader);
    public virtual void ConsoleDump(int tab);
    private void UpdateParentVisibility();
}
[ContentPropertyAttribute("Children")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutAnchorGroup : LayoutGroup`1<LayoutAnchorable> {
    private ILayoutContainer _previousContainer;
    [CompilerGeneratedAttribute]
private string <Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.PreviousContainerId>k__BackingField;
    private string _id;
    [XmlIgnoreAttribute]
private ILayoutContainer Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.PreviousContainer { get; private set; }
    private string Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.PreviousContainerId { get; private set; }
    private string Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable.Id { get; private set; }
    protected virtual bool GetVisibility();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader);
    private sealed virtual override ILayoutContainer Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.get_PreviousContainer();
    private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.set_PreviousContainer(ILayoutContainer value);
    [CompilerGeneratedAttribute]
private sealed virtual override string Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.get_PreviousContainerId();
    [CompilerGeneratedAttribute]
private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.set_PreviousContainerId(string value);
    private sealed virtual override string Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable.get_Id();
    private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable.set_Id(string value);
}
[ContentPropertyAttribute("Children")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutAnchorSide : LayoutGroup`1<LayoutAnchorGroup> {
    private AnchorSide _side;
    public AnchorSide Side { get; private set; }
    public AnchorSide get_Side();
    private void set_Side(AnchorSide value);
    protected virtual bool GetVisibility();
    protected virtual void OnParentChanged(ILayoutContainer oldValue, ILayoutContainer newValue);
    private void UpdateSide();
}
[ContentPropertyAttribute("Content")]
public abstract class Xceed.Wpf.AvalonDock.Layout.LayoutContent : LayoutElement {
    public static DependencyProperty TitleProperty;
    private object _content;
    public static DependencyProperty ContentIdProperty;
    private bool _isSelected;
    [CompilerGeneratedAttribute]
private EventHandler IsSelectedChanged;
    private bool _isActive;
    [CompilerGeneratedAttribute]
private EventHandler IsActiveChanged;
    private bool _isLastFocusedDocument;
    private ILayoutContainer _previousContainer;
    [CompilerGeneratedAttribute]
private string <Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.PreviousContainerId>k__BackingField;
    private ILayoutContainer _initialContainer;
    [CompilerGeneratedAttribute]
private string <Xceed.Wpf.AvalonDock.Layout.ILayoutInitialContainer.InitialContainerId>k__BackingField;
    private int _previousContainerIndex;
    private int _initialContainerIndex;
    private Nullable`1<DateTime> _lastActivationTimeStamp;
    private double _floatingWidth;
    private double _floatingHeight;
    private double _floatingLeft;
    private double _floatingTop;
    private bool _isMaximized;
    private object _toolTip;
    private bool _isFloating;
    private ImageSource _iconSource;
    internal bool _canClose;
    private bool _canFloat;
    private bool _isEnabled;
    [CompilerGeneratedAttribute]
private EventHandler Closed;
    [CompilerGeneratedAttribute]
private EventHandler`1<CancelEventArgs> Closing;
    public string Title { get; public set; }
    [XmlIgnoreAttribute]
public object Content { get; public set; }
    public string ContentId { get; public set; }
    public bool IsSelected { get; public set; }
    [XmlIgnoreAttribute]
public bool IsActive { get; public set; }
    public bool IsLastFocusedDocument { get; internal set; }
    [XmlIgnoreAttribute]
private ILayoutContainer Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.PreviousContainer { get; private set; }
    public ILayoutContainer PreviousContainer { get; protected set; }
    [XmlIgnoreAttribute]
private string Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.PreviousContainerId { get; private set; }
    public string PreviousContainerId { get; protected set; }
    [XmlIgnoreAttribute]
private ILayoutContainer Xceed.Wpf.AvalonDock.Layout.ILayoutInitialContainer.InitialContainer { get; private set; }
    internal ILayoutContainer InitialContainer { get; internal set; }
    [XmlIgnoreAttribute]
private string Xceed.Wpf.AvalonDock.Layout.ILayoutInitialContainer.InitialContainerId { get; private set; }
    internal string InitialContainerId { get; internal set; }
    [XmlIgnoreAttribute]
public int PreviousContainerIndex { get; public set; }
    [XmlIgnoreAttribute]
internal int InitialContainerIndex { get; internal set; }
    public Nullable`1<DateTime> LastActivationTimeStamp { get; public set; }
    public double FloatingWidth { get; public set; }
    public double FloatingHeight { get; public set; }
    public double FloatingLeft { get; public set; }
    public double FloatingTop { get; public set; }
    public bool IsMaximized { get; public set; }
    public object ToolTip { get; public set; }
    public bool IsFloating { get; internal set; }
    public ImageSource IconSource { get; public set; }
    public bool CanClose { get; public set; }
    public bool CanFloat { get; public set; }
    public bool IsEnabled { get; public set; }
    private static LayoutContent();
    public string get_Title();
    public void set_Title(string value);
    private static object CoerceTitleValue(DependencyObject obj, object value);
    private static void OnTitlePropertyChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    public object get_Content();
    public void set_Content(object value);
    public string get_ContentId();
    public void set_ContentId(string value);
    private static void OnContentIdPropertyChanged(DependencyObject obj, DependencyPropertyChangedEventArgs args);
    private void OnContentIdPropertyChanged(string oldValue, string newValue);
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    protected virtual void OnIsSelectedChanged(bool oldValue, bool newValue);
    [CompilerGeneratedAttribute]
public void add_IsSelectedChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsSelectedChanged(EventHandler value);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    protected virtual void OnIsActiveChanged(bool oldValue, bool newValue);
    [CompilerGeneratedAttribute]
public void add_IsActiveChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_IsActiveChanged(EventHandler value);
    public bool get_IsLastFocusedDocument();
    internal void set_IsLastFocusedDocument(bool value);
    private sealed virtual override ILayoutContainer Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.get_PreviousContainer();
    private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.set_PreviousContainer(ILayoutContainer value);
    public ILayoutContainer get_PreviousContainer();
    protected void set_PreviousContainer(ILayoutContainer value);
    [CompilerGeneratedAttribute]
private sealed virtual override string Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.get_PreviousContainerId();
    [CompilerGeneratedAttribute]
private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutPreviousContainer.set_PreviousContainerId(string value);
    public string get_PreviousContainerId();
    protected void set_PreviousContainerId(string value);
    private sealed virtual override ILayoutContainer Xceed.Wpf.AvalonDock.Layout.ILayoutInitialContainer.get_InitialContainer();
    private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutInitialContainer.set_InitialContainer(ILayoutContainer value);
    internal ILayoutContainer get_InitialContainer();
    internal void set_InitialContainer(ILayoutContainer value);
    [CompilerGeneratedAttribute]
private sealed virtual override string Xceed.Wpf.AvalonDock.Layout.ILayoutInitialContainer.get_InitialContainerId();
    [CompilerGeneratedAttribute]
private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutInitialContainer.set_InitialContainerId(string value);
    internal string get_InitialContainerId();
    internal void set_InitialContainerId(string value);
    public int get_PreviousContainerIndex();
    public void set_PreviousContainerIndex(int value);
    internal int get_InitialContainerIndex();
    internal void set_InitialContainerIndex(int value);
    public Nullable`1<DateTime> get_LastActivationTimeStamp();
    public void set_LastActivationTimeStamp(Nullable`1<DateTime> value);
    public sealed virtual double get_FloatingWidth();
    public sealed virtual void set_FloatingWidth(double value);
    public sealed virtual double get_FloatingHeight();
    public sealed virtual void set_FloatingHeight(double value);
    public sealed virtual double get_FloatingLeft();
    public sealed virtual void set_FloatingLeft(double value);
    public sealed virtual double get_FloatingTop();
    public sealed virtual void set_FloatingTop(double value);
    public sealed virtual bool get_IsMaximized();
    public sealed virtual void set_IsMaximized(bool value);
    public object get_ToolTip();
    public void set_ToolTip(object value);
    public bool get_IsFloating();
    internal void set_IsFloating(bool value);
    public ImageSource get_IconSource();
    public void set_IconSource(ImageSource value);
    public bool get_CanClose();
    public void set_CanClose(bool value);
    public bool get_CanFloat();
    public void set_CanFloat(bool value);
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    protected virtual void OnParentChanging(ILayoutContainer oldValue, ILayoutContainer newValue);
    protected virtual void OnParentChanged(ILayoutContainer oldValue, ILayoutContainer newValue);
    public abstract virtual void Close();
    public sealed virtual XmlSchema GetSchema();
    public virtual void ReadXml(XmlReader reader);
    public virtual void WriteXml(XmlWriter writer);
    public sealed virtual int CompareTo(LayoutContent other);
    public void Float();
    public void DockAsDocument();
    public void Dock();
    internal bool TestCanClose();
    internal void CloseInternal();
    protected virtual void OnClosed();
    protected virtual void OnClosing(CancelEventArgs args);
    protected virtual void InternalDock();
    private void UpdateContainedFloatingWindowTaskbarTitle(bool newValue);
    [CompilerGeneratedAttribute]
public void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Closing(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Closing(EventHandler`1<CancelEventArgs> value);
    [CompilerGeneratedAttribute]
private bool <UpdateContainedFloatingWindowTaskbarTitle>b__136_0(LayoutFloatingWindowControl f);
    [CompilerGeneratedAttribute]
private bool <UpdateContainedFloatingWindowTaskbarTitle>b__136_1(LayoutContent l);
}
public class Xceed.Wpf.AvalonDock.Layout.LayoutDocument : LayoutContent {
    internal bool _canMove;
    private bool _isVisible;
    private string _description;
    public bool CanMove { get; public set; }
    public bool IsVisible { get; internal set; }
    public string Description { get; public set; }
    public bool get_CanMove();
    public void set_CanMove(bool value);
    public bool get_IsVisible();
    internal void set_IsVisible(bool value);
    public string get_Description();
    public void set_Description(string value);
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader);
    public virtual void Close();
    public virtual void ConsoleDump(int tab);
    protected virtual void InternalDock();
    internal bool CloseDocument();
}
[ContentPropertyAttribute("RootDocument")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutDocumentFloatingWindow : LayoutFloatingWindow {
    private LayoutDocument _rootDocument;
    [CompilerGeneratedAttribute]
private EventHandler RootDocumentChanged;
    public LayoutDocument RootDocument { get; public set; }
    public IEnumerable`1<ILayoutElement> Children { get; }
    public int ChildrenCount { get; }
    public bool IsValid { get; }
    public LayoutDocument get_RootDocument();
    public void set_RootDocument(LayoutDocument value);
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.Layout.LayoutDocumentFloatingWindow/<get_Children>d__6")]
public virtual IEnumerable`1<ILayoutElement> get_Children();
    public virtual void RemoveChild(ILayoutElement element);
    public virtual void ReplaceChild(ILayoutElement oldElement, ILayoutElement newElement);
    public virtual int get_ChildrenCount();
    public virtual bool get_IsValid();
    public virtual void ReadXml(XmlReader reader);
    public virtual void ConsoleDump(int tab);
    [CompilerGeneratedAttribute]
public void add_RootDocumentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RootDocumentChanged(EventHandler value);
}
[ContentPropertyAttribute("Children")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutDocumentPane : LayoutPositionableGroup`1<LayoutContent> {
    private bool _showHeader;
    private int _selectedIndex;
    private string _id;
    public bool ShowHeader { get; public set; }
    public int SelectedContentIndex { get; public set; }
    public LayoutContent SelectedContent { get; }
    public IEnumerable`1<LayoutContent> ChildrenSorted { get; }
    private string Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable.Id { get; private set; }
    public LayoutDocumentPane(LayoutContent firstChild);
    public bool get_ShowHeader();
    public void set_ShowHeader(bool value);
    public sealed virtual int get_SelectedContentIndex();
    public sealed virtual void set_SelectedContentIndex(int value);
    public sealed virtual LayoutContent get_SelectedContent();
    public IEnumerable`1<LayoutContent> get_ChildrenSorted();
    protected virtual bool GetVisibility();
    protected virtual void ChildMoved(int oldIndex, int newIndex);
    protected virtual void OnChildrenCollectionChanged();
    protected virtual void OnIsVisibleChanged();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader);
    public virtual void ConsoleDump(int tab);
    public sealed virtual int IndexOf(LayoutContent content);
    internal void SetNextSelectedIndex();
    private void UpdateParentVisibility();
    private sealed virtual override string Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable.get_Id();
    private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutPaneSerializable.set_Id(string value);
}
[ContentPropertyAttribute("Children")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutDocumentPaneGroup : LayoutPositionableGroup`1<ILayoutDocumentPane> {
    private Orientation _orientation;
    public Orientation Orientation { get; public set; }
    public LayoutDocumentPaneGroup(LayoutDocumentPane documentPane);
    public sealed virtual Orientation get_Orientation();
    public sealed virtual void set_Orientation(Orientation value);
    protected virtual bool GetVisibility();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader);
    public virtual void ConsoleDump(int tab);
}
public abstract class Xceed.Wpf.AvalonDock.Layout.LayoutElement : DependencyObject {
    private ILayoutContainer _parent;
    private ILayoutRoot _root;
    [CompilerGeneratedAttribute]
[XmlIgnoreAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
[XmlIgnoreAttribute]
private PropertyChangingEventHandler PropertyChanging;
    [XmlIgnoreAttribute]
public ILayoutContainer Parent { get; public set; }
    public ILayoutRoot Root { get; }
    public sealed virtual ILayoutContainer get_Parent();
    public void set_Parent(ILayoutContainer value);
    public sealed virtual ILayoutRoot get_Root();
    public virtual void ConsoleDump(int tab);
    protected virtual void OnParentChanging(ILayoutContainer oldValue, ILayoutContainer newValue);
    protected virtual void OnParentChanged(ILayoutContainer oldValue, ILayoutContainer newValue);
    protected virtual void OnRootChanged(ILayoutRoot oldRoot, ILayoutRoot newRoot);
    protected virtual void RaisePropertyChanged(string propertyName);
    protected virtual void RaisePropertyChanging(string propertyName);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
}
public class Xceed.Wpf.AvalonDock.Layout.LayoutElementEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private LayoutElement <Element>k__BackingField;
    public LayoutElement Element { get; private set; }
    public LayoutElementEventArgs(LayoutElement element);
    [CompilerGeneratedAttribute]
public LayoutElement get_Element();
    [CompilerGeneratedAttribute]
private void set_Element(LayoutElement value);
}
public abstract class Xceed.Wpf.AvalonDock.Layout.LayoutFloatingWindow : LayoutElement {
    public IEnumerable`1<ILayoutElement> Children { get; }
    public int ChildrenCount { get; }
    public bool IsValid { get; }
    public abstract virtual IEnumerable`1<ILayoutElement> get_Children();
    public abstract virtual int get_ChildrenCount();
    public abstract virtual bool get_IsValid();
    public abstract virtual void RemoveChild(ILayoutElement element);
    public abstract virtual void ReplaceChild(ILayoutElement oldElement, ILayoutElement newElement);
    public sealed virtual XmlSchema GetSchema();
    public abstract virtual void ReadXml(XmlReader reader);
    public virtual void WriteXml(XmlWriter writer);
}
public abstract class Xceed.Wpf.AvalonDock.Layout.LayoutGroup`1 : LayoutGroupBase {
    private ObservableCollection`1<T> _children;
    private bool _isVisible;
    public ObservableCollection`1<T> Children { get; }
    public bool IsVisible { get; protected set; }
    public int ChildrenCount { get; }
    private IEnumerable`1<ILayoutElement> Xceed.Wpf.AvalonDock.Layout.ILayoutContainer.Children { get; }
    public ObservableCollection`1<T> get_Children();
    public sealed virtual bool get_IsVisible();
    protected void set_IsVisible(bool value);
    public sealed virtual int get_ChildrenCount();
    protected virtual void OnParentChanged(ILayoutContainer oldValue, ILayoutContainer newValue);
    public sealed virtual void ComputeVisibility();
    public sealed virtual void MoveChild(int oldIndex, int newIndex);
    public sealed virtual void RemoveChildAt(int childIndex);
    public sealed virtual int IndexOfChild(ILayoutElement element);
    public sealed virtual void InsertChildAt(int index, ILayoutElement element);
    public sealed virtual void RemoveChild(ILayoutElement element);
    public sealed virtual void ReplaceChild(ILayoutElement oldElement, ILayoutElement newElement);
    public sealed virtual void ReplaceChildAt(int index, ILayoutElement element);
    public sealed virtual XmlSchema GetSchema();
    public virtual void ReadXml(XmlReader reader);
    public virtual void WriteXml(XmlWriter writer);
    protected virtual void OnIsVisibleChanged();
    protected abstract virtual bool GetVisibility();
    protected virtual void ChildMoved(int oldIndex, int newIndex);
    private void _children_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void UpdateParentVisibility();
    private Type FindType(string name);
    private sealed virtual override IEnumerable`1<ILayoutElement> Xceed.Wpf.AvalonDock.Layout.ILayoutContainer.get_Children();
}
public abstract class Xceed.Wpf.AvalonDock.Layout.LayoutGroupBase : LayoutElement {
    [CompilerGeneratedAttribute]
[XmlIgnoreAttribute]
private EventHandler ChildrenCollectionChanged;
    [CompilerGeneratedAttribute]
[XmlIgnoreAttribute]
private EventHandler`1<ChildrenTreeChangedEventArgs> ChildrenTreeChanged;
    protected virtual void OnChildrenCollectionChanged();
    protected void NotifyChildrenTreeChanged(ChildrenTreeChange change);
    protected virtual void OnChildrenTreeChanged(ChildrenTreeChange change);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ChildrenCollectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ChildrenCollectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ChildrenTreeChanged(EventHandler`1<ChildrenTreeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ChildrenTreeChanged(EventHandler`1<ChildrenTreeChangedEventArgs> value);
}
[ContentPropertyAttribute("Children")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutPanel : LayoutPositionableGroup`1<ILayoutPanelElement> {
    private Orientation _orientation;
    public Orientation Orientation { get; public set; }
    public LayoutPanel(ILayoutPanelElement firstChild);
    public sealed virtual Orientation get_Orientation();
    public sealed virtual void set_Orientation(Orientation value);
    protected virtual bool GetVisibility();
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader);
    public virtual void ConsoleDump(int tab);
}
public abstract class Xceed.Wpf.AvalonDock.Layout.LayoutPositionableGroup`1 : LayoutGroup`1<T> {
    private static GridLengthConverter _gridLengthConverter;
    private GridLength _dockWidth;
    private GridLength _dockHeight;
    private bool _allowDuplicateContent;
    private bool _canRepositionItems;
    private double _dockMinWidth;
    private double _dockMinHeight;
    private double _floatingWidth;
    private double _floatingHeight;
    private double _floatingLeft;
    private double _floatingTop;
    private bool _isMaximized;
    private double _actualWidth;
    private double _actualHeight;
    public GridLength DockWidth { get; public set; }
    public GridLength DockHeight { get; public set; }
    public bool AllowDuplicateContent { get; public set; }
    public bool CanRepositionItems { get; public set; }
    public double DockMinWidth { get; public set; }
    public double DockMinHeight { get; public set; }
    public double FloatingWidth { get; public set; }
    public double FloatingHeight { get; public set; }
    public double FloatingLeft { get; public set; }
    public double FloatingTop { get; public set; }
    public bool IsMaximized { get; public set; }
    private double Xceed.Wpf.AvalonDock.Layout.ILayoutPositionableElementWithActualSize.ActualWidth { get; private set; }
    private double Xceed.Wpf.AvalonDock.Layout.ILayoutPositionableElementWithActualSize.ActualHeight { get; private set; }
    private static LayoutPositionableGroup`1();
    public sealed virtual GridLength get_DockWidth();
    public sealed virtual void set_DockWidth(GridLength value);
    public sealed virtual GridLength get_DockHeight();
    public sealed virtual void set_DockHeight(GridLength value);
    public sealed virtual bool get_AllowDuplicateContent();
    public sealed virtual void set_AllowDuplicateContent(bool value);
    public bool get_CanRepositionItems();
    public void set_CanRepositionItems(bool value);
    public sealed virtual double get_DockMinWidth();
    public sealed virtual void set_DockMinWidth(double value);
    public sealed virtual double get_DockMinHeight();
    public sealed virtual void set_DockMinHeight(double value);
    public sealed virtual double get_FloatingWidth();
    public sealed virtual void set_FloatingWidth(double value);
    public sealed virtual double get_FloatingHeight();
    public sealed virtual void set_FloatingHeight(double value);
    public sealed virtual double get_FloatingLeft();
    public sealed virtual void set_FloatingLeft(double value);
    public sealed virtual double get_FloatingTop();
    public sealed virtual void set_FloatingTop(double value);
    public sealed virtual bool get_IsMaximized();
    public sealed virtual void set_IsMaximized(bool value);
    private sealed virtual override double Xceed.Wpf.AvalonDock.Layout.ILayoutPositionableElementWithActualSize.get_ActualWidth();
    private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutPositionableElementWithActualSize.set_ActualWidth(double value);
    private sealed virtual override double Xceed.Wpf.AvalonDock.Layout.ILayoutPositionableElementWithActualSize.get_ActualHeight();
    private sealed virtual override void Xceed.Wpf.AvalonDock.Layout.ILayoutPositionableElementWithActualSize.set_ActualHeight(double value);
    public virtual void WriteXml(XmlWriter writer);
    public virtual void ReadXml(XmlReader reader);
    protected virtual void OnDockWidthChanged();
    protected virtual void OnDockHeightChanged();
}
[ContentPropertyAttribute("RootPanel")]
public class Xceed.Wpf.AvalonDock.Layout.LayoutRoot : LayoutElement {
    private LayoutPanel _rootPanel;
    private LayoutAnchorSide _topSide;
    private LayoutAnchorSide _rightSide;
    private LayoutAnchorSide _leftSide;
    private LayoutAnchorSide _bottomSide;
    private ObservableCollection`1<LayoutFloatingWindow> _floatingWindows;
    private ObservableCollection`1<LayoutAnchorable> _hiddenAnchorables;
    private WeakReference _activeContent;
    private bool _activeContentSet;
    private WeakReference _lastFocusedDocument;
    private bool _lastFocusedDocumentSet;
    private DockingManager _manager;
    [CompilerGeneratedAttribute]
private EventHandler Updated;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayoutElementEventArgs> ElementAdded;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayoutElementEventArgs> ElementRemoved;
    public LayoutPanel RootPanel { get; public set; }
    public LayoutAnchorSide TopSide { get; public set; }
    public LayoutAnchorSide RightSide { get; public set; }
    public LayoutAnchorSide LeftSide { get; public set; }
    public LayoutAnchorSide BottomSide { get; public set; }
    public ObservableCollection`1<LayoutFloatingWindow> FloatingWindows { get; }
    public ObservableCollection`1<LayoutAnchorable> Hidden { get; }
    public IEnumerable`1<ILayoutElement> Children { get; }
    public int ChildrenCount { get; }
    [XmlIgnoreAttribute]
public LayoutContent ActiveContent { get; public set; }
    [XmlIgnoreAttribute]
public LayoutContent LastFocusedDocument { get; private set; }
    [XmlIgnoreAttribute]
public DockingManager Manager { get; internal set; }
    public sealed virtual LayoutPanel get_RootPanel();
    public void set_RootPanel(LayoutPanel value);
    public sealed virtual LayoutAnchorSide get_TopSide();
    public void set_TopSide(LayoutAnchorSide value);
    public sealed virtual LayoutAnchorSide get_RightSide();
    public void set_RightSide(LayoutAnchorSide value);
    public sealed virtual LayoutAnchorSide get_LeftSide();
    public void set_LeftSide(LayoutAnchorSide value);
    public sealed virtual LayoutAnchorSide get_BottomSide();
    public void set_BottomSide(LayoutAnchorSide value);
    public sealed virtual ObservableCollection`1<LayoutFloatingWindow> get_FloatingWindows();
    public sealed virtual ObservableCollection`1<LayoutAnchorable> get_Hidden();
    [IteratorStateMachineAttribute("Xceed.Wpf.AvalonDock.Layout.LayoutRoot/<get_Children>d__28")]
public sealed virtual IEnumerable`1<ILayoutElement> get_Children();
    public sealed virtual int get_ChildrenCount();
    public sealed virtual LayoutContent get_ActiveContent();
    public sealed virtual void set_ActiveContent(LayoutContent value);
    public LayoutContent get_LastFocusedDocument();
    private void set_LastFocusedDocument(LayoutContent value);
    public sealed virtual DockingManager get_Manager();
    internal void set_Manager(DockingManager value);
    public virtual void ConsoleDump(int tab);
    public sealed virtual void RemoveChild(ILayoutElement element);
    public sealed virtual void ReplaceChild(ILayoutElement oldElement, ILayoutElement newElement);
    public sealed virtual void CollectGarbage();
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void ReadXml(XmlReader reader);
    public sealed virtual void WriteXml(XmlWriter writer);
    internal static Type FindType(string name);
    internal void FireLayoutUpdated();
    internal void OnLayoutElementAdded(LayoutElement element);
    internal void OnLayoutElementRemoved(LayoutElement element);
    private void _floatingWindows_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void _hiddenAnchorables_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void InternalSetActiveContent(LayoutContent currentValue, LayoutContent newActiveContent);
    private void UpdateActiveContentProperty();
    private void FillLayoutAnchorSide(XmlReader reader, LayoutAnchorSide layoutAnchorSide);
    private List`1<ILayoutPanelElement> ReadRootPanel(XmlReader reader, Orientation& orientation);
    private List`1<object> ReadElementList(XmlReader reader, bool isFloatingWindow);
    private object ReadElement(XmlReader reader);
    [CompilerGeneratedAttribute]
public void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_ElementAdded(EventHandler`1<LayoutElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ElementAdded(EventHandler`1<LayoutElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ElementRemoved(EventHandler`1<LayoutElementEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ElementRemoved(EventHandler`1<LayoutElementEventArgs> value);
    [CompilerGeneratedAttribute]
private bool <CollectGarbage>b__48_1(ILayoutPreviousContainer c);
    [CompilerGeneratedAttribute]
private bool <CollectGarbage>b__48_2(ILayoutInitialContainer c);
    [CompilerGeneratedAttribute]
private bool <OnLayoutElementRemoved>b__55_0(LayoutContent c);
    [CompilerGeneratedAttribute]
private bool <OnLayoutElementRemoved>b__55_1(LayoutContent c);
}
public class Xceed.Wpf.AvalonDock.Layout.Serialization.LayoutSerializationCallbackEventArgs : CancelEventArgs {
    [CompilerGeneratedAttribute]
private LayoutContent <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    public LayoutContent Model { get; private set; }
    public object Content { get; public set; }
    public LayoutSerializationCallbackEventArgs(LayoutContent model, object previousContent);
    [CompilerGeneratedAttribute]
public LayoutContent get_Model();
    [CompilerGeneratedAttribute]
private void set_Model(LayoutContent value);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(object value);
}
public abstract class Xceed.Wpf.AvalonDock.Layout.Serialization.LayoutSerializer : object {
    private DockingManager _manager;
    private LayoutAnchorable[] _previousAnchorables;
    private LayoutDocument[] _previousDocuments;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayoutSerializationCallbackEventArgs> LayoutSerializationCallback;
    public DockingManager Manager { get; }
    public LayoutSerializer(DockingManager manager);
    public DockingManager get_Manager();
    [CompilerGeneratedAttribute]
public void add_LayoutSerializationCallback(EventHandler`1<LayoutSerializationCallbackEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayoutSerializationCallback(EventHandler`1<LayoutSerializationCallbackEventArgs> value);
    protected virtual void FixupLayout(LayoutRoot layout);
    protected void StartDeserialization();
    protected void EndDeserialization();
}
public class Xceed.Wpf.AvalonDock.Layout.Serialization.XmlLayoutSerializer : LayoutSerializer {
    public XmlLayoutSerializer(DockingManager manager);
    public void Serialize(XmlWriter writer);
    public void Serialize(TextWriter writer);
    public void Serialize(Stream stream);
    public void Serialize(string filepath);
    public void Deserialize(Stream stream);
    public void Deserialize(TextReader reader);
    public void Deserialize(XmlReader reader);
    public void Deserialize(string filepath);
}
internal class Xceed.Wpf.AvalonDock.LayoutEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private LayoutRoot <LayoutRoot>k__BackingField;
    public LayoutRoot LayoutRoot { get; private set; }
    public LayoutEventArgs(LayoutRoot layoutRoot);
    [CompilerGeneratedAttribute]
public LayoutRoot get_LayoutRoot();
    [CompilerGeneratedAttribute]
private void set_LayoutRoot(LayoutRoot value);
}
internal static class Xceed.Wpf.AvalonDock.MathHelper : object {
    public static double MinMax(double value, double min, double max);
    public static void AssertIsPositiveOrZero(double value);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class Xceed.Wpf.AvalonDock.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string Anchorable_AutoHide { get; }
    public static string Anchorable_BtnAutoHide_Hint { get; }
    public static string Anchorable_BtnClose_Hint { get; }
    public static string Anchorable_CxMenu_Hint { get; }
    public static string Anchorable_Dock { get; }
    public static string Anchorable_DockAsDocument { get; }
    public static string Anchorable_Float { get; }
    public static string Anchorable_Hide { get; }
    public static string Document_BtnPinned_Hint { get; }
    public static string Document_Close { get; }
    public static string Document_CloseAll { get; }
    public static string Document_CloseAllButThis { get; }
    public static string Document_CxMenu_Hint { get; }
    public static string Document_DockAsDocument { get; }
    public static string Document_Float { get; }
    public static string Document_MoveToNextTabGroup { get; }
    public static string Document_MoveToPreviousTabGroup { get; }
    public static string Document_NewHorizontalTabGroup { get; }
    public static string Document_NewVerticalTabGroup { get; }
    public static string Window_Maximize { get; }
    public static string Window_Restore { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_Anchorable_AutoHide();
    public static string get_Anchorable_BtnAutoHide_Hint();
    public static string get_Anchorable_BtnClose_Hint();
    public static string get_Anchorable_CxMenu_Hint();
    public static string get_Anchorable_Dock();
    public static string get_Anchorable_DockAsDocument();
    public static string get_Anchorable_Float();
    public static string get_Anchorable_Hide();
    public static string get_Document_BtnPinned_Hint();
    public static string get_Document_Close();
    public static string get_Document_CloseAll();
    public static string get_Document_CloseAllButThis();
    public static string get_Document_CxMenu_Hint();
    public static string get_Document_DockAsDocument();
    public static string get_Document_Float();
    public static string get_Document_MoveToNextTabGroup();
    public static string get_Document_MoveToPreviousTabGroup();
    public static string get_Document_NewHorizontalTabGroup();
    public static string get_Document_NewVerticalTabGroup();
    public static string get_Window_Maximize();
    public static string get_Window_Restore();
}
public abstract class Xceed.Wpf.AvalonDock.Themes.DictionaryTheme : Theme {
    [CompilerGeneratedAttribute]
private ResourceDictionary <ThemeResourceDictionary>k__BackingField;
    public ResourceDictionary ThemeResourceDictionary { get; private set; }
    public DictionaryTheme(ResourceDictionary themeResourceDictionary);
    [CompilerGeneratedAttribute]
public ResourceDictionary get_ThemeResourceDictionary();
    [CompilerGeneratedAttribute]
private void set_ThemeResourceDictionary(ResourceDictionary value);
    public virtual Uri GetResourceUri();
}
public class Xceed.Wpf.AvalonDock.Themes.GenericTheme : Theme {
    public virtual Uri GetResourceUri();
}
public abstract class Xceed.Wpf.AvalonDock.Themes.Theme : DependencyObject {
    public abstract virtual Uri GetResourceUri();
}
internal static class Xceed.Wpf.AvalonDock.Win32Helper : object {
    internal static int WS_CHILD;
    internal static int WS_VISIBLE;
    internal static int WS_VSCROLL;
    internal static int WS_BORDER;
    internal static int WS_CLIPSIBLINGS;
    internal static int WS_CLIPCHILDREN;
    internal static int WS_TABSTOP;
    internal static int WS_GROUP;
    internal static IntPtr HWND_TOPMOST;
    internal static IntPtr HWND_NOTOPMOST;
    internal static IntPtr HWND_TOP;
    internal static IntPtr HWND_BOTTOM;
    internal static int NCCALCSIZE;
    internal static int WM_WINDOWPOSCHANGED;
    internal static int WM_WINDOWPOSCHANGING;
    internal static int WM_NCMOUSEMOVE;
    internal static int WM_NCLBUTTONDOWN;
    internal static int WM_NCLBUTTONUP;
    internal static int WM_NCLBUTTONDBLCLK;
    internal static int WM_NCRBUTTONDOWN;
    internal static int WM_NCRBUTTONUP;
    internal static int WM_CAPTURECHANGED;
    internal static int WM_EXITSIZEMOVE;
    internal static int WM_ENTERSIZEMOVE;
    internal static int WM_MOVE;
    internal static int WM_MOVING;
    internal static int WM_KILLFOCUS;
    internal static int WM_SETFOCUS;
    internal static int WM_ACTIVATE;
    internal static int WM_NCHITTEST;
    internal static int WM_INITMENUPOPUP;
    internal static int WM_KEYDOWN;
    internal static int WM_KEYUP;
    internal static int WA_INACTIVE;
    internal static int WM_SYSCOMMAND;
    internal static int SC_MAXIMIZE;
    internal static int SC_RESTORE;
    internal static int WM_CREATE;
    internal static int HT_CAPTION;
    public static int HCBT_SETFOCUS;
    public static int HCBT_ACTIVATE;
    internal static UInt32 GW_HWNDNEXT;
    internal static UInt32 GW_HWNDPREV;
    internal static int WM_MOUSEMOVE;
    internal static int WM_LBUTTONDOWN;
    internal static int WM_LBUTTONUP;
    internal static int WM_LBUTTONDBLCLK;
    internal static int WM_RBUTTONDOWN;
    internal static int WM_RBUTTONUP;
    internal static int WM_RBUTTONDBLCLK;
    internal static int WM_MBUTTONDOWN;
    internal static int WM_MBUTTONUP;
    internal static int WM_MBUTTONDBLCLK;
    internal static int WM_MOUSEWHEEL;
    internal static int WM_MOUSEHWHEEL;
    private static Win32Helper();
    internal static IntPtr CreateWindowEx(int dwExStyle, string lpszClassName, string lpszWindowName, int style, int x, int y, int width, int height, IntPtr hwndParent, IntPtr hMenu, IntPtr hInst, object pvParam);
    internal static bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, SetWindowPosFlags uFlags);
    internal static bool IsChild(IntPtr hWndParent, IntPtr hwnd);
    internal static IntPtr SetFocus(IntPtr hWnd);
    public static IntPtr SetActiveWindow(IntPtr hWnd);
    internal static bool DestroyWindow(IntPtr hwnd);
    internal static int SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);
    internal static int PostMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);
    private static bool GetClientRect(IntPtr hWnd, RECT& lpRect);
    internal static bool GetWindowRect(IntPtr hWnd, RECT& lpRect);
    public static UInt32 GetCurrentThreadId();
    public static IntPtr SetWindowsHookEx(HookType code, HookProc func, IntPtr hInstance, int threadID);
    public static int UnhookWindowsHookEx(IntPtr hhook);
    public static int CallNextHookEx(IntPtr hhook, int code, IntPtr wParam, IntPtr lParam);
    internal static RECT GetClientRect(IntPtr hWnd);
    internal static RECT GetWindowRect(IntPtr hWnd);
    internal static IntPtr GetTopWindow(IntPtr hWnd);
    internal static IntPtr GetWindow(IntPtr hWnd, UInt32 uCmd);
    internal static int MakeLParam(int LoWord, int HiWord);
    internal static bool GetCursorPos(Win32Point& pt);
    internal static Point GetMousePosition();
    internal static bool IsWindowVisible(IntPtr hWnd);
    internal static bool IsWindowEnabled(IntPtr hWnd);
    internal static IntPtr GetFocus();
    internal static bool BringWindowToTop(IntPtr hWnd);
    internal static IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent);
    internal static IntPtr GetParent(IntPtr hWnd);
    private static int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);
    private static int GetWindowLong(IntPtr hWnd, int nIndex);
    public static void SetOwner(IntPtr childHandle, IntPtr ownerHandle);
    public static IntPtr GetOwner(IntPtr childHandle);
    public static IntPtr MonitorFromRect(RECT& lprc, UInt32 dwFlags);
    public static IntPtr MonitorFromWindow(IntPtr hwnd, UInt32 dwFlags);
    public static bool GetMonitorInfo(IntPtr hMonitor, MonitorInfo lpmi);
}
[ExtensionAttribute]
internal static class Xceed.Wpf.AvalonDock.WindowHelper : object {
    [ExtensionAttribute]
public static bool IsAttachedToPresentationSource(Visual element);
    [ExtensionAttribute]
public static void SetParentToMainWindowOf(Window window, Visual element);
    [ExtensionAttribute]
public static IntPtr GetParentWindowHandle(Window window);
    [ExtensionAttribute]
public static bool GetParentWindowHandle(Visual element, IntPtr& hwnd);
    [ExtensionAttribute]
public static void SetParentWindowToNull(Window window);
}
