public enum FParsec.Associativity : Enum {
    public int value__;
    public static Associativity None;
    public static Associativity Left;
    public static Associativity Right;
}
public static class FParsec.Buffer : object {
    internal static UInt32 SwapByteOrder(UInt32 value);
    internal static ulong SwapByteOrder(ulong value);
    internal static void SwapByteOrder(UInt32[] array);
    internal static Byte[] CopySubarray(Byte[] array, int index, int length);
    internal static UInt32[] CopyUIntsStoredInLittleEndianByteArray(Byte[] src, int srcIndex, int srcLength);
}
internal static class FParsec.CaseFoldTable : object {
    public static Char[] FoldedChars;
    private static string oneToOneMappings;
    private static CaseFoldTable();
    private static Char[] CreateFoldedCharsArray();
}
internal class FParsec.CharSet : object {
    private static int WordSize;
    private static int Log2WordSize;
    private int Min;
    private int Max;
    private int BitTableMin;
    private Int32[] BitTable;
    private string CharsNotInBitTable;
    public CharSet(string chars);
    public CharSet(string chars, int maxTableSize);
    public bool Contains(char value);
}
public class FParsec.CharStream : object {
    private static int DefaultByteBufferLength;
    private static int MinimumByteBufferLength;
    private static char EOS;
    public static char EndOfStreamChar;
    internal string String;
    internal int Idx;
    internal int IndexBegin;
    internal int IndexEnd;
    public UInt32 StateTag;
    internal long StringToStreamIndexOffset;
    internal long _Line;
    internal long _LineBegin;
    internal string _Name;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Encoding <Encoding>k__BackingField;
    public int BlockOverlap { get; }
    public int MinRegexSpace { get; public set; }
    public long IndexOfFirstChar { get; }
    public long IndexOfLastCharPlus1 { get; }
    public long Index { get; }
    public bool IsBeginOfStream { get; }
    public bool IsEndOfStream { get; }
    public long Line { get; }
    public long LineBegin { get; }
    public long Column { get; }
    public string Name { get; public set; }
    public Encoding Encoding { get; private set; }
    [DebuggerBrowsableAttribute("0")]
public Position Position { get; }
    [DebuggerBrowsableAttribute("0")]
public CharStreamIndexToken IndexToken { get; }
    internal CharStream(string chars);
    public CharStream(string chars, int index, int length);
    public CharStream(string chars, int index, int length, long streamBeginIndex);
    public CharStream(string path, Encoding encoding);
    public CharStream(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public CharStream(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int byteBufferLength);
    public CharStream(Stream stream, Encoding encoding);
    public CharStream(Stream stream, bool leaveOpen, Encoding encoding);
    public CharStream(Stream stream, bool leaveOpen, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public CharStream(Stream stream, bool leaveOpen, Encoding encoding, bool detectEncodingFromByteOrderMarks, int byteBufferLength);
    private static CharStream();
    public int get_BlockOverlap();
    public int get_MinRegexSpace();
    public void set_MinRegexSpace(int value);
    public long get_IndexOfFirstChar();
    public long get_IndexOfLastCharPlus1();
    public long get_Index();
    internal long GetIndex(int idx);
    public bool get_IsBeginOfStream();
    public bool get_IsEndOfStream();
    public long get_Line();
    public void SetLine_WithoutCheckAndWithoutIncrementingTheStateTag(long line);
    public long get_LineBegin();
    public void SetLineBegin_WithoutCheckAndWithoutIncrementingTheStateTag(long lineBegin);
    public long get_Column();
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
private void set_Encoding(Encoding value);
    public Position get_Position();
    private void StreamConstructorContinue(Stream stream, bool leaveOpen, Encoding encoding, bool detectEncodingFromByteOrderMarks, int byteBufferLength);
    public sealed virtual void Dispose();
    public static T ParseString(string chars, int index, int length, FSharpFunc`2<CharStream`1<TUserState>, T> parser, TUserState userState, string streamName);
    public void Seek(long index);
    public CharStreamIndexToken get_IndexToken();
    private void ThrowInvalidIndexToken();
    public void Seek(CharStreamIndexToken indexToken);
    public string ReadFrom(CharStreamIndexToken indexToken);
    internal string ReadFrom(int idx0);
    public void RegisterNewline();
    private void RegisterNewLineBegin(int stringLineBegin, int lineOffset);
    public void RegisterNewlines(int lineOffset, int newColumnMinus1);
    public void RegisterNewlines(long lineOffset, long newColumnMinus1);
    public char Peek();
    public void Skip();
    public char Read();
    public char SkipAndPeek();
    public TwoChars Peek2();
    public char Peek(UInt32 utf16Offset);
    public void Skip(UInt32 utf16Offset);
    public char SkipAndPeek(UInt32 utf16Offset);
    public char Peek(int utf16Offset);
    public void Skip(int utf16Offset);
    public void Skip(long utf16Offset);
    public char SkipAndPeek(int utf16Offset);
    public string PeekString(int length);
    public string Read(int length);
    public int PeekString(Char[] buffer, int bufferIndex, int length);
    public int Read(Char[] buffer, int bufferIndex, int length);
    private int Read(Char[] buffer, int bufferIndex, int length, bool backtrack);
    public bool Match(char ch);
    public bool MatchCaseFolded(char caseFoldedChar);
    public bool Skip(char ch);
    public bool SkipCaseFolded(char caseFoldedChar);
    public bool Skip(TwoChars twoChars);
    public bool Match(string chars);
    public bool Skip(string chars);
    public bool MatchCaseFolded(string caseFoldedChars);
    public bool SkipCaseFolded(string caseFoldedChars);
    public bool Match(Char[] chars, int charsIndex, int length);
    public bool Skip(Char[] chars, int charsIndex, int length);
    private bool Skip(Char[] chars, int charsIndex, int length, bool backtrackEvenIfCharsMatch);
    public Match Match(Regex regex);
    public bool SkipWhitespace();
    public bool SkipUnicodeWhitespace();
    public bool SkipNewline();
    public bool SkipUnicodeNewline();
    public int SkipNewlineThenWhitespace(int powerOf2TabStopDistance, bool allowFormFeed);
    public void SkipRestOfLine(bool skipNewline);
    public string ReadRestOfLine(bool skipNewline);
    public char ReadCharOrNewline();
    public int SkipCharsOrNewlines(int maxCharsOrNewlines);
    public string ReadCharsOrNewlines(int maxCharsOrNewlines, bool normalizeNewlinesInReturnString);
    public int SkipCharsOrNewlinesWhile(FSharpFunc`2<char, bool> f);
    public int SkipCharsOrNewlinesWhile(FSharpFunc`2<char, bool> f1, FSharpFunc`2<char, bool> f);
    public string ReadCharsOrNewlinesWhile(FSharpFunc`2<char, bool> f, bool normalizeNewlines);
    public string ReadCharsOrNewlinesWhile(FSharpFunc`2<char, bool> f1, FSharpFunc`2<char, bool> f, bool normalizeNewlinesInReturnString);
    public int SkipCharsOrNewlinesWhile(FSharpFunc`2<char, bool> f, int minCharsOrNewlines, int maxCharsOrNewlines);
    public int SkipCharsOrNewlinesWhile(FSharpFunc`2<char, bool> f1, FSharpFunc`2<char, bool> f, int minCharsOrNewlines, int maxCharsOrNewlines);
    public string ReadCharsOrNewlinesWhile(FSharpFunc`2<char, bool> f, int minCharsOrNewlines, int maxCharsOrNewlines, bool normalizeNewlinesInReturnString);
    public string ReadCharsOrNewlinesWhile(FSharpFunc`2<char, bool> f1, FSharpFunc`2<char, bool> f, int minCharsOrNewlines, int maxCharsOrNewlines, bool normalizeNewlinesInReturnString);
    private static bool RestOfStringEquals(string str1, int str1Index, string str2);
    private static bool RestOfStringEqualsCI(string str1, int str1Index, string cfStr2);
    public int SkipCharsOrNewlinesUntilString(string str, int maxCharsOrNewlines, Boolean& foundString);
    public int SkipCharsOrNewlinesUntilString(string str, int maxCharsOrNewlines, bool normalizeNewlinesInOutString, String& skippedCharsIfStringFoundOtherwiseNull);
    public int SkipCharsOrNewlinesUntilCaseFoldedString(string caseFoldedString, int maxCharsOrNewlines, Boolean& foundString);
    public int SkipCharsOrNewlinesUntilCaseFoldedString(string caseFoldedString, int maxCharsOrNewlines, bool normalizeNewlinesInOutString, String& skippedCharsIfStringFoundOtherwiseNull);
}
public class FParsec.CharStream`1 : CharStream {
    internal TUserState _UserState;
    public TUserState UserState { get; public set; }
    [DebuggerBrowsableAttribute("0")]
public CharStreamState`1<TUserState> State { get; }
    internal CharStream`1(string chars);
    public CharStream`1(string chars, int index, int length);
    public CharStream`1(string chars, int index, int length, long streamBeginIndex);
    public CharStream`1(string path, Encoding encoding);
    public CharStream`1(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public CharStream`1(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int byteBufferLength);
    public CharStream`1(Stream stream, Encoding encoding);
    public CharStream`1(Stream stream, bool leaveOpen, Encoding encoding);
    public CharStream`1(Stream stream, bool leaveOpen, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public CharStream`1(Stream stream, bool leaveOpen, Encoding encoding, bool detectEncodingFromByteOrderMarks, int byteBufferLength);
    public TUserState get_UserState();
    public void set_UserState(TUserState value);
    public CharStreamState`1<TUserState> get_State();
    private void ThrowInvalidState();
    public void BacktrackTo(CharStreamState`1<TUserState> state);
    public void BacktrackTo(CharStreamState`1& state);
    public string ReadFrom(CharStreamState`1<TUserState> stateWhereStringBegins, bool normalizeNewlines);
    public string ReadFrom(CharStreamState`1& state, bool normalizeNewlines);
    public CharStream`1<TSubStreamUserState> CreateSubstream(CharStreamState`1<TUserState> stateWhereSubstreamBegins);
    public CharStream`1<TSubStreamUserState> CreateSubstream(CharStreamState`1& stateWhereSubstreamBegins);
}
public class FParsec.CharStreamIndexToken : ValueType {
    private int IdxPlus1;
    internal int Idx { get; }
    internal CharStreamIndexToken(int idx);
    internal int get_Idx();
    private void ThrowInvalidIndexToken();
    public long GetIndex(CharStream charStreamFromWhichIndexTokenWasRetrieved);
}
public class FParsec.CharStreamState`1 : ValueType {
    internal int Idx;
    public UInt32 Tag;
    public long Line;
    public long LineBegin;
    public TUserState UserState;
    public string Name;
    public CharStreamIndexToken IndexToken { get; }
    public CharStreamState`1(CharStream`1<TUserState> charStream);
    private void ThrowInvalidState();
    public CharStreamIndexToken get_IndexToken();
    public long GetIndex(CharStream charStreamFromWhichStateWasRetrieved);
    public Position GetPosition(CharStream charStreamFromWhichStateWasRetrieved);
}
internal static class FParsec.CommonAssemblyInfo : object {
    public static string TestAssemblyName;
    public static string StrongNamePublicKey;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class FParsec.ErrorMessage : object {
    public ErrorMessageType Type;
    [DebuggerBrowsableAttribute("0")]
internal string String;
    internal static Comparer`1<ErrorMessage> Comparer;
    internal static ErrorMessage[] EmptyArray;
    internal ErrorMessage(ErrorMessageType messageType);
    private static ErrorMessage();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ErrorMessage other);
    public static bool op_Equality(ErrorMessage left, ErrorMessage right);
    public static bool op_Inequality(ErrorMessage left, ErrorMessage right);
    private bool EqualsHelper(ErrorMessage other);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
}
[DebuggerDisplayAttribute("{ErrorMessageList.GetDebuggerDisplay(this),nq}")]
[DebuggerTypeProxyAttribute("FParsec.ErrorMessageList/DebugView")]
public class FParsec.ErrorMessageList : object {
    public ErrorMessage Head;
    public ErrorMessageList Tail;
    public ErrorMessageList(ErrorMessage head, ErrorMessageList tail);
    public ErrorMessageList(ErrorMessage message);
    public ErrorMessageList(ErrorMessage message1, ErrorMessage message2);
    public static ErrorMessageList Merge(ErrorMessageList list1, ErrorMessageList list2);
    private static ErrorMessageList MergeContinue(ErrorMessageList list1, ErrorMessageList list2);
    public static HashSet`1<ErrorMessage> ToHashSet(ErrorMessageList messages);
    public static ErrorMessage[] ToSortedArray(ErrorMessageList messages);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ErrorMessageList other);
    public static bool op_Equality(ErrorMessageList left, ErrorMessageList right);
    public static bool op_Inequality(ErrorMessageList left, ErrorMessageList right);
    public virtual int GetHashCode();
    internal static string GetDebuggerDisplay(ErrorMessageList list);
}
public enum FParsec.ErrorMessageType : Enum {
    public int value__;
    public static ErrorMessageType Expected;
    public static ErrorMessageType ExpectedString;
    public static ErrorMessageType ExpectedCaseInsensitiveString;
    public static ErrorMessageType Unexpected;
    public static ErrorMessageType UnexpectedString;
    public static ErrorMessageType UnexpectedCaseInsensitiveString;
    public static ErrorMessageType Message;
    public static ErrorMessageType NestedError;
    public static ErrorMessageType CompoundError;
    public static ErrorMessageType Other;
}
internal static class FParsec.Errors : object {
    public static ErrorMessageList ExpectedEndOfInput;
    public static ErrorMessageList UnexpectedEndOfInput;
    public static ErrorMessageList ExpectedAnyChar;
    public static ErrorMessageList ExpectedWhitespace;
    public static ErrorMessageList ExpectedAsciiUppercaseLetter;
    public static ErrorMessageList ExpectedAsciiLowercaseLetter;
    public static ErrorMessageList ExpectedAsciiLetter;
    public static ErrorMessageList ExpectedUppercaseLetter;
    public static ErrorMessageList ExpectedLowercaseLetter;
    public static ErrorMessageList ExpectedLetter;
    public static ErrorMessageList ExpectedBinaryDigit;
    public static ErrorMessageList ExpectedOctalDigit;
    public static ErrorMessageList ExpectedDecimalDigit;
    public static ErrorMessageList ExpectedHexadecimalDigit;
    public static ErrorMessageList ExpectedNewline;
    public static ErrorMessageList UnexpectedNewline;
    public static ErrorMessageList ExpectedTab;
    public static ErrorMessageList ExpectedFloatingPointNumber;
    public static ErrorMessageList ExpectedInt64;
    public static ErrorMessageList ExpectedInt32;
    public static ErrorMessageList ExpectedInt16;
    public static ErrorMessageList ExpectedInt8;
    public static ErrorMessageList ExpectedUInt64;
    public static ErrorMessageList ExpectedUInt32;
    public static ErrorMessageList ExpectedUInt16;
    public static ErrorMessageList ExpectedUInt8;
    public static ErrorMessageList ExpectedPrefixOperator;
    public static ErrorMessageList ExpectedInfixOperator;
    public static ErrorMessageList ExpectedPostfixOperator;
    public static ErrorMessageList ExpectedInfixOrPostfixOperator;
    public static ErrorMessageList NumberOutsideOfDoubleRange;
    public static ErrorMessageList NumberOutsideOfInt64Range;
    public static ErrorMessageList NumberOutsideOfInt32Range;
    public static ErrorMessageList NumberOutsideOfInt16Range;
    public static ErrorMessageList NumberOutsideOfInt8Range;
    public static ErrorMessageList NumberOutsideOfUInt64Range;
    public static ErrorMessageList NumberOutsideOfUInt32Range;
    public static ErrorMessageList NumberOutsideOfUInt16Range;
    public static ErrorMessageList NumberOutsideOfUInt8Range;
    private static Errors();
    private static ErrorMessageList Expected(string str);
    private static ErrorMessageList Unexpected(string str);
    private static ErrorMessageList Message(string str);
    public static ErrorMessageList ExpectedAnyCharIn(string chars);
    public static ErrorMessageList ExpectedAnyCharNotIn(string chars);
    public static ErrorMessageList ExpectedStringMatchingRegex(string regexPattern);
    public static ErrorMessageList ExpectedAnySequenceOfNChars(int n);
    public static ErrorMessageList CouldNotFindString(string str);
    public static ErrorMessageList CouldNotFindCaseInsensitiveString(string str);
    public static ErrorMessageList OperatorsConflict(Position position1, Operator`3<T, W, U> operator1, Position position2, Operator`3<T, W, U> operator2);
    public static ErrorMessageList UnexpectedNonPrefixOperator(Operator`3<T, W, U> op);
    public static ErrorMessageList MissingTernary2ndString(Position position1, Position position2, Operator`3<T, W, U> op);
}
internal static class FParsec.FastGenericEqualityERComparer : object {
    public static EqualityComparer`1<T> Create();
}
internal static class FParsec.FastGenericEqualityERComparer`1 : object {
    public static EqualityComparer`1<T> Instance;
    private static FastGenericEqualityERComparer`1();
    public static bool Equals(T left, T right);
}
public static class FParsec.HexFloat : object {
    private static Byte[] asciiHexValuePlus1s;
    private static HexFloat();
    public static string DoubleToHexString(double x);
    public static string SingleToHexString(float x);
    public static double DoubleFromHexString(string str);
    public static float SingleFromHexString(string str);
}
public class FParsec.IdentifierValidator : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private NormalizationForm <NormalizationForm>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <NormalizeBeforeValidation>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <AllowJoinControlCharsAsIdContinueChars>k__BackingField;
    private IdentifierCharFlags[] AsciiCharOptions;
    private FSharpFunc`2<char, bool> isIdStartOrSurrogateFunc;
    private FSharpFunc`2<char, bool> isIdContinueOrSurrogateFunc;
    private FSharpFunc`2<char, bool> isIdContinueOrJoinControlOrSurrogateFunc;
    private static int XIdStartBmpTable1Offset;
    private static int XIdContinueBmpTable1Offset;
    private static int XIdContinueOrJoinerBmpTable1Offset;
    private static int XIdBmpTable1Size;
    private static int XIdBmpTable1Log2Length;
    private static int XIdBmpTable2Offset;
    private static int XIdBmpTable2Size;
    private static int XIdBmpTable2Log2BitBlockLength;
    private static int XIdStartSmpTable1Offset;
    private static int XIdContinueSmpTable1Offset;
    private static int XIdSmpTable1Size;
    private static int XIdSmpTable1Log2Length;
    private static int XIdSmpTable2Offset;
    private static int XIdSmpTable2Size;
    private static int XIdSmpTable2Log2BlockLength;
    private static int XIdSmpTable3Offset;
    private static int XIdSmpTable3Size;
    private static int XIdSmpTable3Log2BlockLength;
    private static Byte[] DataArray;
    private static Byte[] XIdStartBmpTable1;
    private static Byte[] XIdContinueBmpTable1;
    private static Byte[] XIdContinueOrJoinerBmpTable1;
    private static UInt32[] XIdBmpTable2;
    private static Byte[] XIdStartSmpTable1;
    private static Byte[] XIdContinueSmpTable1;
    private static Byte[] XIdSmpTable2;
    private static UInt32[] XIdSmpTable3;
    public NormalizationForm NormalizationForm { get; public set; }
    public bool NormalizeBeforeValidation { get; public set; }
    public bool AllowJoinControlCharsAsIdContinueChars { get; public set; }
    public FSharpFunc`2<char, bool> IsIdStartOrSurrogateFunc { get; }
    public FSharpFunc`2<char, bool> IsIdContinueOrSurrogateFunc { get; }
    public FSharpFunc`2<char, bool> IsIdContinueOrJoinControlOrSurrogateFunc { get; }
    internal IdentifierValidator(IdentifierCharFlags[] asciiCharOptions);
    private static IdentifierValidator();
    [CompilerGeneratedAttribute]
public NormalizationForm get_NormalizationForm();
    [CompilerGeneratedAttribute]
public void set_NormalizationForm(NormalizationForm value);
    [CompilerGeneratedAttribute]
public bool get_NormalizeBeforeValidation();
    [CompilerGeneratedAttribute]
public void set_NormalizeBeforeValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowJoinControlCharsAsIdContinueChars();
    [CompilerGeneratedAttribute]
public void set_AllowJoinControlCharsAsIdContinueChars(bool value);
    private void CheckAscii(char asciiChar);
    public void SetIsAsciiNoIdChar(char asciiChar);
    public void SetIsAsciiIdStartChar(char asciiChar);
    public void SetIsAsciiIdNonStartChar(char asciiChar);
    public string ValidateAndNormalize(string str, Int32& errorPosition);
    public FSharpFunc`2<char, bool> get_IsIdStartOrSurrogateFunc();
    public FSharpFunc`2<char, bool> get_IsIdContinueOrSurrogateFunc();
    public FSharpFunc`2<char, bool> get_IsIdContinueOrJoinControlOrSurrogateFunc();
    public static bool IsXIdStartOrSurrogate(char bmpCodePoint);
    private static UInt32 IsXIdStartOrSurrogate_(char bmpCodePoint);
    public static bool IsXIdContinueOrSurrogate(char bmpCodePoint);
    private static UInt32 IsXIdContinueOrSurrogate_(char bmpCodePoint);
    public static bool IsXIdContinueOrJoinControlOrSurrogate(char bmpCodePoint);
    private static UInt32 IsXIdContinueOrJoinControlOrSurrogate_(char bmpCodePoint);
    public static bool IsXIdStartSmp(int smpCodePointMinus0x10000);
    private static UInt32 IsXIdStartSmp_(int smpCodePointMinus0x10000);
    public static bool IsXIdContinueSmp(int smpCodePointMinus0x10000);
    private static UInt32 IsXIdContinueSmp_(int smpCodePointMinus0x10000);
}
public class FParsec.InfixOperator`3 : Operator`3<TTerm, TAfterString, TUserState> {
    public InfixOperator`3(string operatorString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterStringParser, int precedence, Associativity associativity, FSharpFunc`2<TTerm, FSharpFunc`2<TTerm, TTerm>> mapping);
    public InfixOperator`3(string operatorString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterStringParser, int precedence, Associativity associativity, Unit dummy, FSharpFunc`2<TAfterString, FSharpFunc`2<TTerm, FSharpFunc`2<TTerm, TTerm>>> mapping);
}
public static class FParsec.Internal.ParserCombinatorInInfiniteLoopHelper : object {
    public static Exception CreateException(string combinatorName, CharStream stream);
}
internal class FParsec.Many1Chars`1 : FSharpFunc`2<CharStream`1<TUserState>, Reply`1<string>> {
    protected FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> CharParser1;
    protected FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> CharParser;
    public FSharpFunc`2<CharStream`1<TUserState>, Reply`1<string>> AsFSharpFunc { get; }
    public Many1Chars`1(FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> charParser1, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> charParser);
    public virtual Reply`1<string> Invoke(CharStream`1<TUserState> stream);
    protected Reply`1<string> ParseRestOfString(CharStream`1<TUserState> stream, char firstChar, ErrorMessageList error);
    public FSharpFunc`2<CharStream`1<TUserState>, Reply`1<string>> get_AsFSharpFunc();
}
internal class FParsec.Many1CharsTill`3 : FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TResult>> {
    protected FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> CharParser1;
    protected FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> CharParser;
    protected FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TEnd>> EndParser;
    protected FSharpFunc`3<string, TEnd, TResult> Mapping;
    public FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TResult>> AsFSharpFunc { get; }
    public Many1CharsTill`3(FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> charParser1, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> charParser, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TEnd>> endParser, FSharpFunc`2<string, FSharpFunc`2<TEnd, TResult>> mapping);
    public virtual Reply`1<TResult> Invoke(CharStream`1<TUserState> stream);
    protected Reply`1<TResult> ParseRestOfString(CharStream`1<TUserState> stream, char firstChar, ErrorMessageList error);
    public FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TResult>> get_AsFSharpFunc();
}
internal class FParsec.ManyChars`1 : Many1Chars`1<TUserState> {
    public ManyChars`1(FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> charParser1, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> charParser);
    public virtual Reply`1<string> Invoke(CharStream`1<TUserState> stream);
}
internal class FParsec.ManyCharsTill`3 : Many1CharsTill`3<TUserState, TEnd, TResult> {
    public ManyCharsTill`3(FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> charParser1, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<char>> charParser, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TEnd>> endParser, FSharpFunc`2<string, FSharpFunc`2<TEnd, TResult>> mapping);
    public virtual Reply`1<TResult> Invoke(CharStream`1<TUserState> stream);
}
public class FParsec.Operator`3 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private OperatorType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <String>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> <AfterStringParser>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <TernaryRightString>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> <AfterTernaryRightStringParser>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Associativity <Associativity>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FSharpFunc`3<TAfterString, TTerm, TTerm> <Mapping1>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FSharpFunc`4<TAfterString, TTerm, TTerm, TTerm> <Mapping2>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FSharpFunc`6<TAfterString, TAfterString, TTerm, TTerm, TTerm, TTerm> <Mapping3>k__BackingField;
    internal static Operator`3<TTerm, TAfterString, TUserState> ZeroPrecedenceOperator;
    public OperatorType Type { get; private set; }
    public string String { get; protected set; }
    internal FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> AfterStringParser { get; private set; }
    public string TernaryRightString { get; protected set; }
    internal FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> AfterTernaryRightStringParser { get; private set; }
    public bool IsTernary { get; }
    public int Precedence { get; protected set; }
    public Associativity Associativity { get; protected set; }
    public bool IsAssociative { get; }
    internal FSharpFunc`3<TAfterString, TTerm, TTerm> Mapping1 { get; private set; }
    internal FSharpFunc`4<TAfterString, TTerm, TTerm, TTerm> Mapping2 { get; private set; }
    internal FSharpFunc`6<TAfterString, TAfterString, TTerm, TTerm, TTerm, TTerm> Mapping3 { get; private set; }
    private Operator`3(OperatorType type, string operatorString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterStringParser, int precedence);
    internal Operator`3(string operatorString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterStringParser, int precedence, Associativity associativity, FSharpFunc`2<TAfterString, FSharpFunc`2<TTerm, FSharpFunc`2<TTerm, TTerm>>> mapping);
    internal Operator`3(OperatorType type, string operatorString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterStringParser, int precedence, bool isAssociative, FSharpFunc`2<TAfterString, FSharpFunc`2<TTerm, TTerm>> mapping);
    internal Operator`3(string leftString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterLeftStringParser, string rightString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterRightStringParser, int precedence, Associativity associativity, FSharpFunc`2<TAfterString, FSharpFunc`2<TAfterString, FSharpFunc`2<TTerm, FSharpFunc`2<TTerm, FSharpFunc`2<TTerm, TTerm>>>>> mapping);
    private static Operator`3();
    [CompilerGeneratedAttribute]
public OperatorType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(OperatorType value);
    [CompilerGeneratedAttribute]
public string get_String();
    [CompilerGeneratedAttribute]
protected void set_String(string value);
    [CompilerGeneratedAttribute]
internal FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> get_AfterStringParser();
    [CompilerGeneratedAttribute]
private void set_AfterStringParser(FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> value);
    [CompilerGeneratedAttribute]
public string get_TernaryRightString();
    [CompilerGeneratedAttribute]
protected void set_TernaryRightString(string value);
    [CompilerGeneratedAttribute]
internal FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> get_AfterTernaryRightStringParser();
    [CompilerGeneratedAttribute]
private void set_AfterTernaryRightStringParser(FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> value);
    public bool get_IsTernary();
    [CompilerGeneratedAttribute]
public int get_Precedence();
    [CompilerGeneratedAttribute]
protected void set_Precedence(int value);
    [CompilerGeneratedAttribute]
public Associativity get_Associativity();
    [CompilerGeneratedAttribute]
protected void set_Associativity(Associativity value);
    public bool get_IsAssociative();
    [CompilerGeneratedAttribute]
internal FSharpFunc`3<TAfterString, TTerm, TTerm> get_Mapping1();
    [CompilerGeneratedAttribute]
private void set_Mapping1(FSharpFunc`3<TAfterString, TTerm, TTerm> value);
    [CompilerGeneratedAttribute]
internal FSharpFunc`4<TAfterString, TTerm, TTerm, TTerm> get_Mapping2();
    [CompilerGeneratedAttribute]
private void set_Mapping2(FSharpFunc`4<TAfterString, TTerm, TTerm, TTerm> value);
    [CompilerGeneratedAttribute]
internal FSharpFunc`6<TAfterString, TAfterString, TTerm, TTerm, TTerm, TTerm> get_Mapping3();
    [CompilerGeneratedAttribute]
private void set_Mapping3(FSharpFunc`6<TAfterString, TAfterString, TTerm, TTerm, TTerm, TTerm> value);
}
public class FParsec.OperatorPrecedenceParser`3 : FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TTerm>> {
    internal static int OpsArrayLength;
    private Operator`3[][] LhsOps;
    private Operator`3[][] RhsOps;
    private int PrefixOpCount;
    private int InfixOpCount;
    private int PostfixOpCount;
    private ErrorMessageList ExpectedInfixOrPostfixOperator;
    private Dictionary`2<string, Operator`3<TTerm, TAfterString, TUserState>> Reserved;
    private Operator`3<TTerm, TAfterString, TUserState> ErrorOp;
    private OperatorData<TTerm, TAfterString, TUserState> ZeroPrecedenceOperatorData;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TTerm>> <TermParser>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private FSharpFunc`2<Tuple`4<Position, Position, TernaryOperator`3<TTerm, TAfterString, TUserState>, TAfterString>, ErrorMessageList> <MissingTernary2ndStringErrorFormatter>k__BackingField;
    private FSharpFunc`3<Tuple`3<Position, Operator`3<TTerm, TAfterString, TUserState>, TAfterString>, Tuple`3<Position, Operator`3<TTerm, TAfterString, TUserState>, TAfterString>, ErrorMessageList> _OperatorConflictErrorFormatter;
    public FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TTerm>> TermParser { get; public set; }
    public FSharpFunc`2<Tuple`4<Position, Position, TernaryOperator`3<TTerm, TAfterString, TUserState>, TAfterString>, ErrorMessageList> MissingTernary2ndStringErrorFormatter { get; public set; }
    public FSharpFunc`2<Tuple`3<Position, Operator`3<TTerm, TAfterString, TUserState>, TAfterString>, FSharpFunc`2<Tuple`3<Position, Operator`3<TTerm, TAfterString, TUserState>, TAfterString>, ErrorMessageList>> OperatorConflictErrorFormatter { get; public set; }
    public FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TTerm>> ExpressionParser { get; }
    public IEnumerable`1<Operator`3<TTerm, TAfterString, TUserState>> Operators { get; }
    [CompilerGeneratedAttribute]
public FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TTerm>> get_TermParser();
    [CompilerGeneratedAttribute]
public void set_TermParser(FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TTerm>> value);
    [CompilerGeneratedAttribute]
public FSharpFunc`2<Tuple`4<Position, Position, TernaryOperator`3<TTerm, TAfterString, TUserState>, TAfterString>, ErrorMessageList> get_MissingTernary2ndStringErrorFormatter();
    [CompilerGeneratedAttribute]
public void set_MissingTernary2ndStringErrorFormatter(FSharpFunc`2<Tuple`4<Position, Position, TernaryOperator`3<TTerm, TAfterString, TUserState>, TAfterString>, ErrorMessageList> value);
    public FSharpFunc`2<Tuple`3<Position, Operator`3<TTerm, TAfterString, TUserState>, TAfterString>, FSharpFunc`2<Tuple`3<Position, Operator`3<TTerm, TAfterString, TUserState>, TAfterString>, ErrorMessageList>> get_OperatorConflictErrorFormatter();
    public void set_OperatorConflictErrorFormatter(FSharpFunc`2<Tuple`3<Position, Operator`3<TTerm, TAfterString, TUserState>, TAfterString>, FSharpFunc`2<Tuple`3<Position, Operator`3<TTerm, TAfterString, TUserState>, TAfterString>, ErrorMessageList>> value);
    public FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TTerm>> get_ExpressionParser();
    private bool FindPosition(Operator`3[][] ops, string str, Int32& arrayIndex, Int32& indexInArray);
    private void ThrowDefinitionConflictException(Operator`3<TTerm, TAfterString, TUserState> op, Operator`3<TTerm, TAfterString, TUserState> oldOp);
    public void AddOperator(Operator`3<TTerm, TAfterString, TUserState> op);
    public bool RemoveInfixOperator(string opString);
    public bool RemovePrefixOperator(string opString);
    public bool RemovePostfixOperator(string opString);
    public bool RemoveTernaryOperator(string opStringLeft, string opStringRight);
    public bool RemoveOperator(Operator`3<TTerm, TAfterString, TUserState> op);
    private bool Remove(OperatorType operatorType, string opString);
    public IEnumerable`1<Operator`3<TTerm, TAfterString, TUserState>> get_Operators();
    private Operator`3<TTerm, TAfterString, TUserState> PeekOp(CharStream`1<TUserState> stream, Operator`3[][] ops);
    public virtual Reply`1<TTerm> Invoke(CharStream`1<TUserState> stream);
    internal Operator`3<TTerm, TAfterString, TUserState> ParseExpression(OperatorData& prevOpData, Reply`1& reply, CharStream`1<TUserState> stream);
    private Operator`3<TTerm, TAfterString, TUserState> ParsePrefixOp(OperatorData& prevOpData, Operator`3<TTerm, TAfterString, TUserState> op, Reply`1& reply, CharStream`1<TUserState> stream);
    private Operator`3<TTerm, TAfterString, TUserState> ParseExpressionContinue(OperatorData& prevOpData, Operator`3<TTerm, TAfterString, TUserState> op, Reply`1& reply, CharStream`1<TUserState> stream);
    private void HandleMissingTernary2ndStringError(OperatorData& opData, Reply`1& reply, CharStream`1<TUserState> stream);
    private void HandlePossibleConflict(OperatorData& prevOpData, Operator`3<TTerm, TAfterString, TUserState> op, Reply`1& reply, CharStream`1<TUserState> stream);
    private void ReportConflict(OperatorData& prevOpData, Operator`3<TTerm, TAfterString, TUserState> op, TAfterString afterStringValue, Reply`1& reply, CharStream`1<TUserState> stream);
}
public enum FParsec.OperatorType : Enum {
    public int value__;
    public static OperatorType Infix;
    public static OperatorType Prefix;
    public static OperatorType Postfix;
}
public class FParsec.Position : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private long <Index>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private long <Line>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private long <Column>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <StreamName>k__BackingField;
    public long Index { get; private set; }
    public long Line { get; private set; }
    public long Column { get; private set; }
    public string StreamName { get; private set; }
    public Position(string streamName, long index, long line, long column);
    [CompilerGeneratedAttribute]
public long get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(long value);
    [CompilerGeneratedAttribute]
public long get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(long value);
    [CompilerGeneratedAttribute]
public long get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(long value);
    [CompilerGeneratedAttribute]
public string get_StreamName();
    [CompilerGeneratedAttribute]
private void set_StreamName(string value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Position other);
    public static bool op_Equality(Position left, Position right);
    public static bool op_Inequality(Position left, Position right);
    public virtual int GetHashCode();
    public static int Compare(Position left, Position right);
    public sealed virtual int CompareTo(Position other);
    private sealed virtual override int System.IComparable.CompareTo(object value);
}
public class FParsec.PostfixOperator`3 : Operator`3<TTerm, TAfterString, TUserState> {
    public PostfixOperator`3(string operatorString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterStringParser, int precedence, bool isAssociative, FSharpFunc`2<TTerm, TTerm> mapping);
    public PostfixOperator`3(string operatorString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterStringParser, int precedence, bool isAssociative, Unit dummy, FSharpFunc`2<TAfterString, FSharpFunc`2<TTerm, TTerm>> mapping);
}
public class FParsec.PrefixOperator`3 : Operator`3<TTerm, TAfterString, TUserState> {
    public PrefixOperator`3(string operatorString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterStringParser, int precedence, bool isAssociative, FSharpFunc`2<TTerm, TTerm> mapping);
    public PrefixOperator`3(string operatorString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterStringParser, int precedence, bool isAssociative, Unit dummy, FSharpFunc`2<TAfterString, FSharpFunc`2<TTerm, TTerm>> mapping);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class FParsec.Reply`1 : ValueType {
    public ErrorMessageList Error;
    public TResult Result;
    public ReplyStatus Status;
    public Reply`1(TResult result);
    public Reply`1(ReplyStatus status, ErrorMessageList error);
    public Reply`1(ReplyStatus status, TResult result, ErrorMessageList error);
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(Reply`1<TResult> other);
    public virtual int GetHashCode();
    public static bool op_Equality(Reply`1<TResult> r1, Reply`1<TResult> r2);
    public static bool op_Inequality(Reply`1<TResult> r1, Reply`1<TResult> r2);
    private string GetDebuggerDisplay();
}
public enum FParsec.ReplyStatus : Enum {
    public int value__;
    public static ReplyStatus Ok;
    public static ReplyStatus Error;
    public static ReplyStatus FatalError;
}
internal static class FParsec.Strings : object {
    public static string EndOfInput;
    public static string AnyChar;
    public static string Whitespace;
    public static string AsciiUppercaseLetter;
    public static string AsciiLowercaseLetter;
    public static string AsciiLetter;
    public static string UppercaseLetter;
    public static string LowercaseLetter;
    public static string Letter;
    public static string BinaryDigit;
    public static string OctalDigit;
    public static string DecimalDigit;
    public static string HexadecimalDigit;
    public static string Newline;
    public static string Tab;
    public static string FloatingPointNumber;
    public static string Int64;
    public static string Int32;
    public static string Int16;
    public static string Int8;
    public static string UInt64;
    public static string UInt32;
    public static string UInt16;
    public static string UInt8;
    public static string Identifier;
    public static string IdentifierContainsInvalidCharacterAtIndicatedPosition;
    public static string NumberOutsideOfDoubleRange;
    public static string NumberOutsideOfInt64Range;
    public static string NumberOutsideOfInt32Range;
    public static string NumberOutsideOfInt16Range;
    public static string NumberOutsideOfInt8Range;
    public static string NumberOutsideOfUInt64Range;
    public static string NumberOutsideOfUInt32Range;
    public static string NumberOutsideOfUInt16Range;
    public static string NumberOutsideOfUInt8Range;
    public static string InfixOperator;
    public static string TernaryOperator;
    public static string PrefixOperator;
    public static string PostfixOperator;
    private static string AnyCharIn1;
    private static string AnyCharIn2;
    private static string AnyCharNotIn1;
    private static string AnyCharNotIn2;
    private static string AnySequenceOfNChars1;
    private static string AnySequenceOfNChars2;
    private static string CouldNotFindString1;
    private static string CouldNotFindString2;
    private static string CouldNotFindCaseInsensitiveString1;
    private static string CouldNotFindCaseInsensitiveString2;
    private static string StringMatchingRegex1;
    private static string StringMatchingRegex2;
    private static string ErrorPositionStreamNameFormat;
    private static string ErrorPositionUnaccountedNewlinesFormat;
    private static string ErrorPositionUtf16ColumnFormat;
    private static string ErrorPositionFormat;
    public static string Note;
    public static string Expecting;
    public static string Unexpected;
    public static string Comma;
    public static string Or;
    public static string And;
    private static string CompoundCouldNotBeParsedBecauseFormat;
    public static string ParserBacktrackedAfter;
    public static string OtherErrors;
    public static string UnknownErrors;
    public static string Utf16ColumnCountOnlyCountsEachTabAs1Char;
    public static string ExactPositionBetweenCaretsDependsOnDisplayUnicodeCapabilities;
    public static string ErrorOccurredAtEndOfInputStream;
    public static string ErrorOccurredOnAnEmptyLine;
    public static string ErrorOccurredAtEndOfLine;
    public static string ErrorOccurredAtSecondCharInNewline;
    private static string NonAssociative;
    private static string LeftAssociative;
    private static string RightAssociative;
    private static string OperatorToStringFormat;
    private static string RelativePositionOnTheSameLine;
    private static string RelativePositionOnPreviousLine;
    private static string RelativePositionOnLineAbove;
    private static string RelativePositionOnDifferentLine;
    private static string RelativePositionInDifferentFile;
    private static string OperatorsConflictsFormat;
    private static string OperatorStringIsRightPartOfTernaryOperatorFormat;
    private static string ColumnCountAssumesTabStopDistanceOfNChars1;
    private static string ColumnCountAssumesTabStopDistanceOfNChars2;
    private static string ErrorOccurredAtNthCharInCombiningCharacterSequence1;
    private static string ErrorOccurredAtNthCharInCombiningCharacterSequence2;
    private static string ErrorOccurredAtNthCharInCombiningCharacterSequence3;
    private static string InputContainsAtLeastNUnaccountedNewlines1;
    private static string InputContainsAtLeastNUnaccountedNewlines2Singular;
    private static string InputContainsAtLeastNUnaccountedNewlines2Plural;
    private static string ErrorOccurredAtBeginningOfSurrogatePair1;
    private static string ErrorOccurredAtBeginningOfSurrogatePair2;
    private static string ErrorOccurredAtSecondCharInSurrogatePair1;
    private static string ErrorOccurredAtSecondCharInSurrogatePair2;
    private static string CharAtErrorPositionIsIsolatedHighSurrogate1;
    private static string CharAtErrorPositionIsIsolatedHighSurrogate2;
    private static string CharAtErrorPositionIsIsolatedLowSurrogate1;
    private static string CharAtErrorPositionIsIsolatedLowSurrogate2;
    private static string CharBeforeErrorPositionIsIsolatedHighSurrogate1;
    private static string CharBeforeErrorPositionIsIsolatedHighSurrogate2;
    private static string CharBeforeErrorPositionIsIsolatedLowSurrogate1;
    private static string CharBeforeErrorPositionIsIsolatedLowSurrogate2;
    private static Strings();
    internal static string Quote(string stringToQuote);
    internal static string Quote(string prefix, string stringToQuote, string postfix);
    internal static string AsciiQuote(string prefix, string stringToQuote, string postfix);
    internal static string QuoteCaseInsensitive(string caseInsensitiveStringToQuote);
    private static string OrdinalEnding(int value);
    public static string ErrorPosition(Position position);
    public static string ErrorPosition(Position position, int unaccountedNewlines, long column, long utf16Column);
    public static string CompoundCouldNotBeParsedBecause(string compoundLabel);
    public static string AnyCharIn(string chars);
    public static string AnyCharNotIn(string chars);
    public static string StringMatchingRegex(string regexPattern);
    public static string ExpectedAnySequenceOfNChars(int n);
    public static string CouldNotFindString(string str);
    public static string CouldNotFindCaseInsensitiveString(string str);
    internal static string OperatorToString(Operator`3<T, W, U> op);
    private static string RelativePosition(Position previousPosition, Position currentPosition);
    public static string OperatorsConflict(Position previousPosition, Operator`3<T, W, U> previousOperator, Position currentPosition, Operator`3<T, W, U> currentOperator);
    public static string OperatorStringIsRightPartOfTernaryOperator(Position position1, Position position2, Operator`3<T, W, U> op);
    public static string ColumnCountAssumesTabStopDistanceOfNChars(int n);
    public static string ErrorOccurredAtNthCharInCombiningCharacterSequence(int n, string textElement);
    public static string InputContainsAtLeastNUnaccountedNewlines(int n);
    public static string ErrorOccurredAtBeginningOfSurrogatePair(string surrogatePair);
    public static string ErrorOccurredAtSecondCharInSurrogatePair(string surrogatePair);
    public static string CharAtErrorPositionIsIsolatedHighSurrogate(char ch);
    public static string CharAtErrorPositionIsIsolatedLowSurrogate(char ch);
    public static string CharBeforeErrorPositionIsIsolatedHighSurrogate(char ch);
    public static string CharBeforeErrorPositionIsIsolatedLowSurrogate(char ch);
}
public class FParsec.TernaryOperator`3 : Operator`3<TTerm, TAfterString, TUserState> {
    public TernaryOperator`3(string leftString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterLeftStringParser, string rightString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterRightStringParser, int precedence, Associativity associativity, FSharpFunc`2<TTerm, FSharpFunc`2<TTerm, FSharpFunc`2<TTerm, TTerm>>> mapping);
    public TernaryOperator`3(string leftString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterLeftStringParser, string rightString, FSharpFunc`2<CharStream`1<TUserState>, Reply`1<TAfterString>> afterRightStringParser, int precedence, Associativity associativity, Unit dummy, FSharpFunc`2<TAfterString, FSharpFunc`2<TAfterString, FSharpFunc`2<TTerm, FSharpFunc`2<TTerm, FSharpFunc`2<TTerm, TTerm>>>>> mapping);
}
public static class FParsec.Text : object {
    internal static int DetectPreamble(Byte[] buffer, int count, Encoding& encoding, bool detectEncoding);
    public static string FoldCase(string str);
    public static char FoldCase(char ch);
    internal static int FindNewlineOrEOSChar(string str);
    public static string NormalizeNewlines(string str);
    internal static string CopyWithNormalizedNewlines(string src, int index, int length, int nCRLF, int nCR);
    public static int CountTextElements(string str);
    public static bool IsSurrogate(char ch);
    public static bool IsHighSurrogate(char ch);
    public static bool IsLowSurrogate(char ch);
    public static bool IsWhitespace(char ch);
    internal static string HexEscape(char c);
    internal static string EscapeChar(char c);
    internal static string Concat(string str0, string str1, string str2, string str3, string str4);
    internal static string Escape(string str, string prefix1, string prefix2, string postfix1, string postfix2, char escapedQuoteChar);
    internal static string AsciiEscape(string str, string prefix1, string prefix2, string postfix1, string postfix2, char escapedQuoteChar);
    internal static string SingleQuote(string str);
    internal static string SingleQuote(string prefix, string str, string postfix);
    internal static string DoubleQuote(string str);
    internal static string DoubleQuote(string prefix, string str, string postfix);
}
public class FParsec.TwoChars : ValueType {
    private UInt32 Chars;
    public char Char0 { get; }
    public char Char1 { get; }
    internal TwoChars(UInt32 chars);
    public TwoChars(char char0, char char1);
    public char get_Char0();
    public char get_Char1();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TwoChars other);
    public virtual int GetHashCode();
    public static bool op_Equality(TwoChars left, TwoChars right);
    public static bool op_Inequality(TwoChars left, TwoChars right);
}
