[CompilationMappingAttribute("3")]
internal class FSComp.SR : object {
    internal static Lazy`1<ResourceManager> resources;
    internal static Type funTyC;
    internal static bool swallowResourceText;
    internal static int init@14;
    internal static bool SwallowResourceText { get; internal set; }
    private static SR();
    internal static bool get_SwallowResourceText();
    internal static void set_SwallowResourceText(bool b);
    internal static string undefinedNameNamespace(string a0);
    internal static string undefinedNameNamespaceOrModule(string a0);
    internal static string undefinedNameFieldConstructorOrMember(string a0);
    internal static string undefinedNameValueConstructorNamespaceOrType(string a0);
    internal static string undefinedNameValueOfConstructor(string a0);
    internal static string undefinedNameValueNamespaceTypeOrModule(string a0);
    internal static string undefinedNameConstructorModuleOrNamespace(string a0);
    internal static string undefinedNameType(string a0);
    internal static string undefinedNameTypeIn(string a0, string a1);
    internal static string undefinedNameRecordLabelOrNamespace(string a0);
    internal static string undefinedNameRecordLabel(string a0);
    internal static string undefinedNameSuggestionsIntro();
    internal static string undefinedNameTypeParameter(string a0);
    internal static string undefinedNamePatternDiscriminator(string a0);
    internal static string replaceWithSuggestion(string a0);
    internal static string addIndexerDot();
    internal static string listElementHasWrongType(string a0, string a1);
    internal static string arrayElementHasWrongType(string a0, string a1);
    internal static string missingElseBranch(string a0);
    internal static string ifExpression(string a0, string a1);
    internal static string elseBranchHasWrongType(string a0, string a1);
    internal static string followingPatternMatchClauseHasWrongType(string a0, string a1);
    internal static string patternMatchGuardIsNotBool(string a0);
    internal static string commaInsteadOfSemicolonInRecord();
    internal static string derefInsteadOfNot();
    internal static string buildUnexpectedTypeArgs(string a0, int a1);
    internal static string returnUsedInsteadOfReturnBang();
    internal static string yieldUsedInsteadOfYieldBang();
    internal static string tupleRequiredInAbstractMethod();
    internal static Tuple`2<int, string> buildInvalidWarningNumber(string a0);
    internal static Tuple`2<int, string> buildInvalidVersionString(string a0);
    internal static Tuple`2<int, string> buildInvalidVersionFile(string a0);
    internal static string buildProductName(string a0);
    internal static string buildProductNameCommunity(string a0);
    internal static Tuple`2<int, string> buildProblemWithFilename(string a0, string a1);
    internal static Tuple`2<int, string> buildNoInputsSpecified();
    internal static Tuple`2<int, string> buildPdbRequiresDebug();
    internal static Tuple`2<int, string> buildInvalidSearchDirectory(string a0);
    internal static Tuple`2<int, string> buildSearchDirectoryNotFound(string a0);
    internal static Tuple`2<int, string> buildInvalidFilename(string a0);
    internal static Tuple`2<int, string> buildInvalidAssemblyName(string a0);
    internal static Tuple`2<int, string> buildInvalidPrivacy(string a0);
    internal static Tuple`2<int, string> buildMultipleReferencesNotAllowed(string a0);
    internal static Tuple`2<int, string> buildCannotReadAssembly(string a0);
    internal static Tuple`2<int, string> buildAssemblyResolutionFailed();
    internal static Tuple`2<int, string> buildImplicitModuleIsNotLegalIdentifier(string a0, string a1);
    internal static Tuple`2<int, string> buildMultiFileRequiresNamespaceOrModule();
    internal static Tuple`2<int, string> noEqualSignAfterModule();
    internal static Tuple`2<int, string> buildMultipleToplevelModules();
    internal static Tuple`2<int, string> buildOptionRequiresParameter(string a0);
    internal static Tuple`2<int, string> buildCouldNotFindSourceFile(string a0);
    internal static Tuple`2<int, string> buildInvalidSourceFileExtension(string a0);
    internal static Tuple`2<int, string> buildCouldNotResolveAssembly(string a0);
    internal static Tuple`2<int, string> buildCouldNotResolveAssemblyRequiredByFile(string a0, string a1);
    internal static Tuple`2<int, string> buildErrorOpeningBinaryFile(string a0, string a1);
    internal static Tuple`2<int, string> buildDifferentVersionMustRecompile(string a0);
    internal static Tuple`2<int, string> buildInvalidHashIDirective();
    internal static Tuple`2<int, string> buildInvalidHashrDirective();
    internal static Tuple`2<int, string> buildInvalidHashloadDirective();
    internal static Tuple`2<int, string> buildInvalidHashtimeDirective();
    internal static Tuple`2<int, string> buildDirectivesInModulesAreIgnored();
    internal static Tuple`2<int, string> buildSignatureAlreadySpecified(string a0);
    internal static Tuple`2<int, string> buildImplementationAlreadyGivenDetail(string a0);
    internal static Tuple`2<int, string> buildImplementationAlreadyGiven(string a0);
    internal static Tuple`2<int, string> buildSignatureWithoutImplementation(string a0);
    internal static Tuple`2<int, string> buildArgInvalidInt(string a0);
    internal static Tuple`2<int, string> buildArgInvalidFloat(string a0);
    internal static Tuple`2<int, string> buildUnrecognizedOption(string a0);
    internal static Tuple`2<int, string> buildInvalidModuleOrNamespaceName();
    internal static string pickleErrorReadingWritingMetadata(string a0, string a1);
    internal static Tuple`2<int, string> tastTypeOrModuleNotConcrete(string a0);
    internal static string tastTypeHasAssemblyCodeRepresentation(string a0);
    internal static Tuple`2<int, string> tastNamespaceAndModuleWithSameNameInAssembly(string a0);
    internal static Tuple`2<int, string> tastTwoModulesWithSameNameInAssembly(string a0);
    internal static Tuple`2<int, string> tastDuplicateTypeDefinitionInAssembly(string a0, string a1);
    internal static Tuple`2<int, string> tastConflictingModuleAndTypeDefinitionInAssembly(string a0, string a1);
    internal static Tuple`2<int, string> tastInvalidMemberSignature();
    internal static Tuple`2<int, string> tastValueDoesNotHaveSetterType();
    internal static Tuple`2<int, string> tastInvalidFormForPropertyGetter();
    internal static Tuple`2<int, string> tastInvalidFormForPropertySetter();
    internal static Tuple`2<int, string> tastUnexpectedByRef();
    internal static Tuple`2<int, string> tastValueMustBeMutable();
    internal static Tuple`2<int, string> tastInvalidMutationOfConstant();
    internal static string tastValueHasBeenCopied();
    internal static Tuple`2<int, string> tastRecursiveValuesMayNotBeInConstructionOfTuple();
    internal static Tuple`2<int, string> tastRecursiveValuesMayNotAppearInConstructionOfType(string a0);
    internal static Tuple`2<int, string> tastRecursiveValuesMayNotBeAssignedToNonMutableField(string a0, string a1);
    internal static string tastUnexpectedDecodeOfAutoOpenAttribute();
    internal static string tastUnexpectedDecodeOfInternalsVisibleToAttribute();
    internal static string tastUnexpectedDecodeOfInterfaceDataVersionAttribute();
    internal static Tuple`2<int, string> tastActivePatternsLimitedToSeven();
    internal static Tuple`2<int, string> tastNotAConstantExpression();
    internal static string ValueNotContainedMutabilityAttributesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityNamesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityCompiledNamesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityDisplayNamesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityAccessibilityMore(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityInlineFlagsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityLiteralConstantValuesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityOneIsTypeFunction(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityParameterCountsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityTypesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityExtensionsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityArityNotInferred(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityGenericParametersDiffer(string a0, string a1, string a2, string a3, string a4);
    internal static string ValueNotContainedMutabilityGenericParametersAreDifferentKinds(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityAritiesDiffer(string a0, string a1, string a2, string a3, string a4, string a5, string a6);
    internal static string ValueNotContainedMutabilityDotNetNamesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityStaticsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityVirtualsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityAbstractsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityFinalsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityOverridesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityOneIsConstructor(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityStaticButInstance(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityInstanceButStatic(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleNamesDiffer(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleMissingInterface(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationSaysNull(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureSaysNull(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationSealed(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleNumbersDiffer(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplDefinesStruct(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleTypeIsHidden(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleILDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleFieldWasPresent(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation(string a0, string a1);
    internal static string ModuleContainsConstructorButNamesDiffer(string a0, string a1);
    internal static string ModuleContainsConstructorButDataFieldsDiffer(string a0, string a1);
    internal static string ModuleContainsConstructorButTypesOfFieldsDiffer(string a0, string a1);
    internal static string ModuleContainsConstructorButAccessibilityDiffers(string a0, string a1);
    internal static string FieldNotContainedNamesDiffer(string a0, string a1);
    internal static string FieldNotContainedAccessibilitiesDiffer(string a0, string a1);
    internal static string FieldNotContainedStaticsDiffer(string a0, string a1);
    internal static string FieldNotContainedMutablesDiffer(string a0, string a1);
    internal static string FieldNotContainedLiteralsDiffer(string a0, string a1);
    internal static string FieldNotContainedTypesDiffer(string a0, string a1);
    internal static Tuple`2<int, string> typrelCannotResolveImplicitGenericInstantiation(string a0, string a1);
    internal static Tuple`2<int, string> typrelCannotResolveAmbiguityInPrintf();
    internal static Tuple`2<int, string> typrelCannotResolveAmbiguityInEnum();
    internal static Tuple`2<int, string> typrelCannotResolveAmbiguityInDelegate();
    internal static Tuple`2<int, string> typrelInvalidValue();
    internal static Tuple`2<int, string> typrelSigImplNotCompatibleParamCountsDiffer();
    internal static Tuple`2<int, string> typrelSigImplNotCompatibleCompileTimeRequirementsDiffer();
    internal static Tuple`2<int, string> typrelSigImplNotCompatibleConstraintsDiffer(string a0, string a1);
    internal static Tuple`2<int, string> typrelSigImplNotCompatibleConstraintsDifferRemove(string a0, string a1);
    internal static Tuple`2<int, string> typrelTypeImplementsIComparableShouldOverrideObjectEquals(string a0);
    internal static Tuple`2<int, string> typrelTypeImplementsIComparableDefaultObjectEqualsProvided(string a0);
    internal static Tuple`2<int, string> typrelExplicitImplementationOfGetHashCodeOrEquals(string a0);
    internal static Tuple`2<int, string> typrelExplicitImplementationOfGetHashCode(string a0);
    internal static Tuple`2<int, string> typrelExplicitImplementationOfEquals(string a0);
    internal static string ExceptionDefsNotCompatibleHiddenBySignature(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleDotNetRepresentationsDiffer(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleAbbreviationHiddenBySignature(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleSignaturesDiffer(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleExceptionDeclarationsDiffer(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleFieldInSigButNotImpl(string a0, string a1, string a2);
    internal static string ExceptionDefsNotCompatibleFieldInImplButNotSig(string a0, string a1, string a2);
    internal static string ExceptionDefsNotCompatibleFieldOrderDiffers(string a0, string a1);
    internal static Tuple`2<int, string> typrelModuleNamespaceAttributesDifferInSigAndImpl();
    internal static Tuple`2<int, string> typrelMethodIsOverconstrained();
    internal static Tuple`2<int, string> typrelOverloadNotFound(string a0, string a1);
    internal static Tuple`2<int, string> typrelOverrideWasAmbiguous(string a0);
    internal static Tuple`2<int, string> typrelMoreThenOneOverride(string a0);
    internal static Tuple`2<int, string> typrelMethodIsSealed(string a0);
    internal static Tuple`2<int, string> typrelOverrideImplementsMoreThenOneSlot(string a0, string a1, string a2);
    internal static Tuple`2<int, string> typrelDuplicateInterface();
    internal static Tuple`2<int, string> typrelNeedExplicitImplementation(string a0);
    internal static Tuple`2<int, string> typrelNamedArgumentHasBeenAssignedMoreThenOnce();
    internal static Tuple`2<int, string> typrelNoImplementationGiven(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenWithSuggestion(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenSeveral(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenSeveralWithSuggestion(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenSeveralTruncated(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenSeveralTruncatedWithSuggestion(string a0);
    internal static Tuple`2<int, string> typrelMemberDoesNotHaveCorrectNumberOfArguments(string a0, string a1);
    internal static Tuple`2<int, string> typrelMemberDoesNotHaveCorrectNumberOfTypeParameters(string a0, string a1);
    internal static Tuple`2<int, string> typrelMemberDoesNotHaveCorrectKindsOfGenericParameters(string a0, string a1);
    internal static Tuple`2<int, string> typrelMemberCannotImplement(string a0, string a1, string a2);
    internal static Tuple`2<int, string> astParseEmbeddedILError();
    internal static Tuple`2<int, string> astParseEmbeddedILTypeError();
    internal static string astDeprecatedIndexerNotation();
    internal static Tuple`2<int, string> astInvalidExprLeftHandOfAssignment();
    internal static Tuple`2<int, string> augNoRefEqualsOnStruct();
    internal static Tuple`2<int, string> augInvalidAttrs();
    internal static Tuple`2<int, string> augNoEqualityNeedsNoComparison();
    internal static Tuple`2<int, string> augStructCompNeedsStructEquality();
    internal static Tuple`2<int, string> augStructEqNeedsNoCompOrStructComp();
    internal static Tuple`2<int, string> augTypeCantHaveRefEqAndStructAttrs();
    internal static Tuple`2<int, string> augOnlyCertainTypesCanHaveAttrs();
    internal static Tuple`2<int, string> augRefEqCantHaveObjEquals();
    internal static Tuple`2<int, string> augCustomEqNeedsObjEquals();
    internal static Tuple`2<int, string> augCustomCompareNeedsIComp();
    internal static Tuple`2<int, string> augNoEqNeedsNoObjEquals();
    internal static Tuple`2<int, string> augNoCompCantImpIComp();
    internal static Tuple`2<int, string> augCustomEqNeedsNoCompOrCustomComp();
    internal static string forPositionalSpecifiersNotPermitted();
    internal static string forMissingFormatSpecifier();
    internal static string forFlagSetTwice(string a0);
    internal static string forPrefixFlagSpacePlusSetTwice();
    internal static string forHashSpecifierIsInvalid();
    internal static string forBadPrecision();
    internal static string forBadWidth();
    internal static string forDoesNotSupportZeroFlag(string a0);
    internal static string forPrecisionMissingAfterDot();
    internal static string forFormatDoesntSupportPrecision(string a0);
    internal static string forBadFormatSpecifier();
    internal static string forLIsUnnecessary();
    internal static string forHIsUnnecessary();
    internal static string forDoesNotSupportPrefixFlag(string a0, string a1);
    internal static string forBadFormatSpecifierGeneral(string a0);
    internal static string elSysEnvExitDidntExit();
    internal static string elDeprecatedOperator();
    internal static Tuple`2<int, string> chkProtectedOrBaseCalled();
    internal static Tuple`2<int, string> chkByrefUsedInInvalidWay(string a0);
    internal static Tuple`2<int, string> chkBaseUsedInInvalidWay();
    internal static string chkVariableUsedInInvalidWay(string a0);
    internal static Tuple`2<int, string> chkTypeLessAccessibleThanType(string a0, string a1);
    internal static Tuple`2<int, string> chkSystemVoidOnlyInTypeof();
    internal static Tuple`2<int, string> chkErrorUseOfByref();
    internal static Tuple`2<int, string> chkErrorContainsCallToRethrow();
    internal static Tuple`2<int, string> chkSplicingOnlyInQuotations();
    internal static Tuple`2<int, string> chkNoFirstClassSplicing();
    internal static Tuple`2<int, string> chkNoFirstClassAddressOf();
    internal static Tuple`2<int, string> chkNoFirstClassRethrow();
    internal static Tuple`2<int, string> chkNoByrefAtThisPoint(string a0);
    internal static Tuple`2<int, string> chkLimitationsOfBaseKeyword();
    internal static Tuple`2<int, string> chkObjCtorsCantUseExceptionHandling();
    internal static Tuple`2<int, string> chkNoAddressOfAtThisPoint(string a0);
    internal static Tuple`2<int, string> chkNoAddressStaticFieldAtThisPoint(string a0);
    internal static Tuple`2<int, string> chkNoAddressFieldAtThisPoint(string a0);
    internal static Tuple`2<int, string> chkNoAddressOfArrayElementAtThisPoint();
    internal static Tuple`2<int, string> chkFirstClassFuncNoByref();
    internal static Tuple`2<int, string> chkReturnTypeNoByref();
    internal static Tuple`2<int, string> chkInvalidCustAttrVal();
    internal static Tuple`2<int, string> chkAttrHasAllowMultiFalse(string a0);
    internal static Tuple`2<int, string> chkMemberUsedInInvalidWay(string a0, string a1, string a2);
    internal static Tuple`2<int, string> chkNoByrefAsTopValue();
    internal static Tuple`2<int, string> chkReflectedDefCantSplice();
    internal static Tuple`2<int, string> chkEntryPointUsage();
    internal static string chkUnionCaseCompiledForm();
    internal static string chkUnionCaseDefaultAugmentation();
    internal static Tuple`2<int, string> chkPropertySameNameMethod(string a0, string a1);
    internal static Tuple`2<int, string> chkGetterSetterDoNotMatchAbstract(string a0, string a1);
    internal static Tuple`2<int, string> chkPropertySameNameIndexer(string a0, string a1);
    internal static Tuple`2<int, string> chkCantStoreByrefValue();
    internal static Tuple`2<int, string> chkDuplicateMethod(string a0, string a1);
    internal static Tuple`2<int, string> chkDuplicateMethodWithSuffix(string a0, string a1);
    internal static Tuple`2<int, string> chkDuplicateMethodCurried(string a0, string a1);
    internal static Tuple`2<int, string> chkCurriedMethodsCantHaveOutParams();
    internal static Tuple`2<int, string> chkDuplicateProperty(string a0, string a1);
    internal static Tuple`2<int, string> chkDuplicatePropertyWithSuffix(string a0, string a1);
    internal static Tuple`2<int, string> chkDuplicateMethodInheritedType(string a0);
    internal static Tuple`2<int, string> chkDuplicateMethodInheritedTypeWithSuffix(string a0);
    internal static Tuple`2<int, string> chkMultipleGenericInterfaceInstantiations(string a0, string a1);
    internal static Tuple`2<int, string> chkValueWithDefaultValueMustHaveDefaultValue();
    internal static Tuple`2<int, string> chkNoByrefInTypeAbbrev();
    internal static Tuple`2<int, string> crefBoundVarUsedInSplice(string a0);
    internal static Tuple`2<int, string> crefQuotationsCantContainGenericExprs();
    internal static Tuple`2<int, string> crefQuotationsCantContainGenericFunctions();
    internal static Tuple`2<int, string> crefQuotationsCantContainObjExprs();
    internal static Tuple`2<int, string> crefQuotationsCantContainAddressOf();
    internal static Tuple`2<int, string> crefQuotationsCantContainStaticFieldRef();
    internal static Tuple`2<int, string> crefQuotationsCantContainInlineIL();
    internal static Tuple`2<int, string> crefQuotationsCantContainDescendingForLoops();
    internal static Tuple`2<int, string> crefQuotationsCantFetchUnionIndexes();
    internal static Tuple`2<int, string> crefQuotationsCantSetUnionFields();
    internal static Tuple`2<int, string> crefQuotationsCantSetExceptionFields();
    internal static Tuple`2<int, string> crefQuotationsCantRequireByref();
    internal static Tuple`2<int, string> crefQuotationsCantCallTraitMembers();
    internal static Tuple`2<int, string> crefQuotationsCantContainThisConstant();
    internal static Tuple`2<int, string> crefQuotationsCantContainThisPatternMatch();
    internal static Tuple`2<int, string> crefQuotationsCantContainArrayPatternMatching();
    internal static Tuple`2<int, string> crefQuotationsCantContainThisType();
    internal static string csTypeCannotBeResolvedAtCompileTime(string a0);
    internal static Tuple`2<int, string> csCodeLessGeneric();
    internal static Tuple`2<int, string> csTypeInferenceMaxDepth();
    internal static string csExpectedArguments();
    internal static string csIndexArgumentMismatch(int a0, int a1);
    internal static string csExpectTypeWithOperatorButGivenFunction(string a0);
    internal static string csExpectTypeWithOperatorButGivenTuple(string a0);
    internal static string csTypesDoNotSupportOperator(string a0, string a1);
    internal static string csTypeDoesNotSupportOperator(string a0, string a1);
    internal static string csTypesDoNotSupportOperatorNullable(string a0, string a1);
    internal static string csTypeDoesNotSupportOperatorNullable(string a0, string a1);
    internal static string csTypeDoesNotSupportConversion(string a0, string a1);
    internal static string csMethodFoundButIsStatic(string a0, string a1, string a2);
    internal static string csMethodFoundButIsNotStatic(string a0, string a1, string a2);
    internal static Tuple`2<int, string> csStructConstraintInconsistent();
    internal static string csTypeDoesNotHaveNull(string a0);
    internal static string csNullableTypeDoesNotHaveNull(string a0);
    internal static string csTypeDoesNotSupportComparison1(string a0);
    internal static string csTypeDoesNotSupportComparison2(string a0);
    internal static string csTypeDoesNotSupportComparison3(string a0);
    internal static string csTypeDoesNotSupportEquality1(string a0);
    internal static string csTypeDoesNotSupportEquality2(string a0);
    internal static string csTypeDoesNotSupportEquality3(string a0);
    internal static string csTypeIsNotEnumType(string a0);
    internal static string csTypeHasNonStandardDelegateType(string a0);
    internal static string csTypeIsNotDelegateType(string a0);
    internal static string csTypeParameterCannotBeNullable();
    internal static string csGenericConstructRequiresStructType(string a0);
    internal static string csGenericConstructRequiresUnmanagedType(string a0);
    internal static string csTypeNotCompatibleBecauseOfPrintf(string a0, string a1);
    internal static string csGenericConstructRequiresReferenceSemantics(string a0);
    internal static string csGenericConstructRequiresNonAbstract(string a0);
    internal static string csGenericConstructRequiresPublicDefaultConstructor(string a0);
    internal static Tuple`2<int, string> csTypeInstantiationLengthMismatch();
    internal static Tuple`2<int, string> csOptionalArgumentNotPermittedHere();
    internal static Tuple`2<int, string> csMemberIsNotStatic(string a0);
    internal static Tuple`2<int, string> csMemberIsNotInstance(string a0);
    internal static Tuple`2<int, string> csArgumentLengthMismatch();
    internal static Tuple`2<int, string> csArgumentTypesDoNotMatch();
    internal static Tuple`2<int, string> csMethodExpectsParams();
    internal static Tuple`2<int, string> csMemberIsNotAccessible(string a0, string a1);
    internal static Tuple`2<int, string> csMemberIsNotAccessible2(string a0, string a1);
    internal static Tuple`2<int, string> csMethodIsNotAStaticMethod(string a0);
    internal static Tuple`2<int, string> csMethodIsNotAnInstanceMethod(string a0);
    internal static string csMemberHasNoArgumentOrReturnProperty(string a0, string a1, string a2);
    internal static string csCtorHasNoArgumentOrReturnProperty(string a0, string a1, string a2);
    internal static Tuple`2<int, string> csRequiredSignatureIs(string a0);
    internal static Tuple`2<int, string> csMemberSignatureMismatch(string a0, int a1, string a2);
    internal static Tuple`2<int, string> csMemberSignatureMismatch2(string a0, int a1, string a2);
    internal static Tuple`2<int, string> csMemberSignatureMismatch3(string a0, int a1, string a2, string a3);
    internal static Tuple`2<int, string> csMemberSignatureMismatch4(string a0, int a1, string a2, string a3);
    internal static Tuple`2<int, string> csMemberSignatureMismatchArityNamed(string a0, int a1, int a2, int a3, string a4);
    internal static Tuple`2<int, string> csMemberSignatureMismatchArity(string a0, int a1, int a2, string a3);
    internal static Tuple`2<int, string> csCtorSignatureMismatchArity(string a0, int a1, int a2, string a3);
    internal static Tuple`2<int, string> csCtorSignatureMismatchArityProp(string a0, int a1, int a2, string a3);
    internal static Tuple`2<int, string> csMemberSignatureMismatchArityType(string a0, int a1, int a2, string a3);
    internal static Tuple`2<int, string> csMemberNotAccessible(string a0, int a1, string a2, int a3);
    internal static Tuple`2<int, string> csIncorrectGenericInstantiation(string a0, string a1, int a2);
    internal static Tuple`2<int, string> csMemberOverloadArityMismatch(string a0, int a1, int a2);
    internal static Tuple`2<int, string> csNoMemberTakesTheseArguments(string a0, string a1, int a2);
    internal static Tuple`2<int, string> csNoMemberTakesTheseArguments2(string a0, string a1, int a2, int a3);
    internal static Tuple`2<int, string> csNoMemberTakesTheseArguments3(string a0, string a1, int a2, string a3);
    internal static Tuple`2<int, string> csMethodNotFound(string a0);
    internal static string csNoOverloadsFound(string a0);
    internal static string csMethodIsOverloaded(string a0);
    internal static string csCandidates(string a0);
    internal static string csSeeAvailableOverloads();
    internal static Tuple`2<int, string> parsDoCannotHaveVisibilityDeclarations(string a0);
    internal static Tuple`2<int, string> parsEofInHashIf();
    internal static Tuple`2<int, string> parsEofInString();
    internal static Tuple`2<int, string> parsEofInVerbatimString();
    internal static Tuple`2<int, string> parsEofInComment();
    internal static Tuple`2<int, string> parsEofInStringInComment();
    internal static Tuple`2<int, string> parsEofInVerbatimStringInComment();
    internal static Tuple`2<int, string> parsEofInIfOcaml();
    internal static Tuple`2<int, string> parsEofInDirective();
    internal static Tuple`2<int, string> parsNoHashEndIfFound();
    internal static Tuple`2<int, string> parsAttributesIgnored();
    internal static Tuple`2<int, string> parsUseBindingsIllegalInImplicitClassConstructors();
    internal static Tuple`2<int, string> parsUseBindingsIllegalInModules();
    internal static Tuple`2<int, string> parsIntegerForLoopRequiresSimpleIdentifier();
    internal static Tuple`2<int, string> parsOnlyOneWithAugmentationAllowed();
    internal static Tuple`2<int, string> parsUnexpectedSemicolon();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFile();
    internal static Tuple`2<int, string> parsUnexpectedVisibilityDeclaration(string a0);
    internal static Tuple`2<int, string> parsOnlyHashDirectivesAllowed();
    internal static Tuple`2<int, string> parsVisibilityDeclarationsShouldComePriorToIdentifier();
    internal static Tuple`2<int, string> parsNamespaceOrModuleNotBoth();
    internal static Tuple`2<int, string> parsModuleAbbreviationMustBeSimpleName();
    internal static Tuple`2<int, string> parsIgnoreAttributesOnModuleAbbreviation();
    internal static Tuple`2<int, string> parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate(string a0);
    internal static Tuple`2<int, string> parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate(string a0);
    internal static Tuple`2<int, string> parsUnClosedBlockInHashLight();
    internal static Tuple`2<int, string> parsUnmatchedBeginOrStruct();
    internal static Tuple`2<int, string> parsModuleDefnMustBeSimpleName();
    internal static Tuple`2<int, string> parsUnexpectedEmptyModuleDefn();
    internal static string parsAttributesMustComeBeforeVal();
    internal static Tuple`2<int, string> parsAttributesAreNotPermittedOnInterfaceImplementations();
    internal static Tuple`2<int, string> parsSyntaxError();
    internal static Tuple`2<int, string> parsAugmentationsIllegalOnDelegateType();
    internal static Tuple`2<int, string> parsUnmatchedClassInterfaceOrStruct();
    internal static Tuple`2<int, string> parsEmptyTypeDefinition();
    internal static Tuple`2<int, string> parsUnmatchedWith();
    internal static Tuple`2<int, string> parsGetOrSetRequired();
    internal static Tuple`2<int, string> parsOnlyClassCanTakeValueArguments();
    internal static Tuple`2<int, string> parsUnmatchedBegin();
    internal static Tuple`2<int, string> parsInvalidDeclarationSyntax();
    internal static Tuple`2<int, string> parsGetAndOrSetRequired();
    internal static Tuple`2<int, string> parsTypeAnnotationsOnGetSet();
    internal static Tuple`2<int, string> parsGetterMustHaveAtLeastOneArgument();
    internal static Tuple`2<int, string> parsMultipleAccessibilitiesForGetSet();
    internal static Tuple`2<int, string> parsSetSyntax();
    internal static Tuple`2<int, string> parsInterfacesHaveSameVisibilityAsEnclosingType();
    internal static Tuple`2<int, string> parsAccessibilityModsIllegalForAbstract();
    internal static Tuple`2<int, string> parsAttributesIllegalOnInherit();
    internal static Tuple`2<int, string> parsVisibilityIllegalOnInherit();
    internal static Tuple`2<int, string> parsInheritDeclarationsCannotHaveAsBindings();
    internal static Tuple`2<int, string> parsAttributesIllegalHere();
    internal static Tuple`2<int, string> parsTypeAbbreviationsCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsEnumTypesCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsAllEnumFieldsRequireValues();
    internal static Tuple`2<int, string> parsInlineAssemblyCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsUnexpectedIdentifier(string a0);
    internal static Tuple`2<int, string> parsUnionCasesCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsEnumFieldsCannotHaveVisibilityDeclarations();
    internal static string parsConsiderUsingSeparateRecordType();
    internal static Tuple`2<int, string> parsRecordFieldsCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsLetAndForNonRecBindings();
    internal static Tuple`2<int, string> parsUnmatchedParen();
    internal static Tuple`2<int, string> parsSuccessivePatternsShouldBeSpacedOrTupled();
    internal static Tuple`2<int, string> parsNoMatchingInForLet();
    internal static Tuple`2<int, string> parsErrorInReturnForLetIncorrectIndentation();
    internal static Tuple`2<int, string> parsExpectedExpressionAfterLet(string a0, string a1);
    internal static Tuple`2<int, string> parsIncompleteIf();
    internal static Tuple`2<int, string> parsAssertIsNotFirstClassValue();
    internal static Tuple`2<int, string> parsIdentifierExpected();
    internal static Tuple`2<int, string> parsInOrEqualExpected();
    internal static Tuple`2<int, string> parsArrowUseIsLimited();
    internal static Tuple`2<int, string> parsSuccessiveArgsShouldBeSpacedOrTupled();
    internal static Tuple`2<int, string> parsUnmatchedBracket();
    internal static Tuple`2<int, string> parsMissingQualificationAfterDot();
    internal static string parsParenFormIsForML();
    internal static Tuple`2<int, string> parsMismatchedQuote(string a0);
    internal static Tuple`2<int, string> parsUnmatched(string a0);
    internal static Tuple`2<int, string> parsUnmatchedBracketBar();
    internal static Tuple`2<int, string> parsUnmatchedBrace();
    internal static Tuple`2<int, string> parsUnmatchedBraceBar();
    internal static Tuple`2<int, string> parsFieldBinding();
    internal static Tuple`2<int, string> parsMemberIllegalInObjectImplementation();
    internal static Tuple`2<int, string> parsMissingFunctionBody();
    internal static Tuple`2<int, string> parsSyntaxErrorInLabeledType();
    internal static Tuple`2<int, string> parsUnexpectedInfixOperator();
    internal static string parsMultiArgumentGenericTypeFormDeprecated();
    internal static Tuple`2<int, string> parsInvalidLiteralInType();
    internal static Tuple`2<int, string> parsUnexpectedOperatorForUnitOfMeasure();
    internal static Tuple`2<int, string> parsUnexpectedIntegerLiteralForUnitOfMeasure();
    internal static Tuple`2<int, string> parsUnexpectedTypeParameter();
    internal static Tuple`2<int, string> parsMismatchedQuotationName(string a0);
    internal static Tuple`2<int, string> parsActivePatternCaseMustBeginWithUpperCase();
    internal static Tuple`2<int, string> parsActivePatternCaseContainsPipe();
    internal static Tuple`2<int, string> parsIllegalDenominatorForMeasureExponent();
    internal static string parsNoEqualShouldFollowNamespace();
    internal static string parsSyntaxModuleStructEndDeprecated();
    internal static string parsSyntaxModuleSigEndDeprecated();
    internal static Tuple`2<int, string> tcStaticFieldUsedWhenInstanceFieldExpected();
    internal static Tuple`2<int, string> tcMethodNotAccessible(string a0);
    internal static Tuple`2<int, string> tcImplicitMeasureFollowingSlash();
    internal static Tuple`2<int, string> tcUnexpectedMeasureAnon();
    internal static Tuple`2<int, string> tcNonZeroConstantCannotHaveGenericUnit();
    internal static Tuple`2<int, string> tcSeqResultsUseYield();
    internal static string tcUnexpectedBigRationalConstant();
    internal static Tuple`2<int, string> tcInvalidTypeForUnitsOfMeasure();
    internal static string tcUnexpectedConstUint16Array();
    internal static string tcUnexpectedConstByteArray();
    internal static Tuple`2<int, string> tcParameterRequiresName();
    internal static Tuple`2<int, string> tcReturnValuesCannotHaveNames();
    internal static string tcMemberKindPropertyGetSetNotExpected();
    internal static Tuple`2<int, string> tcNamespaceCannotContainValues();
    internal static Tuple`2<int, string> tcNamespaceCannotContainExtensionMembers();
    internal static Tuple`2<int, string> tcMultipleVisibilityAttributes();
    internal static Tuple`2<int, string> tcMultipleVisibilityAttributesWithLet();
    internal static string tcInvalidMethodNameForRelationalOperator(string a0, string a1);
    internal static string tcInvalidMethodNameForEquality(string a0, string a1);
    internal static string tcInvalidMemberName(string a0, string a1);
    internal static string tcInvalidMemberNameFixedTypes(string a0);
    internal static string tcInvalidOperatorDefinitionRelational(string a0);
    internal static string tcInvalidOperatorDefinitionEquality(string a0);
    internal static string tcInvalidOperatorDefinition(string a0);
    internal static string tcInvalidIndexOperatorDefinition(string a0);
    internal static string tcExpectModuleOrNamespaceParent(string a0);
    internal static Tuple`2<int, string> tcImplementsIComparableExplicitly(string a0);
    internal static Tuple`2<int, string> tcImplementsGenericIComparableExplicitly(string a0);
    internal static Tuple`2<int, string> tcImplementsIStructuralComparableExplicitly(string a0);
    internal static Tuple`2<int, string> tcRecordFieldInconsistentTypes();
    internal static Tuple`2<int, string> tcDllImportStubsCannotBeInlined();
    internal static Tuple`2<int, string> tcStructsCanOnlyBindThisAtMemberDeclaration();
    internal static Tuple`2<int, string> tcUnexpectedExprAtRecInfPoint();
    internal static Tuple`2<int, string> tcLessGenericBecauseOfAnnotation(string a0, string a1);
    internal static Tuple`2<int, string> tcConstrainedTypeVariableCannotBeGeneralized();
    internal static Tuple`2<int, string> tcGenericParameterHasBeenConstrained(string a0);
    internal static Tuple`2<int, string> tcTypeParameterHasBeenConstrained(string a0);
    internal static Tuple`2<int, string> tcTypeParametersInferredAreNotStable();
    internal static Tuple`2<int, string> tcExplicitTypeParameterInvalid();
    internal static Tuple`2<int, string> tcOverridingMethodRequiresAllOrNoTypeParameters();
    internal static Tuple`2<int, string> tcFieldsDoNotDetermineUniqueRecordType();
    internal static Tuple`2<int, string> tcFieldAppearsTwiceInRecord(string a0);
    internal static Tuple`2<int, string> tcUnknownUnion();
    internal static Tuple`2<int, string> tcNotSufficientlyGenericBecauseOfScope(string a0);
    internal static Tuple`2<int, string> tcPropertyRequiresExplicitTypeParameters();
    internal static Tuple`2<int, string> tcConstructorCannotHaveTypeParameters();
    internal static Tuple`2<int, string> tcInstanceMemberRequiresTarget();
    internal static Tuple`2<int, string> tcUnexpectedPropertyInSyntaxTree();
    internal static Tuple`2<int, string> tcStaticInitializerRequiresArgument();
    internal static Tuple`2<int, string> tcObjectConstructorRequiresArgument();
    internal static Tuple`2<int, string> tcStaticMemberShouldNotHaveThis();
    internal static Tuple`2<int, string> tcExplicitStaticInitializerSyntax();
    internal static Tuple`2<int, string> tcExplicitObjectConstructorSyntax();
    internal static Tuple`2<int, string> tcUnexpectedPropertySpec();
    internal static string tcObjectExpressionFormDeprecated();
    internal static Tuple`2<int, string> tcInvalidDeclaration();
    internal static Tuple`2<int, string> tcAttributesInvalidInPatterns();
    internal static Tuple`2<int, string> tcFunctionRequiresExplicitTypeArguments(string a0);
    internal static Tuple`2<int, string> tcDoesNotAllowExplicitTypeArguments(string a0);
    internal static Tuple`2<int, string> tcTypeParameterArityMismatch(int a0, int a1);
    internal static Tuple`2<int, string> tcDefaultStructConstructorCall();
    internal static string tcCouldNotFindIDisposable();
    internal static Tuple`2<int, string> tcNonLiteralCannotBeUsedInPattern();
    internal static Tuple`2<int, string> tcFieldIsReadonly();
    internal static Tuple`2<int, string> tcNameArgumentsMustAppearLast();
    internal static Tuple`2<int, string> tcFunctionRequiresExplicitLambda(int a0);
    internal static Tuple`2<int, string> tcTypeCannotBeEnumerated(string a0);
    internal static Tuple`2<int, string> tcInvalidMixtureOfRecursiveForms();
    internal static Tuple`2<int, string> tcInvalidObjectConstructionExpression();
    internal static Tuple`2<int, string> tcInvalidConstraint();
    internal static Tuple`2<int, string> tcInvalidConstraintTypeSealed();
    internal static Tuple`2<int, string> tcInvalidEnumConstraint();
    internal static Tuple`2<int, string> tcInvalidNewConstraint();
    internal static Tuple`2<int, string> tcInvalidPropertyType();
    internal static Tuple`2<int, string> tcExpectedUnitOfMeasureMarkWithAttribute();
    internal static Tuple`2<int, string> tcExpectedTypeParameter();
    internal static Tuple`2<int, string> tcExpectedTypeNotUnitOfMeasure();
    internal static Tuple`2<int, string> tcExpectedUnitOfMeasureNotType();
    internal static Tuple`2<int, string> tcInvalidUnitsOfMeasurePrefix();
    internal static Tuple`2<int, string> tcUnitsOfMeasureInvalidInTypeConstructor();
    internal static Tuple`2<int, string> tcRequireBuilderMethod(string a0);
    internal static Tuple`2<int, string> tcTypeHasNoNestedTypes();
    internal static Tuple`2<int, string> tcUnexpectedSymbolInTypeExpression(string a0);
    internal static Tuple`2<int, string> tcTypeParameterInvalidAsTypeConstructor();
    internal static Tuple`2<int, string> tcIllegalSyntaxInTypeExpression();
    internal static Tuple`2<int, string> tcAnonymousUnitsOfMeasureCannotBeNested();
    internal static Tuple`2<int, string> tcAnonymousTypeInvalidInDeclaration();
    internal static Tuple`2<int, string> tcUnexpectedSlashInType();
    internal static Tuple`2<int, string> tcUnexpectedTypeArguments();
    internal static Tuple`2<int, string> tcOptionalArgsOnlyOnMembers();
    internal static Tuple`2<int, string> tcNameNotBoundInPattern(string a0);
    internal static Tuple`2<int, string> tcInvalidNonPrimitiveLiteralInPatternMatch();
    internal static Tuple`2<int, string> tcInvalidTypeArgumentUsage();
    internal static Tuple`2<int, string> tcRequireActivePatternWithOneResult();
    internal static Tuple`2<int, string> tcInvalidArgForParameterizedPattern();
    internal static Tuple`2<int, string> tcInvalidIndexIntoActivePatternArray();
    internal static Tuple`2<int, string> tcUnionCaseDoesNotTakeArguments();
    internal static Tuple`2<int, string> tcUnionCaseRequiresOneArgument();
    internal static Tuple`2<int, string> tcUnionCaseExpectsTupledArguments(int a0);
    internal static Tuple`2<int, string> tcFieldIsNotStatic(string a0);
    internal static Tuple`2<int, string> tcFieldNotLiteralCannotBeUsedInPattern();
    internal static Tuple`2<int, string> tcRequireVarConstRecogOrLiteral();
    internal static Tuple`2<int, string> tcInvalidPattern();
    internal static string tcUseWhenPatternGuard();
    internal static Tuple`2<int, string> tcIllegalPattern();
    internal static Tuple`2<int, string> tcSyntaxErrorUnexpectedQMark();
    internal static Tuple`2<int, string> tcExpressionCountMisMatch(int a0, int a1);
    internal static Tuple`2<int, string> tcExprUndelayed();
    internal static Tuple`2<int, string> tcExpressionRequiresSequence();
    internal static Tuple`2<int, string> tcInvalidObjectExpressionSyntaxForm();
    internal static Tuple`2<int, string> tcInvalidObjectSequenceOrRecordExpression();
    internal static Tuple`2<int, string> tcInvalidSequenceExpressionSyntaxForm();
    internal static string tcExpressionWithIfRequiresParenthesis();
    internal static Tuple`2<int, string> tcUnableToParseFormatString(string a0);
    internal static Tuple`2<int, string> tcListLiteralMaxSize();
    internal static Tuple`2<int, string> tcExpressionFormRequiresObjectConstructor();
    internal static Tuple`2<int, string> tcNamedArgumentsCannotBeUsedInMemberTraits();
    internal static Tuple`2<int, string> tcNotValidEnumCaseName();
    internal static Tuple`2<int, string> tcFieldIsNotMutable();
    internal static Tuple`2<int, string> tcConstructRequiresListArrayOrSequence();
    internal static Tuple`2<int, string> tcConstructRequiresComputationExpressions();
    internal static Tuple`2<int, string> tcConstructRequiresSequenceOrComputations();
    internal static Tuple`2<int, string> tcConstructRequiresComputationExpression();
    internal static Tuple`2<int, string> tcInvalidIndexerExpression();
    internal static Tuple`2<int, string> tcObjectOfIndeterminateTypeUsedRequireTypeConstraint();
    internal static Tuple`2<int, string> tcCannotInheritFromVariableType();
    internal static Tuple`2<int, string> tcObjectConstructorsOnTypeParametersCannotTakeArguments();
    internal static Tuple`2<int, string> tcCompiledNameAttributeMisused();
    internal static Tuple`2<int, string> tcNamedTypeRequired(string a0);
    internal static Tuple`2<int, string> tcInheritCannotBeUsedOnInterfaceType();
    internal static Tuple`2<int, string> tcNewCannotBeUsedOnInterfaceType();
    internal static Tuple`2<int, string> tcAbstractTypeCannotBeInstantiated();
    internal static Tuple`2<int, string> tcIDisposableTypeShouldUseNew();
    internal static Tuple`2<int, string> tcSyntaxCanOnlyBeUsedToCreateObjectTypes(string a0);
    internal static Tuple`2<int, string> tcConstructorRequiresCall(string a0);
    internal static Tuple`2<int, string> tcUndefinedField(string a0, string a1);
    internal static Tuple`2<int, string> tcFieldRequiresAssignment(string a0, string a1);
    internal static Tuple`2<int, string> tcExtraneousFieldsGivenValues();
    internal static Tuple`2<int, string> tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual();
    internal static Tuple`2<int, string> tcNoAbstractOrVirtualMemberFound(string a0);
    internal static Tuple`2<int, string> tcMemberFoundIsNotAbstractOrVirtual(string a0, string a1);
    internal static Tuple`2<int, string> tcArgumentArityMismatch(string a0, int a1, int a2, string a3, string a4);
    internal static Tuple`2<int, string> tcArgumentArityMismatchOneOverload(string a0, int a1, int a2, string a3, string a4);
    internal static Tuple`2<int, string> tcSimpleMethodNameRequired();
    internal static Tuple`2<int, string> tcPredefinedTypeCannotBeUsedAsSuperType();
    internal static Tuple`2<int, string> tcNewMustBeUsedWithNamedType();
    internal static Tuple`2<int, string> tcCannotCreateExtensionOfSealedType();
    internal static Tuple`2<int, string> tcNoArgumentsForRecordValue();
    internal static Tuple`2<int, string> tcNoInterfaceImplementationForConstructionExpression();
    internal static Tuple`2<int, string> tcObjectConstructionCanOnlyBeUsedInClassTypes();
    internal static Tuple`2<int, string> tcOnlySimpleBindingsCanBeUsedInConstructionExpressions();
    internal static Tuple`2<int, string> tcObjectsMustBeInitializedWithObjectExpression();
    internal static Tuple`2<int, string> tcExpectedInterfaceType();
    internal static Tuple`2<int, string> tcConstructorForInterfacesDoNotTakeArguments();
    internal static Tuple`2<int, string> tcConstructorRequiresArguments();
    internal static Tuple`2<int, string> tcNewRequiresObjectConstructor();
    internal static Tuple`2<int, string> tcAtLeastOneOverrideIsInvalid();
    internal static Tuple`2<int, string> tcNumericLiteralRequiresModule(string a0);
    internal static Tuple`2<int, string> tcInvalidRecordConstruction();
    internal static Tuple`2<int, string> tcExpressionFormRequiresRecordTypes();
    internal static Tuple`2<int, string> tcInheritedTypeIsNotObjectModelType();
    internal static Tuple`2<int, string> tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes();
    internal static Tuple`2<int, string> tcEmptyRecordInvalid();
    internal static Tuple`2<int, string> tcTypeIsNotARecordTypeNeedConstructor();
    internal static Tuple`2<int, string> tcTypeIsNotARecordType();
    internal static Tuple`2<int, string> tcConstructIsAmbiguousInComputationExpression();
    internal static Tuple`2<int, string> tcConstructIsAmbiguousInSequenceExpression();
    internal static Tuple`2<int, string> tcDoBangIllegalInSequenceExpression();
    internal static Tuple`2<int, string> tcUseForInSequenceExpression();
    internal static Tuple`2<int, string> tcTryIllegalInSequenceExpression();
    internal static Tuple`2<int, string> tcUseYieldBangForMultipleResults();
    internal static Tuple`2<int, string> tcInvalidAssignment();
    internal static Tuple`2<int, string> tcInvalidUseOfTypeName();
    internal static Tuple`2<int, string> tcTypeHasNoAccessibleConstructor();
    internal static Tuple`2<int, string> tcInvalidUseOfInterfaceType();
    internal static Tuple`2<int, string> tcInvalidUseOfDelegate();
    internal static Tuple`2<int, string> tcPropertyIsNotStatic(string a0);
    internal static Tuple`2<int, string> tcPropertyIsNotReadable(string a0);
    internal static Tuple`2<int, string> tcLookupMayNotBeUsedHere();
    internal static Tuple`2<int, string> tcPropertyIsStatic(string a0);
    internal static Tuple`2<int, string> tcPropertyCannotBeSet1(string a0);
    internal static Tuple`2<int, string> tcConstructorsCannotBeFirstClassValues();
    internal static Tuple`2<int, string> tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields();
    internal static Tuple`2<int, string> tcEventIsStatic(string a0);
    internal static Tuple`2<int, string> tcEventIsNotStatic(string a0);
    internal static Tuple`2<int, string> tcNamedArgumentDidNotMatch(string a0);
    internal static Tuple`2<int, string> tcOverloadsCannotHaveCurriedArguments();
    internal static string tcUnnamedArgumentsDoNotFormPrefix();
    internal static Tuple`2<int, string> tcStaticOptimizationConditionalsOnlyForFSharpLibrary();
    internal static Tuple`2<int, string> tcFormalArgumentIsNotOptional();
    internal static Tuple`2<int, string> tcInvalidOptionalAssignmentToPropertyOrField();
    internal static Tuple`2<int, string> tcDelegateConstructorMustBePassed();
    internal static Tuple`2<int, string> tcBindingCannotBeUseAndRec();
    internal static Tuple`2<int, string> tcVolatileOnlyOnClassLetBindings();
    internal static Tuple`2<int, string> tcAttributesAreNotPermittedOnLetBindings();
    internal static Tuple`2<int, string> tcDefaultValueAttributeRequiresVal();
    internal static Tuple`2<int, string> tcConditionalAttributeRequiresMembers();
    internal static Tuple`2<int, string> tcInvalidActivePatternName();
    internal static Tuple`2<int, string> tcEntryPointAttributeRequiresFunctionInModule();
    internal static Tuple`2<int, string> tcMutableValuesCannotBeInline();
    internal static Tuple`2<int, string> tcMutableValuesMayNotHaveGenericParameters();
    internal static Tuple`2<int, string> tcMutableValuesSyntax();
    internal static Tuple`2<int, string> tcOnlyFunctionsCanBeInline();
    internal static Tuple`2<int, string> tcIllegalAttributesForLiteral();
    internal static Tuple`2<int, string> tcLiteralCannotBeMutable();
    internal static Tuple`2<int, string> tcLiteralCannotBeInline();
    internal static Tuple`2<int, string> tcLiteralCannotHaveGenericParameters();
    internal static Tuple`2<int, string> tcInvalidConstantExpression();
    internal static Tuple`2<int, string> tcTypeIsInaccessible();
    internal static Tuple`2<int, string> tcUnexpectedConditionInImportedAssembly();
    internal static Tuple`2<int, string> tcUnrecognizedAttributeTarget();
    internal static Tuple`2<int, string> tcAttributeIsNotValidForLanguageElementUseDo();
    internal static Tuple`2<int, string> tcAttributeIsNotValidForLanguageElement();
    internal static Tuple`2<int, string> tcOptionalArgumentsCannotBeUsedInCustomAttribute();
    internal static Tuple`2<int, string> tcPropertyCannotBeSet0();
    internal static Tuple`2<int, string> tcPropertyOrFieldNotFoundInAttribute();
    internal static Tuple`2<int, string> tcCustomAttributeMustBeReferenceType();
    internal static Tuple`2<int, string> tcCustomAttributeArgumentMismatch();
    internal static Tuple`2<int, string> tcCustomAttributeMustInvokeConstructor();
    internal static Tuple`2<int, string> tcAttributeExpressionsMustBeConstructorCalls();
    internal static Tuple`2<int, string> tcUnsupportedAttribute();
    internal static Tuple`2<int, string> tcInvalidInlineSpecification();
    internal static Tuple`2<int, string> tcInvalidUseBinding();
    internal static Tuple`2<int, string> tcAbstractMembersIllegalInAugmentation();
    internal static Tuple`2<int, string> tcMethodOverridesIllegalHere();
    internal static Tuple`2<int, string> tcNoMemberFoundForOverride();
    internal static Tuple`2<int, string> tcOverrideArityMismatch(string a0);
    internal static Tuple`2<int, string> tcDefaultImplementationAlreadyExists();
    internal static Tuple`2<int, string> tcDefaultAmbiguous();
    internal static Tuple`2<int, string> tcNoPropertyFoundForOverride();
    internal static Tuple`2<int, string> tcAbstractPropertyMissingGetOrSet(string a0);
    internal static Tuple`2<int, string> tcInvalidSignatureForSet();
    internal static Tuple`2<int, string> tcNewMemberHidesAbstractMember(string a0);
    internal static Tuple`2<int, string> tcNewMemberHidesAbstractMemberWithSuffix(string a0);
    internal static Tuple`2<int, string> tcStaticInitializersIllegalInInterface();
    internal static Tuple`2<int, string> tcObjectConstructorsIllegalInInterface();
    internal static Tuple`2<int, string> tcMemberOverridesIllegalInInterface();
    internal static Tuple`2<int, string> tcConcreteMembersIllegalInInterface();
    internal static Tuple`2<int, string> tcConstructorsDisallowedInExceptionAugmentation();
    internal static Tuple`2<int, string> tcStructsCannotHaveConstructorWithNoArguments();
    internal static Tuple`2<int, string> tcConstructorsIllegalForThisType();
    internal static Tuple`2<int, string> tcRecursiveBindingsWithMembersMustBeDirectAugmentation();
    internal static Tuple`2<int, string> tcOnlySimplePatternsInLetRec();
    internal static Tuple`2<int, string> tcOnlyRecordFieldsAndSimpleLetCanBeMutable();
    internal static Tuple`2<int, string> tcMemberIsNotSufficientlyGeneric();
    internal static Tuple`2<int, string> tcLiteralAttributeRequiresConstantValue();
    internal static Tuple`2<int, string> tcValueInSignatureRequiresLiteralAttribute();
    internal static Tuple`2<int, string> tcThreadStaticAndContextStaticMustBeStatic();
    internal static Tuple`2<int, string> tcVolatileFieldsMustBeMutable();
    internal static Tuple`2<int, string> tcUninitializedValFieldsMustBeMutable();
    internal static Tuple`2<int, string> tcStaticValFieldsMustBeMutableAndPrivate();
    internal static Tuple`2<int, string> tcFieldRequiresName();
    internal static Tuple`2<int, string> tcInvalidNamespaceModuleTypeUnionName();
    internal static Tuple`2<int, string> tcIllegalFormForExplicitTypeDeclaration();
    internal static Tuple`2<int, string> tcReturnTypesForUnionMustBeSameAsType();
    internal static Tuple`2<int, string> tcInvalidEnumerationLiteral();
    internal static Tuple`2<int, string> tcTypeIsNotInterfaceType1(string a0);
    internal static Tuple`2<int, string> tcDuplicateSpecOfInterface();
    internal static Tuple`2<int, string> tcFieldValIllegalHere();
    internal static Tuple`2<int, string> tcInheritIllegalHere();
    internal static Tuple`2<int, string> tcModuleRequiresQualifiedAccess(string a0);
    internal static Tuple`2<int, string> tcOpenUsedWithPartiallyQualifiedPath(string a0);
    internal static Tuple`2<int, string> tcLocalClassBindingsCannotBeInline();
    internal static Tuple`2<int, string> tcTypeAbbreviationsMayNotHaveMembers();
    internal static string tcTypeAbbreviationsCheckedAtCompileTime();
    internal static Tuple`2<int, string> tcEnumerationsMayNotHaveMembers();
    internal static Tuple`2<int, string> tcMeasureDeclarationsRequireStaticMembers();
    internal static string tcStructsMayNotContainDoBindings();
    internal static Tuple`2<int, string> tcStructsMayNotContainLetBindings();
    internal static Tuple`2<int, string> tcStaticLetBindingsRequireClassesWithImplicitConstructors();
    internal static Tuple`2<int, string> tcMeasureDeclarationsRequireStaticMembersNotConstructors();
    internal static Tuple`2<int, string> tcMemberAndLocalClassBindingHaveSameName(string a0);
    internal static Tuple`2<int, string> tcTypeAbbreviationsCannotHaveInterfaceDeclaration();
    internal static Tuple`2<int, string> tcEnumerationsCannotHaveInterfaceDeclaration();
    internal static Tuple`2<int, string> tcTypeIsNotInterfaceType0();
    internal static Tuple`2<int, string> tcAllImplementedInterfacesShouldBeDeclared();
    internal static Tuple`2<int, string> tcDefaultImplementationForInterfaceHasAlreadyBeenAdded();
    internal static Tuple`2<int, string> tcMemberNotPermittedInInterfaceImplementation();
    internal static Tuple`2<int, string> tcDeclarationElementNotPermittedInAugmentation();
    internal static Tuple`2<int, string> tcTypesCannotContainNestedTypes();
    internal static string tcTypeExceptionOrModule();
    internal static string tcTypeOrModule();
    internal static Tuple`2<int, string> tcImplementsIStructuralEquatableExplicitly(string a0);
    internal static Tuple`2<int, string> tcImplementsIEquatableExplicitly(string a0);
    internal static Tuple`2<int, string> tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors();
    internal static Tuple`2<int, string> tcExceptionAbbreviationsShouldNotHaveArgumentList();
    internal static Tuple`2<int, string> tcAbbreviationsFordotNetExceptionsCannotTakeArguments();
    internal static Tuple`2<int, string> tcExceptionAbbreviationsMustReferToValidExceptions();
    internal static Tuple`2<int, string> tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor();
    internal static Tuple`2<int, string> tcNotAnException();
    internal static Tuple`2<int, string> tcInvalidModuleName();
    internal static Tuple`2<int, string> tcInvalidTypeExtension();
    internal static Tuple`2<int, string> tcAttributesOfTypeSpecifyMultipleKindsForType();
    internal static Tuple`2<int, string> tcKindOfTypeSpecifiedDoesNotMatchDefinition();
    internal static Tuple`2<int, string> tcMeasureDefinitionsCannotHaveTypeParameters();
    internal static Tuple`2<int, string> tcTypeRequiresDefinition();
    internal static string tcTypeAbbreviationHasTypeParametersMissingOnType();
    internal static Tuple`2<int, string> tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes();
    internal static Tuple`2<int, string> tcTypesCannotInheritFromMultipleConcreteTypes();
    internal static Tuple`2<int, string> tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute();
    internal static Tuple`2<int, string> tcAllowNullTypesMayOnlyInheritFromAllowNullTypes();
    internal static Tuple`2<int, string> tcGenericTypesCannotHaveStructLayout();
    internal static Tuple`2<int, string> tcOnlyStructsCanHaveStructLayout();
    internal static Tuple`2<int, string> tcRepresentationOfTypeHiddenBySignature();
    internal static Tuple`2<int, string> tcOnlyClassesCanHaveAbstract();
    internal static Tuple`2<int, string> tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure();
    internal static Tuple`2<int, string> tcOverridesCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedDU();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedRecord();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedAssemblyCode();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedStruct();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedDelegate();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedEnum();
    internal static Tuple`2<int, string> tcInterfaceTypesAndDelegatesCannotContainFields();
    internal static Tuple`2<int, string> tcAbbreviatedTypesCannotBeSealed();
    internal static Tuple`2<int, string> tcCannotInheritFromSealedType();
    internal static Tuple`2<int, string> tcCannotInheritFromInterfaceType();
    internal static Tuple`2<int, string> tcStructTypesCannotContainAbstractMembers();
    internal static Tuple`2<int, string> tcInterfaceTypesCannotBeSealed();
    internal static Tuple`2<int, string> tcInvalidDelegateSpecification();
    internal static Tuple`2<int, string> tcDelegatesCannotBeCurried();
    internal static Tuple`2<int, string> tcInvalidTypeForLiteralEnumeration();
    internal static Tuple`2<int, string> tcTypeDefinitionIsCyclic();
    internal static Tuple`2<int, string> tcTypeDefinitionIsCyclicThroughInheritance();
    internal static string tcReservedSyntaxForAugmentation();
    internal static Tuple`2<int, string> tcMembersThatExtendInterfaceMustBePlacedInSeparateModule();
    internal static Tuple`2<int, string> tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(string a0);
    internal static Tuple`2<int, string> tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit();
    internal static Tuple`2<int, string> tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers();
    internal static Tuple`2<int, string> tcInheritDeclarationMissingArguments();
    internal static Tuple`2<int, string> tcInheritConstructionCallNotPartOfImplicitSequence();
    internal static Tuple`2<int, string> tcLetAndDoRequiresImplicitConstructionSequence();
    internal static Tuple`2<int, string> tcTypeAbbreviationsCannotHaveAugmentations();
    internal static Tuple`2<int, string> tcModuleAbbreviationForNamespace(string a0);
    internal static Tuple`2<int, string> tcTypeUsedInInvalidWay(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcMemberUsedInInvalidWay(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcAttributeAutoOpenWasIgnored(string a0, string a1);
    internal static Tuple`2<int, string> ilUndefinedValue(string a0);
    internal static Tuple`2<int, string> ilLabelNotFound(string a0);
    internal static Tuple`2<int, string> ilIncorrectNumberOfTypeArguments();
    internal static string ilDynamicInvocationNotSupported(string a0);
    internal static Tuple`2<int, string> ilAddressOfLiteralFieldIsInvalid();
    internal static Tuple`2<int, string> ilAddressOfValueHereIsInvalid(string a0);
    internal static Tuple`2<int, string> ilCustomMarshallersCannotBeUsedInFSharp();
    internal static Tuple`2<int, string> ilMarshalAsAttributeCannotBeDecoded();
    internal static Tuple`2<int, string> ilSignatureForExternalFunctionContainsTypeParameters();
    internal static Tuple`2<int, string> ilDllImportAttributeCouldNotBeDecoded();
    internal static Tuple`2<int, string> ilLiteralFieldsCannotBeSet();
    internal static Tuple`2<int, string> ilStaticMethodIsNotLambda(string a0);
    internal static Tuple`2<int, string> ilMutableVariablesCannotEscapeMethod();
    internal static Tuple`2<int, string> ilUnexpectedUnrealizedValue();
    internal static Tuple`2<int, string> ilMainModuleEmpty();
    internal static Tuple`2<int, string> ilTypeCannotBeUsedForLiteralField();
    internal static Tuple`2<int, string> ilUnexpectedGetSetAnnotation();
    internal static Tuple`2<int, string> ilFieldOffsetAttributeCouldNotBeDecoded();
    internal static Tuple`2<int, string> ilStructLayoutAttributeCouldNotBeDecoded();
    internal static Tuple`2<int, string> ilDefaultAugmentationAttributeCouldNotBeDecoded();
    internal static Tuple`2<int, string> ilReflectedDefinitionsCannotUseSliceOperator();
    internal static Tuple`2<int, string> optsProblemWithCodepage(int a0, string a1);
    internal static string optsCopyright();
    internal static string optsCopyrightCommunity();
    internal static string optsNameOfOutputFile();
    internal static string optsBuildConsole();
    internal static string optsBuildWindows();
    internal static string optsBuildLibrary();
    internal static string optsBuildModule();
    internal static string optsDelaySign();
    internal static string optsPublicSign();
    internal static string optsWriteXml();
    internal static string optsStrongKeyFile();
    internal static string optsStrongKeyContainer();
    internal static string optsPlatform();
    internal static string optsNoOpt();
    internal static string optsNoInterface();
    internal static string optsSig();
    internal static string optsReference();
    internal static string optsWin32res();
    internal static string optsWin32manifest();
    internal static string optsNowin32manifest();
    internal static string optsEmbedAllSource();
    internal static string optsEmbedSource();
    internal static string optsSourceLink();
    internal static Tuple`2<int, string> optsEmbeddedSourceRequirePortablePDBs();
    internal static Tuple`2<int, string> optsSourceLinkRequirePortablePDBs();
    internal static string srcFileTooLarge();
    internal static string optsResource();
    internal static string optsLinkresource();
    internal static string optsDebugPM();
    internal static string optsDebug(string a0);
    internal static string optsOptimize();
    internal static string optsTailcalls();
    internal static string optsDeterministic();
    internal static string optsPathMap();
    internal static string optsCrossoptimize();
    internal static string optsWarnaserrorPM();
    internal static string optsWarnaserror();
    internal static string optsWarn();
    internal static string optsNowarn();
    internal static string optsWarnOn();
    internal static string optsChecked();
    internal static string optsDefine();
    internal static string optsMlcompatibility();
    internal static string optsNologo();
    internal static string optsHelp();
    internal static string optsResponseFile();
    internal static string optsCodepage();
    internal static string optsUtf8output();
    internal static string optsFullpaths();
    internal static string optsLib();
    internal static string optsBaseaddress();
    internal static string optsChecksumAlgorithm();
    internal static string optsNoframework();
    internal static string optsStandalone();
    internal static string optsStaticlink();
    internal static string optsResident();
    internal static string optsPdb();
    internal static string optsSimpleresolution();
    internal static Tuple`2<int, string> optsUnrecognizedTarget(string a0);
    internal static Tuple`2<int, string> optsUnrecognizedDebugType(string a0);
    internal static Tuple`2<int, string> optsInvalidWarningLevel(int a0);
    internal static string optsShortFormOf(string a0);
    internal static string optsClirootDeprecatedMsg();
    internal static string optsClirootDescription();
    internal static string optsHelpBannerOutputFiles();
    internal static string optsHelpBannerInputFiles();
    internal static string optsHelpBannerResources();
    internal static string optsHelpBannerCodeGen();
    internal static string optsHelpBannerAdvanced();
    internal static string optsHelpBannerMisc();
    internal static string optsHelpBannerLanguage();
    internal static string optsHelpBannerErrsAndWarns();
    internal static Tuple`2<int, string> optsUnknownArgumentToTheTestSwitch(string a0);
    internal static Tuple`2<int, string> optsUnknownPlatform(string a0);
    internal static Tuple`2<int, string> optsUnknownChecksumAlgorithm(string a0);
    internal static string optsInternalNoDescription(string a0);
    internal static string optsDCLONoDescription(string a0);
    internal static string optsDCLODeprecatedSuggestAlternative(string a0, string a1);
    internal static string optsDCLOHtmlDoc(string a0);
    internal static string optsConsoleColors();
    internal static string optsUseHighEntropyVA();
    internal static string optsSubSystemVersion();
    internal static string optsTargetProfile();
    internal static string optsEmitDebugInfoInQuotations();
    internal static string optsPreferredUiLang();
    internal static string optsNoCopyFsharpCore();
    internal static Tuple`2<int, string> optsInvalidSubSystemVersion(string a0);
    internal static Tuple`2<int, string> optsInvalidTargetProfile(string a0);
    internal static string typeInfoFullName();
    internal static string typeInfoOtherOverloads(int a0);
    internal static string typeInfoUnionCase();
    internal static string typeInfoActivePatternResult();
    internal static string typeInfoActiveRecognizer();
    internal static string typeInfoField();
    internal static string typeInfoEvent();
    internal static string typeInfoProperty();
    internal static string typeInfoExtension();
    internal static string typeInfoCustomOperation();
    internal static string typeInfoArgument();
    internal static string typeInfoAnonRecdField();
    internal static string typeInfoPatternVariable();
    internal static string typeInfoNamespace();
    internal static string typeInfoModule();
    internal static string typeInfoNamespaceOrModule();
    internal static string typeInfoFromFirst(string a0);
    internal static string typeInfoFromNext(string a0);
    internal static string typeInfoGeneratedProperty();
    internal static string typeInfoGeneratedType();
    internal static string assemblyResolutionFoundByAssemblyFoldersKey();
    internal static string assemblyResolutionFoundByAssemblyFoldersExKey();
    internal static string assemblyResolutionNetFramework();
    internal static string assemblyResolutionGAC();
    internal static Tuple`2<int, string> recursiveClassHierarchy(string a0);
    internal static Tuple`2<int, string> InvalidRecursiveReferenceToAbstractSlot();
    internal static Tuple`2<int, string> eventHasNonStandardType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> typeIsNotAccessible(string a0);
    internal static Tuple`2<int, string> unionCasesAreNotAccessible(string a0);
    internal static Tuple`2<int, string> valueIsNotAccessible(string a0);
    internal static Tuple`2<int, string> unionCaseIsNotAccessible(string a0);
    internal static Tuple`2<int, string> fieldIsNotAccessible(string a0);
    internal static Tuple`2<int, string> structOrClassFieldIsNotAccessible(string a0);
    internal static string experimentalConstruct();
    internal static Tuple`2<int, string> noInvokeMethodsFound();
    internal static string moreThanOneInvokeMethodFound();
    internal static Tuple`2<int, string> delegatesNotAllowedToHaveCurriedSignatures();
    internal static Tuple`2<int, string> tlrUnexpectedTExpr();
    internal static Tuple`2<int, string> tlrLambdaLiftingOptimizationsNotApplied();
    internal static Tuple`2<int, string> lexhlpIdentifiersContainingAtSymbolReserved();
    internal static string lexhlpIdentifierReserved(string a0);
    internal static Tuple`2<int, string> patcMissingVariable(string a0);
    internal static Tuple`2<int, string> patcPartialActivePatternsGenerateOneResult();
    internal static Tuple`2<int, string> impTypeRequiredUnavailable(string a0, string a1);
    internal static Tuple`2<int, string> impReferencedTypeCouldNotBeFoundInAssembly(string a0, string a1);
    internal static Tuple`2<int, string> impNotEnoughTypeParamsInScopeWhileImporting();
    internal static Tuple`2<int, string> impReferenceToDllRequiredByAssembly(string a0, string a1, string a2);
    internal static Tuple`2<int, string> impImportedAssemblyUsesNotPublicType(string a0);
    internal static Tuple`2<int, string> optValueMarkedInlineButIncomplete(string a0);
    internal static Tuple`2<int, string> optValueMarkedInlineButWasNotBoundInTheOptEnv(string a0);
    internal static Tuple`2<int, string> optLocalValueNotFoundDuringOptimization(string a0);
    internal static Tuple`2<int, string> optValueMarkedInlineHasUnexpectedValue();
    internal static Tuple`2<int, string> optValueMarkedInlineCouldNotBeInlined();
    internal static Tuple`2<int, string> optFailedToInlineValue(string a0);
    internal static Tuple`2<int, string> optRecursiveValValue(string a0);
    internal static string lexfltIncorrentIndentationOfIn();
    internal static string lexfltTokenIsOffsideOfContextStartedEarlier(string a0);
    internal static string lexfltSeparatorTokensOfPatternMatchMisaligned();
    internal static Tuple`2<int, string> nrInvalidModuleExprType();
    internal static Tuple`2<int, string> nrTypeInstantiationNeededToDisambiguateTypesWithSameName(string a0, string a1);
    internal static Tuple`2<int, string> nrTypeInstantiationIsMissingAndCouldNotBeInferred(string a0, string a1);
    internal static Tuple`2<int, string> nrGlobalUsedOnlyAsFirstName();
    internal static Tuple`2<int, string> nrIsNotConstructorOrLiteral();
    internal static Tuple`2<int, string> nrUnexpectedEmptyLongId();
    internal static Tuple`2<int, string> nrRecordDoesNotContainSuchLabel(string a0, string a1);
    internal static Tuple`2<int, string> nrInvalidFieldLabel();
    internal static Tuple`2<int, string> nrInvalidExpression(string a0);
    internal static Tuple`2<int, string> nrNoConstructorsAvailableForType(string a0);
    internal static Tuple`2<int, string> nrUnionTypeNeedsQualifiedAccess(string a0, string a1);
    internal static Tuple`2<int, string> nrRecordTypeNeedsQualifiedAccess(string a0, string a1);
    internal static Tuple`2<int, string> ilwriteErrorCreatingPdb(string a0);
    internal static Tuple`2<int, string> lexOutsideIntegerRange();
    internal static string lexCharNotAllowedInOperatorNames(string a0);
    internal static string lexUnexpectedChar(string a0);
    internal static Tuple`2<int, string> lexByteArrayCannotEncode();
    internal static Tuple`2<int, string> lexIdentEndInMarkReserved(string a0);
    internal static Tuple`2<int, string> lexOutsideEightBitSigned();
    internal static Tuple`2<int, string> lexOutsideEightBitSignedHex();
    internal static Tuple`2<int, string> lexOutsideEightBitUnsigned();
    internal static Tuple`2<int, string> lexOutsideSixteenBitSigned();
    internal static Tuple`2<int, string> lexOutsideSixteenBitUnsigned();
    internal static Tuple`2<int, string> lexOutsideThirtyTwoBitSigned();
    internal static Tuple`2<int, string> lexOutsideThirtyTwoBitUnsigned();
    internal static Tuple`2<int, string> lexOutsideSixtyFourBitSigned();
    internal static Tuple`2<int, string> lexOutsideSixtyFourBitUnsigned();
    internal static Tuple`2<int, string> lexOutsideNativeSigned();
    internal static Tuple`2<int, string> lexOutsideNativeUnsigned();
    internal static Tuple`2<int, string> lexInvalidFloat();
    internal static Tuple`2<int, string> lexOusideDecimal();
    internal static Tuple`2<int, string> lexOusideThirtyTwoBitFloat();
    internal static Tuple`2<int, string> lexInvalidNumericLiteral();
    internal static Tuple`2<int, string> lexInvalidByteLiteral();
    internal static Tuple`2<int, string> lexInvalidCharLiteral();
    internal static Tuple`2<int, string> lexThisUnicodeOnlyInStringLiterals();
    internal static Tuple`2<int, string> lexTokenReserved();
    internal static Tuple`2<int, string> lexTabsNotAllowed();
    internal static Tuple`2<int, string> lexInvalidLineNumber(string a0);
    internal static Tuple`2<int, string> lexHashIfMustBeFirst();
    internal static string lexHashElseNoMatchingIf();
    internal static string lexHashEndifRequiredForElse();
    internal static Tuple`2<int, string> lexHashElseMustBeFirst();
    internal static string lexHashEndingNoMatchingIf();
    internal static Tuple`2<int, string> lexHashEndifMustBeFirst();
    internal static Tuple`2<int, string> lexHashIfMustHaveIdent();
    internal static Tuple`2<int, string> lexWrongNestedHashEndif();
    internal static string lexHashBangMustBeFirstInFile();
    internal static Tuple`2<int, string> pplexExpectedSingleLineComment();
    internal static Tuple`2<int, string> memberOperatorDefinitionWithNoArguments(string a0);
    internal static Tuple`2<int, string> memberOperatorDefinitionWithNonPairArgument(string a0, int a1);
    internal static Tuple`2<int, string> memberOperatorDefinitionWithCurriedArguments(string a0);
    internal static Tuple`2<int, string> tcFSharpCoreRequiresExplicit();
    internal static Tuple`2<int, string> tcStructuralComparisonNotSatisfied1(string a0, string a1);
    internal static Tuple`2<int, string> tcStructuralComparisonNotSatisfied2(string a0, string a1);
    internal static Tuple`2<int, string> tcNoComparisonNeeded1(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcNoComparisonNeeded2(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcNoEqualityNeeded1(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcNoEqualityNeeded2(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcStructuralEqualityNotSatisfied1(string a0, string a1);
    internal static Tuple`2<int, string> tcStructuralEqualityNotSatisfied2(string a0, string a1);
    internal static Tuple`2<int, string> tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly();
    internal static Tuple`2<int, string> chkUnusedValue(string a0);
    internal static Tuple`2<int, string> chkUnusedThisVariable(string a0);
    internal static Tuple`2<int, string> parsGetterAtMostOneArgument();
    internal static Tuple`2<int, string> parsSetterAtMostTwoArguments();
    internal static Tuple`2<int, string> parsInvalidProperty();
    internal static Tuple`2<int, string> parsIndexerPropertyRequiresAtLeastOneArgument();
    internal static Tuple`2<int, string> tastInvalidAddressOfMutableAcrossAssemblyBoundary();
    internal static Tuple`2<int, string> parsNonAdjacentTypars();
    internal static Tuple`2<int, string> parsNonAdjacentTyargs();
    internal static string parsNonAtomicType();
    internal static Tuple`2<int, string> tastUndefinedItemRefModuleNamespace(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tastUndefinedItemRefVal(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tastUndefinedItemRefModuleNamespaceType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcInvalidUseNullAsTrueValue();
    internal static Tuple`2<int, string> tcParameterInferredByref(string a0);
    internal static Tuple`2<int, string> tcNonUniformMemberUse(string a0);
    internal static Tuple`2<int, string> tcAttribArgsDiffer(string a0);
    internal static Tuple`2<int, string> tcCannotCallAbstractBaseMember(string a0);
    internal static Tuple`2<int, string> typrelCannotResolveAmbiguityInUnmanaged();
    internal static string mlCompatMessage(string a0);
    internal static Tuple`2<int, string> ilFieldDoesNotHaveValidOffsetForStructureLayout(string a0, string a1);
    internal static Tuple`2<int, string> tcInterfacesShouldUseInheritNotInterface();
    internal static Tuple`2<int, string> parsInvalidPrefixOperator();
    internal static Tuple`2<int, string> parsInvalidPrefixOperatorDefinition();
    internal static string buildCompilingExtensionIsForML();
    internal static string lexIndentOffForML();
    internal static Tuple`2<int, string> activePatternIdentIsNotFunctionTyped(string a0);
    internal static Tuple`2<int, string> activePatternChoiceHasFreeTypars(string a0);
    internal static Tuple`2<int, string> ilFieldHasOffsetForSequentialLayout();
    internal static Tuple`2<int, string> tcOptionalArgsMustComeAfterNonOptionalArgs();
    internal static Tuple`2<int, string> tcConditionalAttributeUsage();
    internal static Tuple`2<int, string> tcMemberOperatorDefinitionInExtrinsic();
    internal static Tuple`2<int, string> ilwriteMDBFileNameCannotBeChangedWarning();
    internal static Tuple`2<int, string> ilwriteMDBMemberMissing(string a0);
    internal static Tuple`2<int, string> ilwriteErrorCreatingMdb();
    internal static Tuple`2<int, string> tcUnionCaseNameConflictsWithGeneratedType(string a0, string a1);
    internal static Tuple`2<int, string> chkNoReflectedDefinitionOnStructMember();
    internal static Tuple`2<int, string> tcDllImportNotAllowed();
    internal static Tuple`2<int, string> buildExplicitCoreLibRequiresNoFramework(string a0);
    internal static Tuple`2<int, string> buildExpectedSigdataFile(string a0);
    internal static Tuple`2<int, string> buildExpectedFileAlongSideFSharpCore(string a0, string a1);
    internal static Tuple`2<int, string> buildUnexpectedFileNameCharacter(string a0, string a1);
    internal static Tuple`2<int, string> tcInvalidUseBangBinding();
    internal static Tuple`2<int, string> crefNoInnerGenericsInQuotations();
    internal static Tuple`2<int, string> tcEnumTypeCannotBeEnumerated(string a0);
    internal static Tuple`2<int, string> parsEofInTripleQuoteString();
    internal static Tuple`2<int, string> parsEofInTripleQuoteStringInComment();
    internal static Tuple`2<int, string> tcTypeTestLosesMeasures(string a0);
    internal static Tuple`2<int, string> parsMissingTypeArgs();
    internal static Tuple`2<int, string> parsMissingGreaterThan();
    internal static Tuple`2<int, string> parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString();
    internal static Tuple`2<int, string> parsErrorParsingAsOperatorName();
    internal static Tuple`2<int, string> lexInvalidUnicodeLiteral(string a0);
    internal static Tuple`2<int, string> tcCallerInfoWrongType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcCallerInfoNotOptional(string a0);
    internal static Tuple`2<int, string> toolLocationHelperUnsupportedFrameworkVersion(string a0);
    internal static Tuple`2<int, string> ilSignInvalidMagicValue();
    internal static Tuple`2<int, string> ilSignBadImageFormat();
    internal static Tuple`2<int, string> ilSignPrivateKeyExpected();
    internal static Tuple`2<int, string> ilSignRsaKeyExpected();
    internal static Tuple`2<int, string> ilSignInvalidBitLen();
    internal static Tuple`2<int, string> ilSignInvalidRSAParams();
    internal static Tuple`2<int, string> ilSignInvalidAlgId();
    internal static Tuple`2<int, string> ilSignInvalidSignatureSize();
    internal static Tuple`2<int, string> ilSignNoSignatureDirectory();
    internal static Tuple`2<int, string> ilSignInvalidPKBlob();
    internal static string fscTooManyErrors();
    internal static Tuple`2<int, string> docfileNoXmlSuffix();
    internal static Tuple`2<int, string> fscNoImplementationFiles();
    internal static Tuple`2<int, string> fscBadAssemblyVersion(string a0, string a1);
    internal static Tuple`2<int, string> fscTwoResourceManifests();
    internal static Tuple`2<int, string> fscQuotationLiteralsStaticLinking(string a0);
    internal static Tuple`2<int, string> fscQuotationLiteralsStaticLinking0();
    internal static Tuple`2<int, string> fscStaticLinkingNoEXE();
    internal static Tuple`2<int, string> fscStaticLinkingNoMixedDLL();
    internal static Tuple`2<int, string> fscIgnoringMixedWhenLinking(string a0);
    internal static Tuple`2<int, string> fscAssumeStaticLinkContainsNoDependencies(string a0);
    internal static Tuple`2<int, string> fscAssemblyNotFoundInDependencySet(string a0);
    internal static Tuple`2<int, string> fscKeyFileCouldNotBeOpened(string a0);
    internal static Tuple`2<int, string> fscProblemWritingBinary(string a0, string a1);
    internal static Tuple`2<int, string> fscAssemblyVersionAttributeIgnored();
    internal static Tuple`2<int, string> fscAssemblyCultureAttributeError();
    internal static Tuple`2<int, string> fscDelaySignWarning();
    internal static Tuple`2<int, string> fscKeyFileWarning();
    internal static Tuple`2<int, string> fscKeyNameWarning();
    internal static Tuple`2<int, string> fscReferenceOnCommandLine(string a0);
    internal static Tuple`2<int, string> fscRemotingError();
    internal static Tuple`2<int, string> pathIsInvalid(string a0);
    internal static Tuple`2<int, string> fscResxSourceFileDeprecated(string a0);
    internal static Tuple`2<int, string> fscStaticLinkingNoProfileMismatches();
    internal static Tuple`2<int, string> fscAssemblyWildcardAndDeterminism(string a0, string a1);
    internal static Tuple`2<int, string> fscDeterministicDebugRequiresPortablePdb();
    internal static Tuple`2<int, string> fscPathMapDebugRequiresPortablePdb();
    internal static Tuple`2<int, string> optsInvalidPathMapFormat();
    internal static Tuple`2<int, string> etIllegalCharactersInNamespaceName(string a0, string a1);
    internal static Tuple`2<int, string> etNullOrEmptyMemberName(string a0);
    internal static Tuple`2<int, string> etNullMember(string a0);
    internal static Tuple`2<int, string> etNullMemberDeclaringType(string a0, string a1);
    internal static Tuple`2<int, string> etNullMemberDeclaringTypeDifferentFromProvidedType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> etHostingAssemblyFoundWithoutHosts(string a0, string a1);
    internal static Tuple`2<int, string> etEmptyNamespaceOfTypeNotAllowed(string a0, string a1);
    internal static Tuple`2<int, string> etEmptyNamespaceNotAllowed(string a0);
    internal static Tuple`2<int, string> etMustNotBeGeneric(string a0);
    internal static Tuple`2<int, string> etMustNotBeAnArray(string a0);
    internal static Tuple`2<int, string> etMethodHasRequirements(string a0, string a1);
    internal static Tuple`2<int, string> etUnsupportedMemberKind(string a0, string a1);
    internal static Tuple`2<int, string> etPropertyCanReadButHasNoGetter(string a0, string a1);
    internal static Tuple`2<int, string> etPropertyHasGetterButNoCanRead(string a0, string a1);
    internal static Tuple`2<int, string> etPropertyCanWriteButHasNoSetter(string a0, string a1);
    internal static Tuple`2<int, string> etPropertyHasSetterButNoCanWrite(string a0, string a1);
    internal static Tuple`2<int, string> etOneOrMoreErrorsSeenDuringExtensionTypeSetting();
    internal static Tuple`2<int, string> etUnexpectedExceptionFromProvidedTypeMember(string a0, string a1, string a2);
    internal static Tuple`2<int, string> etUnsupportedConstantType(string a0);
    internal static Tuple`2<int, string> etUnsupportedProvidedExpression(string a0);
    internal static Tuple`2<int, string> etProvidedTypeHasUnexpectedName(string a0, string a1);
    internal static Tuple`2<int, string> etEventNoAdd(string a0, string a1);
    internal static Tuple`2<int, string> etEventNoRemove(string a0, string a1);
    internal static Tuple`2<int, string> etProviderHasWrongDesignerAssembly(string a0, string a1, string a2);
    internal static Tuple`2<int, string> etProviderDoesNotHaveValidConstructor();
    internal static Tuple`2<int, string> etProviderError(string a0, string a1);
    internal static Tuple`2<int, string> etIncorrectParameterExpression(string a0, string a1);
    internal static Tuple`2<int, string> etIncorrectProvidedMethod(string a0, string a1, int a2, string a3);
    internal static Tuple`2<int, string> etIncorrectProvidedConstructor(string a0, string a1);
    internal static Tuple`2<int, string> etDirectReferenceToGeneratedTypeNotAllowed(string a0);
    internal static Tuple`2<int, string> etProvidedTypeHasUnexpectedPath(string a0, string a1);
    internal static Tuple`2<int, string> etUnexpectedNullFromProvidedTypeMember(string a0, string a1);
    internal static Tuple`2<int, string> etUnexpectedExceptionFromProvidedMemberMember(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters();
    internal static Tuple`2<int, string> etInvalidStaticArgument(string a0);
    internal static Tuple`2<int, string> etErrorApplyingStaticArgumentsToType();
    internal static Tuple`2<int, string> etUnknownStaticArgumentKind(string a0, string a1);
    internal static string invalidNamespaceForProvidedType();
    internal static string invalidFullNameForProvidedType();
    internal static Tuple`2<int, string> etProviderReturnedNull(string a0);
    internal static Tuple`2<int, string> etTypeProviderConstructorException(string a0);
    internal static Tuple`2<int, string> etNullProvidedExpression(string a0);
    internal static Tuple`2<int, string> etProvidedAppliedTypeHadWrongName(string a0, string a1, string a2);
    internal static Tuple`2<int, string> etProvidedAppliedMethodHadWrongName(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcTypeTestLossy(string a0, string a1);
    internal static Tuple`2<int, string> tcTypeCastErased(string a0, string a1);
    internal static Tuple`2<int, string> tcTypeTestErased(string a0, string a1);
    internal static Tuple`2<int, string> tcCannotInheritFromErasedType();
    internal static Tuple`2<int, string> etInvalidTypeProviderAssemblyName(string a0, string a1);
    internal static Tuple`2<int, string> tcInvalidMemberNameCtor();
    internal static Tuple`2<int, string> tcInferredGenericTypeGivesRiseToInconsistency(string a0, string a1);
    internal static Tuple`2<int, string> tcInvalidTypeArgumentCount(int a0, int a1);
    internal static Tuple`2<int, string> tcCannotOverrideSealedMethod(string a0);
    internal static Tuple`2<int, string> etProviderErrorWithContext(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> etProvidedTypeWithNameException(string a0, string a1);
    internal static Tuple`2<int, string> etProvidedTypeWithNullOrEmptyName(string a0);
    internal static Tuple`2<int, string> etIllegalCharactersInTypeName(string a0, string a1);
    internal static Tuple`2<int, string> tcJoinMustUseSimplePattern(string a0);
    internal static Tuple`2<int, string> tcMissingCustomOperation(string a0);
    internal static Tuple`2<int, string> etBadUnnamedStaticArgs();
    internal static Tuple`2<int, string> etStaticParameterRequiresAValue(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> etNoStaticParameterWithName(string a0);
    internal static Tuple`2<int, string> etStaticParameterAlreadyHasValue(string a0);
    internal static Tuple`2<int, string> etMultipleStaticParameterWithName(string a0);
    internal static Tuple`2<int, string> tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings();
    internal static Tuple`2<int, string> tcCustomOperationMayNotBeUsedHere();
    internal static Tuple`2<int, string> tcCustomOperationMayNotBeOverloaded(string a0);
    internal static Tuple`2<int, string> tcIfThenElseMayNotBeUsedWithinQueries();
    internal static Tuple`2<int, string> ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen();
    internal static Tuple`2<int, string> etProvidedTypeReferenceMissingArgument(string a0);
    internal static Tuple`2<int, string> etProvidedTypeReferenceInvalidText(string a0);
    internal static Tuple`2<int, string> tcCustomOperationNotUsedCorrectly(string a0);
    internal static Tuple`2<int, string> tcCustomOperationNotUsedCorrectly2(string a0, string a1);
    internal static string customOperationTextLikeJoin(string a0, string a1, string a2);
    internal static string customOperationTextLikeGroupJoin(string a0, string a1, string a2);
    internal static string customOperationTextLikeZip(string a0);
    internal static Tuple`2<int, string> tcBinaryOperatorRequiresVariable(string a0, string a1);
    internal static Tuple`2<int, string> tcOperatorIncorrectSyntax(string a0, string a1);
    internal static Tuple`2<int, string> tcBinaryOperatorRequiresBody(string a0, string a1);
    internal static Tuple`2<int, string> tcCustomOperationHasIncorrectArgCount(string a0, int a1, int a2);
    internal static Tuple`2<int, string> parsExpectedExpressionAfterToken();
    internal static Tuple`2<int, string> parsExpectedTypeAfterToken();
    internal static Tuple`2<int, string> parsUnmatchedLBrackLess();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileMatch();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileTry();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileWhile();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileFor();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileWith();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileThen();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileElse();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileFunBody();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileTypeArgs();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileTypeSignature();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileTypeDefinition();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileObjectMembers();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileDefinition();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileExpression();
    internal static Tuple`2<int, string> parsExpectedNameAfterToken();
    internal static Tuple`2<int, string> parsUnmatchedLet();
    internal static Tuple`2<int, string> parsUnmatchedLetBang();
    internal static Tuple`2<int, string> parsUnmatchedUseBang();
    internal static Tuple`2<int, string> parsUnmatchedUse();
    internal static Tuple`2<int, string> parsWhileDoExpected();
    internal static Tuple`2<int, string> parsForDoExpected();
    internal static Tuple`2<int, string> tcInvalidRelationInJoin(string a0);
    internal static string typeInfoCallsWord();
    internal static Tuple`2<int, string> impInvalidNumberOfGenericArguments(string a0, int a1, int a2);
    internal static Tuple`2<int, string> impInvalidMeasureArgument1(string a0, string a1);
    internal static Tuple`2<int, string> impInvalidMeasureArgument2(string a0);
    internal static Tuple`2<int, string> etPropertyNeedsCanWriteOrCanRead(string a0, string a1);
    internal static Tuple`2<int, string> tcIntoNeedsRestOfQuery();
    internal static Tuple`2<int, string> tcOperatorDoesntAcceptInto(string a0);
    internal static Tuple`2<int, string> tcCustomOperationInvalid(string a0);
    internal static Tuple`2<int, string> tcThisTypeMayNotHaveACLIMutableAttribute();
    internal static Tuple`2<int, string> tcAutoPropertyRequiresImplicitConstructionSequence();
    internal static Tuple`2<int, string> parsMutableOnAutoPropertyShouldBeGetSet();
    internal static Tuple`2<int, string> parsMutableOnAutoPropertyShouldBeGetSetNotJustSet();
    internal static Tuple`2<int, string> chkNoByrefsOfByrefs(string a0);
    internal static Tuple`2<int, string> tastopsMaxArrayThirtyTwo(int a0);
    internal static Tuple`2<int, string> tcNoIntegerForLoopInQuery();
    internal static Tuple`2<int, string> tcNoWhileInQuery();
    internal static Tuple`2<int, string> tcNoTryFinallyInQuery();
    internal static Tuple`2<int, string> tcUseMayNotBeUsedInQueries();
    internal static Tuple`2<int, string> tcBindMayNotBeUsedInQueries();
    internal static Tuple`2<int, string> tcReturnMayNotBeUsedInQueries();
    internal static Tuple`2<int, string> tcUnrecognizedQueryOperator();
    internal static Tuple`2<int, string> tcTryWithMayNotBeUsedInQueries();
    internal static Tuple`2<int, string> tcNonSimpleLetBindingInQuery();
    internal static Tuple`2<int, string> etTooManyStaticParameters(int a0, int a1, int a2);
    internal static Tuple`2<int, string> infosInvalidProvidedLiteralValue(string a0);
    internal static Tuple`2<int, string> invalidPlatformTarget();
    internal static Tuple`2<int, string> tcThisValueMayNotBeInlined();
    internal static Tuple`2<int, string> etErasedTypeUsedInGeneration(string a0, string a1);
    internal static Tuple`2<int, string> tcUnrecognizedQueryBinaryOperator();
    internal static Tuple`2<int, string> crefNoSetOfHole();
    internal static string nicePrintOtherOverloads1();
    internal static string nicePrintOtherOverloadsN(int a0);
    internal static string erasedTo();
    internal static Tuple`2<int, string> parsUnfinishedExpression(string a0);
    internal static Tuple`2<int, string> parsAttributeOnIncompleteCode();
    internal static Tuple`2<int, string> parsTypeNameCannotBeEmpty();
    internal static Tuple`2<int, string> buildProblemReadingAssembly(string a0, string a1);
    internal static Tuple`2<int, string> tcTPFieldMustBeLiteral();
    internal static string loadingDescription();
    internal static string descriptionUnavailable();
    internal static Tuple`2<int, string> chkTyparMultipleClassConstraints();
    internal static Tuple`2<int, string> tcMatchMayNotBeUsedWithQuery();
    internal static Tuple`2<int, string> memberOperatorDefinitionWithNonTripleArgument(string a0, int a1);
    internal static Tuple`2<int, string> cannotResolveNullableOperators(string a0);
    internal static Tuple`2<int, string> tcOperatorRequiresIn(string a0, string a1);
    internal static Tuple`2<int, string> parsIllegalMemberVarInObjectImplementation();
    internal static Tuple`2<int, string> tcEmptyCopyAndUpdateRecordInvalid();
    internal static Tuple`2<int, string> parsUnderscoreInvalidFieldName();
    internal static Tuple`2<int, string> tcGeneratedTypesShouldBeInternalOrPrivate();
    internal static Tuple`2<int, string> chkGetterAndSetterHaveSamePropertyType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcRuntimeSuppliedMethodCannotBeUsedInUserCode(string a0);
    internal static Tuple`2<int, string> tcUnionCaseConstructorDoesNotHaveFieldWithGivenName(string a0, string a1);
    internal static Tuple`2<int, string> tcExceptionConstructorDoesNotHaveFieldWithGivenName(string a0, string a1);
    internal static Tuple`2<int, string> tcActivePatternsDoNotHaveFields();
    internal static Tuple`2<int, string> tcConstructorDoesNotHaveFieldWithGivenName(string a0);
    internal static Tuple`2<int, string> tcUnionCaseFieldCannotBeUsedMoreThanOnce(string a0);
    internal static Tuple`2<int, string> tcFieldNameIsUsedModeThanOnce(string a0);
    internal static Tuple`2<int, string> tcFieldNameConflictsWithGeneratedNameForAnonymousField(string a0);
    internal static Tuple`2<int, string> tastConstantExpressionOverflow();
    internal static Tuple`2<int, string> tcIllegalStructTypeForConstantExpression();
    internal static Tuple`2<int, string> fscSystemRuntimeInteropServicesIsRequired();
    internal static Tuple`2<int, string> abImplicitHeapAllocation(string a0);
    internal static string estApplyStaticArgumentsForMethodNotImplemented();
    internal static Tuple`2<int, string> etErrorApplyingStaticArgumentsToMethod();
    internal static Tuple`2<int, string> pplexUnexpectedChar(string a0);
    internal static Tuple`2<int, string> ppparsUnexpectedToken(string a0);
    internal static Tuple`2<int, string> ppparsIncompleteExpression();
    internal static Tuple`2<int, string> ppparsMissingToken(string a0);
    internal static Tuple`2<int, string> pickleMissingDefinition(int a0, string a1, string a2);
    internal static Tuple`2<int, string> checkNotSufficientlyGenericBecauseOfScope(string a0);
    internal static Tuple`2<int, string> checkNotSufficientlyGenericBecauseOfScopeAnon();
    internal static Tuple`2<int, string> checkRaiseFamilyFunctionArgumentCount(string a0, int a1, int a2);
    internal static Tuple`2<int, string> checkLowercaseLiteralBindingInPattern(string a0);
    internal static Tuple`2<int, string> tcLiteralDoesNotTakeArguments();
    internal static Tuple`2<int, string> tcConstructorsIllegalInAugmentation();
    internal static Tuple`2<int, string> optsInvalidResponseFile(string a0, string a1);
    internal static Tuple`2<int, string> optsResponseFileNotFound(string a0, string a1);
    internal static Tuple`2<int, string> optsResponseFileNameInvalid(string a0);
    internal static Tuple`2<int, string> fsharpCoreNotFoundToBeCopied();
    internal static string tcTupleStructMismatch();
    internal static Tuple`2<int, string> etMissingStaticArgumentsToMethod();
    internal static Tuple`2<int, string> considerUpcast(string a0, string a1);
    internal static Tuple`2<int, string> considerUpcastOperator(string a0, string a1);
    internal static Tuple`2<int, string> tcRecImplied();
    internal static Tuple`2<int, string> tcOpenFirstInMutRec();
    internal static Tuple`2<int, string> tcModuleAbbrevFirstInMutRec();
    internal static Tuple`2<int, string> tcUnsupportedMutRecDecl();
    internal static Tuple`2<int, string> parsInvalidUseOfRec();
    internal static Tuple`2<int, string> tcStructUnionMultiCaseDistinctFields();
    internal static Tuple`2<int, string> CallerMemberNameIsOverriden(string a0);
    internal static Tuple`2<int, string> tcFixedNotAllowed();
    internal static Tuple`2<int, string> tcCouldNotFindOffsetToStringData();
    internal static Tuple`2<int, string> chkNoByrefAddressOfLocal(string a0);
    internal static Tuple`2<int, string> tcNamedActivePattern(string a0);
    internal static Tuple`2<int, string> DefaultParameterValueNotAppropriateForArgument();
    internal static string tcGlobalsSystemTypeNotFound(string a0);
    internal static Tuple`2<int, string> typrelMemberHasMultiplePossibleDispatchSlots(string a0, string a1);
    internal static Tuple`2<int, string> methodIsNotStatic(string a0);
    internal static Tuple`2<int, string> parsUnexpectedSymbolEqualsInsteadOfIn();
    internal static string tcAnonRecdCcuMismatch(string a0, string a1);
    internal static string tcAnonRecdFieldNameMismatch(string a0, string a1);
    internal static string keywordDescriptionAbstract();
    internal static string keyworkDescriptionAnd();
    internal static string keywordDescriptionAs();
    internal static string keywordDescriptionAssert();
    internal static string keywordDescriptionBase();
    internal static string keywordDescriptionBegin();
    internal static string keywordDescriptionClass();
    internal static string keywordDescriptionDefault();
    internal static string keywordDescriptionDelegate();
    internal static string keywordDescriptionDo();
    internal static string keywordDescriptionDone();
    internal static string keywordDescriptionDowncast();
    internal static string keywordDescriptionDownto();
    internal static string keywordDescriptionElif();
    internal static string keywordDescriptionElse();
    internal static string keywordDescriptionEnd();
    internal static string keywordDescriptionException();
    internal static string keywordDescriptionExtern();
    internal static string keywordDescriptionTrueFalse();
    internal static string keywordDescriptionFinally();
    internal static string keywordDescriptionFor();
    internal static string keywordDescriptionFun();
    internal static string keywordDescriptionFunction();
    internal static string keywordDescriptionGlobal();
    internal static string keywordDescriptionIf();
    internal static string keywordDescriptionIn();
    internal static string keywordDescriptionInherit();
    internal static string keywordDescriptionInline();
    internal static string keywordDescriptionInterface();
    internal static string keywordDescriptionInternal();
    internal static string keywordDescriptionLazy();
    internal static string keywordDescriptionLet();
    internal static string keywordDescriptionLetBang();
    internal static string keywordDescriptionMatch();
    internal static string keywordDescriptionMatchBang();
    internal static string keywordDescriptionMember();
    internal static string keywordDescriptionModule();
    internal static string keywordDescriptionMutable();
    internal static string keywordDescriptionNamespace();
    internal static string keywordDescriptionNew();
    internal static string keywordDescriptionNot();
    internal static string keywordDescriptionNull();
    internal static string keywordDescriptionOf();
    internal static string keywordDescriptionOpen();
    internal static string keywordDescriptionOr();
    internal static string keywordDescriptionOverride();
    internal static string keywordDescriptionPrivate();
    internal static string keywordDescriptionPublic();
    internal static string keywordDescriptionRec();
    internal static string keywordDescriptionReturn();
    internal static string keywordDescriptionReturnBang();
    internal static string keywordDescriptionSelect();
    internal static string keywordDescriptionStatic();
    internal static string keywordDescriptionStruct();
    internal static string keywordDescriptionThen();
    internal static string keywordDescriptionTo();
    internal static string keywordDescriptionTry();
    internal static string keywordDescriptionType();
    internal static string keywordDescriptionUpcast();
    internal static string keywordDescriptionUse();
    internal static string keywordDescriptionUseBang();
    internal static string keywordDescriptionVal();
    internal static string keywordDescriptionVoid();
    internal static string keywordDescriptionWhen();
    internal static string keywordDescriptionWhile();
    internal static string keywordDescriptionWith();
    internal static string keywordDescriptionYield();
    internal static string keywordDescriptionYieldBang();
    internal static string keywordDescriptionRightArrow();
    internal static string keywordDescriptionLeftArrow();
    internal static string keywordDescriptionCast();
    internal static string keywordDescriptionDynamicCast();
    internal static string keywordDescriptionTypedQuotation();
    internal static string keywordDescriptionUntypedQuotation();
    internal static Tuple`2<int, string> itemNotFoundDuringDynamicCodeGen(string a0, string a1, string a2);
    internal static Tuple`2<int, string> itemNotFoundInTypeDuringDynamicCodeGen(string a0, string a1, string a2, string a3);
    internal static string descriptionWordIs();
    internal static string notAFunction();
    internal static string notAFunctionButMaybeIndexerWithName(string a0);
    internal static string notAFunctionButMaybeIndexer();
    internal static Tuple`2<int, string> notAFunctionButMaybeIndexerErrorCode();
    internal static string notAFunctionButMaybeDeclaration();
    internal static Tuple`2<int, string> ArgumentsInSigAndImplMismatch(string a0, string a1);
    internal static Tuple`2<int, string> pickleUnexpectedNonZero(string a0);
    internal static Tuple`2<int, string> tcTupleMemberNotNormallyUsed();
    internal static Tuple`2<int, string> implicitlyDiscardedInSequenceExpression(string a0);
    internal static Tuple`2<int, string> implicitlyDiscardedSequenceInSequenceExpression(string a0);
    internal static Tuple`2<int, string> ilreadFileChanged(string a0);
    internal static Tuple`2<int, string> writeToReadOnlyByref();
    internal static Tuple`2<int, string> readOnlyAttributeOnStructWithMutableField();
    internal static Tuple`2<int, string> tcByrefReturnImplicitlyDereferenced();
    internal static Tuple`2<int, string> tcByRefLikeNotStruct();
    internal static Tuple`2<int, string> chkNoByrefAddressOfValueFromExpression();
    internal static Tuple`2<int, string> chkNoWriteToLimitedSpan(string a0);
    internal static Tuple`2<int, string> tastValueMustBeLocal();
    internal static Tuple`2<int, string> tcIsReadOnlyNotStruct();
    internal static Tuple`2<int, string> chkStructsMayNotReturnAddressesOfContents();
    internal static Tuple`2<int, string> chkNoByrefLikeFunctionCall();
    internal static Tuple`2<int, string> chkNoSpanLikeVariable(string a0);
    internal static Tuple`2<int, string> chkNoSpanLikeValueFromExpression();
    internal static Tuple`2<int, string> tastCantTakeAddressOfExpression();
    internal static Tuple`2<int, string> tcCannotCallExtensionMethodInrefToByref(string a0);
    internal static Tuple`2<int, string> tcByrefsMayNotHaveTypeExtensions();
    internal static Tuple`2<int, string> tcCannotPartiallyApplyExtensionMethodForByref(string a0);
    internal static Tuple`2<int, string> tcTypeDoesNotInheritAttribute();
    internal static Tuple`2<int, string> parsInvalidAnonRecdExpr();
    internal static Tuple`2<int, string> parsInvalidAnonRecdType();
    internal static Tuple`2<int, string> tcCopyAndUpdateNeedsRecordType();
    internal static Tuple`2<int, string> chkInvalidFunctionParameterType(string a0, string a1);
    internal static Tuple`2<int, string> chkInvalidFunctionReturnType(string a0);
    internal static string useSdkRefs();
    internal static string fSharpBannerVersion(string a0, string a1);
    internal static void RunStartupValidation();
    [CompilerGeneratedAttribute]
internal static Assembly getCurrentAssembly();
    [CompilerGeneratedAttribute]
internal static Type getTypeInfo(Type t);
    [CompilerGeneratedAttribute]
internal static string GetString(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object mkFunctionValue(Type[] tys, FSharpFunc`2<object, object> impl);
    [CompilerGeneratedAttribute]
internal static bool isNamedType(Type ty);
    [CompilerGeneratedAttribute]
internal static bool isFunctionType(Type ty1);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Type, Type[]> destFunTy(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object buildFunctionForOneArgPat(Type ty, FSharpFunc`2<Type, FSharpFunc`2<object, object>> impl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object capture1(string fmt, int i, FSharpList`1<object> args, Type ty, FSharpFunc`2<FSharpList`1<object>, FSharpFunc`2<Type, FSharpFunc`2<int, object>>> go);
    [CompilerGeneratedAttribute]
internal static string postProcessString(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static T createMessageString(string messageString, PrintfFormat`4<T, Unit, string, string> fmt);
    [CompilerGeneratedAttribute]
internal static T GetStringFunc(string messageID, PrintfFormat`4<T, Unit, string, string> fmt);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.BuildProperties : object {
    internal static string fsProductVersion { get; }
    internal static string fsLanguageVersion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_fsProductVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_fsLanguageVersion();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Diagnostics : object {
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<FSharpOption`1<TextWriter>> diagnosticsLog { get; }
    internal static FSharpRef`1<FSharpOption`1<TextWriter>> get_diagnosticsLog();
    internal static void setDiagnosticsChannel(FSharpOption`1<TextWriter> s);
    internal static void dflushn();
    internal static void dflush();
    internal static void dprintn(string s);
    internal static a dprintf(PrintfFormat`4<a, TextWriter, Unit, Unit> fmt);
    internal static a dprintfn(PrintfFormat`4<a, TextWriter, Unit, Unit> fmt);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Extensions.ILX.EraseClosures : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<b>, a> stripUpTo(int n, FSharpFunc`2<a, bool> test, FSharpFunc`2<a, Tuple`2<b, a>> dest, a x);
    internal static Tuple`2<ILGenericParameterDef, IlxClosureLambdas> destTyLambda(IlxClosureLambdas _arg1);
    internal static Tuple`3<FSharpList`1<ILType>, FSharpList`1<ILType>, IlxClosureApps> stripSupportedIndirectCall(IlxClosureApps apps);
    internal static Tuple`3<FSharpList`1<ILGenericParameterDef>, FSharpList`1<ILParameter>, IlxClosureLambdas> stripSupportedAbstraction(IlxClosureLambdas lambdas);
    internal static ILTypeRef mkFuncTypeRef(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef addMethodGeneratedAttrsToTypeDef(cenv cenv, ILTypeDef tdef);
    internal static cenv newIlxPubCloEnv(ILGlobals ilg, FSharpFunc`2<ILMethodDef, ILMethodDef> addMethodGeneratedAttrs, FSharpFunc`2<ILFieldDef, ILFieldDef> addFieldGeneratedAttrs, FSharpFunc`2<ILFieldDef, ILFieldDef> addFieldNeverAttrs);
    internal static ILType mkILTyFuncTy(cenv cenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkILFuncTy(cenv cenv, ILType dty, ILType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType typ_Func(cenv cenv, FSharpList`1<ILType> dtys, ILType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkTyOfApps(cenv cenv, IlxClosureApps apps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkTyOfLambdas(cenv cenv, IlxClosureLambdas lam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, ILMethodSpec> mkMethSpecForMultiApp(cenv cenv, FSharpList`1<ILType> argtys', ILType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkCallBlockForMultiValueApp(cenv cenv, ILTailcall doTailCall, FSharpList`1<ILType> args', ILType rty');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkLdFreeVar(IlxClosureSpec clospec, IlxClosureFreeVar fv);
    internal static Tuple`2<FSharpList`1<FSharpList`1<ILInstr>>, FSharpList`1<FSharpList`1<ILInstr>>> unwind@224(FSharpFunc`2<ILType, ushort> allocLocal, int numThisGenParams, IlxClosureApps apps);
    internal static Tuple`2<FSharpList`1<ILInstr>, FSharpList`1<ILInstr>> computePreCall@239(FSharpFunc`2<ILType, ushort> allocLocal, int numThisGenParams, bool fst, int n, IlxClosureApps rest, FSharpList`1<ILInstr> loaders);
    internal static FSharpList`1<ILInstr> buildApp@246(cenv cenv, FSharpFunc`2<ILType, ushort> allocLocal, int numThisGenParams, ILTailcall tl, bool fst, FSharpList`1<ILInstr> loaders, IlxClosureApps apps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkCallFunc(cenv cenv, FSharpFunc`2<ILType, ushort> allocLocal, int numThisGenParams, ILTailcall tl, IlxClosureApps apps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> convReturnInstr(ILType ty, ILInstr instr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodBody convILMethodBody(FSharpOption`1<a> thisClo, FSharpOption`1<ILType> boxReturnTy, ILMethodBody il);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodBody convMethodBody(FSharpOption`1<a> thisClo, MethodBody _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef convMethodDef(FSharpOption`1<a> thisClo, ILMethodDef md);
    internal static IlxClosureFreeVar mkILFreeVarForParam(ILParameter p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<string, ILType>> mkILCloFldSpecs(a _cenv, IlxClosureFreeVar[] flds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILFieldDef> mkILCloFldDefs(cenv cenv, IlxClosureFreeVar[] flds);
    internal static a findMatchingArg@380(FSharpList`1<Tuple`2<int, IlxClosureFreeVar>> argToFreeVarMap, FSharpFunc`2<int, a> mkEnv, FSharpFunc`2<int, a> mkArg, int n, FSharpList`1<Tuple`2<int, b>> l, int c);
    internal static a fixupArg@379(FSharpList`1<Tuple`2<int, IlxClosureFreeVar>> argToFreeVarMap, FSharpFunc`2<int, a> mkEnv, FSharpFunc`2<int, a> mkArg, int n);
    internal static ILMethodBody rewriteCodeToAccessArgsFromEnv@375(IlxClosureInfo clo, IlxClosureSpec laterCloSpec, FSharpList`1<Tuple`2<int, IlxClosureFreeVar>> argToFreeVarMap);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ILTypeDef> newTypeDefs$cont@615(cenv cenv, ILTypeDef td, IlxClosureInfo clo, IlxClosureFreeVar[] nowFields, ILType nowTy, IlxClosureSpec nowCloSpec, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ILTypeDef> newTypeDefs$cont@569-1(cenv cenv, ILTypeDef td, IlxClosureInfo clo, IlxClosureFreeVar[] nowFields, ILType nowTy, IlxClosureSpec nowCloSpec, FSharpList`1<ILParameter> nowParams, ILType nowReturnTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ILTypeDef> newTypeDefs$cont@472-2(cenv cenv, ILTypeDef td, IlxClosureInfo clo, IlxClosureFreeVar[] nowFields, ILType nowTy, IlxClosureSpec nowCloSpec, FSharpList`1<ILGenericParameterDef> tyargsl, ILType nowReturnTy, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILTypeDef> convIlxClosureDef(cenv cenv, FSharpList`1<string> encl, ILTypeDef td, IlxClosureInfo clo);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Extensions.ILX.EraseUnions : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int TagNil;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int TagCons;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string ALT_NAME_CONS;
    [CompilationMappingAttribute("9")]
internal static UnionReprDecisions`3<IlxUnionSpec, IlxUnionAlternative, ILType> cuspecRepr { get; }
    [CompilationMappingAttribute("9")]
internal static UnionReprDecisions`3<Tuple`2<ILTypeDef, IlxUnionInfo>, IlxUnionAlternative, NoTypesGeneratedViaThisReprDecider> cudefRepr { get; }
    internal static string tagPropertyName { get; }
    private static EraseUnions();
    internal static ILType baseTyOfUnionSpec(IlxUnionSpec cuspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string mkMakerName(IlxUnionSpec cuspec, string nm);
    internal static UnionReprDecisions`3<IlxUnionSpec, IlxUnionAlternative, ILType> get_cuspecRepr();
    internal static UnionReprDecisions`3<Tuple`2<ILTypeDef, IlxUnionInfo>, IlxUnionAlternative, NoTypesGeneratedViaThisReprDecider> get_cudefRepr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagPropertyName();
    internal static FSharpList`1<ILType> formalTypeArgs(ILType baseTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec mkConstFieldSpec(string nm, ILType baseTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GetILTypeForAlternative(IlxUnionSpec cuspec, int alt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxUnionAlternative altOfUnionSpec(IlxUnionSpec cuspec, int cidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool doesRuntimeTypeDiscriminateUseHelper(bool avoidHelpers, IlxUnionSpec cuspec, IlxUnionAlternative alt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkRuntimeTypeDiscriminate(ILGlobals ilg, bool avoidHelpers, IlxUnionSpec cuspec, IlxUnionAlternative alt, string altName, ILType altTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkRuntimeTypeDiscriminateThen(ILGlobals ilg, bool avoidHelpers, IlxUnionSpec cuspec, IlxUnionAlternative alt, string altName, ILType altTy, ILInstr after);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkGetTagFromField(ILGlobals ilg, a cuspec, ILType baseTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string adjustFieldName(IlxUnionHasHelpers hasHelpers, string nm);
    internal static FSharpList`1<ILInstr> mkLdData(bool avoidHelpers, IlxUnionSpec cuspec, int cidx, int fidx);
    internal static FSharpList`1<ILInstr> mkLdDataAddr(bool avoidHelpers, IlxUnionSpec cuspec, int cidx, int fidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr mkGetTagFromHelpers(ILGlobals ilg, IlxUnionSpec cuspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkGetTag(ILGlobals ilg, IlxUnionSpec cuspec);
    internal static FSharpList`1<ILInstr> mkCeqThen(ILInstr after);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkTagDiscriminate(ILGlobals ilg, IlxUnionSpec cuspec, a _baseTy, int cidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkTagDiscriminateThen(ILGlobals ilg, IlxUnionSpec cuspec, int cidx, ILInstr after);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<ILType>, FSharpList`1<ILInstr>> extraTysAndInstrsForStructCtor(ILGlobals ilg, int cidx);
    internal static bool takesExtraParams(IlxUnionAlternative[] alts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> convNewDataInstrInternal(ILGlobals ilg, IlxUnionSpec cuspec, int cidx);
    internal static FSharpList`1<ILInstr> mkStData(IlxUnionSpec cuspec, int cidx, int fidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkNewData(ILGlobals ilg, IlxUnionSpec cuspec, int cidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkIsData(ILGlobals ilg, bool avoidHelpers, IlxUnionSpec cuspec, int cidx);
    internal static ILCode genWith(FSharpFunc`2<ICodeGen`1<int>, Unit> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkBrIsData(ILGlobals ilg, bool sense, bool avoidHelpers, IlxUnionSpec cuspec, int cidx, int tg);
    internal static void emitCase@495(ILGlobals ilg, ICodeGen`1<Mark> cg, IlxUnionSpec cuspec, bool avoidHelpers, ILInstr ld, Mark outlab, int cidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitLdDataTagPrim(ILGlobals ilg, FSharpOption`1<ILInstr> ldOpt, ICodeGen`1<Mark> cg, bool avoidHelpers, IlxUnionSpec cuspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitLdDataTag(ILGlobals ilg, ICodeGen`1<Mark> cg, bool avoidHelpers, IlxUnionSpec cuspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitCastData(ILGlobals ilg, ICodeGen`1<Mark> cg, bool canfail, bool avoidHelpers, IlxUnionSpec cuspec, int cidx);
    internal static FSharpFunc`2<int, FSharpFunc`2<a, int>> emitCase@589-1(ICodeGen`1<Mark> cg, Dictionary`2<int, int> dict, Mark failLab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitDataSwitch(ILGlobals ilg, ICodeGen`1<Mark> cg, bool avoidHelpers, IlxUnionSpec cuspec, FSharpList`1<Tuple`2<int, int>> cases);
    [CompilerGeneratedAttribute]
internal static b mapping@1-7(FSharpFunc`2<ILPropertyDef, b> addPropertyGeneratedAttrs, IlxUnionHasHelpers hasHelpers, ILType ilTy, IlxUnionField field);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<b>, FSharpList`1<a>> mkMethodsAndPropertiesForFields(FSharpFunc`2<ILMethodDef, a> addMethodGeneratedAttrs, FSharpFunc`2<ILPropertyDef, b> addPropertyGeneratedAttrs, ILMemberAccess access, FSharpOption`1<ILSourceMarker> attr, IlxUnionHasHelpers hasHelpers, ILType ilTy, IlxUnionField[] fields);
    internal static ILMethodDef addAltAttribs@651(IlxUnionAlternative alt, ILMethodDef mdef);
    [CompilerGeneratedAttribute]
internal static ILParameter mapping@1-8(IlxUnionField fd);
    [CompilerGeneratedAttribute]
internal static ILMethodDef mapping@1-9(FSharpFunc`2<ILMethodDef, ILMethodDef> addMethodGeneratedAttrs, ILTypeDef td, ILType altTy, ILType debugProxyTy, IlxUnionField field);
    [CompilerGeneratedAttribute]
internal static ILPropertyDef mapping@1-10(FSharpFunc`2<ILPropertyDef, ILPropertyDef> addPropertyGeneratedAttrs, ILType debugProxyTy, IlxUnionField fdef);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<ILTypeDef>, FSharpList`1<ILAttribute>> convAlternativeDef$cont@789(FSharpFunc`2<ILType, ILAttribute> mkDebuggerTypeProxyAttribute, FSharpFunc`2<ILPropertyDef, ILPropertyDef> addPropertyGeneratedAttrs, FSharpFunc`2<ILMethodDef, ILMethodDef> addMethodGeneratedAttrs, FSharpFunc`2<ILFieldDef, b> addFieldNeverAttrs, FSharpFunc`2<b, ILFieldDef> addFieldGeneratedAttrs, ILGlobals ilg, ILTypeDef td, IlxUnionInfo cud, IlxUnionField[] fields, ILType altTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ILFieldDef mapping@1-11(FSharpFunc`2<ILFieldDef, b> addFieldNeverAttrs, FSharpFunc`2<b, ILFieldDef> addFieldGeneratedAttrs, bool isTotallyImmutable, IlxUnionField field);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<ILMethodDef>, FSharpList`1<a>, FSharpList`1<ILMethodDef>, FSharpList`1<ILTypeDef>, FSharpList`1<ILTypeDef>, FSharpList`1<Tuple`6<Tuple`2<ILTypeDef, IlxUnionInfo>, IlxUnionAlternative, ILType, int, ILFieldDef, bool>>> convAlternativeDef(FSharpFunc`2<ILMethodDef, ILMethodDef> addMethodGeneratedAttrs, FSharpFunc`2<ILPropertyDef, ILPropertyDef> addPropertyGeneratedAttrs, FSharpFunc`2<ILPropertyDef, a> addPropertyNeverAttrs, FSharpFunc`2<b, ILFieldDef> addFieldGeneratedAttrs, FSharpFunc`2<ILFieldDef, b> addFieldNeverAttrs, FSharpFunc`2<ILType, ILAttribute> mkDebuggerTypeProxyAttribute, ILGlobals ilg, int num, ILTypeDef td, IlxUnionInfo cud, ILTypeDef info_0, IlxUnionInfo info_1, IlxUnionSpec cuspec, ILType baseTy, IlxUnionAlternative alt);
    internal static ILTypeDef addConstFieldInit@997(ILGlobals ilg, IlxUnionInfo cud, ILType baseTy, FSharpList`1<Tuple`6<Tuple`2<ILTypeDef, IlxUnionInfo>, IlxUnionAlternative, ILType, int, ILFieldDef, bool>> altNullaryFields, ILTypeDef cd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef mkClassUnionDef(FSharpFunc`2<ILMethodDef, ILMethodDef> addMethodGeneratedAttrs, FSharpFunc`2<ILPropertyDef, ILPropertyDef> addPropertyGeneratedAttrs, FSharpFunc`2<ILPropertyDef, ILPropertyDef> addPropertyNeverAttrs, FSharpFunc`2<ILFieldDef, ILFieldDef> addFieldGeneratedAttrs, FSharpFunc`2<ILFieldDef, ILFieldDef> addFieldNeverAttrs, FSharpFunc`2<ILType, ILAttribute> mkDebuggerTypeProxyAttribute, ILGlobals ilg, ILTypeRef tref, ILTypeDef td, IlxUnionInfo cud);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Extensions.ILX.IlxSettings : object {
    [DebuggerBrowsableAttribute("0")]
internal static T826942_32Bytes@ field826943@;
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<bool> ilxCompilingFSharpCoreLib { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<FSharpOption`1<ILAssemblyRef>> ilxFsharpCoreLibAssemRef { get; }
    private static IlxSettings();
    internal static FSharpRef`1<bool> get_ilxCompilingFSharpCoreLib();
    internal static FSharpRef`1<FSharpOption`1<ILAssemblyRef>> get_ilxFsharpCoreLibAssemRef();
    internal static ILScopeRef ilxFsharpCoreLibScopeRef();
    internal static string ilxNamespace();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Extensions.ILX.Types : object {
    internal static string mkLowerName(string nm);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@69-18(IlxClosureApps this, IlxClosureApps obj, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxClosureApps instAppsAux(int n, FSharpList`1<ILType> inst, IlxClosureApps _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxClosureLambdas instLambdasAux(int n, FSharpList`1<ILType> inst, IlxClosureLambdas _arg1);
    internal static IlxClosureFreeVar mkILFreeVar(string name, bool compgen, ILType ty);
    internal static Tuple`2<ILType, IlxClosureApps> destTyFuncApp(IlxClosureApps _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxClosureSpec mkILFormalCloRef(FSharpList`1<ILGenericParameterDef> gparams, IlxClosureRef csig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType actualTypOfIlxUnionField(IlxUnionSpec cuspec, int idx, int fidx);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.AbstractIL.IL : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Object;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_String;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Array;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Type;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Int64;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_UInt64;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Int32;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_UInt32;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Int16;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_UInt16;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_SByte;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Byte;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Single;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Double;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Bool;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Char;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_IntPtr;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_UIntPtr;
    [DebuggerBrowsableAttribute("0")]
internal static T826307_32Bytes@ field826308@;
    [DebuggerBrowsableAttribute("0")]
internal static T826318_1Bytes@ field826319@;
    [DebuggerBrowsableAttribute("0")]
internal static T826318_1Bytes@ field826320@;
    [DebuggerBrowsableAttribute("0")]
internal static T826318_1Bytes@ field826321@;
    [DebuggerBrowsableAttribute("0")]
internal static T826318_1Bytes@ field826322@;
    [DebuggerBrowsableAttribute("0")]
internal static T826318_1Bytes@ field826323@;
    [DebuggerBrowsableAttribute("0")]
internal static T826318_1Bytes@ field826325@;
    [DebuggerBrowsableAttribute("0")]
internal static T826432_2Bytes@ field826433@;
    internal static bool logging { get; }
    [CompilationMappingAttribute("9")]
public static bool runningOnMono { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<int> int_order { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, FSharpList`1<string>> memoizeNamespaceTable { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, Tuple`2<FSharpOption`1<string>, string>> memoizeNamespaceRightTable { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, String[]> memoizeNamespaceArrayTable { get; }
    [CompilationMappingAttribute("9")]
internal static String[] emptyStringArray { get; }
    [CompilationMappingAttribute("9")]
internal static UniqueStampGenerator`1<AssemblyRefData> AssemblyRefUniqueStampGenerator { get; }
    [CompilationMappingAttribute("9")]
public static ILAttributes emptyILCustomAttrs { get; }
    [CompilationMappingAttribute("9")]
internal static ILAttributesStored emptyILCustomAttrsStored { get; }
    [CompilationMappingAttribute("9")]
public static ILSecurityDecls emptyILSecurityDecls { get; }
    [CompilationMappingAttribute("9")]
internal static ILSecurityDeclsStored emptyILSecurityDeclsStored { get; }
    public static int NoMetadataIdx { get; }
    public static FSharpList`1<ILGenericParameterDef> mkILEmptyGenericParams { get; }
    internal static FSharpList`1<ILType> emptyILGenericArgsList { get; }
    public static string typeNameForGlobalFunctions { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<int> codeLabelCount { get; }
    [CompilationMappingAttribute("9")]
public static ILTypeDefs emptyILTypeDefs { get; }
    [CompilationMappingAttribute("9")]
public static ILMethodDefs emptyILMethods { get; }
    internal static int defaultSubSystem { get; }
    internal static int defaultPhysAlignment { get; }
    internal static int defaultVirtAlignment { get; }
    internal static int defaultImageBase { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr[] ldargs { get; }
    [CompilationMappingAttribute("9")]
public static ILInstr mkLdarg0 { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr[] ldlocs { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr[] stlocs { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr[] ldi32s { get; }
    internal static string tname_CompilerGeneratedAttribute { get; }
    internal static string tname_DebuggableAttribute { get; }
    [CompilationMappingAttribute("9")]
public static PublicKey ecmaPublicKey { get; }
    [CompilationMappingAttribute("9")]
internal static ILReturn mkILVoidReturn { get; }
    [CompilationMappingAttribute("9")]
public static ILLazyMethodBody methBodyNotAvailable { get; }
    [CompilationMappingAttribute("9")]
internal static MethodBody mb@1535 { get; }
    [CompilationMappingAttribute("9")]
public static ILLazyMethodBody methBodyAbstract { get; }
    [CompilationMappingAttribute("9")]
internal static MethodBody mb@1535-1 { get; }
    [CompilationMappingAttribute("9")]
public static ILLazyMethodBody methBodyNative { get; }
    [CompilationMappingAttribute("9")]
internal static MethodBody mb@1535-2 { get; }
    [CompilationMappingAttribute("9")]
public static ILFieldDefs emptyILFields { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILFieldDef> l@3141 { get; }
    [CompilationMappingAttribute("9")]
public static ILEventDefs emptyILEvents { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILEventDef> l@3147-1 { get; }
    [CompilationMappingAttribute("9")]
public static ILPropertyDefs emptyILProperties { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILPropertyDef> l@3153-2 { get; }
    [CompilationMappingAttribute("9")]
public static ILMethodImplDefs emptyILMethodImpls { get; }
    internal static byte et_END { get; }
    internal static byte et_VOID { get; }
    internal static byte et_BOOLEAN { get; }
    internal static byte et_CHAR { get; }
    internal static byte et_I1 { get; }
    internal static byte et_U1 { get; }
    internal static byte et_I2 { get; }
    internal static byte et_U2 { get; }
    internal static byte et_I4 { get; }
    internal static byte et_U4 { get; }
    internal static byte et_I8 { get; }
    internal static byte et_U8 { get; }
    internal static byte et_R4 { get; }
    internal static byte et_R8 { get; }
    internal static byte et_STRING { get; }
    internal static byte et_PTR { get; }
    internal static byte et_BYREF { get; }
    internal static byte et_VALUETYPE { get; }
    internal static byte et_CLASS { get; }
    internal static byte et_VAR { get; }
    internal static byte et_ARRAY { get; }
    internal static byte et_WITH { get; }
    internal static byte et_TYPEDBYREF { get; }
    internal static byte et_I { get; }
    internal static byte et_U { get; }
    internal static byte et_FNPTR { get; }
    internal static byte et_OBJECT { get; }
    internal static byte et_SZARRAY { get; }
    internal static byte et_MVAR { get; }
    internal static byte et_CMOD_REQD { get; }
    internal static byte et_CMOD_OPT { get; }
    [CompilationMappingAttribute("9")]
internal static ILScopeRef MscorlibScopeRef { get; }
    [CompilationMappingAttribute("9")]
public static ILGlobals EcmaMscorlibILGlobals { get; }
    [CompilationMappingAttribute("9")]
public static ILReferences emptyILRefs { get; }
    [CompilationMappingAttribute("9")]
internal static TimeSpan tspan { get; }
    [CompilationMappingAttribute("9")]
internal static DateTime copyOfStruct@4234-1 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static DateTime copyOfStruct@4234-2 { get; internal set; }
    private static IL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_logging();
    public static bool get_runningOnMono();
    internal static IComparer`1<int> get_int_order();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<b> lazyMap(FSharpFunc`2<a, b> f, Lazy`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, string> splitNameAt(string nm, int idx);
    internal static FSharpList`1<string> splitNamespaceAux(string nm);
    internal static ConcurrentDictionary`2<string, FSharpList`1<string>> get_memoizeNamespaceTable();
    internal static ConcurrentDictionary`2<string, Tuple`2<FSharpOption`1<string>, string>> get_memoizeNamespaceRightTable();
    public static FSharpList`1<string> splitNamespace(string nm);
    internal static ConcurrentDictionary`2<string, String[]> get_memoizeNamespaceArrayTable();
    public static String[] splitNamespaceToArray(string nm);
    public static Tuple`2<FSharpList`1<string>, string> splitILTypeName(string nm);
    internal static String[] get_emptyStringArray();
    public static Tuple`2<String[], string> splitILTypeNameWithPossibleStaticArguments(string nm);
    internal static Tuple`2<FSharpOption`1<string>, string> splitTypeNameRightAux(string nm);
    public static Tuple`2<FSharpOption`1<string>, string> splitTypeNameRight(string nm);
    public static Byte[] sha1HashBytes(Byte[] s);
    public static long sha1HashInt64(Byte[] s);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@360-2(AssemblyRefData this, AssemblyRefData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@360-3(IComparer comp, AssemblyRefData this, AssemblyRefData objTemp, Unit unitVar);
    internal static UniqueStampGenerator`1<AssemblyRefData> get_AssemblyRefUniqueStampGenerator();
    internal static char convDigit@455(int digit);
    public static ILCallingSignature mkILCallSig(ILCallingConv cc, FSharpList`1<ILType> args, ILType ret);
    public static ILType mkILBoxedType(ILTypeSpec tspec);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@911-4(ILSourceMarker this, ILSourceMarker obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@911-5(ILSourceMarker this, ILSourceMarker objTemp, Unit unitVar);
    public static ILAttributes get_emptyILCustomAttrs();
    public static ILAttributes mkILCustomAttrsFromArray(ILAttribute[] attrs);
    public static ILAttributes mkILCustomAttrs(FSharpList`1<ILAttribute> l);
    internal static ILAttributesStored get_emptyILCustomAttrsStored();
    public static ILAttributesStored storeILCustomAttrs(ILAttributes attrs);
    public static ILAttributesStored mkILCustomAttrsReader(FSharpFunc`2<int, ILAttribute[]> f);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1050-6(ILConst this, ILConst obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1050-7(IComparer comp, ILConst this, ILConst objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1050(ILConst this, ILConst obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1208-8(ILExceptionClause this, ILExceptionClause obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1208-9(ILExceptionClause this, ILExceptionClause objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1265-10(ILFieldInit this, ILFieldInit obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1265-11(IComparer comp, ILFieldInit this, ILFieldInit objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@1265(IEqualityComparer comp, ILFieldInit this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1265-1(ILFieldInit this, ILFieldInit that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1265-2(ILFieldInit this, ILFieldInit obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1288-12(ILNativeType this, ILNativeType obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1288-13(IComparer comp, ILNativeType this, ILNativeType objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@1288-1(IEqualityComparer comp, ILNativeType this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1288-3(ILNativeType this, ILNativeType that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1288-4(ILNativeType this, ILNativeType obj, Unit unitVar);
    public static ILSecurityDecls get_emptyILSecurityDecls();
    internal static ILSecurityDeclsStored get_emptyILSecurityDeclsStored();
    public static ILSecurityDecls mkILSecurityDecls(FSharpList`1<ILSecurityDecl> l);
    public static ILSecurityDeclsStored storeILSecurityDecls(ILSecurityDecls x);
    public static ILSecurityDeclsStored mkILSecurityDeclsReader(FSharpFunc`2<int, ILSecurityDecl[]> f);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1503-14(ILMethodVirtualInfo this, ILMethodVirtualInfo obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1503-15(ILMethodVirtualInfo this, ILMethodVirtualInfo objTemp, Unit unitVar);
    public static ILLazyMethodBody mkMethBodyAux(MethodBody mb);
    public static ILLazyMethodBody mkMethBodyLazyAux(Lazy`1<MethodBody> mb);
    public static FSharpList`1<ILType> typesOfILParams(FSharpList`1<ILParameter> ps);
    internal static ILMemberAccess memberAccessOfFlags(int flags);
    internal static MethodAttributes convertMemberAccess(ILMemberAccess ilMemberAccess);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_NoMetadataIdx();
    internal static FieldAttributes convertFieldAccess(ILMemberAccess ilMemberAccess);
    internal static ILTypeDefAccess typeAccessOfFlags(int flags);
    internal static ILDefaultPInvokeEncoding typeEncodingOfFlags(int flags);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefKind typeKindOfFlags(string nm, a _mdefs, b _fdefs, FSharpOption`1<ILType> super, int flags);
    internal static TypeAttributes convertTypeAccessFlags(ILTypeDefAccess access);
    internal static TypeAttributes convertTypeKind(ILTypeDefKind kind);
    internal static TypeAttributes convertToNestedTypeAccess(ILMemberAccess ilMemberAccess);
    public static ILTypeDefStored mkILTypeDefReader(FSharpFunc`2<int, ILTypeDef> f);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2274-16(ILNativeResource this, ILNativeResource obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2274-17(ILNativeResource this, ILNativeResource objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static FSharpList`1<ILGenericParameterDef> get_mkILEmptyGenericParams();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpList`1<ILType> get_emptyILGenericArgsList();
    public static ILTypeRef mkILNestedTyRef(ILScopeRef scope, FSharpList`1<string> l, string nm);
    public static ILTypeRef mkILTyRef(ILScopeRef scope, string nm);
    public static ILTypeSpec mkILTySpec(ILTypeRef tref, FSharpList`1<ILType> inst);
    public static ILTypeSpec mkILNonGenericTySpec(ILTypeRef tref);
    public static ILTypeRef mkILTyRefInTyRef(ILTypeRef tref, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType mkILTy(ILBoxity boxed, ILTypeSpec tspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType mkILNamedTy(ILBoxity vc, ILTypeRef tref, FSharpList`1<ILType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType mkILValueTy(ILTypeRef tref, FSharpList`1<ILType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType mkILBoxedTy(ILTypeRef tref, FSharpList`1<ILType> tinst);
    public static ILType mkILNonGenericValueTy(ILTypeRef tref);
    public static ILType mkILNonGenericBoxedTy(ILTypeRef tref);
    public static ILAssemblyRef mkSimpleAssemblyRef(string n);
    public static ILModuleRef mkSimpleModRef(string n);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_typeNameForGlobalFunctions();
    public static ILType mkILTypeForGlobalFunctions(ILScopeRef scoref);
    public static bool isTypeNameForGlobalFunctions(string d);
    public static ILMethodRef mkILMethRef(ILTypeRef tref, ILCallingConv callconv, string nm, int gparams, FSharpList`1<ILType> args, ILType rty);
    public static ILMethodSpec mkILMethSpecForMethRefInTy(ILMethodRef mref, ILType ty, FSharpList`1<ILType> minst);
    public static ILMethodSpec mkILMethSpec(ILMethodRef mref, ILBoxity vc, FSharpList`1<ILType> tinst, FSharpList`1<ILType> minst);
    internal static ILMethodSpec mkILMethSpecInTypeRef(ILTypeRef tref, ILBoxity vc, ILCallingConv cc, string nm, FSharpList`1<ILType> args, ILType rty, FSharpList`1<ILType> tinst, FSharpList`1<ILType> minst);
    public static ILMethodSpec mkILMethSpecInTy(ILType ty, ILCallingConv cc, string nm, FSharpList`1<ILType> args, ILType rty, FSharpList`1<ILType> minst);
    public static ILMethodSpec mkILNonGenericMethSpecInTy(ILType ty, ILCallingConv cc, string nm, FSharpList`1<ILType> args, ILType rty);
    public static ILMethodSpec mkILInstanceMethSpecInTy(ILType ty, string nm, FSharpList`1<ILType> args, ILType rty, FSharpList`1<ILType> minst);
    public static ILMethodSpec mkILNonGenericInstanceMethSpecInTy(ILType ty, string nm, FSharpList`1<ILType> args, ILType rty);
    public static ILMethodSpec mkILStaticMethSpecInTy(ILType ty, string nm, FSharpList`1<ILType> args, ILType rty, FSharpList`1<ILType> minst);
    public static ILMethodSpec mkILNonGenericStaticMethSpecInTy(ILType ty, string nm, FSharpList`1<ILType> args, ILType rty);
    internal static ILMethodSpec mkILCtorMethSpec(ILTypeRef tref, FSharpList`1<ILType> args, FSharpList`1<ILType> cinst);
    public static ILMethodSpec mkILCtorMethSpecForTy(ILType ty, FSharpList`1<ILType> args);
    public static ILFieldRef mkILFieldRef(ILTypeRef tref, string nm, ILType ty);
    public static ILFieldSpec mkILFieldSpec(ILFieldRef tref, ILType ty);
    public static ILFieldSpec mkILFieldSpecInTy(ILType ty, string nm, ILType fty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILTailcall andTailness(ILTailcall x, bool y);
    public static string formatCodeLabel(int x);
    internal static FSharpRef`1<int> get_codeLabelCount();
    public static int generateCodeLabel();
    public static ILCode nonBranchingInstrsToCode(FSharpList`1<ILInstr> instrs);
    public static ILType mkILTyvarTy(ushort tv);
    public static ILGenericParameterDef mkILSimpleTypar(string nm);
    public static FSharpList`1<ILGenericParameterDef> mkILFormalTypars(FSharpList`1<ILType> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<ILType> mkILFormalGenericArgs(int numtypars, FSharpList`1<ILGenericParameterDef> gparams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType mkILFormalBoxedTy(ILTypeRef tref, FSharpList`1<ILGenericParameterDef> gparams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType mkILFormalNamedTy(ILBoxity bx, ILTypeRef tref, FSharpList`1<ILGenericParameterDef> gparams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILTypeRef mkRefForNestedILTypeDef(ILScopeRef scope, FSharpList`1<ILTypeDef> enc, ILTypeDef td);
    public static ILPreTypeDef mkILPreTypeDef(ILTypeDef td);
    public static ILPreTypeDef mkILPreTypeDefComputed(FSharpList`1<string> ns, string n, FSharpFunc`2<Unit, ILTypeDef> f);
    public static ILPreTypeDef mkILPreTypeDefRead(FSharpList`1<string> ns, string n, int idx, ILTypeDefStored f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILTypeDefs addILTypeDef(ILTypeDef td, ILTypeDefs tdefs);
    public static ILTypeDefs mkILTypeDefsFromArray(ILTypeDef[] l);
    public static ILTypeDefs mkILTypeDefs(FSharpList`1<ILTypeDef> l);
    public static ILTypeDefs mkILTypeDefsComputed(FSharpFunc`2<Unit, ILPreTypeDef[]> f);
    public static ILTypeDefs get_emptyILTypeDefs();
    public static ILMethodDefs mkILMethodsFromArray(ILMethodDef[] xs);
    public static ILMethodDefs mkILMethods(FSharpList`1<ILMethodDef> xs);
    public static ILMethodDefs mkILMethodsComputed(FSharpFunc`2<Unit, ILMethodDef[]> f);
    public static ILMethodDefs get_emptyILMethods();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_defaultSubSystem();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_defaultPhysAlignment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_defaultVirtAlignment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_defaultImageBase();
    public static ILType mkILArrTy(ILType ty, ILArrayShape shape);
    public static ILType mkILArr1DTy(ILType ty);
    public static bool isILArrTy(ILType ty);
    public static Tuple`2<ILArrayShape, ILType> destILArrTy(ILType ty);
    public static ILGlobals mkILGlobals(ILScopeRef primaryScopeRef);
    public static ILInstr mkNormalCall(ILMethodSpec mspec);
    public static ILInstr mkNormalCallvirt(ILMethodSpec mspec);
    public static ILInstr mkNormalCallconstraint(ILType ty, ILMethodSpec mspec);
    public static ILInstr mkNormalNewobj(ILMethodSpec mspec);
    internal static ILInstr[] get_ldargs();
    public static ILInstr mkLdarg(ushort i);
    public static ILInstr get_mkLdarg0();
    internal static ILInstr[] get_ldlocs();
    public static ILInstr mkLdloc(ushort i);
    internal static ILInstr[] get_stlocs();
    public static ILInstr mkStloc(ushort i);
    internal static ILInstr[] get_ldi32s();
    public static ILInstr mkLdcInt32(int i);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tname_CompilerGeneratedAttribute();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tname_DebuggableAttribute();
    public static PublicKey get_ecmaPublicKey();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isPrimaryAssemblyTySpec(ILTypeSpec tspec, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILBoxedPrimaryAssemblyTy(ILType ty, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILValuePrimaryAssemblyTy(ILType ty, string n);
    public static bool isILObjectTy(ILType ty);
    public static bool isILStringTy(ILType ty);
    public static bool isILTypedReferenceTy(ILType ty);
    public static bool isILSByteTy(ILType ty);
    public static bool isILByteTy(ILType ty);
    public static bool isILInt16Ty(ILType ty);
    public static bool isILUInt16Ty(ILType ty);
    public static bool isILInt32Ty(ILType ty);
    public static bool isILUInt32Ty(ILType ty);
    public static bool isILInt64Ty(ILType ty);
    public static bool isILUInt64Ty(ILType ty);
    public static bool isILIntPtrTy(ILType ty);
    public static bool isILUIntPtrTy(ILType ty);
    public static bool isILBoolTy(ILType ty);
    public static bool isILCharTy(ILType ty);
    public static bool isILSingleTy(ILType ty);
    public static bool isILDoubleTy(ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILScopeRef rescopeILScopeRef(ILScopeRef scoref, ILScopeRef scoref1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef rescopeILTypeRef(ILScopeRef scoref, ILTypeRef tref1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILTypeSpec rescopeILTypeSpec(ILScopeRef scoref, ILTypeSpec tspec1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType rescopeILType(ILScopeRef scoref, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> rescopeILTypes(ILScopeRef scoref, FSharpList`1<ILType> i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCallingSignature rescopeILCallSig(ILScopeRef scoref, ILCallingSignature csig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILMethodRef rescopeILMethodRef(ILScopeRef scoref, ILMethodRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILFieldRef rescopeILFieldRef(ILScopeRef scoref, ILFieldRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType instILTypeAux(int numFree, FSharpList`1<ILType> inst, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> instILGenericArgsAux(int numFree, FSharpList`1<ILType> inst, FSharpList`1<ILType> i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCallingSignature instILCallSigAux(int numFree, FSharpList`1<ILType> inst, ILCallingSignature csig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType instILType(FSharpList`1<ILType> i, ILType t);
    public static ILParameter mkILParam(FSharpOption`1<string> name, ILType ty);
    public static ILParameter mkILParamNamed(string s, ILType ty);
    public static ILParameter mkILParamAnon(ILType ty);
    public static ILReturn mkILReturn(ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILLocal mkILLocal(ILType ty, FSharpOption`1<Tuple`3<string, int, int>> dbgInfo);
    public static ILMethodBody mkILMethodBody(bool initlocals, FSharpList`1<ILLocal> locals, int maxstack, ILCode code, FSharpOption`1<ILSourceMarker> tag);
    public static MethodBody mkMethodBody(bool zeroinit, FSharpList`1<ILLocal> locals, int maxstack, ILCode code, FSharpOption`1<ILSourceMarker> tag);
    internal static ILReturn get_mkILVoidReturn();
    public static ILLazyMethodBody get_methBodyNotAvailable();
    internal static MethodBody get_mb@1535();
    public static ILLazyMethodBody get_methBodyAbstract();
    internal static MethodBody get_mb@1535-1();
    public static ILLazyMethodBody get_methBodyNative();
    internal static MethodBody get_mb@1535-2();
    public static ILMethodDef mkILCtor(ILMemberAccess access, FSharpList`1<ILParameter> args, MethodBody impl);
    public static FSharpList`1<ILInstr> mkCallBaseConstructor(ILType ty, FSharpList`1<ILType> args);
    public static ILInstr mkNormalStfld(ILFieldSpec fspec);
    public static ILInstr mkNormalStsfld(ILFieldSpec fspec);
    public static ILInstr mkNormalLdsfld(ILFieldSpec fspec);
    public static ILInstr mkNormalLdfld(ILFieldSpec fspec);
    public static ILInstr mkNormalLdflda(ILFieldSpec fspec);
    public static ILInstr mkNormalLdobj(ILType dt);
    public static ILInstr mkNormalStobj(ILType dt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILMethodDef mkILNonGenericEmptyCtor(FSharpOption`1<ILSourceMarker> tag, ILType superTy);
    public static ILMethodDef mkILStaticMethod(FSharpList`1<ILGenericParameterDef> genparams, string nm, ILMemberAccess access, FSharpList`1<ILParameter> args, ILReturn ret, MethodBody impl);
    public static ILMethodDef mkILNonGenericStaticMethod(string nm, ILMemberAccess access, FSharpList`1<ILParameter> args, ILReturn ret, MethodBody impl);
    public static ILMethodDef mkILClassCtor(MethodBody impl);
    public static ILMethodDef mkILGenericVirtualMethod(string nm, ILMemberAccess access, FSharpList`1<ILGenericParameterDef> genparams, FSharpList`1<ILParameter> actual_args, ILReturn actual_ret, MethodBody impl);
    public static ILMethodDef mkILNonGenericVirtualMethod(string nm, ILMemberAccess access, FSharpList`1<ILParameter> args, ILReturn ret, MethodBody impl);
    public static ILMethodDef mkILGenericNonVirtualMethod(string nm, ILMemberAccess access, FSharpList`1<ILGenericParameterDef> genparams, FSharpList`1<ILParameter> actual_args, ILReturn actual_ret, MethodBody impl);
    public static ILMethodDef mkILNonGenericInstanceMethod(string nm, ILMemberAccess access, FSharpList`1<ILParameter> args, ILReturn ret, MethodBody impl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodBody ilmbody_code2code(FSharpFunc`2<ILCode, ILCode> f, ILMethodBody il);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef mdef_code2code(FSharpFunc`2<ILCode, ILCode> f, ILMethodDef md);
    [CompilerGeneratedAttribute]
internal static ILCode prependInstrsToCode$cont@3061(ILCode c2, ILInstr[] instrs, int n, ILInstr matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILCode prependInstrsToCode(FSharpList`1<ILInstr> instrs, ILCode c2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILMethodDef prependInstrsToMethod(FSharpList`1<ILInstr> new_code, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef cdef_cctorCode2CodeOrCreate(FSharpOption`1<ILSourceMarker> tag, FSharpFunc`2<ILMethodDef, ILMethodDef> f, ILTypeDef cd);
    public static ILMethodRef mkRefToILMethod(ILTypeRef tref, ILMethodDef md);
    public static ILFieldRef mkRefToILField(ILTypeRef tref, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILMethodRef mkRefForILMethod(ILScopeRef scope, FSharpList`1<ILTypeDef> tdefs, ILTypeDef tdef, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILFieldRef mkRefForILField(ILScopeRef scope, FSharpList`1<ILTypeDef> tdefs, ILTypeDef tdef, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILTypeDef prependInstrsToClassCtor(FSharpList`1<ILInstr> instrs, FSharpOption`1<ILSourceMarker> tag, ILTypeDef cd);
    internal static ILFieldDef mkILField(bool isStatic, string nm, ILType ty, FSharpOption`1<ILFieldInit> init, FSharpOption`1<Byte[]> at, ILMemberAccess access, bool isLiteral);
    public static ILFieldDef mkILInstanceField(string nm, ILType ty, FSharpOption`1<ILFieldInit> init, ILMemberAccess access);
    public static ILFieldDef mkILStaticField(string nm, ILType ty, FSharpOption`1<ILFieldInit> init, FSharpOption`1<Byte[]> at, ILMemberAccess access);
    public static ILFieldDef mkILLiteralField(string nm, ILType ty, ILFieldInit init, FSharpOption`1<Byte[]> at, ILMemberAccess access);
    public static ILFieldDefs mkILFieldsLazy(Lazy`1<FSharpList`1<ILFieldDef>> l);
    public static ILFieldDefs mkILFields(FSharpList`1<ILFieldDef> l);
    public static ILFieldDefs get_emptyILFields();
    internal static FSharpList`1<ILFieldDef> get_l@3141();
    public static ILEventDefs mkILEventsLazy(Lazy`1<FSharpList`1<ILEventDef>> l);
    public static ILEventDefs mkILEvents(FSharpList`1<ILEventDef> l);
    public static ILEventDefs get_emptyILEvents();
    internal static FSharpList`1<ILEventDef> get_l@3147-1();
    public static ILPropertyDefs mkILPropertiesLazy(Lazy`1<FSharpList`1<ILPropertyDef>> l);
    public static ILPropertyDefs mkILProperties(FSharpList`1<ILPropertyDef> l);
    public static ILPropertyDefs get_emptyILProperties();
    internal static FSharpList`1<ILPropertyDef> get_l@3153-2();
    public static ILExportedTypesAndForwarders mkILExportedTypes(FSharpList`1<ILExportedTypeOrForwarder> l);
    public static ILExportedTypesAndForwarders mkILExportedTypesLazy(Lazy`1<FSharpList`1<ILExportedTypeOrForwarder>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILExportedTypeOrForwarder mkTypeForwarder(ILScopeRef scopeRef, string name, ILNestedExportedTypes nested, ILAttributes customAttrs, ILTypeDefAccess access);
    public static ILNestedExportedTypes mkILNestedExportedTypes(FSharpList`1<ILNestedExportedType> l);
    public static ILNestedExportedTypes mkILNestedExportedTypesLazy(Lazy`1<FSharpList`1<ILNestedExportedType>> l);
    public static ILResources mkILResources(FSharpList`1<ILResource> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<Tuple`2<string, int>, FSharpList`1<ILMethodImplDef>> addMethodImplToTable(ILMethodImplDef y, FSharpMap`2<Tuple`2<string, int>, FSharpList`1<ILMethodImplDef>> tab);
    public static ILMethodImplDefs mkILMethodImpls(FSharpList`1<ILMethodImplDef> l);
    public static ILMethodImplDefs mkILMethodImplsLazy(Lazy`1<FSharpList`1<ILMethodImplDef>> l);
    public static ILMethodImplDefs get_emptyILMethodImpls();
    internal static ILMethodDef mkILStorageCtorWithParamNames(FSharpOption`1<ILSourceMarker> tag, FSharpList`1<ILInstr> preblock, ILType ty, FSharpList`1<ILParameter> extraParams, FSharpList`1<Tuple`3<string, string, ILType>> flds, ILMemberAccess access);
    public static ILMethodDef mkILSimpleStorageCtorWithParamNames(FSharpOption`1<ILSourceMarker> tag, FSharpOption`1<ILTypeSpec> baseTySpec, ILType ty, FSharpList`1<ILParameter> extraParams, FSharpList`1<Tuple`3<string, string, ILType>> flds, ILMemberAccess access);
    internal static FSharpList`1<Tuple`3<a, a, b>> addParamNames(FSharpList`1<Tuple`2<a, b>> flds);
    public static ILMethodDef mkILSimpleStorageCtor(FSharpOption`1<ILSourceMarker> tag, FSharpOption`1<ILTypeSpec> baseTySpec, ILType ty, FSharpList`1<ILParameter> extraParams, FSharpList`1<Tuple`2<string, ILType>> flds, ILMemberAccess access);
    public static ILMethodDef mkILStorageCtor(FSharpOption`1<ILSourceMarker> tag, FSharpList`1<ILInstr> preblock, ILType ty, FSharpList`1<Tuple`2<string, ILType>> flds, ILMemberAccess access);
    public static ILTypeDef mkILGenericClass(string nm, ILTypeDefAccess access, FSharpList`1<ILGenericParameterDef> genparams, ILType extends, FSharpList`1<ILType> impl, ILMethodDefs methods, ILFieldDefs fields, ILTypeDefs nestedTypes, ILPropertyDefs props, ILEventDefs events, ILAttributes attrs, ILTypeInit init);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILTypeDef mkRawDataValueTypeDef(ILType iltyp_ValueType, string nm, int size, ushort pack);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILTypeDef mkILSimpleClass(ILGlobals ilg, string nm, ILTypeDefAccess access, ILMethodDefs methods, ILFieldDefs fields, ILTypeDefs nestedTypes, ILPropertyDefs props, ILEventDefs events, ILAttributes attrs, ILTypeInit init);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILTypeDef mkILTypeDefForGlobalFunctions(ILGlobals ilg, ILMethodDefs methods, ILFieldDefs fields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<ILTypeDef> destTypeDefsWithGlobalFunctionsFirst(ILGlobals ilg, ILTypeDefs tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILModuleDef mkILSimpleModule(string assemblyName, string moduleName, bool dll, Tuple`2<int, int> subsystemVersion, bool useHighEntropyVA, ILTypeDefs tdefs, FSharpOption`1<int> hashalg, FSharpOption`1<string> locale, int flags, ILExportedTypesAndForwarders exportedTypes, string metadataVersion);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILCode buildILCode(string _methName, Dictionary`2<int, int> lab2pc, ILInstr[] instrs, FSharpList`1<ILExceptionSpec> tryspecs, FSharpList`1<ILLocalDebugInfo> localspecs);
    internal static ILMethodDef one@3341(ILMemberAccess access, string nm, FSharpList`1<ILParameter> args, ILType ret);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<ILMethodDef> mkILDelegateMethods(ILMemberAccess access, ILGlobals ilg, ILType iltyp_AsyncCallback, ILType iltyp_IAsyncResult, FSharpList`1<ILParameter> parms, ILReturn rtv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILMethodSpec mkCtorMethSpecForDelegate(ILGlobals ilg, ILType ty, bool useUIntPtr);
    public static ILType getTyOfILEnumInfo(ILEnumInfo info);
    public static ILEnumInfo computeILEnumInfo(string mdName, ILFieldDefs mdFields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<byte, int> sigptr_get_u8(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<sbyte, int> sigptr_get_i8(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ushort, int> sigptr_get_u16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<short, int> sigptr_get_i16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptr_get_i32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<UInt32, int> sigptr_get_u32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<long, int> sigptr_get_i64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ulong, int> sigptr_get_u64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<float, int> sigptr_get_ieee32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<double, int> sigptr_get_ieee64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Byte[], int> sigptr_get_intarray(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> sigptr_get_string(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptr_get_z_i32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> sigptr_get_serstring(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<string>, int> sigptr_get_serstring_possibly_null(Byte[] bytes, int sigptr);
    public static ILAssemblyRef mkRefToILAssembly(ILAssemblyManifest m);
    internal static Byte[] z_unsigned_int(int n);
    internal static Byte[] u16AsBytes(ushort x);
    internal static Byte[] i32AsBytes(int i);
    internal static Byte[] i64AsBytes(long i);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_END();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VOID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_BOOLEAN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CHAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_STRING();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_PTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_BYREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VALUETYPE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CLASS();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_ARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_WITH();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_TYPEDBYREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_FNPTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_SZARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_MVAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CMOD_REQD();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CMOD_OPT();
    public static string formatILVersion(ILVersionInfo version);
    internal static Byte[] encodeCustomAttrString(string s);
    internal static Byte[] encodeCustomAttrElemType(ILType x);
    internal static Byte[] encodeCustomAttrElemTypeForObject(ILAttribElem x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILType, int> decodeCustomAttrElemType(ILGlobals ilg, Byte[] bytes, int sigptr, byte x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] encodeCustomAttrPrimValue(a ilg, ILAttribElem c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] encodeCustomAttrValue(a ilg, ILType ty, ILAttribElem c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] encodeCustomAttrNamedArg(a ilg, string nm, ILType ty, bool prop, ILAttribElem elem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] encodeCustomAttrArgs(ILGlobals ilg, ILMethodSpec mspec, FSharpList`1<ILAttribElem> fixedArgs, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> namedArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute encodeCustomAttr(ILGlobals ilg, ILMethodSpec mspec, FSharpList`1<ILAttribElem> fixedArgs, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> namedArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILAttribute mkILCustomAttribMethRef(ILGlobals ilg, ILMethodSpec mspec, FSharpList`1<ILAttribElem> fixedArgs, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> namedArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILAttribute mkILCustomAttribute(ILGlobals ilg, ILTypeRef tref, FSharpList`1<ILType> argtys, FSharpList`1<ILAttribElem> argvs, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> propvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] getCustomAttrData(ILGlobals ilg, ILAttribute cattr);
    internal static ILScopeRef get_MscorlibScopeRef();
    public static ILGlobals get_EcmaMscorlibILGlobals();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILSecurityDecl mkPermissionSet(ILGlobals ilg, ILSecurityAction action, FSharpList`1<Tuple`2<ILTypeRef, FSharpList`1<Tuple`3<string, ILType, ILAttribElem>>>> attributes);
    internal static string grabScopeComponent@3824(ILTypeSigParser x, Unit unitVar0);
    internal static Tuple`2<FSharpList`1<ILAttribElem>, int> parseElems@3949(ILGlobals ilg, Byte[] bytes, ILType elemTy, FSharpList`1<ILAttribElem> acc, int n, int sigptr);
    internal static Tuple`2<ILAttribElem, int> parseVal@3888(ILGlobals ilg, Byte[] bytes, ILType argty, int sigptr);
    internal static Tuple`2<FSharpList`1<ILAttribElem>, int> parseFixed@3959(ILGlobals ilg, Byte[] bytes, FSharpList`1<ILType> argtys, int sigptr);
    internal static FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> parseNamed@3968(ILGlobals ilg, Byte[] bytes, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> acc, int n, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>> decodeILAttribData(ILGlobals ilg, ILAttribute ca);
    public static ILReferences get_emptyILRefs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_scoref(ILReferencesAccumulator s, ILScopeRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_typ(ILReferencesAccumulator s, ILType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_tspec(ILReferencesAccumulator s, ILTypeSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_callsig(ILReferencesAccumulator s, ILCallingSignature csig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_genparams(ILReferencesAccumulator s, FSharpList`1<ILGenericParameterDef> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_mref(ILReferencesAccumulator s, ILMethodRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_fref(ILReferencesAccumulator s, ILFieldRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_ospec(ILReferencesAccumulator s, ILOverridesSpec _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_mspec(ILReferencesAccumulator s, ILMethodSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_tys(ILReferencesAccumulator s, FSharpList`1<ILType> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_token(ILReferencesAccumulator s, ILToken x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_custom_attrs(ILReferencesAccumulator s, ILAttributes cas);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_varargs(ILReferencesAccumulator s, FSharpOption`1<FSharpList`1<ILType>> tyso);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_instr(ILReferencesAccumulator s, ILInstr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_il_code(ILReferencesAccumulator s, ILCode c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_ilmbody(ILReferencesAccumulator s, ILMethodBody il);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_local(ILReferencesAccumulator s, ILLocal loc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_mbody(ILReferencesAccumulator s, MethodBody x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_mdef(ILReferencesAccumulator s, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_param(ILReferencesAccumulator s, ILParameter p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_return(ILReferencesAccumulator s, ILReturn rt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_mdefs(ILReferencesAccumulator s, IEnumerable`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_event_def(ILReferencesAccumulator s, ILEventDef ed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_events(ILReferencesAccumulator s, ILEventDefs x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_property_def(ILReferencesAccumulator s, ILPropertyDef pd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_properties(ILReferencesAccumulator s, ILPropertyDefs x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_fdef(ILReferencesAccumulator s, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_fields(ILReferencesAccumulator s, FSharpList`1<b> fields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_method_impls(ILReferencesAccumulator s, FSharpList`1<ILMethodImplDef> mimpls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_method_impl(ILReferencesAccumulator s, ILMethodImplDef m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_tdef(ILReferencesAccumulator s, ILTypeDef td);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_types(ILReferencesAccumulator s, ILTypeDefs types);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_exported_types(ILReferencesAccumulator s, ILExportedTypesAndForwarders tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_resource_where(ILReferencesAccumulator s, ILResourceLocation x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_resource(ILReferencesAccumulator s, ILResource x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_resources(ILReferencesAccumulator s, ILResources tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_modul(ILReferencesAccumulator s, ILModuleDef m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refs_of_manifest(ILReferencesAccumulator s, ILAssemblyManifest m);
    public static ILReferences computeILRefs(ILModuleDef modul);
    internal static TimeSpan get_tspan();
    internal static DateTime get_copyOfStruct@4234-1();
    internal static void set_copyOfStruct@4234-1(DateTime value);
    internal static DateTime get_copyOfStruct@4234-2();
    internal static void set_copyOfStruct@4234-2(DateTime value);
    internal static ushort zero32@4260(int n);
    public static ILVersionInfo parseILVersion(string vstr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int compareILVersions(ILVersionInfo version1, ILVersionInfo version2);
    internal static ILTypeRef unscopeILTypeRef(ILTypeRef x);
    internal static ILTypeSpec unscopeILTypeSpec(ILTypeSpec tspec);
    public static ILType unscopeILType(ILType ty);
    internal static FSharpList`1<ILType> unscopeILTypes(FSharpList`1<ILType> i);
    internal static ILCallingSignature unscopeILCallSig(ILCallingSignature csig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILMethodDef resolveILMethodRefWithRescope(FSharpFunc`2<ILType, ILType> r, ILTypeDef td, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILMethodDef resolveILMethodRef(ILTypeDef td, ILMethodRef mref);
    public static ILModuleRef mkRefToILModule(ILModuleDef m);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILAsciiWriter : object {
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.AbstractIL.ILBinaryReader : object {
    [DebuggerBrowsableAttribute("0")]
internal static T826771_32Bytes@ field826772@;
    internal static bool checking { get; }
    internal static bool logging { get; }
    [CompilationMappingAttribute("9")]
internal static bool noStableFileHeuristic { get; }
    [CompilationMappingAttribute("9")]
internal static bool alwaysMemoryMapFSC { get; }
    internal static int stronglyHeldReaderCacheSizeDefault { get; }
    [CompilationMappingAttribute("9")]
internal static int stronglyHeldReaderCacheSize { get; }
    [CompilationMappingAttribute("9")]
internal static Statistics stats { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<FSharpOption`1<ILInstrDecoder[]>> oneByteInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<FSharpOption`1<ILInstrDecoder[]>> twoByteInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindAssemblyRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindModuleRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFileRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindTypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindTypeSpec { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindTypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindPropertyMap { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindEventMap { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindInterfaceImpl { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindNested { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindCustomAttribute { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindDeclSecurity { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMemberRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindStandAloneSig { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFieldRVA { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFieldMarshal { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindConstant { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFieldLayout { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindParam { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMethodImpl { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindImplMap { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMethodSemantics { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindProperty { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindEvent { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindManifestResource { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindClassLayout { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindExportedType { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindAssembly { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindGenericParam_v1_1 { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindGenericParam_v2_0 { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMethodSpec { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindGenericParamConstraint { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindModule { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindIllegal { get; }
    [CompilationMappingAttribute("9")]
internal static Byte[] emptyByteArray { get; }
    [CompilationMappingAttribute("9")]
internal static AgedLookup`3<ILModuleReaderCache1LockToken, ILModuleReaderCacheKey, ILModuleReader> ilModuleReaderCache1 { get; }
    [CompilationMappingAttribute("9")]
internal static Lock`1<ILModuleReaderCache1LockToken> ilModuleReaderCache1Lock { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<ILModuleReaderCacheKey, WeakReference`1<ILModuleReader>> ilModuleReaderCache2 { get; }
    private static ILBinaryReader();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_checking();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_logging();
    internal static bool get_noStableFileHeuristic();
    internal static bool get_alwaysMemoryMapFSC();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_stronglyHeldReaderCacheSizeDefault();
    internal static int get_stronglyHeldReaderCacheSize();
    internal static Tuple`2<TableName, int> i32ToUncodedToken(int tok);
    internal static TaggedIndex`1<TypeDefOrRefTag> uncodedTokenToTypeDefOrRefOrSpec(TableName tab, int tok);
    internal static TaggedIndex`1<MethodDefOrRefTag> uncodedTokenToMethodDefOrRef(TableName tab, int tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<a> tokToTaggedIdx(FSharpFunc`2<int, a> f, int nbits, int tok);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@94-21(Statistics this, Statistics obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@94-22(Statistics this, Statistics objTemp, Unit unitVar);
    internal static Statistics get_stats();
    public static Statistics GetStatistics();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static long seekReadInt64(BinaryView mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadCompressedUInt32(BinaryView mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekCountUtf8String(BinaryView mdv, int addr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string seekReadUTF8String(BinaryView mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] seekReadBlob(BinaryView mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string seekReadUserString(BinaryView mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, int> sigptrGetBool(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<sbyte, int> sigptrGetSByte(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ushort, int> sigptrGetUInt16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<short, int> sigptrGetInt16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptrGetInt32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<UInt32, int> sigptrGetUInt32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ulong, int> sigptrGetUInt64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<long, int> sigptrGetInt64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<float, int> sigptrGetSingle(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<double, int> sigptrGetDouble(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptrGetZInt32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<a>, int> sigptrFoldAcc(FSharpFunc`2<Byte[], FSharpFunc`2<int, Tuple`2<a, int>>> f, int n, Byte[] bytes, int sigptr, int i, FSharpList`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Byte[], int> sigptrGetBytes(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> sigptrGetString(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a noPrefixes(a mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a volatileOrUnalignedPrefix(FSharpFunc`2<Tuple`2<ILAlignment, ILVolatility>, a> mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a volatilePrefix(FSharpFunc`2<ILVolatility, a> mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a tailPrefix(FSharpFunc`2<ILTailcall, a> mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a constraintOrTailPrefix(FSharpFunc`2<Tuple`2<FSharpOption`1<ILType>, ILTailcall>, a> mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a readonlyPrefix(FSharpFunc`2<ILReadonly, a> mk, ILInstrPrefixesRegister prefixes);
    internal static FSharpFunc`2<ILInstrPrefixesRegister, ILInstr> mkStind(ILBasicType dt);
    internal static FSharpFunc`2<ILInstrPrefixesRegister, ILInstr> mkLdind(ILBasicType dt);
    internal static FSharpList`1<Tuple`2<int, ILInstrDecoder>> instrs();
    internal static FSharpRef`1<FSharpOption`1<ILInstrDecoder[]>> get_oneByteInstrs();
    internal static FSharpRef`1<FSharpOption`1<ILInstrDecoder[]>> get_twoByteInstrs();
    internal static void addInstr@742(ILInstrDecoder[] oneByteInstrTable, ILInstrDecoder[] twoByteInstrTable, Tuple`2<int, ILInstrDecoder> tupledArg);
    internal static void fillInstrs();
    internal static ILInstrDecoder getOneByteInstr(int i);
    internal static ILInstrDecoder getTwoByteInstr(int i);
    internal static RowKind get_kindAssemblyRef();
    internal static RowKind get_kindModuleRef();
    internal static RowKind get_kindFileRef();
    internal static RowKind get_kindTypeRef();
    internal static RowKind get_kindTypeSpec();
    internal static RowKind get_kindTypeDef();
    internal static RowKind get_kindPropertyMap();
    internal static RowKind get_kindEventMap();
    internal static RowKind get_kindInterfaceImpl();
    internal static RowKind get_kindNested();
    internal static RowKind get_kindCustomAttribute();
    internal static RowKind get_kindDeclSecurity();
    internal static RowKind get_kindMemberRef();
    internal static RowKind get_kindStandAloneSig();
    internal static RowKind get_kindFieldDef();
    internal static RowKind get_kindFieldRVA();
    internal static RowKind get_kindFieldMarshal();
    internal static RowKind get_kindConstant();
    internal static RowKind get_kindFieldLayout();
    internal static RowKind get_kindParam();
    internal static RowKind get_kindMethodDef();
    internal static RowKind get_kindMethodImpl();
    internal static RowKind get_kindImplMap();
    internal static RowKind get_kindMethodSemantics();
    internal static RowKind get_kindProperty();
    internal static RowKind get_kindEvent();
    internal static RowKind get_kindManifestResource();
    internal static RowKind get_kindClassLayout();
    internal static RowKind get_kindExportedType();
    internal static RowKind get_kindAssembly();
    internal static RowKind get_kindGenericParam_v1_1();
    internal static RowKind get_kindGenericParam_v2_0();
    internal static RowKind get_kindMethodSpec();
    internal static RowKind get_kindGenericParamConstraint();
    internal static RowKind get_kindModule();
    internal static RowKind get_kindIllegal();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hcCompare(TaggedIndex`1<HasConstantTag> _arg2, TaggedIndex`1<HasConstantTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hsCompare(TaggedIndex`1<HasSemanticsTag> _arg2, TaggedIndex`1<HasSemanticsTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hcaCompare(TaggedIndex`1<HasCustomAttributeTag> _arg2, TaggedIndex`1<HasCustomAttributeTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int mfCompare(TaggedIndex`1<MemberForwardedTag> _arg2, TaggedIndex`1<MemberForwardedTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hdsCompare(TaggedIndex`1<HasDeclSecurityTag> _arg2, TaggedIndex`1<HasDeclSecurityTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hfmCompare(TaggedIndex`1<HasFieldMarshalTag> _arg2, TaggedIndex`1<HasFieldMarshalTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int tomdCompare(TaggedIndex`1<TypeOrMethodDefTag> _arg2, TaggedIndex`1<TypeOrMethodDefTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int simpleIndexCompare(int idx1, int idx2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpFunc`2<int, d>, FSharpFunc`2<int, d>> mkCacheInt32(bool lowMem, a _inbase, b _nm, c _sz);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpFunc`2<T, d>, FSharpFunc`2<T, d>> mkCacheGeneric(bool lowMem, a _inbase, b _nm, c _sz);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<c> seekReadIndexedRows$cont@951(FSharpFunc`2<int, a> rowReader, FSharpFunc`2<a, c> rowConverter, int numRows, FSharpFunc`2<a, b> keyFunc, FSharpFunc`2<b, int> keyComparer, Unit unitVar);
    internal static FSharpList`1<c> seekReadIndexedRows(int numRows, FSharpFunc`2<int, a> rowReader, FSharpFunc`2<a, b> keyFunc, FSharpFunc`2<b, int> keyComparer, bool binaryChop, FSharpFunc`2<a, c> rowConverter);
    internal static FSharpOption`1<c> seekReadOptionalIndexedRow(int info_0, FSharpFunc`2<int, a> info_1, FSharpFunc`2<a, b> info_2, FSharpFunc`2<b, int> info_3, bool info_4, FSharpFunc`2<a, c> info_5);
    internal static c seekReadIndexedRow(int info_0, FSharpFunc`2<int, a> info_1, FSharpFunc`2<a, b> info_2, FSharpFunc`2<b, int> info_3, bool info_4, FSharpFunc`2<a, c> info_5);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1044-23(MethodData thisCast, MethodData objCast, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1044-24(IComparer comp, MethodData thisCastu, MethodData thatCastu, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1044-5(MethodData this, MethodData that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1045-25(VarArgMethodData thisCast, VarArgMethodData objCast, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1045-26(IComparer comp, VarArgMethodData thisCastu, VarArgMethodData thatCastu, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@1045-2(IEqualityComparer comp, VarArgMethodData this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1045-6(VarArgMethodData this, VarArgMethodData that, IEqualityComparer comp, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadUInt16AsInt32Adv(BinaryView mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<a> seekReadTaggedIdx(FSharpFunc`2<int, a> f, int nbits, bool big, BinaryView mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadIdx(bool big, BinaryView mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<ushort, int, int, int, int> seekReadModuleRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TaggedIndex`1<ResolutionScopeTag>, int, int> seekReadTypeRefRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<int, int, int, TaggedIndex`1<TypeDefOrRefTag>, int, int> seekReadTypeDefRowUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, int> seekReadFieldRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<int, int, int, int, int, int> seekReadMethodRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, int> seekReadParamRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, TaggedIndex`1<TypeDefOrRefTag>> seekReadInterfaceImplRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TaggedIndex`1<MemberRefParentTag>, int, int> seekReadMemberRefRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ushort, TaggedIndex`1<HasConstantTag>, int> seekReadConstantRowUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TaggedIndex`1<HasCustomAttributeTag>, TaggedIndex`1<CustomAttributeTypeTag>, int> seekReadCustomAttributeRow(ILMetadataReader ctxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TaggedIndex`1<HasFieldMarshalTag>, int> seekReadFieldMarshalRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ushort, TaggedIndex`1<HasDeclSecurityTag>, int> seekReadPermissionRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ushort, int, int> seekReadClassLayoutRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadFieldLayoutRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadStandAloneSigRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadEventMapRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, TaggedIndex`1<TypeDefOrRefTag>> seekReadEventRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadPropertyMapRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, int> seekReadPropertyRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, TaggedIndex`1<HasSemanticsTag>> seekReadMethodSemanticsRowUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, TaggedIndex`1<MethodDefOrRefTag>, TaggedIndex`1<MethodDefOrRefTag>> seekReadMethodImplRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadModuleRefRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadTypeSpecRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<int, TaggedIndex`1<MemberForwardedTag>, int, int> seekReadImplMapRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadFieldRVARow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<int, ushort, ushort, ushort, ushort, int, int, Tuple`2<int, int>> seekReadAssemblyRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<ushort, ushort, ushort, ushort, int, int, int, Tuple`2<int, int>> seekReadAssemblyRefRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, int> seekReadFileRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<int, int, int, int, TaggedIndex`1<ImplementationTag>> seekReadExportedTypeRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<int, int, int, TaggedIndex`1<ImplementationTag>> seekReadManifestResourceRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadNestedRowUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<int, ushort, ushort, TaggedIndex`1<TypeOrMethodDefTag>, int> seekReadGenericParamRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, TaggedIndex`1<TypeDefOrRefTag>> seekReadGenericParamConstraintRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TaggedIndex`1<MethodDefOrRefTag>, int> seekReadMethodSpecRow(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string readUserStringHeapUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string readStringHeapUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> readStringHeapOption(ILMetadataReader ctxt, int idx);
    internal static Byte[] get_emptyByteArray();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] readBlobHeapUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Byte[]> readBlobHeapOption(ILMetadataReader ctxt, int idx);
    internal static FSharpList`1<ILNativeResource> readNativeResources(PEReader pectxt);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<int> getDataEndPointsDelayed$cont@1583(PEReader pectxt, ILMetadataReader ctxt, BinaryView mdv, FSharpList`1<Tuple`2<string, int>> dataStartPoints, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<FSharpList`1<int>> getDataEndPointsDelayed(PEReader pectxt, FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH);
    internal static Byte[] look@1611-1(ILMetadataReader ctxt, PEReader pectxt, string nm, int rva, int start, FSharpList`1<int> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] rvaToData(ILMetadataReader ctxt, PEReader pectxt, string nm, int rva);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSorted(ILMetadataReader ctxt, TableName tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef seekReadModule(ILMetadataReader ctxt, PEReader pectxtEager, BinaryView pevEager, ushort peinfo_0, Tuple`2<int, int> peinfo_1, bool peinfo_2, bool peinfo_3, bool peinfo_4, bool peinfo_5, bool peinfo_6, FSharpOption`1<ILPlatform> peinfo_7, bool peinfo_8, int peinfo_9, int peinfo_10, int peinfo_11, string ilMetadataVersion, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAssemblyManifest seekReadAssemblyManifest(ILMetadataReader ctxt, PEReader pectxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAssemblyRef seekReadAssemblyRefUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleRef seekReadModuleRef(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleRef seekReadFile(ILMetadataReader ctxt, BinaryView mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefLayoutInfo seekReadClassLayout(ILMetadataReader ctxt, BinaryView mdv, int idx);
    internal static ILTypeDefAccess typeAccessOfFlags(int flags);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefLayout typeLayoutOfFlags(ILMetadataReader ctxt, BinaryView mdv, int flags, int tidx);
    internal static bool isTopTypeDef(int flags);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<string>, string> readBlobHeapAsSplitTypeName(ILMetadataReader ctxt, int nameIdx, int namespaceIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string readBlobHeapAsTypeName(ILMetadataReader ctxt, int nameIdx, int namespaceIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadTypeDefRowExtents(ILMetadataReader ctxt, a _info, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`6<int, int, int, TaggedIndex`1<TypeDefOrRefTag>, int, int>, Tuple`2<int, int>> seekReadTypeDefRowWithExtents(ILMetadataReader ctxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILPreTypeDef> seekReadPreTypeDef(ILMetadataReader ctxt, bool toponly, int idx);
    internal static ILTypeDefStored typeDefReader(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH);
    internal static ILPreTypeDef[] seekReadTopTypeDefs(ILMetadataReader ctxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefs seekReadNestedTypeDefs(ILMetadataReader ctxt, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> seekReadInterfaceImpls(ILMetadataReader ctxt, BinaryView mdv, int numtypars, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILGenericParameterDef> seekReadGenericParams(ILMetadataReader ctxt, int numtypars, TypeOrMethodDefTag a, int b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILGenericParameterDef> seekReadGenericParamsUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, GenericParamsIdx _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> seekReadGenericParamConstraints(ILMetadataReader ctxt, BinaryView mdv, int numtypars, int gpidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType seekReadTypeDefAsTypeUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, TypeDefAsTypIdx _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef seekReadTypeDefAsTypeRef(ILMetadataReader ctxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef seekReadTypeRefUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType seekReadTypeRefAsTypeUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, TypeRefAsTypIdx _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType seekReadTypeDefOrRef(ILMetadataReader ctxt, int numtypars, ILBoxity boxity, FSharpList`1<ILType> ginst, TaggedIndex`1<TypeDefOrRefTag> _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef seekReadTypeDefOrRefAsTypeRef(ILMetadataReader ctxt, TaggedIndex`1<TypeDefOrRefTag> _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType seekReadMethodRefParent(ILMetadataReader ctxt, BinaryView mdv, int numtypars, TaggedIndex`1<MemberRefParentTag> _arg6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static VarArgMethodData seekReadMethodDefOrRef(ILMetadataReader ctxt, int numtypars, TaggedIndex`1<MethodDefOrRefTag> _arg7);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodData seekReadMethodDefOrRefNoVarargs(ILMetadataReader ctxt, int numtypars, TaggedIndex`1<MethodDefOrRefTag> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodSpec seekReadCustomAttrType(ILMetadataReader ctxt, TaggedIndex`1<CustomAttributeTypeTag> _arg8);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILScopeRef seekReadImplAsScopeRef(ILMetadataReader ctxt, BinaryView mdv, TaggedIndex`1<ImplementationTag> _arg9);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILScopeRef, FSharpList`1<string>> seekReadTypeRefScope(ILMetadataReader ctxt, BinaryView mdv, TaggedIndex`1<ResolutionScopeTag> _arg10);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILType> seekReadOptionalTypeDefOrRef(ILMetadataReader ctxt, int numtypars, ILBoxity boxity, TaggedIndex`1<TypeDefOrRefTag> idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldDef seekReadField(ILMetadataReader ctxt, BinaryView mdv, int numtypars, bool hasLayout, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldDefs seekReadFields(ILMetadataReader ctxt, int numtypars, bool hasLayout, int fidx1, int fidx2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDefs seekReadMethods(ILMetadataReader ctxt, int numtypars, int midx1, int midx2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TaggedIndex`1<TypeDefOrRefTag>, int> sigptrGetTypeDefOrRefOrSpecIdx(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILType, int> sigptrGetTy(ILMetadataReader ctxt, int numtypars, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<ILType>, int> sigptrGetVarArgTys(ILMetadataReader ctxt, int n, int numtypars, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpList`1<ILType>, FSharpOption`1<FSharpList`1<ILType>>>, int> sigptrGetArgTys(ILMetadataReader ctxt, int n, int numtypars, Byte[] bytes, int sigptr, FSharpList`1<ILType> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILLocal, int> sigptrGetLocal(ILMetadataReader ctxt, int numtypars, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<bool, int, ILCallingConv, ILType, FSharpList`1<ILType>, FSharpOption`1<FSharpList`1<ILType>>> readBlobHeapAsMethodSigUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, BlobAsMethodSigIdx _arg11);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType readBlobHeapAsType(ILMetadataReader ctxt, int numtypars, int blobIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType readBlobHeapAsFieldSig(ILMetadataReader ctxt, int numtypars, int blobIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType readBlobHeapAsFieldSigUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, BlobAsFieldSigIdx _arg12);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ILThisConvention, ILType, FSharpList`1<ILType>> readBlobHeapAsPropertySigUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, BlobAsPropSigIdx _arg13);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILLocal> readBlobHeapAsLocalsSigUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, BlobAsLocalSigIdx _arg14);
    internal static ILThisConvention byteAsHasThis(byte b);
    internal static Tuple`2<bool, ILCallingConv> byteAsCallConv(byte b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static VarArgMethodData seekReadMemberRefAsMethodData(ILMetadataReader ctxt, int numtypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static VarArgMethodData seekReadMemberRefAsMethodDataUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, MemberRefAsMspecIdx _arg15);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodData seekReadMemberRefAsMethDataNoVarArgs(ILMetadataReader ctxt, int numtypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static VarArgMethodData seekReadMethodSpecAsMethodDataUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, MethodSpecAsMspecIdx _arg16);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec seekReadMemberRefAsFieldSpecUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, MemberRefAsFspecIdx _arg17);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodData seekReadMethodDefAsMethodData(ILMetadataReader ctxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodData seekReadMethodDefAsMethodDataUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec seekReadFieldDefAsFieldSpecUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef seekReadMethod(ILMetadataReader ctxt, BinaryView mdv, int numtypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILReturn, FSharpList`1<ILParameter>> seekReadParams(ILMetadataReader ctxt, BinaryView mdv, ILType retty, FSharpList`1<ILType> argtys, int pidx1, int pidx2);
    internal static ILNativeType fmReader@2426(ILMetadataReader ctxt, BinaryView mdv, TaggedIndex`1<HasFieldMarshalTag> idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void seekReadParamExtras(ILMetadataReader ctxt, BinaryView mdv, FSharpRef`1<ILReturn> retRes, ILParameter[] paramsRes, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodImplDefs seekReadMethodImpls(ILMetadataReader ctxt, int numtypars, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILMethodRef> seekReadMultipleMethodSemantics(ILMetadataReader ctxt, int flags, TaggedIndex`1<HasSemanticsTag> id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILMethodRef> seekReadoptional_MethodSemantics(ILMetadataReader ctxt, int id_0, TaggedIndex`1<HasSemanticsTag> id_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodRef seekReadMethodSemantics(ILMetadataReader ctxt, int id_0, TaggedIndex`1<HasSemanticsTag> id_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDef seekReadEvent(ILMetadataReader ctxt, BinaryView mdv, int numtypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDefs seekReadEvents(ILMetadataReader ctxt, int numtypars, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDef seekReadProperty(ILMetadataReader ctxt, BinaryView mdv, int numtypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDefs seekReadProperties(ILMetadataReader ctxt, int numtypars, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttributesStored customAttrsReader(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, HasCustomAttributeTag tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute seekReadCustomAttr(ILMetadataReader ctxt, TaggedIndex`1<CustomAttributeTypeTag> _arg18, int b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute seekReadCustomAttrUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, CustomAttrIdx _arg19);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILSecurityDeclsStored securityDeclsReader(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, HasDeclSecurityTag tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILSecurityDecl seekReadSecurityDecl(ILMetadataReader ctxt, ushort act, int ty);
    [CompilerGeneratedAttribute]
internal static ILFieldInit seekReadConstant$cont@2605-1(ILMetadataReader ctxt, int vidx, ushort kind, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ILFieldInit seekReadConstant$cont@2605(ILMetadataReader ctxt, int vidx, ushort kind, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldInit seekReadConstant(ILMetadataReader ctxt, TaggedIndex`1<HasConstantTag> idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILLazyMethodBody seekReadImplMap(ILMetadataReader ctxt, string nm, int midx);
    internal static FSharpOption`1<int> tryRawToLabel@2682(Dictionary`2<int, int> labelsOfRawOffsets, int rawOffset);
    internal static int rawToLabel@2687(Dictionary`2<int, int> labelsOfRawOffsets, int rawOffset);
    internal static void get@2705(BinaryView pev, int sz, int start, FSharpRef`1<int> curr, FSharpRef`1<int> lastb, FSharpRef`1<int> lastb2, FSharpRef`1<int> b, Unit unitVar0);
    internal static bool isInstrStart@2918(Dictionary`2<int, int> labelsOfRawOffsets, Dictionary`2<int, int> ilOffsetsOfLabels, int x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<ILInstr[], FSharpFunc`2<int, int>, Dictionary`2<int, int>, FSharpFunc`2<int, int>> seekReadTopCode(ILMetadataReader ctxt, BinaryView pev, BinaryView mdv, int numtypars, int sz, int start, FSharpList`1<Tuple`2<int, ILSourceMarker>> seqpoints);
    [CompilerGeneratedAttribute]
internal static Tuple`2<int, ILSourceMarker> mapping@1-2(FSharpFunc`2<string, ILSourceDocument> get_doc, PdbSequencePoint sp);
    internal static FSharpList`1<FSharpFunc`2<FSharpFunc`2<int, int>, ILLocalDebugInfo>> scopes@2972(PdbMethodScope scp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILLazyMethodBody seekReadMethodRVA(PEReader pectxt, ILMetadataReader ctxt, int idx, string nm, bool _internalcall, bool noinline, bool aggressiveinline, int numtypars, int rva);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILNativeVariant int32AsILVariantType(ILMetadataReader ctxt, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILNativeType readBlobHeapAsNativeType(ILMetadataReader ctxt, int blobIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILNativeType, int> sigptrGetILNativeType(ILMetadataReader ctxt, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILResources seekReadManifestResources(ILMetadataReader ctxt, BinaryView mdv, PEReader pectxtEager, BinaryView pevEager);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILNestedExportedTypes seekReadNestedExportedTypes(ILMetadataReader ctxt, Tuple`5[] exported, Lazy`1<FSharpList`1[]> nested, int parentIdx);
    internal static ILExportedTypesAndForwarders seekReadTopExportedTypes(ILMetadataReader ctxt);
    [CompilerGeneratedAttribute]
internal static void action@1-5(Dictionary`2<string, ILSourceDocument> tab, PdbDocument pdbdoc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<PdbReader, FSharpFunc`2<string, ILSourceDocument>>> getPdbReader(FSharpOption`1<string> pdbDirPath, string fileName);
    internal static FSharpOption`1<Tuple`2<int, int>> look@3351-6(int metadataPhysLoc, BinaryView mdv, int numStreams, Int32[] name, int i, int pos);
    internal static FSharpOption`1<Tuple`2<int, int>> tryFindStream@3350(int metadataPhysLoc, BinaryView mdv, int numStreams, int streamHeadersStart, Int32[] name);
    internal static Tuple`2<int, int> findStream@3371(int metadataPhysLoc, BinaryView mdv, int numStreams, int streamHeadersStart, Int32[] name);
    internal static bool codedBigness@3485(Int32[] tableRowCount, int nbits, TableName tab);
    [CompilerGeneratedAttribute]
internal static int projection@1(bool stringsBigness, bool guidsBigness, bool blobsBigness, Boolean[] tableBigness, bool tdorBigness, bool tomdBigness, bool hcBigness, bool hcaBigness, bool hfmBigness, bool hdsBigness, bool mrpBigness, bool hsBigness, bool mdorBigness, bool mfBigness, bool iBigness, bool catBigness, bool rsBigness, RowElementKind x);
    internal static int rowKindSize@3570(bool stringsBigness, bool guidsBigness, bool blobsBigness, Boolean[] tableBigness, bool tdorBigness, bool tomdBigness, bool hcBigness, bool hcaBigness, bool hfmBigness, bool hdsBigness, bool mrpBigness, bool hsBigness, bool mdorBigness, bool mfBigness, bool iBigness, bool catBigness, bool rsBigness, RowKind _arg1);
    internal static Tuple`2<ILModuleDef, Lazy`1<FSharpList`1<ILAssemblyRef>>> openMetadataReader(string fileName, BinaryFile mdfile, int metadataPhysLoc, Tuple`8<ushort, Tuple`2<int, int>, bool, bool, bool, bool, bool, Tuple`5<FSharpOption`1<ILPlatform>, bool, int, int, int>> peinfo, PEReader pectxtEager, BinaryView pevEager, FSharpOption`1<PEReader> pectxtCaptured, bool reduceMemoryUsage, ILGlobals ilGlobals);
    internal static int look@3821-7(BinaryView pev, int numSections, int addr, int i, int pos);
    internal static int findSectionHeader@3820(BinaryView pev, int numSections, int sectionHeadersStartPhysLoc, int addr);
    internal static int look@3846-8(string fileName, int numSections, int v, string n, BinaryView pev, int i, int pos);
    internal static int anyV2P@3844(BinaryFile pefile, string fileName, int numSections, int sectionHeadersStartPhysLoc, Tuple`2<string, int> tupledArg);
    internal static Tuple`6<int, int, Tuple`8<ushort, Tuple`2<int, int>, bool, bool, bool, bool, bool, Tuple`5<FSharpOption`1<ILPlatform>, bool, int, int, int>>, PEReader, BinaryView, FSharpOption`1<Tuple`2<PdbReader, FSharpFunc`2<string, ILSourceDocument>>>> openPEFileReader(string fileName, BinaryFile pefile, FSharpOption`1<string> pdbDirPath, bool noFileOnDisk);
    internal static Tuple`3<ILModuleDef, Lazy`1<FSharpList`1<ILAssemblyRef>>, FSharpOption`1<Tuple`2<PdbReader, FSharpFunc`2<string, ILSourceDocument>>>> openPE(string fileName, BinaryFile pefile, FSharpOption`1<string> pdbDirPath, bool reduceMemoryUsage, ILGlobals ilGlobals, bool noFileOnDisk);
    internal static Tuple`2<ILModuleDef, Lazy`1<FSharpList`1<ILAssemblyRef>>> openPEMetadataOnly(string fileName, Tuple`8<ushort, Tuple`2<int, int>, bool, bool, bool, bool, bool, Tuple`5<FSharpOption`1<ILPlatform>, bool, int, int, int>> peinfo, PEReader pectxtEager, BinaryView pev, BinaryFile mdfile, bool reduceMemoryUsage, ILGlobals ilGlobals);
    internal static void ClosePdbReader(FSharpOption`1<Tuple`2<PdbReader, a>> pdb);
    internal static AgedLookup`3<ILModuleReaderCache1LockToken, ILModuleReaderCacheKey, ILModuleReader> get_ilModuleReaderCache1();
    internal static Lock`1<ILModuleReaderCache1LockToken> get_ilModuleReaderCache1Lock();
    internal static ConcurrentDictionary`2<ILModuleReaderCacheKey, WeakReference`1<ILModuleReader>> get_ilModuleReaderCache2();
    internal static bool stableFileHeuristicApplies(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static BinaryFile createByteFileChunk(ILReaderOptions opts, string fileName, FSharpOption`1<Tuple`2<int, int>> chunk);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<IDisposable, BinaryFile> tryMemoryMapWholeFile(ILReaderOptions opts, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleReader OpenILModuleReaderFromBytes(string fileNameForDebugOutput, Byte[] assemblyContents, ILReaderOptions options);
    internal static void ClearAllILModuleReaderCache();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleReader OpenILModuleReader(string fileName, ILReaderOptions opts);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILBinaryWriter : object {
    [DebuggerBrowsableAttribute("0")]
internal static T826828_32Bytes@ field826829@;
    [DebuggerBrowsableAttribute("0")]
internal static T826830_48Bytes@ field826831@;
    [DebuggerBrowsableAttribute("0")]
internal static T826828_32Bytes@ field826832@;
    [DebuggerBrowsableAttribute("0")]
internal static T826828_32Bytes@ field826833@;
    [DebuggerBrowsableAttribute("0")]
internal static T826834_128Bytes@ field826835@;
    [DebuggerBrowsableAttribute("0")]
internal static T826836_4Bytes@ field826837@;
    [DebuggerBrowsableAttribute("0")]
internal static T826836_4Bytes@ field826838@;
    [DebuggerBrowsableAttribute("0")]
internal static T826839_8Bytes@ field826840@;
    [DebuggerBrowsableAttribute("0")]
internal static T826836_4Bytes@ field826841@;
    [DebuggerBrowsableAttribute("0")]
internal static T826839_8Bytes@ field826842@;
    [DebuggerBrowsableAttribute("0")]
internal static T826836_4Bytes@ field826843@;
    [DebuggerBrowsableAttribute("0")]
internal static T826839_8Bytes@ field826844@;
    [DebuggerBrowsableAttribute("0")]
internal static T826836_4Bytes@ field826845@;
    [DebuggerBrowsableAttribute("0")]
internal static T826846_14Bytes@ field826847@;
    [DebuggerBrowsableAttribute("0")]
internal static T826846_14Bytes@ field826848@;
    [DebuggerBrowsableAttribute("0")]
internal static T826849_12Bytes@ field826850@;
    [DebuggerBrowsableAttribute("0")]
internal static T826839_8Bytes@ field826851@;
    [DebuggerBrowsableAttribute("0")]
internal static T826852_1Bytes@ field826853@;
    [CompilationMappingAttribute("9")]
internal static int timestamp { get; }
    [CompilationMappingAttribute("9")]
internal static Byte[] msdosHeader { get; }
    private static ILBinaryWriter();
    internal static int ByteBuffer.Z32Size.Static(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ByteBuffer.EmitZ32(ByteBuffer buf, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ByteBuffer.EmitPadding(ByteBuffer buf, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ByteBuffer.EmitZUntaggedIndex(ByteBuffer buf, bool big, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ByteBuffer.EmitZTaggedIndex(ByteBuffer buf, int tag, int nbits, bool big, int idx);
    internal static bool scan@119(Byte[] b, int len, int i);
    internal static int markerForUnicodeBytes(Byte[] b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkFixup32(Byte[] data, int offset, int exp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void applyFixup32(Byte[] data, int offset, int v);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@156-33(ILStrongNameSigner this, ILStrongNameSigner obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@156-34(IComparer comp, ILStrongNameSigner this, ILStrongNameSigner objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@156-4(IEqualityComparer comp, ILStrongNameSigner this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@156-7(ILStrongNameSigner this, object obj, IEqualityComparer comp, Unit unitVar);
    internal static int pkSignatureSize@193(Byte[] pk);
    internal static RowElement Data(int x, bool k);
    internal static int hashRow(RowElement[] elems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equalRows(RowElement[] elems, RowElement[] elems2);
    internal static SharedRow AssemblyRefRow(ushort s1, ushort s2, ushort s3, ushort s4, int l1, int b1, int nameIdx, int str2, int b2);
    internal static SharedRow MemberRefRow(RowElement mrp, int nmIdx, int blobIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeWriterEnv envForMethodRef(ILTypeWriterEnv env, ILType ty);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@535-35(PropertyTableKey this, PropertyTableKey obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@535-36(IComparer comp, PropertyTableKey this, PropertyTableKey objTemp, Unit unitVar);
    internal static Tuple`2<int, int> metadataSchemaVersionSupportedByCLRVersion(ILVersionInfo v);
    internal static Tuple`2<int, int> headerVersionSupportedByCLRVersion(ILVersionInfo v);
    internal static int peOptionalHeaderByteByCLRVersion(ILVersionInfo v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void recordRequiredDataFixup(FSharpRef`1<FSharpList`1<Tuple`2<a, b>>> requiredDataFixups, ByteBuffer buf, a pos, b lab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetBytesAsBlobIdx(cenv cenv, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetStringHeapIdx(cenv cenv, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetStringHeapIdxOption(cenv cenv, FSharpOption`1<string> sopt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<RowElement, RowElement> GetTypeNameAsElemPair(cenv cenv, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefPass1(FSharpList`1<string> enc, cenv cenv, ILTypeDef td);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefsPass1(FSharpList`1<string> enc, cenv cenv, FSharpList`1<ILTypeDef> tds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetIdxForTypeDef(cenv cenv, TypeDefTableKey key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetAssemblyRefAsRow(cenv cenv, ILAssemblyRef aref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetAssemblyRefAsIdx(cenv cenv, ILAssemblyRef aref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetModuleRefAsRow(cenv cenv, ILModuleRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetModuleRefAsFileRow(cenv cenv, ILModuleRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetModuleRefAsIdx(cenv cenv, ILModuleRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetModuleRefAsFileIdx(cenv cenv, ILModuleRef mref);
    internal static bool isScopeRefLocal(ILScopeRef scoref);
    internal static bool isTypeLocal(ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ImplementationTag, int> GetScopeRefAsImplementationElem(cenv cenv, ILScopeRef scoref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetTypeRefAsTypeRefRow(cenv cenv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetTypeRefAsTypeRefIdx(cenv cenv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ResolutionScopeTag, int> GetResolutionScopeAsElem(cenv cenv, ILScopeRef scoref, FSharpList`1<string> enc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitTypeInfoAsTypeDefOrRefEncoded(cenv cenv, ByteBuffer bb, ILScopeRef scoref, FSharpList`1<string> enc, string nm);
    internal static int getTypeDefOrRefAsUncodedToken(TypeDefOrRefTag tag, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitArrayShape(ByteBuffer bb, ILArrayShape _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static byte callconvToByte(int ntypars, ILCallingConv _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitTypeSpec(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, byte et, ILTypeSpec tspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TypeDefOrRefTag, int> GetTypeAsTypeDefOrRef(cenv cenv, ILTypeWriterEnv env, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetTypeAsTypeSpecRow(cenv cenv, ILTypeWriterEnv env, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetTypeAsTypeSpecIdx(cenv cenv, ILTypeWriterEnv env, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitType(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitLocalInfo(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, ILLocal l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitCallsig(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, ILCallingConv callconv, FSharpList`1<ILType> args, ILType ret, FSharpOption`1<FSharpList`1<ILType>> varargs, int genarity);
    [CompilerGeneratedAttribute]
internal static void f@55-1(cenv cenv, ILTypeWriterEnv env, ILCallingConv x_0, FSharpList`1<ILType> x_1, ILType x_2, FSharpOption`1<FSharpList`1<ILType>> x_3, int x_4, ByteBuffer bb);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetCallsigAsBytes(cenv cenv, ILTypeWriterEnv env, ILCallingConv x_0, FSharpList`1<ILType> x_1, ILType x_2, FSharpOption`1<FSharpList`1<ILType>> x_3, int x_4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitTypes(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, FSharpList`1<ILType> inst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RowElement GetTypeAsMemberRefParent(cenv cenv, ILTypeWriterEnv env, ILType ty);
    internal static int GetVariantTypeAsInt32(ILNativeVariant ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitNativeType(ByteBuffer bb, ILNativeType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldInitAsBlobIdx(cenv cenv, ILFieldInit x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GetFieldInit(ByteBuffer bb, ILFieldInit x);
    internal static RowElement GetFieldInitFlags(ILFieldInit i);
    internal static int GetMemberAccessFlags(ILMemberAccess access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetTypeDefAsRow(cenv cenv, ILTypeWriterEnv env, a _enc, ILTypeDef td);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TypeDefOrRefTag, int> GetTypeOptionAsTypeDefOrRef(cenv cenv, ILTypeWriterEnv env, FSharpOption`1<ILType> tyOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetTypeDefAsPropertyMapRow(cenv cenv, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetTypeDefAsEventMapRow(cenv cenv, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenFieldDefPass2(cenv cenv, int tidx, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodDefKey GetKeyForMethodDef(int tidx, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodDefPass2(cenv cenv, int tidx, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PropertyTableKey GetKeyForPropertyDef(int tidx, ILPropertyDef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenPropertyDefPass2(cenv cenv, int tidx, ILPropertyDef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetTypeAsImplementsRow(cenv cenv, ILTypeWriterEnv env, int tidx, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenImplementsPass2(cenv cenv, ILTypeWriterEnv env, int tidx, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenEventDefPass2(cenv cenv, int tidx, ILEventDef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefPass2(int pidx, FSharpList`1<string> enc, cenv cenv, ILTypeDef td);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefsPass2(int pidx, FSharpList`1<string> enc, cenv cenv, FSharpList`1<ILTypeDef> tds);
    internal static TypeDefTableKey typeNameOfIdx@1221(cenv cenv, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int FindMethodDefIdx(cenv cenv, MethodDefKey mdkey);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int FindFieldDefIdx(cenv cenv, FieldDefKey fdkey);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodRefAsMethodDefIdx(cenv cenv, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow MethodRefInfoAsMemberRefRow(cenv cenv, ILTypeWriterEnv env, ILTypeWriterEnv fenv, string nm, ILType ty, ILCallingConv callconv, FSharpList`1<ILType> args, ILType ret, FSharpOption`1<FSharpList`1<ILType>> varargs, int genarity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodRefInfoAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILCallingConv info_0, FSharpList`1<ILType> info_1, ILType info_2, FSharpOption`1<FSharpList`1<ILType>> info_3, int info_4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodRefInfoAsMemberRefIdx(cenv cenv, ILTypeWriterEnv env, string _arg1_0, ILType _arg1_1, ILCallingConv _arg1_2, FSharpList`1<ILType> _arg1_3, ILType _arg1_4, FSharpOption`1<FSharpList`1<ILType>> _arg1_5, int _arg1_6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MethodDefOrRefTag, int> GetMethodRefInfoAsMethodRefOrDef(bool isAlwaysMethodDef, cenv cenv, ILTypeWriterEnv env, string _arg1_0, ILType _arg1_1, ILCallingConv _arg1_2, FSharpList`1<ILType> _arg1_3, ILType _arg1_4, FSharpOption`1<FSharpList`1<ILType>> _arg1_5, int _arg1_6);
    [CompilerGeneratedAttribute]
internal static void f@55-2(cenv cenv, ILTypeWriterEnv env, FSharpList`1<ILType> minst, ByteBuffer bb);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodSpecInfoAsMethodSpecIdx(cenv cenv, ILTypeWriterEnv env, string nm, ILType ty, ILCallingConv cc, FSharpList`1<ILType> args, ILType ret, FSharpOption`1<FSharpList`1<ILType>> varargs, FSharpList`1<ILType> minst);
    internal static int GetMethodDefOrRefAsUncodedToken(MethodDefOrRefTag tag, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodSpecInfoAsUncodedToken(cenv cenv, ILTypeWriterEnv env, string _arg1_0, ILType _arg1_1, ILCallingConv _arg1_2, FSharpList`1<ILType> _arg1_3, ILType _arg1_4, FSharpOption`1<FSharpList`1<ILType>> _arg1_5, FSharpList`1<ILType> _arg1_6);
    internal static Tuple`7<string, ILType, ILCallingConv, FSharpList`1<ILType>, ILType, FSharpOption`1<FSharpList`1<ILType>>, int> GetMethodRefInfoOfMethodSpecInfo(string nm, ILType ty, ILCallingConv cc, FSharpList`1<ILType> args, ILType ret, FSharpOption`1<FSharpList`1<ILType>> varargs, FSharpList`1<ILType> minst);
    internal static Tuple`7<string, ILType, ILCallingConv, FSharpList`1<ILType>, ILType, FSharpOption`1<FSharpList`1<ILType>>, FSharpList`1<ILType>> InfoOfMethodSpec(ILMethodSpec mspec, FSharpOption`1<FSharpList`1<ILType>> varargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetOverridesSpecAsMemberRefIdx(cenv cenv, ILTypeWriterEnv env, ILOverridesSpec ospec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MethodDefOrRefTag, int> GetOverridesSpecAsMethodDefOrRef(cenv cenv, ILTypeWriterEnv env, ILOverridesSpec ospec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodRefAsMemberRefIdx(cenv cenv, ILTypeWriterEnv env, ILTypeWriterEnv fenv, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CustomAttributeTypeTag, int> GetMethodRefAsCustomAttribType(cenv cenv, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetCustomAttrDataAsBlobIdx(cenv cenv, Byte[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetCustomAttrRow(cenv cenv, HasCustomAttributeTag hca_0, int hca_1, ILAttribute attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenCustomAttrPass3Or4(cenv cenv, HasCustomAttributeTag hca_0, int hca_1, ILAttribute attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenCustomAttrsPass3Or4(cenv cenv, HasCustomAttributeTag hca_0, int hca_1, ILAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetSecurityDeclRow(cenv cenv, HasDeclSecurityTag hds_0, int hds_1, ILSecurityDecl _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSecurityDeclPass3(cenv cenv, HasDeclSecurityTag hds_0, int hds_1, ILSecurityDecl attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSecurityDeclsPass3(cenv cenv, HasDeclSecurityTag hds_0, int hds_1, FSharpList`1<ILSecurityDecl> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetFieldSpecAsMemberRefRow(cenv cenv, ILTypeWriterEnv env, ILTypeWriterEnv fenv, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldSpecAsMemberRefIdx(cenv cenv, ILTypeWriterEnv env, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetFieldSpecSigAsBytes(cenv cenv, ILTypeWriterEnv env, ILFieldSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldSpecSigAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILFieldSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, int> GetFieldSpecAsFieldDefOrRef(cenv cenv, ILTypeWriterEnv env, ILFieldSpec fspec);
    internal static int GetFieldDefOrRefAsUncodedToken(bool tag, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetCallsigAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILCallingSignature callsig, FSharpOption`1<FSharpList`1<ILType>> varargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetCallsigAsStandAloneSigRow(cenv cenv, ILTypeWriterEnv env, ILCallingSignature x_0, FSharpOption`1<FSharpList`1<ILType>> x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetCallsigAsStandAloneSigIdx(cenv cenv, ILTypeWriterEnv env, ILCallingSignature info_0, FSharpOption`1<FSharpList`1<ILType>> info_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitLocalSig(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, FSharpList`1<ILLocal> locals);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetLocalSigAsBlobHeapIdx(cenv cenv, ILTypeWriterEnv env, FSharpList`1<ILLocal> locals);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetLocalSigAsStandAloneSigIdx(cenv cenv, ILTypeWriterEnv env, FSharpList`1<ILLocal> locals);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldDefTypeAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILType ty);
    [CompilerGeneratedAttribute]
internal static Byte[] mapping@1-5(cenv cenv, ILTypeWriterEnv env, ILLocal l);
    internal static int kindAsInt32@2284(ExceptionClauseKind k);
    internal static int kindAsExtraInt32@2290(ExceptionClauseKind k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<int, Tuple`2<Tuple`2<int, FSharpList`1<Tuple`2<int, int>>>, Byte[]>, PdbSequencePoint[], PdbMethodScope> GenILMethodBody(a mname, cenv cenv, ILTypeWriterEnv env, ILMethodBody il);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetFieldDefAsFieldDefRow(cenv cenv, ILTypeWriterEnv env, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldDefSigAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenFieldDefPass3(cenv cenv, ILTypeWriterEnv env, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetGenericParamAsGenericParamRow(cenv cenv, a _env, int idx, TypeOrMethodDefTag owner_0, int owner_1, ILGenericParameterDef gp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GenTypeAsGenericParamConstraintRow(cenv cenv, ILTypeWriterEnv env, int gpidx, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGenericParamConstraintPass4(cenv cenv, ILTypeWriterEnv env, int gpidx, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGenericParamPass3(cenv cenv, a env, int idx, TypeOrMethodDefTag owner_0, int owner_1, ILGenericParameterDef gp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGenericParamPass4(cenv cenv, ILTypeWriterEnv env, int idx, TypeOrMethodDefTag owner_0, int owner_1, ILGenericParameterDef gp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetParamAsParamRow(cenv cenv, a _env, int seq, ILParameter param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenParamPass3(cenv cenv, a env, int seq, ILParameter param);
    internal static UnsharedRow GenReturnAsParamRow(ILReturn returnv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenReturnPass3(cenv cenv, ILReturn returnv);
    [CompilerGeneratedAttribute]
internal static void f@55-3(cenv cenv, ILTypeWriterEnv env, ILMethodDef mdef, ByteBuffer bb);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetMethodDefSigAsBytes(cenv cenv, ILTypeWriterEnv env, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GenMethodDefAsRow(cenv cenv, ILTypeWriterEnv env, int midx, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodImplPass3(cenv cenv, ILTypeWriterEnv env, a _tgparams, int tidx, ILMethodImplDef mimpl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodDefPass3(cenv cenv, ILTypeWriterEnv env, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodDefPass4(cenv cenv, ILTypeWriterEnv env, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenPropertyMethodSemanticsPass3(cenv cenv, int pidx, int kind, ILMethodRef mref);
    [CompilerGeneratedAttribute]
internal static void f@55-4(cenv cenv, ILTypeWriterEnv env, ILPropertyDef prop, ByteBuffer bb);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetPropertySigAsBytes(cenv cenv, ILTypeWriterEnv env, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetPropertyAsPropertyRow(cenv cenv, ILTypeWriterEnv env, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenPropertyPass3(cenv cenv, ILTypeWriterEnv env, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenEventMethodSemanticsPass3(cenv cenv, int eidx, int kind, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GenEventAsEventRow(cenv cenv, ILTypeWriterEnv env, ILEventDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenEventPass3(cenv cenv, ILTypeWriterEnv env, ILEventDef md);
    internal static Tuple`2<RowElement, Tuple`2<ImplementationTag, int>> embedManagedResources@2696(cenv cenv, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetResourceAsManifestResourceRow(cenv cenv, ILResource r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenResourcePass3(cenv cenv, ILResource r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefPass3(FSharpList`1<string> enc, cenv cenv, ILTypeDef td);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefsPass3(FSharpList`1<string> enc, cenv cenv, FSharpList`1<ILTypeDef> tds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefPass4(FSharpList`1<string> enc, cenv cenv, ILTypeDef td);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefsPass4(FSharpList`1<string> enc, cenv cenv, FSharpList`1<ILTypeDef> tds);
    internal static int get_timestamp();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenNestedExportedTypePass3(cenv cenv, int cidx, ILNestedExportedType ce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenNestedExportedTypesPass3(cenv cenv, int nidx, ILNestedExportedTypes nce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExportedTypePass3(cenv cenv, ILExportedTypeOrForwarder ce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetManifsetAsAssemblyRow(cenv cenv, ILAssemblyManifest m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenManifestPass3(cenv cenv, ILAssemblyManifest m);
    internal static Byte[] newGuid(ILModuleDef modul);
    internal static Byte[] deterministicGuid(ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetModuleAsRow(cenv cenv, ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int rowElemCompare(RowElement e1, RowElement e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RowElement[][] SortTableRows(TableName tab, RowElement[][] rows);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenModule(cenv cenv, ILModuleDef modul);
    [CompilerGeneratedAttribute]
internal static MetadataTable initializer@1-2(int i);
    internal static int idxForNextedTypeDef@2993(cenv cenv, FSharpList`1<ILTypeDef> tupledArg0, ILTypeDef tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<Byte[][], Byte[][], Byte[][], Byte[][], MetadataTable[], int, Byte[], Tuple`5<FSharpList`1<Tuple`2<int, FSharpList`1<Tuple`2<int, int>>>>, Byte[], Byte[], PdbData, ILTokenMappings>> generateIL(FSharpRef`1<FSharpList`1<Tuple`2<int, Tuple`2<int, bool>>>> requiredDataFixups, ILVersionInfo desiredMetadataVersion, bool generatePdb, ILGlobals ilg, bool emitTailcalls, bool deterministic, bool showTimes, ILModuleDef m, int cilStartAddress, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int count(FSharpFunc`2<a, int> f, a[] arr);
    internal static int guidAddress@3153(int n);
    internal static int stringAddress@3164(Int32[] stringAddressTable, int n);
    internal static int userStringAddress@3178(Int32[] userStringAddressTable, int n);
    internal static int blobAddress@3191(Int32[] blobAddressTable, int n);
    [CompilerGeneratedAttribute]
internal static RowElement[][] initializer@1-3(MetadataTable[] tables, int i);
    internal static bool codedBigness@3211-1(MetadataTable[] tables, int nbits, TableName tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<int, Byte[], Byte[], Byte[], Byte[], Byte[], FSharpList`1<Tuple`2<int, Tuple`2<int, bool>>>, Tuple`3<PdbData, ILTokenMappings, int>> writeILMetadataAndCode(bool generatePdb, ILVersionInfo desiredMetadataVersion, ILGlobals ilg, bool emitTailcalls, bool deterministic, bool showTimes, ILModuleDef modul, int cilStartAddress, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
    internal static Byte[] get_msdosHeader();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeInt64(BinaryWriter os, long x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeInt32(BinaryWriter os, int x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeInt32AsUInt16(BinaryWriter os, int x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeDirectory(BinaryWriter os, BinaryChunk dict);
    [CompilerGeneratedAttribute]
internal static int dataRva$cont@3804(BinaryChunk rawdataChunk, int dataOffset, Unit unitVar);
    internal static void write@3819(FSharpOption`1<int> p, BinaryWriter os, string chunkName, Byte[] chunk);
    internal static void writePadding@3829(BinaryWriter os, a _comment, int sz);
    [CompilerGeneratedAttribute]
internal static PdbData pdbData$cont@3856(HashAlgorithm checksumAlgorithm, BinaryWriter os, PdbData pdbData, Byte[] metadata, int guidStart, Byte[] data, Byte[] code, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void writeBinaryAndReportMappings$cont@4237(bool showTimes, FSharpOption`1<string> pdbfile, PathMap pathMap, string outfile, bool embeddedPDB, bool deterministic, FSharpFunc`2<int, int> textV2P, FSharpOption`1<Tuple`5<long, BlobContentId, MemoryStream, string, Byte[]>> pdbOpt, PdbData pdbData, BinaryChunk debugEmbeddedPdbChunk, BinaryChunk debugDirectoryChunk, BinaryChunk debugDeterministicPdbChunk, BinaryChunk debugDataChunk, BinaryChunk debugChecksumPdbChunk, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTokenMappings writeBinaryAndReportMappings(string outfile, ILGlobals ilg, FSharpOption`1<string> pdbfile, FSharpOption`1<ILStrongNameSigner> signer, bool portablePDB, bool embeddedPDB, bool embedAllSource, FSharpList`1<string> embedSourceList, string sourceLink, HashAlgorithm checksumAlgorithm, bool emitTailcalls, bool deterministic, bool showTimes, bool dumpDebugInfo, PathMap pathMap, ILModuleDef modul, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
    internal static void WriteILBinary(string filename, options options, ILModuleDef input, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILPdbWriter : object {
    internal static int sizeof_IMAGE_DEBUG_DIRECTORY { get; }
    [CompilationMappingAttribute("9")]
internal static Guid guidSha1 { get; }
    [CompilationMappingAttribute("9")]
internal static Guid guidSha2 { get; }
    internal static long cvMagicNumber { get; }
    internal static long pdbMagicNumber { get; }
    [CompilationMappingAttribute("9")]
internal static AssemblyName monoCompilerSvc { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-27(PdbMethodScope this, PdbMethodScope obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-28(IComparer comp, PdbMethodScope this, object obj, PdbMethodScope objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@71-29(PdbSequencePoint this, PdbSequencePoint obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@71-30(PdbSequencePoint this, PdbSequencePoint objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@80-31(PdbMethodData this, PdbMethodData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@80-32(IComparer comp, PdbMethodData this, PdbMethodData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@80-3(IEqualityComparer comp, PdbMethodData this, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_sizeof_IMAGE_DEBUG_DIRECTORY();
    internal static Guid get_guidSha1();
    internal static Guid get_guidSha2();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Guid, Byte[]>> checkSum(string url, HashAlgorithm checksumAlgorithm);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static long get_cvMagicNumber();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd pdbGetCvDebugInfo(Byte[] mvid, int timestamp, string filepath, BinaryChunk cvChunk);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static long get_pdbMagicNumber();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd pdbGetEmbeddedPdbDebugInfo(BinaryChunk embeddedPdbChunk, long uncompressedLength, MemoryStream stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd pdbChecksumDebugInfo(int timestamp, BinaryChunk checksumPdbChunk, string algorithmName, Byte[] checksum);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd[] pdbGetDebugInfo(Byte[] contentId, int timestamp, string filepath, BinaryChunk cvChunk, FSharpOption`1<BinaryChunk> embeddedPdbChunk, BinaryChunk deterministicPdbChunk, BinaryChunk checksumPdbChunk, string algorithmName, Byte[] checksum, long uncompressedLength, FSharpOption`1<MemoryStream> stream, bool embeddedPdb, bool deterministic);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getDebugFileName(string outfile, bool portablePDB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sortMethods(bool showTimes, PdbData info);
    internal static ImmutableArray`1<int> getRowCounts(Int32[] tableRowCounts);
    internal static FSharpFunc`2<a, int> count@279-1(IEnumerable`1<a> s);
    internal static BlobHandle serializeDocumentName@277(PathMap pathMap, MetadataBuilder metadata, string name);
    internal static FSharpOption`1<ImmutableArray`1<byte>> includeSource@309(bool embedAllSource, FSharpList`1<string> embedSourceList, string file);
    internal static DocumentHandle getDocumentHandle@388(ILSourceDocument[] docs, Dictionary`2<string, DocumentHandle> documentIndex, int d);
    internal static int capValue@430(int v, int maxValue);
    [CompilerGeneratedAttribute]
internal static Tuple`2<DocumentHandle, BlobHandle> generatePortablePdb$cont@388(ILSourceDocument[] docs, MetadataBuilder metadata, Dictionary`2<string, DocumentHandle> documentIndex, PdbSequencePoint[] sps, BlobBuilder builder, Unit unitVar);
    internal static void toList@498-1(List`1<PdbMethodScope> list, PdbMethodScope scope, FSharpOption`1<PdbMethodScope> parent);
    internal static PdbMethodScope[] collectScopes@496(FSharpFunc`2<PdbMethodScope, FSharpFunc`2<PdbMethodScope, int>> scopeSorter, PdbMethodScope scope);
    internal static void writeMethodScope@488(MetadataBuilder metadata, PdbMethodData minfo, FSharpRef`1<LocalVariableHandle> lastLocalVariableHandle, PdbMethodScope scope);
    [CompilerGeneratedAttribute]
internal static void action@1-6(ILSourceDocument[] docs, MetadataBuilder metadata, Dictionary`2<string, DocumentHandle> documentIndex, FSharpRef`1<LocalVariableHandle> lastLocalVariableHandle, PdbMethodData minfo);
    internal static BlobContentId convert@539(HashAlgorithm hashAlgorithm, FSharpRef`1<Byte[]> contentHash, IEnumerable`1<Blob> content);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<long, BlobContentId, MemoryStream, string, Byte[]> generatePortablePdb(bool embedAllSource, FSharpList`1<string> embedSourceList, string sourceLink, HashAlgorithm checksumAlgorithm, bool showTimes, PdbData info, PathMap pathMap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<long, BlobContentId, MemoryStream> compressPortablePdbStream(long uncompressedLength, BlobContentId contentId, MemoryStream stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd[] writePortablePdbInfo(BlobContentId contentId, MemoryStream stream, bool showTimes, string fpdb, PathMap pathMap, BinaryChunk cvChunk, BinaryChunk deterministicPdbChunk, BinaryChunk checksumPdbChunk, string algorithmName, Byte[] checksum, bool embeddedPDB, bool deterministic);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd[] embedPortablePdbInfo(long uncompressedLength, BlobContentId contentId, MemoryStream stream, bool showTimes, string fpdb, BinaryChunk cvChunk, BinaryChunk pdbChunk, BinaryChunk deterministicPdbChunk, BinaryChunk checksumPdbChunk, string algorithmName, Byte[] checksum, bool embeddedPDB, bool deterministic);
    internal static PdbDocumentWriter getDocument@591(PdbDocumentWriter[] docs, int i);
    [CompilerGeneratedAttribute]
internal static Tuple`5<int, int, int, int, int> mapping@1-3(PdbSequencePoint sp);
    [CompilerGeneratedAttribute]
internal static void action@1-7(FSharpRef`1<PdbWriter> pdbw, PdbLocalVar v);
    internal static void writePdbScope@643(FSharpRef`1<PdbWriter> pdbw, FSharpOption`1<PdbMethodScope> parent, PdbMethodScope sco);
    [CompilerGeneratedAttribute]
internal static void writePdbInfo$cont@609(FSharpRef`1<PdbWriter> pdbw, PdbDocumentWriter[] docs, PdbMethodData minfo, Tuple`2[] sps, FSharpOption`1<Tuple`2<PdbSourceLoc, PdbSourceLoc>> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd[] writePdbInfo(bool showTimes, string f, string fpdb, PdbData info, BinaryChunk cvChunk);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static R op_Dynamic(a this, string memb, Args args);
    internal static AssemblyName get_monoCompilerSvc();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object createSourceMethodImpl(string name, int token, int namespaceID);
    internal static object createWriter(string f);
    internal static Tuple`2<object, object> getDocument@739-1(Tuple`2[] docs, int i);
    internal static void writeScope@760(object wr, PdbMethodScope scope);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a writeMdbInfo(string fmdb, string f, PdbData info);
    internal static void writeScope@812-1(StreamWriter sw, string offs, PdbMethodScope scope);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void logDebugInfo(string outfile, PdbData info);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILRuntimeWriter : object {
    [DebuggerBrowsableAttribute("0")]
internal static T826855_370Bytes@ field826856@;
    [DebuggerBrowsableAttribute("0")]
internal static T826857_382Bytes@ field826858@;
    [DebuggerBrowsableAttribute("0")]
internal static T826859_394Bytes@ field826860@;
    [DebuggerBrowsableAttribute("0")]
internal static T826857_382Bytes@ field826861@;
    [DebuggerBrowsableAttribute("0")]
internal static T826859_394Bytes@ field826862@;
    [DebuggerBrowsableAttribute("0")]
internal static T826863_406Bytes@ field826864@;
    [CompilationMappingAttribute("9")]
internal static IComparer`1<int> codeLabelOrder { get; }
    internal static bool logRefEmitCalls { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ILTypeRef> orderILTypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ILMethodRef> orderILMethodRef { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ILFieldRef> orderILFieldRef { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ILPropertyRef> orderILPropertyRef { get; }
    [CompilationMappingAttribute("9")]
internal static emEnv emEnv0 { get; }
    [CompilationMappingAttribute("9")]
internal static Type TypeBuilderInstantiationT { get; }
    internal static bool enablePInvoke { get; }
    internal static bool verbose2 { get; }
    private static ILRuntimeWriter();
    internal static IComparer`1<int> get_codeLabelOrder();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c wrapCustomAttr(FSharpFunc`2<Tuple`2<a, b>, c> setCustomAttr, a cinfo, b bytes);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_logRefEmitCalls();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleBuilder AssemblyBuilder.DefineDynamicModuleAndLog(AssemblyBuilder asmB, string a, string b, bool c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AssemblyBuilder.SetCustomAttributeAndLog(AssemblyBuilder asmB, ConstructorInfo cinfo, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AssemblyBuilder.AddResourceFileAndLog(AssemblyBuilder asmB, string nm1, string nm2, ResourceAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AssemblyBuilder.SetCustomAttributeAndLog(AssemblyBuilder asmB, CustomAttributeBuilder cab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo ModuleBuilder.GetArrayMethodAndLog(ModuleBuilder modB, Type aty, string nm, CallingConventions flags, Type rty, Type[] tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ISymbolDocumentWriter ModuleBuilder.DefineDocumentAndLog(ModuleBuilder modB, string file, Guid lang, Guid vendor, Guid doctype);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type ModuleBuilder.GetTypeAndLog(ModuleBuilder modB, string nameInModule, bool flag1, bool flag2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeBuilder ModuleBuilder.DefineTypeAndLog(ModuleBuilder modB, string name, TypeAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ModuleBuilder.DefineManifestResourceAndLog(ModuleBuilder modB, string name, Stream stream, ResourceAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ModuleBuilder.SetCustomAttributeAndLog(ModuleBuilder modB, ConstructorInfo cinfo, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ConstructorBuilder.SetImplementationFlagsAndLog(ConstructorBuilder consB, MethodImplAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParameterBuilder ConstructorBuilder.DefineParameterAndLog(ConstructorBuilder consB, int n, ParameterAttributes attr, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILGenerator ConstructorBuilder.GetILGeneratorAndLog(ConstructorBuilder );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void MethodBuilder.SetImplementationFlagsAndLog(MethodBuilder methB, MethodImplAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void MethodBuilder.SetSignatureAndLog(MethodBuilder methB, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParameterBuilder MethodBuilder.DefineParameterAndLog(MethodBuilder methB, int n, ParameterAttributes attr, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static GenericTypeParameterBuilder[] MethodBuilder.DefineGenericParametersAndLog(MethodBuilder methB, String[] gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILGenerator MethodBuilder.GetILGeneratorAndLog(MethodBuilder );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void MethodBuilder.SetCustomAttributeAndLog(MethodBuilder methB, ConstructorInfo cinfo, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type TypeBuilder.CreateTypeAndLog(TypeBuilder );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeBuilder TypeBuilder.DefineNestedTypeAndLog(TypeBuilder typB, string name, TypeAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodBuilder TypeBuilder.DefineMethodAndLog(TypeBuilder typB, string name, MethodAttributes attrs, CallingConventions cconv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static GenericTypeParameterBuilder[] TypeBuilder.DefineGenericParametersAndLog(TypeBuilder typB, String[] gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorBuilder TypeBuilder.DefineConstructorAndLog(TypeBuilder typB, MethodAttributes attrs, CallingConventions cconv, Type[] parms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldBuilder TypeBuilder.DefineFieldAndLog(TypeBuilder typB, string nm, Type ty, FieldAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PropertyBuilder TypeBuilder.DefinePropertyAndLog(TypeBuilder typB, string nm, PropertyAttributes attrs, Type ty, Type[] args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EventBuilder TypeBuilder.DefineEventAndLog(TypeBuilder typB, string nm, EventAttributes attrs, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TypeBuilder.SetParentAndLog(TypeBuilder typB, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TypeBuilder.AddInterfaceImplementationAndLog(TypeBuilder typB, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object TypeBuilder.InvokeMemberAndLog(TypeBuilder typB, string nm, BindingFlags _flags, Object[] args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TypeBuilder.SetCustomAttributeAndLog(TypeBuilder typB, ConstructorInfo cinfo, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string OpCode.get_RefEmitName(OpCode );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LocalBuilder ILGenerator.DeclareLocalAndLog(ILGenerator ilG, Type ty, bool isPinned);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.MarkLabelAndLog(ILGenerator ilG, Label lab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.MarkSequencePointAndLog(ILGenerator ilG, a symDoc, int l1, int c1, int l2, int c2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Label ILGenerator.BeginExceptionBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EndExceptionBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.BeginFinallyBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.BeginCatchBlockAndLog(ILGenerator ilG, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.BeginExceptFilterBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.BeginFaultBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Label ILGenerator.DefineLabelAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, Label v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, short v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, int v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, MethodInfo v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, string v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, Type v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, FieldInfo v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, ConstructorInfo v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a flagsIf(bool b, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equalTypes(Type s, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equalTypeLists(FSharpList`1<a> ss, FSharpList`1<b> tt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equalTypeArrays(a[] ss, b[] tt);
    internal static Type[] getGenericArgumentsOfType(Type typT);
    internal static Type[] getGenericArgumentsOfMethod(MethodInfo methI);
    internal static Type getTypeConstructor(Type ty);
    internal static AssemblyName convAssemblyRef(ILAssemblyRef aref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeRefAux(cenv cenv, ILTypeRef tref);
    internal static IComparer`1<ILTypeRef> get_orderILTypeRef();
    internal static IComparer`1<ILMethodRef> get_orderILMethodRef();
    internal static IComparer`1<ILFieldRef> get_orderILFieldRef();
    internal static IComparer`1<ILPropertyRef> get_orderILPropertyRef();
    internal static emEnv get_emEnv0();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envBindTypeRef(emEnv emEnv, ILTypeRef tref, Type typT, TypeBuilder typB, ILTypeDef typeDef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envUpdateCreatedTypeRef(emEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeRef(cenv cenv, emEnv emEnv, bool preferCreated, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envBindConsRef(emEnv emEnv, ILMethodRef mref, ConstructorBuilder consB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorBuilder envGetConsB(emEnv emEnv, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envBindMethodRef(emEnv emEnv, ILMethodRef mref, MethodBuilder methB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodBuilder envGetMethB(emEnv emEnv, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envBindFieldRef(emEnv emEnv, ILFieldRef fref, FieldBuilder fieldB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldBuilder envGetFieldB(emEnv emEnv, ILFieldRef fref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envBindPropRef(emEnv emEnv, ILPropertyRef pref, PropertyBuilder propB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PropertyBuilder envGetPropB(emEnv emEnv, ILPropertyRef pref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeBuilder envGetTypB(emEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef envGetTypeDef(emEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envSetLocals(emEnv emEnv, LocalBuilder[] locs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LocalBuilder envGetLocal(emEnv emEnv, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envSetLabel(emEnv emEnv, int name, Label lab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Label envGetLabel(emEnv emEnv, int name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envPushTyvars(emEnv emEnv, Type[] tys);
    internal static emEnv envPopTyvars(emEnv emEnv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type envGetTyvar(emEnv emEnv, ushort u16);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isEmittedTypeRef(emEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv envAddEntryPt(emEnv emEnv, TypeBuilder mref_0, string mref_1);
    internal static Tuple`2<emEnv, FSharpList`1<Tuple`2<TypeBuilder, string>>> envPopEntryPts(emEnv emEnv);
    internal static CallingConventions convCallConv(ILCallingConv _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeSpec(cenv cenv, emEnv emEnv, bool preferCreated, ILTypeSpec tspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeAux(cenv cenv, emEnv emEnv, bool preferCreated, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convType(cenv cenv, emEnv emEnv, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeOrTypeDef(cenv cenv, emEnv emEnv, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Type> convTypes(cenv cenv, emEnv emEnv, FSharpList`1<ILType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type[] convTypesToArray(cenv cenv, emEnv emEnv, FSharpList`1<ILType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convCreatedType(cenv cenv, emEnv emEnv, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convCreatedTypeRef(cenv cenv, emEnv emEnv, ILTypeRef ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2[] convParamModifiersOfType(cenv cenv, emEnv emEnv, ILType pty);
    internal static Tuple`2<a[], a[]> splitModifiers(Tuple`2[] mods);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Type[], Type[]> convParamModifiers(cenv cenv, emEnv emEnv, ILParameter p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Type[], Type[]> convReturnModifiers(cenv cenv, emEnv emEnv, ILReturn p);
    internal static object convFieldInit(ILFieldInit x);
    internal static Type get_TypeBuilderInstantiationT();
    internal static bool typeIsNotQueryable(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldInfo queryableTypeGetField(a _emEnv, Type parentT, ILFieldRef fref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldInfo nonQueryableTypeGetField(Type parentTI, FieldInfo fieldInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldInfo convFieldSpec(cenv cenv, emEnv emEnv, ILFieldSpec fspec);
    internal static bool satisfiesAllParameters@740(FSharpFunc`2<FSharpOption`1<Type>, FSharpFunc`2<Type, bool>> satisfiesParameter, FSharpOption`1[] args, Type[] ps);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Type> mapping@1-6(cenv cenv, ILType t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo queryableTypeGetMethodBySearch(cenv cenv, emEnv emEnv, Type parentT, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo queryableTypeGetMethod(cenv cenv, emEnv emEnv, Type parentT, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo nonQueryableTypeGetMethod(Type parentTI, MethodInfo methInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo convMethodRef(cenv cenv, emEnv emEnv, Type parentTI, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo convMethodSpec(cenv cenv, emEnv emEnv, ILMethodSpec mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorInfo queryableTypeGetConstructor(cenv cenv, emEnv emEnv, Type parentT, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorInfo nonQueryableTypeGetConstructor(Type parentTI, ConstructorInfo consInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorInfo convConstructorSpec(cenv cenv, emEnv emEnv, ILMethodSpec mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitLabelMark(emEnv emEnv, ILGenerator ilG, int label);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrCompare(emEnv emEnv, ILGenerator ilG, ILComparisonInstr comp, int targ);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrVolatile(ILGenerator ilG, ILVolatility _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrAlign(ILGenerator ilG, ILAlignment _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrTail(ILGenerator ilG, ILTailcall tail, FSharpFunc`2<Unit, Unit> emitTheCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrNewobj(cenv cenv, emEnv emEnv, ILGenerator ilG, ILMethodSpec mspec, FSharpOption`1<a> varargs);
    internal static void emitSilverlightCheck(ILGenerator ilG);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrCall(cenv cenv, emEnv emEnv, ILGenerator ilG, OpCode opCall, ILTailcall tail, ILMethodSpec mspec, FSharpOption`1<FSharpList`1<ILType>> varargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo getGenericMethodDefinition(FSharpExpr q, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo getArrayMethInfo(int n, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo setArrayMethInfo(int n, Type ty);
    internal static Guid guid@1300(FSharpOption`1<Byte[]> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstr(cenv cenv, ModuleBuilder modB, emEnv emEnv, ILGenerator ilG, ILInstr instr);
    internal static void add@1339-1(Dictionary`2<int, FSharpList`1<FSharpFunc`2<Unit, Unit>>> pc2action, Dictionary`2<int, int> lab2pc, int lab, FSharpFunc`2<Unit, Unit> action);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitCode(cenv cenv, ModuleBuilder modB, emEnv emEnv, ILGenerator ilG, ILCode code);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LocalBuilder emitLocal(cenv cenv, emEnv emEnv, ILGenerator ilG, ILLocal local);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitILMethodBody(cenv cenv, ModuleBuilder modB, emEnv emEnv, ILGenerator ilG, ILMethodBody ilmbody);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitMethodBody(cenv cenv, ModuleBuilder modB, emEnv emEnv, FSharpFunc`2<Unit, a> ilG, b _name, ILLazyMethodBody mbody);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ConstructorInfo, Byte[]> convCustomAttr(cenv cenv, emEnv emEnv, ILAttribute cattr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a emitCustomAttr(cenv cenv, emEnv emEnv, FSharpFunc`2<Tuple`2<ConstructorInfo, Byte[]>, a> add, ILAttribute cattr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitCustomAttrs(cenv cenv, emEnv emEnv, FSharpFunc`2<Tuple`2<ConstructorInfo, Byte[]>, Unit> add, ILAttributes cattrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildGenParamsPass1(a _emEnv, FSharpFunc`2<String[], b> defineGenericParameters, FSharpList`1<ILGenericParameterDef> gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildGenParamsPass1b(cenv cenv, emEnv emEnv, Type[] genArgs, FSharpList`1<ILGenericParameterDef> gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitParameter(cenv cenv, emEnv emEnv, FSharpFunc`2<Tuple`3<int, ParameterAttributes, string>, ParameterBuilder> defineParameter, int i, ILParameter param);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_enablePInvoke();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildMethodPass2(cenv cenv, ILTypeRef tref, TypeBuilder typB, emEnv emEnv, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildMethodPass3(cenv cenv, ILTypeRef tref, ModuleBuilder modB, TypeBuilder typB, emEnv emEnv, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildFieldPass2(cenv cenv, ILTypeRef tref, TypeBuilder typB, emEnv emEnv, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildFieldPass3(cenv cenv, ILTypeRef tref, TypeBuilder _typB, emEnv emEnv, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildPropertyPass2(cenv cenv, ILTypeRef tref, TypeBuilder typB, emEnv emEnv, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildPropertyPass3(cenv cenv, ILTypeRef tref, TypeBuilder _typB, emEnv emEnv, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildEventPass3(cenv cenv, TypeBuilder typB, emEnv emEnv, ILEventDef eventDef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildMethodImplsPass3(cenv cenv, a _tref, TypeBuilder typB, emEnv emEnv, ILMethodImplDef mimpl);
    internal static TypeAttributes typeAttrbutesOfTypeDefKind(ILTypeDefKind x);
    internal static TypeAttributes typeAttrbutesOfTypeAccess(ILTypeDefAccess x);
    internal static TypeAttributes typeAttributesOfTypeEncoding(ILDefaultPInvokeEncoding x);
    internal static FSharpOption`1<Tuple`2<ConstructorInfo, Byte[]>> attr@1775(cenv cenv, emEnv emEnv, int x, ILTypeDefLayoutInfo p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<ConstructorInfo, Byte[]>> typeAttributesOfTypeLayout(cenv cenv, emEnv emEnv, ILTypeDefLayout x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildTypeDefPass1(cenv cenv, emEnv emEnv, ModuleBuilder modB, FSharpFunc`2<Tuple`2<string, TypeAttributes>, TypeBuilder> rootTypeBuilder, FSharpList`1<ILTypeDef> nesting, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildTypeTypeDef(cenv cenv, emEnv emEnv, ModuleBuilder modB, TypeBuilder typB, FSharpList`1<ILTypeDef> nesting, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildTypeDefPass1b(cenv cenv, FSharpList`1<ILTypeDef> nesting, emEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildTypeDefPass2(cenv cenv, FSharpList`1<ILTypeDef> nesting, emEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildTypeDefPass3(cenv cenv, FSharpList`1<ILTypeDef> nesting, ModuleBuilder modB, emEnv emEnv, ILTypeDef tdef);
    internal static FSharpList`1<ILTypeRef> getEnclosingTypeRefs(ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILTypeRef> getTypeRefsInType(CollectTypes allTypes, ILType ty, FSharpList`1<ILTypeRef> acc);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_verbose2();
    internal static void traverseTypeDef@1963(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, emEnv emEnv, ILTypeRef tref, ILTypeDef tdef);
    internal static void traverseType@1994(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, emEnv emEnv, CollectTypes allTypes, ILType ty);
    internal static void traverseTypeRef@1999(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, emEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createTypeRef(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, emEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildTypeDefPass4(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, FSharpList`1<ILTypeDef> nesting, emEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildModuleTypePass1(cenv cenv, ModuleBuilder modB, emEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildModuleTypePass1b(cenv cenv, emEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildModuleTypePass2(cenv cenv, emEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildModuleTypePass3(cenv cenv, ModuleBuilder modB, emEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildModuleTypePass4(Dictionary`2<ILTypeRef, bool> visited_0, Dictionary`2<ILTypeRef, bool> visited_1, emEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static emEnv buildModuleFragment(cenv cenv, emEnv emEnv, AssemblyBuilder asmB, ModuleBuilder modB, ILModuleDef m);
    internal static AssemblyBuilder defineDynamicAssemblyAndLog(AssemblyName asmName, AssemblyBuilderAccess flags, string asmDir);
    internal static Tuple`2<AssemblyBuilder, ModuleBuilder> mkDynamicAssemblyAndModule(string assemblyName, bool optimize, bool debugInfo, bool collectible);
    internal static Tuple`2<emEnv, FSharpList`1<FSharpFunc`2<Unit, FSharpOption`1<Exception>>>> emitModuleFragment(ILGlobals ilg, emEnv emEnv, AssemblyBuilder asmB, ModuleBuilder modB, ILModuleDef modul, bool debugInfo, FSharpFunc`2<ILAssemblyRef, FSharpOption`1<FSharpChoice`2<string, Assembly>>> resolveAssemblyRef, FSharpFunc`2<string, FSharpOption`1<ILTypeRef>> tryFindSysILTypeRef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type LookupTypeRef(cenv cenv, emEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type LookupType(cenv cenv, emEnv emEnv, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FieldInfo> LookupFieldRef(emEnv emEnv, ILFieldRef fref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MethodInfo> LookupMethodRef(emEnv emEnv, ILMethodRef mref);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Internal.AsciiConstants : object {
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<ILGlobals> parseILGlobals { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, ILInstr>>> noArgInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Unit, ILInstr>>>> NoArgInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<long, ILInstr>>>> Int64Instrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<int, ILInstr>>>> Int32Instrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<int, int>, ILInstr>>>> Int32Int32Instrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILConst, ILInstr>>>> DoubleInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<ILMethodSpec, FSharpOption`1<FSharpList`1<ILType>>>, ILInstr>>>> MethodSpecInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<string, ILInstr>>>> StringInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILToken, ILInstr>>>> TokenInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILType, ILInstr>>>> TypeInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<int, ILType>, ILInstr>>>> IntTypeInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILType, ILInstr>>>> ValueTypeInstrs { get; }
    internal static FSharpRef`1<ILGlobals> get_parseILGlobals();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, ILInstr>>> get_noArgInstrs();
    internal static Tuple`2<a, FSharpFunc`2<Unit, ILInstr>> mk_stind(a nm, ILBasicType dt);
    internal static Tuple`2<a, FSharpFunc`2<Unit, ILInstr>> mk_ldind(a nm, ILBasicType dt);
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Unit, ILInstr>>>> get_NoArgInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<long, ILInstr>>>> get_Int64Instrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<int, ILInstr>>>> get_Int32Instrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<int, int>, ILInstr>>>> get_Int32Int32Instrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILConst, ILInstr>>>> get_DoubleInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<ILMethodSpec, FSharpOption`1<FSharpList`1<ILType>>>, ILInstr>>>> get_MethodSpecInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<string, ILInstr>>>> get_StringInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILToken, ILInstr>>>> get_TokenInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILType, ILInstr>>>> get_TypeInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<int, ILType>, ILInstr>>>> get_IntTypeInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILType, ILInstr>>>> get_ValueTypeInstrs();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Internal.AsciiLexer : object {
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826523@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826524@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826525@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826526@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826527@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826528@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826529@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826530@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826531@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826532@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826533@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826534@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826535@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826536@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826537@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826538@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826539@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826540@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826541@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826542@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826543@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826544@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826545@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826546@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826547@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826548@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826549@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826550@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826551@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826552@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826553@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826554@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826555@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826556@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826557@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826558@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826559@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826560@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826561@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826562@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826563@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826564@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826565@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826566@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826567@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826568@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826569@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826570@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826571@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826572@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826573@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826574@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826575@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826576@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826577@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826578@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826579@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826580@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826581@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826582@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826583@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826584@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826585@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826586@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826587@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826588@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826589@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826590@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826591@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826592@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826593@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826594@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826595@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826596@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826597@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826598@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826599@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826600@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826601@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826602@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826603@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826604@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826605@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826606@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826607@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826608@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826609@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826610@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826611@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826612@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826613@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826614@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826615@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826616@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826617@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826618@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826619@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826620@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826621@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826622@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826623@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826624@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826625@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826626@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826627@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826628@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826629@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826630@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826631@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826632@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826633@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826634@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826635@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826636@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826637@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826638@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826639@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826640@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826641@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826642@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826643@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826644@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826645@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826646@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826647@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826648@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826649@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826650@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826651@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826652@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826653@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826654@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826655@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826656@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826657@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826658@;
    [DebuggerBrowsableAttribute("0")]
internal static T826522_830Bytes@ field826659@;
    [DebuggerBrowsableAttribute("0")]
internal static T826660_274Bytes@ field826661@;
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<string, token>>> keywords { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<HashMultiMap`2<string, token>> kwdInstrTable { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[][] trans { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] actions { get; }
    [CompilationMappingAttribute("9")]
internal static UnicodeTables _fslex_tables { get; }
    private static AsciiLexer();
    internal static string lexeme(LexBuffer`1<char> lexbuf);
    internal static b unexpectedChar(a _lexbuf);
    internal static Lazy`1<FSharpList`1<Tuple`2<string, token>>> get_keywords();
    internal static Lazy`1<HashMultiMap`2<string, token>> get_kwdInstrTable();
    internal static void addTable@67(HashMultiMap`2<string, token> t, FSharpFunc`2<a, token> f, Lazy`1<FSharpList`1<Tuple`2<b, a>>> l);
    internal static token kwdOrInstr(string s);
    internal static int eval(char _arg1);
    internal static token kwdOrInstrOrId(string s);
    internal static UInt16[][] get_trans();
    internal static UInt16[] get_actions();
    internal static UnicodeTables get__fslex_tables();
    internal static a _fslex_dummy();
    internal static token token(LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Internal.AsciiParser : object {
    [DebuggerBrowsableAttribute("0")]
internal static T826507_628Bytes@ field826508@;
    [DebuggerBrowsableAttribute("0")]
internal static T826509_64Bytes@ field826510@;
    [DebuggerBrowsableAttribute("0")]
internal static T826511_648Bytes@ field826512@;
    [DebuggerBrowsableAttribute("0")]
internal static T826513_284Bytes@ field826514@;
    [DebuggerBrowsableAttribute("0")]
internal static T826515_2208Bytes@ field826516@;
    [DebuggerBrowsableAttribute("0")]
internal static T826513_284Bytes@ field826517@;
    [DebuggerBrowsableAttribute("0")]
internal static T826518_192Bytes@ field826519@;
    [DebuggerBrowsableAttribute("0")]
internal static T826518_192Bytes@ field826520@;
    [DebuggerBrowsableAttribute("0")]
internal static T826513_284Bytes@ field826521@;
    internal static int _fsyacc_endOfInputTag { get; }
    internal static int _fsyacc_tagOfErrorTerminal { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_gotos { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_sparseGotoTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableRowOffsets { get; }
    internal static int _fsyacc_action_rows { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_reductionSymbolCounts { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_productionToNonTerminalTable { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_immediateActions { get; }
    private static AsciiParser();
    internal static a pfailwith(string s);
    internal static Tuple`2<FSharpList`1<ILType>, FSharpOption`1<FSharpList`1<ILType>>> normals@27(FSharpList`1<SigArg> _arg1);
    internal static FSharpList`1<ILType> varargs@31(FSharpList`1<SigArg> _arg2);
    internal static Tuple`2<FSharpList`1<ILType>, FSharpOption`1<FSharpList`1<ILType>>> decodeVarargs(FSharpList`1<SigArg> args);
    internal static ResolvedAtMethodSpecScope`1<a> noMethodSpecScope(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a resolveMethodSpecScope(ResolvedAtMethodSpecScope`1<a> _arg1, FSharpList`1<ILGenericParameterDef> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResolvedAtMethodSpecScope`1<b> resolveMethodSpecScopeThen(ResolvedAtMethodSpecScope`1<a> _arg1, FSharpFunc`2<a, ResolvedAtMethodSpecScope`1<b>> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a resolveFormalMethodSpecScope(FSharpOption`1<ILTypeSpec> tspeco, ResolvedAtMethodSpecScope`1<a> obj);
    internal static a resolveCurrentMethodSpecScope(ResolvedAtMethodSpecScope`1<a> obj);
    internal static ILAssemblyRef findSystemRuntimeAssemblyRef();
    internal static ILAssemblyRef findAssemblyRef(string nm);
    internal static int tagOfToken(token t);
    internal static tokenId tokenTagToTokenId(int tokenIdx);
    internal static nonTerminalId prodIdxToNonTerminal(int prodIdx);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_endOfInputTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_tagOfErrorTerminal();
    internal static string token_to_string(token t);
    internal static object _fsyacc_dataOfToken(token t);
    internal static UInt16[] get__fsyacc_gotos();
    internal static UInt16[] get__fsyacc_sparseGotoTableRowOffsets();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableElements();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableRowOffsets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_action_rows();
    internal static UInt16[] get__fsyacc_actionTableElements();
    internal static UInt16[] get__fsyacc_actionTableRowOffsets();
    internal static UInt16[] get__fsyacc_reductionSymbolCounts();
    internal static UInt16[] get__fsyacc_productionToNonTerminalTable();
    internal static UInt16[] get__fsyacc_immediateActions();
    internal static FSharpFunc`2[] _fsyacc_reductions();
    internal static Tables`1<token> tables();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object engine(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf, int startState);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr[] ilInstrs(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType ilType(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Internal.BinaryConstants : object {
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<TableName, int>> sortedTableInfo { get; }
    [CompilationMappingAttribute("9")]
internal static TypeDefOrRefTag tdor_TypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static TypeDefOrRefTag tdor_TypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static TypeDefOrRefTag tdor_TypeSpec { get; }
    [CompilationMappingAttribute("9")]
internal static HasConstantTag hc_FieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasConstantTag hc_ParamDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasConstantTag hc_Property { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_FieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_TypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_TypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_ParamDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_InterfaceImpl { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_MemberRef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Module { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Permission { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Property { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Event { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_StandAloneSig { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_ModuleRef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_TypeSpec { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Assembly { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_AssemblyRef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_File { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_ExportedType { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_ManifestResource { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_GenericParam { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_GenericParamConstraint { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_MethodSpec { get; }
    [CompilationMappingAttribute("9")]
internal static HasFieldMarshalTag hfm_FieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasFieldMarshalTag hfm_ParamDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasDeclSecurityTag hds_TypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasDeclSecurityTag hds_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasDeclSecurityTag hds_Assembly { get; }
    [CompilationMappingAttribute("9")]
internal static MemberRefParentTag mrp_TypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static MemberRefParentTag mrp_ModuleRef { get; }
    [CompilationMappingAttribute("9")]
internal static MemberRefParentTag mrp_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static MemberRefParentTag mrp_TypeSpec { get; }
    [CompilationMappingAttribute("9")]
internal static HasSemanticsTag hs_Event { get; }
    [CompilationMappingAttribute("9")]
internal static HasSemanticsTag hs_Property { get; }
    [CompilationMappingAttribute("9")]
internal static MethodDefOrRefTag mdor_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static MethodDefOrRefTag mdor_MemberRef { get; }
    [CompilationMappingAttribute("9")]
internal static MethodDefOrRefTag mdor_MethodSpec { get; }
    [CompilationMappingAttribute("9")]
internal static MemberForwardedTag mf_FieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static MemberForwardedTag mf_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static ImplementationTag i_File { get; }
    [CompilationMappingAttribute("9")]
internal static ImplementationTag i_AssemblyRef { get; }
    [CompilationMappingAttribute("9")]
internal static ImplementationTag i_ExportedType { get; }
    [CompilationMappingAttribute("9")]
internal static CustomAttributeTypeTag cat_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static CustomAttributeTypeTag cat_MemberRef { get; }
    [CompilationMappingAttribute("9")]
internal static ResolutionScopeTag rs_Module { get; }
    [CompilationMappingAttribute("9")]
internal static ResolutionScopeTag rs_ModuleRef { get; }
    [CompilationMappingAttribute("9")]
internal static ResolutionScopeTag rs_AssemblyRef { get; }
    [CompilationMappingAttribute("9")]
internal static ResolutionScopeTag rs_TypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static TypeOrMethodDefTag tomd_TypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static TypeOrMethodDefTag tomd_MethodDef { get; }
    internal static byte et_END { get; }
    internal static byte et_VOID { get; }
    internal static byte et_BOOLEAN { get; }
    internal static byte et_CHAR { get; }
    internal static byte et_I1 { get; }
    internal static byte et_U1 { get; }
    internal static byte et_I2 { get; }
    internal static byte et_U2 { get; }
    internal static byte et_I4 { get; }
    internal static byte et_U4 { get; }
    internal static byte et_I8 { get; }
    internal static byte et_U8 { get; }
    internal static byte et_R4 { get; }
    internal static byte et_R8 { get; }
    internal static byte et_STRING { get; }
    internal static byte et_PTR { get; }
    internal static byte et_BYREF { get; }
    internal static byte et_VALUETYPE { get; }
    internal static byte et_CLASS { get; }
    internal static byte et_VAR { get; }
    internal static byte et_ARRAY { get; }
    internal static byte et_WITH { get; }
    internal static byte et_TYPEDBYREF { get; }
    internal static byte et_I { get; }
    internal static byte et_U { get; }
    internal static byte et_FNPTR { get; }
    internal static byte et_OBJECT { get; }
    internal static byte et_SZARRAY { get; }
    internal static byte et_MVAR { get; }
    internal static byte et_CMOD_REQD { get; }
    internal static byte et_CMOD_OPT { get; }
    internal static byte et_SENTINEL { get; }
    internal static byte et_PINNED { get; }
    internal static int i_nop { get; }
    internal static int i_break { get; }
    internal static int i_ldarg_0 { get; }
    internal static int i_ldarg_1 { get; }
    internal static int i_ldarg_2 { get; }
    internal static int i_ldarg_3 { get; }
    internal static int i_ldloc_0 { get; }
    internal static int i_ldloc_1 { get; }
    internal static int i_ldloc_2 { get; }
    internal static int i_ldloc_3 { get; }
    internal static int i_stloc_0 { get; }
    internal static int i_stloc_1 { get; }
    internal static int i_stloc_2 { get; }
    internal static int i_stloc_3 { get; }
    internal static int i_ldarg_s { get; }
    internal static int i_ldarga_s { get; }
    internal static int i_starg_s { get; }
    internal static int i_ldloc_s { get; }
    internal static int i_ldloca_s { get; }
    internal static int i_stloc_s { get; }
    internal static int i_ldnull { get; }
    internal static int i_ldc_i4_m1 { get; }
    internal static int i_ldc_i4_0 { get; }
    internal static int i_ldc_i4_1 { get; }
    internal static int i_ldc_i4_2 { get; }
    internal static int i_ldc_i4_3 { get; }
    internal static int i_ldc_i4_4 { get; }
    internal static int i_ldc_i4_5 { get; }
    internal static int i_ldc_i4_6 { get; }
    internal static int i_ldc_i4_7 { get; }
    internal static int i_ldc_i4_8 { get; }
    internal static int i_ldc_i4_s { get; }
    internal static int i_ldc_i4 { get; }
    internal static int i_ldc_i8 { get; }
    internal static int i_ldc_r4 { get; }
    internal static int i_ldc_r8 { get; }
    internal static int i_dup { get; }
    internal static int i_pop { get; }
    internal static int i_jmp { get; }
    internal static int i_call { get; }
    internal static int i_calli { get; }
    internal static int i_ret { get; }
    internal static int i_br_s { get; }
    internal static int i_brfalse_s { get; }
    internal static int i_brtrue_s { get; }
    internal static int i_beq_s { get; }
    internal static int i_bge_s { get; }
    internal static int i_bgt_s { get; }
    internal static int i_ble_s { get; }
    internal static int i_blt_s { get; }
    internal static int i_bne_un_s { get; }
    internal static int i_bge_un_s { get; }
    internal static int i_bgt_un_s { get; }
    internal static int i_ble_un_s { get; }
    internal static int i_blt_un_s { get; }
    internal static int i_br { get; }
    internal static int i_brfalse { get; }
    internal static int i_brtrue { get; }
    internal static int i_beq { get; }
    internal static int i_bge { get; }
    internal static int i_bgt { get; }
    internal static int i_ble { get; }
    internal static int i_blt { get; }
    internal static int i_bne_un { get; }
    internal static int i_bge_un { get; }
    internal static int i_bgt_un { get; }
    internal static int i_ble_un { get; }
    internal static int i_blt_un { get; }
    internal static int i_switch { get; }
    internal static int i_ldind_i1 { get; }
    internal static int i_ldind_u1 { get; }
    internal static int i_ldind_i2 { get; }
    internal static int i_ldind_u2 { get; }
    internal static int i_ldind_i4 { get; }
    internal static int i_ldind_u4 { get; }
    internal static int i_ldind_i8 { get; }
    internal static int i_ldind_i { get; }
    internal static int i_ldind_r4 { get; }
    internal static int i_ldind_r8 { get; }
    internal static int i_ldind_ref { get; }
    internal static int i_stind_ref { get; }
    internal static int i_stind_i1 { get; }
    internal static int i_stind_i2 { get; }
    internal static int i_stind_i4 { get; }
    internal static int i_stind_i8 { get; }
    internal static int i_stind_r4 { get; }
    internal static int i_stind_r8 { get; }
    internal static int i_add { get; }
    internal static int i_sub { get; }
    internal static int i_mul { get; }
    internal static int i_div { get; }
    internal static int i_div_un { get; }
    internal static int i_rem { get; }
    internal static int i_rem_un { get; }
    internal static int i_and { get; }
    internal static int i_or { get; }
    internal static int i_xor { get; }
    internal static int i_shl { get; }
    internal static int i_shr { get; }
    internal static int i_shr_un { get; }
    internal static int i_neg { get; }
    internal static int i_not { get; }
    internal static int i_conv_i1 { get; }
    internal static int i_conv_i2 { get; }
    internal static int i_conv_i4 { get; }
    internal static int i_conv_i8 { get; }
    internal static int i_conv_r4 { get; }
    internal static int i_conv_r8 { get; }
    internal static int i_conv_u4 { get; }
    internal static int i_conv_u8 { get; }
    internal static int i_callvirt { get; }
    internal static int i_cpobj { get; }
    internal static int i_ldobj { get; }
    internal static int i_ldstr { get; }
    internal static int i_newobj { get; }
    internal static int i_castclass { get; }
    internal static int i_isinst { get; }
    internal static int i_conv_r_un { get; }
    internal static int i_unbox { get; }
    internal static int i_throw { get; }
    internal static int i_ldfld { get; }
    internal static int i_ldflda { get; }
    internal static int i_stfld { get; }
    internal static int i_ldsfld { get; }
    internal static int i_ldsflda { get; }
    internal static int i_stsfld { get; }
    internal static int i_stobj { get; }
    internal static int i_conv_ovf_i1_un { get; }
    internal static int i_conv_ovf_i2_un { get; }
    internal static int i_conv_ovf_i4_un { get; }
    internal static int i_conv_ovf_i8_un { get; }
    internal static int i_conv_ovf_u1_un { get; }
    internal static int i_conv_ovf_u2_un { get; }
    internal static int i_conv_ovf_u4_un { get; }
    internal static int i_conv_ovf_u8_un { get; }
    internal static int i_conv_ovf_i_un { get; }
    internal static int i_conv_ovf_u_un { get; }
    internal static int i_box { get; }
    internal static int i_newarr { get; }
    internal static int i_ldlen { get; }
    internal static int i_ldelema { get; }
    internal static int i_ldelem_i1 { get; }
    internal static int i_ldelem_u1 { get; }
    internal static int i_ldelem_i2 { get; }
    internal static int i_ldelem_u2 { get; }
    internal static int i_ldelem_i4 { get; }
    internal static int i_ldelem_u4 { get; }
    internal static int i_ldelem_i8 { get; }
    internal static int i_ldelem_i { get; }
    internal static int i_ldelem_r4 { get; }
    internal static int i_ldelem_r8 { get; }
    internal static int i_ldelem_ref { get; }
    internal static int i_stelem_i { get; }
    internal static int i_stelem_i1 { get; }
    internal static int i_stelem_i2 { get; }
    internal static int i_stelem_i4 { get; }
    internal static int i_stelem_i8 { get; }
    internal static int i_stelem_r4 { get; }
    internal static int i_stelem_r8 { get; }
    internal static int i_stelem_ref { get; }
    internal static int i_conv_ovf_i1 { get; }
    internal static int i_conv_ovf_u1 { get; }
    internal static int i_conv_ovf_i2 { get; }
    internal static int i_conv_ovf_u2 { get; }
    internal static int i_conv_ovf_i4 { get; }
    internal static int i_conv_ovf_u4 { get; }
    internal static int i_conv_ovf_i8 { get; }
    internal static int i_conv_ovf_u8 { get; }
    internal static int i_refanyval { get; }
    internal static int i_ckfinite { get; }
    internal static int i_mkrefany { get; }
    internal static int i_ldtoken { get; }
    internal static int i_conv_u2 { get; }
    internal static int i_conv_u1 { get; }
    internal static int i_conv_i { get; }
    internal static int i_conv_ovf_i { get; }
    internal static int i_conv_ovf_u { get; }
    internal static int i_add_ovf { get; }
    internal static int i_add_ovf_un { get; }
    internal static int i_mul_ovf { get; }
    internal static int i_mul_ovf_un { get; }
    internal static int i_sub_ovf { get; }
    internal static int i_sub_ovf_un { get; }
    internal static int i_endfinally { get; }
    internal static int i_leave { get; }
    internal static int i_leave_s { get; }
    internal static int i_stind_i { get; }
    internal static int i_conv_u { get; }
    internal static int i_arglist { get; }
    internal static int i_ceq { get; }
    internal static int i_cgt { get; }
    internal static int i_cgt_un { get; }
    internal static int i_clt { get; }
    internal static int i_clt_un { get; }
    internal static int i_ldftn { get; }
    internal static int i_ldvirtftn { get; }
    internal static int i_ldarg { get; }
    internal static int i_ldarga { get; }
    internal static int i_starg { get; }
    internal static int i_ldloc { get; }
    internal static int i_ldloca { get; }
    internal static int i_stloc { get; }
    internal static int i_localloc { get; }
    internal static int i_endfilter { get; }
    internal static int i_unaligned { get; }
    internal static int i_volatile { get; }
    internal static int i_constrained { get; }
    internal static int i_readonly { get; }
    internal static int i_tail { get; }
    internal static int i_initobj { get; }
    internal static int i_cpblk { get; }
    internal static int i_initblk { get; }
    internal static int i_rethrow { get; }
    internal static int i_sizeof { get; }
    internal static int i_refanytype { get; }
    internal static int i_ldelem_any { get; }
    internal static int i_stelem_any { get; }
    internal static int i_unbox_any { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<int, ILInstr>>> noArgInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<Dictionary`2<ILComparisonInstr, int>> ILCmpInstrMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<Dictionary`2<ILComparisonInstr, int>> ILCmpInstrRevMap { get; }
    internal static byte nt_VOID { get; }
    internal static byte nt_BOOLEAN { get; }
    internal static byte nt_I1 { get; }
    internal static byte nt_U1 { get; }
    internal static byte nt_I2 { get; }
    internal static byte nt_U2 { get; }
    internal static byte nt_I4 { get; }
    internal static byte nt_U4 { get; }
    internal static byte nt_I8 { get; }
    internal static byte nt_U8 { get; }
    internal static byte nt_R4 { get; }
    internal static byte nt_R8 { get; }
    internal static byte nt_SYSCHAR { get; }
    internal static byte nt_VARIANT { get; }
    internal static byte nt_CURRENCY { get; }
    internal static byte nt_PTR { get; }
    internal static byte nt_DECIMAL { get; }
    internal static byte nt_DATE { get; }
    internal static byte nt_BSTR { get; }
    internal static byte nt_LPSTR { get; }
    internal static byte nt_LPWSTR { get; }
    internal static byte nt_LPTSTR { get; }
    internal static byte nt_FIXEDSYSSTRING { get; }
    internal static byte nt_OBJECTREF { get; }
    internal static byte nt_IUNKNOWN { get; }
    internal static byte nt_IDISPATCH { get; }
    internal static byte nt_STRUCT { get; }
    internal static byte nt_INTF { get; }
    internal static byte nt_SAFEARRAY { get; }
    internal static byte nt_FIXEDARRAY { get; }
    internal static byte nt_INT { get; }
    internal static byte nt_UINT { get; }
    internal static byte nt_NESTEDSTRUCT { get; }
    internal static byte nt_BYVALSTR { get; }
    internal static byte nt_ANSIBSTR { get; }
    internal static byte nt_TBSTR { get; }
    internal static byte nt_VARIANTBOOL { get; }
    internal static byte nt_FUNC { get; }
    internal static byte nt_ASANY { get; }
    internal static byte nt_ARRAY { get; }
    internal static byte nt_LPSTRUCT { get; }
    internal static byte nt_CUSTOMMARSHALER { get; }
    internal static byte nt_ERROR { get; }
    internal static byte nt_LPUTF8STR { get; }
    internal static byte nt_MAX { get; }
    internal static int vt_EMPTY { get; }
    internal static int vt_NULL { get; }
    internal static int vt_I2 { get; }
    internal static int vt_I4 { get; }
    internal static int vt_R4 { get; }
    internal static int vt_R8 { get; }
    internal static int vt_CY { get; }
    internal static int vt_DATE { get; }
    internal static int vt_BSTR { get; }
    internal static int vt_DISPATCH { get; }
    internal static int vt_ERROR { get; }
    internal static int vt_BOOL { get; }
    internal static int vt_VARIANT { get; }
    internal static int vt_UNKNOWN { get; }
    internal static int vt_DECIMAL { get; }
    internal static int vt_I1 { get; }
    internal static int vt_UI1 { get; }
    internal static int vt_UI2 { get; }
    internal static int vt_UI4 { get; }
    internal static int vt_I8 { get; }
    internal static int vt_UI8 { get; }
    internal static int vt_INT { get; }
    internal static int vt_UINT { get; }
    internal static int vt_VOID { get; }
    internal static int vt_HRESULT { get; }
    internal static int vt_PTR { get; }
    internal static int vt_SAFEARRAY { get; }
    internal static int vt_CARRAY { get; }
    internal static int vt_USERDEFINED { get; }
    internal static int vt_LPSTR { get; }
    internal static int vt_LPWSTR { get; }
    internal static int vt_RECORD { get; }
    internal static int vt_FILETIME { get; }
    internal static int vt_BLOB { get; }
    internal static int vt_STREAM { get; }
    internal static int vt_STORAGE { get; }
    internal static int vt_STREAMED_OBJECT { get; }
    internal static int vt_STORED_OBJECT { get; }
    internal static int vt_BLOB_OBJECT { get; }
    internal static int vt_CF { get; }
    internal static int vt_CLSID { get; }
    internal static int vt_VECTOR { get; }
    internal static int vt_ARRAY { get; }
    internal static int vt_BYREF { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<byte, ILNativeType>>> ILNativeTypeMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<ILNativeType, byte>>> ILNativeTypeRevMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<ILNativeVariant, int>>> ILVariantTypeMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<int, ILNativeVariant>>> ILVariantTypeRevMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<ILSecurityAction, int>>> ILSecurityActionMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<int, ILSecurityAction>>> ILSecurityActionRevMap { get; }
    internal static byte e_CorILMethod_TinyFormat { get; }
    internal static byte e_CorILMethod_FatFormat { get; }
    internal static byte e_CorILMethod_FormatMask { get; }
    internal static byte e_CorILMethod_MoreSects { get; }
    internal static byte e_CorILMethod_InitLocals { get; }
    internal static byte e_CorILMethod_Sect_EHTable { get; }
    internal static byte e_CorILMethod_Sect_FatFormat { get; }
    internal static byte e_CorILMethod_Sect_MoreSects { get; }
    internal static int e_COR_ILEXCEPTION_CLAUSE_EXCEPTION { get; }
    internal static int e_COR_ILEXCEPTION_CLAUSE_FILTER { get; }
    internal static int e_COR_ILEXCEPTION_CLAUSE_FINALLY { get; }
    internal static int e_COR_ILEXCEPTION_CLAUSE_FAULT { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_FASTCALL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_STDCALL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_THISCALL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_CDECL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_VARARG { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_FIELD { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_LOCAL_SIG { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_PROPERTY { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_GENERICINST { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_GENERIC { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_INSTANCE { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_INSTANCE_EXPLICIT { get; }
    internal static FSharpList`1<Tuple`2<TableName, int>> get_sortedTableInfo();
    internal static TypeDefOrRefTag get_tdor_TypeDef();
    internal static TypeDefOrRefTag get_tdor_TypeRef();
    internal static TypeDefOrRefTag get_tdor_TypeSpec();
    internal static TypeDefOrRefTag mkTypeDefOrRefOrSpecTag(int x);
    internal static HasConstantTag get_hc_FieldDef();
    internal static HasConstantTag get_hc_ParamDef();
    internal static HasConstantTag get_hc_Property();
    internal static HasConstantTag mkHasConstantTag(int x);
    internal static HasCustomAttributeTag get_hca_MethodDef();
    internal static HasCustomAttributeTag get_hca_FieldDef();
    internal static HasCustomAttributeTag get_hca_TypeRef();
    internal static HasCustomAttributeTag get_hca_TypeDef();
    internal static HasCustomAttributeTag get_hca_ParamDef();
    internal static HasCustomAttributeTag get_hca_InterfaceImpl();
    internal static HasCustomAttributeTag get_hca_MemberRef();
    internal static HasCustomAttributeTag get_hca_Module();
    internal static HasCustomAttributeTag get_hca_Permission();
    internal static HasCustomAttributeTag get_hca_Property();
    internal static HasCustomAttributeTag get_hca_Event();
    internal static HasCustomAttributeTag get_hca_StandAloneSig();
    internal static HasCustomAttributeTag get_hca_ModuleRef();
    internal static HasCustomAttributeTag get_hca_TypeSpec();
    internal static HasCustomAttributeTag get_hca_Assembly();
    internal static HasCustomAttributeTag get_hca_AssemblyRef();
    internal static HasCustomAttributeTag get_hca_File();
    internal static HasCustomAttributeTag get_hca_ExportedType();
    internal static HasCustomAttributeTag get_hca_ManifestResource();
    internal static HasCustomAttributeTag get_hca_GenericParam();
    internal static HasCustomAttributeTag get_hca_GenericParamConstraint();
    internal static HasCustomAttributeTag get_hca_MethodSpec();
    internal static HasCustomAttributeTag mkHasCustomAttributeTag(int x);
    internal static HasFieldMarshalTag get_hfm_FieldDef();
    internal static HasFieldMarshalTag get_hfm_ParamDef();
    internal static HasFieldMarshalTag mkHasFieldMarshalTag(int x);
    internal static HasDeclSecurityTag get_hds_TypeDef();
    internal static HasDeclSecurityTag get_hds_MethodDef();
    internal static HasDeclSecurityTag get_hds_Assembly();
    internal static HasDeclSecurityTag mkHasDeclSecurityTag(int x);
    internal static MemberRefParentTag get_mrp_TypeRef();
    internal static MemberRefParentTag get_mrp_ModuleRef();
    internal static MemberRefParentTag get_mrp_MethodDef();
    internal static MemberRefParentTag get_mrp_TypeSpec();
    internal static MemberRefParentTag mkMemberRefParentTag(int x);
    internal static HasSemanticsTag get_hs_Event();
    internal static HasSemanticsTag get_hs_Property();
    internal static HasSemanticsTag mkHasSemanticsTag(int x);
    internal static MethodDefOrRefTag get_mdor_MethodDef();
    internal static MethodDefOrRefTag get_mdor_MemberRef();
    internal static MethodDefOrRefTag get_mdor_MethodSpec();
    internal static MethodDefOrRefTag mkMethodDefOrRefTag(int x);
    internal static MemberForwardedTag get_mf_FieldDef();
    internal static MemberForwardedTag get_mf_MethodDef();
    internal static MemberForwardedTag mkMemberForwardedTag(int x);
    internal static ImplementationTag get_i_File();
    internal static ImplementationTag get_i_AssemblyRef();
    internal static ImplementationTag get_i_ExportedType();
    internal static ImplementationTag mkImplementationTag(int x);
    internal static CustomAttributeTypeTag get_cat_MethodDef();
    internal static CustomAttributeTypeTag get_cat_MemberRef();
    internal static CustomAttributeTypeTag mkILCustomAttributeTypeTag(int x);
    internal static ResolutionScopeTag get_rs_Module();
    internal static ResolutionScopeTag get_rs_ModuleRef();
    internal static ResolutionScopeTag get_rs_AssemblyRef();
    internal static ResolutionScopeTag get_rs_TypeRef();
    internal static ResolutionScopeTag mkResolutionScopeTag(int x);
    internal static TypeOrMethodDefTag get_tomd_TypeDef();
    internal static TypeOrMethodDefTag get_tomd_MethodDef();
    internal static TypeOrMethodDefTag mkTypeOrMethodDefTag(int x);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_END();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VOID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_BOOLEAN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CHAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_STRING();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_PTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_BYREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VALUETYPE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CLASS();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_ARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_WITH();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_TYPEDBYREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_FNPTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_SZARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_MVAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CMOD_REQD();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CMOD_OPT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_SENTINEL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_PINNED();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_nop();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_break();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarga_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_starg_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloca_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldnull();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_m1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_6();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_7();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_dup();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_pop();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_jmp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_call();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_calli();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ret();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_br_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_brfalse_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_brtrue_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_beq_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bge_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bgt_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ble_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_blt_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bne_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bge_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bgt_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ble_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_blt_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_br();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_brfalse();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_brtrue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_beq();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bge();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bgt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ble();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_blt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bne_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bge_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bgt_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ble_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_blt_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_switch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_u1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_u2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_u4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_ref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_ref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_add();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_sub();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_mul();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_div();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_div_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_rem();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_rem_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_and();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_or();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_xor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_shl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_shr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_shr_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_neg();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_not();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_callvirt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_cpobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldstr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_newobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_castclass();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_isinst();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_r_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_unbox();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_throw();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldfld();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldflda();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stfld();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldsfld();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldsflda();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stsfld();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i1_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i2_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i4_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i8_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u1_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u2_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u4_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u8_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_box();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_newarr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldlen();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelema();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_u1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_u2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_u4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_ref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_ref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_refanyval();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ckfinite();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_mkrefany();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldtoken();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_add_ovf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_add_ovf_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_mul_ovf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_mul_ovf_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_sub_ovf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_sub_ovf_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_endfinally();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_leave();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_leave_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_arglist();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ceq();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_cgt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_cgt_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_clt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_clt_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldftn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldvirtftn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarga();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_starg();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloca();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_localloc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_endfilter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_unaligned();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_volatile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_constrained();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_readonly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_tail();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_initobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_cpblk();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_initblk();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_rethrow();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_sizeof();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_refanytype();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_any();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_any();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_unbox_any();
    internal static Lazy`1<FSharpList`1<Tuple`2<int, ILInstr>>> get_noArgInstrs();
    [CompilerGeneratedAttribute]
internal static bool isNoArgInstr$cont@662(ILInstr i, Unit unitVar);
    internal static bool isNoArgInstr(ILInstr i);
    internal static Lazy`1<Dictionary`2<ILComparisonInstr, int>> get_ILCmpInstrMap();
    internal static Lazy`1<Dictionary`2<ILComparisonInstr, int>> get_ILCmpInstrRevMap();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_VOID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_BOOLEAN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_I1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_U1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_I2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_U2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_I4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_U4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_I8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_U8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_R4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_R8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_SYSCHAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_VARIANT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_CURRENCY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_PTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_DECIMAL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_DATE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_BSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPWSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPTSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_FIXEDSYSSTRING();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_OBJECTREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_IUNKNOWN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_IDISPATCH();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_STRUCT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_INTF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_SAFEARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_FIXEDARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_INT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_UINT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_NESTEDSTRUCT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_BYVALSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_ANSIBSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_TBSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_VARIANTBOOL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_FUNC();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_ASANY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_ARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPSTRUCT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_CUSTOMMARSHALER();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_ERROR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPUTF8STR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_MAX();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_EMPTY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_NULL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_I2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_I4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_R4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_R8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_CY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_DATE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_DISPATCH();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_ERROR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BOOL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_VARIANT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UNKNOWN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_DECIMAL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_I1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UI1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UI2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UI4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_I8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UI8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_INT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UINT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_VOID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_HRESULT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_PTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_SAFEARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_CARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_USERDEFINED();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_LPSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_LPWSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_RECORD();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_FILETIME();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BLOB();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_STREAM();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_STORAGE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_STREAMED_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_STORED_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BLOB_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_CF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_CLSID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_VECTOR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_ARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BYREF();
    internal static Lazy`1<FSharpList`1<Tuple`2<byte, ILNativeType>>> get_ILNativeTypeMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<ILNativeType, byte>>> get_ILNativeTypeRevMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<ILNativeVariant, int>>> get_ILVariantTypeMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<int, ILNativeVariant>>> get_ILVariantTypeRevMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<ILSecurityAction, int>>> get_ILSecurityActionMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<int, ILSecurityAction>>> get_ILSecurityActionRevMap();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_TinyFormat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_FatFormat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_FormatMask();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_MoreSects();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_InitLocals();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_Sect_EHTable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_Sect_FatFormat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_Sect_MoreSects();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_e_COR_ILEXCEPTION_CLAUSE_EXCEPTION();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_e_COR_ILEXCEPTION_CLAUSE_FILTER();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_e_COR_ILEXCEPTION_CLAUSE_FINALLY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_e_COR_ILEXCEPTION_CLAUSE_FAULT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_FASTCALL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_STDCALL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_THISCALL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_CDECL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_VARARG();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_FIELD();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_LOCAL_SIG();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_PROPERTY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_GENERICINST();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_GENERIC();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_INSTANCE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_INSTANCE_EXPLICIT();
}
[SealedAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.AbstractIL.Internal.ByteBuffer : object {
    [DebuggerBrowsableAttribute("0")]
internal Byte[] bbArray@;
    [DebuggerBrowsableAttribute("0")]
internal int bbCurrent@;
    [CompilationMappingAttribute("4", "0")]
internal Byte[] bbArray { get; internal set; }
    [CompilationMappingAttribute("4", "1")]
internal int bbCurrent { get; internal set; }
    internal int Position { get; }
    internal ByteBuffer(Byte[] bbArray, int bbCurrent);
    internal Byte[] get_bbArray();
    internal int get_bbCurrent();
    internal void set_bbArray(Byte[] value);
    internal void set_bbCurrent(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ByteBuffer obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal void Ensure(int newSize);
    internal Byte[] Close();
    internal void EmitIntAsByte(int i);
    internal void EmitByte(byte b);
    internal void EmitIntsAsBytes(Int32[] arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal void FixupInt32(int pos, int value);
    internal void EmitInt32(int n);
    internal void EmitBytes(Byte[] i);
    internal void EmitInt32AsUInt16(int n);
    internal void EmitBoolAsByte(bool b);
    internal void EmitUInt16(ushort x);
    internal void EmitInt64(long x);
    internal int get_Position();
    internal static ByteBuffer Create(int sz);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ByteBuffer obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Internal.Bytes : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int get(Byte[] b, int n);
    internal static Byte[] zeroCreate(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void blit(Byte[] a, int b, Byte[] c, int d, int e);
    internal static Byte[] ofInt32Array(Int32[] arr);
    internal static Byte[] stringAsUtf8NullTerminated(string s);
    internal static Byte[] stringAsUnicodeNullTerminated(string s);
}
[SealedAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.AbstractIL.Internal.ByteStream : object {
    [DebuggerBrowsableAttribute("0")]
internal Byte[] bytes@;
    [DebuggerBrowsableAttribute("0")]
internal int pos@;
    [DebuggerBrowsableAttribute("0")]
internal int max@;
    [CompilationMappingAttribute("4", "0")]
internal Byte[] bytes { get; }
    [CompilationMappingAttribute("4", "1")]
internal int pos { get; internal set; }
    [CompilationMappingAttribute("4", "2")]
internal int max { get; }
    internal int Position { get; }
    internal ByteStream(Byte[] bytes, int pos, int max);
    internal Byte[] get_bytes();
    internal int get_pos();
    internal int get_max();
    internal void set_pos(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ByteStream obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal byte ReadByte();
    internal string ReadUtf8String(int n);
    internal static ByteStream FromBytes(Byte[] b, int start, int length);
    internal Byte[] ReadBytes(int n);
    internal int get_Position();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ByteStream obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.AbstractIL.Internal.Library : object {
    public static int LOH_SIZE_THRESHOLD_BYTES { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<bool, FSharpFunc`2<string, Unit>> reportTime { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<FSharpOption`1<double>> tFirst@54 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<FSharpOption`1<double>> tPrev@55 { get; }
    [CompilationMappingAttribute("9")]
public static CancellableBuilder cancellable { get; }
    [CompilationMappingAttribute("9")]
public static EventuallyBuilder eventually { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int op_GreaterGreaterGreaterAmp(int x, int n);
    public static Lazy`1<a> notlazy(a v);
    public static bool isNil(FSharpList`1<a> l);
    public static bool isNilOrSingleton(FSharpList`1<a> l);
    public static bool isSingleton(FSharpList`1<a> l);
    public static bool isNonNull(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a nonNull(string msg, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_EqualsEqualsEquals(a x, a y);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_LOH_SIZE_THRESHOLD_BYTES();
    public static FSharpFunc`2<bool, FSharpFunc`2<string, Unit>> get_reportTime();
    internal static FSharpRef`1<FSharpOption`1<double>> get_tFirst@54();
    internal static FSharpRef`1<FSharpOption`1<double>> get_tPrev@55();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static d foldOn(FSharpFunc`2<a, b> p, FSharpFunc`2<c, FSharpFunc`2<b, d>> f, c z, a x);
    public static a notFound();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool String.StartsWithOrdinal(string x, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool String.EndsWithOrdinal(string x, string value);
    public static void RequireCompilationThread(CompilationThreadToken _ctok);
    public static void DoesNotRequireCompilerThreadTokenAndCouldPossiblyBeMadeConcurrent(CompilationThreadToken _ctok);
    public static CompilationThreadToken AssumeCompilationThreadWithoutEvidence();
    public static AnyCallerThreadToken AssumeAnyCallerThreadWithoutEvidence();
    public static LockTokenType AssumeLockWithoutEvidence();
    public static a getHole(FSharpRef`1<FSharpOption`1<a>> r);
    public static CancellableBuilder get_cancellable();
    public static EventuallyBuilder get_eventually();
    [CompilerGeneratedAttribute]
internal static U action@1(MemoizationTable`2<T, U> t, T x, Unit unitVar0);
    public static FSharpMap`2<Key, Value> Map`2.get_Empty.Static();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<Value> Map`2.get_Values(FSharpMap`2<Key, Value> );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpMap`2<Key, Value> Map`2.AddAndMarkAsCollapsible(FSharpMap`2<Key, Value> x, KeyValuePair`2[] kvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpMap`2<Key, Value> Map`2.LinearTryModifyThenLaterFlatten(FSharpMap`2<Key, Value> x, Key key, FSharpFunc`2<FSharpOption`1<Value>, Value> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpMap`2<Key, Value> Map`2.MarkAsCollapsible(FSharpMap`2<Key, Value> );
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Internal.Support : object {
    [CompilationMappingAttribute("9")]
internal static DateTime DateTime1970Jan01 { get; }
    internal static int MAX_PATH { get; }
    internal static int E_FAIL { get; }
    [CompilationMappingAttribute("9")]
internal static Guid guidSourceHashMD5 { get; }
    internal static int hashSizeOfMD5 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<ICLRStrongName> iclrsn { get; internal set; }
    internal static DateTime get_DateTime1970Jan01();
    internal static int absilWriteGetTimeStamp();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void check(a _action, int hresult);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_MAX_PATH();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_E_FAIL();
    internal static short bytesToWord(byte b0, byte b1);
    internal static int bytesToDWord(byte b0, byte b1, byte b2, byte b3);
    internal static long bytesToQWord(byte b0, byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7);
    internal static Tuple`2<Byte[], int> dwToBytes(int n);
    internal static Tuple`2<Byte[], int> wToBytes(short n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_FILE_HEADER bytesToIFH(Byte[] buffer, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_SECTION_HEADER bytesToISH(Byte[] buffer, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_SYMBOL bytesToIS(Byte[] buffer, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_RELOCATION bytesToIR(Byte[] buffer, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_RESOURCE_DIRECTORY bytesToIRD(Byte[] buffer, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_RESOURCE_DIRECTORY_ENTRY bytesToIRDE(Byte[] buffer, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_RESOURCE_DATA_ENTRY bytesToIRDataE(Byte[] buffer, int offset);
    internal static void SaveChunk@527(Byte[] pUnlinkedResource, int offset, FSharpRef`1<int> size, FSharpRef`1<int> unlinkedResourceOffset, Byte[] tupledArg0, int tupledArg1);
    internal static string GetUniqueRandomFileName@600(string path);
    internal static Tuple`3<string, string, FSharpList`1<string>> createCvtresArgs@613(FSharpList`1<Byte[]> unlinkedResources, string cmdLineArgsPreamble, string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] linkNativeResources(FSharpList`1<Byte[]> unlinkedResources, int rva, PEFileType fileType, string tempFilePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] unlinkResource(int ulLinkedResourceBaseRVA, Byte[] pbLinkedResource);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@999-19(idd this, idd obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@999-20(IComparer comp, idd this, idd objTemp, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PdbWriter pdbInitialize(string binaryName, string pdbName);
    internal static void pdbCloseDocument(PdbDocumentWriter documentWriter);
    internal static bool isLocked@1053(string filename);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pdbClose(PdbWriter writer, string dllFilename, string pdbFilename);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pdbSetUserEntryPoint(PdbWriter writer, int entryMethodToken);
    internal static Guid get_guidSourceHashMD5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_hashSizeOfMD5();
    internal static void setCheckSum(string url, ISymUnmanagedDocumentWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PdbDocumentWriter pdbDefineDocument(PdbWriter writer, string url);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pdbOpenMethod(PdbWriter writer, int methodToken);
    internal static void pdbCloseMethod(PdbWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pdbOpenScope(PdbWriter writer, int startOffset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pdbCloseScope(PdbWriter writer, int endOffset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pdbDefineLocalVariable(PdbWriter writer, string name, Byte[] signature, int addr1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pdbSetMethodRange(PdbWriter writer, PdbDocumentWriter docWriter1, int startLine, int startCol, PdbDocumentWriter docWriter2, int endLine, int endCol);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pdbDefineSequencePoints(PdbWriter writer, PdbDocumentWriter docWriter, Tuple`5[] pts);
    internal static idd pdbWriteDebugInfo(PdbWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PdbReader pdbReadOpen(string moduleName, string path);
    internal static void pdbReadClose(PdbReader _reader);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PdbMethod pdbReaderGetMethod(PdbReader reader, int token);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PdbMethod pdbReaderGetMethodFromDocumentPosition(PdbReader reader, PdbDocument document, int line, int column);
    internal static PdbDocument[] pdbReaderGetDocuments(PdbReader reader);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PdbDocument pdbReaderGetDocument(PdbReader reader, string url, Byte[] language, Byte[] languageVendor, Byte[] documentType);
    internal static string pdbDocumentGetURL(PdbDocument document);
    internal static Byte[] pdbDocumentGetType(PdbDocument document);
    internal static Byte[] pdbDocumentGetLanguage(PdbDocument document);
    internal static Byte[] pdbDocumentGetLanguageVendor(PdbDocument document);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int pdbDocumentFindClosestLine(PdbDocument document, int line);
    internal static int pdbMethodGetToken(PdbMethod meth);
    [CompilerGeneratedAttribute]
internal static PdbSequencePoint initializer@1-1(Int32[] offsets, ISymbolDocument[] docs, Int32[] lines, Int32[] cols, Int32[] endLines, Int32[] endColumns, int i);
    internal static PdbSequencePoint[] pdbMethodGetSequencePoints(PdbMethod meth);
    internal static PdbMethodScope[] pdbScopeGetChildren(PdbMethodScope scope);
    internal static Tuple`2<int, int> pdbScopeGetOffsets(PdbMethodScope scope);
    internal static PdbVariable[] pdbScopeGetLocals(PdbMethodScope scope);
    internal static string pdbVariableGetName(PdbVariable variable);
    internal static Byte[] pdbVariableGetSignature(PdbVariable variable);
    internal static Tuple`2<int, int> pdbVariableGetAddressAttributes(PdbVariable variable);
    [SecurityCriticalAttribute]
internal static void CreateInterface(Guid _clsidguid, Guid _guid, ICLRMetaHost& _metaHost);
    internal static Byte[] signerOpenPublicKeyFile(string filePath);
    internal static Byte[] signerOpenKeyPairFile(string filePath);
    internal static FSharpOption`1<ICLRStrongName> get_iclrsn();
    internal static void set_iclrsn(FSharpOption`1<ICLRStrongName> value);
    internal static ICLRStrongName getICLRStrongName();
    internal static Byte[] signerGetPublicKeyForKeyPair(Byte[] kp);
    internal static Byte[] signerGetPublicKeyForKeyContainer(string kc);
    internal static void signerCloseKeyContainer(string kc);
    internal static int signerSignatureSize(Byte[] pk);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void signerSignFileWithKeyPair(string fileName, Byte[] kp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void signerSignFileWithKeyContainer(string fileName, string kcName);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Internal.ZmapModule : object {
    internal static Map`3<Key, T, IComparer`1<Key>> empty(IComparer`1<Key> ord);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, T, IComparer`1<Key>> add(Key k, T v, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T find(Key k, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<T> tryFind(Key k, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, T, IComparer`1<Key>> remove(Key k, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool mem(Key k, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<T, FSharpFunc`2<U, Unit>> action, Map`3<T, U, IComparer`1<T>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Key, T>> first(FSharpFunc`2<Key, FSharpFunc`2<T, bool>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<Key, FSharpFunc`2<T, bool>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<Key, FSharpFunc`2<T, bool>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, U, IComparer`1<Key>> map(FSharpFunc`2<T, U> mapping, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, U, IComparer`1<Key>> mapi(FSharpFunc`2<Key, FSharpFunc`2<T, U>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static U fold(FSharpFunc`2<Key, FSharpFunc`2<T, FSharpFunc`2<U, U>>> f, Map`3<Key, T, IComparer`1<Key>> m, U x);
    internal static FSharpList`1<Tuple`2<Key, T>> toList(Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static U foldSection(Key lo, Key hi, FSharpFunc`2<Key, FSharpFunc`2<T, FSharpFunc`2<U, U>>> f, Map`3<Key, T, IComparer`1<Key>> m, U x);
    internal static bool isEmpty(Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<State, Map`3<Key, U, IComparer`1<Key>>> foldMap(FSharpFunc`2<State, FSharpFunc`2<Key, FSharpFunc`2<T, Tuple`2<State, U>>>> f, State z, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<U> choose(FSharpFunc`2<Key, FSharpFunc`2<T, FSharpOption`1<U>>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<U> chooseL(FSharpFunc`2<Key, FSharpFunc`2<T, FSharpOption`1<U>>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, T, IComparer`1<Key>> ofList(IComparer`1<Key> ord, FSharpList`1<Tuple`2<Key, T>> xs);
    internal static FSharpList`1<Key> keys(Map`3<Key, T, IComparer`1<Key>> m);
    internal static FSharpList`1<T> values(Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool memberOf(Map`3<Key, T, IComparer`1<Key>> m, Key k);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Internal.ZsetModule : object {
    internal static Set`2<T, IComparer`1<T>> empty(IComparer`1<T> ord);
    internal static bool isEmpty(Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool contains(T x, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> add(T x, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> addList(FSharpList`1<T> xs, Set`2<T, IComparer`1<T>> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> singleton(IComparer`1<T> ord, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> remove(T x, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static State fold(FSharpFunc`2<T, FSharpFunc`2<State, State>> f, Set`2<T, IComparer`1<T>> s, State b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<T, Unit> f, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<T, bool> predicate, Set`2<T, IComparer`1<T>> s);
    internal static int count(Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<T, bool> predicate, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool subset(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equal(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    internal static FSharpList`1<T> elements(Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> filter(FSharpFunc`2<T, bool> predicate, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> union(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> inter(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> diff(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool memberOf(Set`2<T, IComparer`1<T>> m, T k);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Morphs : object {
    [CompilationMappingAttribute("9")]
internal static bool morphCustomAttributeData { get; internal set; }
    internal static bool get_morphCustomAttributeData();
    internal static void set_morphCustomAttributeData(bool value);
    internal static void enableMorphCustomAttributeData();
    internal static void disableMorphCustomAttributeData();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode code_instr2instr(FSharpFunc`2<ILInstr, ILInstr> f, ILCode code);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode code_instr2instrs(FSharpFunc`2<ILInstr, FSharpList`1<ILInstr>> f, ILCode code);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode code_instr2instr_ty2ty(FSharpFunc`2<ILInstr, ILInstr> finstr, FSharpFunc`2<ILType, ILType> fty, ILCode c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType ty_tref2tref(FSharpFunc`2<ILTypeRef, ILTypeRef> f, ILType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeSpec tspec_tref2tref(FSharpFunc`2<ILTypeRef, ILTypeRef> f, ILTypeSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType ty_scoref2scoref_tyvar2ty(FSharpFunc`2<ILScopeRef, ILScopeRef> _arg1_0, FSharpFunc`2<ushort, ILType> _arg1_1, ILType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeSpec tspec_scoref2scoref_tyvar2ty(FSharpFunc`2<ILScopeRef, ILScopeRef> fs_0, FSharpFunc`2<ushort, ILType> fs_1, ILTypeSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCallingSignature callsig_scoref2scoref_tyvar2ty(FSharpFunc`2<ILScopeRef, ILScopeRef> f_0, FSharpFunc`2<ushort, ILType> f_1, ILCallingSignature x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> tys_scoref2scoref_tyvar2ty(FSharpFunc`2<ILScopeRef, ILScopeRef> f_0, FSharpFunc`2<ushort, ILType> f_1, FSharpList`1<ILType> i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef morphILScopeRefsInILTypeRef(FSharpFunc`2<ILScopeRef, ILScopeRef> fscope, ILTypeRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCallingSignature callsig_ty2ty(FSharpFunc`2<ILType, ILType> f, ILCallingSignature x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILGenericParameterDef gparam_ty2ty(FSharpFunc`2<ILType, ILType> f, ILGenericParameterDef gf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodRef mref_ty2ty(FSharpFunc`2<ILType, ILType> f, ILMethodRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodSpec mspec_ty2ty(FSharpFunc`2<ILType, ILType> _arg1_0, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>> _arg1_1, ILMethodSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldRef fref_ty2ty(FSharpFunc`2<ILType, ILType> f, ILFieldRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec fspec_ty2ty(FSharpFunc`2<ILType, ILType> _arg1_0, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>> _arg1_1, ILFieldSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribElem celem_ty2ty(FSharpFunc`2<ILType, ILType> f, ILAttribElem celem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute cattr_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> f, ILAttribute c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldDef fdef_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> ftye, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILLocal local_ty2ty(FSharpFunc`2<ILType, ILType> f, ILLocal l);
    internal static ILFieldSpec conv_fspec@166(ILInstr i, FSharpFunc`2<ILType, ILType> factualty, FSharpFunc`2<FSharpOption`1<ILInstr>, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>>> _arg1_1, ILFieldSpec fr);
    internal static ILMethodSpec conv_mspec@167(ILInstr i, FSharpFunc`2<ILType, ILType> factualty, FSharpFunc`2<FSharpOption`1<ILInstr>, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>>> _arg1_1, ILMethodSpec mr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr morphILTypesInILInstr(FSharpFunc`2<FSharpOption`1<ILInstr>, FSharpFunc`2<ILType, ILType>> _arg1_0, FSharpFunc`2<FSharpOption`1<ILInstr>, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>>> _arg1_1, ILInstr i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILReturn return_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> f, ILReturn r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILParameter param_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> f, ILParameter p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDefs morphILMethodDefs(FSharpFunc`2<ILMethodDef, ILMethodDef> f, ILMethodDefs m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefs morphILTypeDefs(FSharpFunc`2<ILTypeDef, ILTypeDef> f, ILTypeDefs m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodBody ilmbody_instr2instr_ty2ty(FSharpFunc`2<ILInstr, ILInstr> fs_0, FSharpFunc`2<ILType, ILType> fs_1, ILMethodBody il);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILLazyMethodBody morphILMethodBody(FSharpFunc`2<ILMethodBody, ILMethodBody> filmbody, ILLazyMethodBody x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILOverridesSpec ospec_ty2ty(FSharpFunc`2<ILType, ILType> f, ILOverridesSpec _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef mdef_ty2ty_ilmbody2ilmbody(ILGlobals ilg, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>> fs_0, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILMethodBody, ILMethodBody>> fs_1, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldDefs fdefs_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> f, ILFieldDefs x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDefs mdefs_ty2ty_ilmbody2ilmbody(ILGlobals ilg, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>> fs_0, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILMethodBody, ILMethodBody>> fs_1, ILMethodDefs x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodImplDef mimpl_ty2ty(FSharpFunc`2<ILType, ILType> f, ILMethodImplDef e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDef edef_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> f, ILEventDef e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDef pdef_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> f, ILPropertyDef p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDefs pdefs_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> f, ILPropertyDefs pdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDefs edefs_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> f, ILEventDefs edefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef tdef_ty2ty_ilmbody2ilmbody_mdefs2mdefs(ILGlobals ilg, FSharpList`1<ILTypeDef> enc, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<ILType, ILType>>> fs_0, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<ILMethodDefs, ILMethodDefs>> fs_1, ILTypeDef td);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefs tdefs_ty2ty_ilmbody2ilmbody_mdefs2mdefs(ILGlobals ilg, FSharpList`1<ILTypeDef> enc, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<ILType, ILType>>> fs_0, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<ILMethodDefs, ILMethodDefs>> fs_1, ILTypeDefs tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAssemblyManifest manifest_ty2ty(ILGlobals ilg, FSharpFunc`2<ILType, ILType> f, ILAssemblyManifest m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef morphILTypeInILModule_ilmbody2ilmbody_mdefs2mdefs(ILGlobals ilg, FSharpFunc`2<ILModuleDef, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>>>> ftye, FSharpFunc`2<ILModuleDef, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<ILMethodDefs, ILMethodDefs>>> fmdefs, ILModuleDef m);
    internal static FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILMethodBody, ILMethodBody>> filmbody@302(FSharpFunc`2<ILModuleDef, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILInstr, ILInstr>>>> fs_0, FSharpFunc`2<ILModuleDef, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>>>> fs_1, ILModuleDef modCtxt, Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef> tdefCtxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef module_instr2instr_ty2ty(ILGlobals ilg, FSharpFunc`2<ILModuleDef, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILInstr, ILInstr>>>> fs_0, FSharpFunc`2<ILModuleDef, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>>>> fs_1, ILModuleDef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode morphILInstrsInILCode(FSharpFunc`2<ILInstr, FSharpList`1<ILInstr>> f, ILCode x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef morphILTypeInILModule(ILGlobals ilg, FSharpFunc`2<ILModuleDef, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>>>> ftye, ILModuleDef y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef morphILTypeRefsInILModuleMemoized(ILGlobals ilg, FSharpFunc`2<ILTypeRef, ILTypeRef> f, ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef morphILScopeRefsInILModuleMemoized(ILGlobals ilg, FSharpFunc`2<ILScopeRef, ILScopeRef> f, ILModuleDef modul);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AccessibilityLogic : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsAccessible(AccessorDomain ad, Accessibility taccess);
    [CompilerGeneratedAttribute]
internal static bool IsILMemberAccessible$cont@78(TcGlobals g, ImportMap amap, range m, EntityRef tcrefOfViewedItem, AccessorDomain ad, ILMemberAccess access, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILMemberAccessible(TcGlobals g, ImportMap amap, range m, EntityRef tcrefOfViewedItem, AccessorDomain ad, ILMemberAccess access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILTypeDefAccessible(ImportMap amap, range m, AccessorDomain ad, FSharpOption`1<EntityRef> encTyconRefOpt, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTyconAccessibleViaVisibleTo(AccessorDomain ad, EntityRef tcrefOfViewedItem);
    internal static bool check@132-3(ImportMap amap, range m, AccessorDomain ad, EntityRef tcrefOfViewedItem, ILScopeRef scoref, FSharpOption`1<Tuple`2<EntityRef, FSharpList`1<ILTypeDef>>> parentTycon, FSharpList`1<ILTypeDef> path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILTypeInfoAccessible(ImportMap amap, range m, AccessorDomain ad, EntityRef tcrefOfViewedItem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILTypeAndMemberAccessible(TcGlobals g, ImportMap amap, range m, AccessorDomain adType, AccessorDomain ad, ILTypeInfo ty, ILMemberAccess access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsEntityAccessible(ImportMap amap, range m, AccessorDomain ad, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckTyconAccessible(ImportMap amap, range m, AccessorDomain ad, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTyconReprAccessible(ImportMap amap, range m, AccessorDomain ad, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckTyconReprAccessible(ImportMap amap, range m, AccessorDomain ad, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTypeAccessible(TcGlobals g, ImportMap amap, range m, AccessorDomain ad, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTypeInstAccessible(TcGlobals g, ImportMap amap, range m, AccessorDomain ad, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsProvidedMemberAccessible(ImportMap amap, range m, AccessorDomain ad, TType ty, ILMemberAccess access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMemberAccess ComputeILAccess(bool isPublic, bool isFamily, bool isFamilyOrAssembly, bool isFamilyAndAssembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILFieldInfoAccessible(TcGlobals g, ImportMap amap, range m, AccessorDomain ad, ILFieldInfo x);
    internal static ILMemberAccess GetILAccessOfILEventInfo(ILEventInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILEventInfoAccessible(TcGlobals g, ImportMap amap, range m, AccessorDomain ad, ILEventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILMethInfoAccessible(TcGlobals g, ImportMap amap, range m, AccessorDomain adType, AccessorDomain ad, ILMethInfo ilminfo);
    internal static ILMemberAccess GetILAccessOfILPropInfo(ILPropInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILPropInfoAccessible(TcGlobals g, ImportMap amap, range m, AccessorDomain ad, ILPropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsValAccessible(AccessorDomain ad, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValAccessible(range m, AccessorDomain ad, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsUnionCaseAccessible(ImportMap amap, range m, AccessorDomain ad, UnionCaseRef ucref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckUnionCaseAccessible(ImportMap amap, range m, AccessorDomain ad, UnionCaseRef ucref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsRecdFieldAccessible(ImportMap amap, range m, AccessorDomain ad, RecdFieldRef rfref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckRecdFieldAccessible(ImportMap amap, range m, AccessorDomain ad, RecdFieldRef rfref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckRecdFieldInfoAccessible(ImportMap amap, range m, AccessorDomain ad, RecdFieldInfo rfinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckILFieldInfoAccessible(TcGlobals g, ImportMap amap, range m, AccessorDomain ad, ILFieldInfo finfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTypeAndMethInfoAccessible(ImportMap amap, range m, AccessorDomain accessDomainTy, AccessorDomain ad, MethInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsMethInfoAccessible(ImportMap amap, range m, AccessorDomain ad, MethInfo minfo);
    internal static FSharpOption`1<ILMemberAccess> tryGetILAccessForProvidedMethodBase@330(ProvidedMethodBase mi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsPropInfoAccessible(TcGlobals g, ImportMap amap, range m, AccessorDomain ad, PropInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsFieldInfoAccessible(AccessorDomain ad, RecdFieldInfo rfref);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Ast : object {
    public static string FsiDynamicModulePrefix { get; }
    [CompilationMappingAttribute("9")]
public static string opNameParenGet { get; }
    [CompilationMappingAttribute("9")]
public static string opNameQMark { get; }
    [CompilationMappingAttribute("9")]
public static MemberFlags CtorMemberFlags { get; }
    [CompilationMappingAttribute("9")]
public static MemberFlags ClassCtorMemberFlags { get; }
    [CompilationMappingAttribute("9")]
public static SynValTyparDecls inferredTyparDecls { get; }
    [CompilationMappingAttribute("9")]
public static SynValTyparDecls noInferredTypars { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_FsiDynamicModulePrefix();
    internal static FSharpList`1<string> processLines@101(FSharpList`1<string> lines);
    public static Ident ident(string s, range r);
    public static string textOfId(Ident id);
    public static FSharpList`1<string> pathOfLid(FSharpList`1<Ident> lid);
    public static String[] arrPathOfLid(FSharpList`1<Ident> lid);
    public static string textOfPath(IEnumerable`1<string> path);
    public static string textOfLid(FSharpList`1<Ident> lid);
    public static range rangeOfLid(FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Ident mkSynId(range m, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<Ident> pathToSynLid(range m, FSharpList`1<string> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynIdGet(range m, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynLidGet(range m, FSharpList`1<string> path, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynIdGetWithAlt(range m, Ident id, FSharpOption`1<FSharpRef`1<SynSimplePatAlternativeIdInfo>> altInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynSimplePat mkSynSimplePatVar(bool isOpt, Ident id);
    public static SynSimplePat mkSynCompGenSimplePatVar(Ident id);
    public static FSharpOption`1<Tuple`4<bool, LongIdentWithDots, FSharpOption`1<FSharpRef`1<SynSimplePatAlternativeIdInfo>>, range>> |LongOrSingleIdent|_|(SynExpr inp);
    public static FSharpOption`1<Ident> |SingleIdent|_|(SynExpr inp);
    public static bool IsControlFlowExpression(SynExpr e);
    public static SynField mkAnonField(SynType ty);
    public static SynField mkNamedField(Ident ident, SynType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynPat mkSynPatVar(FSharpOption`1<SynAccess> vis, Ident id);
    public static SynPat mkSynThisPatVar(Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynPat mkSynPatMaybeVar(LongIdentWithDots lidwd, FSharpOption`1<SynAccess> vis, range m);
    public static FSharpOption`1<SynPat> |SynPatForConstructorDecl|_|(SynPat x);
    public static FSharpOption`1<Unit> |SynPatForNullaryArgs|_|(SynPat x);
    public static SynExpr |SynExprErrorSkip|(SynExpr p);
    public static FSharpOption`1<Tuple`4<SynExpr, range, FSharpOption`1<range>, range>> |SynExprParen|_|(SynExpr e);
    public static SynPat |SynPatErrorSkip|(SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<SynSimplePat, FSharpOption`1<FSharpFunc`2<SynExpr, SynExpr>>> SimplePatOfPat(SynArgNameGenerator synArgNameGenerator, SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a appFunOpt(FSharpOption`1<FSharpFunc`2<a, a>> funOpt, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<FSharpFunc`2<a, a>> composeFunOpt(FSharpOption`1<FSharpFunc`2<a, a>> funOpt1, FSharpOption`1<FSharpFunc`2<a, a>> funOpt2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<SynSimplePats, FSharpOption`1<FSharpFunc`2<SynExpr, SynExpr>>> SimplePatsOfPat(SynArgNameGenerator synArgNameGenerator, SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<SynSimplePats, SynExpr> PushPatternToExpr(SynArgNameGenerator synArgNameGenerator, bool isMember, SynPat pat, SynExpr rhs);
    internal static bool isSimplePattern(SynPat pat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FSharpList`1<SynSimplePats>, SynExpr> PushCurriedPatternsToExpr(SynArgNameGenerator synArgNameGenerator, range wholem, bool isMember, FSharpList`1<SynPat> pats, SynExpr rhs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILInstr[] ParseAssemblyCodeInstructions(string s, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILType ParseAssemblyCodeType(string s, range m);
    public static string get_opNameParenGet();
    public static string get_opNameQMark();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynOperator(range opm, string oper);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynInfix(range opm, SynExpr l, string oper, SynExpr r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynBifix(range m, string oper, SynExpr x1, SynExpr x2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynTrifix(range m, string oper, SynExpr x1, SynExpr x2, SynExpr x3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynPrefixPrim(range opm, range m, string oper, SynExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynPrefix(range opm, range m, string oper, SynExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<Ident> mkSynCaseName(range m, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynApp1(SynExpr f, SynExpr x1, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynApp2(SynExpr f, SynExpr x1, SynExpr x2, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynApp3(SynExpr f, SynExpr x1, SynExpr x2, SynExpr x3, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynApp4(SynExpr f, SynExpr x1, SynExpr x2, SynExpr x3, SynExpr x4, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynApp5(SynExpr f, SynExpr x1, SynExpr x2, SynExpr x3, SynExpr x4, SynExpr x5, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynDotParenSet(range m, SynExpr a, SynExpr b, SynExpr c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynDotBrackGet(range m, range mDot, SynExpr a, SynExpr b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynQMarkSet(range m, SynExpr a, SynExpr b, SynExpr c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynDotBrackSliceGet(range m, range mDot, SynExpr arr, SynIndexerArg sliceArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynDotBrackSeqSliceGet(range m, range mDot, SynExpr arr, FSharpList`1<SynIndexerArg> argslist);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynDotParenGet(range lhsm, range dotm, SynExpr a, SynExpr b);
    public static SynExpr mkSynUnit(range m);
    public static SynPat mkSynUnitPat(range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynDelay(range m, SynExpr e);
    [CompilerGeneratedAttribute]
internal static SynExpr mkSynAssign$cont@2069-1(SynExpr l, SynExpr r, range m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static SynExpr mkSynAssign$cont@2069(SynExpr l, SynExpr r, range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynAssign(SynExpr l, SynExpr r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynDot(range dotm, range m, SynExpr l, Ident r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynDotMissing(range dotm, range m, SynExpr l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynExpr mkSynFunMatchLambdas(SynArgNameGenerator synArgNameGenerator, bool isMember, range wholem, FSharpList`1<SynPat> ps, SynExpr e);
    public static SynExpr arbExpr(string debugStr, range range);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<SynAttributeList> mkAttributeList(FSharpList`1<SynAttribute> attrs, range range);
    public static FSharpList`1<SynAttribute> ConcatAttributesLists(FSharpList`1<SynAttributeList> attrsLists);
    public static FSharpList`1<SynAttribute> |Attributes|(FSharpList`1<SynAttributeList> synAttributes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<SynExpr, FSharpOption`1<SynBindingReturnInfo>> mkSynBindingRhs(FSharpList`1<Tuple`2<FSharpList`1<SynStaticOptimizationConstraint>, SynExpr>> staticOptimizations, SynExpr rhsExpr, range mRhs, FSharpOption`1<SynReturnInfo> retInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static SynBinding mkSynBinding(PreXmlDoc xmlDoc, SynPat headPat, FSharpOption`1<SynAccess> vis, bool isInline, bool isMutable, range mBind, SequencePointInfoForBinding spBind, FSharpOption`1<SynReturnInfo> retInfo, SynExpr origRhsExpr, range mRhs, FSharpList`1<Tuple`2<FSharpList`1<SynStaticOptimizationConstraint>, SynExpr>> staticOptimizations, FSharpList`1<SynAttributeList> attrs, FSharpOption`1<MemberFlags> memberFlagsOpt);
    public static MemberFlags NonVirtualMemberFlags(MemberKind k);
    public static MemberFlags get_CtorMemberFlags();
    public static MemberFlags get_ClassCtorMemberFlags();
    public static MemberFlags OverrideMemberFlags(MemberKind k);
    public static MemberFlags AbstractMemberFlags(MemberKind k);
    public static MemberFlags StaticMemberFlags(MemberKind k);
    public static SynValTyparDecls get_inferredTyparDecls();
    public static SynValTyparDecls get_noInferredTypars();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2341-37(LexerIfdefExpression this, LexerIfdefExpression obj, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool LexerIfdefEval(FSharpFunc`2<string, bool> lookup, LexerIfdefExpression _arg1);
    internal static pos posOfLexPosition(Position p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range mkSynRange(Position p1, Position p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range LexBuffer`1.get_LexemeRange(LexBuffer`1<Char> );
    internal static range lhs(IParseState parseState);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range rhs2(IParseState parseState, int i, int j);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range rhs(IParseState parseState, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynArgNameGenerator IParseState.get_SynArgNameGenerator(IParseState );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IParseState.ResetSynArgNameGenerator(IParseState );
    internal static bool walkMatchClauses@2481(FSharpFunc`2<SynBinding, bool> walkBind, FSharpList`1<SynMatchClause> cl);
    internal static bool walkExprOpt@2482(FSharpFunc`2<SynBinding, bool> walkBind, FSharpOption`1<SynExpr> eOpt);
    internal static bool walkExpr@2483(FSharpFunc`2<SynBinding, bool> walkBind, SynExpr e);
    public static bool synExprContainsError(SynExpr inpExpr);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AttributeChecking : object {
    internal static a fail();
    internal static object evalILAttribElem(ILAttribElem e);
    [CompilerGeneratedAttribute]
internal static object evalFSharpAttribArg$cont@56(Const c, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object evalFSharpAttribArg(TcGlobals g, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> AttribInfosOfIL(TcGlobals g, ImportMap amap, ILScopeRef scoref, range m, ILAttributes attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> AttribInfosOfFS(TcGlobals g, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> GetAttribInfosOfEntity(TcGlobals g, ImportMap amap, range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> GetAttribInfosOfMethod(ImportMap amap, range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> GetAttribInfosOfProp(ImportMap amap, range m, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> GetAttribInfosOfEvent(ImportMap amap, range m, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> TryBindTyconRefAttribute(TcGlobals g, range m, BuiltinAttribInfo _arg1, EntityRef tcref, FSharpFunc`2<Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>>, FSharpOption`1<a>> f1, FSharpFunc`2<Attrib, FSharpOption`1<a>> f2, FSharpFunc`2<Tuple`2<FSharpList`1<FSharpOption`1<object>>, FSharpList`1<Tuple`2<string, FSharpOption`1<object>>>>, FSharpOption`1<a>> f3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a BindMethInfoAttributes(range m, MethInfo minfo, FSharpFunc`2<ILAttributes, a> f1, FSharpFunc`2<FSharpList`1<Attrib>, a> f2, FSharpFunc`2<Tainted`1<IProvidedCustomAttributeProvider>, a> f3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> TryBindMethInfoAttribute(TcGlobals g, range m, BuiltinAttribInfo _arg1, MethInfo minfo, FSharpFunc`2<Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>>, FSharpOption`1<a>> f1, FSharpFunc`2<Attrib, FSharpOption`1<a>> f2, FSharpFunc`2<Tuple`2<FSharpList`1<FSharpOption`1<object>>, FSharpList`1<Tuple`2<string, FSharpOption`1<object>>>>, FSharpOption`1<a>> f3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindMethInfoStringAttribute(TcGlobals g, range m, BuiltinAttribInfo attribSpec, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethInfoHasAttribute(TcGlobals g, range m, BuiltinAttribInfo attribSpec, MethInfo minfo);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> CheckILAttributes$cont@253(bool isByrefLikeTyconRef, range m, FSharpOption`1<Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>>> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckILAttributes(TcGlobals g, bool isByrefLikeTyconRef, ILAttributes cattrs, range m);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> CheckFSharpAttributes$cont@273(TcGlobals g, FSharpList`1<Attrib> attribs, range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckFSharpAttributes(TcGlobals g, FSharpList`1<Attrib> attribs, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckProvidedAttributes(TcGlobals g, range m, Tainted`1<IProvidedCustomAttributeProvider> provAttribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckILAttributesForUnseen(TcGlobals g, ILAttributes cattrs, a _m);
    [CompilerGeneratedAttribute]
internal static bool CheckFSharpAttributesForHidden$cont@344(TcGlobals g, FSharpList`1<Attrib> attribs, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckFSharpAttributesForHidden(TcGlobals g, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckFSharpAttributesForObsolete(TcGlobals g, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckFSharpAttributesForUnseen(TcGlobals g, FSharpList`1<Attrib> attribs, a _m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckProvidedAttributesForUnseen(Tainted`1<IProvidedCustomAttributeProvider> provAttribs, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckPropInfoAttributes(PropInfo pinfo, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckILFieldAttributes(TcGlobals g, ILFieldInfo finfo, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckMethInfoAttributes(TcGlobals g, range m, FSharpOption`1<a> tyargsOpt, MethInfo minfo);
    internal static bool isUnseenByObsoleteAttrib@423(TcGlobals g, range m, MethInfo minfo, Unit unitVar0);
    internal static bool isUnseenByHidingAttribute@436(TcGlobals g, range m, TType ty, MethInfo minfo, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethInfoIsUnseen(TcGlobals g, range m, TType ty, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PropInfoIsUnseen(a m, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckEntityAttributes(TcGlobals g, EntityRef x, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckUnionCaseAttributes(TcGlobals g, UnionCaseRef x, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckRecdFieldAttributes(TcGlobals g, RecdFieldRef x, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckValAttributes(TcGlobals g, ValRef x, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckRecdFieldInfoAttributes(TcGlobals g, RecdFieldInfo x, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsSecurityAttribute(TcGlobals g, ImportMap amap, Dictionary`2<long, bool> casmap, Attrib _arg1, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsSecurityCriticalAttribute(TcGlobals g, Attrib _arg1);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AugmentWithHashCompare : object {
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<FSharpList`1<ArgReprInfo>> unitArg { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<FSharpList`1<ArgReprInfo>> unaryArg { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<FSharpList`1<ArgReprInfo>> tupArg { get; }
    internal static SlotSig mkIComparableCompareToSlotSig(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig mkGenericIComparableCompareToSlotSig(TcGlobals g, TType ty);
    internal static SlotSig mkIStructuralComparableCompareToSlotSig(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig mkGenericIEquatableEqualsSlotSig(TcGlobals g, TType ty);
    internal static SlotSig mkIStructuralEquatableEqualsSlotSig(TcGlobals g);
    internal static SlotSig mkIStructuralEquatableGetHashCodeSlotSig(TcGlobals g);
    internal static SlotSig mkGetHashCodeSlotSig(TcGlobals g);
    internal static SlotSig mkEqualsSlotSig(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkThisTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkCompareObjTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkCompareTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkCompareWithComparerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkEqualsObjTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkEqualsTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkEqualsWithComparerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkHashTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkHashWithComparerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRelBinOp(TcGlobals g, ILInstr op, range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkILCallGetComparer(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkILCallGetEqualityComparer(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkShl(TcGlobals g, range m, Expr acce, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkShr(TcGlobals g, range m, Expr acce, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAdd(TcGlobals g, range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAddToHashAcc(TcGlobals g, range m, Expr e, ValRef accv, Expr acce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCombineHashGenerators(TcGlobals g, range m, FSharpList`1<Expr> exprs, ValRef accv, Expr acce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<Val>, Expr> mkThatAddrLocalIfNeeded(TcGlobals g, range m, Expr tcve, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<Val, Val, Expr, Expr> mkThisVarThatVar(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkThatVarBind(TcGlobals g, range m, TType ty, Val thataddrv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindThatAddr(TcGlobals g, range m, TType ty, Val thataddrv, Val thatv, Expr thate, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindThatAddrIfNeeded(range m, FSharpOption`1<Val> thataddrvOpt, Val thatv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCompareTestConjuncts(TcGlobals g, range m, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkEqualsTestConjuncts(TcGlobals g, range m, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, TType> mkMinimalTy(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindNullComparison(TcGlobals g, range m, Expr thise, Expr thate, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindThisNullEquals(TcGlobals g, range m, Expr thise, Expr thate, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindThatNullEquals(TcGlobals g, range m, Expr thise, Expr thate, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindNullHash(TcGlobals g, range m, Expr thise, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkRecdCompare(TcGlobals g, EntityRef tcref, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRecdCompareWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, a _thisv, Expr thise, b _arg1, Expr thate, Expr compe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkRecdEquality(TcGlobals g, EntityRef tcref, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRecdEqualityWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, a _thisv, Expr thise, Expr thatobje, Val thatv, Expr thate, Expr compe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkExnEquality(TcGlobals g, EntityRef exnref, Entity exnc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkExnEqualityWithComparer(TcGlobals g, EntityRef exnref, Entity exnc, a _thisv, Expr thise, Expr thatobje, Val thatv, Expr thate, Expr compe);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkTest@357-6(TcGlobals g, FSharpList`1<TType> tinst, Expr compe, UnionCaseRef cref, range m, Expr thise, Expr thataddre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkUnionCompare(TcGlobals g, EntityRef tcref, Entity tycon);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkTest@416-8(TcGlobals g, Expr compe, FSharpList`1<TType> tinst, UnionCaseRef cref, range m, Expr thise, Expr thataddre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnionCompareWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, a _thisv, Expr thise, b _thatobjv, Expr thatcaste, Expr compe);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkTest@477-10(TcGlobals g, FSharpList`1<TType> tinst, UnionCaseRef cref, range m, Expr thise, Expr thataddre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkUnionEquality(TcGlobals g, EntityRef tcref, Entity tycon);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkTest@537-12(TcGlobals g, Expr compe, FSharpList`1<TType> tinst, UnionCaseRef cref, range m, Expr thise, Expr thataddre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnionEqualityWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, a _thisv, Expr thise, Expr thatobje, Val thatv, Expr thate, Expr compe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkRecdHashWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, Expr compe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkExnHashWithComparer(TcGlobals g, EntityRef exnref, Entity exnc, Expr compe);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkHash@636-1(TcGlobals g, Expr compe, FSharpList`1<TType> tinst, UnionCaseRef c1ref, range m, Expr thise);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkUnionHashWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, Expr compe);
    internal static bool isNominalExnc(Entity exnc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTrueFSharpStructTycon(a _g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBeAugmentedWithEquals(a g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBeAugmentedWithCompare(a g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<bool, bool, FSharpOption`1<bool>, FSharpOption`1<bool>, FSharpOption`1<bool>, FSharpOption`1<bool>, FSharpOption`1<bool>, Tuple`2<FSharpOption`1<bool>, FSharpOption`1<bool>>> getAugmentationAttribs(TcGlobals g, Entity tycon);
    internal static bool hasNominalInterface@785(TcGlobals g, ImportMap amap, Entity tycon, EntityRef tcref);
    [CompilerGeneratedAttribute]
internal static void CheckAugmentationAttribs$cont@803(bool isImplementation, range m, Tuple`8<bool, bool, FSharpOption`1<bool>, FSharpOption`1<bool>, FSharpOption`1<bool>, FSharpOption`1<bool>, FSharpOption`1<bool>, Tuple`2<FSharpOption`1<bool>, FSharpOption`1<bool>>> attribs, bool hasExplicitICompare, bool hasExplicitIGenericCompare, bool hasExplicitEquals, bool hasExplicitGenericEquals, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAugmentationAttribs(bool isImplementation, TcGlobals g, ImportMap amap, Entity tycon);
    [CompilerGeneratedAttribute]
internal static bool TyconIsCandidateForAugmentationWithCompare$cont@830(TcGlobals g, Entity tycon, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconIsCandidateForAugmentationWithCompare(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconIsCandidateForAugmentationWithEquals(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconIsCandidateForAugmentationWithHash(TcGlobals g, Entity tycon);
    internal static ValMemberInfo slotImplMethod(bool final, EntityRef c, SlotSig slotsig);
    internal static ValMemberInfo nonVirtualMethod(EntityRef c);
    internal static FSharpList`1<FSharpList`1<ArgReprInfo>> get_unitArg();
    internal static FSharpList`1<FSharpList`1<ArgReprInfo>> get_unaryArg();
    internal static FSharpList`1<FSharpList`1<ArgReprInfo>> get_tupArg();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val mkValSpec(TcGlobals g, EntityRef tcref, TType tmty, Accessibility vis, FSharpOption`1<SlotSig> slotsig, string methn, TType ty, FSharpList`1<FSharpList`1<ArgReprInfo>> argData);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Val> MakeValsForCompareAugmentation(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val MakeValsForCompareWithComparerAugmentation(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Val> MakeValsForEqualsAugmentation(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Val> MakeValsForEqualityWithComparerAugmentation(TcGlobals g, EntityRef tcref);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Binding> mkCompare$cont@939(TcGlobals g, Entity tycon, EntityRef tcref, range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, Tuple`3<Val, Val, Expr>>>> comparef, FSharpOption`1<Tuple`2<ValRef, ValRef>> matchValue, Unit unitVar);
    internal static FSharpList`1<Binding> mkCompare@935(TcGlobals g, Entity tycon, EntityRef tcref, range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, Tuple`3<Val, Val, Expr>>>> comparef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> MakeBindingsForCompareAugmentation(TcGlobals g, Entity tycon);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Binding> mkCompare$cont@972-1(TcGlobals g, Entity tycon, EntityRef tcref, range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, Expr>>>>>> comparef, FSharpOption`1<ValRef> matchValue, Unit unitVar);
    internal static FSharpList`1<Binding> mkCompare@968-1(TcGlobals g, Entity tycon, EntityRef tcref, range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, Expr>>>>>> comparef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> MakeBindingsForCompareWithComparerAugmentation(TcGlobals g, Entity tycon);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Binding> mkStructuralEquatable$cont@1000(TcGlobals g, Entity tycon, EntityRef tcref, range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Expr, Tuple`2<Val, Expr>>>>> hashf, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, Expr>>>>>>> equalsf, FSharpOption`1<Tuple`3<ValRef, ValRef, ValRef>> matchValue, Unit unitVar);
    internal static FSharpList`1<Binding> mkStructuralEquatable@994(TcGlobals g, Entity tycon, EntityRef tcref, range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Expr, Tuple`2<Val, Expr>>>>> hashf, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, Expr>>>>>>> equalsf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> MakeBindingsForEqualityWithComparerAugmentation(TcGlobals g, Entity tycon);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Binding> mkEquals$cont@1046(TcGlobals g, Entity tycon, EntityRef tcref, range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, Tuple`3<Val, Val, Expr>>>> equalsf, FSharpOption`1<Tuple`2<ValRef, ValRef>> matchValue, Unit unitVar);
    internal static FSharpList`1<Binding> mkEquals@1041(TcGlobals g, Entity tycon, EntityRef tcref, range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, Tuple`3<Val, Val, Expr>>>> equalsf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> MakeBindingsForEqualsAugmentation(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeDefinitelyHasEquality(TcGlobals g, TType ty);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AutoBox : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideEscapes(FSharpList`1<Val> syntacticArgs, Expr body);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpFunc`2<a, FSharpList`1<a>>> snoc@38();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideLambda(FSharpOption`1<FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>>> exprF, cenv cenv, ValReprInfo topValInfo, Expr expr, TType ety, Set`2<Val, IComparer`1<Val>> z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideExprOp(FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>> exprF, FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>> noInterceptF, Set`2<Val, IComparer`1<Val>> z, Expr expr, TOp op, FSharpList`1<a> tyargs, FSharpList`1<Expr> args);
    internal static FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Tuple`2<a, FSharpList`1<ObjExprMethod>>, Set`2<Val, IComparer`1<Val>>>> CheckInterfaceImpl@92-1(FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<ObjExprMethod, Set`2<Val, IComparer`1<Val>>>> CheckMethod);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideExpr(cenv cenv, FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>> exprF, FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>> noInterceptF, Set`2<Val, IComparer`1<Val>> z, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideBinding(cenv cenv, Set`2<Val, IComparer`1<Val>> z, Binding _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideBindings(cenv cenv, Set`2<Val, IComparer`1<Val>> z, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideImplFile(TcGlobals g, ImportMap amap, TypedImplFile implFile);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Expr> TransformExpr$cont@136(TcGlobals g, ValMap`1<Tuple`2<a, Expr>> nvs, FSharpFunc`2<Expr, Expr> exprF, Expr expr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TransformExpr(TcGlobals g, ValMap`1<Tuple`2<a, Expr>> nvs, FSharpFunc`2<Expr, Expr> exprF, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Binding> TransformBinding(TcGlobals g, ValMap`1<Tuple`2<Val, a>> nvs, FSharpFunc`2<Expr, Expr> exprF, Binding _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypedImplFile TransformImplFile(TcGlobals g, ImportMap amap, TypedImplFile implFile);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CheckFormatStrings : object {
    internal static int lowestDefaultPriority { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType copyAndFixupFormatTypar(range m, Typar tp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_lowestDefaultPriority();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFlexibleFormatTypar(range m, FSharpList`1<TType> tys, TType dflt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFlexibleIntFormatTypar(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFlexibleDecimalFormatTypar(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFlexibleFloatFormatTypar(TcGlobals g, range m);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@37-52(FormatInfoRegister this, FormatInfoRegister obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@37-53(IComparer comp, FormatInfoRegister this, FormatInfoRegister objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<int, string> parseFormatStringInternal$cont@55(range m, FSharpOption`1<FormatStringCheckContext> context, string fmt, Unit unitVar);
    internal static int flags@93(string fmt, int len, FormatInfoRegister info, int i);
    internal static int digitsPrecision@115(string fmt, int len, int i);
    internal static Tuple`2<bool, int> precision@121(string fmt, int len, FormatInfoRegister info, int i);
    internal static Tuple`2<bool, int> optionalDotAndPrecision@128(string fmt, int len, FormatInfoRegister info, int i);
    internal static Tuple`2<bool, int> digitsWidthAndPrecision@134(string fmt, int len, FormatInfoRegister info, int i);
    internal static Tuple`2<bool, Tuple`2<bool, int>> widthAndPrecision@140(string fmt, int len, FormatInfoRegister info, int i);
    internal static Tuple`2<FSharpOption`1<int>, int> digitsPosition@147(string fmt, int len, int n, int i);
    internal static Tuple`2<FSharpOption`1<int>, int> position@154(string fmt, int len, int i);
    internal static void checkNoPrecision@179(FormatInfoRegister info, a c);
    internal static void checkNoZeroFlag@180(FormatInfoRegister info, a c);
    internal static void checkNoNumericPrefix@181(FormatInfoRegister info, a c);
    internal static void collectSpecifierLocation@189(range m, int offset, List`1<Tuple`2<range, int>> specifierLocations, int relCol, bool widthArg, bool precisionArg, int relLine, int relCol@189, int numStdArgs);
    internal static FSharpList`1<TType> parseLoop@73(range m, TcGlobals g, TType bty, TType cty, int offset, string fmt, int len, List`1<Tuple`2<range, int>> specifierLocations, FSharpList`1<Tuple`2<FSharpOption`1<int>, TType>> acc, int tupledArg0, int tupledArg1, int tupledArg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, FSharpList`1<Tuple`2<range, int>>> parseFormatStringInternal(range m, TcGlobals g, FSharpOption`1<FormatStringCheckContext> context, string fmt, TType bty, TType cty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<TType, TType>, FSharpList`1<Tuple`2<range, int>>> ParseFormatString(range m, TcGlobals g, FSharpOption`1<FormatStringCheckContext> formatStringCheckContext, string fmt, TType bty, TType cty, TType dty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<int> TryCountFormatStringArguments(range m, TcGlobals g, string fmt, TType bty, TType cty);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CompileOps : object {
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> FSharpSigFileSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> mlCompatSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> FSharpImplFileSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> resSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> FSharpScriptFileSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> doNotRequireNamespaceOrModuleSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> FSharpLightSyntaxFileSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<QualifiedNameOfFile> qnameOrder { get; }
    internal static FSharpList`1<string> get_FSharpSigFileSuffixes();
    internal static FSharpList`1<string> get_mlCompatSuffixes();
    internal static FSharpList`1<string> get_FSharpImplFileSuffixes();
    internal static FSharpList`1<string> get_resSuffixes();
    internal static FSharpList`1<string> get_FSharpScriptFileSuffixes();
    internal static FSharpList`1<string> get_doNotRequireNamespaceOrModuleSuffixes();
    internal static FSharpList`1<string> get_FSharpLightSyntaxFileSuffixes();
    internal static FSharpOption`1<range> RangeFromException@98(Exception _arg1);
    internal static FSharpOption`1<range> GetRangeOfDiagnostic(PhasedDiagnostic err);
    internal static int GetFromException@242(Exception e);
    internal static int GetDiagnosticNumber(PhasedDiagnostic err);
    internal static int GetWarningLevel(PhasedDiagnostic err);
    [CompilerGeneratedAttribute]
internal static bool contains@1-6(a e, FSharpList`1<a> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool warningOn(PhasedDiagnostic err, int level, FSharpList`1<int> specificWarnOn);
    internal static Tuple`2<PhasedDiagnostic, FSharpList`1<PhasedDiagnostic>> SplitRelatedException@407(PhasedDiagnostic err, FSharpFunc`2<Exception, PhasedDiagnostic> ToPhased, Exception _arg1);
    internal static Tuple`2<PhasedDiagnostic, FSharpList`1<PhasedDiagnostic>> SplitRelatedDiagnostics(PhasedDiagnostic err);
    internal static ResourceString`1<FSharpFunc`2<string, FSharpFunc`2<string, string>>> ConstraintSolverTypesNotInEqualityRelation1E();
    internal static ResourceString`1<FSharpFunc`2<string, FSharpFunc`2<string, string>>> ConstraintSolverTypesNotInEqualityRelation2E();
    internal static ResourceString`1<FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<string, string>>>> ConstraintSolverTypesNotInSubsumptionRelationE();
    internal static ResourceString`1<FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<string, string>>>> UnitTypeExpectedWithPossiblePropertySetterE();
    internal static ResourceString`1<FSharpFunc`2<string, FSharpFunc`2<string, string>>> UnitTypeExpectedWithPossibleAssignmentToMutableE();
    internal static FSharpOption`1<string> |InvalidArgument|_|(Exception exn);
    internal static void suggestNames@606-1(StringBuilder os, bool canSuggestNames, FSharpFunc`2<FSharpFunc`2<string, Unit>, Unit> suggestionsF, string idText);
    [CompilerGeneratedAttribute]
internal static void OutputExceptionR$cont@660-1(StringBuilder os, range m, ContextInfo contextInfo, string t2, string t1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void OutputExceptionR$cont@658(StringBuilder os, TType t2, TType t1, range m2, range m, DisplayEnv denv, ContextInfo contextInfo, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void OutputExceptionR$cont@697-3(StringBuilder os, range m, ContextInfo contextInfo, string tpcs, string t2, string t1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void OutputExceptionR$cont@696-2(StringBuilder os, TType t2, TType t1, range m, DisplayEnv denv, ContextInfo contextInfo, Unit unitVar);
    internal static FSharpOption`1<Unit> |EndOfStructuredConstructToken|_|@895(tokenId token);
    [CompilerGeneratedAttribute]
internal static string tokenIdToText$cont@905(tokenId tid, Unit unitVar);
    internal static string tokenIdToText@904(tokenId tid);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Expr|_|@1104(nonTerminalId _arg1);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Pattern|_|@1112(nonTerminalId _arg2);
    internal static FSharpOption`1<Unit> |NONTERM_Category_IfThenElse|_|@1117(nonTerminalId _arg3);
    internal static FSharpOption`1<Unit> |NONTERM_Category_SignatureFile|_|@1122(nonTerminalId _arg4);
    internal static FSharpOption`1<Unit> |NONTERM_Category_ImplementationFile|_|@1125(nonTerminalId _arg5);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Definition|_|@1128(nonTerminalId _arg6);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Type|_|@1133(nonTerminalId _arg7);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Interaction|_|@1137(nonTerminalId _arg8);
    [CompilerGeneratedAttribute]
internal static bool foundInContext$cont@1144(StringBuilder os, FSharpList`1<nonTerminalId> matchValue, Unit unitVar);
    internal static string fix@1201(string s);
    [CompilerGeneratedAttribute]
internal static void OutputExceptionR$cont@1095-4(StringBuilder os, ParseErrorContext`1<token> ctxt, FSharpFunc`2<tokenId, string> tokenIdToText, FSharpOption`1<token> matchValue, Unit unitVar);
    internal static bool hasUnitTType_app@1252(TcGlobals g, FSharpList`1<TType> types);
    [CompilerGeneratedAttribute]
internal static void OutputExceptionR$cont@1244-5(StringBuilder os, FSharpOption`1<MethInfo> minfoVirtOpt, range m, OverrideInfo impl, TcGlobals g, DisplayEnv denv, ImportMap amap, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void OutputExceptionR$cont@1445-6(StringBuilder os, Val v, bool hassig, DisplayEnv denv, Unit unitVar);
    internal static void OutputExceptionR@619(StringBuilder os, bool canSuggestNames, StringBuilder os@619, Exception error);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void OutputPhasedErrorR(StringBuilder os, PhasedDiagnostic err, bool canSuggestNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void OutputPhasedDiagnostic(StringBuilder os, PhasedDiagnostic err, bool flattenErrors, bool suggestNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string SanitizeFileName(string fileName, string implicitIncludeDir);
    [CompilerGeneratedAttribute]
internal static DiagnosticLocation outputWhere$cont@1650(string implicitIncludeDir, bool showFullPaths, ErrorStyle errorStyle, range m, Unit unitVar);
    internal static DiagnosticLocation outputWhere@1646(string implicitIncludeDir, bool tupledArg0, ErrorStyle tupledArg1, range m);
    internal static FSharpOption`1<DiagnosticLocation> OutputWhere@1700(bool showFullPaths, string implicitIncludeDir, ErrorStyle errorStyle, PhasedDiagnostic err);
    internal static DiagnosticCanonicalInformation OutputCanonicalInformation@1705(bool isError, ErrorStyle errorStyle, string tupledArg0, int tupledArg1);
    internal static void report@1699(bool showFullPaths, bool isError, string implicitIncludeDir, bool flattenErrors, ErrorStyle errorStyle, bool canSuggestNames, List`1<Diagnostic> errors, PhasedDiagnostic err);
    internal static IEnumerable`1<Diagnostic> CollectDiagnostic(string implicitIncludeDir, bool showFullPaths, bool flattenErrors, ErrorStyle errorStyle, bool warning, PhasedDiagnostic err, bool suggestNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void OutputDiagnostic(string implicitIncludeDir, bool showFullPaths, bool flattenErrors, ErrorStyle errorStyle, bool isError, StringBuilder os, PhasedDiagnostic err);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void OutputDiagnosticContext(string prefix, FSharpFunc`2<string, FSharpFunc`2<int, string>> fileLineFunction, StringBuilder os, PhasedDiagnostic err);
    internal static FSharpOption`1<string> TryResolveFileUsingPaths(FSharpList`1<string> paths, range m, string name);
    internal static string ResolveFileUsingPaths(FSharpList`1<string> paths, range m, string name);
    internal static FSharpOption`1<int> GetWarningNumber(range m, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ComputeMakePathAbsolute(string implicitIncludeDir, string path);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@1978-9(IEqualityComparer comp, ImportedBinary this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1978-16(ImportedBinary this, object obj, IEqualityComparer comp, Unit unitVar);
    internal static string ext@2338(TcConfigBuilder tcConfigB, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static bool contains@1-7(a e, FSharpList`1<a> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-8(a e, FSharpList`1<a> xs1);
    internal static ILModuleReader OpenILBinary(string filename, ReduceMemoryFlag reduceMemoryUsage, ILGlobals ilGlobals, FSharpOption`1<string> pdbDirPath, a shadowCopyReferences, FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot);
    internal static string GetNameOfILModule(ILModuleDef m);
    internal static ILScopeRef MakeScopeRefForILModule(ILModuleDef ilModule);
    internal static FSharpList`1<ILAttribute> GetCustomAttributesOfILModule(ILModuleDef ilModule);
    internal static bool isPoundRReference@2946(range r);
    internal static FSharpFunc`2<string, Unit> logMessage@3023(TcConfig tcConfig, bool showMessages);
    internal static FSharpFunc`2<bool, FSharpFunc`2<string, FSharpFunc`2<string, Unit>>> logDiagnostic@3027(ResolveAssemblyReferenceMode mode, range errorAndWarningRange, bool showMessages);
    internal static Tuple`2<int, FSharpList`1<AssemblyResolution>> mapping@1-24(TcConfig tcConfig, string tupledArg0, int tupledArg1, FSharpList`1<AssemblyReference> tupledArg2);
    internal static ResolvedFile[] Resolve@3063(TcConfig tcConfig, ResolveAssemblyReferenceMode mode, range errorAndWarningRange, string targetProcessorArchitecture, Tuple`2[] tupledArg0, bool tupledArg1);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, int, int> mapping@1-26(Tuple`3[] groupedReferences, int i);
    internal static Tuple`2<string, string> mapping@1-27(string tupledArg0, int tupledArg1, int tupledArg2);
    [CompilerGeneratedAttribute]
internal static Tuple`2<int, FSharpList`1<AssemblyResolution>> mapping@1-28(TcConfig tcConfig, Tuple`3[] groupedReferences, ResolvedFile resolvedFile);
    internal static bool IsResolved@3113(TcConfig tcConfig, ResolveAssemblyReferenceMode mode, range errorAndWarningRange, string targetProcessorArchitecture, FSharpList`1<AssemblyResolution> resultingResolutions, string originalName);
    internal static Tuple`2<AssemblyReference, FSharpOption`1<string>> nameOfDll@2573(TcConfig this, AssemblyReference defaultCoreLibraryReference, AssemblyReference r);
    [CompilerGeneratedAttribute]
internal static bool contains@1-9(a e, FSharpList`1<a> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ReportWarning(FSharpErrorSeverityOptions options, PhasedDiagnostic err);
    [CompilerGeneratedAttribute]
internal static bool contains@1-10(a e, FSharpList`1<a> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-11(a e, FSharpList`1<a> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-12(a e, FSharpList`1<a> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ReportWarningAsError(FSharpErrorSeverityOptions options, PhasedDiagnostic err);
    internal static FSharpList`1<ScopedPragma> GetScopedPragmasForHashDirective(ParsedHashDirective hd);
    internal static FSharpList`1<ScopedPragma> GetScopedPragmasForInput(ParsedInput input);
    internal static ErrorLogger GetErrorLoggerFilteringByScopedPragmas(bool checkFile, FSharpList`1<ScopedPragma> scopedPragmas, ErrorLogger errorLogger);
    internal static string CanonicalizeFilename(string filename);
    internal static bool IsScript(string filename);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile QualFileNameOfModuleName(range m, string filename, FSharpList`1<Ident> modname);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile QualFileNameOfFilename(range m, string filename);
    internal static QualifiedNameOfFile ComputeQualifiedNameOfFileFromUniquePath(range m, FSharpList`1<string> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile QualFileNameOfSpecs(string filename, FSharpList`1<SynModuleOrNamespaceSig> specs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile QualFileNameOfImpls(string filename, FSharpList`1<SynModuleOrNamespace> specs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile PrepandPathToQualFileName(FSharpList`1<Ident> x, QualifiedNameOfFile _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynModuleOrNamespace PrepandPathToImpl(FSharpList`1<Ident> x, SynModuleOrNamespace _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynModuleOrNamespaceSig PrepandPathToSpec(FSharpList`1<Ident> x, SynModuleOrNamespaceSig _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParsedInput PrependPathToInput(FSharpList`1<Ident> x, ParsedInput inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Ident> ComputeAnonModuleName(bool check, FSharpOption`1<string> defaultNamespace, string filename, range m);
    [CompilerGeneratedAttribute]
internal static SynModuleOrNamespace PostParseModuleImpl$cont@3263(ParsedImplFileFragment impl, Unit unitVar);
    internal static SynModuleOrNamespace PostParseModuleImpl(a _i, FSharpOption`1<string> defaultNamespace, Tuple`2<bool, bool> isLastCompiland, string filename, ParsedImplFileFragment impl);
    [CompilerGeneratedAttribute]
internal static SynModuleOrNamespaceSig PostParseModuleSpec$cont@3293(ParsedSigFileFragment intf, Unit unitVar);
    internal static SynModuleOrNamespaceSig PostParseModuleSpec(a _i, FSharpOption`1<string> defaultNamespace, Tuple`2<bool, bool> isLastCompiland, string filename, ParsedSigFileFragment intf);
    internal static ParsedInput PostParseModuleImpls(FSharpOption`1<string> defaultNamespace, string filename, Tuple`2<bool, bool> isLastCompiland, ParsedImplFile _arg1);
    internal static ParsedInput PostParseModuleSpecs(FSharpOption`1<string> defaultNamespace, string filename, Tuple`2<bool, bool> isLastCompiland, ParsedSigFile _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<QualifiedNameOfFile, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>>> DeduplicateModuleName(FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, string fileName, QualifiedNameOfFile qualNameOfFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ParsedInput, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>>> DeduplicateParsedInputModuleName(FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, ParsedInput input);
    internal static ParsedInput ParseInput(FSharpFunc`2<LexBuffer`1<char>, token> lexer, ErrorLogger errorLogger, LexBuffer`1<char> lexbuf, FSharpOption`1<string> defaultNamespace, string filename, Tuple`2<bool, bool> isLastCompiland);
    internal static FSharpList`1<SynModuleSigDecl> flattenSpecs@3462(FSharpList`1<SynModuleSigDecl> specs);
    internal static FSharpList`1<SynModuleDecl> flattenDefns@3464(FSharpList`1<SynModuleDecl> specs);
    internal static FSharpOption`1<ParsedInput> ParseOneInputLexbuf(TcConfig tcConfig, LexResourceManager lexResourceManager, FSharpList`1<string> conditionalCompilationDefines, LexBuffer`1<char> lexbuf, string filename, Tuple`2<bool, bool> isLastCompiland, ErrorLogger errorLogger);
    internal static FSharpOption`1<ParsedInput> ParseOneInputFile(TcConfig tcConfig, LexResourceManager lexResourceManager, FSharpList`1<string> conditionalCompilationDefines, string filename, Tuple`2<bool, bool> isLastCompiland, ErrorLogger errorLogger, bool retryLocked);
    internal static bool IsSignatureDataResource(ILResource r);
    internal static bool IsOptimizationDataResource(ILResource r);
    internal static string GetSignatureDataResourceName(ILResource r);
    internal static string GetOptimizationDataResourceName(ILResource r);
    internal static bool IsReflectedDefinitionsResource(ILResource r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILResource PickleToResource(bool inMem, string file, TcGlobals g, CcuThunk scope, string rname, FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> p, a x);
    internal static ILResource WriteSignatureData(TcConfig tcConfig, TcGlobals tcGlobals, Remap exportRemapping, CcuThunk ccu, string filename, bool inMem);
    internal static ILResource WriteOptimizationData(TcGlobals tcGlobals, string filename, bool inMem, CcuThunk ccu, Lazy`1<ModuleInfo> modulInfo);
    [CompilerGeneratedAttribute]
internal static bool contains@1-13(a e, FSharpList`1<a> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-14(a e, FSharpList`1<a> xs1);
    internal static FSharpOption`1<CcuThunk> availableToOptionalCcu(CcuResolutionResult _arg1);
    internal static FSharpOption`1<ImportedBinary> look@3898-10(string assemblyName, TcImports t);
    internal static FSharpOption`1<ImportedAssembly> look@3934-11(string assemblyName, TcImports t);
    internal static void loop@4310-91(TcImports tcImportsStrong, TcConfig tcConfig, range m, Entity entityToInjectInto, ResolutionEnvironment typeProviderEnvironment, Tainted`1<ITypeProvider> provider, Tainted`1<IProvidedNamespace> providedNamespace);
    internal static bool tryFile@4569(TcImports tcImports, range m, CompilationThreadToken ctok, string speculativeFileName);
    internal static Tuple`2<TcEnv, Tuple`2<FSharpList`1<ImportedBinary>, FSharpList`1<ImportedAssembly>>> RequireDLL(CompilationThreadToken ctok, TcImports tcImports, TcEnv tcEnv, string thisAssemblyName, range referenceRange, string file);
    internal static T ProcessMetaCommand@4816(FSharpFunc`2<T, FSharpFunc`2<Tuple`2<range, string>, T>> nowarnF, FSharpFunc`2<T, FSharpFunc`2<Tuple`2<range, string>, Unit>> loadSourceF, FSharpFunc`2<T, FSharpFunc`2<Tuple`2<range, string>, T>> dllRequireF, TcConfigBuilder tcConfig, string pathOfMetaCommandSource, bool canHaveScriptMetaCommands, T state, ParsedHashDirective hash);
    internal static void WarnOnIgnoredSpecDecls@4871(FSharpList`1<SynModuleSigDecl> decls);
    internal static void WarnOnIgnoredImplDecls@4878(FSharpList`1<SynModuleDecl> decls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T ProcessMetaCommandsFromInput(Tuple`3<FSharpFunc`2<T, FSharpFunc`2<Tuple`2<range, string>, T>>, FSharpFunc`2<T, FSharpFunc`2<Tuple`2<range, string>, T>>, FSharpFunc`2<T, FSharpFunc`2<Tuple`2<range, string>, Unit>>> tupledArg, TcConfigBuilder tcConfig, ParsedInput inp, string pathOfMetaCommandSource, T state0);
    internal static FSharpFunc`2<Unit, FSharpFunc`2<Tuple`2<a, b>, Unit>> addReferencedAssemblyByPath@4917();
    internal static FSharpFunc`2<Unit, FSharpFunc`2<Tuple`2<a, b>, Unit>> addLoadedSource@4918();
    internal static TcConfig ApplyNoWarnsToTcConfig(TcConfig tcConfig, ParsedInput inp, string pathOfMetaCommandSource);
    internal static FSharpFunc`2<Unit, FSharpFunc`2<a, Unit>> getWarningNumber@4925();
    internal static TcConfig ApplyMetaCommandsFromInputToTcConfig(TcConfig tcConfig, ParsedInput inp, string pathOfMetaCommandSource);
    internal static Tuple`2<FSharpList`1<AssemblyResolution>, FSharpList`1<UnresolvedAssemblyReference>> GetAssemblyResolutionInformation(CompilationThreadToken ctok, TcConfig tcConfig);
    internal static TcEnv GetInitialTcEnv(string assemblyName, range initm, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals);
    internal static void CheckSimulateException(TcConfig tcConfig);
    internal static IComparer`1<QualifiedNameOfFile> get_qnameOrder();
    internal static TcState GetInitialTcState(range m, string ccuName, TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, NiceNameGenerator niceNameGen, TcEnv tcEnv0);
    internal static Eventually`1<Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<TypedImplFile>, ModuleOrNamespaceType>, TcState>> TypeCheckOneInputEventually(FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcResultsSink tcSink, TcState tcState, ParsedInput inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<TypedImplFile>, ModuleOrNamespaceType>, TcState> TypeCheckOneInput(CompilationThreadToken ctok, FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcState tcState, ParsedInput inp);
    internal static Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpList`1<T>, FSharpList`1<U>>, TcState> TypeCheckMultipleInputsFinish(FSharpList`1<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<T>, U>> results, TcState tcState);
    internal static Eventually`1<Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpList`1<TypedImplFile>, FSharpList`1<ModuleOrNamespaceType>>, TcState>> TypeCheckOneInputAndFinishEventually(FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcResultsSink tcSink, TcState tcState, ParsedInput input);
    internal static Tuple`2<TcState, FSharpList`1<TypedImplFile>> TypeCheckClosedInputSetFinish(FSharpList`1<TypedImplFile> declaredImpls, TcState tcState);
    internal static Tuple`4<TcState, TopAttribs, FSharpList`1<TypedImplFile>, TcEnv> TypeCheckClosedInputSet(CompilationThreadToken ctok, FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcState tcState, FSharpList`1<ParsedInput> inputs);
    internal static string GetFSharpCoreLibraryName();
    internal static FSharpList`1<string> DefaultReferencesForScriptsAndOutOfProjectSources(bool assumeDotNetFramework);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CompileOptions : object {
    internal static bool lexFilterVerbose { get; }
    [CompilationMappingAttribute("9")]
internal static bool enableConsoleColoring { get; internal set; }
    internal static string tagString { get; }
    internal static string tagExe { get; }
    internal static string tagWinExe { get; }
    internal static string tagLibrary { get; }
    internal static string tagModule { get; }
    internal static string tagFile { get; }
    internal static string tagFileList { get; }
    internal static string tagDirList { get; }
    internal static string tagPathList { get; }
    internal static string tagResInfo { get; }
    internal static string tagFullPDBOnlyPortable { get; }
    internal static string tagWarnList { get; }
    internal static string tagSymbolList { get; }
    internal static string tagAddress { get; }
    internal static string tagAlgorithm { get; }
    internal static string tagInt { get; }
    internal static string tagPathMap { get; }
    internal static string tagNone { get; }
    [CompilationMappingAttribute("9")]
internal static CompilerOption mlKeywordsFlag { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<int> showTermFileCount { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<FSharpOption`1<Tuple`2<double, Int32[]>>> tPrev { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<FSharpOption`1<string>> nPrev { get; }
    internal static FSharpList`1<CompilerOption> GetOptionsOfBlock(CompilerOptionBlock block);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompilerOptionBlock FilterCompilerOptionBlock(FSharpFunc`2<CompilerOption, bool> pred, CompilerOptionBlock block);
    internal static string compilerOptionUsage(CompilerOption _arg1);
    internal static void PrintCompilerOption(CompilerOption _arg1);
    internal static void PrintPublicOptions(string heading, FSharpList`1<CompilerOption> opts);
    internal static FSharpFunc`2<a, bool> equals@128(a x);
    internal static FSharpFunc`2<FSharpSet`1<string>, FSharpFunc`2<Tuple`2<string, a>, FSharpSet`1<string>>> consider@130(FSharpList`1<Tuple`2<string, FSharpList`1<CompilerOption>>> publicBlocks);
    internal static void PrintCompilerOptionBlocks(FSharpList`1<CompilerOptionBlock> blocks);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void dumpCompilerOption(string prefix, CompilerOption _arg1);
    internal static void dumpCompilerOptionBlock(CompilerOptionBlock _arg1);
    internal static void DumpCompilerOptionBlocks(FSharpList`1<CompilerOptionBlock> blocks);
    internal static bool isSlashOpt(string opt);
    internal static Tuple`2<string, string> parseOption@198(string s);
    internal static string getOptionArg@222(CompilerOption compilerOption, string argString);
    internal static FSharpList`1<string> getOptionArgList@227(CompilerOption compilerOption, string argString);
    internal static string getSwitchOpt@234(string opt);
    internal static OptionSwitch getSwitch@241(string s);
    internal static void reportDeprecatedOption@281(FSharpOption`1<a> errOpt);
    internal static FSharpList`1<string> attempt@286(FSharpFunc`2<string, Unit> collectOtherArgument, FSharpList`1<CompilerOptionBlock> blocks, FSharpList`1<string> args, FSharpList`1<string> t, string opt, string optToken, string argString, FSharpList`1<CompilerOption> l);
    internal static void processArg@245(FSharpFunc`2<string, Unit> collectOtherArgument, FSharpList`1<CompilerOptionBlock> blocks, FSharpList`1<CompilerOption> specs, FSharpList`1<string> args);
    internal static void ParseCompilerOptions(FSharpFunc`2<string, Unit> collectOtherArgument, FSharpList`1<CompilerOptionBlock> blocks, FSharpList`1<string> args);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_lexFilterVerbose();
    internal static bool get_enableConsoleColoring();
    internal static void set_enableConsoleColoring(bool value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a setFlag(FSharpFunc`2<bool, a> r, int n);
    internal static void SetOptimizeOff(TcConfigBuilder tcConfigB);
    internal static void SetOptimizeOn(TcConfigBuilder tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetOptimizeSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetTailcallSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetDeterministicSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddPathMapping(TcConfigBuilder tcConfigB, string pathPair);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void jitoptimizeSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void localoptimizeSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void crossOptimizeSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void splittingSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void callVirtSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void useHighEntropyVASwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilerGeneratedAttribute]
internal static void subSystemVersionSwitch$cont@443(TcConfigBuilder tcConfigB, string text, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void subSystemVersionSwitch(TcConfigBuilder tcConfigB, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetTarget(TcConfigBuilder tcConfigB, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetDebugSwitch(TcConfigBuilder tcConfigB, FSharpOption`1<string> dtype, OptionSwitch s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetEmbedAllSourceSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagExe();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagWinExe();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagLibrary();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagFileList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagDirList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagPathList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagResInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagFullPDBOnlyPortable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagWarnList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagSymbolList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagAddress();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagAlgorithm();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagInt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagPathMap();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagNone();
    internal static void PrintOptionInfo(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> inputFileFlagsBoth(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> inputFileFlagsFsi(TcConfigBuilder tcConfigB);
    internal static string trimFS@580(string s);
    internal static FSharpOption`1<int> trimFStoInt@581(string s);
    internal static FSharpList`1<CompilerOption> errorsAndWarningsFlags(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> outputFileFlagsFsc(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> resourcesFlagsFsc(TcConfigBuilder tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<CompilerOption> codeGenerationFlags(bool isFsi, TcConfigBuilder tcConfigB);
    internal static CompilerOption mlCompatibilityFlag(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> languageFlags(TcConfigBuilder tcConfigB);
    internal static CompilerOption libFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption codePageFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption preferredUiLang(TcConfigBuilder tcConfigB);
    internal static CompilerOption utf8OutputFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption fullPathsFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption cliRootFlag(TcConfigBuilder _tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetTargetProfile(TcConfigBuilder tcConfigB, string v);
    internal static FSharpList`1<CompilerOption> advancedFlagsBoth(TcConfigBuilder tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompilerOption noFrameworkFlag(bool isFsc, TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> advancedFlagsFsi(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> advancedFlagsFsc(TcConfigBuilder tcConfigB);
    internal static CompilerOption testFlag(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> editorSpecificFlags(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> internalFlags(TcConfigBuilder tcConfigB);
    internal static CompilerOption compilingFsLibFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption compilingFsLib20Flag(TcConfigBuilder tcConfigB);
    internal static CompilerOption compilingFsLib40Flag(TcConfigBuilder tcConfigB);
    internal static CompilerOption compilingFsLibNoBigIntFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption get_mlKeywordsFlag();
    internal static CompilerOption gnuStyleErrorsFlag(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> deprecatedFlagsBoth(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> deprecatedFlagsFsc(TcConfigBuilder tcConfigB);
    internal static void DisplayBannerText(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> miscFlagsBoth(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> miscFlagsFsc(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> abbreviatedFlagsBoth(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> abbreviatedFlagsFsi(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> abbreviatedFlagsFsc(TcConfigBuilder tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpSet`1<string> GetAbbrevFlagSet(TcConfigBuilder tcConfigB, bool isFsc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> PostProcessCompilerArgs(FSharpSet`1<string> abbrevArgs, String[] args);
    internal static FSharpList`1<CompilerOption> testingAndQAFlags(a _tcConfigB);
    internal static FSharpList`1<CompilerOptionBlock> GetCoreFscCompilerOptions(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOptionBlock> GetCoreServiceCompilerOptions(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOptionBlock> GetCoreFsiCompilerOptions(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<string> ApplyCommandLineArgs(TcConfigBuilder tcConfigB, FSharpList`1<string> sourceFiles, FSharpList`1<string> argv);
    internal static FSharpRef`1<int> get_showTermFileCount();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PrintWholeAssemblyImplementation(TcGlobals g, TcConfig tcConfig, string outfile, string header, FSharpList`1<TypedImplFile> expr);
    internal static FSharpRef`1<FSharpOption`1<Tuple`2<double, Int32[]>>> get_tPrev();
    internal static FSharpRef`1<FSharpOption`1<string>> get_nPrev();
    [CompilerGeneratedAttribute]
internal static void ReportTime$cont@1611(TcConfig tcConfig, string descr, FSharpOption`1<string> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void ReportTime$cont@1649-1(Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ReportTime(TcConfig tcConfig, string descr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv AddExternalCcuToOpimizationEnv(TcGlobals tcGlobals, IncrementalOptimizationEnv optEnv, ImportedAssembly ccuinfo);
    internal static IncrementalOptimizationEnv GetInitialOptimizationEnv(TcImports tcImports, TcGlobals tcGlobals);
    internal static Tuple`3<TypedAssemblyAfterOptimization, Lazy`1<ModuleInfo>, IncrementalOptimizationEnv> ApplyAllOptimizations(TcConfig tcConfig, TcGlobals tcGlobals, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<range, Tuple`2<Expr, TType>>>>> tcVal, string outfile, ImportMap importMap, bool isIncrementalFragment, IncrementalOptimizationEnv optEnv, CcuThunk ccu, FSharpList`1<TypedImplFile> implFiles);
    internal static IlxAssemblyGenerator CreateIlxAssemblyGenerator(TcConfig _tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<range, Tuple`2<Expr, TType>>>>> tcVal, CcuThunk generatedCcu);
    internal static IlxGenResults GenerateIlxCode(IlxGenBackend ilxBackend, bool isInteractiveItExpr, bool isInteractiveOnMono, TcConfig tcConfig, TopAttribs topAttrs, TypedAssemblyAfterOptimization optimizedImpls, string fragName, IlxAssemblyGenerator ilxGenerator);
    internal static FSharpFunc`2<ILScopeRef, ILScopeRef> NormalizeAssemblyRefs(CompilationThreadToken ctok, TcImports tcImports);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string GetGeneratedILModuleName(CompilerTarget t, string s);
    internal static void ignoreFailureOnMono1_1_16(FSharpFunc`2<Unit, Unit> f);
    internal static FSharpOption`1<Tuple`2<ConsoleColor, ConsoleColor>> foreBackColor();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a DoWithColor(ConsoleColor newColor, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a DoWithErrorColor(bool isError, FSharpFunc`2<Unit, a> f);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CompilerGlobalState : object {
    internal NiceNameGenerator globalNng;
    internal StableNiceNameGenerator globalStableNameGenerator;
    internal NiceNameGenerator ilxgenGlobalNng;
    internal NiceNameGenerator NiceNameGenerator { get; }
    internal StableNiceNameGenerator StableNameGenerator { get; }
    internal NiceNameGenerator IlxGenNiceNameGenerator { get; }
    internal NiceNameGenerator get_NiceNameGenerator();
    internal StableNiceNameGenerator get_StableNameGenerator();
    internal NiceNameGenerator get_IlxGenNiceNameGenerator();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.ConstraintSolver : object {
    [CompilationMappingAttribute("9")]
internal static Ident compgenId { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> BakedInTraitConstraintNames { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> arg@1-1 { get; }
    [CompilationMappingAttribute("9")]
internal static OperationResult`1<Unit> localAbortD { get; }
    internal static Ident get_compgenId();
    internal static Typar NewCompGenTypar(TyparKind kind, TyparRigidity rigid, TyparStaticReq staticReq, TyparDynamicReq dynamicReq, bool error);
    internal static Typar NewAnonTypar(TyparKind kind, range m, TyparRigidity rigid, TyparStaticReq var, TyparDynamicReq dyn);
    internal static Typar NewNamedInferenceMeasureVar(a _m, TyparRigidity rigid, TyparStaticReq var, Ident id);
    internal static Typar NewInferenceMeasurePar();
    internal static Typar NewErrorTypar();
    internal static Typar NewErrorMeasureVar();
    internal static TType NewInferenceType();
    internal static TType NewErrorType();
    internal static Measure NewErrorMeasure();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType NewByRefKindInferenceType(TcGlobals g, range m);
    internal static FSharpList`1<TType> NewInferenceTypes(FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>> FreshenAndFixupTypars(range m, TyparRigidity rigid, FSharpList`1<Typar> fctps, FSharpList`1<TType> tinst, FSharpList`1<Typar> tpsorig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>> FreshenTypeInst(range m, FSharpList`1<Typar> tpsorig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> FreshenTypars(range m, FSharpList`1<Typar> tpsorig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> FreshenMethInfo(range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Exception> GetPossibleOverloads(ImportMap amap, range m, DisplayEnv denv, FSharpList`1<Tuple`2<CalledMeth`1<a>, Exception>> calledMethGroup);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstraintSolverEnv MakeConstraintSolverEnv(ContextInfo contextInfo, ConstraintSolverState css, range m, DisplayEnv denv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool occursCheck(TcGlobals g, Typar un, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNativeIntegerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSignedIntegerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnsignedIntegerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isIntegerOrIntegerEnumTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isIntegerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFpTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsNonDecimalNumericOrIntegralEnumType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsNumericOrIntegralEnumType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsNonDecimalNumericType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsNumericType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsRelationalType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<EntityRef, Measure>> GetMeasureOfType(TcGlobals g, TType ty);
    internal static FSharpSet`1<string> get_BakedInTraitConstraintNames();
    internal static FSharpList`1<string> get_arg@1-1();
    internal static a CollectThenUndo(FSharpFunc`2<Trace, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`3<a, FSharpList`1<Exception>, Trace>> FilterEachThenUndo(FSharpFunc`2<Trace, FSharpFunc`2<a, OperationResult`1<b>>> f, FSharpList`1<a> meths);
    internal static string ShowAccessDomain(AccessorDomain ad);
    internal static OperationResult`1<Unit> get_localAbortD();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PreferUnifyTypar(Typar v1, Typar v2);
    internal static FSharpList`1<Tuple`2<Typar, b>> find@483-1(FSharpList`1<Tuple`2<Typar, b>> vs);
    internal static FSharpList`1<Tuple`2<Typar, a>> FindPreferredTypar(FSharpList`1<Tuple`2<Typar, a>> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SubstMeasure(Typar r, Measure ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> TransactStaticReq(ConstraintSolverEnv csenv, OptionalTrace trace, Typar tpr, TyparStaticReq req);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypStaticReqTypar(ConstraintSolverEnv csenv, OptionalTrace trace, TyparStaticReq req, Typar tpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypStaticReq(ConstraintSolverEnv csenv, OptionalTrace trace, TyparStaticReq req, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> TransactDynamicReq(OptionalTrace trace, Typar tpr, TyparDynamicReq req);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypDynamicReq(ConstraintSolverEnv csenv, OptionalTrace trace, TyparDynamicReq req, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> TransactIsCompatFlex(OptionalTrace trace, Typar tpr, bool req);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypIsCompatFlex(ConstraintSolverEnv csenv, OptionalTrace trace, bool req, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SubstMeasureWarnIfRigid(ConstraintSolverEnv csenv, OptionalTrace trace, Typar v, Measure ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> UnifyMeasureWithOne(ConstraintSolverEnv csenv, OptionalTrace trace, Measure ms);
    internal static Tuple`2<FSharpList`1<Typar>, FSharpOption`1<Typar>> simp@610(TcGlobals g, Measure ms, FSharpList`1<Typar> vars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpOption`1<Typar>> SimplifyMeasure(TcGlobals g, FSharpList`1<Typar> vars, Measure ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpList`1<Typar>> SimplifyMeasuresInType(TcGlobals g, bool resultFirst, FSharpList`1<Typar> _arg1_0, FSharpList`1<Typar> _arg1_1, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpList`1<Typar>> SimplifyMeasuresInTypes(TcGlobals g, FSharpList`1<Typar> param_0, FSharpList`1<Typar> param_1, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpList`1<Typar>> SimplifyMeasuresInConstraint(TcGlobals g, FSharpList`1<Typar> param_0, FSharpList`1<Typar> param_1, TyparConstraint c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpList`1<Typar>> SimplifyMeasuresInConstraints(TcGlobals g, FSharpList`1<Typar> param_0, FSharpList`1<Typar> param_1, FSharpList`1<TyparConstraint> cs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational GetMeasureVarGcdInType(Typar v, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational GetMeasureVarGcdInTypes(Typar v, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> NormalizeExponentsInTypeScheme(FSharpList`1<Typar> uvars, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> SimplifyMeasuresInTypeScheme(TcGlobals g, bool resultFirst, FSharpList`1<Typar> generalizable, TType ty, FSharpList`1<TyparConstraint> constraints);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckWarnIfRigid(ConstraintSolverEnv csenv, TType ty1, Typar r, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTyparEqualsType(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty1, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> solveTypMeetsTyparConstraints(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty, Typar r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveAnonInfoEqualsAnonInfo(ConstraintSolverEnv csenv, range m2, AnonRecdTypeInfo anonInfo1, AnonRecdTypeInfo anonInfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsType(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsTypeKeepAbbrevs(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsTypeKeepAbbrevsWithCxsln(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    internal static OperationResult`1<Unit> loop@915-70(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, FSharpList`1<TType> origl1, FSharpList`1<TType> origl2, FSharpList`1<TType> l1, FSharpList`1<TType> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsTypeEqns(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, FSharpList`1<TType> origl1, FSharpList`1<TType> origl2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveFunTypeEqn(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType d1, TType d2, TType r1, TType r2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSubsumesType(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSubsumesTypeKeepAbbrevs(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTyparSubtypeOfType(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, Typar tp, TType ty1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> DepthCheck(int ndeep, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveDimensionlessNumericType(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> SolveMemberConstraint$cont@1399(range m2, string nm, range m, DisplayEnv denv, FSharpList`1<TType> tys, Unit unitVar);
    internal static bool checkRuleAppliesInPreferenceToMethods@1138(bool permitWeakResolution, TcGlobals g, FSharpList`1<MethInfo> minfos, TType argty1, TType argty2);
    internal static bool checkRuleAppliesInPreferenceToMethods@1138-1(bool permitWeakResolution, TcGlobals g, FSharpList`1<MethInfo> minfos, TType argty1, TType argty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> SolveMemberConstraint(ConstraintSolverEnv csenv, bool ignoreUnresolvedOverload, bool permitWeakResolution, int ndeep, range m2, OptionalTrace trace, TraitConstraintInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> RecordMemberConstraintSolution(ConstraintSolverState css, range m, OptionalTrace trace, TraitConstraintInfo traitInfo, TraitConstraintSolution res);
    [CompilerGeneratedAttribute]
internal static TraitConstraintSln MemberConstraintSolutionOfMethInfo$cont@1526(ConstraintSolverState css, MethInfo minfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TraitConstraintSln MemberConstraintSolutionOfMethInfo(ConstraintSolverState css, range m, MethInfo minfo, FSharpList`1<TType> minst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TransactMemberConstraintSolution(TraitConstraintInfo traitInfo, OptionalTrace trace, TraitConstraintSln sln);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetRelevantMethodsForTrait(ConstraintSolverEnv csenv, bool permitWeakResolution, string nm, TraitConstraintInfo _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> GetSupportOfMemberConstraint(ConstraintSolverEnv csenv, TraitConstraintInfo _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool SupportOfMemberConstraintIsFullySolved(ConstraintSolverEnv csenv, TraitConstraintInfo _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> GetFreeTyparsOfMemberConstraint(ConstraintSolverEnv csenv, TraitConstraintInfo _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberConstraintIsReadyForWeakResolution(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberConstraintIsReadyForStrongResolution(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberConstraintSupportIsReadyForDeterminingOverloads(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveRelevantMemberConstraints(ConstraintSolverEnv csenv, int ndeep, bool permitWeakResolution, OptionalTrace trace, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> SolveRelevantMemberConstraintsForTypar(ConstraintSolverEnv csenv, int ndeep, bool permitWeakResolution, OptionalTrace trace, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CanonicalizeRelevantMemberConstraints(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> AddMemberConstraint(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TraitConstraintInfo traitInfo, FSharpList`1<Typar> support, FSharpList`1<Typar> frees);
    internal static FSharpList`1<TType> collect@1712(TcGlobals g, ImportMap amap, range m, TType ty);
    internal static OperationResult`1<Unit> consistent@1686(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TcGlobals g, ImportMap amap, range m, TyparConstraint tpc1, TyparConstraint tpc2);
    internal static bool implies@1758(TcGlobals g, TypeEquivEnv aenv, ImportMap amap, range m, TyparConstraint tpc1, TyparConstraint tpc2);
    internal static OperationResult`1<Unit> enforceMutualConsistency@1793(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TcGlobals g, ImportMap amap, range m, FSharpList`1<TyparConstraint> allCxs, int i, FSharpList`1<TyparConstraint> cxs);
    internal static FSharpList`1<TyparConstraint> eliminateRedundant@1825(TcGlobals g, TypeEquivEnv aenv, ImportMap amap, range m, FSharpList`1<TyparConstraint> cxs, FSharpList`1<TyparConstraint> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> AddConstraint(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, Typar tp, TyparConstraint newConstraint);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSupportsNull(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSupportsComparison(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSupportsEquality(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsEnum(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty, TType underlying);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsDelegate(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty, TType aty, TType bty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsNonNullableValueType(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsUnmanaged(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeChoice(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsReferenceType(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType ty);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> SolveTypeRequiresDefaultConstructor$cont@2043(ConstraintSolverEnv csenv, range m2, TType origTy, TcGlobals g, ImportMap amap, range m, DisplayEnv denv, TType ty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeRequiresDefaultConstructor(ConstraintSolverEnv csenv, int ndeep, range m2, OptionalTrace trace, TType origTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CanMemberSigsMatchUpToCheck(ConstraintSolverEnv csenv, bool permitOptArgs, bool alwaysCheckReturn, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<Unit>>> unifyTypes, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<Unit>>> subsumeTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CallerArg`1<a>, OperationResult`1<Unit>>> subsumeArg, FSharpOption`1<TType> reqdRetTyOpt, CalledMeth`1<a> calledMeth);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSubsumesTypeWithReport(ConstraintSolverEnv csenv, int ndeep, range m, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsTypeWithReport(ConstraintSolverEnv csenv, int ndeep, range m, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType actual, TType expected);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> ArgsMustSubsumeOrConvert(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, bool isConstraint, CalledArg calledArg, CallerArg`1<T> callerArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> MustUnify(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> ArgsMustSubsumeOrConvertInsideUndo(ConstraintSolverEnv csenv, int ndeep, Trace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, bool isConstraint, CalledArg calledArg, CallerArg`1<b> _arg6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> TypesMustSubsumeOrConvertInsideUndo(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, range m, TType calledArgTy, TType callerArgTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> ArgsEquivInsideUndo(ConstraintSolverEnv csenv, bool isConstraint, CalledArg calledArg, CallerArg`1<c> _arg7);
    [CompilerGeneratedAttribute]
internal static Exception ReportNoCandidatesError$cont@2269(string methodName, FSharpFunc`2<d, bool> isSequential, range m, CalledMeth`1<d> cmeth, MethInfo minfo, int nReqd, int nActual, string signature, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Exception ReportNoCandidatesError$cont@2222-1(int nUnnamedCallerArgs, int nNamedCallerArgs, string methodName, AccessorDomain ad, FSharpList`1<CalledMeth`1<d>> calledMethGroup, range m, Tuple`2<FSharpList`1<CalledMeth`1<d>>, FSharpList`1<CalledMeth`1<d>>> matchValue_2, Tuple`2<FSharpList`1<CalledMeth`1<d>>, FSharpList`1<CalledMeth`1<d>>> matchValue_3, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<e> ReportNoCandidatesError(ConstraintSolverEnv csenv, int nUnnamedCallerArgs, int nNamedCallerArgs, string methodName, AccessorDomain ad, FSharpList`1<CalledMeth`1<d>> calledMethGroup, FSharpFunc`2<d, bool> isSequential);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<f> ReportNoCandidatesErrorExpr(ConstraintSolverEnv csenv, int callerArgCounts_0, int callerArgCounts_1, string methodName, AccessorDomain ad, FSharpList`1<CalledMeth`1<Expr>> calledMethGroup);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<g> ReportNoCandidatesErrorSynExpr(ConstraintSolverEnv csenv, int callerArgCounts_0, int callerArgCounts_1, string methodName, AccessorDomain ad, FSharpList`1<CalledMeth`1<SynExpr>> calledMethGroup);
    internal static Exception failOverloading@2410(FSharpList`1<CalledMeth`1<Expr>> calledMethGroup, FSharpOption`1<TType> reqdRetTyOpt, ImportMap amap, range m, DisplayEnv denv, bool isOpConversion, string msg, FSharpList`1<Tuple`2<CalledMeth`1<h>, Exception>> errors);
    internal static FSharpFunc`2<T, FSharpFunc`2<T, int>> compareCond@2464(FSharpFunc`2<T, FSharpFunc`2<T, bool>> p);
    internal static int compareTypes@2468(ConstraintSolverEnv csenv, int ndeep, range m, TType ty1, TType ty2);
    [CompilerGeneratedAttribute]
internal static int better$cont@2557-2(CalledMeth`1<h> candidate, CalledMeth`1<k> other, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int better$cont@2528-1(range m, FSharpFunc`2<TType, FSharpFunc`2<TType, int>> compareTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CalledArg, int>> compareArg, CalledMeth`1<h> candidate, CalledMeth`1<k> other, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int better$cont@2510(ConstraintSolverEnv csenv, int ndeep, range m, FSharpFunc`2<TType, FSharpFunc`2<TType, int>> compareTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CalledArg, int>> compareArg, CalledMeth`1<h> candidate, CalledMeth`1<k> other, Unit unitVar);
    internal static int better@2496(ConstraintSolverEnv csenv, int ndeep, range m, FSharpFunc`2<TType, FSharpFunc`2<TType, int>> compareTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CalledArg, int>> compareArg, CalledMeth`1<h> tupledArg0, FSharpList`1<i> tupledArg1, j tupledArg2, CalledMeth`1<k> tupledArg0@2496, FSharpList`1<l> tupledArg1@2496, m tupledArg2@2496);
    [CompilerGeneratedAttribute]
internal static Tuple`3<FSharpOption`1<CalledMeth`1<Expr>>, OperationResult`1<Unit>, OptionalTrace> ResolveOverloading$cont@2464(ConstraintSolverEnv csenv, string methodName, int ndeep, FSharpList`1<CalledMeth`1<Expr>> calledMethGroup, FSharpOption`1<TType> reqdRetTyOpt, TcGlobals g, ImportMap amap, range m, DisplayEnv denv, bool isOpConversion, FSharpList`1<CalledMeth`1<Expr>> candidates, FSharpList`1<Tuple`3<CalledMeth`1<Expr>, FSharpList`1<Exception>, Trace>> applicableMeths, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<CalledMeth`1<Expr>>, OperationResult`1<Unit>> ResolveOverloading(ConstraintSolverEnv csenv, OptionalTrace trace, string methodName, int ndeep, FSharpOption`1<TraitConstraintInfo> cx, int callerArgCounts_0, int callerArgCounts_1, AccessorDomain ad, FSharpList`1<CalledMeth`1<Expr>> calledMethGroup, bool permitOptArgs, FSharpOption`1<TType> reqdRetTyOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> UnifyUniqueOverloading(ConstraintSolverEnv csenv, int callerArgCounts_0, int callerArgCounts_1, string methodName, AccessorDomain ad, FSharpList`1<CalledMeth`1<SynExpr>> calledMethGroup, TType reqdRetTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EliminateConstraintsForGeneralizedTypars(ConstraintSolverEnv csenv, OptionalTrace trace, FSharpList`1<Typar> generalizedTypars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeEqualsType(ContextInfo contextInfo, DisplayEnv denv, ConstraintSolverState css, range m, TType actual, TType expected);
    internal static bool UndoIfFailed(FSharpFunc`2<Trace, OperationResult`1<a>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool AddCxTypeEqualsTypeUndoIfFailed(DisplayEnv denv, ConstraintSolverState css, range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool AddCxTypeEqualsTypeMatchingOnlyUndoIfFailed(DisplayEnv denv, ConstraintSolverState css, range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool AddCxTypeMustSubsumeTypeUndoIfFailed(DisplayEnv denv, ConstraintSolverState css, range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool AddCxTypeMustSubsumeTypeMatchingOnlyUndoIfFailed(DisplayEnv denv, ConstraintSolverState css, range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeMustSubsumeType(ContextInfo contextInfo, DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxMethodConstraint(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeMustSupportNull(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeMustSupportComparison(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeMustSupportEquality(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeMustSupportDefaultCtor(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsReferenceType(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsValueType(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsUnmanaged(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsEnum(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty, TType underlying);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsDelegate(DisplayEnv denv, ConstraintSolverState css, range m, OptionalTrace trace, TType ty, TType aty, TType bty);
    [CompilerGeneratedAttribute]
internal static FSharpChoice`5<Tuple`2<MethInfo, FSharpList`1<TType>>, Tuple`3<FSharpList`1<TType>, RecdFieldRef, bool>, Tuple`3<AnonRecdTypeInfo, FSharpList`1<TType>, int>, Expr, Unit> sln$cont@2821(TcGlobals g, ImportMap amap, range m, FSharpOption`1<TraitConstraintSln> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<FSharpOption`1<Expr>> CodegenWitnessThatTypeSupportsTraitConstraint$cont@2846(TcGlobals g, ImportMap amap, range m, TraitConstraintInfo traitInfo, FSharpList`1<Expr> argExprs, FSharpChoice`5<Tuple`2<MethInfo, FSharpList`1<TType>>, Tuple`3<FSharpList`1<TType>, RecdFieldRef, bool>, Tuple`3<AnonRecdTypeInfo, FSharpList`1<TType>, int>, Expr, Unit> sln, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<FSharpOption`1<Expr>> CodegenWitnessThatTypeSupportsTraitConstraint$cont@2877-1(TcGlobals g, range m, FSharpList`1<Expr> argExprs, FSharpChoice`5<Tuple`2<MethInfo, FSharpList`1<TType>>, Tuple`3<FSharpList`1<TType>, RecdFieldRef, bool>, Tuple`3<AnonRecdTypeInfo, FSharpList`1<TType>, int>, Expr, Unit> sln, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<FSharpOption`1<Expr>> CodegenWitnessThatTypeSupportsTraitConstraint(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, range m, TraitConstraintInfo traitInfo, FSharpList`1<Expr> argExprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ChooseTyparSolutionAndSolve(ConstraintSolverState css, DisplayEnv denv, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDeclaredTypars(DisplayEnv denv, ConstraintSolverState css, range m, FSharpList`1<Typar> typars1, FSharpList`1<Typar> typars2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsApplicableMethApprox(TcGlobals g, ImportMap amap, range m, MethInfo minfo, TType availObjTy);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Detuple : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<TupleStructure>, FSharpFunc`2<FSharpList`1<TupleStructure>, int>> callPatternOrder { get; }
    internal static FSharpOption`1<Tuple`5<Expr, TType, FSharpList`1<TType>, FSharpList`1<Expr>, range>> |TyappAndApp|_|(Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val mkLocalVal(range m, string name, TType ty, FSharpOption`1<ValReprInfo> topValInfo);
    internal static FSharpList`1<FSharpList`1<ArgReprInfo>> ValReprInfoForTS(TupleStructure ts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TupleStructure andTS(TupleStructure ts, TupleStructure tsB);
    internal static TupleStructure checkTS(TupleStructure _arg1);
    internal static TupleStructure uncheckedExprTS(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TupleStructure uncheckedTypeTS(TcGlobals g, TType ty);
    internal static Tuple`2<Tuple`2<Expr, TType>, FSharpList`1<Val>> rebuild@379(TcGlobals g, range m, FSharpList`1<Val> vs, TupleStructure ts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr rebuildTS(TcGlobals g, range m, TupleStructure ts, FSharpList`1<Val> vs);
    internal static FSharpFunc`2<FSharpList`1<TupleStructure>, FSharpFunc`2<FSharpList`1<TupleStructure>, int>> get_callPatternOrder();
    internal static FSharpList`1<TupleStructure> minimalCallPattern(FSharpList`1<TupleStructure> callPattern);
    internal static FSharpList`1<TupleStructure> andCPs@416(FSharpList`1<TupleStructure> cpA, FSharpList`1<TupleStructure> cpB);
    internal static FSharpList`1<TupleStructure> commonCallPattern(FSharpList`1<FSharpList`1<TupleStructure>> callPatterns);
    internal static FSharpList`1<TupleStructure> siteCP(a _accessors, b _inst, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Transform mkTransform(TcGlobals g, Val f, range m, FSharpList`1<Typar> tps, FSharpList`1<TType> x1Ntys, TType rty, FSharpList`1<TupleStructure> callPattern, FSharpList`1<Tuple`2<FSharpList`1<TType>, FSharpList`1<Val>>> tyfringes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TupleStructure, FSharpList`1<TType>> zipTupleStructureAndType(TcGlobals g, TupleStructure ts, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TupleStructure>, FSharpList`1<TType>> zipTupleStructuresAndTypes(TcGlobals g, FSharpList`1<TupleStructure> tss, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TupleStructure>, FSharpList`1<Tuple`2<FSharpList`1<TType>, FSharpList`1<Val>>>> zipCallPatternArgTys(range m, TcGlobals g, FSharpList`1<TupleStructure> callPattern, FSharpList`1<FSharpList`1<Val>> vss);
    internal static TupleStructure trimTsByAccess@534(FSharpList`1<accessor> accessors, TupleStructure ts);
    internal static FSharpFunc`2<TupleStructure, FSharpFunc`2<Tuple`3<FSharpList`1<accessor>, a, b>, TupleStructure>> trim@546();
    internal static TupleStructure trimTsByVal@542(Results z, TupleStructure ts, Val v);
    internal static FSharpFunc`2<TupleStructure, FSharpFunc`2<FSharpList`1<Val>, TupleStructure>> trimTsByFormal@549(FSharpFunc`2<Results, FSharpFunc`2<TupleStructure, FSharpFunc`2<Val, TupleStructure>>> trimTsByVal, Results z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TupleStructure> decideFormalSuggestedCP(TcGlobals g, Results z, FSharpList`1<TType> tys, FSharpList`1<FSharpList`1<Val>> vss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Val, Transform>> decideTransform(TcGlobals g, Results z, Val v, FSharpList`1<FSharpList`1<TupleStructure>> callPatterns, range m, FSharpList`1<Typar> tps, FSharpList`1<FSharpList`1<Val>> vss, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eligibleVal(TcGlobals g, range m, Val v);
    internal static FSharpFunc`2<Val, FSharpFunc`2<FSharpList`1<Tuple`3<a, b, FSharpList`1<Expr>>>, FSharpOption`1<Tuple`2<Val, Transform>>>> selectTransform@604(TcGlobals g, Results z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Val, Transform, IComparer`1<Val>> determineTransforms(TcGlobals g, Results z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static env suffixE(env env, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> newLocalN(env env, int i, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, Expr> noEffectExpr(env env, FSharpList`1<Binding> bindings, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Expr>> buildProjections(env env, FSharpList`1<Binding> bindings, Expr x, FSharpList`1<TType> xtys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Expr>> collapseArg(env env, FSharpList`1<Binding> bindings, TupleStructure ts, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Expr>> collapseArgs(env env, FSharpList`1<Binding> bindings, int n, FSharpList`1<TupleStructure> callPattern, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLets(FSharpList`1<Binding> binds, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr fixupApp(penv penv, Expr fx, TType fty, FSharpList`1<TType> tys, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Val>> transFormal(TransformedFormal ybi, FSharpList`1<Val> xi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> transRebind(TransformedFormal ybi, FSharpList`1<Val> xi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding passBind(penv penv, Binding _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> postTransformExpr(penv penv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypedImplFile passImplFile(penv penv, TypedImplFile assembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypedImplFile DetupleImplFile(CcuThunk ccu, TcGlobals g, TypedImplFile expr);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.DiagnosticMessage : object {
    [CompilationMappingAttribute("9")]
internal static Type funTyC { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object mkFunctionValue(Type[] tys, FSharpFunc`2<object, object> impl);
    internal static Type get_funTyC();
    internal static bool isNamedType(Type ty);
    internal static bool isFunctionType(Type ty1);
    internal static Tuple`2<Type, Type[]> destFunTy(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object buildFunctionForOneArgPat(Type ty, FSharpFunc`2<Type, FSharpFunc`2<object, object>> impl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object capture1(string fmt, int i, FSharpList`1<object> args, Type ty, FSharpFunc`2<FSharpList`1<object>, FSharpFunc`2<Type, FSharpFunc`2<int, object>>> go);
    internal static object capture@73-6(string messageString, string fmt, int len, FSharpList`1<object> args, Type ty, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T createMessageString(string messageString, PrintfFormat`4<T, Unit, string, string> fmt);
    internal static ResourceString`1<T> DeclareResourceString(string messageID, PrintfFormat`4<T, Unit, string, string> fmt);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.DotNetFrameworkDependencies : object {
    internal static string getFSharpCoreLibraryName { get; }
    internal static string getFsiLibraryName { get; }
    [CompilationMappingAttribute("9")]
internal static string frameworkDir { get; }
    [CompilationMappingAttribute("9")]
internal static string getDefaultFSharpCoreReference { get; }
    [CompilationMappingAttribute("9")]
internal static string getFSharpCompilerLocation { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> executionTfm { get; }
    [CompilationMappingAttribute("9")]
internal static string file@82 { get; }
    [CompilationMappingAttribute("9")]
internal static string pattern@89 { get; }
    [CompilationMappingAttribute("9")]
internal static int startPos@90 { get; }
    [CompilationMappingAttribute("9")]
internal static int startPos@91-1 { get; }
    [CompilationMappingAttribute("9")]
internal static int length@94 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> getFrameworkRefsPackDirectoryPath { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> getFrameworkRefsPackDirectory { get; }
    [CompilationMappingAttribute("9")]
internal static HashSet`1<string> systemAssemblies { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_getFSharpCoreLibraryName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_getFsiLibraryName();
    internal static string get_frameworkDir();
    internal static string get_getDefaultFSharpCoreReference();
    internal static string get_getFSharpCompilerLocation();
    internal static FSharpOption`1<string> getDefaultSystemValueTupleReference();
    internal static ValueTuple`4<int, int, int, string> deconstructVersion(string version);
    [CompilerGeneratedAttribute]
internal static int versionCompare$cont@62(string c1, string c2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int versionCompare(string c1, string c2);
    internal static FSharpOption`1<string> get_executionTfm();
    internal static string get_file@82();
    internal static string get_pattern@89();
    internal static int get_startPos@90();
    internal static int get_startPos@91-1();
    internal static int get_length@94();
    internal static FSharpOption`1<string> get_getFrameworkRefsPackDirectoryPath();
    internal static bool isInReferenceAssemblyPackDirectory(string filename);
    internal static FSharpOption`1<string> get_getFrameworkRefsPackDirectory();
    internal static string frameworkPathFromSimpleName@138(string simpleName);
    internal static void traverseDependencies@150(Dictionary`2<string, string> assemblies, string reference);
    internal static Dictionary`2<string, string> getDependenciesOf(FSharpList`1<string> assemblyReferences);
    internal static FSharpList`1<string> getDesktopDefaultReferences(bool useFsiAuxLib);
    internal static FSharpList`1<string> getImplementationReferences@226(bool useFsiAuxLib, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> fetchPathsForDefaultReferencesForScriptsAndOutOfProjectSources(bool useFsiAuxLib, bool useSdkRefs, bool assumeDotNetFramework);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> defaultReferencesForScriptsAndOutOfProjectSources(bool assumeDotNetFramework, bool useSdkRefs);
    internal static HashSet`1<string> get_systemAssemblies();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> basicReferencesForScriptLoadClosure(bool useFsiAuxLib, bool useSdkRefs, bool assumeDotNetFramework);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Driver : object {
    [CompilationMappingAttribute("9")]
internal static string DefaultFSharpBinariesDir { get; }
    internal static ErrorLogger ConsoleErrorLoggerUpToMaxErrors(TcConfigBuilder tcConfigB, Exiter exiter);
    internal static void AbortOnError(ErrorLogger errorLogger, Exiter exiter);
    internal static Tuple`4<TcState, TopAttribs, FSharpList`1<TypedImplFile>, TcEnv> TypeCheck(CompilationThreadToken ctok, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, ErrorLogger errorLogger, string assemblyName, NiceNameGenerator niceNameGen, TcEnv tcEnv0, FSharpList`1<ParsedInput> inputs, Exiter exiter);
    [CompilerGeneratedAttribute]
internal static bool contains@1-15(a e, FSharpList`1<a> xs1);
    internal static void AddIfNotPresent@219(FSharpRef`1<FSharpList`1<string>> allSources, string filename);
    internal static FSharpList`1<string> AdjustForScriptCompile(CompilationThreadToken ctok, TcConfigBuilder tcConfigB, FSharpList`1<string> commandLineSourceFiles, LexResourceManager lexResourceManager);
    internal static FSharpList`1<string> ProcessCommandLineFlags(TcConfigBuilder tcConfigB, FSharpFunc`2<TcConfigBuilder, Unit> setProcessThreadLocals, FSharpOption`1<int> lcidFromCodePage, String[] argv);
    internal static string get_DefaultFSharpBinariesDir();
    internal static bool GenerateInterfaceData(TcConfig tcConfig);
    internal static Tuple`2<FSharpList`1<ILAttribute>, FSharpList`1<ILResource>> EncodeInterfaceData(TcConfig tcConfig, TcGlobals tcGlobals, Remap exportRemapping, CcuThunk generatedCcu, string outfile, bool isIncrementalBuild);
    internal static FSharpList`1<ILResource> EncodeOptimizationData(TcGlobals tcGlobals, TcConfig tcConfig, string outfile, Remap exportRemapping, Tuple`2<CcuThunk, a> data, bool isIncrementalBuild);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1600-68(StrongNameSigningInfo this, StrongNameSigningInfo obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1600-69(IComparer comp, StrongNameSigningInfo this, StrongNameSigningInfo objTemp, Unit unitVar);
    internal static StrongNameSigningInfo ValidateKeySigningAttributes(TcConfig tcConfig, TcGlobals tcGlobals, TopAttribs topAttrs);
    internal static FSharpOption`1<ILStrongNameSigner> GetStrongNameSigner(StrongNameSigningInfo signingInfo);
    internal static void copyFileIfDifferent@1681(string src, string dest);
    internal static void CopyFSharpCore(string outFile, FSharpList`1<AssemblyReference> referencedDlls);
    internal static void displayBannerIfNeeded@1732(bool bannerAlreadyPrinted, TcConfigBuilder tcConfigB);
    internal static FSharpFunc`2<b, FSharpOption`1<c>> tryGetMetadataSnapshot@1737();
    internal static Args`1<Tuple`8<a, TcGlobals, TcImports, TcImports, CcuThunk, FSharpList`1<TypedImplFile>, TopAttribs, Tuple`6<TcConfig, string, FSharpOption`1<string>, string, ErrorLogger, Exiter>>> main0(a ctok, String[] argv, Resolver legacyReferenceResolver, bool bannerAlreadyPrinted, ReduceMemoryFlag reduceMemoryUsage, CopyFSharpCoreFlag defaultCopyFSharpCore, Exiter exiter, ErrorLoggerProvider errorLoggerProvider, DisposablesTracker disposables);
    internal static Args`1<Tuple`8<a, TcConfig, TcImports, c, b, ErrorLogger, CcuThunk, Tuple`8<e, d, TopAttribs, f, string, FSharpOption`1<ILVersionInfo>, StrongNameSigningInfo, Tuple`1<Exiter>>>> main1(Args`1<Tuple`8<a, b, TcImports, c, CcuThunk, d, TopAttribs, Tuple`6<TcConfig, e, f, string, g, Exiter>>> _arg1);
    internal static FSharpFunc`2<e, FSharpOption`1<f>> tryGetMetadataSnapshot@1935-2();
    internal static Args`1<Tuple`8<a, TcConfig, TcImports, TcImports, TcGlobals, ErrorLogger, CcuThunk, Tuple`8<b, FSharpList`1<TypedImplFile>, TopAttribs, FSharpOption`1<c>, string, FSharpOption`1<ILVersionInfo>, StrongNameSigningInfo, Tuple`1<d>>>> main1OfAst(a ctok, Resolver legacyReferenceResolver, ReduceMemoryFlag reduceMemoryUsage, string assemblyName, CompilerTarget target, b outfile, FSharpOption`1<c> pdbFile, FSharpList`1<string> dllReferences, bool noframework, d exiter, ErrorLoggerProvider errorLoggerProvider, FSharpList`1<ParsedInput> inputs);
    internal static Args`1<Tuple`8<a, TcConfig, TcImports, b, ErrorLogger, CcuThunk, string, Tuple`8<TypedAssemblyAfterOptimization, c, d, e, Tuple`2<FSharpList`1<ILAttribute>, FSharpList`1<ILResource>>, FSharpList`1<ILResource>, f, Tuple`3<g, string, Exiter>>>> main2a(Args`1<Tuple`8<a, TcConfig, TcImports, TcImports, b, ErrorLogger, CcuThunk, Tuple`8<string, FSharpList`1<TypedImplFile>, c, d, e, f, g, Tuple`1<Exiter>>>> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Args`1<Tuple`8<b, TcConfig, TcImports, TcGlobals, c, FSharpFunc`2<ILModuleDef, ILModuleDef>, string, Tuple`4<FSharpOption`1<d>, ILModuleDef, h, Exiter>>> main2b(FSharpOption`1<FSharpFunc`2<TcImports, Unit>> tcImportsCapture, FSharpOption`1<a> dynamicAssemblyCreator, Args`1<Tuple`8<b, TcConfig, TcImports, TcGlobals, c, CcuThunk, string, Tuple`8<TypedAssemblyAfterOptimization, TopAttribs, FSharpOption`1<d>, string, Tuple`2<e, f>, g, FSharpOption`1<ILVersionInfo>, Tuple`3<h, string, Exiter>>>> _arg1);
    internal static Args`1<Tuple`8<a, b, c, d, ErrorLogger, f, g, Tuple`3<h, i, Exiter>>> main3(Args`1<Tuple`8<a, b, c, d, ErrorLogger, FSharpFunc`2<e, f>, g, Tuple`4<h, e, i, Exiter>>> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void main4(FSharpOption`1<FSharpFunc`2<Tuple`3<TcGlobals, string, ILModuleDef>, Unit>> dynamicAssemblyCreator, Args`1<Tuple`8<a, TcConfig, TcImports, TcGlobals, ErrorLogger, ILModuleDef, string, Tuple`3<FSharpOption`1<string>, StrongNameSigningInfo, Exiter>>> _arg1);
    internal static void typecheckAndCompile(CompilationThreadToken ctok, String[] argv, Resolver legacyReferenceResolver, bool bannerAlreadyPrinted, ReduceMemoryFlag reduceMemoryUsage, CopyFSharpCoreFlag defaultCopyFSharpCore, Exiter exiter, ErrorLoggerProvider loggerProvider, FSharpOption`1<FSharpFunc`2<TcImports, Unit>> tcImportsCapture, FSharpOption`1<FSharpFunc`2<Tuple`3<TcGlobals, string, ILModuleDef>, Unit>> dynamicAssemblyCreator);
    internal static void compileOfAst(CompilationThreadToken ctok, Resolver legacyReferenceResolver, ReduceMemoryFlag reduceMemoryUsage, string assemblyName, CompilerTarget target, string targetDll, FSharpOption`1<string> targetPdb, FSharpList`1<string> dependencies, bool noframework, Exiter exiter, ErrorLoggerProvider loggerProvider, FSharpList`1<ParsedInput> inputs, FSharpOption`1<FSharpFunc`2<TcImports, Unit>> tcImportsCapture, FSharpOption`1<FSharpFunc`2<Tuple`3<TcGlobals, string, ILModuleDef>, Unit>> dynamicAssemblyCreator);
    internal static void mainCompile(CompilationThreadToken ctok, String[] argv, Resolver legacyReferenceResolver, bool bannerAlreadyPrinted, ReduceMemoryFlag reduceMemoryUsage, CopyFSharpCoreFlag defaultCopyFSharpCore, Exiter exiter, ErrorLoggerProvider loggerProvider, FSharpOption`1<FSharpFunc`2<TcImports, Unit>> tcImportsCapture, FSharpOption`1<FSharpFunc`2<Tuple`3<TcGlobals, string, ILModuleDef>, Unit>> dynamicAssemblyCreator);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.ErrorLogger : object {
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<FSharpFunc`2<string, Unit>, Unit> NoSuggestions { get; }
    [CompilationMappingAttribute("9")]
public static Exiter QuitProcessExiter { get; }
    [CompilationMappingAttribute("9")]
public static ErrorLogger DiscardErrorsLogger { get; }
    [CompilationMappingAttribute("9")]
public static ErrorLogger AssertFalseErrorLogger { get; }
    [CompilationMappingAttribute("9")]
public static bool reportLibraryOnlyFeatures { get; public set; }
    [CompilationMappingAttribute("9")]
public static OperationResult`1<Unit> CompleteD { get; }
    [CompilationMappingAttribute("9")]
public static TrackErrorsBuilder trackErrors { get; }
    [CompilationMappingAttribute("9")]
public static string stringThatIsAProxyForANewlineInFlatErrors { get; }
    public static Exception findOriginalException(Exception err);
    public static FSharpFunc`2<FSharpFunc`2<string, Unit>, Unit> get_NoSuggestions();
    public static FSharpOption`1<Unit> |StopProcessing|_|(Exception exn);
    public static Exception StopProcessing();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a protectAssemblyExploration(a dflt, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a protectAssemblyExplorationF(FSharpFunc`2<Tuple`2<string, string>, a> dflt, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a protectAssemblyExplorationNoReraise(a dflt1, a dflt2, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Exception AttachRange(range m, Exception exn);
    public static Exiter get_QuitProcessExiter();
    public static ErrorLogger get_DiscardErrorsLogger();
    public static ErrorLogger get_AssertFalseErrorLogger();
    internal static void action@1-4(ErrorLogger errorLogger, PhasedDiagnostic tupledArg0, bool tupledArg1);
    public static IDisposable PushThreadBuildPhaseUntilUnwind(BuildPhase phase);
    public static IDisposable PushErrorLoggerPhaseUntilUnwind(FSharpFunc`2<ErrorLogger, a> errorLoggerTransformer);
    public static void SetThreadBuildPhaseNoUnwind(BuildPhase phase);
    public static void SetThreadErrorLoggerNoUnwind(ErrorLogger errorLogger);
    public static void errorR(Exception exn);
    public static void warning(Exception exn);
    public static a error(Exception exn);
    public static a simulateError(PhasedDiagnostic p);
    public static void diagnosticSink(PhasedDiagnostic phasedError, bool isError);
    public static void errorSink(PhasedDiagnostic pe);
    public static void warnSink(PhasedDiagnostic pe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void errorRecovery(Exception exn, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void stopProcessingRecovery(Exception exn, range m);
    public static void errorRecoveryNoRange(Exception exn);
    public static a report(FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deprecatedWithError(string s, range m);
    public static bool get_reportLibraryOnlyFeatures();
    public static void set_reportLibraryOnlyFeatures(bool value);
    public static void libraryOnlyError(range m);
    public static void libraryOnlyWarning(range m);
    public static void deprecatedOperator(range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void mlCompatWarning(string s, range m);
    public static a suppressErrorReporting(FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a conditionallySuppressErrorReporting(bool cond, FSharpFunc`2<Unit, a> f);
    public static void ReportWarnings(FSharpList`1<a> warns);
    public static a CommitOperationResult(OperationResult`1<a> res);
    public static void RaiseOperationResult(OperationResult`1<Unit> res);
    public static OperationResult`1<a> ErrorD(Exception err);
    public static OperationResult`1<Unit> WarnD(Exception err);
    public static OperationResult`1<Unit> get_CompleteD();
    public static OperationResult`1<a> ResultD(a x);
    public static FSharpOption`1<FSharpList`1<Exception>> CheckNoErrorsAndGetWarnings(OperationResult`1<a> res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<b> op_PlusPlus(OperationResult`1<a> res, FSharpFunc`2<a, OperationResult`1<b>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<Unit> IterateD(FSharpFunc`2<a, OperationResult`1<Unit>> f, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<Unit> WhileD(FSharpFunc`2<Unit, bool> gd, FSharpFunc`2<Unit, OperationResult`1<Unit>> body);
    internal static OperationResult`1<FSharpList`1<b>> loop@569-33(FSharpFunc`2<a, OperationResult`1<b>> f, FSharpList`1<b> acc, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<FSharpList`1<b>> MapD(FSharpFunc`2<a, OperationResult`1<b>> f, FSharpList`1<a> xs);
    public static TrackErrorsBuilder get_trackErrors();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<Unit> OptionD(FSharpFunc`2<a, OperationResult`1<Unit>> f, FSharpOption`1<a> xs);
    internal static OperationResult`1<Unit> loop@597-35(FSharpFunc`2<int, FSharpFunc`2<a, OperationResult`1<Unit>>> f, FSharpList`1<a> xs, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<Unit> IterateIdxD(FSharpFunc`2<int, FSharpFunc`2<a, OperationResult`1<Unit>>> f, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<Unit> Iterate2D(FSharpFunc`2<a, FSharpFunc`2<b, OperationResult`1<Unit>>> f, FSharpList`1<a> xs, FSharpList`1<b> ys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<a> TryD(FSharpFunc`2<Unit, OperationResult`1<a>> f, FSharpFunc`2<Exception, OperationResult`1<a>> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<Unit> RepeatWhileD(int ndeep, FSharpFunc`2<int, OperationResult`1<bool>> body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationResult`1<bool> AtLeastOneD(FSharpFunc`2<a, OperationResult`1<bool>> f, FSharpList`1<a> l);
    public static string get_stringThatIsAProxyForANewlineInFlatErrors();
    public static string NewlineifyErrorString(string message);
    public static string NormalizeErrorString(string text);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@661(FSharpErrorSeverityOptions this, FSharpErrorSeverityOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@661-1(IComparer comp, FSharpErrorSeverityOptions this, FSharpErrorSeverityOptions objTemp, int n, Unit unitVar);
    public static void dummyMethodFOrBug6417A();
    public static void dummyMethodFOrBug6417B();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.ErrorResolutionHints : object {
    internal static int maxSuggestions { get; }
    internal static double minThresholdForSuggestions { get; }
    internal static double highConfidenceThreshold { get; }
    internal static int minStringLengthForSuggestion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_maxSuggestions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double get_minThresholdForSuggestions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double get_highConfidenceThreshold();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_minStringLengthForSuggestion();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsInEditDistanceProximity(string idText, string suggestion);
    internal static string DemangleOperator(string nm);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.ExtensionTyping : object {
    internal static BindingFlags bindingFlags { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<Type> providedSystemTypeComparer { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@27-40(ResolutionEnvironment this, ResolutionEnvironment obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@27-41(IComparer comp, ResolutionEnvironment this, ResolutionEnvironment objTemp, Unit unitVar);
    internal static FSharpList`1<string> toolingCompatibleVersions();
    internal static FSharpList`1<string> toolingCompatiblePaths();
    internal static a raiseError@68(string runTimeAssemblyFileName, range m, string designTimeAssemblyNameString, Exception e);
    internal static FSharpOption`1<Assembly> loadFromLocation@75(string runTimeAssemblyFileName, range m, string designTimeAssemblyNameString, string designTimeAssemblyPath);
    internal static IEnumerable`1<FSharpOption`1<Assembly>> searchParentDirChain@81(string runTimeAssemblyFileName, range m, string designTimeAssemblyNameString, string dir, string designTimeAssemblyName);
    internal static FSharpOption`1<Assembly> loadFromParentDirRelativeToRuntimeAssemblyLocation@92(string runTimeAssemblyFileName, range m, string designTimeAssemblyNameString, string designTimeAssemblyName);
    internal static FSharpList`1<Type> GetTypeProviderImplementationTypes(string runTimeAssemblyFileName, string designTimeAssemblyNameString, range m);
    internal static Exception StripException(Exception e);
    internal static a protect@162(Type typeProviderImplementationType, range m, FSharpFunc`2<Unit, a> f);
    internal static ITypeProvider CreateTypeProvider(Type typeProviderImplementationType, string runtimeAssemblyPath, ResolutionEnvironment resolutionEnvironment, bool isInvalidationSupported, bool isInteractive, FSharpFunc`2<string, bool> systemRuntimeContainsType, Version systemRuntimeAssemblyVersion, range m);
    internal static FSharpList`1<Tainted`1<ITypeProvider>> GetTypeProvidersOfAssembly(string runtimeAssemblyFilename, ILScopeRef ilScopeRefOfRuntimeAssembly, string designerAssemblyName, ResolutionEnvironment resolutionEnvironment, bool isInvalidationSupported, bool isInteractive, FSharpFunc`2<string, bool> systemRuntimeContainsType, Version systemRuntimeAssemblyVersion, range m);
    internal static a unmarshal(Tainted`1<a> t);
    internal static Tainted`1<b> TryTypeMember(Tainted`1<a> st, string fullName, string memberName, range m, b recover, FSharpFunc`2<a, b> f);
    internal static Tainted`1[] TryTypeMemberArray(Tainted`1<a> st, string fullName, string memberName, range m, FSharpFunc`2<a, b[]> f);
    internal static Tainted`1<b> TryTypeMemberNonNull(Tainted`1<a> st, string fullName, string memberName, range m, b recover, FSharpFunc`2<a, b> f);
    internal static Tainted`1<b> TryMemberMember(Tainted`1<a> mi, string typeName, string memberName, string memberMemberName, range m, b recover, FSharpFunc`2<a, b> f);
    internal static string DisplayNameOfTypeProvider(Tainted`1<ITypeProvider> resolver, range m);
    internal static void ValidateNamespaceName(string name, Tainted`1<ITypeProvider> typeProvider, range m, string nsp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_bindingFlags();
    internal static IEqualityComparer`1<Type> get_providedSystemTypeComparer();
    internal static FSharpFunc`2<CustomAttributeNamedArgument, FSharpOption`1<CustomAttributeTypedArgument>> |Member|_|@452(string s);
    internal static FSharpOption`1<object> |Arg|_|@453(CustomAttributeTypedArgument x);
    internal static FSharpFunc`2<CustomAttributeData, bool> findAttribByName@454(string tyFullName);
    internal static bool findAttrib@455(Type ty, CustomAttributeData a);
    internal static FSharpOption`1<Tuple`2<ProvidedConstructorInfo, ProvidedExpr[]>> |ProvidedNewObjectExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<ProvidedExpr, ProvidedExpr>> |ProvidedWhileLoopExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`3<ProvidedType, ProvidedVar[], ProvidedExpr>> |ProvidedNewDelegateExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`3<FSharpOption`1<ProvidedExpr>, ProvidedMethodInfo, ProvidedExpr[]>> |ProvidedCallExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<ProvidedType> |ProvidedDefaultExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<object, ProvidedType>> |ProvidedConstantExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<ProvidedExpr, ProvidedType>> |ProvidedTypeAsExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<ProvidedExpr[]> |ProvidedNewTupleExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<ProvidedExpr, int>> |ProvidedTupleGetExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<ProvidedType, ProvidedExpr[]>> |ProvidedNewArrayExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<ProvidedExpr, ProvidedExpr>> |ProvidedSequentialExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<ProvidedVar, ProvidedExpr>> |ProvidedLambdaExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<ProvidedExpr, ProvidedExpr>> |ProvidedTryFinallyExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`5<ProvidedExpr, ProvidedVar, ProvidedExpr, ProvidedVar, ProvidedExpr>> |ProvidedTryWithExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<ProvidedExpr, ProvidedType>> |ProvidedTypeTestExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`3<ProvidedVar, ProvidedExpr, ProvidedExpr>> |ProvidedLetExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`4<ProvidedVar, ProvidedExpr, ProvidedExpr, ProvidedExpr>> |ProvidedForIntegerRangeLoopExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`2<ProvidedVar, ProvidedExpr>> |ProvidedVarSetExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<Tuple`3<ProvidedExpr, ProvidedExpr, ProvidedExpr>> |ProvidedIfThenElseExpr|_|(ProvidedExpr x);
    internal static FSharpOption`1<ProvidedVar> |ProvidedVarExpr|_|(ProvidedExpr x);
    internal static ProvidedExpr GetInvokerExpression(ITypeProvider provider, ProvidedMethodBase methodBase, ProvidedVar[] paramExprs);
    internal static string CheckAndComputeProvidedNameProperty(range m, Tainted`1<ProvidedType> st, FSharpFunc`2<ProvidedType, string> proj, string propertyString);
    internal static void ValidateAttributesOfProvidedType(range m, Tainted`1<ProvidedType> st);
    internal static FSharpList`1<string> declaringTypes@885(range m, string name, Tainted`1<ProvidedType> st, FSharpList`1<string> accu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ValidateExpectedName(range m, String[] expectedPath, string expectedName, Tainted`1<ProvidedType> st);
    internal static void ValidateProvidedTypeAfterStaticInstantiation(range m, Tainted`1<ProvidedType> st, String[] expectedPath, string expectedName);
    internal static void ValidateProvidedTypeDefinition(range m, Tainted`1<ProvidedType> st, String[] expectedPath, string expectedName);
    internal static Tainted`1<ProvidedType> ResolveProvidedType(Tainted`1<ITypeProvider> resolver, range m, String[] moduleOrNamespace, string typeName);
    internal static FSharpOption`1<Tainted`1<ProvidedType>> TryResolveProvidedType(Tainted`1<ITypeProvider> resolver, range m, String[] moduleOrNamespace, string typeName);
    internal static string nameContrib@1068(range m, Tainted`1<ProvidedType> st);
    internal static FSharpList`1<string> encContrib@1077(range m, Tainted`1<ProvidedType> st);
    internal static Tuple`2<FSharpList`1<string>, string> ILPathToProvidedType(Tainted`1<ProvidedType> st, range m);
    [CompilerGeneratedAttribute]
internal static Tuple`2<string, FSharpOption`1<string>> mapping@1-12(ProvidedParameterInfo sp);
    internal static string ComputeMangledNameForApplyStaticParameters(string nm, Object[] staticArgs, Tainted`1<ProvidedParameterInfo[]> staticParams, range m);
    internal static FSharpOption`1<Tainted`1<ProvidedMethodBase>> TryApplyProvidedMethod(Tainted`1<ProvidedMethodBase> methBeforeArguments, Object[] staticArgs, range m);
    internal static FSharpOption`1<Tuple`2<Tainted`1<ProvidedType>, FSharpFunc`2<Unit, Unit>>> TryApplyProvidedType(Tainted`1<ProvidedType> typeBeforeArguments, FSharpOption`1<FSharpList`1<string>> optGeneratedTypePath, Object[] staticArgs, range m);
    [CompilerGeneratedAttribute]
internal static object mapping@1-13(string typeLogicalName, range m, IDictionary`2<string, string> argSpecsTable, Tainted`1<ProvidedType> typeBeforeArguments, Tainted`1<ProvidedParameterInfo> sp);
    internal static FSharpOption`1<Tainted`1<ProvidedType>> TryLinkProvidedType(Tainted`1<ITypeProvider> resolver, String[] moduleOrNamespace, string typeLogicalName, range range);
    internal static FSharpList`1<string> GetPartsOfNamespaceRecover(string namespaceName);
    internal static FSharpList`1<string> GetProvidedNamespaceAsPath(range m, Tainted`1<ITypeProvider> resolver, string namespaceName);
    internal static FSharpList`1<string> walkUpNestedClasses@1226(range m, Tainted`1<ProvidedType> tupledArg0, FSharpList`1<string> tupledArg1);
    internal static FSharpList`1<string> GetFSharpPathToProvidedType(Tainted`1<ProvidedType> st, range range);
    internal static ILAssemblyRef GetOriginalILAssemblyRefOfProvidedAssembly(Tainted`1<ProvidedAssembly> assembly, range m);
    internal static ILTypeRef GetOriginalILTypeRefOfProvidedType(Tainted`1<ProvidedType> st, range range);
    internal static ILTypeRef GetILTypeRefOfProvidedType(Tainted`1<ProvidedType> st, range range);
    internal static bool IsGeneratedTypeDirectReference(Tainted`1<ProvidedType> st, range m);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.FindUnsolved : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTy(cenv cenv, a _env, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTypeInst(cenv cenv, a env, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accExpr(cenv cenv, env env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accMethods(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, FSharpList`1<ObjExprMethod> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accMethod(cenv cenv, env env, FSharpOption`1<Val> _baseValOpt, ObjExprMethod _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accIntfImpls(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accIntfImpl(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, TType ty, FSharpList`1<ObjExprMethod> overrides);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accOp(cenv cenv, env env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range _m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accLambdas(cenv cenv, env env, ValReprInfo topValInfo, Expr e, TType ety);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accExprs(cenv cenv, env env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTargets(cenv cenv, env env, range m, TType ty, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTarget(cenv cenv, env env, range _m, TType _ty, DecisionTreeTarget _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accDTree(cenv cenv, env env, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accSwitch(cenv cenv, env env, Expr e, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> dflt, range _m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accDiscrim(cenv cenv, env env, DecisionTreeTest d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accAttrib(cenv cenv, env env, Attrib _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accAttribs(cenv cenv, env env, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accValReprInfo(cenv cenv, env env, ValReprInfo _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accArgReprInfo(cenv cenv, env env, ArgReprInfo argInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accVal(cenv cenv, env env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accBind(cenv cenv, env env, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accBinds(cenv cenv, env env, FSharpList`1<Binding> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTyconRecdField(cenv cenv, env env, a _tycon, RecdField rfield);
    [CompilerGeneratedAttribute]
internal static void action@1-11(cenv cenv, env env, Entity tycon, UnionCase uc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTycon(cenv cenv, env env, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accModuleOrNamespaceDef(cenv cenv, env env, ModuleOrNamespaceExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accModuleOrNamespaceBinds(cenv cenv, env env, FSharpList`1<ModuleOrNamespaceBinding> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accModuleOrNamespaceBind(cenv cenv, env env, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> UnsolvedTyparsOfModuleDef(TcGlobals g, ImportMap amap, DisplayEnv denv, ModuleOrNamespaceExpr mdef, FSharpList`1<Attrib> extraAttribs);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.FrameworkImportsCache : object {
    internal AgedLookup`3<CompilationThreadToken, Tuple`4<FSharpList`1<string>, string, FSharpList`1<string>, string>, Tuple`2<TcGlobals, TcImports>> frameworkTcImportsCache;
    public FrameworkImportsCache(int size);
    internal void Downsize(CompilationThreadToken ctok);
    internal void Clear(CompilationThreadToken ctok);
    internal Cancellable`1<Tuple`4<TcGlobals, TcImports, FSharpList`1<AssemblyResolution>, FSharpList`1<UnresolvedAssemblyReference>>> Get(CompilationThreadToken ctok, TcConfig tcConfig);
}
[SealedAttribute]
[EventSourceAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.FSharpCompilerEventSource : EventSource {
    internal static FSharpCompilerEventSource instance;
    internal static int init@17-2;
    internal static FSharpCompilerEventSource Instance { get; }
    private static FSharpCompilerEventSource();
    internal static FSharpCompilerEventSource get_Instance();
    [EventAttribute("1")]
internal void Log(LogCompilerFunctionId functionId);
    [EventAttribute("2")]
internal void LogMessage(string message, LogCompilerFunctionId functionId);
    [EventAttribute("3")]
internal void BlockStart(LogCompilerFunctionId functionId);
    [EventAttribute("4")]
internal void BlockStop(LogCompilerFunctionId functionId);
    [EventAttribute("5")]
internal void BlockMessageStart(string message, LogCompilerFunctionId functionId);
    [EventAttribute("6")]
internal void BlockMessageStop(string message, LogCompilerFunctionId functionId);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.IlxGen : object {
    [DebuggerBrowsableAttribute("0")]
internal static T829974_327Bytes@ field829975@;
    internal static string debugDisplayMethodName { get; }
    internal static bool useHiddenInitCode { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr iLdcZero { get; }
    [CompilationMappingAttribute("9")]
internal static string mainMethName { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<TextWriter, Unit> reports { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> CountClosure { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> CountMethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> CountStaticFieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> CountCallFuncInstructions { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILType> Push0 { get; }
    [CompilationMappingAttribute("9")]
internal static sequel discard { get; }
    [CompilationMappingAttribute("9")]
internal static sequel discardAndReturnVoid { get; }
    internal static bool compileSequenceExpressions { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Type, object> defaultOf { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<MethodInfo> gminfo@7640 { get; }
    private static IlxGen();
    internal static bool IsNonErasedTypar(Typar tp);
    internal static FSharpList`1<TType> DropErasedTyargs(FSharpList`1<TType> tys);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_debugDisplayMethodName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_useHiddenInitCode();
    internal static ILInstr get_iLdcZero();
    internal static ILMethodDef mkLdfldMethodDef(string ilMethName, ILMemberAccess reprAccess, bool isStatic, ILType ilTy, string ilFieldName, ILType ilPropType);
    internal static FSharpList`1<Tuple`3<string, string, a>> ChooseParamNames(FSharpList`1<Tuple`3<string, string, a>> fieldNamesAndTypes);
    internal static bool CheckCodeDoesSomething(ILCode code);
    internal static Tuple`2<string, Set`2<string, IComparer`1<string>>> chooseName@92(Set`2<string, IComparer`1<string>> names, Tuple`2<string, FSharpOption`1<int>> tupledArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> ChooseFreeVarNames(FSharpList`1<string> takenNames, FSharpList`1<string> ts);
    internal static string get_mainMethName();
    internal static FSharpFunc`2<TextWriter, Unit> get_reports();
    internal static void set_reports(FSharpFunc`2<TextWriter, Unit> value);
    internal static void AddReport(FSharpFunc`2<TextWriter, Unit> f);
    internal static void ReportStatistics(TextWriter oc);
    internal static FSharpFunc`2<Unit, Unit> NewCounter(string nm);
    internal static FSharpFunc`2<Unit, Unit> get_CountClosure();
    internal static FSharpFunc`2<Unit, Unit> get_CountMethodDef();
    internal static FSharpFunc`2<Unit, Unit> get_CountStaticFieldDef();
    internal static FSharpFunc`2<Unit, Unit> get_CountCallFuncInstructions();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTypeOfExpr(cenv cenv, range m, ILType ilty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool useCallVirt(cenv cenv, ILBoxity boxity, ILMethodSpec mspec, bool isBaseCall);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@276-66(CompileLocation this, CompileLocation obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@276-67(IComparer comp, CompileLocation this, CompileLocation objTemp, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string mkTopName(FSharpOption`1<string> ns, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompileLocation CompLocForFragment(string fragName, CcuThunk ccu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompileLocation CompLocForSubModuleOrNamespace(CompileLocation cloc, Entity submod);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompileLocation CompLocForFixedPath(string fragName, string qname, CompilationPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef NestedTypeRefForCompLoc(CompileLocation cloc, string n);
    internal static string CleanUpGeneratedTypeName(string nm);
    internal static string TypeNameForInitClass(CompileLocation cloc);
    internal static string TypeNameForPrivateImplementationDetails(CompileLocation cloc);
    internal static CompileLocation CompLocForInitClass(CompileLocation cloc);
    internal static CompileLocation CompLocForPrivateImplementationDetails(CompileLocation cloc);
    internal static ILTypeRef TypeRefForCompLoc(CompileLocation cloc);
    internal static ILMemberAccess ComputeMemberAccess(bool hidden);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefAccess ComputeTypeAccess(ILTypeRef tref, bool hidden);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILAttribute> GenReadOnlyAttributeIfNecessary(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenReadOnlyModReqIfNecessary(TcGlobals g, TType ty, ILType ilTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenTyAppAux(ImportMap amap, range m, TypeReprEnv tyenv, CompiledTypeRepr repr, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenILTyAppAux(ImportMap amap, range m, TypeReprEnv tyenv, ILTypeRef tref, ILBoxity boxity, FSharpOption`1<ILType> ilTypeOpt, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenNamedTyAppAux(ImportMap amap, range m, TypeReprEnv tyenv, PtrsOK ptrsOK, EntityRef tcref, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenTypeAux(ImportMap amap, range m, TypeReprEnv tyenv, VoidNotOK voidOK, PtrsOK ptrsOK, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxUnionField[] GenUnionCaseRef(ImportMap amap, range m, TypeReprEnv tyenv, int i, RecdField[] fspecs);
    [CompilerGeneratedAttribute]
internal static IlxUnionRef resf@381-1(ImportMap amap, range m, EntityRef tcref, TcGlobals g, Entity tycon, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxUnionRef GenUnionRef(ImportMap amap, range m, EntityRef tcref);
    [CompilerGeneratedAttribute]
internal static IlxUnionHasHelpers ComputeUnionHasHelpers$cont@584(TcGlobals g, EntityRef tcref, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxUnionHasHelpers ComputeUnionHasHelpers(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<IlxUnionSpec, int> GenUnionCaseSpec(ImportMap amap, range m, TypeReprEnv tyenv, UnionCaseRef ucref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenType(ImportMap amap, range m, TypeReprEnv tyenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> GenTypes(ImportMap amap, range m, TypeReprEnv tyenv, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenReturnType(ImportMap amap, range m, TypeReprEnv tyenv, FSharpOption`1<TType> returnTyOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenParamType(ImportMap amap, range m, TypeReprEnv tyenv, bool isSlotSig, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> GenTypeArgs(ImportMap amap, range m, TypeReprEnv tyenv, FSharpList`1<TType> tyargs);
    internal static ILFieldSpec GenFieldSpecForStaticField(bool isInteractive, TcGlobals g, ILType ilContainerTy, Val vspec, string nm, range m, CompileLocation cloc, ILType ilTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec GenRecdFieldRef(range m, cenv cenv, TypeReprEnv tyenv, RecdFieldRef rfref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv SetIsInLoop(bool isInLoop, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv ReplaceTyenv(TypeReprEnv tyenv, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv EnvForTypars(FSharpList`1<Typar> tps, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddTyparsToEnv(FSharpList`1<Typar> typars, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddSignatureRemapInfo(a _msg, SignatureRepackageInfo rpi, SignatureHidingInfo mhi, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddStorageForVal(TcGlobals g, Val v, Lazy`1<ValStorage> s, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddStorageForLocalVals(TcGlobals g, FSharpList`1<Tuple`2<Val, ValStorage>> vals, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage StorageForVal(TcGlobals g, range m, Val v, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<ILMethodSpec, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<ArgReprInfo>, ArgReprInfo, FSharpList`1<TType>> GetMethodSpecForMemberVal(ImportMap amap, TcGlobals g, ValMemberInfo memberInfo, ValRef vref);
    internal static ILFieldSpec generate@991(Val vspec, string nm, range m, bool isInteractive, ILType ilTyForProperty, ILType ilTy, TcGlobals g, CompileLocation cloc, Unit unitVar0);
    internal static ILFieldSpec ComputeFieldSpecForVal(FSharpOption`1<IlxGenIntraAssemblyInfo> optIntraAssemblyInfo, bool isInteractive, TcGlobals g, ILType ilTyForProperty, Val vspec, string nm, range m, CompileLocation cloc, ILType ilTy, ILMethodRef ilGetterMethRef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage ComputeStorageForFSharpValue(ImportMap amap, TcGlobals g, CompileLocation cloc, FSharpOption`1<IlxGenIntraAssemblyInfo> optIntraAssemblyInfo, OptionalShadowLocal optShadowLocal, bool isInteractive, TType returnTy, ValRef vref, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage ComputeStorageForFSharpMember(ImportMap amap, TcGlobals g, ValReprInfo topValInfo, ValMemberInfo memberInfo, ValRef vref, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage ComputeStorageForFSharpFunctionOrFSharpExtensionMember(ImportMap amap, TcGlobals g, CompileLocation cloc, ValReprInfo topValInfo, ValRef vref, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsFSharpValCompiledAsMethod(TcGlobals g, Val v);
    internal static ValStorage ComputeStorageForTopVal(ImportMap amap, TcGlobals g, FSharpOption`1<IlxGenIntraAssemblyInfo> optIntraAssemblyInfo, bool isInteractive, OptionalShadowLocal optShadowLocal, ValRef vref, CompileLocation cloc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv ComputeAndAddStorageForLocalTopVal(ImportMap amap, TcGlobals g, IlxGenIntraAssemblyInfo intraAssemblyFieldTable, bool isInteractive, OptionalShadowLocal optShadowLocal, CompileLocation cloc, Val v, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage ComputeStorageForNonLocalTopVal(ImportMap amap, TcGlobals g, CompileLocation cloc, EntityRef modref, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddStorageForNonLocalModuleOrNamespaceRef(ImportMap amap, TcGlobals g, CompileLocation cloc, IlxGenEnv acc, EntityRef modref, Entity modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddStorageForExternalCcu(ImportMap amap, TcGlobals g, IlxGenEnv eenv, CcuThunk ccu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a AddBindingsForLocalModuleType(FSharpFunc`2<CompileLocation, FSharpFunc`2<Val, FSharpFunc`2<a, a>>> allocVal, CompileLocation cloc, a eenv, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a AddBindingsForTycon(FSharpFunc`2<CompileLocation, FSharpFunc`2<Val, FSharpFunc`2<a, a>>> allocVal, CompileLocation cloc, Entity tycon, a eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a AddBindingsForModuleDefs(FSharpFunc`2<CompileLocation, FSharpFunc`2<Val, FSharpFunc`2<a, a>>> allocVal, CompileLocation cloc, a eenv, FSharpList`1<ModuleOrNamespaceExpr> mdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a AddBindingsForModuleDef(FSharpFunc`2<CompileLocation, FSharpFunc`2<Val, FSharpFunc`2<a, a>>> allocVal, CompileLocation cloc, a eenv, ModuleOrNamespaceExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a AddBindingsForModule(FSharpFunc`2<CompileLocation, FSharpFunc`2<Val, FSharpFunc`2<a, a>>> allocVal, CompileLocation cloc, ModuleOrNamespaceBinding x, a eenv);
    internal static IlxGenEnv AddIncrementalLocalAssemblyFragmentToIlxGenEnv(ImportMap amap, bool isIncrementalFragment, TcGlobals g, CcuThunk ccu, string fragName, IlxGenIntraAssemblyInfo intraAssemblyInfo, IlxGenEnv eenv, FSharpList`1<TypedImplFile> typedImplFiles);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILSourceMarker GenILSourceMarker(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILSourceMarker> GenPossibleILSourceMarker(cenv cenv, range m);
    internal static FSharpList`1<b> HashRangeSorted(IDictionary`2<a, Tuple`2<int, b>> ht);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<b> MergeOptions(a m, FSharpOption`1<b> o1, FSharpOption`1<b> o2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDef MergePropertyPair(a m, ILPropertyDef pd, ILPropertyDef pdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddPropertyDefToHash(range m, Dictionary`2<PropKey, Tuple`2<int, ILPropertyDef>> ht, ILPropertyDef pdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILPropertyDef> MergePropertyDefs(range m, FSharpList`1<a> ilPropertyDefs);
    internal static FSharpList`1<ILType> get_Push0();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr FeeFeeInstr(cenv cenv, ILSourceDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenString(cenv cenv, CodeGenBuffer cgbuf, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenConstArray(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ILType ilElementType, a[] data, FSharpFunc`2<ByteBuffer, FSharpFunc`2<a, Unit>> write);
    internal static sequel get_discard();
    internal static sequel get_discardAndReturnVoid();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`7<FSharpList`1<ILLocal>, int, Dictionary`2<int, int>, ILInstr[], FSharpList`1<ILExceptionSpec>, FSharpList`1<ILLocalDebugInfo>, bool> CodeGenThen(cenv cenv, AssemblyBuilder mgbuf, FSharpList`1<Tuple`2<ValRef, BranchCallItem>> entryPointInfo, string methodName, IlxGenEnv eenv, int alreadyUsedArgs, FSharpFunc`2<CodeGenBuffer, FSharpFunc`2<IlxGenEnv, Unit>> codeGenFunction, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILInstr[], ILMethodBody> CodeGenMethod(cenv cenv, AssemblyBuilder mgbuf, FSharpList`1<Tuple`2<ValRef, BranchCallItem>> entryPointInfo, string methodName, IlxGenEnv eenv, int alreadyUsedArgs, FSharpFunc`2<CodeGenBuffer, FSharpFunc`2<IlxGenEnv, Unit>> codeGenFunction, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Mark, Mark> StartDelayedLocalScope(string nm, CodeGenBuffer cgbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Mark, Mark> StartLocalScope(string nm, CodeGenBuffer cgbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a LocalScope(string nm, CodeGenBuffer cgbuf, FSharpFunc`2<Tuple`2<Mark, Mark>, a> f);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_compileSequenceExpressions();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<bool, FSharpOption`1<range>, EmitSequencePointState> ComputeSequencePointInfoForBinding(TcGlobals g, Binding _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool BindingEmitsSequencePoint(TcGlobals g, Binding bind);
    internal static bool BindingEmitsHiddenCode(Binding _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool FirstEmittedCodeWillBeSequencePoint(TcGlobals g, EmitSequencePointState sp, Expr expr);
    [CompilerGeneratedAttribute]
internal static bool EmitSequencePointForWholeExpr$cont@2077(TcGlobals g, Expr matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EmitSequencePointForWholeExpr(TcGlobals g, EmitSequencePointState sp, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EmitHiddenCodeMarkerForWholeExpr(TcGlobals g, EmitSequencePointState sp, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range RangeOfSequencePointForWholeExpr(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool DoesGenExprStartWithSequencePoint(TcGlobals g, EmitSequencePointState sp, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ProcessSequencePointForExpr(cenv cenv, CodeGenBuffer cgbuf, EmitSequencePointState sp, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, EmitSequencePointState sp, Expr expr, sequel sequel);
    internal static void ProcessDelayedGenMethods(cenv cenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExprWithStackGuard(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, EmitSequencePointState sp, Expr expr, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExprAux(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, EmitSequencePointState sp, Expr expr, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExprs(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodBody CodeGenMethodForExpr(cenv cenv, AssemblyBuilder mgbuf, EmitSequencePointState spReq, FSharpList`1<Tuple`2<ValRef, BranchCallItem>> entryPointInfo, string methodName, IlxGenEnv eenv, int alreadyUsedArgs, Expr expr0, sequel sequel0);
    internal static FSharpOption`1<sequel> sequelAfterDiscard(sequel sequel);
    internal static sequel sequelIgnoringEndScopesAndDiscard(sequel sequel);
    internal static sequel sequelIgnoreEndScopes(sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSequelEndScopes(CodeGenBuffer cgbuf, sequel sequel);
    internal static string StringOfSequel(sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSequel(cenv cenv, CompileLocation cloc, CodeGenBuffer cgbuf, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenConstant(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Const c, range m, TType ty, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenUnitTy(cenv cenv, IlxGenEnv eenv, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUnit(cenv cenv, IlxGenEnv eenv, range m, CodeGenBuffer cgbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUnitThenSequel(cenv cenv, IlxGenEnv eenv, range m, CompileLocation cloc, CodeGenBuffer cgbuf, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocTuple(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TupInfo tupInfo, FSharpList`1<Expr> args, FSharpList`1<TType> argtys, range m, sequel sequel);
    internal static Expr getCompiledTupleItem@2516(cenv cenv, IlxGenEnv eenv, bool tupInfo, TcGlobals g, Expr tupledArg0, FSharpList`1<TType> tupledArg1, int tupledArg2, range tupledArg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetTupleField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TupInfo tupInfo, Expr e, FSharpList`1<TType> tys, int n, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocExn(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, EntityRef c, FSharpList`1<Expr> args, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocUnionCaseCore(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, UnionCaseRef c, FSharpList`1<TType> tyargs, int n, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocUnionCase(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, UnionCaseRef c, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m, sequel sequel);
    [CompilerGeneratedAttribute]
internal static FakeUnit func1@1-25(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, sequel sequel, FSharpList`1<TType> tyargs, range m, UnionCaseRef c, FSharpList`1<Expr> argsFront, FakeUnit _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FakeUnit GenLinearExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, EmitSequencePointState sp, Expr expr, sequel sequel, bool canProcessSequencePoint, FSharpFunc`2<FakeUnit, FakeUnit> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocRecd(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecordConstructionInfo ctorInfo, EntityRef tcref, FSharpList`1<TType> argtys, FSharpList`1<Expr> args, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocAnonRecd(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, AnonRecdTypeInfo anonInfo, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetAnonRecdField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, AnonRecdTypeInfo anonInfo, Expr e, FSharpList`1<TType> tyargs, int n, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenNewArraySimple(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Expr> elems, TType elemTy, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenNewArray(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Expr> elems, TType elemTy, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenCoerce(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, TType tgty, range m, TType srcty, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenReraise(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType rtnty, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetExnField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, EntityRef ecref, int fieldNum, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetExnField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, EntityRef ecref, int fieldNum, Expr e2, range m, sequel sequel);
    internal static ICodeGen`1<Mark> UnionCodeGen(CodeGenBuffer cgbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUnionCaseProof(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, UnionCaseRef ucref, FSharpList`1<TType> tyargs, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetUnionCaseField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, UnionCaseRef ucref, FSharpList`1<TType> tyargs, int n, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetUnionCaseFieldAddr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, UnionCaseRef ucref, FSharpList`1<TType> tyargs, int n, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetUnionCaseTag(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, EntityRef tcref, FSharpList`1<TType> tyargs, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetUnionCaseField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, UnionCaseRef ucref, FSharpList`1<TType> tyargs, int n, Expr e2, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetRecdFieldAddr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, RecdFieldRef f, FSharpList`1<TType> tyargs, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetStaticFieldAddr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef f, FSharpList`1<TType> tyargs, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetRecdField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, RecdFieldRef f, FSharpList`1<TType> tyargs, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetRecdField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e1, RecdFieldRef f, FSharpList`1<TType> tyargs, Expr e2, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetStaticField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef f, FSharpList`1<TType> tyargs, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetStaticField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef f, FSharpList`1<TType> tyargs, Expr e2, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenFieldGet(bool isStatic, cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef rfref, FSharpList`1<TType> tyargs, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenFieldStore(bool isStatic, cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef rfref, FSharpList`1<TType> tyargs, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUntupledArgsDiscardingLoneUnit(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, range m, int numObjArgs, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> curriedArgInfos, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUntupledArgExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, range m, FSharpList`1<Tuple`2<TType, ArgReprInfo>> argInfos, Expr expr, sequel sequel);
    [CompilerGeneratedAttribute]
internal static int ntmargs$cont@3000(FSharpList`1<Expr> args, int numObjArgs, int ntmargs, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> curriedArgInfos, Unit unitVar);
    internal static Expr |OptionalCoerce|@3029(Expr _arg34);
    internal static Expr |OptionalTyapp|@3030(Expr _arg35);
    internal static FSharpList`1<ILType> mkFormalParams@3048(FSharpList`1<TType> gparams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenApp(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr f, TType fty, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m, sequel sequel);
    internal static ILTailcall CanTailcall(bool hasStructObjArg, FSharpOption`1<TType> ccallInfo, bool withinSEH, bool hasByrefArg, bool mustGenerateUnitAfterCall, bool isDllImport, bool isSelfInit, bool makesNoCriticalTailcalls, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType GenNamedLocalTyFuncCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType ty, IlxClosureInfo cloinfo, FSharpList`1<TType> tyargs, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenArgsAndIndirectCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType functy, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m, sequel sequel);
    internal static bool check@3277-10(IlxClosureApps x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenIndirectCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType functy, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<int, IlxGenEnv, Tuple`2<FSharpList`1<ILType>, FSharpList`1<int>>, Tuple`2<int, int>, Mark, ILType> GenTry(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Mark scopeMarks_0, Mark scopeMarks_1, Expr e1, range m, TType resty, SequencePointInfoForTry spTry);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTryCatch(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e1, Val vf, Expr ef, Val vh, Expr eh, range m, TType resty, SequencePointInfoForTry spTry, SequencePointInfoForWith spWith, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTryFinally(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr bodyExpr, Expr handlerExpr, range m, TType resty, SequencePointInfoForTry spTry, SequencePointInfoForFinally spFinally, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenForLoop(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, SequencePointInfoForForLoop spFor, Val v, Expr e1, ForLoopStyle dir, Expr e2, Expr loopBody, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenWhileLoop(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, SequencePointInfoForWhileLoop spWhile, Expr e1, Expr e2, range m, sequel sequel);
    internal static void err@3581-5(range m, ILInstr i, string s);
    internal static ILFieldSpec modFieldSpec@3584(FSharpList`1<ILType> ilTyArgs, ILFieldSpec fspec);
    internal static bool anyfpType@3683(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAsmCode(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<ILInstr> il, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, FSharpList`1<TType> returnTys, range m, sequel sequel);
    internal static Expr mkList@3760(range m, TcGlobals g, TType ty, FSharpList`1<Expr> els);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenQuotation(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr ast, FSharpRef`1<FSharpOption`1<Tuple`4<FSharpList`1<ILTypeRef>, FSharpList`1<TType>, FSharpList`1<Expr>, ExprData>>> conv, range m, TType ety, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenILCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, bool virt, bool valu, bool newobj, ValUseFlag valUseFlags, bool isDllImport, ILMethodRef ilMethRef, FSharpList`1<TType> enclArgTys, FSharpList`1<TType> methArgTys, FSharpList`1<Expr> argExprs, FSharpList`1<TType> returnTys, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CommitCallSequel(cenv cenv, IlxGenEnv eenv, range m, CompileLocation cloc, CodeGenBuffer cgbuf, bool mustGenerateUnitAfterCall, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeNotSupportedExnExpr(cenv cenv, IlxGenEnv eenv, Expr argExpr, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTraitCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TraitConstraintInfo traitInfo, FSharpList`1<Expr> argExprs, range m, Expr expr, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetAddrOfRefCellField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, TType ty, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetValAddr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef v, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetByref(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef v, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetByref(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef v, Expr e, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenDefaultValue(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType ty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILGenericParameterDef GenGenericParam(cenv cenv, IlxGenEnv eenv, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILParameter GenSlotParam(range m, cenv cenv, IlxGenEnv eenv, SlotParam _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ILType, FSharpList`1<ILParameter>, ILReturn> GenFormalSlotsig(range m, cenv cenv, IlxGenEnv eenv, SlotSig _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotParam instSlotParam(FSharpList`1<Tuple`2<Typar, TType>> inst, SlotParam _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<ILParameter>, ILReturn> GenActualSlotsig(range m, cenv cenv, IlxGenEnv eenv, SlotSig _arg4, FSharpList`1<Typar> methTyparsOfOverridingMethod, FSharpList`1<Val> methodParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string GenNameOfOverridingMethod(cenv cenv, bool useMethodImpl, SlotSig slotsig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, FSharpFunc`2<Tuple`2<ILType, FSharpList`1<Typar>>, ILMethodImplDef>> GenMethodImpl(cenv cenv, IlxGenEnv eenv, bool useMethodImpl, SlotSig _arg5, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv bindBaseOrThisVarOpt(cenv cenv, IlxGenEnv eenv, FSharpOption`1<Val> baseValOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef renameMethodDef(string nameOfOverridingMethod, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Tuple`3<bool, FSharpFunc`2<Tuple`2<ILType, FSharpList`1<Typar>>, ILMethodImplDef>, FSharpList`1<Typar>>, ILMethodDef>> GenObjectMethod(cenv cenv, IlxGenEnv eenvinner, CodeGenBuffer cgbuf, bool useMethodImpl, ObjExprMethod tmethod);
    internal static FSharpList`1<Tuple`2<FSharpOption`1<ILMethodImplDef>, ILMethodDef>> genMethodAndOptionalMethodImpl@4137(cenv cenv, CodeGenBuffer cgbuf, ILType ilTyForOverriding, IlxGenEnv eenvinner, ObjExprMethod tmethod, bool useMethodImpl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenObjectExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenvouter, Expr expr, TType baseType, FSharpOption`1<Val> baseValOpt, Expr basecall, FSharpList`1<ObjExprMethod> overrides, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> interfaceImpls, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSequenceExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenvouter, ValRef nextEnumeratorValRef, ValRef pcvref, ValRef currvref, FSharpList`1<ValRef> stateVars, Expr generateNextExpr, Expr closeExpr, Expr checkCloseExpr, TType seqElemTy, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILTypeDef> GenClosureTypeDefs(cenv cenv, ILTypeRef tref, FSharpList`1<ILGenericParameterDef> ilGenParams, FSharpList`1<ILAttribute> attrs, IlxClosureFreeVar[] ilCloFreeVars, IlxClosureLambdas ilCloLambdas, ILMethodBody ilCtorBody, FSharpList`1<ILMethodDef> mdefs, FSharpList`1<ILMethodImplDef> mimpls, ILType ext, FSharpList`1<ILType> ilIntfTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILGenericParameterDef> GenGenericParams(cenv cenv, IlxGenEnv eenv, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> GenGenericArgs(range m, TypeReprEnv tyenv, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<IlxClosureInfo, range> GenLambdaClosure(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, bool isLocalTypeFunc, FSharpOption`1<ValRef> selfv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenLambdaVal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, IlxClosureInfo cloinfo, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenLambda(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, bool isLocalTypeFunc, FSharpOption`1<ValRef> selfv, Expr expr, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenTypeOfVal(cenv cenv, IlxGenEnv eenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenFreevar(cenv cenv, range m, IlxGenEnv eenvouter, TypeReprEnv tyenvinner, Val fv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<FSharpList`1<Attrib>, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Val>, ILTypeRef, IlxClosureFreeVar[], Tuple`1<IlxGenEnv>> GetIlxClosureFreeVars(cenv cenv, range m, FSharpOption`1<ValRef> selfv, IlxGenEnv eenvouter, FSharpList`1<string> takenNames, Expr expr);
    internal static Tuple`4<FSharpList`1<FSharpList`1<Typar>>, FSharpList`1<Val>, Expr, TType> getCallStructure@4512(bool isLocalTypeFunc, TcGlobals g, FSharpList`1<FSharpList`1<Typar>> tvacc, FSharpList`1<Val> vacc, Expr tupledArg0, TType tupledArg1);
    internal static Tuple`2<IlxClosureLambdas, IlxGenEnv> getClosureArgs@4531(cenv cenv, range m, TcGlobals g, TType returnTy, IlxGenEnv eenv, int ntmargs, FSharpList`1<FSharpList`1<Typar>> tvsl, FSharpList`1<Val> vs);
    internal static Tuple`3<FSharpList`1<ILGenericParameterDef>, ILType, IlxClosureLambdas> strip@4605-2(IlxClosureLambdas lambdas, FSharpList`1<ILGenericParameterDef> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<IlxClosureInfo, Expr, IlxGenEnv> GetIlxClosureInfo(cenv cenv, range m, bool isLocalTypeFunc, FSharpOption`1<ValRef> selfv, IlxGenEnv eenvouter, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsNamedLocalTypeFuncVal(TcGlobals g, Val v, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<ILGenericParameterDef>, FSharpList`1<ILGenericParameterDef>, ILTypeSpec, ILType> GenNamedLocalTypeFuncContractInfo(cenv cenv, IlxGenEnv eenv, range m, IlxClosureInfo cloinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenDelegateExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenvouter, Expr expr, ObjExprMethod _arg6, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenStaticOptimization(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<StaticOptimization> constraints, Expr e2, Expr e3, range _m, sequel sequel);
    internal static bool IsSequelImmediate(sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<sequel, Mark, FSharpList`1<ILType>, sequel> GenJoinPoint(cenv cenv, CodeGenBuffer cgbuf, string pos, IlxGenEnv eenv, TType ty, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMatch(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, SequencePointInfoForBinding spBind, range _exprm, DecisionTree tree, DecisionTreeTarget[] targets, range m, TType ty, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenDecisionTreeAndTargets(cenv cenv, CodeGenBuffer cgbuf, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, DecisionTree tree, DecisionTreeTarget[] targets, FSharpFunc`2<Unit, Unit> repeatSP, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> TryFindTargetInfo(Map`3<int, Tuple`2<a, b>, IComparer`1<int>> targetInfos, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> GenDecisionTreeAndTargetsInner(cenv cenv, CodeGenBuffer cgbuf, FSharpOption`1<Mark> inplabOpt, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, DecisionTree tree, DecisionTreeTarget[] targets, FSharpFunc`2<Unit, Unit> repeatSP, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c GetTarget(c[] targets, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> GenDecisionTreeSuccess(cenv cenv, CodeGenBuffer cgbuf, FSharpOption`1<Mark> inplabOpt, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, FSharpList`1<Expr> es, int targetIdx, DecisionTreeTarget[] targets, FSharpFunc`2<Unit, Unit> repeatSP, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenPostponedDecisionTreeTargets(cenv cenv, CodeGenBuffer cgbuf, FSharpList`1<ILType> stackAtTargets, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenDecisionTreeTarget(cenv cenv, CodeGenBuffer cgbuf, FSharpList`1<ILType> stackAtTargets, int _targetIdx, Mark targetMarkBeforeBinds, Mark targetMarkAfterBinds, IlxGenEnv eenvAtTarget, Expr successExpr, SequencePointInfoForTarget spTarget, FSharpFunc`2<Unit, Unit> repeatSP, FSharpList`1<Val> vs, FSharpList`1<Binding> binds, Mark startScope, Mark endScope, sequel sequel);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<int, int> func2@1-3(int e1);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<int, int> func2@1-4(int e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> GenDecisionTreeSwitch(cenv cenv, CodeGenBuffer cgbuf, FSharpOption`1<Mark> inplabOpt, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, Expr e, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> defaultTargetOpt, range switchm, DecisionTreeTarget[] targets, FSharpFunc`2<Unit, Unit> repeatSP, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> GenDecisionTreeCases(cenv cenv, CodeGenBuffer cgbuf, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, DecisionTreeTarget[] targets, FSharpFunc`2<Unit, Unit> repeatSP, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, FSharpOption`1<DecisionTree> defaultTargetOpt, FSharpList`1<Mark> caseLabels, FSharpList`1<DecisionTreeCase> cases, sequel sequel);
    internal static FSharpOption`1<bool> |BoolExpr|_|(Expr _arg43);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> GenDecisionTreeTest(cenv cenv, CompileLocation cloc, CodeGenBuffer cgbuf, FSharpList`1<ILType> stackAtTargets, Expr e, FSharpOption`1<Tuple`3<int, FSharpList`1<ILType>, FSharpChoice`2<Tuple`3<bool, IlxUnionSpec, int>, ILInstr>>> tester, IlxGenEnv eenv, DecisionTree successTree, DecisionTree failureTree, DecisionTreeTarget[] targets, FSharpFunc`2<Unit, Unit> repeatSP, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, SequencePointInfoForTarget, FSharpFunc`2<Unit, Unit>, FSharpList`1<Val>, Tuple`3<FSharpList`1<Binding>, Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenLetRecFixup(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, IlxClosureSpec ilxCloSpec, Expr e, ILFieldSpec ilField, Expr e2, d _m);
    internal static FSharpFunc`2<FSharpOption`1<Val>, FSharpFunc`2<Expr, FSharpFunc`2<FSharpFunc`2<Expr, Expr>, FSharpFunc`2<Expr, Unit>>>> computeFixupsForOneRecursiveVar@5165(cenv cenv, CodeGenBuffer cgbuf, range m, IlxGenEnv eenv, Val boundv, Set`2<Val, IComparer`1<Val>> forwardReferenceSet, FSharpRef`1<FSharpList`1<Tuple`3<Val, Val, FSharpFunc`2<Unit, Unit>>>> fixups);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenLetRecBindings(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Binding> allBinds, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenLetRec(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Binding> binds, Expr body, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EmitSequencePointState GenSequencePointForBind(cenv cenv, CodeGenBuffer cgbuf, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenBinding(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMemberAccess ComputeMethodAccessRestrictedBySig(IlxGenEnv eenv, Val vspec);
    internal static bool canTarget@5324(FSharpOption`1<AttributeTargets> tupledArg0, AttributeTargets tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenBindingAfterSequencePoint(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, EmitSequencePointState sp, Binding _arg7, FSharpOption`1<Mark> startScopeMarkOpt);
    internal static ILNativeType decodeUnmanagedType@5429(range m, AttributeDecoder decoder, int unmanagedType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<ILNativeType>, FSharpList`1<Attrib>> GenMarshal(cenv cenv, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<bool, bool, bool, FSharpOption`1<ILFieldInit>, FSharpOption`1<ILNativeType>, FSharpList`1<Attrib>> GenParamAttribs(cenv cenv, TType paramTy, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILParameter> GenParams(cenv cenv, IlxGenEnv eenv, ILMethodSpec mspec, FSharpList`1<ArgReprInfo> attribs, FSharpList`1<TType> methodArgTys, FSharpOption`1<FSharpList`1<Val>> implValsOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILReturn GenReturnInfo(cenv cenv, IlxGenEnv eenv, ILType ilRetTy, ArgReprInfo retInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDef GenPropertyForMethodDef(bool compileAsInstance, ILTypeRef tref, ILMethodDef mdef, Val v, ValMemberInfo memberInfo, FSharpList`1<ILType> ilArgTys, ILType ilPropTy, ILAttributes ilAttrs, FSharpOption`1<string> compiledName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDef GenEventForProperty(cenv cenv, IlxGenEnv eenvForMeth, ILMethodSpec mspec, Val v, FSharpList`1<ILAttribute> ilAttrsThatGoOnPrimaryItem, range m, TType returnTy);
    [CompilerGeneratedAttribute]
internal static ILMethodDef func1@1-26(e mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpFunc`2<e, ILMethodDef>> ComputeFlagFixupsForMemberBinding(cenv cenv, Val v, ValMemberInfo memberInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<bool, bool, bool, bool, FSharpList`1<Attrib>> ComputeMethodImplAttribs(cenv cenv, Val _v, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void DelayGenMethodForBinding(cenv cenv, AssemblyBuilder mgbuf, IlxGenEnv eenv, Val ilxMethInfoArgs_0, ILMethodSpec ilxMethInfoArgs_1, ILMemberAccess ilxMethInfoArgs_2, FSharpList`1<ArgReprInfo> ilxMethInfoArgs_3, ArgReprInfo ilxMethInfoArgs_4, ValReprInfo ilxMethInfoArgs_5, FSharpOption`1<Val> ilxMethInfoArgs_6, FSharpOption`1<Val> ilxMethInfoArgs_7, FSharpList`1<Typar> ilxMethInfoArgs_8, FSharpList`1<Val> ilxMethInfoArgs_9, FSharpList`1<TType> ilxMethInfoArgs_10, Expr ilxMethInfoArgs_11, TType ilxMethInfoArgs_12);
    internal static void EmitTheMethodDef@5832(AssemblyBuilder mgbuf, Val v, TcGlobals g, bool hasPreserveSigNamedArg, bool hasDllImport, bool hasSynchronizedImplFlag, bool hasPreserveSigImplFlag, bool hasNoInliningFlag, bool hasAggressiveInliningImplFlag, FSharpList`1<Attrib> securityAttributes, FSharpList`1<Attrib> attrs, ILSecurityDecls secDecls, ILTypeRef tref, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodForBinding(cenv cenv, AssemblyBuilder mgbuf, IlxGenEnv eenv, Val v, ILMethodSpec mspec, ILMemberAccess access, FSharpList`1<ArgReprInfo> paramInfos, ArgReprInfo retInfo, ValReprInfo topValInfo, FSharpOption`1<Val> ctorThisValOpt, FSharpOption`1<Val> baseValOpt, FSharpList`1<Typar> tps, FSharpList`1<Val> methodVars, FSharpList`1<TType> methodArgTys, Expr body, TType returnTy);
    internal static Tuple`2<bool, MethodBody> GenPInvokeMethod(string nm, string dll, FSharpList`1<AttribNamedArg> namedArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenBindings(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetVal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef vref, Expr e, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetValRefAndSequel(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, range m, ValRef v, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, range, sequel>> fetchSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetVal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef v, range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenBindingRhs(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, EmitSequencePointState sp, Val vspec, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CommitStartScope(CodeGenBuffer cgbuf, FSharpOption`1<Mark> startScopeMarkOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitInitLocal(CodeGenBuffer cgbuf, ILType ty, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitSetLocal(CodeGenBuffer cgbuf, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitGetLocal(CodeGenBuffer cgbuf, ILType ty, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitSetStaticField(CodeGenBuffer cgbuf, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitGetStaticFieldAddr(CodeGenBuffer cgbuf, ILType ty, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitGetStaticField(CodeGenBuffer cgbuf, ILType ty, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetStorage(range m, CodeGenBuffer cgbuf, ValStorage storage);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CommitGetStorageSequel(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, range m, TType ty, FSharpOption`1<FSharpRef`1<NamedLocalIlxClosureInfo>> localCloInfo, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, range, sequel>> storeSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetStorageAndSequel(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, range m, TType ty, ILType ilTy, ValStorage storage, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, range, sequel>> storeSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetLocalVals(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenvouter, range m, FSharpList`1<Val> fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetLocalVal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, range m, Val vspec, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, range, sequel>> fetchSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetLocalVRef(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, range m, ValRef vref, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, range, sequel>> fetchSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenStoreVal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, range m, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, bool, IlxGenEnv> AllocLocal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, bool compgen, string v, ILType ty, bool isFixed, Mark scopeMarks_0, Mark scopeMarks_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<ValStorage>, IlxGenEnv> AllocLocalVal(cenv cenv, CodeGenBuffer cgbuf, Val v, IlxGenEnv eenv, FSharpOption`1<Expr> repr, Mark scopeMarks_0, Mark scopeMarks_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AllocStorageForBind(cenv cenv, CodeGenBuffer cgbuf, Mark scopeMarks_0, Mark scopeMarks_1, IlxGenEnv eenv, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AllocStorageForBinds(cenv cenv, CodeGenBuffer cgbuf, Mark scopeMarks_0, Mark scopeMarks_1, IlxGenEnv eenv, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<ValStorage>, IlxGenEnv> AllocValForBind(cenv cenv, CodeGenBuffer cgbuf, Mark scopeMarks_0, Mark scopeMarks_1, IlxGenEnv eenv, Binding _arg8);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AllocTopValWithinExpr(cenv cenv, CodeGenBuffer cgbuf, CompileLocation cloc, Mark scopeMarks_0, Mark scopeMarks_1, Val v, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpList`1<ILType>, FSharpList`1<int>>, IlxGenEnv> EmitSaveStack(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, range m, Mark scopeMarks_0, Mark scopeMarks_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitRestoreStack(CodeGenBuffer cgbuf, FSharpList`1<ILType> savedStack, FSharpList`1<int> savedStackLocals);
    [CompilerGeneratedAttribute]
internal static ILAttribElem GenAttribArg$cont@6284-1(range m, Const c, string tynm, bool isobj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ILAttribElem GenAttribArg$cont@6284(range m, Const c, string tynm, bool isobj, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribElem GenAttribArg(ImportMap amap, TcGlobals g, IlxGenEnv eenv, Expr x, ILType ilArgTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute GenAttr(ImportMap amap, TcGlobals g, IlxGenEnv eenv, Attrib _arg9);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILAttribute> GenAttrs(cenv cenv, IlxGenEnv eenv, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILAttribute> GenCompilationArgumentCountsAttr(cenv cenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILSecurityDecl> CreatePermissionSets(cenv cenv, IlxGenEnv eenv, FSharpList`1<Attrib> securityAttributes);
    [CompilerGeneratedAttribute]
internal static bool contains@1-5(a e, FSharpList`1<a> xs1);
    internal static void GenTypeDefForCompLoc(cenv cenv, IlxGenEnv eenv, AssemblyBuilder mgbuf, CompileLocation cloc, bool hidden, FSharpList`1<Attrib> attribs, ILTypeInit initTrigger, bool eliminateIfEmpty, bool addAtEnd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenModuleExpr(cenv cenv, CodeGenBuffer cgbuf, QualifiedNameOfFile qname, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, IlxGenEnv eenv, ModuleOrNamespaceExprWithSig x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenModuleDefs(cenv cenv, CodeGenBuffer cgbuf, QualifiedNameOfFile qname, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, IlxGenEnv eenv, FSharpList`1<ModuleOrNamespaceExpr> mdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenModuleDef(cenv cenv, CodeGenBuffer cgbuf, QualifiedNameOfFile qname, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, IlxGenEnv eenv, ModuleOrNamespaceExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenModuleBinding(cenv cenv, CodeGenBuffer cgbuf, QualifiedNameOfFile qname, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, IlxGenEnv eenv, range m, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv GenTopImpl(cenv cenv, AssemblyBuilder mgbuf, FSharpOption`1<FSharpList`1<Attrib>> mainInfoOpt, IlxGenEnv eenv, TypedImplFile _arg10, FSharpFunc`2<Expr, Expr> optimizeDuringCodeGen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenForceWholeFileInitializationAsPartOfCCtor(cenv cenv, AssemblyBuilder mgbuf, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, ILTypeRef tref, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef GenEqualsOverrideCallingIComparable(cenv cenv, EntityRef tcref, ILType ilThisTy, f _ilThatTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldInit GenFieldInit(range m, Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<ILMethodDef>, FSharpList`1<ILPropertyDef>, FSharpList`1<ILEventDef>> GenAbstractBinding(cenv cenv, IlxGenEnv eenv, ILTypeRef tref, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILMethodDef> GenToStringMethod(cenv cenv, IlxGenEnv eenv, ILType ilThisTy, range m);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ILAttribute> defaultMemberAttrs$cont@6888(TcGlobals g, ValRef vref, string name, FSharpOption`1<ValMemberInfo> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<ILMethodDef> methodDefs$cont@7063(ILType ilThisTy, bool isStatic, bool isPropHidden, ILType ilPropType, string ilFieldName, RecdField fspec, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDef(cenv cenv, AssemblyBuilder mgbuf, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, IlxGenEnv eenv, range m, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExnDef(cenv cenv, AssemblyBuilder mgbuf, IlxGenEnv eenv, range m, Entity exnc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CodegenAssembly(cenv cenv, IlxGenEnv eenv, AssemblyBuilder mgbuf, FSharpList`1<Tuple`2<TypedImplFile, FSharpFunc`2<Expr, Expr>>> fileImpls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv GetEmptyIlxGenEnv(ILGlobals ilg, CcuThunk ccu);
    internal static IlxGenResults GenerateCode(cenv cenv, AnonTypeGenerationTable anonTypeTable, IlxGenEnv eenv, TypedAssemblyAfterOptimization _arg1, FSharpList`1<Attrib> assemAttribs, FSharpList`1<Attrib> moduleAttribs);
    internal static FSharpFunc`2<Type, object> get_defaultOf();
    internal static Lazy`1<MethodInfo> get_gminfo@7640();
    internal static Type objTyp@7655(ImportMap amap, ExecutionContext ctxt, Val v, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<object, Type>> LookupGeneratedValue(ImportMap amap, ExecutionContext ctxt, IlxGenEnv eenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ClearGeneratedValue(ExecutionContext ctxt, TcGlobals g, IlxGenEnv eenv, Val v);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Import : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanImportILScopeRef(ImportMap env, range m, ILScopeRef scoref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ImportTypeRefData(ImportMap env, range m, ILScopeRef scoref, String[] path, string typeName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ImportILTypeRefUncached(ImportMap env, range m, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ImportILTypeRef(ImportMap env, range m, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanImportILTypeRef(ImportMap env, range m, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportILType(ImportMap env, range m, FSharpList`1<TType> tinst, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanImportILType(ImportMap env, range m, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ImportProvidedNamedType(ImportMap env, range m, Tainted`1<ProvidedType> st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType ImportProvidedTypeAsILType(ImportMap env, range m, Tainted`1<ProvidedType> st);
    [CompilerGeneratedAttribute]
internal static EntityRef tcref$cont@283(TcGlobals g, EntityRef tcref, FSharpList`1<TType> genericArgs, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Measure conv$cont@297(range m, TcGlobals g, Typar tp, TType ty, Unit unitVar);
    internal static Measure conv@296-2(range m, TcGlobals g, Typar tp, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportProvidedType(ImportMap env, range m, Tainted`1<ProvidedType> st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodRef ImportProvidedMethodBaseAsILMethodRef(ImportMap env, range m, Tainted`1<ProvidedMethodBase> mbase);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> ImportILGenericParameters(FSharpFunc`2<Unit, ImportMap> amap, range m, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<ILGenericParameterDef> gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> multisetDiscriminateAndMap(FSharpFunc`2<Key, FSharpFunc`2<FSharpList`1<Tuple`2<FSharpList`1<Key>, Value>>, a>> nodef, FSharpFunc`2<Value, a> tipf, FSharpList`1<Tuple`2<FSharpList`1<Key>, Value>> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity ImportILTypeDef(FSharpFunc`2<Unit, ImportMap> amap, range m, ILScopeRef scoref, CompilationPath cpath, FSharpList`1<ILTypeDef> enc, string nm, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType ImportILTypeDefList(FSharpFunc`2<Unit, ImportMap> amap, range m, CompilationPath cpath, FSharpList`1<ILTypeDef> enc, FSharpList`1<Tuple`2<FSharpList`1<string>, Tuple`2<string, Lazy`1<Tuple`3<ILScopeRef, a, ILPreTypeDef>>>>> items);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<string>, Tuple`2<string, Lazy`1<Tuple`3<ILScopeRef, int, ILPreTypeDef>>>> mapping@1-17(ILScopeRef scoref, ILPreTypeDef pre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType ImportILTypeDefs(FSharpFunc`2<Unit, ImportMap> amap, range m, ILScopeRef scoref, CompilationPath cpath, FSharpList`1<ILTypeDef> enc, ILTypeDefs tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType ImportILAssemblyMainTypeDefs(FSharpFunc`2<Unit, ImportMap> amap, range m, ILScopeRef scoref, ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ModuleOrNamespaceType> ImportILAssemblyExportedType(FSharpFunc`2<Unit, ImportMap> amap, range m, FSharpFunc`2<ILScopeRef, ILModuleDef> auxModLoader, ILScopeRef scoref, ILExportedTypeOrForwarder exportedType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ModuleOrNamespaceType> ImportILAssemblyExportedTypes(FSharpFunc`2<Unit, ImportMap> amap, range m, FSharpFunc`2<ILScopeRef, ILModuleDef> auxModLoader, ILScopeRef scoref, ILExportedTypesAndForwarders exportedTypes);
    internal static ModuleOrNamespaceType ImportILAssemblyTypeDefs(FSharpFunc`2<Unit, ImportMap> amap, range m, FSharpFunc`2<ILScopeRef, ILModuleDef> auxModLoader, ILAssemblyRef aref, ILModuleDef mainmod);
    internal static FSharpList`1<Tuple`2<Tuple`2<String[], string>, Lazy`1<EntityRef>>> nested@549-2(range m, FSharpFunc`2<Unit, ImportMap> amap, ILExportedTypeOrForwarder exportedType, ILNestedExportedTypes nets, FSharpList`1<string> enc);
    internal static FSharpMap`2<Tuple`2<String[], string>, Lazy`1<EntityRef>> ImportILAssemblyTypeForwarders(FSharpFunc`2<Unit, ImportMap> amap, range m, ILExportedTypesAndForwarders exportedTypes);
    internal static CcuThunk ImportILAssembly(FSharpFunc`2<Unit, ImportMap> amap, range m, FSharpFunc`2<ILScopeRef, ILModuleDef> auxModuleLoader, ILScopeRef ilScopeRef, string sourceDir, FSharpOption`1<string> filename, ILModuleDef ilModule, IEvent`2<FSharpHandler`1<string>, string> invalidateCcu);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.IncrementalBuild : object {
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<int> nextid { get; }
    [CompilationMappingAttribute("9")]
internal static bool injectCancellationFault { get; internal set; }
    internal static FSharpRef`1<int> get_nextid();
    internal static Id NextId();
    internal static a visitVector@159(FSharpFunc`2<BuildRuleExpr, FSharpFunc`2<a, a>> op, VectorBuildRule ve, a acc);
    internal static a visitScalar@167(FSharpFunc`2<BuildRuleExpr, FSharpFunc`2<a, a>> op, ScalarBuildRule se, a acc);
    internal static a FoldOverBuildRules(BuildRules rules, FSharpFunc`2<BuildRuleExpr, FSharpFunc`2<a, a>> op, a acc);
    internal static BuildRules createRules@184(FSharpList`1<NamedOutput> names, Unit unitVar0);
    internal static BuildRules ToBuild(FSharpList`1<NamedOutput> names);
    internal static FSharpFunc`2<DateTime, FSharpFunc`2<Tuple`2<b, Result>, DateTime>> maximize@269();
    internal static FSharpOption`1<int> KnownValue@320(PartialBuild bt, Id id, Unit unitVar0);
    internal static FSharpOption`1<int> GetVectorWidthByExpr(PartialBuild bt, VectorBuildRule ve);
    internal static BuildRuleExpr GetTopLevelExprByName(PartialBuild bt, string seek);
    internal static BuildRuleExpr GetExprByName(PartialBuild bt, INode node);
    internal static FSharpOption`1<BuildRuleExpr> vectorExprOfId@350(Id seek, VectorBuildRule ve);
    internal static FSharpOption`1<BuildRuleExpr> scalarExprOfId@361(Id seek, ScalarBuildRule se);
    internal static FSharpOption`1<BuildRuleExpr> exprOfId@367(Id seek, BuildRuleExpr expr);
    internal static BuildRuleExpr GetExprById(PartialBuild bt, Id seek);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetVectorWidthById(PartialBuild bt, Id seek);
    internal static Result GetScalarExprResult(PartialBuild bt, ScalarBuildRule se);
    internal static FSharpOption`1<ResultVector> GetVectorExprResultVector(PartialBuild bt, VectorBuildRule ve);
    internal static Result GetVectorExprResult(PartialBuild bt, VectorBuildRule ve, int slot);
    internal static DateTime MaxTimestamp(PartialBuild bt, Id id);
    internal static InputSignature Signature(PartialBuild bt, Id id);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpFunc`2<Tuple`2<b, Result>, FSharpList`1<a>>> Extract@436(FSharpFunc`2<Result, a> extractor);
    internal static FSharpList`1<a> GetAvailable@435(FSharpFunc`2<Result, a> extractor, ResultVector rv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> AllResultsOfExpr(FSharpFunc`2<Result, a> extractor, PartialBuild bt, VectorBuildRule expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<object> AvailableAllResultsOfExpr(PartialBuild bt, VectorBuildRule expr);
    internal static FSharpMap`2<Id, ResultSet> applyScalarExpr@467(FSharpList`1<BuildInput> inputs, DateTime now, ScalarBuildRule tupledArg0, FSharpMap`2<Id, ResultSet> tupledArg1);
    internal static FSharpMap`2<Id, ResultSet> ApplyVectorExpr@480(FSharpList`1<BuildInput> inputs, DateTime now, VectorBuildRule tupledArg0, FSharpMap`2<Id, ResultSet> tupledArg1);
    internal static PartialBuild ToBound(BuildRules buildRules, FSharpList`1<BuildInput> inputs);
    internal static bool isSeen@512(Dictionary`2<Id, bool> seen, Id id);
    internal static bool shouldEvaluate@518(PartialBuild tupledArg0, InputSignature tupledArg1, Id tupledArg2);
    internal static T resizeVectorExpr@524(PartialBuild bt, FSharpFunc`2<Action, FSharpFunc`2<T, T>> actionFunc, VectorBuildRule tupledArg0, T tupledArg1);
    internal static T MapResults@593(PartialBuild bt, FSharpFunc`2<Action, FSharpFunc`2<T, T>> actionFunc, VectorBuildRule ve, string taskname, VectorBuildRule inputExpr, Id id, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<object, object>> func, int cardinality, T acc, int slot);
    internal static T checkStamp@624(TimeStampCache cache, CompilationThreadToken ctok, PartialBuild bt, FSharpFunc`2<Action, FSharpFunc`2<T, T>> actionFunc, VectorBuildRule ve, string taskname, VectorBuildRule inputExpr, Id id, FSharpFunc`2<TimeStampCache, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<object, DateTime>>> func, int cardinality, T acc, int slot);
    internal static T visitVector@538-1(TimeStampCache cache, CompilationThreadToken ctok, PartialBuild bt, FSharpFunc`2<Action, FSharpFunc`2<T, T>> actionFunc, Dictionary`2<Id, bool> seen, FSharpOption`1<int> optSlot, VectorBuildRule ve, T acc);
    internal static T visitScalar@654-1(TimeStampCache cache, CompilationThreadToken ctok, PartialBuild bt, FSharpFunc`2<Action, FSharpFunc`2<T, T>> actionFunc, Dictionary`2<Id, bool> seen, ScalarBuildRule se, T acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T ForeachAction(TimeStampCache cache, CompilationThreadToken ctok, Target _arg1, PartialBuild bt, FSharpFunc`2<Action, FSharpFunc`2<T, T>> actionFunc, T acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Action> CollectActions(TimeStampCache cache, Target target, PartialBuild bt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DateTime ComputeMaxTimeStamp(TimeStampCache cache, CompilationThreadToken ctok, string output, PartialBuild bt, DateTime acc);
    internal static PartialBuild ApplyResult(ActionResult actionResult, PartialBuild bt);
    internal static bool get_injectCancellationFault();
    internal static void set_injectCancellationFault(bool value);
    internal static IDisposable LocallyInjectCancellationFault();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<PartialBuild> ExecuteApply(CompilationThreadToken ctok, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<PartialBuild, Unit>> save, Action action, PartialBuild bt);
    internal static Cancellable`1<PartialBuild> eval@777(TimeStampCache cache, CompilationThreadToken ctok, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<PartialBuild, Unit>> save, Target target, PartialBuild tupledArg0, int tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<PartialBuild> EvalLeafsFirst(TimeStampCache cache, CompilationThreadToken ctok, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<PartialBuild, Unit>> save, Target target, PartialBuild bt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<FSharpOption`1<PartialBuild>> Step(TimeStampCache cache, CompilationThreadToken ctok, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<PartialBuild, Unit>> save, Target target, PartialBuild bt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<PartialBuild> Eval(TimeStampCache cache, CompilationThreadToken ctok, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<PartialBuild, Unit>> save, INode node, PartialBuild bt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<PartialBuild> EvalUpTo(TimeStampCache cache, CompilationThreadToken ctok, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<PartialBuild, Unit>> save, INode node, int n, PartialBuild bt);
    internal static FSharpOption`1<Tuple`2<T, DateTime>> GetScalarResult(Scalar`1<T> node, PartialBuild bt);
    internal static T[] GetVectorResult(Vector`1<T> node, PartialBuild bt);
    internal static FSharpOption`1<Tuple`2<T, DateTime>> GetVectorResultBySlot(Vector`1<T> node, int slot, PartialBuild bt);
    internal static FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<Tuple`2<a, Result>, FSharpOption`1<a>>> MatchNames@871(FSharpFunc`2<T, bool> found);
    internal static FSharpOption`1<int> TryGetSlotByInput(Vector`1<T> node, PartialBuild build, FSharpFunc`2<T, bool> found);
    internal static Vector`1<T> InputVector(string name);
    internal static Scalar`1<T> InputScalar(string name);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.IncrementalBuilder : object {
    internal FSharpList`1<UnresolvedAssemblyReference> unresolvedReferences;
    internal TcGlobals tcGlobals;
    internal TcConfig tcConfig;
    internal string outfile;
    internal FSharpList`1<AssemblyResolution> nonFrameworkResolutions;
    internal NiceNameGenerator niceNameGen;
    internal long maxTimeShareMilliseconds;
    internal FSharpOption`1<LoadClosure> loadClosureOpt;
    internal LexResourceManager lexResourceManager;
    internal bool keepAssemblyContents;
    internal bool keepAllBackgroundResolutions;
    internal TcImports frameworkTcImports;
    internal string assemblyName;
    internal TcConfigProvider tcConfigP;
    internal FSharpEvent`1<string> fileParsed;
    internal FSharpEvent`1<string> beforeFileChecked;
    internal FSharpEvent`1<string> fileChecked;
    internal FSharpEvent`1<Unit> projectChecked;
    internal FSharpEvent`1<string> importsInvalidatedByTypeProvider;
    internal FSharpOption`1<TcImports> currentTcImportsOpt;
    internal FSharpList`1<Tuple`3<range, string, Tuple`2<bool, bool>>> sourceFiles@1227-1;
    internal DateTime defaultTimeStamp;
    internal FSharpList`1<string> basicDependencies;
    internal String[] allDependencies;
    internal Vector`1<Tuple`3<range, string, Tuple`2<bool, bool>>> fileNamesNode;
    internal Vector`1<Tuple`3<range, string, Tuple`2<bool, bool>>> stampedFileNamesNode;
    internal Vector`1<Tuple`2<FSharpChoice`2<string, IProjectReference>, FSharpFunc`2<TimeStampCache, FSharpFunc`2<CompilationThreadToken, DateTime>>>> stampedReferencedAssembliesNode;
    internal Scalar`1<TypeCheckAccumulator> initialTcAccNode;
    internal Vector`1<TypeCheckAccumulator> tcStatesNode;
    internal Scalar`1<Tuple`4<ILAssemblyRef, FSharpOption`1<IRawFSharpAssemblyData>, FSharpOption`1<FSharpList`1<TypedImplFile>>, TypeCheckAccumulator>> finalizedTypeCheckNode;
    internal PartialBuild partialBuild;
    internal TcConfig TcConfig { get; }
    internal IEvent`2<FSharpHandler`1<string>, string> FileParsed { get; }
    internal IEvent`2<FSharpHandler`1<string>, string> BeforeFileChecked { get; }
    internal IEvent`2<FSharpHandler`1<string>, string> FileChecked { get; }
    internal IEvent`2<FSharpHandler`1<Unit>, Unit> ProjectChecked { get; }
    internal IEvent`2<FSharpHandler`1<string>, string> ImportsInvalidatedByTypeProvider { get; }
    internal String[] AllDependenciesDeprecated { get; }
    internal FSharpList`1<string> SourceFiles { get; }
    public IncrementalBuilder(TcGlobals tcGlobals, TcImports frameworkTcImports, FSharpList`1<Tuple`2<FSharpChoice`2<string, IProjectReference>, FSharpFunc`2<TimeStampCache, FSharpFunc`2<CompilationThreadToken, DateTime>>>> nonFrameworkAssemblyInputs, FSharpList`1<AssemblyResolution> nonFrameworkResolutions, FSharpList`1<UnresolvedAssemblyReference> unresolvedReferences, TcConfig tcConfig, string projectDirectory, string outfile, string assemblyName, NiceNameGenerator niceNameGen, LexResourceManager lexResourceManager, FSharpList`1<string> sourceFiles, FSharpOption`1<LoadClosure> loadClosureOpt, bool keepAssemblyContents, bool keepAllBackgroundResolutions, long maxTimeShareMilliseconds);
    internal TcConfig get_TcConfig();
    internal IEvent`2<FSharpHandler`1<string>, string> get_FileParsed();
    internal IEvent`2<FSharpHandler`1<string>, string> get_BeforeFileChecked();
    internal IEvent`2<FSharpHandler`1<string>, string> get_FileChecked();
    internal IEvent`2<FSharpHandler`1<Unit>, Unit> get_ProjectChecked();
    internal IEvent`2<FSharpHandler`1<string>, string> get_ImportsInvalidatedByTypeProvider();
    internal FSharpOption`1<TcImports> TryGetCurrentTcImports();
    internal String[] get_AllDependenciesDeprecated();
    internal Cancellable`1<bool> Step(CompilationThreadToken ctok);
    internal FSharpOption`1<PartialCheckResults> GetCheckResultsBeforeFileInProjectEvenIfStale(string filename);
    internal bool AreCheckResultsBeforeFileInProjectReady(string filename);
    internal Cancellable`1<PartialCheckResults> GetCheckResultsBeforeSlotInProject(CompilationThreadToken ctok, int slotOfFile);
    internal Cancellable`1<PartialCheckResults> GetCheckResultsBeforeFileInProject(CompilationThreadToken ctok, string filename);
    internal Cancellable`1<PartialCheckResults> GetCheckResultsAfterFileInProject(CompilationThreadToken ctok, string filename);
    internal Cancellable`1<PartialCheckResults> GetCheckResultsAfterLastFileInProject(CompilationThreadToken ctok);
    internal Cancellable`1<Tuple`4<PartialCheckResults, ILAssemblyRef, FSharpOption`1<IRawFSharpAssemblyData>, FSharpOption`1<FSharpList`1<TypedImplFile>>>> GetCheckResultsAndImplementationsForProject(CompilationThreadToken ctok);
    internal DateTime GetLogicalTimeStampForProject(TimeStampCache cache, CompilationThreadToken ctok);
    internal int GetSlotOfFileName(string filename);
    internal int GetSlotsCount();
    internal Cancellable`1<Tuple`4<FSharpOption`1<ParsedInput>, range, string, Tuple`2[]>> GetParseResultsForFile(CompilationThreadToken ctok, string filename);
    internal FSharpList`1<string> get_SourceFiles();
    internal static Cancellable`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpErrorInfo[]>> TryCreateBackgroundBuilderForProjectOptions(CompilationThreadToken ctok, Resolver legacyReferenceResolver, string defaultFSharpBinariesDir, FrameworkImportsCache frameworkTcImportsCache, FSharpOption`1<LoadClosure> scriptClosureOptions, FSharpList`1<string> sourceFiles, FSharpList`1<string> commandLineArgs, FSharpList`1<IProjectReference> projectReferences, string projectDirectory, bool useScriptResolutionRules, bool keepAssemblyContents, bool keepAllBackgroundResolutions, long maxTimeShareMilliseconds, FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot, bool suggestNamesForErrors);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal DateTime StampFileNameTask(TimeStampCache cache, a _ctok, range _m, string filename, b _isLastCompiland);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`4<FSharpOption`1<ParsedInput>, range, string, Tuple`2[]> ParseTask(CompilationThreadToken ctok, range sourceRange, string filename, Tuple`2<bool, bool> isLastCompiland);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal c StampReferencedAssemblyTask(TimeStampCache cache, a ctok, b _ref, FSharpFunc`2<TimeStampCache, FSharpFunc`2<a, c>> timeStamper);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Cancellable`1<TypeCheckAccumulator> CombineImportedAssembliesTask(CompilationThreadToken ctok, a _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Eventually`1<TypeCheckAccumulator> TypeCheckTask(CompilationThreadToken ctok, TypeCheckAccumulator tcAcc, FSharpOption`1<ParsedInput> input_0, a input_1, string input_2, Tuple`2[] input_3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Cancellable`1<Tuple`4<ILAssemblyRef, FSharpOption`1<IRawFSharpAssemblyData>, FSharpOption`1<FSharpList`1<TypedImplFile>>, TypeCheckAccumulator>> FinalizeTypeCheckTask(CompilationThreadToken ctok, TypeCheckAccumulator[] tcStates);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal void SavePartialBuild(CompilationThreadToken ctok, PartialBuild b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal DateTime MaxTimeStampInDependencies(TimeStampCache cache, CompilationThreadToken ctok, INode output);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.IncrementalBuilderEventTesting : object {
    [CompilationMappingAttribute("9")]
internal static FixedLengthMRU`1<IBEvent> MRU { get; }
    internal static FixedLengthMRU`1<IBEvent> get_MRU();
    internal static FSharpList`1<IBEvent> GetMostRecentIncrementalBuildEvents(int n);
    internal static int GetCurrentIncrementalBuildEventNum();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.InfoReader : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> SelectImmediateMemberVals(TcGlobals g, FSharpOption`1<string> optFilter, FSharpFunc`2<ValMemberInfo, FSharpFunc`2<ValRef, FSharpOption`1<a>>> f, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkFilter(FSharpOption`1<string> optFilter, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MethInfo> TrySelectMemberVal(TcGlobals g, FSharpOption`1<string> optFilter, TType ty, FSharpOption`1<ulong> pri, a _membInfo, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetImmediateIntrinsicMethInfosOfTypeAux(FSharpOption`1<string> optFilter, AccessorDomain ad, TcGlobals g, ImportMap amap, range m, TType origTy, TType metadataTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetImmediateIntrinsicMethInfosOfType(FSharpOption`1<string> optFilter, AccessorDomain ad, TcGlobals g, ImportMap amap, range m, TType ty);
    [CompilerGeneratedAttribute]
internal static int hasher@1(PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> GetImmediateIntrinsicPropInfosOfTypeAux(FSharpOption`1<string> optFilter, AccessorDomain ad, TcGlobals g, ImportMap amap, range m, TType origTy, TType metadataTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> GetImmediateIntrinsicPropInfosOfType(FSharpOption`1<string> optFilter, AccessorDomain ad, TcGlobals g, ImportMap amap, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsIndexerType(TcGlobals g, ImportMap amap, TType ty);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<HierarchyItem> GetIntrinsicNamedItemsUncached$cont@318(FSharpOption`1<HierarchyItem> acc, FSharpList`1<PropInfo> pinfos, FSharpList`1<ILFieldInfo> finfos, FSharpList`1<EventInfo> einfos, FSharpList`1<RecdFieldInfo> rfinfos, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<MethInfo> f@105-10(InfoReader infoReader, range m, TType origTy, TType metadataTy, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetIntrinsicConstructorInfosOfTypeAux(InfoReader infoReader, range m, TType origTy, TType metadataTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetIntrinsicConstructorInfosOfType(InfoReader infoReader, range m, TType ty);
    internal static IndexedList`1<a> loop@537-54(FSharpFunc`2<a, string> nmf, FSharpFunc`2<a, FSharpFunc`2<a, bool>> keepTest, FSharpList`1<FSharpList`1<a>> itemLists);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<a>> FilterItemsInSubTypesBasedOnItemsInSuperTypes(FSharpFunc`2<a, string> nmf, FSharpFunc`2<a, FSharpFunc`2<a, bool>> keepTest, FSharpList`1<FSharpList`1<a>> itemLists);
    internal static FSharpList`1<FSharpList`1<a>> loop@548-55(FSharpFunc`2<a, string> nmf, FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<a>, bool>> keepTest, FSharpList`1<FSharpList`1<a>> itemLists, IndexedList`1<a> indexedItemsInSubTypes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<a>> FilterItemsInSuperTypesBasedOnItemsInSubTypes(FSharpFunc`2<a, string> nmf, FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<a>, bool>> keepTest, FSharpList`1<FSharpList`1<a>> itemLists);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<a>> ExcludeItemsInSuperTypesBasedOnEquivTestWithItemsInSubTypes(FSharpFunc`2<a, string> nmf, FSharpFunc`2<a, FSharpFunc`2<a, bool>> equivTest, FSharpList`1<FSharpList`1<a>> itemLists);
    internal static bool equivVirts@563(FSharpFunc`2<a, bool> isVirt, FSharpFunc`2<a, FSharpFunc`2<a, bool>> equivSigs, a x, a y);
    internal static FSharpFunc`2<a, bool> equivNewSlots@582(FSharpFunc`2<a, bool> isNewSlot, FSharpFunc`2<a, FSharpFunc`2<a, bool>> equivSigs, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<a>> FilterOverrides(FindMemberFlag findFlag, FSharpFunc`2<a, bool> isVirt, FSharpFunc`2<a, bool> isNewSlot, FSharpFunc`2<a, bool> isDefiniteOverride, FSharpFunc`2<a, bool> isFinal, FSharpFunc`2<a, FSharpFunc`2<a, bool>> equivSigs, FSharpFunc`2<a, string> nmf, FSharpList`1<FSharpList`1<a>> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<MethInfo>> FilterOverridesOfMethInfos(FindMemberFlag findFlag, TcGlobals g, ImportMap amap, range m, FSharpList`1<FSharpList`1<MethInfo>> minfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<PropInfo>> FilterOverridesOfPropInfos(FindMemberFlag findFlag, TcGlobals g, ImportMap amap, range m, FSharpList`1<FSharpList`1<PropInfo>> props);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> ExcludeHiddenOfMethInfos(TcGlobals g, ImportMap amap, range m, FSharpList`1<FSharpList`1<MethInfo>> minfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> ExcludeHiddenOfPropInfos(TcGlobals g, ImportMap amap, range m, FSharpList`1<FSharpList`1<PropInfo>> pinfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<MethInfo>> GetIntrinsicMethInfoSetsOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<PropInfo>> GetIntrinsicPropInfoSetsOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetIntrinsicMethInfosOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> GetIntrinsicPropInfosOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<HierarchyItem> TryFindIntrinsicNamedItemOfType(InfoReader infoReader, string nm, AccessorDomain ad, FindMemberFlag findFlag, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> TryFindIntrinsicMethInfo(InfoReader infoReader, range m, AccessorDomain ad, string nm, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> TryFindPropInfo(InfoReader infoReader, range m, AccessorDomain ad, string nm, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SigOfFunctionForDelegate GetSigOfFunctionForDelegate(InfoReader infoReader, TType delty, range m, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<TType, TType>> TryDestStandardDelegateType(InfoReader infoReader, range m, AccessorDomain ad, TType delTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsStandardEventInfo(InfoReader infoReader, range m, AccessorDomain ad, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ArgsTypOfEventInfo(InfoReader infoReader, range m, AccessorDomain ad, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType PropTypOfEventInfo(InfoReader infoReader, range m, AccessorDomain ad, EventInfo einfo);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Infos : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportILType(ILScopeRef scoref, ImportMap amap, range m, FSharpList`1<TType> importInst, ILType ilty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanImportILType(ILScopeRef scoref, ImportMap amap, range m, ILType ilty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isExnDeclTy(TcGlobals g, TType ty);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<TType> GetSuperTypeOfType$cont@71(TcGlobals g, TType ty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> GetSuperTypeOfType(TcGlobals g, ImportMap amap, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkSystemCollectionsGenericIListTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> GetImmediateInterfacesOfType(SkipUnrefInterfaces skipUnref, TcGlobals g, ImportMap amap, range m, TType ty);
    internal static Tuple`3<FSharpSet`1<long>, TyconRefMultiMap`1<TType>, a> loop@155-50(bool followInterfaces, AllowMultiIntfInstantiations allowMultiIntfInst, SkipUnrefInterfaces skipUnref, FSharpFunc`2<TType, FSharpFunc`2<a, a>> visitor, TcGlobals g, ImportMap amap, range m, int ndeep, TType ty, Tuple`3<FSharpSet`1<long>, TyconRefMultiMap`1<TType>, a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a FoldHierarchyOfTypeAux(bool followInterfaces, AllowMultiIntfInstantiations allowMultiIntfInst, SkipUnrefInterfaces skipUnref, FSharpFunc`2<TType, FSharpFunc`2<a, a>> visitor, TcGlobals g, ImportMap amap, range m, TType ty, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a FoldPrimaryHierarchyOfType(FSharpFunc`2<TType, FSharpFunc`2<a, a>> f, TcGlobals g, ImportMap amap, range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a FoldEntireHierarchyOfType(FSharpFunc`2<TType, FSharpFunc`2<a, a>> f, TcGlobals g, ImportMap amap, range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IterateEntireHierarchyOfType(FSharpFunc`2<TType, Unit> f, TcGlobals g, ImportMap amap, range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExistsInEntireHierarchyOfType(FSharpFunc`2<TType, bool> f, TcGlobals g, ImportMap amap, range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> SearchEntireHierarchyOfType(FSharpFunc`2<TType, bool> f, TcGlobals g, ImportMap amap, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> AllSuperTypesOfType(TcGlobals g, ImportMap amap, range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> AllInterfacesOfType(TcGlobals g, ImportMap amap, range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HaveSameHeadType(TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasHeadType(TcGlobals g, EntityRef tcref, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExistsSameHeadTypeInHierarchy(TcGlobals g, ImportMap amap, range m, TType typeToSearchFrom, TType typeToLookFor);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExistsHeadTypeInEntireHierarchy(TcGlobals g, ImportMap amap, range m, TType typeToSearchFrom, EntityRef tcrefToLookFor);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportILTypeFromMetadata(ImportMap amap, range m, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<TType> minst, ILType ilty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportILTypeFromMetadataWithAttributes(ImportMap amap, range m, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<TType> minst, ILType ilty, ILAttributes cattrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportParameterTypeFromMetadata(ImportMap amap, range m, ILType ilty, ILAttributes cattrs, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<TType> mist);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> ImportReturnTypeFromMetadata(ImportMap amap, range m, ILType ilty, ILAttributes cattrs, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<TType> minst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TyparConstraint> CopyTyparConstraints(range m, FSharpList`1<Tuple`2<Typar, TType>> tprefInst, Typar tporig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>> FixupNewTypars(range m, FSharpList`1<Typar> formalEnclosingTypars, FSharpList`1<TType> tinst, FSharpList`1<Typar> tpsorig, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.IsFSharpEventProperty(ValRef x, TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.get_IsVirtualMember(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.get_IsDispatchSlotMember(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.get_IsDefiniteFSharpOverrideMember(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.IsFSharpExplicitInterfaceImplementation(ValRef vref, TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<SlotSig> ValRef.get_ImplementedSlotSignatures(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> GetCompiledReturnTyOfProvidedMethodInfo(ImportMap amap, range m, Tainted`1<ProvidedMethodBase> mi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig ReparentSlotSigToUseMethodTypars(TcGlobals g, range m, ValRef ovByMethValRef, SlotSig slotsig);
    internal static SlotParam MakeSlotParam(TType ty, ArgReprInfo argInfo);
    internal static SlotSig MakeSlotSig(string nm, TType ty, FSharpList`1<Typar> ctps, FSharpList`1<Typar> mtps, FSharpList`1<FSharpList`1<SlotParam>> paraml, FSharpOption`1<TType> retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpOption`1<TType>, FSharpList`1<TType>> AnalyzeTypeOfMemberVal(bool isCSharpExt, TcGlobals g, TType ty, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType GetObjTypeOfInstanceExtensionMethod(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> GetArgInfosOfMember(bool isCSharpExt, TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> CombineMethInsts(FSharpList`1<Typar> ttps, FSharpList`1<Typar> mtps, FSharpList`1<TType> tinst, FSharpList`1<TType> minst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> GetInstantiationForMemberVal(TcGlobals g, bool isCSharpExt, TType ty, ValRef vref, FSharpList`1<TType> methTyArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> GetInstantiationForPropertyVal(TcGlobals g, TType ty, ValRef vref);
    internal static OptionalArgCallerSideValue analyze@521(TcGlobals g, ILParameter ilParam, TType ty);
    [CompilerGeneratedAttribute]
internal static ILFieldInit FromProvidedObj$cont@595(range m, object v, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldInit ILFieldInit.FromProvidedObj.Static(range m, object v);
    internal static OptionalArgCallerSideValue analyze@625-1(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OptionalArgInfo OptionalArgInfoOfProvidedParameter(ImportMap amap, range m, Tainted`1<ProvidedParameterInfo> provParam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tainted`1<ProvidedMethodBase> GetAndSanityCheckProviderMethod(range m, Tainted`1<T> mi, FSharpFunc`2<T, ProvidedMethodInfo> get, FSharpFunc`2<Tuple`2<string, string>, Tuple`2<int, string>> err);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tainted`1<ProvidedMethodBase> ArbitraryMethodInfoOfPropertyInfo(Tainted`1<ProvidedPropertyInfo> pi, range m);
    internal static ParamNameAndType func1@1-8(TType tupledArg0, ArgReprInfo tupledArg1);
    internal static bool optVrefEq@2199(TcGlobals g, FSharpOption`1<ValRef> _arg10, FSharpOption`1<ValRef> _arg11);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyConformsToIDelegateEvent(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception nonStandardEventError(string nm, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType FindDelegateTypeOfPropertyEvent(TcGlobals g, ImportMap amap, string nm, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompiledSig CompiledSigOfMeth(TcGlobals g, ImportMap amap, range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethInfosEquivByNameAndPartialSig(Erasure erasureFlag, bool ignoreFinal, TcGlobals g, ImportMap amap, range m, MethInfo minfo, MethInfo minfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PropInfosEquivByNameAndPartialSig(Erasure erasureFlag, TcGlobals g, ImportMap amap, range m, PropInfo pinfo, PropInfo pinfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethInfosEquivByNameAndSig(Erasure erasureFlag, bool ignoreFinal, TcGlobals g, ImportMap amap, range m, MethInfo minfo, MethInfo minfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PropInfosEquivByNameAndSig(Erasure erasureFlag, TcGlobals g, ImportMap amap, range m, PropInfo pinfo, PropInfo pinfo2);
    internal static FSharpList`1<Tuple`2<MethInfo, FSharpOption`1<PropInfo>>> SettersOfPropInfos(FSharpList`1<PropInfo> pinfos);
    internal static FSharpList`1<Tuple`2<MethInfo, FSharpOption`1<PropInfo>>> GettersOfPropInfos(FSharpList`1<PropInfo> pinfos);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.InnerLambdasToTopLevelFuncs : object {
    internal static bool verboseTLR { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<BindingGroupSharingSameReqdItems> fclassOrder { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ReqdItem> reqdItemOrder { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_verboseTLR();
    internal static a internalError(string str);
    internal static FSharpList`1<b> collect@45-3(Tree`1<b> tr, FSharpList`1<b> acc);
    internal static FSharpList`1<a> fringeTR(Tree`1<a> tr);
    internal static Tuple`5<Expr, TType, FSharpList`1<TType>, a, b> destApp(Expr f, TType fty, FSharpList`1<TType> tys, a args, b m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDelayedRepr(Val f, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val mkLocalNameTypeArity(bool compgen, range m, string name, TType ty, FSharpOption`1<ValReprInfo> topValInfo);
    internal static Set`2<Val, IComparer`1<Val>> GetValsBoundUnderMustInline(Results xinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsRefusedTLR(TcGlobals g, Val f);
    internal static bool IsMandatoryTopLevel(Val f);
    internal static IComparer`1<BindingGroupSharingSameReqdItems> get_fclassOrder();
    internal static IComparer`1<ReqdItem> get_reqdItemOrder();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsArityMet(ValRef vref, int wf, FSharpList`1<TType> tys, FSharpList`1<a> args);
    internal static Map`3<Val, Val, IComparer`1<Val>> carrierMapFor@701(Map`3<Val, BindingGroupSharingSameReqdItems, IComparer`1<Val>> fclassM, Map`3<BindingGroupSharingSameReqdItems, Map`3<Val, Val, IComparer`1<Val>>, IComparer`1<BindingGroupSharingSameReqdItems>> carrierMaps, Val f);
    internal static Expr aenvExprFor@754(ReqdItemsForDefn env, Map`3<Val, Val, IComparer`1<Val>> cmap, Val v);
    internal static FSharpFunc`2<BindingGroupSharingSameReqdItems, Tuple`2<Tuple`2<BindingGroupSharingSameReqdItems, PackedReqdItems>, Map`3<BindingGroupSharingSameReqdItems, Map`3<Val, Val, IComparer`1<Val>>, IComparer`1<BindingGroupSharingSameReqdItems>>>> packEnv@696(TcGlobals g, Map`3<Val, BindingGroupSharingSameReqdItems, IComparer`1<Val>> fclassM, Set`2<Val, IComparer`1<Val>> topValS, Map`3<BindingGroupSharingSameReqdItems, ReqdItemsForDefn, IComparer`1<BindingGroupSharingSameReqdItems>> reqdItemsMap, Map`3<BindingGroupSharingSameReqdItems, Map`3<Val, Val, IComparer`1<Val>>, IComparer`1<BindingGroupSharingSameReqdItems>> carrierMaps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<BindingGroupSharingSameReqdItems, PackedReqdItems, IComparer`1<BindingGroupSharingSameReqdItems>> FlatEnvPacks(TcGlobals g, Map`3<Val, BindingGroupSharingSameReqdItems, IComparer`1<Val>> fclassM, Set`2<Val, IComparer`1<Val>> topValS, FSharpList`1<a> declist, Map`3<BindingGroupSharingSameReqdItems, ReqdItemsForDefn, IComparer`1<BindingGroupSharingSameReqdItems>> reqdItemsMap);
    internal static Val createFHat@838(TcGlobals g, Map`3<Val, int, IComparer`1<Val>> arityM, Map`3<Val, BindingGroupSharingSameReqdItems, IComparer`1<Val>> fclassM, Map`3<BindingGroupSharingSameReqdItems, PackedReqdItems, IComparer`1<BindingGroupSharingSameReqdItems>> envPackM, Val f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Val, Val, IComparer`1<Val>> CreateNewValuesForTLR(TcGlobals g, Set`2<Val, IComparer`1<Val>> tlrS, Map`3<Val, int, IComparer`1<Val>> arityM, Map`3<Val, BindingGroupSharingSameReqdItems, IComparer`1<Val>> fclassM, Map`3<BindingGroupSharingSameReqdItems, PackedReqdItems, IComparer`1<BindingGroupSharingSameReqdItems>> envPackM);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypedImplFile MakeTLRDecisions(CcuThunk ccu, TcGlobals g, TypedImplFile expr);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Interactive.Shell : object {
    internal static Layout makeListL@308(FSharpList`1<Layout> itemLs);
    internal static string prune@491(string text);
    [CompilerGeneratedAttribute]
internal static void f@87-44(FsiStdinSyphon syphon, TcConfigBuilder tcConfig, PhasedDiagnostic err, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ErrorLogger.CheckForErrors(ErrorLogger );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ErrorLogger.AbortOnError(ErrorLogger x, FsiConsoleOutput fsiConsoleOutput);
    internal static string directoryName(string s);
    internal static void InstallErrorLoggingOnThisThread(ErrorLogger errorLogger);
    internal static void SetServerCodePages(FsiCommandLineOptions fsiOptions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a WithImplicitHome(TcConfigBuilder tcConfigB, string dir, FSharpFunc`2<Unit, a> f);
    internal static SynBinding mkBind@1222(range m, SynPat pat, SynExpr expr);
    [CompilerGeneratedAttribute]
internal static Tuple`4<TcState, TopAttribs, FSharpList`1<TypedImplFile>, TcEnv> action@1-13(FsiDynamicCompiler this, FSharpList`1<Ident> prefixPath, FSharpList`1<ParsedInput> inputs, ErrorLogger errorLogger, CompilationThreadToken ctok, TcState tcState, TcConfig tcConfig, Unit _arg1);
    [CompilerGeneratedAttribute]
internal static void arg10@1068(FsiDynamicCompiler this, ErrorLogger errorLogger, FSharpList`1<FSharpFunc`2<Unit, FSharpOption`1<Exception>>> execs, Unit unitVar0);
    internal static void raiseCtrlC@1418(FsiInterruptController controller, Thread threadToKill, int pauseMilliseconds, Unit unitVar0);
    internal static void register@1467(Type monoUnixStdlib, Delegate monoHandler, object monoSignalNumber, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<ErrorLogger, FSharpFunc`2<Tuple`2<FSharpOption`1<ParsedFsiInteraction>, FsiDynamicCompilerState>, Tuple`2<FsiDynamicCompilerState, FsiInteractionStepStatus>>> clo0@2114-1496(FsiInteractionProcessor __, CompilationThreadToken ctok);
    internal static Tuple`2<FsiDynamicCompilerState, FsiInteractionStepStatus> run@2132-1(FsiInteractionProcessor processor, CompilationThreadToken ctok, ErrorLogger errorLogger, LexFilter tokenizer, FsiDynamicCompilerState istate);
    internal static FsiDynamicCompilerState consume@2162-1(FsiInteractionProcessor processor, CompilationThreadToken ctok, ErrorLogger errorLogger, FsiDynamicCompilerState istate, FSharpList`1<Tuple`2<string, bool>> sourceFiles);
    internal static void loop@2254-142(FsiInteractionProcessor processor, ErrorLogger errorLogger, FSharpFunc`2<FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<FsiDynamicCompilerState, Tuple`2<FsiDynamicCompilerState, FsiInteractionStepStatus>>>, FSharpFunc`2<FsiDynamicCompilerState, Tuple`2<FsiDynamicCompilerState, FsiInteractionStepStatus>>> runCodeOnMainThread, LexFilter currTokenizer);
    internal static FSharpFunc`2<b, token> lexerWhichSavesLastToken@1851(LexFilter tokenizer, FSharpRef`1<token> lastToken);
    internal static bool isBreakable@1985(SynModuleDecl def);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SpawnThread(string name, FSharpFunc`2<Unit, Unit> f);
    internal static void SpawnInteractiveServer(FsiEvaluationSessionHostConfig fsi, FsiCommandLineOptions fsiOptions, FsiConsoleOutput fsiConsoleOutput);
    internal static void runLoop@2356(FsiConsoleOutput fsiConsoleOutput, FsiEvaluationSessionHostConfig fsi, Unit unitVar0);
    internal static void DriveFsiEventLoop(FsiEvaluationSessionHostConfig fsi, FsiConsoleOutput fsiConsoleOutput);
    [CompilerGeneratedAttribute]
internal static void action@1-14(CompilerInputStream x, string str, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Byte[]> action@1-15(CompilerInputStream this, int count, Unit unitVar0);
    internal static Byte[] loop@2949-143(CompilerInputStream this, int count, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void action@1-16(CompilerOutputStream x, int offset, Byte[] buffer, int stop, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static string action@1-17(CompilerOutputStream x, Unit unitVar0);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Layout : object {
    [CompilationMappingAttribute("9")]
public static Layout emptyL { get; }
    internal static int chunkN { get; }
    [CompilationMappingAttribute("9")]
public static LayoutRenderer`2<string, FSharpList`1<string>> stringR { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TaggedText mkNav(range r, TaggedText t);
    internal static bool juxtLeft(Layout _arg1);
    internal static bool juxtRight(Layout _arg1);
    public static Layout get_emptyL();
    public static bool isEmptyL(Layout _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout mkNode(Layout l, Layout r, Joint joint);
    public static Layout wordL(TaggedText str);
    public static Layout sepL(TaggedText str);
    public static Layout rightL(TaggedText str);
    public static Layout leftL(TaggedText str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout aboveL(Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout apply2(FSharpFunc`2<Layout, FSharpFunc`2<Layout, Layout>> f, Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_HatHat(Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_PlusPlus(Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_MinusMinus(Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_MinusMinusMinus(Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_MinusMinusMinusMinus(Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_MinusMinusMinusMinusMinus(Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_AtAt(Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_AtAtMinus(Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_AtAtMinusMinus(Layout l, Layout r);
    internal static Layout process'@242-1(FSharpFunc`2<Layout, Layout> tagger, Layout prefixL, FSharpList`1<Layout> _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout tagListL(FSharpFunc`2<Layout, Layout> tagger, FSharpList`1<Layout> _arg1);
    public static Layout commaListL(FSharpList`1<Layout> x);
    public static Layout semiListL(FSharpList`1<Layout> x);
    public static Layout spaceListL(FSharpList`1<Layout> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout sepListL(Layout x, FSharpList`1<Layout> y);
    public static Layout bracketL(Layout l);
    public static Layout tupleL(FSharpList`1<Layout> xs);
    public static Layout aboveListL(FSharpList`1<Layout> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout optionL(FSharpFunc`2<a, Layout> xL, FSharpOption`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout listL(FSharpFunc`2<a, Layout> xL, FSharpList`1<a> xs);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_chunkN();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static breaks pushBreak(int saving, breaks _arg1);
    internal static Tuple`2<breaks, bool> popBreak(breaks _arg1);
    internal static FSharpOption`1<Tuple`2<breaks, int>> forceBreak(breaks _arg1);
    internal static Tuple`4<breaks, Layout, int, int> fitLeaf@332-1(int maxWidth, Layout layout, int textWidth, breaks breaks, int pos);
    internal static Tuple`4<breaks, Layout, int, int> fit@321-1(int maxWidth, breaks breaks, int tupledArg0, Layout tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout squashTo(int maxWidth, Layout layout);
    internal static c addL@390-4(LayoutRenderer`2<b, a> rr, a z, int pos, int i, Layout layout, FSharpFunc`2<Tuple`2<a, int>, c> k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b renderL(LayoutRenderer`2<b, a> rr, Layout layout);
    public static LayoutRenderer`2<string, FSharpList`1<string>> get_stringR();
    public static LayoutRenderer`2<NoResult, NoState> taggedTextListR(FSharpFunc`2<TaggedText, Unit> collector);
    public static LayoutRenderer`2<NoResult, NoState> channelR(TextWriter chan);
    public static LayoutRenderer`2<NoResult, NoState> bufferR(StringBuilder os);
    public static string showL(Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void outL(TextWriter chan, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void bufferL(StringBuilder os, Layout layout);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Lexer : object {
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827100@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827101@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827102@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827103@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827104@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827105@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827106@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827107@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827108@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827109@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827110@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827111@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827112@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827113@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827114@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827115@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827116@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827117@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827118@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827119@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827120@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827121@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827122@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827123@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827124@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827125@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827126@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827127@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827128@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827129@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827130@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827131@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827132@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827133@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827134@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827135@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827136@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827137@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827138@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827139@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827140@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827141@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827142@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827143@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827144@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827145@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827146@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827147@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827148@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827149@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827150@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827151@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827152@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827153@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827154@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827155@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827156@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827157@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827158@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827159@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827160@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827161@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827162@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827163@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827164@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827165@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827166@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827167@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827168@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827169@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827170@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827171@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827172@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827173@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827174@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827175@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827176@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827177@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827178@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827179@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827180@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827181@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827182@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827183@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827184@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827185@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827186@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827187@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827188@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827189@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827190@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827191@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827192@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827193@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827194@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827195@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827196@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827197@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827198@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827199@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827200@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827201@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827202@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827203@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827204@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827205@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827206@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827207@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827208@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827209@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827210@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827211@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827212@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827213@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827214@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827215@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827216@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827217@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827218@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827219@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827220@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827221@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827222@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827223@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827224@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827225@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827226@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827227@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827228@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827229@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827230@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827231@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827232@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827233@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827234@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827235@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827236@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827237@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827238@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827239@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827240@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827241@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827242@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827243@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827244@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827245@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827246@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827247@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827248@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827249@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827250@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827251@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827252@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827253@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827254@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827255@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827256@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827257@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827258@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827259@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827260@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827261@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827262@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827263@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827264@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827265@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827266@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827267@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827268@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827269@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827270@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827271@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827272@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827273@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827274@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827275@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827276@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827277@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827278@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827279@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827280@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827281@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827282@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827283@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827284@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827285@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827286@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827287@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827288@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827289@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827290@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827291@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827292@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827293@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827294@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827295@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827296@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827297@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827298@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827299@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827300@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827301@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827302@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827303@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827304@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827305@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827306@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827307@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827308@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827309@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827310@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827311@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827312@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827313@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827314@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827315@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827316@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827317@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827318@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827319@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827320@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827321@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827322@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827323@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827324@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827325@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827326@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827327@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827328@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827329@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827330@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827331@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827332@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827333@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827334@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827335@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827336@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827337@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827338@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827339@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827340@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827341@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827342@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827343@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827344@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827345@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827346@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827347@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827348@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827349@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827350@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827351@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827352@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827353@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827354@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827355@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827356@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827357@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827358@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827359@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827360@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827361@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827362@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827363@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827364@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827365@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827366@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827367@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827368@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827369@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827370@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827371@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827372@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827373@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827374@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827375@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827376@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827377@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827378@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827379@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827380@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827381@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827382@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827383@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827384@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827385@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827386@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827387@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827388@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827389@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827390@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827391@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827392@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827393@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827394@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827395@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827396@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827397@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827398@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827399@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827400@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827401@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827402@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827403@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827404@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827405@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827406@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827407@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827408@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827409@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827410@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827411@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827412@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827413@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827414@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827415@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827416@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827417@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827418@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827419@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827420@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827421@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827422@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827423@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827424@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827425@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827426@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827427@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827428@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827429@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827430@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827431@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827432@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827433@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827434@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827435@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827436@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827437@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827438@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827439@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827440@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827441@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827442@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827443@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827444@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827445@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827446@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827447@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827448@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827449@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827450@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827451@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827452@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827453@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827454@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827455@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827456@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827457@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827458@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827459@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827460@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827461@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827462@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827463@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827464@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827465@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827466@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827467@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827468@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827469@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827470@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827471@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827472@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827473@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827474@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827475@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827476@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827477@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827478@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827479@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827480@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827481@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827482@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827483@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827484@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827485@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827486@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827487@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827488@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827489@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827490@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827491@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827492@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827493@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827494@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827495@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827496@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827497@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827498@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827499@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827500@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827501@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827502@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827503@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827504@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827505@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827506@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827507@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827508@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827509@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827510@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827511@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827512@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827513@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827514@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827515@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827516@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827517@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827518@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827519@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827520@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827521@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827522@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827523@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827524@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827525@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827526@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827527@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827528@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827529@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827530@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827531@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827532@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827533@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827534@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827535@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827536@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827537@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827538@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827539@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827540@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827541@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827542@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827543@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827544@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827545@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827546@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827547@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827548@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827549@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827550@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827551@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827552@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827553@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827554@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827555@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827556@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827557@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827558@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827559@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827560@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827561@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827562@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827563@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827564@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827565@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827566@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827567@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827568@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827569@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827570@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827571@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827572@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827573@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827574@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827575@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827576@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827577@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827578@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827579@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827580@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827581@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827582@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827583@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827584@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827585@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827586@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827587@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827588@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827589@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827590@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827591@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827592@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827593@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827594@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827595@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827596@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827597@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827598@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827599@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827600@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827601@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827602@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827603@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827604@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827605@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827606@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827607@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827608@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827609@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827610@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827611@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827612@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827613@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827614@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827615@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827616@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827617@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827618@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827619@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827620@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827621@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827622@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827623@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827624@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827625@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827626@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827627@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827628@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827629@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827630@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827631@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827632@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827633@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827634@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827635@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827636@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827637@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827638@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827639@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827640@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827641@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827642@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827643@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827644@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827645@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827646@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827647@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827648@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827649@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827650@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827651@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827652@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827653@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827654@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827655@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827656@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827657@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827658@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827659@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827660@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827661@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827662@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827663@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827664@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827665@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827666@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827667@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827668@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827669@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827670@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827671@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827672@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827673@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827674@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827675@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827676@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827677@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827678@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827679@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827680@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827681@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827682@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827683@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827684@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827685@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827686@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827687@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827688@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827689@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827690@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827691@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827692@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827693@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827694@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827695@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827696@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827697@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827698@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827699@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827700@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827701@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827702@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827703@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827704@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827705@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827706@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827707@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827708@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827709@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827710@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827711@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827712@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827713@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827714@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827715@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827716@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827717@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827718@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827719@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827720@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827721@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827722@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827723@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827724@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827725@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827726@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827727@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827728@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827729@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827730@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827731@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827732@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827733@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827734@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827735@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827736@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827737@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827738@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827739@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827740@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827741@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827742@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827743@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827744@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827745@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827746@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827747@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827748@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827749@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827750@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827751@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827752@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827753@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827754@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827755@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827756@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827757@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827758@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827759@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827760@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827761@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827762@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827763@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827764@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827765@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827766@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827767@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827768@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827769@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827770@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827771@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827772@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827773@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827774@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827775@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827776@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827777@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827778@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827779@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827780@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827781@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827782@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827783@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827784@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827785@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827786@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827787@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827788@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827789@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827790@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827791@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827792@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827793@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827794@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827795@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827796@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827797@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827798@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827799@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827800@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827801@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827802@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827803@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827804@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827805@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827806@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827807@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827808@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827809@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827810@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827811@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827812@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827813@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827814@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827815@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827816@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827817@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827818@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827819@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827820@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827821@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827822@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827823@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827824@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827825@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827826@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827827@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827828@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827829@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827830@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827831@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827832@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827833@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827834@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827835@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827836@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827837@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827838@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827839@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827840@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827841@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827842@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827843@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827844@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827845@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827846@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827847@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827848@;
    [DebuggerBrowsableAttribute("0")]
internal static T827099_318Bytes@ field827849@;
    [DebuggerBrowsableAttribute("0")]
internal static T827850_1500Bytes@ field827851@;
    [CompilationMappingAttribute("9")]
internal static UInt16[][] trans { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] actions { get; }
    [CompilationMappingAttribute("9")]
internal static UnicodeTables _fslex_tables { get; }
    private static Lexer();
    internal static string lexeme(LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string trimBoth(string s, int n, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string lexemeTrimBoth(LexBuffer`1<char> lexbuf, int n, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string lexemeTrimRight(LexBuffer`1<char> lexbuf, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string lexemeTrimLeft(LexBuffer`1<char> lexbuf, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a fail(lexargs args, LexBuffer`1<char> lexbuf, int msg_0, string msg_1, a dflt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int getSign32(string s, Int32& p, int l);
    internal static bool isOXB(char c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool is0OXB(string s, int p, int l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static char get0OXB(string s, Int32& p, int l);
    internal static a formatError();
    internal static ulong parse@70(string s, int l, int n, ulong acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ulong parseBinaryUInt64(string s, int p, int l);
    internal static ulong parse@74-1(string s, int l, int n, ulong acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ulong parseOctalUInt64(string s, int p, int l);
    internal static string removeUnderscores(string s);
    internal static int parseInt32(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int lexemeTrimRightToInt32(lexargs args, LexBuffer`1<char> lexbuf, int n);
    internal static void checkExprOp(LexBuffer`1<char> lexbuf);
    internal static token unexpectedChar(LexBuffer`1<char> lexbuf);
    internal static FSharpFunc`2<b, FSharpFunc`2<bool, FSharpFunc`2<Byte[], token>>> fin@118(lexargs args, LexBuffer`1<char> lexbuf, ByteBuffer buf, Position startp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ByteBuffer, FSharpFunc`2<a, FSharpFunc`2<bool, FSharpFunc`2<Byte[], token>>>, range> startString(lexargs args, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void trySaveXmlDoc(LexBuffer`1<char> lexbuf, FSharpOption`1<StringBuilder> buff);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void tryAppendXmlDoc(FSharpOption`1<StringBuilder> buff, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a shouldStartLine(lexargs args, LexBuffer`1<char> lexbuf, range m, int err_0, string err_1, a tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a shouldStartFile(lexargs args, LexBuffer`1<char> lexbuf, range m, int err_0, string err_1, a tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool evalIfDefExpression(Position startPos, lexargs args, FSharpFunc`2<string, bool> lookup, string lexed);
    internal static UInt16[][] get_trans();
    internal static UInt16[] get_actions();
    internal static UnicodeTables get__fslex_tables();
    internal static a _fslex_dummy();
    internal static Tuple`2<int, FSharpOption`1<string>> parseLeadingDirective@491(LexBuffer`1<char> lexbuf, string s, int n);
    internal static Tuple`2<int, FSharpOption`1<string>> parseLeadingWhitespace@496(LexBuffer`1<char> lexbuf, string s, int n);
    internal static Tuple`2<int, FSharpOption`1<string>> parseLineNumber@501(LexBuffer`1<char> lexbuf, string s, int start, int n);
    internal static FSharpOption`1<string> parseWhitespaceBeforeFile@510(LexBuffer`1<char> lexbuf, string s, int n);
    internal static string parseFile@516(LexBuffer`1<char> lexbuf, string s, int start, int n);
    [CompilerGeneratedAttribute]
internal static bool contains@1(a e, FSharpList`1<a> xs1);
    [CompilerGeneratedAttribute]
internal static token token$cont@616(lexargs args, bool skip, LexBuffer`1<char> lexbuf, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token token(lexargs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilerGeneratedAttribute]
internal static token ifdefSkip$cont@682(int n, lexargs args, bool skip, LexBuffer`1<char> lexbuf, string lexed, range m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static token ifdefSkip$cont@700-1(int n, lexargs args, bool skip, LexBuffer`1<char> lexbuf, string lexed, range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token ifdefSkip(int n, range m, lexargs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token endline(LexerEndlineContinuation cont, lexargs args, bool skip, LexBuffer`1<char> lexbuf);
    internal static token result@772(Tuple`4<ByteBuffer, FSharpFunc`2<range, FSharpFunc`2<bool, FSharpFunc`2<Byte[], token>>>, range, lexargs> sargs, bool skip, LexBuffer`1<char> lexbuf, range m, lexargs args, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token string(ByteBuffer sargs_0, FSharpFunc`2<range, FSharpFunc`2<bool, FSharpFunc`2<Byte[], token>>> sargs_1, range sargs_2, lexargs sargs_3, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token verbatimString(ByteBuffer sargs_0, FSharpFunc`2<range, FSharpFunc`2<bool, FSharpFunc`2<Byte[], token>>> sargs_1, range sargs_2, lexargs sargs_3, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token tripleQuoteString(ByteBuffer sargs_0, FSharpFunc`2<range, FSharpFunc`2<bool, FSharpFunc`2<Byte[], token>>> sargs_1, range sargs_2, lexargs sargs_3, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token singleLineComment(FSharpOption`1<StringBuilder> cargs_0, int cargs_1, range cargs_2, lexargs cargs_3, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token comment(int cargs_0, range cargs_1, lexargs cargs_2, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token stringInComment(int n, range m, lexargs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token verbatimStringInComment(int n, range m, lexargs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token tripleQuoteStringInComment(int n, range m, lexargs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token mlOnly(range m, lexargs args, bool skip, LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.LexFilter : object {
    internal static bool debug { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_debug();
    internal static string stringOfPos(Position p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputPos(TextWriter os, Position p);
    internal static string warningStringOfPos(Position p);
    internal static bool isInfix(token token);
    internal static bool isNonAssocInfixToken(token token);
    internal static int infixTokenLength(token token);
    internal static bool isIfBlockContinuator(token token);
    internal static bool isTryBlockContinuator(token token);
    internal static bool isThenBlockContinuator(token token);
    internal static bool isDoContinuator(token token);
    internal static bool isInterfaceContinuator(token token);
    internal static bool isNamespaceContinuator(token token);
    internal static bool isTypeContinuator(token token);
    internal static bool isForLoopContinuator(token token);
    internal static bool isWhileBlockContinuator(token token);
    internal static bool isLetContinuator(token token);
    internal static bool isTypeSeqBlockElementContinuator(token token);
    internal static bool isSeqBlockElementContinuator(token token);
    internal static bool isWithAugmentBlockContinuator(token token);
    internal static bool isLongIdentifier(token token);
    internal static bool isLongIdentifierOrGlobal(token token);
    internal static bool isAtomicExprEndToken(token token);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool parenTokensBalance(token t1, token t2);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<token> afterOp$cont@470(FSharpList`1<char> afterAngles, string matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<FSharpFunc`2[], FSharpOption`1<token>>> |TyparsCloseOp|_|$cont@449(FSharpList`1<char> angles, FSharpList`1<char> afterAngles, Unit unitVar);
    internal static FSharpOption`1<Tuple`2<FSharpFunc`2[], FSharpOption`1<token>>> |TyparsCloseOp|_|(string txt);
    internal static bool check@616-1(FSharpList`1<Context> s);
    internal static PositionWithColumn unindentationLimit@633(Context newCtxt, bool strict, FSharpList`1<Context> stack);
    internal static bool scanAhead@866(LexFilterImpl this, bool indentation, Position tokenEndPos, FSharpRef`1<FSharpList`1<Tuple`2<TokenTup, bool>>> stack, int nParen);
    internal static bool isSameLine@1051(LexFilterImpl this, Position tokenStartPos, token token, Unit unitVar0);
    internal static bool isControlFlowOrNotSameLine@1056(LexFilterImpl this, Position tokenStartPos, token token, Unit unitVar0);
    internal static bool loop@1068-40(LexFilterImpl this, Unit unitVar0);
    internal static bool isLongIdentEquals@1064(LexFilterImpl this, token token);
    internal static token insertTokenFromPrevPosToCurrentPos@1098(LexFilterImpl this, TokenTup tokenTup, token tok);
    internal static token insertToken@1108(LexFilterImpl this, TokenTup tokenTup, token tok);
    internal static bool thereIsACtxtMemberBodyOnTheStackAndWeShouldPopStackForUpcomingMember@1123(FSharpList`1<Context> ctxtStack);
    internal static FSharpOption`1<token> endTokenForACtxt@1136(Context ctxt);
    internal static bool tokenForcesHeadContextClosure@1163(LexFilterImpl this, token token, FSharpList`1<Context> stack);
    internal static bool nextOuterMostInterestingContextIsNamespaceOrModule@1201(FSharpList`1<Context> offsideStack);
    internal static void insertComingSoonTokens@1193(LexFilterImpl this, TokenTup tokenTup, string tupledArg0, token tupledArg1, token tupledArg2);
    internal static void delayMergedToken@2184(LexFilterImpl this, TokenTup tokenTup, TokenTup nextTokenTup, token tok);
    internal static void noMerge@2185(LexFilterImpl this, TokenTup tokenTup, TokenTup nextTokenTup, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void rulesForBothSoftWhiteAndHardWhite$cont@2199(LexFilterImpl this, TokenTup tokenTup, bool plus, TokenTup nextTokenTup, Unit unitVar);
    internal static token loop@2272-41(LexFilter __, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<LexBuffer`1<char>, token> token(lexargs lexargs, bool skip);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Lexhelp : object {
    internal static string stdinMockFilename { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_stdinMockFilename();
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@54-8(lexargs this, object obj, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@65-38(LongUnicodeLexResult this, LongUnicodeLexResult obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@65-39(LongUnicodeLexResult this, object obj, LongUnicodeLexResult objTemp, Unit unitVar);
    internal static lexargs mkLexargs(a _filename, FSharpList`1<string> defines, LightSyntaxStatus lightSyntaxStatus, LexResourceManager resourceManager, FSharpRef`1<FSharpList`1<Tuple`2<LexerIfdefStackEntry, range>>> ifdefStack, ErrorLogger errorLogger, PathMap pathMap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a reusingLexbufForParsing(LexBuffer`1<char> lexbuf, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void resetLexbufPos(string filename, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a usingLexbufForParsing(LexBuffer`1<char> lexbuf, string filename, FSharpFunc`2<LexBuffer`1<char>, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token defaultStringFinisher(a _endm, b _b, Byte[] s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c callStringFinisher(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<Byte[], c>>> fin, ByteBuffer buf, a endm, b b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addUnicodeString(ByteBuffer buf, string x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addUnicodeChar(ByteBuffer buf, int c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addByteChar(ByteBuffer buf, char c);
    internal static string stringBufferAsString(Byte[] buf);
    internal static Byte[] stringBufferAsBytes(ByteBuffer buf);
    internal static bool stringBufferIsBytes(ByteBuffer buf);
    internal static void newline(LexBuffer`1<a> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static char trigraph(char c1, char c2, char c3);
    internal static int digit(char d);
    internal static int hexdigit(char d);
    internal static ushort unicodeGraphShort(string s);
    internal static ushort hexGraphShort(string s);
    internal static LongUnicodeLexResult unicodeGraphLong(string s);
    internal static char escape(char c);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Lib : object {
    internal static bool debug { get; }
    internal static bool verbose { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<bool> progress { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<bool> tracking { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_debug();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_verbose();
    internal static FSharpRef`1<bool> get_progress();
    internal static FSharpRef`1<bool> get_tracking();
    internal static bool condition(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetEnvInteger(string e, int dflt);
    internal static void dispose(IDisposable x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<c, e>, d> mapFoldFst(FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<c, d>>> f, a s, b x, e y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<e, c>, d> mapFoldSnd(FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<c, d>>> f, a s, e x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<a, b> pair(a a, b b);
    internal static a p13(a x, b _y, c _z);
    internal static b p23(a _x, b y, c _z);
    internal static c p33(a _x, b _y, c z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<b, c> map1Of2(FSharpFunc`2<a, b> f, a a1, c a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<c, b> map2Of2(FSharpFunc`2<a, b> f, c a1, a a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<b, c, d> map1Of3(FSharpFunc`2<a, b> f, a a1, c a2, d a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<c, b, d> map2Of3(FSharpFunc`2<a, b> f, c a1, a a2, d a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<c, d, b> map3Of3(FSharpFunc`2<a, b> f, c a1, d a2, a a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<c, d, b, e> map3Of4(FSharpFunc`2<a, b> f, c a1, d a2, a a3, e a4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<c, d, e, b> map4Of4(FSharpFunc`2<a, b> f, c a1, d a2, e a3, a a4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<c, d, e, f, b> map5Of5(FSharpFunc`2<a, b> f, c a1, d a2, e a3, f a4, a a5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<c, d, e, f, g, b> map6Of6(FSharpFunc`2<a, b> f, c a1, d a2, e a3, f a4, g a5, a a6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static e foldPair(FSharpFunc`2<a, FSharpFunc`2<b, c>> f1, FSharpFunc`2<c, FSharpFunc`2<d, e>> f2, a acc, b a1, d a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c fold1Of2(FSharpFunc`2<a, FSharpFunc`2<b, c>> f1, a acc, b a1, d _a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static g foldTriple(FSharpFunc`2<a, FSharpFunc`2<b, c>> f1, FSharpFunc`2<c, FSharpFunc`2<d, e>> f2, FSharpFunc`2<e, FSharpFunc`2<f, g>> f3, a acc, b a1, d a2, f a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static i foldQuadruple(FSharpFunc`2<a, FSharpFunc`2<b, c>> f1, FSharpFunc`2<c, FSharpFunc`2<d, e>> f2, FSharpFunc`2<e, FSharpFunc`2<f, g>> f3, FSharpFunc`2<g, FSharpFunc`2<h, i>> f4, a acc, b a1, d a2, f a3, h a4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<b, d> mapPair(FSharpFunc`2<a, b> f1, FSharpFunc`2<c, d> f2, a a1, c a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<b, d, f> mapTriple(FSharpFunc`2<a, b> f1, FSharpFunc`2<c, d> f2, FSharpFunc`2<e, f> f3, a a1, c a2, e a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<b, d, f, h> mapQuadruple(FSharpFunc`2<a, b> f1, FSharpFunc`2<c, d> f2, FSharpFunc`2<e, f> f3, FSharpFunc`2<g, h> f4, a a1, c a2, e a3, g a4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<c, Tuple`2<e, d>> fmap2Of2(FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<c, d>>> f, a z, e a1, b a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equalOn(FSharpFunc`2<a, b> f, a x, a y);
    internal static string bufs(FSharpFunc`2<StringBuilder, Unit> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buff(TextWriter os, FSharpFunc`2<StringBuilder, FSharpFunc`2<a, Unit>> f, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeViaBufferWithEnvironmentNewLines(TextWriter os, FSharpFunc`2<StringBuilder, FSharpFunc`2<a, Unit>> f, a x);
    internal static void trace@350(Graph`2<Data, Id> g, FSharpFunc`2<FSharpList`1<Data>, Unit> f, FSharpList`1<Data> path, GraphNode`2<Data, Id> node);
    internal static T nullableSlotEmpty();
    internal static a nullableSlotFull(a x);
    internal static cache`1<a> newCache();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a cached(cache`1<a> cache, FSharpFunc`2<Unit, a> resf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a cacheOptRef(FSharpRef`1<FSharpOption`1<a>> cache, FSharpFunc`2<Unit, a> f);
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.LogCompilerFunctionId : Enum {
    public int value__;
    public static LogCompilerFunctionId Service_ParseAndCheckFileInProject;
    public static LogCompilerFunctionId Service_CheckOneFile;
    public static LogCompilerFunctionId Service_IncrementalBuildersCache_BuildingNewCache;
    public static LogCompilerFunctionId Service_IncrementalBuildersCache_GettingCache;
    public static LogCompilerFunctionId CompileOps_TypeCheckOneInputAndFinishEventually;
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Logger : object {
    internal static void Log(LogCompilerFunctionId functionId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void LogMessage(string message, LogCompilerFunctionId functionId);
    internal static void LogBlockStart(LogCompilerFunctionId functionId);
    internal static void LogBlockStop(LogCompilerFunctionId functionId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void LogBlockMessageStart(string message, LogCompilerFunctionId functionId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void LogBlockMessageStop(string message, LogCompilerFunctionId functionId);
    internal static IDisposable LogBlock(LogCompilerFunctionId functionId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IDisposable LogBlockMessage(string message, LogCompilerFunctionId functionId);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.LowerCallsAndSeqs : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> InterceptExpr(TcGlobals g, FSharpFunc`2<Expr, Expr> cont, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypedImplFile LowerImplFile(TcGlobals g, TypedImplFile assembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr callNonOverloadedMethod(TcGlobals g, ImportMap amap, range m, string methName, TType ty, FSharpList`1<Expr> args);
    internal static FSharpOption`1<Tuple`2<Expr, range>> |SeqYield|_|@122(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Tuple`3<Expr, Expr, range>> |SeqAppend|_|@130(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Tuple`3<Expr, Expr, range>> |SeqWhile|_|@138(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Tuple`3<Expr, Expr, range>> |SeqTryFinally|_|@147(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Tuple`5<Expr, Val, Expr, TType, range>> |SeqUsing|_|@156(TcGlobals g, Expr expr);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`5<Expr, Val, Expr, TType, range>> |SeqFor|_|$cont@165(TcGlobals g, Expr expr, Unit unitVar);
    internal static FSharpOption`1<Tuple`5<Expr, Val, Expr, TType, range>> |SeqFor|_|@164(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Tuple`2<Expr, TType>> |SeqDelay|_|@174(TcGlobals g, Expr expr);
    internal static FSharpOption`1<range> |SeqEmpty|_|@179(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Tuple`2<Expr, TType>> |Seq|_|@184(TcGlobals g, Expr expr);
    internal static LoweredSeqFirstPhaseResult RepresentBindingAsLocal@191(Binding bind, LoweredSeqFirstPhaseResult res2, range m);
    internal static LoweredSeqFirstPhaseResult RepresentBindingAsStateMachineLocal@203(Binding bind, LoweredSeqFirstPhaseResult res2, range m);
    internal static LoweredSeqFirstPhaseResult RepresentBindingsAsLifted@226(FSharpFunc`2<Expr, Expr> mkBinds, LoweredSeqFirstPhaseResult res2);
    internal static FSharpFunc`2<TType, bool> tyConfirmsToSeq@539(TcGlobals g);
    internal static FSharpOption`1<LoweredSeqFirstPhaseResult> Lower@236(TcGlobals g, ImportMap amap, bool isWholeExpr, bool isTailCall, int noDisposeContinuationLabel, int currentDisposeContinuationLabel, Expr expr);
    internal static DecisionTree mkGotoLabelTarget@644(range m, MatchBuilder mbuilder, int lab);
    internal static Expr addJumpTable@642(TcGlobals g, range m, int initLabel, int noDisposeContinuationLabel, Expr pcExpr, FSharpList`1<int> pcs, int pcDone, FSharpMap`2<int, int> pc2lab, bool isDisposal, Expr expr);
    internal static Expr handleExeceptionsInDispose@674(TcGlobals g, range m, Expr pcExpr, int pcDone, Expr disposalExpr);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`8<ValRef, ValRef, ValRef, FSharpList`1<ValRef>, Expr, Expr, Expr, Tuple`2<TType, range>>> LowerSeqExpr$cont@592(TcGlobals g, TType ty, range m, int initLabel, int noDisposeContinuationLabel, FSharpOption`1<LoweredSeqFirstPhaseResult> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`8<ValRef, ValRef, ValRef, FSharpList`1<ValRef>, Expr, Expr, Expr, Tuple`2<TType, range>>> LowerSeqExpr(TcGlobals g, ImportMap amap, Expr overallExpr);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.MethodCalls : object {
    internal static CalledArg CalledArg(Tuple`2<int, int> pos, bool isParamArray, OptionalArgInfo optArgInfo, CallerInfo callerInfo, bool isInArg, bool isOutArg, FSharpOption`1<Ident> nameOpt, ReflectedArgInfo reflArgInfo, TType calledArgTy);
    internal static TType adjustDelegateTy@159(InfoReader infoReader, TcGlobals g, TType calledArgTy, TType callerArgTy, range m, TType calledTy);
    [CompilerGeneratedAttribute]
internal static TType AdjustCalledArgType$cont@158(InfoReader infoReader, CalledArg calledArg, CallerArg`1<a> callerArg, TcGlobals g, TType calledArgTy, TType callerArgTy, range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType AdjustCalledArgType(InfoReader infoReader, bool isConstraint, CalledArg calledArg, CallerArg`1<a> callerArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<CalledArg>> MakeCalledArgs(ImportMap amap, range m, MethInfo minfo, FSharpList`1<TType> minst);
    internal static FSharpList`1<Ident> NamesOfCalledArgs(FSharpList`1<CalledArg> calledArgs);
    internal static int loop@515-59(SynExpr e);
    internal static int InferLambdaArgsForLambdaPropagation(SynExpr origRhsExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArgumentAnalysis ExamineArgumentForLambdaPropagation(InfoReader infoReader, AssignedCalledArg`1<SynExpr> arg);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<FSharpList`1<ArgumentAnalysis>>, FSharpList`1<FSharpList`1<Tuple`2<Ident, ArgumentAnalysis>>>>> ExamineMethodForLambdaPropagation(CalledMeth`1<SynExpr> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildObjCtorCall(TcGlobals g, range m);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<Val>, Expr> BuildNewDelegateExpr$cont@576(range m, TcGlobals g, TType fty, Expr f, FSharpOption`1<EventInfo> eventInfoOpt, FSharpList`1<TType> delArgTys, Unit unitVar);
    internal static Expr BuildNewDelegateExpr(FSharpOption`1<EventInfo> eventInfoOpt, TcGlobals g, ImportMap amap, TType delegateTy, MethInfo invokeMethInfo, FSharpList`1<TType> delArgTys, Expr f, TType fty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr CoerceFromFSharpFuncToDelegate(TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, TType callerArgTy, range m, Expr callerArgExpr, TType delegateTy);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpOption`1<a>, Expr> AdjustCallerArgExprForCoercions$cont@619(TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, bool isOutArg, TType calledArgTy, ReflectedArgInfo reflArgInfo, TType callerArgTy, range m, Expr callerArgExpr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<a>, Expr> AdjustCallerArgExprForCoercions(TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, bool isOutArg, TType calledArgTy, ReflectedArgInfo reflArgInfo, TType callerArgTy, range m, Expr callerArgExpr);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<Expr, Expr>, Expr> build$cont@701(FSharpFunc`2<range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, FSharpOption`1<string> eCallerMemberName, TcGlobals g, range mMethExpr, FSharpFunc`2<Expr, Expr> emptyPreBinder, CalledArg calledArg, TType currCalledArgTy, ILFieldInit fieldInit, Unit unitVar);
    internal static Tuple`2<FSharpFunc`2<Expr, Expr>, Expr> build@682(FSharpFunc`2<range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, FSharpOption`1<string> eCallerMemberName, TcGlobals g, range mMethExpr, FSharpFunc`2<Expr, Expr> emptyPreBinder, CalledArg calledArg, TType currCalledArgTy, OptionalArgCallerSideValue currDfltVal);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<Expr, Expr>, Expr> AdjustOptionalCallerArgExprs$cont@737(FSharpOption`1<string> eCallerMemberName, TcGlobals g, range mMethExpr, FSharpFunc`2<Expr, Expr> emptyPreBinder, CalledArg calledArg, TType calledArgTy, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<AssignedCalledArg`1<Expr>>, FSharpFunc`2<Expr, Expr>, FSharpList`1<AssignedCalledArg`1<Expr>>, FSharpList`1<AssignedCalledArg`1<Expr>>> AdjustOptionalCallerArgExprs(FSharpFunc`2<range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, FSharpOption`1<string> eCallerMemberName, TcGlobals g, CalledMeth`1<Expr> calledMeth, range mItem, range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<AssignedCalledArg`1<Expr>>, FSharpList`1<Expr>, FSharpList`1<Binding>> AdjustOutCallerArgExprs(TcGlobals g, CalledMeth`1<a> calledMeth, range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpOption`1<a>>, FSharpList`1<AssignedCalledArg`1<Expr>>> AdjustParamArrayCallerArgExprs(TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, CalledMeth`1<Expr> calledMeth, range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<FSharpFunc`2<Expr, Expr>, FSharpList`1<Expr>, FSharpList`1<FSharpOption`1<b>>, FSharpList`1<AssignedCalledArg`1<Expr>>, FSharpList`1<Expr>, FSharpFunc`2<Expr, Expr>, FSharpList`1<FSharpOption`1<c>>, Tuple`2<FSharpList`1<Expr>, FSharpList`1<Binding>>> AdjustCallerArgExprs(FSharpFunc`2<range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, FSharpOption`1<string> eCallerMemberName, TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, CalledMeth`1<Expr> calledMeth, FSharpList`1<Expr> objArgs, FSharpOption`1<a> lambdaVars, range mItem, range mMethExpr);
    internal static bool IsBaseCall(FSharpList`1<Expr> objArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> ComputeConstrainedCallInfo(TcGlobals g, ImportMap amap, range m, FSharpList`1<Expr> objArgs, MethInfo minfo);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<Expr, Expr>, FSharpList`1<Expr>> TakeObjAddrForMethodCall$cont@938(TcGlobals g, ImportMap amap, MethInfo minfo, Mutates isMutable, range m, FSharpOption`1<TType> ccallInfo, Expr objArgExpr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, a> TakeObjAddrForMethodCall(TcGlobals g, ImportMap amap, MethInfo minfo, Mutates isMutable, range m, FSharpList`1<Expr> objArgs, FSharpFunc`2<FSharpOption`1<TType>, FSharpFunc`2<FSharpList`1<Expr>, Tuple`2<Expr, a>>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildILMethInfoCall(TcGlobals g, ImportMap amap, range m, bool isProp, ILMethInfo minfo, ValUseFlag valUseFlags, FSharpList`1<TType> minst, bool direct, FSharpList`1<Expr> args);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, Tuple`2<FSharpList`1<Expr>, TType>> BuildFSharpMethodApp$cont@1014(TcGlobals g, range m, TType fty, FSharpList`1<Expr> args, int arity, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildFSharpMethodApp(TcGlobals g, range m, ValRef vref, Expr vexp, TType vexprty, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildFSharpMethodCall(TcGlobals g, range m, TType ty, ValRef vref, ValUseFlag valUseFlags, FSharpList`1<TType> minst, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeMethInfoCall(ImportMap amap, range m, MethInfo minfo, FSharpList`1<TType> minst, FSharpList`1<Expr> args);
    internal static FSharpOption`1<ValRef> TryImportProvidedMethodBaseAsLibraryIntrinsic(ImportMap amap, range m, Tainted`1<ProvidedMethodBase> mbase);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, TType> BuildMethodCall$cont@1141-1(TcGlobals g, range m, bool isProp, MethInfo minfo, FSharpList`1<TType> minst, FSharpList`1<Expr> allArgs, ValUseFlag valUseFlags, Tainted`1<ProvidedMethodBase> providedMeth, ImportMap amap, TType enclTy, bool valu, bool isCtor, bool useCallvirt, bool isProtected, TType exprTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, TType> BuildMethodCall$cont@1118(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, range m, bool isProp, MethInfo minfo, FSharpList`1<TType> minst, bool direct, FSharpList`1<Expr> allArgs, ValUseFlag valUseFlags, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildMethodCall(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Mutates isMutable, range m, bool isProp, MethInfo minfo, ValUseFlag valUseFlags, FSharpList`1<TType> minst, FSharpList`1<Expr> objArgs, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void RecdFieldInstanceChecks(TcGlobals g, ImportMap amap, AccessorDomain ad, range m, RecdFieldInfo rfinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILFieldInstanceChecks(TcGlobals g, ImportMap amap, AccessorDomain ad, range m, ILFieldInfo finfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void MethInfoChecks(TcGlobals g, ImportMap amap, bool isInstance, FSharpOption`1<a> tyargsOpt, FSharpList`1<Expr> objArgs, AccessorDomain ad, range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckRecdFieldMutation(range m, DisplayEnv denv, RecdFieldInfo rfinfo);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.MethodOverrides : object {
    [CompilerGeneratedAttribute]
internal static void FinalTypeDefinitionChecksAtEndOfInferenceScope$cont@716(TcResultsSink sink, NameResolutionEnv nenv, bool isImplementation, InfoReader infoReader, DisplayEnv denv, Entity tycon, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void FinalTypeDefinitionChecksAtEndOfInferenceScope(InfoReader infoReader, NameResolutionEnv nenv, TcResultsSink sink, bool isImplementation, DisplayEnv denv, Entity tycon);
    internal static Tuple`2<FSharpList`1<MethInfo>, FSharpList`1<MethInfo>> GetAbstractMethInfosForSynMethodDecl(InfoReader infoReader, AccessorDomain ad, Ident memberName, range bindm, Tuple`2<TType, FSharpOption`1<SlotImplSet>> typToSearchForAbstractMembers, SynValInfo valSynData);
    internal static FSharpList`1<PropInfo> GetAbstractPropInfosForSynPropertyDecl(InfoReader infoReader, AccessorDomain ad, Ident memberName, range bindm, Tuple`2<TType, FSharpOption`1<SlotImplSet>> typToSearchForAbstractMembers, a _k, b _valSynData);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.NameResolution : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<UnionCaseRef> UnionCaseRefsInTycon(EntityRef modref, Entity tycon);
    internal static FSharpList`1<UnionCaseRef> UnionCaseRefsInModuleOrNamespace(EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Entity> TryFindTypeWithUnionCase(EntityRef modref, Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Entity> TryFindTypeWithRecdField(EntityRef modref, Ident id);
    internal static FSharpList`1<ActivePatternElemRef> ActivePatternElemsOfValRef(ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ValRef> TryMkValRefInModRef(EntityRef modref, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ActivePatternElemRef> ActivePatternElemsOfVal(EntityRef modref, Val vspec);
    [CompilerGeneratedAttribute]
internal static FSharpMap`2<string, ActivePatternElemRef> f@390-11(EntityRef modref, ModuleOrNamespaceType mtyp, Unit unitVar0);
    internal static FSharpMap`2<string, ActivePatternElemRef> ActivePatternElemsOfModuleOrNamespace(EntityRef modref);
    internal static FSharpOption`1<EntityRef> |AbbrevOrAppTy|_|(TType ty);
    internal static int valRefHash(ValRef vref);
    internal static ItemWithInst ItemWithNoInst(Item item);
    internal static Tuple`2<Item, FSharpList`1<Tuple`2<Typar, TType>>> |ItemWithInst|(ItemWithInst x);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<FSharpChoice`2<Tuple`2<EntityRef, ExtensionMember>, ExtensionMember>> GetCSharpStyleIndexedExtensionMembersForTyconRef$cont@441(ImportMap amap, range m, EntityRef tcrefOfStaticClass, TcGlobals g, ulong pri, MethInfo minfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpChoice`2<Tuple`2<EntityRef, ExtensionMember>, ExtensionMember>> GetCSharpStyleIndexedExtensionMembersForTyconRef(ImportMap amap, range m, EntityRef tcrefOfStaticClass);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Item> AddValRefsToItems(BulkAdd bulkAddMode, FSharpMap`2<string, Item> eUnqualifiedItems, ValRef[] vrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconRefMultiMap`1<ExtensionMember> AddValRefToExtensionMembers(ulong pri, TyconRefMultiMap`1<ExtensionMember> eIndexedExtensionMembers, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddFakeNamedValRefToNameEnv(string nm, NameResolutionEnv nenv, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddFakeNameToNameEnv(string nm, NameResolutionEnv nenv, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Item> AddValRefsToActivePatternsNameEnv(FSharpMap`2<string, Item> ePatItems, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddValRefsToNameEnvWithPriority(BulkAdd bulkAddMode, ulong pri, NameResolutionEnv nenv, ValRef[] vrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddValRefToNameEnv(NameResolutionEnv nenv, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddActivePatternResultTagsToNameEnv(ActivePatternInfo apinfo, NameResolutionEnv nenv, TType ty, range m);
    internal static UnionCaseInfo GeneralizeUnionCaseRef(UnionCaseRef ucref);
    [CompilerGeneratedAttribute]
internal static KeyValuePair`2<NameArityPair, EntityRef> mapping@1-18(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<NameArityPair, EntityRef> AddTyconsByDemangledNameAndArity(BulkAdd bulkAddMode, EntityRef[] tcrefs, FSharpMap`2<NameArityPair, EntityRef> tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LayeredMultiMap`2<string, EntityRef> AddTyconByAccessNames(BulkAdd bulkAddMode, EntityRef[] tcrefs, LayeredMultiMap`2<string, EntityRef> tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Item> AddUnionCases1(FSharpMap`2<string, Item> tab, FSharpList`1<UnionCaseRef> ucrefs);
    [CompilerGeneratedAttribute]
internal static KeyValuePair`2<string, Item> mapping@1-19(UnionCaseRef ucref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Item> AddUnionCases2(BulkAdd bulkAddMode, FSharpMap`2<string, Item> eUnqualifiedItems, FSharpList`1<UnionCaseRef> ucrefs);
    [CompilerGeneratedAttribute]
internal static bool f@105-12(TcGlobals g, EntityRef tcref, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static Item f@1246-13(EntityRef tcref, FSharpOption`1<Item> prev);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddPartsOfTyconRefToNameEnv(BulkAdd bulkAddMode, bool ownDefinition, TcGlobals g, ImportMap amap, range m, NameResolutionEnv nenv, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddTyconRefsToNameEnv(BulkAdd bulkAddMode, bool ownDefinition, TcGlobals g, ImportMap amap, range m, bool root, NameResolutionEnv nenv, FSharpList`1<EntityRef> tcrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddExceptionDeclsToNameEnv(BulkAdd bulkAddMode, NameResolutionEnv nenv, EntityRef ecref);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpFunc`2<FSharpList`1<a>, FSharpList`1<a>>> add@740-4();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleAbbrevToNameEnv(Ident id, NameResolutionEnv nenv, FSharpList`1<EntityRef> modrefs);
    internal static FSharpList`1<EntityRef> MakeNestedModuleRefs(EntityRef modref);
    internal static FSharpMap`2<string, FSharpList`1<EntityRef>> addModrefs@758(ImportMap amap, range m, AccessorDomain ad, FSharpMap`2<string, EntityRef> modrefsMap, FSharpMap`2<string, FSharpList`1<EntityRef>> tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleOrNamespaceRefsToNameEnv(TcGlobals g, ImportMap amap, range m, bool root, AccessorDomain ad, NameResolutionEnv nenv, FSharpList`1<EntityRef> modrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleOrNamespaceContentsToNameEnv(TcGlobals g, ImportMap amap, AccessorDomain ad, range m, bool root, NameResolutionEnv nenv, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModulesAndNamespacesContentsToNameEnv(TcGlobals g, ImportMap amap, AccessorDomain ad, range m, bool root, NameResolutionEnv nenv, FSharpList`1<EntityRef> modrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleOrNamespaceRefToNameEnv(TcGlobals g, ImportMap amap, range m, bool root, AccessorDomain ad, NameResolutionEnv nenv, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddDeclaredTyparsToNameEnv(CheckForDuplicateTyparFlag check, NameResolutionEnv nenv, FSharpList`1<Typar> typars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType FreshenTycon(NameResolver ncenv, range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseInfo FreshenUnionCaseRef(NameResolver ncenv, range m, UnionCaseRef ucref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item FreshenUnqualifiedItem(NameResolver ncenv, range m, Item res);
    internal static ResultOrException`1<FSharpList`1<a>> OneResult(ResultOrException`1<a> res);
    [CompilerGeneratedAttribute]
internal static ResultOrException`1<FSharpList`1<a>> AddResults$cont@894(ResultOrException`1<FSharpList`1<a>> res1, ResultOrException`1<FSharpList`1<a>> res2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<a>> AddResults(ResultOrException`1<FSharpList`1<a>> res1, ResultOrException`1<FSharpList`1<a>> res2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<b>> CollectResults(FSharpFunc`2<a, ResultOrException`1<b>> f, FSharpList`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<b>> CollectAtMostOneResult(FSharpFunc`2<a, ResultOrException`1<b>> f, FSharpList`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpList`1<a>, ResultOrException`1<FSharpList`1<b>>> CollectResults2(ResultCollectionSettings resultCollectionSettings, FSharpFunc`2<a, ResultOrException`1<b>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<b>> MapResults(FSharpFunc`2<a, b> f, ResultOrException`1<FSharpList`1<a>> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<a> AtMostOneResult(range m, ResultOrException`1<FSharpList`1<a>> res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<a>> AtMostOneResultQuery(FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<a>>> query2, ResultOrException`1<FSharpList`1<a>> res1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Entity> LookupTypeNameInEntityHaveArity(string nm, TypeNameResolutionStaticArgsInfo staticResInfo, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<EntityRef> LookupTypeNameInEnvHaveArity(FullyQualifiedFlag fq, string nm, int numTyArgs, NameResolutionEnv nenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> LookupTypeNameNoArity(string nm, FSharpMap`2<NameArityPair, a> byDemangledNameAndArity, LayeredMultiMap`2<string, a> byAccessNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<EntityRef> LookupTypeNameInEnvNoArity(FullyQualifiedFlag fq, string nm, NameResolutionEnv nenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<EntityRef> LookupTypeNameInEnvMaybeHaveArity(FullyQualifiedFlag fq, string nm, TypeNameResolutionInfo typeNameResInfo, NameResolutionEnv nenv);
    internal static void CheckForDirectReferenceToGeneratedType(EntityRef tcref, PermitDirectReferenceToGeneratedType genOk, range m);
    internal static EntityRef AddEntityForProvidedType(ImportMap amap, EntityRef modref, ResolutionEnvironment resolutionEnvironment, Tainted`1<ProvidedType> st, range m);
    internal static FSharpList`1<EntityRef> ResolveProvidedTypeNameInEntity(ImportMap amap, range m, string typeName, EntityRef modref);
    internal static FSharpList`1<EntityRef> LookupTypeNameInEntityMaybeHaveArity(ImportMap amap, range m, AccessorDomain ad, string nm, TypeNameResolutionStaticArgsInfo staticResInfo, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType MakeNestedType(NameResolver ncenv, FSharpList`1<TType> tinst, range m, EntityRef tcrefNested);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> GetNestedTypesOfType(AccessorDomain ad, NameResolver ncenv, FSharpOption`1<string> optFilter, TypeNameResolutionStaticArgsInfo staticResInfo, bool checkForGenerated, range m, TType ty);
    internal static FSharpOption`1<Tuple`2<string, EntityRef>> |RecordFieldUse|_|(Item item);
    internal static FSharpOption`1<ILFieldInfo> |ILFieldUse|_|(Item item);
    internal static FSharpOption`1<PropInfo> |PropertyUse|_|(Item item);
    internal static FSharpOption`1<ValRef> |FSharpPropertyUse|_|(Item item);
    internal static FSharpOption`1<MethInfo> |MethodUse|_|(Item item);
    internal static FSharpOption`1<ValRef> |FSharpMethodUse|_|(Item item);
    internal static FSharpOption`1<EntityRef> |EntityUse|_|(Item item);
    internal static FSharpOption`1<EventInfo> |EventUse|_|(Item item);
    internal static FSharpOption`1<ValRef> |FSharpEventUse|_|(Item item);
    internal static FSharpOption`1<UnionCaseRef> |UnionCaseUse|_|(Item item);
    internal static FSharpOption`1<ValRef> |ValUse|_|(Item item);
    internal static FSharpOption`1<Tuple`3<range, range, int>> |ActivePatternCaseUse|_|(Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int tyconRefDefnHash(TcGlobals _g, EntityRef eref1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyconRefDefnEq(TcGlobals g, EntityRef eref1, EntityRef eref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int valRefDefnHash(TcGlobals _g, ValRef vref1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valRefDefnEq(TcGlobals g, ValRef vref1, ValRef vref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool unionCaseRefDefnEq(TcGlobals g, UnionCaseRef uc1, UnionCaseRef uc2);
    [CompilerGeneratedAttribute]
internal static bool ItemsAreEffectivelyEqual$cont@1386(TcGlobals g, Typar tp2, Typar tp1, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ItemsAreEffectivelyEqual(TcGlobals g, Item orig, Item other);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ItemsAreEffectivelyEqualHash(TcGlobals g, Item orig);
    internal static IDisposable WithNewTypecheckResultsSink(ITypecheckResultsSink newSink, TcResultsSink sink);
    internal static IDisposable TemporarilySuspendReportingTypecheckResultsToSink(TcResultsSink sink);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallEnvSink(TcResultsSink sink, range scopem, NameResolutionEnv nenv, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallNameResolutionSink(TcResultsSink sink, range m, NameResolutionEnv nenv, Item item, Item itemMethodGroup, FSharpList`1<Tuple`2<Typar, TType>> tpinst, ItemOccurence occurenceType, DisplayEnv denv, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallNameResolutionSinkReplacing(TcResultsSink sink, range m, NameResolutionEnv nenv, Item item, Item itemMethodGroup, FSharpList`1<Tuple`2<Typar, TType>> tpinst, ItemOccurence occurenceType, DisplayEnv denv, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallExprHasTypeSink(TcResultsSink sink, range m, NameResolutionEnv nenv, TType ty, DisplayEnv denv, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallOpenDeclarationSink(TcResultsSink sink, OpenDeclaration openDeclaration);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckAllTyparsInferrable(ImportMap amap, range m, Item item);
    internal static FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>> CheckForTypeLegitimacyAndMultipleGenericTypeAmbiguities(FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>> tcrefs, TypeNameResolutionInfo typeNameResInfo, PermitDirectReferenceToGeneratedType genOk, range m);
    internal static ResultOrException`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>> moduleNotFound@1851(ImportMap amap, range m, AccessorDomain ad, FSharpRef`1<FSharpOption`1<Tuple`2<range, ResultOrException`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>>>>> moduleNotFoundErrorCache, EntityRef modref, ModuleOrNamespaceType mty, Ident id, int depth);
    internal static void notifyNameResolution@1865(TcResultsSink sink, NameResolutionEnv nenv, AccessorDomain ad, bool isOpenDecl, EntityRef modref, range m);
    internal static ResultOrException`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>> look@1873-9(TcResultsSink sink, ImportMap amap, range m, NameResolutionEnv nenv, AccessorDomain ad, bool isOpenDecl, FSharpRef`1<FSharpOption`1<Tuple`2<range, ResultOrException`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>>>>> moduleNotFoundErrorCache, int depth, EntityRef modref, ModuleOrNamespaceType mty, FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>>> ResolveLongIndentAsModuleOrNamespace(TcResultsSink sink, ResultCollectionSettings atMostOne, ImportMap amap, range m, bool first, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, bool isOpenDecl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<b>> ResolveLongIndentAsModuleOrNamespaceThen(TcResultsSink sink, ResultCollectionSettings atMostOne, ImportMap amap, range m, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, AccessorDomain ad, Ident id, FSharpList`1<a> rest, bool isOpenDecl, FSharpFunc`2<ResolutionInfo, FSharpFunc`2<int, FSharpFunc`2<range, FSharpFunc`2<EntityRef, FSharpFunc`2<ModuleOrNamespaceType, FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<a>, ResultOrException`1<b>>>>>>>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`2<a, Item>> ResolveObjectConstructorPrim(NameResolver ncenv, DisplayEnv edenv, a resInfo, range m, AccessorDomain ad, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Item> ResolveObjectConstructor(NameResolver ncenv, DisplayEnv edenv, range m, AccessorDomain ad, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> IntrinsicPropInfosOfTypeInScope(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, FindMemberFlag findFlag, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> SelectPropInfosFromExtMembers(InfoReader infoReader, AccessorDomain ad, FSharpOption`1<string> optFilter, TType declaringTy, range m, IEnumerable`1<ExtensionMember> extMemInfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> ExtensionPropInfosOfTypeInScope(ResultCollectionSettings collectionSettings, InfoReader infoReader, NameResolutionEnv nenv, FSharpOption`1<string> optFilter, AccessorDomain ad, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> AllPropInfosOfTypeInScope(ResultCollectionSettings collectionSettings, InfoReader infoReader, NameResolutionEnv nenv, FSharpOption`1<string> optFilter, AccessorDomain ad, FindMemberFlag findFlag, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> IntrinsicMethInfosOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, range m, TType ty);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<MethInfo> SelectMethInfosFromExtMembers$cont@2014(InfoReader infoReader, FSharpOption`1<string> optFilter, TType apparentTy, range m, TcGlobals g, ExtensionMember emem, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> SelectMethInfosFromExtMembers(InfoReader infoReader, FSharpOption`1<string> optFilter, TType apparentTy, range m, IEnumerable`1<ExtensionMember> extMemInfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> ExtensionMethInfosOfTypeInScope(ResultCollectionSettings collectionSettings, InfoReader infoReader, NameResolutionEnv nenv, FSharpOption`1<string> optFilter, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> AllMethInfosOfTypeInScope(ResultCollectionSettings collectionSettings, InfoReader infoReader, NameResolutionEnv nenv, FSharpOption`1<string> optFilter, AccessorDomain ad, FindMemberFlag findFlag, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<UnionCaseInfo> TryFindUnionCaseOfType(TcGlobals g, TType ty, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Item> TryFindAnonRecdFieldOfType(TcGlobals g, TType typ, string nm);
    internal static string CoreDisplayName(PropInfo pinfo);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Item> DecodeFSharpEvent$cont@2111(FSharpList`1<PropInfo> pinfos, AccessorDomain ad, TcGlobals g, NameResolver ncenv, range m, PropInfo pinfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Item> DecodeFSharpEvent(FSharpList`1<PropInfo> pinfos, AccessorDomain ad, TcGlobals g, NameResolver ncenv, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static HashSet`1<string> GetRecordLabelsForType(TcGlobals g, NameResolutionEnv nenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> ResolveLongIdentInTypePrim(NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, ResolutionInfo resInfo, int depth, range m, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, FindMemberFlag findFlag, TypeNameResolutionInfo typeNameResInfo, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> ResolveLongIdentInNestedTypes(NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, ResolutionInfo resInfo, int depth, Ident id, range m, AccessorDomain ad, Ident id2, FSharpList`1<Ident> rest, FindMemberFlag findFlag, TypeNameResolutionInfo typeNameResInfo, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Item, FSharpList`1<Ident>> ResolveLongIdentInType(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, range m, AccessorDomain ad, Ident id, FindMemberFlag findFlag, TypeNameResolutionInfo typeNameResInfo, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> ResolveLongIdentInTyconRef(NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, ResolutionInfo resInfo, int depth, range m, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, TypeNameResolutionInfo typeNameResInfo, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> ResolveLongIdentInTyconRefs(ResultCollectionSettings atMostOne, NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, int depth, range m, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, TypeNameResolutionInfo typeNameResInfo, range idRange, FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>> tcrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<EntityRef> |AccessibleEntityRef|_|(ImportMap amap, range m, AccessorDomain ad, EntityRef modref, Entity mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>> ResolveExprLongIdentInModuleOrNamespace(NameResolver ncenv, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, AccessorDomain ad, ResolutionInfo resInfo, int depth, range m, EntityRef modref, ModuleOrNamespaceType mty, Ident id, FSharpList`1<Ident> rest);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<a>>>> ChooseTyconRefInExpr(NameResolver ncenv, range m, AccessorDomain ad, NameResolutionEnv nenv, Ident id, TypeNameResolutionInfo typeNameResInfo, ResolutionInfo resInfo, FSharpList`1<EntityRef> tcrefs);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<a>>>>> implicitOpSearch@2460(Ident id, ResolutionInfo resInfo);
    internal static bool ValIsInEnv@2511(FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, string nm);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> moduleSearch@2524-1(TcResultsSink sink, NameResolver ncenv, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, Ident id, FSharpList`1<Ident> rest, bool isOpenDecl, range m, AccessorDomain ad, Unit unitVar1);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>>> tyconSearch@2530-4(NameResolver ncenv, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, Ident id, FSharpList`1<Ident> rest, ResolutionInfo resInfo, range m, AccessorDomain ad);
    internal static void suggestEverythingInScope@2562(NameResolver ncenv, FullyQualifiedFlag fullyQualified, AccessorDomain ad, NameResolutionEnv nenv, range m, FSharpFunc`2<string, Unit> addToBuffer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Item, FSharpList`1<Ident>> ResolveExprLongIdentPrim(TcResultsSink sink, NameResolver ncenv, bool first, FullyQualifiedFlag fullyQualified, range m, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, Ident id, FSharpList`1<Ident> rest, bool isOpenDecl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Item, FSharpList`1<Ident>> ResolveExprLongIdent(TcResultsSink sink, NameResolver ncenv, range m, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, FSharpList`1<Ident> lid);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<a>>>>> ctorSearch@2639(NameResolver ncenv, NameResolutionEnv nenv, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, range m, Lazy`1<FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>>> tcrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>> ResolvePatternLongIdentInModuleOrNamespace(NameResolver ncenv, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, AccessorDomain ad, ResolutionInfo resInfo, int depth, range m, EntityRef modref, ModuleOrNamespaceType mty, Ident id, FSharpList`1<Ident> rest);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>>> moduleSearch@2708-5(TcResultsSink sink, NameResolver ncenv, FullyQualifiedFlag fullyQualified, range m, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, Ident id, FSharpList`1<Ident> rest, AccessorDomain ad);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> tyconSearch@2712-6(NameResolver ncenv, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, Ident id, FSharpList`1<Ident> rest, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item ResolvePatternLongIdentPrim(TcResultsSink sink, NameResolver ncenv, FullyQualifiedFlag fullyQualified, WarnOnUpperFlag warnOnUpper, bool newDef, range m, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, Ident id, FSharpList`1<Ident> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item ResolvePatternLongIdent(TcResultsSink sink, NameResolver ncenv, WarnOnUpperFlag warnOnUpper, bool newDef, range m, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ResolveNestedTypeThroughAbbreviation(NameResolver ncenv, EntityRef tcref, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`2<ResolutionInfo, EntityRef>> ResolveTypeLongIdentInTyconRefPrim(NameResolver ncenv, TypeNameResolutionInfo typeNameResInfo, AccessorDomain ad, ResolutionInfo resInfo, PermitDirectReferenceToGeneratedType genOk, int depth, range m, EntityRef tcref, Ident id, FSharpList`1<Ident> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ResolveTypeLongIdentInTyconRef(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, AccessorDomain ad, range m, EntityRef tcref, FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception SuggestTypeLongIdentInModuleOrNamespace(int depth, EntityRef modref, ImportMap amap, AccessorDomain ad, range m, Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>>> ResolveTypeLongIdentInModuleOrNamespace(TcResultsSink sink, NameResolutionEnv nenv, NameResolver ncenv, TypeNameResolutionInfo typeNameResInfo, AccessorDomain ad, PermitDirectReferenceToGeneratedType genOk, ResolutionInfo resInfo, int depth, range m, EntityRef modref, ModuleOrNamespaceType _mty, Ident id, FSharpList`1<Ident> rest);
    internal static ResultOrException`1<FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>>> modulSearchFailed@2925(TcResultsSink sink, NameResolver ncenv, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, Ident id, FSharpList`1<Ident> rest, PermitDirectReferenceToGeneratedType genOk, TypeNameResolutionInfo typeNameResInfo, range m2, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`2<ResolutionInfo, EntityRef>> ResolveTypeLongIdentPrim(TcResultsSink sink, NameResolver ncenv, ItemOccurence occurence, bool first, FullyQualifiedFlag fullyQualified, range m, NameResolutionEnv nenv, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, TypeNameResolutionStaticArgsInfo staticResInfo, PermitDirectReferenceToGeneratedType genOk);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<EntityRef> ResolveTypeLongIdent(TcResultsSink sink, NameResolver ncenv, ItemOccurence occurence, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, AccessorDomain ad, FSharpList`1<Ident> lid, TypeNameResolutionStaticArgsInfo staticResInfo, PermitDirectReferenceToGeneratedType genOk);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`3<ResolutionInfo, FieldResolution, FSharpList`1<Ident>>> ResolveFieldInModuleOrNamespace(NameResolver ncenv, NameResolutionEnv nenv, AccessorDomain ad, ResolutionInfo resInfo, int depth, range m, EntityRef modref, ModuleOrNamespaceType _mty, Ident id, FSharpList`1<Ident> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static HashSet`1<string> SuggestOtherLabelsOfSameRecordType(TcGlobals g, NameResolutionEnv nenv, TType ty, Ident id, FSharpList`1<Ident> allFields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception SuggestLabelsOfRelatedRecords(TcGlobals g, NameResolutionEnv nenv, Ident id, FSharpList`1<Ident> allFields);
    internal static FSharpList`1<Tuple`2<ResolutionInfo, FieldResolution>> lookup@3079-1(NameResolutionEnv nenv, Ident id, FSharpList`1<Ident> allFields, TcGlobals g, Unit unitVar0);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, FieldResolution, FSharpList`1<Ident>>>>> tyconSearch@3110-11(NameResolver ncenv, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, FSharpList`1<Ident> lid, AccessorDomain ad);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, FieldResolution, FSharpList`1<Ident>>>> modulSearch@3123-6(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, range m, FSharpList`1<Ident> lid, AccessorDomain ad, Unit unitVar1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<ResolutionInfo, FieldResolution>> ResolveFieldPrim(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, AccessorDomain ad, TType ty, FSharpList`1<Ident> mp, Ident id, FSharpList`1<Ident> allFields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FieldResolution> ResolveField(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, AccessorDomain ad, TType ty, FSharpList`1<Ident> mp, Ident id, FSharpList`1<Ident> allFields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item FreshenRecdFieldRef(NameResolver ncenv, range m, RecdFieldRef rfref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>> ResolveExprDotLongIdent(NameResolver ncenv, range m, AccessorDomain ad, NameResolutionEnv nenv, TType ty, Ident id, FSharpList`1<Ident> rest, FindMemberFlag findFlag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range ComputeItemRange(range wholem, FSharpList`1<Ident> lid, FSharpList`1<a> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item FilterMethodGroups(NameResolver ncenv, range itemRange, Item item, bool staticOnly);
    internal static bool NeedsWorkAfterResolution(Item namedItem);
    internal static void callSink@3254(TcResultsSink sink, AccessorDomain ad, NameResolutionEnv nenv, range itemRange, Item item, bool isFakeIdents, Item tupledArg0, FSharpList`1<Tuple`2<Typar, TType>> tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<Item, range, FSharpList`1<Ident>, AfterResolution> ResolveLongIdentAsExprAndComputeRange(TcResultsSink sink, NameResolver ncenv, range wholem, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, FSharpList`1<Ident> lid);
    internal static FSharpOption`1<Unit> |NonOverridable|_|(Item namedItem);
    internal static Tuple`4<ResolutionInfo, Item, FSharpList`1<Ident>, range> resolveExpr@3298(NameResolver ncenv, range wholem, AccessorDomain ad, NameResolutionEnv nenv, TType ty, FSharpList`1<Ident> lid, FindMemberFlag findFlag);
    internal static void callSink@3324-1(TcResultsSink sink, NameResolver ncenv, AccessorDomain ad, NameResolutionEnv nenv, bool thisIsActuallyATyAppNotAnExpr, Item unrefinedItem, range itemRange, Item tupledArg0, FSharpList`1<Tuple`2<Typar, TType>> tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<Item, range, FSharpList`1<Ident>, AfterResolution> ResolveExprDotLongIdentAndComputeRange(TcResultsSink sink, NameResolver ncenv, range wholem, AccessorDomain ad, NameResolutionEnv nenv, TType ty, FSharpList`1<Ident> lid, FindMemberFlag findFlag, bool thisIsActuallyATyAppNotAnExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> FakeInstantiationGenerator(range _m, FSharpList`1<Typar> gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTyconUnseenObsoleteSpec(AccessorDomain ad, TcGlobals g, ImportMap amap, range m, EntityRef x, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsValUnseen(AccessorDomain ad, TcGlobals g, a m, ValRef v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsUnionCaseUnseen(AccessorDomain ad, TcGlobals g, ImportMap amap, range m, UnionCaseRef ucref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ItemIsUnseen(AccessorDomain ad, TcGlobals g, ImportMap amap, range m, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item ItemOfTyconRef(NameResolver ncenv, range m, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item ItemOfTy(TcGlobals g, TType x);
    internal static bool IsInterestingModuleName(string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> PartialResolveLookupInModuleOrNamespaceAsModuleOrNamespaceThen(FSharpFunc`2<EntityRef, FSharpList`1<a>> f, FSharpList`1<string> plid, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> PartialResolveLongIndentAsModuleOrNamespaceThen(NameResolutionEnv nenv, FSharpList`1<string> plid, FSharpFunc`2<EntityRef, FSharpList`1<a>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolveRecordOrClassFieldsOfType(NameResolver ncenv, range m, AccessorDomain ad, TType ty, bool statics);
    internal static FSharpFunc`2<MethInfo, bool> minfoFilter@3516(ResolveCompletionTargets completionTargets, range m, AccessorDomain ad, bool statics, TType ty, TcGlobals g, ImportMap amap, Set`2<string, IComparer`1<string>> suppressedMethNames);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<MethInfo> minfos$cont@3581(ResolveCompletionTargets completionTargets, range m, AccessorDomain ad, bool statics, TType ty, TcGlobals g, ImportMap amap, FSharpList`1<string> pinfoMethNames, FSharpList`1<string> einfoMethNames, FSharpList`1<Item> pinfoItems, FSharpList`1<MethInfo> minfos, Unit unitVar);
    internal static FSharpMap`2<string, FSharpList`1<MethInfo>> partitionl@3627(FSharpList`1<MethInfo> l, FSharpMap`2<string, FSharpList`1<MethInfo>> acc);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Item> f@105-14(NameResolver ncenv, NameResolutionEnv nenv, ResolveCompletionTargets completionTargets, range m, AccessorDomain ad, bool statics, TType ty, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolveCompletionsInType(NameResolver ncenv, NameResolutionEnv nenv, ResolveCompletionTargets completionTargets, range m, AccessorDomain ad, bool statics, TType ty);
    internal static TType FullTypeOfPinfo@3673(range m, TcGlobals g, ImportMap amap, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentInType(NameResolver ncenv, NameResolutionEnv nenv, ResolveCompletionTargets isApplicableMeth, range m, AccessorDomain ad, bool statics, FSharpList`1<string> plid, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> InfosForTyconConstructors(NameResolver ncenv, range m, AccessorDomain ad, EntityRef tcref);
    internal static HashSet`1<string> getFakeContainerModulesFromTycons(a tycons);
    internal static HashSet`1<string> getFakeContainerModulesFromTyconRefs(a tyconRefs);
    [CompilerGeneratedAttribute]
internal static bool f@119-15(range m, AccessorDomain ad, EntityRef modref, TcGlobals g, Val v, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EntityRefContainsSomethingAccessible(NameResolver ncenv, range m, AccessorDomain ad, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentInModuleOrNamespace(NameResolver ncenv, NameResolutionEnv nenv, ResolveCompletionTargets isApplicableMeth, range m, AccessorDomain ad, EntityRef modref, FSharpList`1<string> plid, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> TryToResolveLongIdentAsType(NameResolver ncenv, NameResolutionEnv nenv, range m, FSharpList`1<string> plid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentPrim(NameResolver ncenv, NameResolutionEnv nenv, ResolveCompletionTargets isApplicableMeth, FullyQualifiedFlag fullyQualified, range m, AccessorDomain ad, FSharpList`1<string> plid, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdent(NameResolver ncenv, NameResolutionEnv nenv, FSharpFunc`2<MethInfo, FSharpFunc`2<TType, bool>> isApplicableMeth, range m, AccessorDomain ad, FSharpList`1<string> plid, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentInModuleOrNamespaceForRecordFields(NameResolver ncenv, a nenv, range m, AccessorDomain ad, EntityRef modref, FSharpList`1<string> plid, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentToClassOrRecdFields(NameResolver ncenv, NameResolutionEnv nenv, range m, AccessorDomain ad, FSharpList`1<string> plid, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentToClassOrRecdFieldsImpl(NameResolver ncenv, NameResolutionEnv nenv, FullyQualifiedFlag fullyQualified, range m, AccessorDomain ad, FSharpList`1<string> plid, bool allowObsolete);
    internal static FSharpFunc`2<MethInfo, bool> minfoFilter@4228-2(range m, AccessorDomain ad, bool statics, TType ty, TcGlobals g, ImportMap amap, Set`2<string, IComparer`1<string>> suppressedMethNames);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<MethInfo> minfos$cont@4282-1(range m, AccessorDomain ad, bool statics, TType ty, TcGlobals g, ImportMap amap, FSharpList`1<string> pinfoMethNames, FSharpList`1<string> einfoMethNames, FSharpList`1<Item> pinfoItems, FSharpList`1<MethInfo> minfos, Unit unitVar);
    internal static FSharpMap`2<string, FSharpList`1<MethInfo>> partitionl@4324-1(FSharpList`1<MethInfo> l, FSharpMap`2<string, FSharpList`1<MethInfo>> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Item> ResolveCompletionsInTypeForItem(NameResolver ncenv, NameResolutionEnv nenv, range m, AccessorDomain ad, bool statics, TType ty, Item item);
    internal static TType fullTypeOfPinfo@4355(range m, TcGlobals g, ImportMap amap, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Item> ResolvePartialLongIdentInTypeForItem(NameResolver ncenv, NameResolutionEnv nenv, range m, AccessorDomain ad, bool statics, FSharpList`1<string> plid, Item item, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Item> ResolvePartialLongIdentInModuleOrNamespaceForItem(NameResolver ncenv, NameResolutionEnv nenv, range m, AccessorDomain ad, EntityRef modref, FSharpList`1<string> plid, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<a> PartialResolveLookupInModuleOrNamespaceAsModuleOrNamespaceThenLazy(FSharpFunc`2<EntityRef, IEnumerable`1<a>> f, FSharpList`1<string> plid, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<a> PartialResolveLongIndentAsModuleOrNamespaceThenLazy(NameResolutionEnv nenv, FSharpList`1<string> plid, FSharpFunc`2<EntityRef, IEnumerable`1<a>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Item> GetCompletionForItem(NameResolver ncenv, NameResolutionEnv nenv, range m, AccessorDomain ad, FSharpList`1<string> plid, Item item);
    [CompilerGeneratedAttribute]
internal static bool f@105-16(NameResolver ncenv, NameResolutionEnv nenv, range m, AccessorDomain ad, FSharpList`1<string> plid, Item item, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsItemResolvable(NameResolver ncenv, NameResolutionEnv nenv, range m, AccessorDomain ad, FSharpList`1<string> plid, Item item);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<EntityRef> f@105-17(NameResolver ncenv, NameResolutionEnv nenv, range m, AccessorDomain ad, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<EntityRef> GetVisibleNamespacesAndModulesAtPoint(NameResolver ncenv, NameResolutionEnv nenv, range m, AccessorDomain ad);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.NiceNameGenerator : object {
    internal object lockObj;
    internal Dictionary`2<string, int> basicNameCounts;
    public string FreshCompilerGeneratedName(string name, range m);
    public void Reset();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.NicePrint : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutTyparConstraint(DisplayEnv denv, Typar x_0, TyparConstraint x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputType(DisplayEnv denv, StringBuilder os, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutType(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputTypars(DisplayEnv denv, TaggedText nm, StringBuilder os, FSharpList`1<Typar> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputTyconRef(DisplayEnv denv, StringBuilder os, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutTyconRef(DisplayEnv denv, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutConst(TcGlobals g, TType ty, Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfMemberSig(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> x_0, string x_1, FSharpList`1<Typar> x_2, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> x_3, TType x_4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<TType, Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, Layout>> prettyLayoutOfUncurriedSig(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> argInfos, FSharpList`1<Tuple`2<TType, ArgReprInfo>> tau);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout dataExprL(DisplayEnv denv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputValOrMember(DisplayEnv denv, StringBuilder os, Val x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringValOrMember(DisplayEnv denv, Val x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, Layout> layoutQualifiedValOrMember(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> typarInst, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputQualifiedValOrMember(DisplayEnv denv, StringBuilder os, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputQualifiedValSpec(DisplayEnv denv, StringBuilder os, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfQualifiedValOrMember(DisplayEnv denv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void formatMethInfoToBufferFreeStyle(ImportMap amap, range m, DisplayEnv denv, StringBuilder buf, MethInfo d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, Layout> prettyLayoutOfMethInfoFreeStyle(ImportMap amap, range m, DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> typarInst, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfPropInfoFreeStyle(TcGlobals g, ImportMap amap, range m, DisplayEnv denv, PropInfo d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfMethInfo(ImportMap amap, range m, DisplayEnv denv, MethInfo d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfParamData(DisplayEnv denv, ParamData paramData);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutOfParamData(DisplayEnv denv, ParamData paramData);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputILTypeRef(DisplayEnv denv, StringBuilder os, ILTypeRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutILTypeRef(DisplayEnv denv, ILTypeRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputExnDef(DisplayEnv denv, StringBuilder os, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutExnDef(DisplayEnv denv, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfTyparConstraints(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TyparConstraint>> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputTycon(DisplayEnv denv, InfoReader infoReader, AccessorDomain ad, range m, StringBuilder os, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutTycon(DisplayEnv denv, InfoReader infoReader, AccessorDomain ad, range m, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutUnionCases(DisplayEnv denv, FSharpList`1<RecdField> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputUnionCases(DisplayEnv denv, StringBuilder os, FSharpList`1<RecdField> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isGeneratedUnionCaseField(int pos, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isGeneratedExceptionField(int pos, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfTyparConstraint(DisplayEnv denv, Typar tpc_0, TyparConstraint tpc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfTy(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfType(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfTypeNoCx(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string prettyStringOfTy(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string prettyStringOfTyNoCx(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfRecdField(DisplayEnv denv, RecdField x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfUnionCase(DisplayEnv denv, UnionCase x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfExnDef(DisplayEnv denv, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfFSAttrib(DisplayEnv denv, Attrib x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfILAttrib(DisplayEnv denv, ILType x_0, FSharpList`1<ILAttribElem> x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutInferredSigOfModuleExpr(bool showHeader, DisplayEnv denv, InfoReader infoReader, AccessorDomain ad, range m, ModuleOrNamespaceExprWithSig expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, Layout> prettyLayoutOfValOrMember(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> typarInst, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfValOrMemberNoInst(DisplayEnv denv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Tuple`2<Typar, TType>>, Tuple`2<FSharpList`1<TType>, TType>, Tuple`2<FSharpList`1<Layout>, Layout>, Layout> prettyLayoutOfInstAndSig(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> x_0, FSharpList`1<TType> x_1, TType x_2);
    internal static string makeName@2108(TType t1, DisplayEnv denv, TType t);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, string, string> minimalStringsOfTwoTypes$cont@2094-1(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TyparConstraint>> tpcs, TType t2, TType t1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, string, string> minimalStringsOfTwoTypes$cont@2078(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TyparConstraint>> tpcs, TType t2, TType t1, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<string, string, string> minimalStringsOfTwoTypes(DisplayEnv denv, TType t1, TType t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, string> minimalStringsOfTwoValues(DisplayEnv denv, Val v1, Val v2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string minimalStringOfType(DisplayEnv denv, TType ty);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Optimizer : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static bool verboseOptimizationInfo;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static bool verboseOptimizations;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int callSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int forAndWhileLoopSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int tryCatchSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int tryFinallySize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int closureTotalSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int methodDefnTotalSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int minDepthForASizeNode;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static bool jitOptDefault;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static bool localOptDefault;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static bool crossModuleOptDefault;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int localVarSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string suffixForVariablesThatMayNotBeEliminated;
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILInstr> i_ldlen { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<ModuleInfo> EmptyModuleInfo { get; }
    [CompilationMappingAttribute("9")]
internal static ValInfo UnknownValInfo { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpList`1<Expr>, FSharpList`1<Summary`1<ExprValueInfo>>> NoExprs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> AbstractOptimizationInfoToEssentials { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> abstractLazyModulInfo@1128-1 { get; }
    private static Optimizer();
    internal static FSharpList`1<ILInstr> get_i_ldlen();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@200-56(Summary`1<Info> this, Summary`1<Info> obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@200-57(Summary`1<Info> this, Summary`1<Info> objTemp, Unit unitVar);
    internal static int SizeOfValueInfos(ExprValueInfo[] arr);
    internal static int SizeOfValueInfo(ExprValueInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprValueInfo MakeValueInfoWithCachedSize(int vdepth, ExprValueInfo v);
    internal static ExprValueInfo bound@250(int depth, ExprValueInfo x);
    internal static ExprValueInfo BoundValueInfoBySize(ExprValueInfo vinfo);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@281-60(OptimizationSettings this, OptimizationSettings obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@281-59(OptimizationSettings this, OptimizationSettings obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@281-58(OptimizationSettings this, OptimizationSettings obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@281-63(OptimizationSettings this, OptimizationSettings objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@281-62(OptimizationSettings this, OptimizationSettings objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@281-61(IComparer comp, OptimizationSettings this, OptimizationSettings objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@281-8(IEqualityComparer comp, OptimizationSettings this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@281-14(OptimizationSettings this, OptimizationSettings that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@281-15(OptimizationSettings this, OptimizationSettings obj, Unit unitVar);
    internal static bool IsPartialExprVal(ExprValueInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckInlineValueIsComplete(Val v, ExprValueInfo res);
    internal static Lazy`1<ModuleInfo> get_EmptyModuleInfo();
    internal static Lazy`1<ModuleInfo> UnionOptimizationInfos(IEnumerable`1<Lazy`1<ModuleInfo>> minfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<ModuleInfo> FindOrCreateModuleInfo(a n, FSharpMap`2<a, Lazy`1<ModuleInfo>> ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<ModuleInfo> FindOrCreateGlobalModuleInfo(a n, FSharpMap`2<a, Lazy`1<ModuleInfo>> ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleInfo BindValueInSubModuleFSharpCore(String[] mp, int i, Val v, ValInfo vval, ModuleInfo ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Lazy`1<ModuleInfo>> BindValueInModuleForFslib(string n, String[] mp, int i, Val v, ValInfo vval, FSharpMap`2<string, Lazy`1<ModuleInfo>> ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<a, Lazy`1<ModuleInfo>> BindValueInGlobalModuleForFslib(a n, String[] mp, int i, Val v, ValInfo vval, FSharpMap`2<a, Lazy`1<ModuleInfo>> ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindValueForFslib(NonLocalValOrMemberRef nlvref, Val v, ValInfo vval, IncrementalOptimizationEnv env);
    internal static ValInfo get_UnknownValInfo();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a BindInternalLocalVal(cenv cenv, Val v, ValInfo vval, a env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindExternalLocalVal(cenv cenv, Val v, ValInfo vval, IncrementalOptimizationEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindValsInModuleOrNamespace(cenv cenv, Lazy`1<ModuleInfo> mval, IncrementalOptimizationEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindTypeVar(Typar tyv, TypeValueInfo typeinfo, IncrementalOptimizationEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindTypeVarsToUnknown(FSharpList`1<Typar> tps, IncrementalOptimizationEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindCcu(CcuThunk ccu, Lazy`1<ModuleInfo> mval, IncrementalOptimizationEnv env, TcGlobals _g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValInfo GetInfoForLocalValue(cenv cenv, IncrementalOptimizationEnv env, Val v, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ModuleInfo> TryGetInfoForEntity(ModuleInfo sv, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ModuleInfo> TryGetInfoForPath(ModuleInfo sv, String[] p, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ModuleInfo> TryGetInfoForNonLocalEntityRef(IncrementalOptimizationEnv env, NonLocalEntityRef nleref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValInfo GetInfoForNonLocalVal(cenv cenv, IncrementalOptimizationEnv env, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValInfo GetInfoForVal(cenv cenv, IncrementalOptimizationEnv env, range m, ValRef vref);
    internal static ExprValueInfo stripValue(ExprValueInfo _arg1);
    internal static FSharpOption`1<Const> |StripConstValue|_|(ExprValueInfo ev);
    internal static FSharpOption`1<Tuple`5<long, int, int, Expr, TType>> |StripLambdaValue|_|(ExprValueInfo ev);
    internal static FSharpOption`1<ExprValueInfo[]> destTupleValue(ExprValueInfo ev);
    internal static FSharpOption`1<ExprValueInfo[]> destRecdValue(ExprValueInfo ev);
    internal static FSharpOption`1<Tuple`2<UnionCaseRef, ExprValueInfo[]>> |StripUnionCaseValue|_|(ExprValueInfo ev);
    [CompilerGeneratedAttribute]
internal static ExprValueInfo mkAssemblyCodeValueInfo$cont@965(TcGlobals g, TType ty, bool a, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ExprValueInfo mkAssemblyCodeValueInfo$cont@930-3(TcGlobals g, ExprValueInfo matchValue_0, ExprValueInfo matchValue_1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ExprValueInfo mkAssemblyCodeValueInfo$cont@930-2(TcGlobals g, ExprValueInfo matchValue_0, ExprValueInfo matchValue_1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ExprValueInfo mkAssemblyCodeValueInfo$cont@930-1(TcGlobals g, ExprValueInfo matchValue_0, ExprValueInfo matchValue_1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ExprValueInfo mkAssemblyCodeValueInfo$cont@942-4(TcGlobals g, ExprValueInfo matchValue_0, ExprValueInfo matchValue_1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ExprValueInfo mkAssemblyCodeValueInfo$cont@949-5(TcGlobals g, ExprValueInfo matchValue_0, ExprValueInfo matchValue_1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@758(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@758-1(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@758-2(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@758-3(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@758-4(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@758-5(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerUnaryOp$cont@729(TcGlobals g, Const c, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ExprValueInfo mkAssemblyCodeValueInfo$cont@795-6(TcGlobals g, ExprValueInfo a, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprValueInfo mkAssemblyCodeValueInfo(TcGlobals g, FSharpList`1<ILInstr> instrs, FSharpList`1<ExprValueInfo> argvals, FSharpList`1<TType> tys);
    internal static int AddTotalSizes(FSharpList`1<Summary`1<a>> l);
    internal static int AddFunctionSizes(FSharpList`1<Summary`1<a>> l);
    internal static bool OrEffects(FSharpList`1<Summary`1<a>> l);
    internal static bool OrTailcalls(FSharpList`1<Summary`1<a>> l);
    internal static Tuple`2<FSharpList`1<Expr>, FSharpList`1<Summary`1<ExprValueInfo>>> get_NoExprs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Summary`1<b> CombineValueInfos(FSharpList`1<Summary`1<a>> einfos, b res);
    internal static ExprValueInfo abstractExprInfo@1051(bool isAssemblyBoundary, FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> abstractLazyModulInfo, FSharpFunc`2<Entity, bool> patternInput_0, FSharpFunc`2<Entity, bool> patternInput_1, FSharpFunc`2<Val, bool> patternInput_2, FSharpFunc`2<RecdFieldRef, bool> patternInput_3, FSharpFunc`2<UnionCaseRef, bool> patternInput_4, ExprValueInfo ivalue);
    internal static ValInfo abstractValInfo@1105(bool isAssemblyBoundary, FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> abstractLazyModulInfo, FSharpFunc`2<Entity, bool> patternInput_0, FSharpFunc`2<Entity, bool> patternInput_1, FSharpFunc`2<Val, bool> patternInput_2, FSharpFunc`2<RecdFieldRef, bool> patternInput_3, FSharpFunc`2<UnionCaseRef, bool> patternInput_4, ValInfo v);
    internal static ModuleInfo abstractModulInfo@1109(bool isAssemblyBoundary, FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> abstractLazyModulInfo, FSharpFunc`2<Entity, bool> patternInput_0, FSharpFunc`2<Entity, bool> patternInput_1, FSharpFunc`2<Val, bool> patternInput_2, FSharpFunc`2<RecdFieldRef, bool> patternInput_3, FSharpFunc`2<UnionCaseRef, bool> patternInput_4, ModuleInfo ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> AbstractLazyModulInfoByHiding(bool isAssemblyBoundary, SignatureHidingInfo mhi);
    internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> get_AbstractOptimizationInfoToEssentials();
    internal static ModuleInfo abstractModulInfo@1124-3(ModuleInfo ss);
    internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> get_abstractLazyModulInfo@1128-1();
    internal static ExprValueInfo abstractExprInfo@1143-3(FSharpList`1<Typar> boundTyVars, FSharpList`1<Val> boundVars, ExprValueInfo ivalue);
    internal static ValInfo abstractValInfo@1186-1(FSharpList`1<Typar> boundTyVars, FSharpList`1<Val> boundVars, ValInfo v);
    internal static ModuleInfo abstractModulInfo@1190-6(FSharpList`1<Typar> boundTyVars, FSharpList`1<Val> boundVars, ModuleInfo ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprValueInfo AbstractExprInfoByVars(FSharpList`1<Val> boundVars, FSharpList`1<Typar> boundTyVars, ExprValueInfo ivalue);
    internal static ExprValueInfo remapExprInfo@1201(TcGlobals g, Remap tmenv, ExprValueInfo ivalue);
    internal static ValInfo remapValInfo@1213(TcGlobals g, Remap tmenv, ValInfo v);
    internal static ModuleInfo remapModulInfo@1217(TcGlobals g, Remap tmenv, FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> remapLazyModulInfo, ModuleInfo ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> RemapOptimizationInfo(TcGlobals g, Remap tmenv);
    internal static bool IsTyFuncValRefExpr(Expr _arg1);
    internal static bool IsSmallConstExpr(Expr x);
    internal static ExprValueInfo ValueOfExpr(Expr expr);
    internal static bool IsDiscardableEffectExpr(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValueIsUsedOrHasEffect(cenv cenv, FSharpFunc`2<Unit, Set`2<Val, IComparer`1<Val>>> fvs, Binding b, Summary`1<a> binfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Summary`1<a>>> SplitValuesByIsUsedOrHasEffect(cenv cenv, FSharpFunc`2<Unit, Set`2<Val, IComparer`1<Val>>> fvs, FSharpList`1<Tuple`2<Binding, Summary`1<a>>> x);
    internal static bool IlAssemblyCodeInstrHasEffect(ILInstr i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExprHasEffect(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExprsHaveEffect(TcGlobals g, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool BindingsHaveEffect(TcGlobals g, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool BindingHasEffect(TcGlobals g, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool OpHasEffect(TcGlobals g, range m, TOp op);
    internal static bool IsUniqueUse@1402(Val vspec1, Val vspec2, FSharpList`1<Expr> args);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<Expr>, FSharpList`1<Expr>>> GetImmediateUseContext@1410(cenv cenv, Val vspec1, FSharpList`1<Expr> rargsl, FSharpList`1<Expr> argsr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryEliminateBinding(cenv cenv, a _env, Binding _arg1, Expr e2, b _m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, int> TryEliminateLet(cenv cenv, a env, Binding bind, Expr e2, range m);
    internal static FSharpOption`1<Tuple`3<ValRef, FSharpList`1<TType>, FSharpList`1<Expr>>> |KnownValApp|_|(Expr expr);
    internal static FSharpOption`1<Tuple`5<Expr, bool, DecisionTree, DecisionTree, range>> |TDBoolSwitch|_|(DecisionTree dtree);
    internal static FSharpOption`1<bool> |ConstantBoolTarget|_|(DecisionTreeTarget target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> CountBoolLogicTree(DecisionTreeTarget[] _arg1_0, int _arg1_1, int _arg1_2, bool _arg1_3, DecisionTree tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree RewriteBoolLogicTree(DecisionTreeTarget[] _arg1_0, DecisionTree _arg1_1, DecisionTree _arg1_2, bool _arg1_3, DecisionTree tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTreeCase RewriteBoolLogicCase(DecisionTreeTarget[] data_0, DecisionTree data_1, DecisionTree data_2, bool data_3, DecisionTreeCase _arg2);
    internal static Expr CombineBoolLogic(Expr expr);
    internal static bool CanExpandStructuralBinding(Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Binding> MakeStructuralBindingTemp(Val v, int i, Expr arg, TType argTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr ExpandStructuralBindingRaw(cenv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> RearrangeTupleBindings(Expr expr, FSharpFunc`2<Expr, Expr> fin);
    [CompilerGeneratedAttribute]
internal static Expr ExpandStructuralBinding$cont@1615(cenv cenv, Expr expr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr ExpandStructuralBinding(cenv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, FSharpOption`1<TType>>> |QueryRun|_|(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Tuple`4<ValRef, FSharpList`1<TType>, Expr, FSharpList`1<Expr>>> |AnyInstanceMethodApp|_|(Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<FSharpList`1<TType>, Expr, FSharpList`1<Expr>>> |InstanceMethodApp|_|(TcGlobals g, ValRef expectedValRef, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<TType, Expr>> |QuerySourceEnumerable|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<TType, TType, TType, Expr, Expr>> |QueryFor|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<TType, TType, Expr>> |QueryYield|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<TType, TType, Expr>> |QueryYieldFrom|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<TType, TType, TType, Expr, Expr>> |QuerySelect|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<TType, TType>> |QueryZero|_|(TcGlobals g, Expr _arg1);
    internal static Tuple`2<FSharpList`1<Expr>, FSharpFunc`2<FSharpList`1<Expr>, Expr>> |AnyRefTupleTrans|(Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, FSharpFunc`2<Expr, Expr>>> |AnyQueryBuilderOpTrans|_|(TcGlobals g, Expr _arg1);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<DecisionTreeTarget> mapping@1-23(TcGlobals g, DecisionTreeTarget _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> tryRewriteToSeqCombinators(TcGlobals g, Expr e);
    internal static FSharpOption`1<Tuple`2<Expr, FSharpOption`1<Tuple`2<TType, TType>>>> loopOuter@1781(cenv cenv, TcGlobals g, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryDetectQueryQuoteAndRun(cenv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILMethodRefDeclaringTypeSystemString(ILGlobals ilg, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILMethodRefSystemStringConcatOverload(ILGlobals ilg, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILMethodRefSystemStringConcatArray(ILGlobals ilg, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExpr(cenv cenv, IncrementalOptimizationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeObjectExpr(cenv cenv, IncrementalOptimizationEnv env, TType ty, FSharpOption`1<Val> baseValOpt, Expr basecall, FSharpList`1<ObjExprMethod> overrides, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> iimpls, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<ObjExprMethod>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeMethods(cenv cenv, IncrementalOptimizationEnv env, FSharpOption`1<Val> baseValOpt, FSharpList`1<ObjExprMethod> methods);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ObjExprMethod, Summary`1<ExprValueInfo>> OptimizeMethod(cenv cenv, IncrementalOptimizationEnv env, FSharpOption`1<Val> baseValOpt, ObjExprMethod _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeInterfaceImpls(cenv cenv, IncrementalOptimizationEnv env, FSharpOption`1<Val> baseValOpt, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> iimpls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<TType, FSharpList`1<ObjExprMethod>>, Summary`1<ExprValueInfo>> OptimizeInterfaceImpl(cenv cenv, IncrementalOptimizationEnv env, FSharpOption`1<Val> baseValOpt, TType ty, FSharpList`1<ObjExprMethod> overrides);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Expr> optimizeArg$cont@1974(cenv cenv, range m, Expr argExpr, FSharpList`1<Expr> accArgs, Unit unitVar);
    internal static FSharpList`1<Expr> optimizeArg@1973(cenv cenv, range m, Expr argExpr, FSharpList`1<Expr> accArgs);
    internal static FSharpList`1<Expr> optimizeArgs@1987(cenv cenv, range m, FSharpList`1<Expr> args, FSharpList`1<Expr> accArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> MakeOptimizedSystemStringConcatCall(cenv cenv, IncrementalOptimizationEnv env, range m, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprOp(cenv cenv, IncrementalOptimizationEnv env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprOpReductions(cenv cenv, IncrementalOptimizationEnv env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprOpReductionsAfter(cenv cenv, IncrementalOptimizationEnv env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> argsR, FSharpList`1<Summary`1<ExprValueInfo>> arginfos, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprOpFallback(cenv cenv, IncrementalOptimizationEnv env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> argsR, range m, FSharpList`1<Summary`1<ExprValueInfo>> arginfos, ExprValueInfo valu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeConst(cenv cenv, IncrementalOptimizationEnv env, Expr expr, Const c, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ExprValueInfo> TryOptimizeRecordFieldGet(cenv cenv, IncrementalOptimizationEnv _env, Summary`1<ExprValueInfo> e1info, RecdFieldRef _arg2, FSharpList`1<TType> _tinst, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ExprValueInfo> TryOptimizeTupleFieldGet(cenv cenv, IncrementalOptimizationEnv _env, TupInfo _tupInfo, Summary`1<ExprValueInfo> e1info, FSharpList`1<TType> tys, int n, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ExprValueInfo> TryOptimizeUnionCaseGet(cenv cenv, IncrementalOptimizationEnv _env, Summary`1<ExprValueInfo> e1info, UnionCaseRef cspec, FSharpList`1<TType> _tys, int n, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeFastIntegerForLoop(cenv cenv, IncrementalOptimizationEnv env, SequencePointInfoForForLoop spStart, Val v, Expr e1, ForLoopStyle dir, Expr e2, Expr e3, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeLetRec(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<Binding> binds, Expr bodyExpr, range m);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> func1@1-10(cenv cenv, IncrementalOptimizationEnv env, TType ty, SequencePointInfoForTarget spTarget2, SequencePointInfoForBinding spMatch, range m, range exprm, DecisionTree dtreeR, Summary`1<ExprValueInfo> dinfo, Summary`1<ExprValueInfo> tg1info, DecisionTreeTarget tg1, Expr tupledArg0, Summary`1<ExprValueInfo> tupledArg1);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> func1@1-11(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<TType> tyargs, TOp op, range m, FSharpList`1<Expr> argsHeadR, FSharpList`1<Summary`1<ExprValueInfo>> argsHeadInfosR, Expr tupledArg0, Summary`1<ExprValueInfo> tupledArg1);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> func1@1-12(cenv cenv, SequencePointInfoForSeq spSeq, range m, SequentialOpKind flag, Summary`1<ExprValueInfo> e1info, Expr e1R, Expr tupledArg0, Summary`1<ExprValueInfo> tupledArg1);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> func1@1-13(cenv cenv, range m, IncrementalOptimizationEnv env, Summary`1<ExprValueInfo> bindingInfo, Binding bindR, Expr tupledArg0, Summary`1<ExprValueInfo> tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeLinearExpr(cenv cenv, IncrementalOptimizationEnv env, Expr expr, FSharpFunc`2<Tuple`2<Expr, Summary`1<ExprValueInfo>>, Tuple`2<Expr, Summary`1<ExprValueInfo>>> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeTryFinally(cenv cenv, IncrementalOptimizationEnv env, SequencePointInfoForTry spTry, SequencePointInfoForFinally spFinally, Expr e1, Expr e2, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeTryCatch(cenv cenv, IncrementalOptimizationEnv env, Expr e1, Val vf, Expr ef, Val vh, Expr eh, range m, TType ty, SequencePointInfoForTry spTry, SequencePointInfoForWith spWith);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeWhileLoop(cenv cenv, IncrementalOptimizationEnv env, SequencePointInfoForWhileLoop spWhile, SpecialWhileLoopMarker marker, Expr e1, Expr e2, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeTraitCall(cenv cenv, IncrementalOptimizationEnv env, TraitConstraintInfo traitInfo, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryOptimizeVal(cenv cenv, IncrementalOptimizationEnv env, bool mustInline, ExprValueInfo valInfoForVal, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryOptimizeValInfo(cenv cenv, IncrementalOptimizationEnv env, range m, Summary`1<ExprValueInfo> vinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Summary`1<ExprValueInfo> AddValEqualityInfo(a g, b m, ValRef v, Summary`1<ExprValueInfo> info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeVal(cenv cenv, IncrementalOptimizationEnv env, Expr expr, ValRef v, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<EntityRef, FSharpList`1<TType>> StripToNominalTyconRef(cenv cenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanDevirtualizeApplication(cenv cenv, ValRef v, ValRef vref, TType ty, FSharpList`1<c> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<Expr, Expr>, FSharpList`1<Expr>> TakeAddressOfStructArgumentIfNeeded(cenv cenv, ValRef vref, TType ty, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> DevirtualizeApplication(cenv cenv, IncrementalOptimizationEnv env, ValRef vref, TType ty, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Summary`1<ExprValueInfo>>> TryDevirtualizeApplication(cenv cenv, IncrementalOptimizationEnv env, Expr f, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Summary`1<ExprValueInfo>>> TryInlineApplication(cenv cenv, IncrementalOptimizationEnv env, Summary`1<ExprValueInfo> finfo, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeApplication(cenv cenv, IncrementalOptimizationEnv env, Expr f0, TType f0ty, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m);
    [CompilerGeneratedAttribute]
internal static void OptimizeLambdas$cont@2921(cenv cenv, Summary`1<ExprValueInfo> bodyinfo, Val v, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeLambdas(FSharpOption`1<Val> vspec, cenv cenv, IncrementalOptimizationEnv env, ValReprInfo topValInfo, Expr e, TType ety);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Expr>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeExprsThenReshapeAndConsiderSplits(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<Tuple`2<ExprValueInfo, Expr>> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Expr>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeExprsThenConsiderSplits(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprThenReshapeAndConsiderSplit(cenv cenv, IncrementalOptimizationEnv env, ExprValueInfo shape, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<DecisionTreeTarget>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeDecisionTreeTargets(cenv cenv, IncrementalOptimizationEnv env, range m, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr ReshapeExpr(cenv cenv, ExprValueInfo shape, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprThenConsiderSplit(cenv cenv, IncrementalOptimizationEnv env, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ComputeSplitToMethodCondition(bool flag, int threshold, cenv cenv, IncrementalOptimizationEnv env, Expr e, Summary`1<d> einfo);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> ConsiderSplitToMethod$cont@3027(cenv cenv, IncrementalOptimizationEnv env, Expr e, Summary`1<ExprValueInfo> einfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> ConsiderSplitToMethod(bool flag, int threshold, cenv cenv, IncrementalOptimizationEnv env, Expr e, Summary`1<ExprValueInfo> einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeMatch(cenv cenv, IncrementalOptimizationEnv env, SequencePointInfoForBinding spMatch, range exprm, DecisionTree dtree, DecisionTreeTarget[] targets, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeMatchPart2(cenv cenv, SequencePointInfoForBinding spMatch, range exprm, DecisionTree dtreeR, FSharpList`1<DecisionTreeTarget> targetsR, Summary`1<ExprValueInfo> dinfo, FSharpList`1<Summary`1<ExprValueInfo>> tinfos, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Summary`1<ExprValueInfo> CombineMatchInfos(Summary`1<e> dinfo, Summary`1<f> tinfo);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> RebuildOptimizedMatch(SequencePointInfoForBinding spMatch, range exprm, range m, TType ty, DecisionTree dtree, FSharpList`1<DecisionTreeTarget> tgs, Summary`1<ExprValueInfo> dinfo, FSharpList`1<Summary`1<ExprValueInfo>> tinfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTreeTarget, Summary`1<ExprValueInfo>> OptimizeDecisionTreeTarget(cenv cenv, IncrementalOptimizationEnv env, range _m, DecisionTreeTarget _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, Summary`1<ExprValueInfo>> OptimizeDecisionTree(cenv cenv, IncrementalOptimizationEnv env, range m, DecisionTree x);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<bool> TryOptimizeDecisionTreeTest$cont@3114(DecisionTreeTest test, ExprValueInfo vinfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryOptimizeDecisionTreeTest(cenv cenv, DecisionTreeTest test, ExprValueInfo vinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, Summary`1<ExprValueInfo>> OptimizeSwitch(cenv cenv, IncrementalOptimizationEnv env, Expr e, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> dflt, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, Summary`1<ExprValueInfo>> OptimizeSwitchFallback(cenv cenv, IncrementalOptimizationEnv env, Expr eR, Summary`1<ExprValueInfo> einfo, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> dflt, range m);
    internal static ExprValueInfo cut@3179(cenv cenv, ExprValueInfo ivalue);
    [CompilerGeneratedAttribute]
internal static bool einfo$cont@3231(cenv cenv, ValRef nvref, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<Binding, Summary`1<ExprValueInfo>>, IncrementalOptimizationEnv> OptimizeBinding(cenv cenv, bool isRec, IncrementalOptimizationEnv env, Binding _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>, IncrementalOptimizationEnv> OptimizeBindings(cenv cenv, bool isRec, IncrementalOptimizationEnv env, FSharpList`1<Binding> xs);
    internal static ModuleOrNamespaceType elimModTy@3301(Set`2<Val, IComparer`1<Val>> deadSet, ModuleOrNamespaceType mtyp);
    internal static void elimModSpec@3309(Set`2<Val, IComparer`1<Val>> deadSet, Entity mspec);
    internal static ModuleOrNamespaceExpr elimModDef@3313(Set`2<Val, IComparer`1<Val>> deadSet, FSharpFunc`2<ModuleOrNamespaceBinding, FSharpOption`1<ModuleOrNamespaceBinding>> elimModuleBinding, ModuleOrNamespaceExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceExprWithSig, Lazy`1<ModuleInfo>> OptimizeModuleExpr(cenv cenv, IncrementalOptimizationEnv env, ModuleOrNamespaceExprWithSig x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<ModuleOrNamespaceExpr, Lazy`1<ModuleInfo>>, Tuple`2<IncrementalOptimizationEnv, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>>>> OptimizeModuleDef(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>> bindInfosColl, ModuleOrNamespaceExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<ModuleOrNamespaceBinding, FSharpChoice`2<Tuple`2<Binding, Summary`1<ExprValueInfo>>, Tuple`2<string, Lazy`1<ModuleInfo>>>>>, Tuple`2<IncrementalOptimizationEnv, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>>>> OptimizeModuleBindings(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>> bindInfosColl, FSharpList`1<ModuleOrNamespaceBinding> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<ModuleOrNamespaceBinding, FSharpChoice`2<Tuple`2<Binding, Summary`1<ExprValueInfo>>, Tuple`2<string, Lazy`1<ModuleInfo>>>>, Tuple`2<IncrementalOptimizationEnv, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>>>> OptimizeModuleBinding(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>> bindInfosColl, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpList`1<ModuleOrNamespaceExpr>, Lazy`1<ModuleInfo>>, Tuple`2<IncrementalOptimizationEnv, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>>>> OptimizeModuleDefs(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>> bindInfosColl, FSharpList`1<ModuleOrNamespaceExpr> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<IncrementalOptimizationEnv, TypedImplFile, Lazy`1<ModuleInfo>, SignatureHidingInfo> OptimizeImplFileInternal(cenv cenv, IncrementalOptimizationEnv env, bool isIncrementalFragment, SignatureHidingInfo hidden, TypedImplFile _arg5);
    internal static Tuple`2<Tuple`4<IncrementalOptimizationEnv, TypedImplFile, Lazy`1<ModuleInfo>, SignatureHidingInfo>, FSharpFunc`2<Expr, Expr>> OptimizeImplFile(OptimizationSettings settings, CcuThunk ccu, TcGlobals tcGlobals, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<range, Tuple`2<Expr, TType>>>>> tcVal, ImportMap importMap, IncrementalOptimizationEnv optEnv, bool isIncrementalFragment, bool emitTaicalls, SignatureHidingInfo hidden, TypedImplFile mimpls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ExprValueInfo(ExprValueInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ModuleInfo(ModuleInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_LazyModuleInfo(Lazy`1<ModuleInfo> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_CcuOptimizationInfo(Lazy`1<ModuleInfo> x, WriterState st);
    internal static ExprValueInfo loop@3480-89(ReaderState st);
    internal static ExprValueInfo u_ExprInfo(ReaderState st);
    internal static ValInfo u_ValInfo(ReaderState st);
    internal static ModuleInfo u_ModuleInfo(ReaderState st);
    internal static Lazy`1<ModuleInfo> u_LazyModuleInfo(ReaderState st);
    internal static Lazy`1<ModuleInfo> u_CcuOptimizationInfo(ReaderState st);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Parser : object {
    [DebuggerBrowsableAttribute("0")]
internal static T827053_28936Bytes@ field827054@;
    [DebuggerBrowsableAttribute("0")]
internal static T827055_652Bytes@ field827056@;
    [DebuggerBrowsableAttribute("0")]
internal static T827057_14480Bytes@ field827058@;
    [DebuggerBrowsableAttribute("0")]
internal static T827059_3662Bytes@ field827060@;
    [DebuggerBrowsableAttribute("0")]
internal static T827061_75064Bytes@ field827062@;
    [DebuggerBrowsableAttribute("0")]
internal static T827059_3662Bytes@ field827063@;
    [DebuggerBrowsableAttribute("0")]
internal static T827064_2128Bytes@ field827065@;
    [DebuggerBrowsableAttribute("0")]
internal static T827064_2128Bytes@ field827066@;
    [DebuggerBrowsableAttribute("0")]
internal static T827059_3662Bytes@ field827067@;
    internal static int _fsyacc_endOfInputTag { get; }
    internal static int _fsyacc_tagOfErrorTerminal { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_gotos { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_sparseGotoTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableRowOffsets { get; }
    internal static int _fsyacc_action_rows { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_reductionSymbolCounts { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_productionToNonTerminalTable { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_immediateActions { get; }
    private static Parser();
    internal static void debugPrint(a s);
    internal static SynExpr exprFromParseError(SynExpr e);
    internal static SynPat patFromParseError(SynPat e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynOptionalExpr(range m, FSharpOption`1<SynExpr> xopt);
    internal static FSharpList`1<Tuple`3<d, e, c>> run@46(c lastSep, d tupledArg0, e tupledArg1, FSharpList`1<Tuple`2<Tuple`2<d, e>, c>> l, FSharpList`1<Tuple`3<d, e, c>> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`3<a, b, c>> rebindRanges(a first_0, b first_1, FSharpList`1<Tuple`2<Tuple`2<a, b>, c>> fields, c lastSep);
    internal static Tuple`2<LongIdentWithDots, bool> mkUnderscoreRecdField(range m);
    internal static Tuple`2<a, bool> mkRecdField(a lidwd);
    internal static SynBinding mkSynDoBinding(FSharpOption`1<a> vis, bool strict, SynExpr expr, range m);
    internal static SynModuleDecl mkSynDoDecl(SynExpr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynPat addAttribs(FSharpList`1<SynAttributeList> attrs, SynPat p);
    internal static FSharpOption`1<FSharpFunc`2<ParseErrorContext`1<a>, Unit>> parse_error_rich();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void reportParseErrorAt(range m, int s_0, string s_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range unionRangeWithPos(range r, pos p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a raiseParseErrorAt(range m, int s_0, string s_1);
    internal static void checkEndOfFileError(LexerWhitespaceContinuation t);
    internal static SynMemberDefn mkClassMemberLocalBindings(bool isStatic, FSharpOption`1<range> initialRangeOpt, FSharpList`1<SynAttributeList> attrs, FSharpOption`1<SynAccess> vis, BindingSet _arg1);
    internal static SynExpr mkLocalBindings(range mWhole, BindingSet _arg1, SynExpr body);
    internal static FSharpList`1<SynModuleDecl> mkDefnBindings(range mWhole, BindingSet _arg1, FSharpList`1<SynAttributeList> attrs, FSharpOption`1<SynAccess> vis, range attrsm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Ident idOfPat(range m, SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> checkForMultipleAugmentations(range m, FSharpList`1<a> a1, FSharpList`1<a> a2);
    internal static PreXmlDoc grabXmlDoc(IParseState parseState, int elemIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range unionRangeWithListBy(FSharpFunc`2<a, range> projectRangeFromThing, range m, FSharpList`1<a> listOfThing);
    internal static range rangeOfNonNilAttrs(FSharpList`1<SynAttributeList> attrs);
    internal static range rangeOfLongIdent(FSharpList`1<Ident> lid);
    internal static int tagOfToken(token t);
    internal static tokenId tokenTagToTokenId(int tokenIdx);
    internal static nonTerminalId prodIdxToNonTerminal(int prodIdx);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_endOfInputTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_tagOfErrorTerminal();
    internal static string token_to_string(token t);
    internal static object _fsyacc_dataOfToken(token t);
    internal static UInt16[] get__fsyacc_gotos();
    internal static UInt16[] get__fsyacc_sparseGotoTableRowOffsets();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableElements();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableRowOffsets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_action_rows();
    internal static UInt16[] get__fsyacc_actionTableElements();
    internal static UInt16[] get__fsyacc_actionTableRowOffsets();
    internal static UInt16[] get__fsyacc_reductionSymbolCounts();
    internal static UInt16[] get__fsyacc_productionToNonTerminalTable();
    internal static UInt16[] get__fsyacc_immediateActions();
    internal static MemberKind getSetAdjuster@943(MemberKind getSet, SynValInfo arity);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynModuleDecl> _fsyacc_reductions$cont@1240(IParseState parseState, FSharpList`1<SynAttributeList> _1, FSharpOption`1<SynAccess> _2, FSharpChoice`2<FSharpList`1<Ident>, FSharpList`1<SynModuleDecl>> _5, FSharpOption`1<SynAccess> vis, FSharpList`1<Ident> path, bool isRec, Unit unitVar);
    internal static string go@1654-5(range mBindLhs, SynPat p);
    internal static FSharpList`1<SynArgInfo> adjustValueArg@1703(FSharpList`1<SynArgInfo> valueArg);
    internal static FSharpOption`1<SynAccess> mergeLidVisOuter@1747(range mBindLhs, FSharpOption`1<SynAccess> lidVisOuter, FSharpOption`1<SynAccess> lidVisInner);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynPat> args$cont@1763(range m, Ident id, FSharpList`1<SynPat> args, Unit unitVar);
    internal static SynPat go@1756-6(range mBindLhs, FSharpOption`1<SynAccess> lidVisOuter, LongIdentWithDots lidOuter, SynPat p);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynMemberDefn> _fsyacc_reductions$cont@1684-1(FSharpOption`1<SynReturnInfo> _3, range mWhole, FSharpFunc`2<Tuple`8<FSharpOption`1<SynAccess>, bool, bool, range, SequencePointInfoForBinding, FSharpOption`1<SynReturnInfo>, SynExpr, Tuple`4<range, FSharpList`1<Tuple`2<FSharpList`1<SynStaticOptimizationConstraint>, SynExpr>>, FSharpList`1<SynAttributeList>, FSharpOption`1<MemberFlags>>>, SynBinding> propertyNameBindingBuilder, FSharpFunc`2<MemberKind, MemberFlags> memFlagsBuilder, FSharpOption`1<SynReturnInfo> optReturnType, range exprm, SynExpr expr, FSharpFunc`2<Tuple`8<FSharpOption`1<SynAccess>, bool, bool, range, SequencePointInfoForBinding, FSharpOption`1<SynReturnInfo>, SynExpr, Tuple`4<range, FSharpList`1<Tuple`2<FSharpList`1<SynStaticOptimizationConstraint>, SynExpr>>, FSharpList`1<SynAttributeList>, FSharpOption`1<MemberFlags>>>, SynBinding> bindingBuilder, bool optInline, FSharpOption`1<SynAccess> vis, range mBindLhs, bool isInline, FSharpList`1<SynAttributeList> attrs, FSharpOption`1<MemberKind> memberKind, Unit unitVar);
    internal static MemberKind getSetAdjuster@1845-1(MemberKind getSet, SynValInfo arity);
    internal static FSharpFunc`2<FSharpList`1<SynAttributeList>, FSharpFunc`2<FSharpOption`1<SynAccess>, FSharpFunc`2<range, FSharpFunc`2<a, SynBinding>>>> attrLocalBindingBuilder@2594(FSharpList`1<SynAttributeList> _1, FSharpFunc`2<FSharpList`1<SynAttributeList>, FSharpFunc`2<FSharpOption`1<SynAccess>, FSharpFunc`2<range, SynBinding>>> localBindingBuilder);
    internal static FSharpFunc`2[] _fsyacc_reductions();
    internal static Tables`1<token> tables();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object engine(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf, int startState);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParsedSigFile signatureFile(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParsedImplFile implementationFile(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParsedFsiInteraction interaction(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr typedSeqExprEOF(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynType typEOF(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.PartialCheckResults : object {
    [DebuggerBrowsableAttribute("0")]
internal TcState TcState@;
    [DebuggerBrowsableAttribute("0")]
internal TcImports TcImports@;
    [DebuggerBrowsableAttribute("0")]
internal TcGlobals TcGlobals@;
    [DebuggerBrowsableAttribute("0")]
internal TcConfig TcConfig@;
    [DebuggerBrowsableAttribute("0")]
internal TcEnv TcEnvAtEnd@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2[]> TcErrorsRev@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<TcResolutions> TcResolutionsRev@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<TcSymbolUses> TcSymbolUsesRev@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<OpenDeclaration[]> TcOpenDeclarationsRev@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> ModuleNamesDict@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> TcDependencyFiles@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<TopAttribs> TopAttribs@;
    [DebuggerBrowsableAttribute("0")]
internal DateTime TimeStamp@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<TypedImplFile> LatestImplementationFile@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<ModuleOrNamespaceType> LastestCcuSigForFile@;
    [CompilationMappingAttribute("4", "0")]
internal TcState TcState { get; }
    [CompilationMappingAttribute("4", "1")]
internal TcImports TcImports { get; }
    [CompilationMappingAttribute("4", "2")]
internal TcGlobals TcGlobals { get; }
    [CompilationMappingAttribute("4", "3")]
internal TcConfig TcConfig { get; }
    [CompilationMappingAttribute("4", "4")]
internal TcEnv TcEnvAtEnd { get; }
    [CompilationMappingAttribute("4", "5")]
internal FSharpList`1<Tuple`2[]> TcErrorsRev { get; }
    [CompilationMappingAttribute("4", "6")]
internal FSharpList`1<TcResolutions> TcResolutionsRev { get; }
    [CompilationMappingAttribute("4", "7")]
internal FSharpList`1<TcSymbolUses> TcSymbolUsesRev { get; }
    [CompilationMappingAttribute("4", "8")]
internal FSharpList`1<OpenDeclaration[]> TcOpenDeclarationsRev { get; }
    [CompilationMappingAttribute("4", "9")]
internal FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> ModuleNamesDict { get; }
    [CompilationMappingAttribute("4", "10")]
internal FSharpList`1<string> TcDependencyFiles { get; }
    [CompilationMappingAttribute("4", "11")]
internal FSharpOption`1<TopAttribs> TopAttribs { get; }
    [CompilationMappingAttribute("4", "12")]
internal DateTime TimeStamp { get; }
    [CompilationMappingAttribute("4", "13")]
internal FSharpOption`1<TypedImplFile> LatestImplementationFile { get; }
    [CompilationMappingAttribute("4", "14")]
internal FSharpOption`1<ModuleOrNamespaceType> LastestCcuSigForFile { get; }
    internal Tuple`2[] TcErrors { get; }
    internal FSharpList`1<TcSymbolUses> TcSymbolUses { get; }
    internal PartialCheckResults(TcState tcState, TcImports tcImports, TcGlobals tcGlobals, TcConfig tcConfig, TcEnv tcEnvAtEnd, FSharpList`1<Tuple`2[]> tcErrorsRev, FSharpList`1<TcResolutions> tcResolutionsRev, FSharpList`1<TcSymbolUses> tcSymbolUsesRev, FSharpList`1<OpenDeclaration[]> tcOpenDeclarationsRev, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, FSharpList`1<string> tcDependencyFiles, FSharpOption`1<TopAttribs> topAttribs, DateTime timeStamp, FSharpOption`1<TypedImplFile> latestImplementationFile, FSharpOption`1<ModuleOrNamespaceType> lastestCcuSigForFile);
    internal TcState get_TcState();
    internal TcImports get_TcImports();
    internal TcGlobals get_TcGlobals();
    internal TcConfig get_TcConfig();
    internal TcEnv get_TcEnvAtEnd();
    internal FSharpList`1<Tuple`2[]> get_TcErrorsRev();
    internal FSharpList`1<TcResolutions> get_TcResolutionsRev();
    internal FSharpList`1<TcSymbolUses> get_TcSymbolUsesRev();
    internal FSharpList`1<OpenDeclaration[]> get_TcOpenDeclarationsRev();
    internal FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> get_ModuleNamesDict();
    internal FSharpList`1<string> get_TcDependencyFiles();
    internal FSharpOption`1<TopAttribs> get_TopAttribs();
    internal DateTime get_TimeStamp();
    internal FSharpOption`1<TypedImplFile> get_LatestImplementationFile();
    internal FSharpOption`1<ModuleOrNamespaceType> get_LastestCcuSigForFile();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal Tuple`2[] get_TcErrors();
    internal FSharpList`1<TcSymbolUses> get_TcSymbolUses();
    internal static PartialCheckResults Create(TypeCheckAccumulator tcAcc, DateTime timestamp);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.PartialLongName : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> QualifyingIdents@;
    [DebuggerBrowsableAttribute("0")]
internal string PartialIdent@;
    [DebuggerBrowsableAttribute("0")]
internal int EndColumn@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<int> LastDotPos@;
    [CompilationMappingAttribute("4", "0")]
public FSharpList`1<string> QualifyingIdents { get; }
    [CompilationMappingAttribute("4", "1")]
public string PartialIdent { get; }
    [CompilationMappingAttribute("4", "2")]
public int EndColumn { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<int> LastDotPos { get; }
    public PartialLongName(FSharpList`1<string> qualifyingIdents, string partialIdent, int endColumn, FSharpOption`1<int> lastDotPos);
    public FSharpList`1<string> get_QualifyingIdents();
    public string get_PartialIdent();
    public int get_EndColumn();
    public FSharpOption`1<int> get_LastDotPos();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PartialLongName obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static PartialLongName Empty(int endColumn);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PartialLongName obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.PatternMatchCompilation : object {
    internal static bool debug { get; }
    internal static string notNullText { get; }
    internal static string otherSubtypeText { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_debug();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> BindSubExprOfInput(TcGlobals g, ImportMap amap, FSharpList`1<Typar> gtps, PatternValBinding _arg2, range m, SubExprOfInput _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr GetSubExprOfInput(TcGlobals g, FSharpList`1<a> gtps, FSharpList`1<TType> tyargs, FSharpList`1<Tuple`2<Typar, TType>> tinst, SubExprOfInput _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool pathEq(Path p1, Path p2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notNullText();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_otherSubtypeText();
    internal static Const ilFieldToTastConst(ILFieldInit lit);
    internal static Tuple`2<Expr, bool> go@194-8(TcGlobals g, range m, Path path, FSharpFunc`2<TType, Tuple`2<Expr, bool>> tm);
    internal static Tuple`2<FSharpList`1<Expr>, bool> mkOneKnown@220(TcGlobals g, range m, FSharpFunc`2<TType, Tuple`2<Expr, bool>> tm, int n, FSharpList`1<TType> tys);
    internal static FSharpList`1<Expr> mkUnknowns@223(TcGlobals g, range m, FSharpList`1<TType> tys);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, bool> tm$cont@258-1(TcGlobals g, range m, TType ty, FSharpSet`1<Const> consts, FSharpOption`1<Const> c', Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, bool> tm$cont@232(TcGlobals g, range m, TType ty, FSharpList`1<DecisionTreeTest> rest, Const c, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, bool> RefuteDiscrimSet(TcGlobals g, range m, Path path, FSharpList`1<DecisionTreeTest> discrims);
    internal static string MaxStrings@332(string s1, string s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr CombineRefutations(TcGlobals g, Expr r1, Expr r2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<string, bool, bool>> ShowCounterExample(TcGlobals g, DisplayEnv denv, range m, FSharpList`1<RefutedSet> refuted);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isMemOfActives(Path p1, FSharpList`1<Active> actives);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SubExprOfInput, Pattern> lookupActive(Path x, FSharpList`1<Active> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Active> removeActive(Path x, FSharpList`1<Active> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<DecisionTreeTest> getDiscrimOfPattern(TcGlobals g, FSharpList`1<Tuple`2<Typar, TType>> tpinst, Pattern t);
    internal static Const constOfDiscrim(DecisionTreeTest discrim);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool discrimsEq(TcGlobals g, DecisionTreeTest d1, DecisionTreeTest d2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDiscrimSubsumedBy(TcGlobals g, ImportMap amap, range m, DecisionTreeTest d1, DecisionTreeTest d2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<a>, FSharpList`1<b>> chooseSimultaneousEdgeSet(FSharpOption`1<a> prevOpt, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<b, Tuple`2<FSharpOption`1<a>, c>>> f, FSharpList`1<b> l);
    internal static bool canCompactConstantClass(Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool discrimsHaveSameSimultaneousClass(TcGlobals g, DecisionTreeTest d1, DecisionTreeTest d2);
    internal static Active choose@498-4(FSharpList`1<Active> l);
    internal static Active ChooseInvestigationPointLeftToRight(FSharpList`1<Frontier> frontiers);
    internal static FSharpOption`1<Unit> |ConstNeedsDefaultCase|_|(Const c);
    internal static FSharpList`1<FSharpList`1<DecisionTreeCase>> compactify@627(FSharpOption`1<FSharpList`1<DecisionTreeCase>> curr, FSharpList`1<DecisionTreeCase> edges);
    [CompilerGeneratedAttribute]
internal static DecisionTree BuildSwitch$cont@561(TcGlobals g, Expr expr, FSharpList`1<DecisionTreeCase> edges, FSharpOption`1<DecisionTree> dflt, range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree BuildSwitch(FSharpOption`1<a> inpExprOpt, TcGlobals g, Expr expr, FSharpList`1<DecisionTreeCase> edges, FSharpOption`1<DecisionTree> dflt, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Frontier> mkFrontiers(FSharpList`1<Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>>> investigations, int i);
    internal static bool isPatternPartial(Pattern p);
    internal static Pattern erasePartialPatterns(Pattern inpp);
    internal static FSharpList`1<Pattern> erasePartials(FSharpList`1<Pattern> inps);
    internal static TypedMatchClause getIncompleteMatchClause@753(TcGlobals g, DisplayEnv denv, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, Val origInputVal, TType resultTy, MatchBuilder matchBuilder, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, FSharpList`1<RefutedSet> refuted);
    internal static TypedMatchClause GetClause@815(TcGlobals g, DisplayEnv denv, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, Val origInputVal, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, int i, FSharpList`1<RefutedSet> refuted);
    internal static DecisionTree InvestigateFrontiers@835(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, FSharpList`1<RefutedSet> refuted, FSharpList`1<Frontier> frontiers);
    internal static DecisionTree CompileSuccessPointAndGuard@879(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, int i, FSharpList`1<RefutedSet> refuted, ValMap`1<Expr> valMap, FSharpList`1<Frontier> rest);
    internal static Tuple`2<FSharpList`1<EdgeDiscrim>, FSharpList`1<Frontier>> ChooseSimultaneousEdges@911(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, FSharpList`1<Frontier> frontiers, Path path);
    internal static bool IsCopyableInputExpr@927(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, Expr origInputExpr);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpOption`1<Expr>, FSharpOption`1<Binding>> ChoosePreBinder$cont@996(TcGlobals g, FSharpList`1<Typar> origInputValTypars, Val origInputVal, SubExprOfInput subexpr, FSharpList`1<TType> resTys, range m, ActivePatternInfo apinfo, Expr activePatExpr, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, Unit unitVar);
    internal static Tuple`2<FSharpOption`1<Expr>, FSharpOption`1<Binding>> ChoosePreBinder@932(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, FSharpList`1<EdgeDiscrim> simulSetOfEdgeDiscrims, SubExprOfInput subexpr);
    internal static Tuple`2<FSharpList`1<DecisionTreeCase>, FSharpList`1<DecisionTreeTest>> CompileSimultaneousSet@1008(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, FSharpList`1<Frontier> frontiers, Path path, FSharpList`1<RefutedSet> refuted, SubExprOfInput subexpr, FSharpList`1<EdgeDiscrim> simulSetOfEdgeDiscrims, FSharpOption`1<Expr> inpExprOpt);
    internal static bool isRefuted@1078(TcGlobals g, ImportMap amap, range exprm, Path path, FSharpList`1<DecisionTreeTest> simulSetOfDiscrims, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, Frontier _arg5);
    internal static FSharpOption`1<DecisionTree> CompileFallThroughTree@1074(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, FSharpList`1<Frontier> fallthroughPathFrontiers, Path path, FSharpList`1<RefutedSet> refuted, FSharpList`1<DecisionTreeCase> simulSetOfCases);
    internal static FSharpList`1<Frontier> mkSubFrontiers@1109(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, ValMap`1<Expr> valMap, int i, Tuple`2<Expr, Val> ve, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, a path, FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<Expr, Expr>>> accessf', FSharpList`1<Active> active', FSharpList`1<Pattern> argpats, FSharpFunc`2<a, FSharpFunc`2<int, Path>> pathBuilder);
    internal static FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<a, Expr>>> accessf'@1127(TcGlobals g, range exprm, FSharpOption`1<Expr> inpExprOpt, FSharpList`1<TType> resTys, range m, int idx, int aparity);
    internal static FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<b, Expr>>> accessf'@1146-2(TcGlobals g, range exprm, FSharpOption`1<Expr> inpExprOpt, FSharpList`1<TType> resTys);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Frontier> GenerateNewFrontiersAfterSuccessfulInvestigation$cont@1123(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpOption`1<Expr> inpExprOpt, Frontier _arg1, Path path, int i', DecisionTreeTest discrim, ValMap`1<Expr> valMap, int i, Tuple`2<Expr, Val> ve, Pattern pat, FSharpList`1<Active> active', FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, Unit unitVar);
    internal static FSharpFunc`2<Frontier, FSharpList`1<Frontier>> GenerateNewFrontiersAfterSuccessfulInvestigation@1104(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, FSharpOption`1<Expr> inpExprOpt, FSharpOption`1<Expr> resPostBindOpt, InvestigationPoint _arg2);
    internal static Active mkSubActive@1243-1(Path path, Tuple`2<Expr, Val> ve, FSharpFunc`2<Path, FSharpFunc`2<a, Path>> pathBuilder, FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<Expr, Expr>>> accessf', a j, Pattern p');
    internal static FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<Expr, Expr>>> accessf'@1260-6(TcGlobals g, range exprm, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<Expr, Expr>> accessf, FSharpList`1<TType> tinst, RecdFieldRef fref);
    internal static FSharpList`1<Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>>> BindProjectionPattern@1241(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, Active _arg4, Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>> _arg3);
    internal static FSharpList`1<Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>>> BindProjectionPatterns@1286(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, TypedMatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> patternInput_0, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> patternInput_1, FSharpRef`1<FSharpOption`1<TypedMatchClause>> incompleteMatchClauseOnce, FSharpList`1<Active> ps, Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, FSharpList`1<DecisionTreeTarget>> CompilePatternBasic(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnUnused, bool warnOnIncomplete, ActionOnFailure actionOnFailure, Val origInputVal, FSharpList`1<Typar> origInputValTypars, FSharpOption`1<Expr> _origInputExprOpt, FSharpList`1<TypedMatchClause> clausesL, TType inputTy, TType resultTy);
    internal static bool isPartialOrWhenClause(TypedMatchClause c);
    internal static Tuple`2<DecisionTree, FSharpList`1<DecisionTreeTarget>> atMostOnePartialAtATime@1332(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> origInputExprOpt, TType inputTy, TType resultTy, FSharpList`1<TypedMatchClause> clauses);
    internal static Tuple`2<DecisionTree, FSharpList`1<DecisionTreeTarget>> doGroupWithAtMostOnePartial@1340(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> origInputExprOpt, TType inputTy, TType resultTy, FSharpList`1<TypedMatchClause> group, FSharpList`1<TypedMatchClause> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, FSharpList`1<DecisionTreeTarget>> CompilePattern(TcGlobals g, DisplayEnv denv, ImportMap amap, range exprm, range matchm, bool warnOnUnused, ActionOnFailure actionOnFailure, Val origInputVal, FSharpList`1<Typar> origInputValTypars, FSharpOption`1<Expr> origInputExprOpt, FSharpList`1<TypedMatchClause> clausesL, TType inputTy, TType resultTy);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.PostTypeCheckSemanticChecks : object {
    [CompilationMappingAttribute("9")]
internal static Limit NoLimit { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static env BindTypar(env env, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static env BindTypars(TcGlobals g, env env, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static env BindArgVals(env env, FSharpList`1<Val> vs);
    internal static Limit get_NoLimit();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CombineTwoLimits(Limit limit1, Limit limit2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsValLocal(env env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit GetLimitVal(cenv cenv, env env, range m, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit GetLimitValByRef(cenv cenv, env env, range m, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void BindVal(cenv cenv, env env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void RecordAnonRecdInfo(cenv cenv, AnonRecdTypeInfo anonInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeDeep(cenv cenv, FSharpFunc`2<TType, Unit> _arg1_0, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> _arg1_1, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> _arg1_2, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> _arg1_3, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> _arg1_4, TcGlobals g, env env, bool isInner, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypesDeep(cenv cenv, FSharpFunc`2<TType, Unit> f_0, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> f_1, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> f_2, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> f_3, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> f_4, TcGlobals g, env env, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypesDeepNoInner(cenv cenv, FSharpFunc`2<TType, Unit> f_0, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> f_1, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> f_2, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> f_3, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> f_4, TcGlobals g, env env, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeConstraintDeep(cenv cenv, FSharpFunc`2<TType, Unit> f_0, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> f_1, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> f_2, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> f_3, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> f_4, TcGlobals g, env env, TyparConstraint x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTraitInfoDeep(cenv cenv, FSharpFunc`2<TType, Unit> _arg3_0, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> _arg3_1, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> _arg3_2, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> _arg3_3, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> _arg3_4, TcGlobals g, env env, TraitConstraintInfo _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForByrefLikeType(cenv cenv, env env, range m, TType ty, FSharpFunc`2<Unit, Unit> check);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForByrefType(cenv cenv, env env, TType ty, FSharpFunc`2<Unit, Unit> check);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FreeVars> CheckEscapes$cont@418(cenv cenv, bool allowProtected, range m, FSharpList`1<Val> syntacticArgs, Expr body, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FreeVars> CheckEscapes(cenv cenv, bool allowProtected, range m, FSharpList`1<Val> syntacticArgs, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility AccessInternalsVisibleToAsInternal(CompilationPath thisCompPath, FSharpList`1<CompilationPath> internalsVisibleToPaths, Accessibility access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeForAccess(cenv cenv, env env, FSharpFunc`2<Unit, string> objName, Accessibility valAcc, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void WarnOnWrongTypeForAccess(cenv cenv, env env, FSharpFunc`2<Unit, string> objName, Accessibility valAcc, range m, TType ty);
    internal static PermitByRefExpr mkArgsPermit(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PermitByRefExpr> mkArgsForAppliedVal(bool isBaseCall, ValRef vref, FSharpList`1<a> argsl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PermitByRefExpr> mkArgsForAppliedExpr(bool isBaseCall, FSharpList`1<a> argsl, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeAux(PermitByRefType permitByRefLike, cenv cenv, env env, range m, TType ty, FSharpFunc`2<Unit, Unit> onInnerByrefError);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckType(PermitByRefType permitByRefLike, cenv cenv, env env, range m, TType ty);
    internal static Expr |OptionalCoerce|(Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckNoReraise(cenv cenv, FSharpOption`1<FreeVars> freesOpt, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpliceOperator(TcGlobals g, ValRef v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMultipleInterfaceInstantiations(cenv cenv, FSharpList`1<TType> interfaces, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValRef(cenv cenv, env env, ValRef v, range m, PermitByRefExpr context);
    [CompilerGeneratedAttribute]
internal static void CheckValUse$cont@719(env env, ValRef vref, ValUseFlag vFlags, range m, PermitByRefExpr context, TcGlobals g, Limit limit, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckValUse(cenv cenv, env env, ValRef vref, ValUseFlag vFlags, range m, PermitByRefExpr context);
    [CompilerGeneratedAttribute]
internal static void CheckForOverAppliedExceptionRaisingPrimitive$cont@788-2(TcGlobals g, FSharpList`1<Expr> argsl, range funcRange, ValRef failwithfFunc, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void CheckForOverAppliedExceptionRaisingPrimitive$cont@773-1(TcGlobals g, Expr f, FSharpList`1<Expr> argsl, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void CheckForOverAppliedExceptionRaisingPrimitive$cont@773(TcGlobals g, Expr f, FSharpList`1<Expr> argsl, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForOverAppliedExceptionRaisingPrimitive(cenv cenv, Expr expr);
    [CompilerGeneratedAttribute]
internal static void CheckCallLimitArgs$cont@818(env env, range m, Limit limitArgs, PermitByRefExpr context, bool isReturnLimitedByRef, bool isReturnLimitedSpanLike, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckCallLimitArgs(cenv cenv, env env, range m, TType returnTy, Limit limitArgs, PermitByRefExpr context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckCallWithReceiver(cenv cenv, env env, range m, TType returnTy, FSharpList`1<Expr> args, FSharpList`1<PermitByRefExpr> contexts, PermitByRefExpr context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprLinear(cenv cenv, env env, Expr expr, PermitByRefExpr context, FSharpFunc`2<Limit, Limit> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExpr(cenv cenv, env env, Expr origExpr, PermitByRefExpr context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMethods(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, FSharpList`1<ObjExprMethod> methods);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMethod(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, ObjExprMethod _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckInterfaceImpls(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckInterfaceImpl(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, TType _ty, FSharpList`1<ObjExprMethod> overrides);
    internal static void ctorLimitedZoneCheck@1137(env env, range m, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprOp(cenv cenv, env env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, range m, PermitByRefExpr context, Expr expr);
    [CompilerGeneratedAttribute]
internal static int projection@1-1(TcGlobals g, TyparConstraint _arg8);
    [CompilerGeneratedAttribute]
internal static void CheckLambdas$cont@1483(bool isTop, cenv cenv, TcGlobals g, range m, FSharpList`1<Typar> tps, TType bodyty, env env, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckLambdas(bool isTop, FSharpOption`1<ValMemberInfo> memInfo, cenv cenv, env env, bool inlined, ValReprInfo topValInfo, bool alwaysCheckNoReraise, Expr e, range mOrig, TType ety, PermitByRefExpr context);
    internal static PermitByRefExpr argArity@1518(PermitByRefExpr[] contexts, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprs(cenv cenv, env env, FSharpList`1<Expr> exprs, FSharpList`1<PermitByRefExpr> contexts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprsNoByRefLike(cenv cenv, env env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprsPermitByRefLike(cenv cenv, env env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprPermitByRefLike(cenv cenv, env env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprPermitReturnableByRef(cenv cenv, env env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckDecisionTreeTargets(cenv cenv, env env, DecisionTreeTarget[] targets, PermitByRefExpr context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckDecisionTreeTarget(cenv cenv, env env, PermitByRefExpr context, DecisionTreeTarget _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTree(cenv cenv, env env, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTreeSwitch(cenv cenv, env env, Expr e, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> dflt, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTreeTest(cenv cenv, env env, range m, DecisionTreeTest discrim);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAttrib(cenv cenv, env env, Attrib _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAttribExpr(cenv cenv, env env, AttribExpr _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAttribArgExpr(cenv cenv, env env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAttribs(cenv cenv, env env, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValInfo(cenv cenv, env env, ValReprInfo _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckArgInfo(cenv cenv, env env, ArgReprInfo argInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValSpecAux(PermitByRefType permitByRefLike, cenv cenv, env env, Val v, FSharpFunc`2<Unit, Unit> onInnerByrefError);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValSpec(PermitByRefType permitByRefLike, cenv cenv, env env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility AdjustAccess(bool isHidden, FSharpFunc`2<Unit, CompilationPath> cpath, Accessibility access);
    [CompilerGeneratedAttribute]
internal static void CheckBinding$cont@1731(cenv cenv, Val v, Expr bindRhs, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckBinding(cenv cenv, env env, bool alwaysCheckNoReraise, PermitByRefExpr context, Binding _arg6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckBindings(cenv cenv, env env, FSharpList`1<Binding> xs);
    [CompilerGeneratedAttribute]
internal static void check$cont@1842(Val v, EntityRef tcref, string kind, string nm, Unit unitVar);
    internal static void check@1824-5(Val v, EntityRef tcref, bool hasDefaultAugmentation, string kind, bool skipValCheck, string nm);
    [CompilerGeneratedAttribute]
internal static void CheckModuleBinding$cont@1816(cenv cenv, Val v, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckModuleBinding(cenv cenv, env env, Binding _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckRecdField(bool isUnion, cenv cenv, env env, Entity tycon, RecdField rfield);
    [CompilerGeneratedAttribute]
internal static bool contains@1-2(a e, FSharpList`1<a> xs1);
    internal static bool methodUniquenessIncludesReturnType@1967(FSharpList`1<string> namesOfMethodsThatMayDifferOnlyInReturnType, MethInfo minfo);
    internal static bool MethInfosEquivWrtUniqueness@1968(cenv cenv, TcGlobals g, FSharpList`1<string> namesOfMethodsThatMayDifferOnlyInReturnType, Erasure eraseFlag, range m, MethInfo minfo, MethInfo minfo2);
    internal static FSharpList`1<a> getHash@1979(Dictionary`2<string, FSharpList`1<a>> hash, string nm);
    internal static FSharpList`1<MethInfo> getOtherMethods@1994(Dictionary`2<string, FSharpList`1<MethInfo>> hashOfImmediateMeths, MethInfo minfo);
    internal static bool IsAbstractDefaultPair2@2012(MethInfo minfo, MethInfo minfo2);
    internal static FSharpFunc`2<MethInfo, bool> checkForDup@2014(cenv cenv, TcGlobals g, FSharpList`1<string> namesOfMethodsThatMayDifferOnlyInReturnType, MethInfo minfo, range m, Erasure erasureFlag);
    internal static FSharpFunc`2<PropInfo, bool> checkForDup@2077-2(cenv cenv, TcGlobals g, PropInfo pinfo, range m, Erasure erasureFlag);
    internal static FSharpFunc`2<MethInfo, bool> checkForDup@2124-4(cenv cenv, TcGlobals g, MethInfo minfo, range m, Erasure erasureFlag);
    internal static FSharpFunc`2<MethInfo, bool> checkForDup@2139-6(cenv cenv, TcGlobals g, MethInfo minfo, range m, Erasure erasureFlag);
    [CompilerGeneratedAttribute]
internal static void CheckEntityDefn$cont@2114-1(cenv cenv, TcGlobals g, range m, FSharpList`1<MethInfo> allVirtualMethsInParent, FSharpList`1<MethInfo> immediateMeths, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void CheckEntityDefn$cont@1959(cenv cenv, Entity tycon, TcGlobals g, range m, TType ty, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void action@1-12(cenv cenv, Entity tycon, env env, UnionCase uc);
    internal static void visitType@2182-3(cenv cenv, Entity tycon, env env, Accessibility access, TType ty);
    [CompilerGeneratedAttribute]
internal static void CheckEntityDefn$cont@2214-2(cenv cenv, Entity tycon, TcGlobals g, range m, TType ty, env env, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckEntityDefn(cenv cenv, env env, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckModuleExpr(cenv cenv, env env, ModuleOrNamespaceExprWithSig x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckNothingAfterEntryPoint(cenv cenv, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDefnInModule(cenv cenv, env env, ModuleOrNamespaceExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckModuleSpec(cenv cenv, env env, ModuleOrNamespaceBinding x);
    internal static void resolve@2312(FSharpOption`1<EntityRef> _arg1);
    internal static Tuple`2<bool, FSharpMap`2<long, AnonRecdTypeInfo>> CheckTopImpl(TcGlobals g, ImportMap amap, bool reportErrors, InfoReader infoReader, FSharpList`1<CompilationPath> internalsVisibleToPaths, CcuThunk viewCcu, DisplayEnv denv, ModuleOrNamespaceExprWithSig mexpr, FSharpList`1<Attrib> extraAttribs, Tuple`2<bool, bool> isLastCompiland, bool isInternalTestSpanStackReferring);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.PPLexer : object {
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827069@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827070@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827071@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827072@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827073@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827074@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827075@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827076@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827077@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827078@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827079@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827080@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827081@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827082@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827083@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827084@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827085@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827086@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827087@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827088@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827089@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827090@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827091@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827092@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827093@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827094@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827095@;
    [DebuggerBrowsableAttribute("0")]
internal static T827068_318Bytes@ field827096@;
    [DebuggerBrowsableAttribute("0")]
internal static T827097_56Bytes@ field827098@;
    [CompilationMappingAttribute("9")]
internal static UInt16[][] trans { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] actions { get; }
    [CompilationMappingAttribute("9")]
internal static UnicodeTables _fslex_tables { get; }
    private static PPLexer();
    internal static string lexeme(LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token fail(lexargs args, LexBuffer`1<char> lexbuf, int e_0, string e_1);
    internal static UInt16[][] get_trans();
    internal static UInt16[] get_actions();
    internal static UnicodeTables get__fslex_tables();
    internal static a _fslex_dummy();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token tokenstream(lexargs args, LexBuffer`1<char> lexbuf);
    internal static void rest(LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.PPParser : object {
    [DebuggerBrowsableAttribute("0")]
internal static T827038_92Bytes@ field827039@;
    [DebuggerBrowsableAttribute("0")]
internal static T827040_10Bytes@ field827041@;
    [DebuggerBrowsableAttribute("0")]
internal static T827042_168Bytes@ field827043@;
    [DebuggerBrowsableAttribute("0")]
internal static T827044_62Bytes@ field827045@;
    [DebuggerBrowsableAttribute("0")]
internal static T827046_344Bytes@ field827047@;
    [DebuggerBrowsableAttribute("0")]
internal static T827044_62Bytes@ field827048@;
    [DebuggerBrowsableAttribute("0")]
internal static T827049_38Bytes@ field827050@;
    [DebuggerBrowsableAttribute("0")]
internal static T827049_38Bytes@ field827051@;
    [DebuggerBrowsableAttribute("0")]
internal static T827044_62Bytes@ field827052@;
    [CompilationMappingAttribute("9")]
internal static LexerIfdefExpression dummy { get; }
    internal static int _fsyacc_endOfInputTag { get; }
    internal static int _fsyacc_tagOfErrorTerminal { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_gotos { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_sparseGotoTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableRowOffsets { get; }
    internal static int _fsyacc_action_rows { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_reductionSymbolCounts { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_productionToNonTerminalTable { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_immediateActions { get; }
    private static PPParser();
    internal static LexerIfdefExpression get_dummy();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b doNothing(a _arg1, b dflt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LexerIfdefExpression fail(IParseState ps, int i, int e_0, string e_1);
    internal static int tagOfToken(token t);
    internal static tokenId tokenTagToTokenId(int tokenIdx);
    internal static nonTerminalId prodIdxToNonTerminal(int prodIdx);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_endOfInputTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_tagOfErrorTerminal();
    internal static string token_to_string(token t);
    internal static object _fsyacc_dataOfToken(token t);
    internal static UInt16[] get__fsyacc_gotos();
    internal static UInt16[] get__fsyacc_sparseGotoTableRowOffsets();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableElements();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableRowOffsets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_action_rows();
    internal static UInt16[] get__fsyacc_actionTableElements();
    internal static UInt16[] get__fsyacc_actionTableRowOffsets();
    internal static UInt16[] get__fsyacc_reductionSymbolCounts();
    internal static UInt16[] get__fsyacc_productionToNonTerminalTable();
    internal static UInt16[] get__fsyacc_immediateActions();
    internal static FSharpFunc`2[] _fsyacc_reductions();
    internal static Tables`1<token> tables();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object engine(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf, int startState);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LexerIfdefExpression start(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.PrettyNaming : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string parenGet;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string parenSet;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string qmark;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string qmarkSet;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string opNamePrefix;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string compilerGeneratedMarker;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static char compilerGeneratedMarkerChar;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static char mangledGenericTypeNameSym;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string FSharpModuleSuffix;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string MangledGlobalName;
    [DebuggerBrowsableAttribute("0")]
internal static T826940_22Bytes@ field826941@;
    [CompilationMappingAttribute("9")]
internal static Tuple`2[] opNameTable { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2[] opCharTranslateTable { get; }
    [CompilationMappingAttribute("9")]
internal static HashSet`1<char> opCharSet { get; }
    [CompilationMappingAttribute("9")]
internal static HashSet`1<char> t@121-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> compileCustomOpName { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<char, string> t2@151 { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<char, string> t2@152-1 { get; }
    [CompilationMappingAttribute("9")]
internal static int maxOperatorNameLength@158 { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<char, string> accv@1 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static int acc@1 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<char, string> x@1 { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, string> compiledOperators@166 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, string> CompileOpName { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, string> standardOpNames@192 { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, string> opNames@193 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> decompileCustomOpName { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, string> decompiledOperators@214 { get; }
    [CompilationMappingAttribute("9")]
internal static int minOperatorNameLength@218 { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<char, string> accv@1-1 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static int acc@1-1 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<char, string> x@1-1 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, string> DecompileOpName { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, string> standardOps@281 { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, string> ops@282 { get; }
    [CompilationMappingAttribute("9")]
public static string opNameCons { get; }
    [CompilationMappingAttribute("9")]
public static string opNameNil { get; }
    [CompilationMappingAttribute("9")]
public static string opNameEquals { get; }
    [CompilationMappingAttribute("9")]
public static string opNameEqualsNullable { get; }
    [CompilationMappingAttribute("9")]
public static string opNameNullableEquals { get; }
    [CompilationMappingAttribute("9")]
public static string opNameNullableEqualsNullable { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, bool> IsInfixOperator { get; }
    [CompilationMappingAttribute("9")]
internal static String[] relational@404 { get; }
    [CompilationMappingAttribute("9")]
internal static String[] concat@407-1 { get; }
    [CompilationMappingAttribute("9")]
internal static String[] plusMinus@410 { get; }
    [CompilationMappingAttribute("9")]
internal static String[] otherMath@413 { get; }
    [CompilationMappingAttribute("9")]
internal static Char[] ignoredChars@417 { get; }
    [CompilationMappingAttribute("9")]
public static Char[] IllegalCharactersInTypeAndNamespaceNames { get; }
    public static string outArgCompilerGeneratedName { get; }
    private static PrettyNaming();
    internal static Tuple`2[] get_opNameTable();
    internal static Tuple`2[] get_opCharTranslateTable();
    internal static HashSet`1<char> get_opCharSet();
    internal static HashSet`1<char> get_t@121-1();
    internal static bool loop@130-37(string name, int nameLen, int i);
    public static bool IsOperatorOrBacktickedName(string name);
    public static bool IsOperatorName(string name);
    public static bool IsMangledOpName(string n);
    internal static FSharpFunc`2<string, string> get_compileCustomOpName();
    internal static Dictionary`2<char, string> get_t2@151();
    internal static Dictionary`2<char, string> get_t2@152-1();
    internal static int get_maxOperatorNameLength@158();
    internal static Tuple`2<char, string> get_accv@1();
    internal static void set_accv@1(Tuple`2<char, string> value);
    internal static int get_acc@1();
    internal static void set_acc@1(int value);
    internal static Tuple`2<char, string> get_x@1();
    internal static ConcurrentDictionary`2<string, string> get_compiledOperators@166();
    public static FSharpFunc`2<string, string> get_CompileOpName();
    internal static Dictionary`2<string, string> get_standardOpNames@192();
    internal static Dictionary`2<string, string> get_opNames@193();
    internal static FSharpFunc`2<string, string> get_decompileCustomOpName();
    internal static ConcurrentDictionary`2<string, string> get_decompiledOperators@214();
    internal static int get_minOperatorNameLength@218();
    internal static Tuple`2<char, string> get_accv@1-1();
    internal static void set_accv@1-1(Tuple`2<char, string> value);
    internal static int get_acc@1-1();
    internal static void set_acc@1-1(int value);
    internal static Tuple`2<char, string> get_x@1-1();
    internal static string decompile@234(string opName, int opNameLen, StringBuilder sb, int idx);
    public static FSharpFunc`2<string, string> get_DecompileOpName();
    internal static Dictionary`2<string, string> get_standardOps@281();
    internal static Dictionary`2<string, string> get_ops@282();
    public static string DemangleOperatorName(string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout DemangleOperatorNameAsLayout(FSharpFunc`2<string, a> nonOpTagged, string nm);
    public static string get_opNameCons();
    public static string get_opNameNil();
    public static string get_opNameEquals();
    public static string get_opNameEqualsNullable();
    public static string get_opNameNullableEquals();
    public static string get_opNameNullableEqualsNullable();
    public static bool IsIdentifierFirstCharacter(char c);
    public static bool IsIdentifierPartCharacter(char c);
    public static bool IsLongIdentifierPartCharacter(char c);
    public static bool IsValidPrefixOperatorUse(string s);
    public static bool IsValidPrefixOperatorDefinitionName(string s);
    [CompilerGeneratedAttribute]
internal static bool IsPrefixOperator$cont@376(string s, Unit unitVar);
    public static bool IsPrefixOperator(string s);
    [CompilerGeneratedAttribute]
internal static bool IsPunctuation$cont@387(string s, Unit unitVar);
    public static bool IsPunctuation(string s);
    public static bool IsTernaryOperator(string s);
    public static FSharpFunc`2<string, bool> get_IsInfixOperator();
    internal static String[] get_relational@404();
    internal static String[] get_concat@407-1();
    internal static String[] get_plusMinus@410();
    internal static String[] get_otherMath@413();
    internal static Char[] get_ignoredChars@417();
    public static FSharpChoice`6<Unit, Unit, Unit, Unit, Unit, Unit> |Control|Equality|Relational|Indexer|FixedTypes|Other|(string opName);
    public static bool IsCompilerGeneratedName(string nm);
    public static string CompilerGeneratedName(string nm);
    public static string GetBasicNameOfPossibleCompilerGeneratedName(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string CompilerGeneratedNameSuffix(string basicName, string suffix);
    public static FSharpValueOption`1<int> TryDemangleGenericNameAndPos(string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NameArityPair DecodeGenericTypeName(int pos, string mangledName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string DemangleGenericTypeNameWithPos(int pos, string mangledName);
    public static string DemangleGenericTypeName(string mangledName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string chopStringTo(string s, char c);
    public static FSharpOption`1<string> TryChopPropertyName(string s);
    public static string ChopPropertyName(string s);
    public static FSharpList`1<string> SplitNamesForILPath(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNotQuotedQuotation(string text, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] splitAroundQuotation(string text, char separator);
    [CompilerGeneratedAttribute]
internal static String[] splitAroundQuotationWithCount$cont@581(char separator, int count, String[] mangledText, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] splitAroundQuotationWithCount(string text, char separator, int count);
    public static Char[] get_IllegalCharactersInTypeAndNamespaceNames();
    public static bool IsActivePatternName(string nm);
    internal static FSharpList`1<Tuple`2<string, range>> loop@627-38(string nm, range mp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<ActivePatternInfo> ActivePatternInfoOfValName(string nm, range m);
    internal static string mangleStaticStringArg(string nm, string v);
    internal static FSharpOption`1<Tuple`2<string, string>> tryDemangleStaticStringArg(string mangledText);
    [CompilerGeneratedAttribute]
internal static Tuple`2<string, Tuple`2[]> demangleProvidedTypeName$cont@663(string typeLogicalName, Unit unitVar);
    public static Tuple`2<string, Tuple`2[]> demangleProvidedTypeName(string typeLogicalName);
    public static string mangleProvidedTypeName(string typeLogicalName, Tuple`2[] nonDefaultArgs);
    public static string computeMangledNameWithoutDefaultArgValues(string nm, Object[] staticArgs, Tuple`2[] defaultArgValues);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_outArgCompilerGeneratedName();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.QuickParse : object {
    public static int MagicalAdjustmentConstant { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<String[]> expected { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_MagicalAdjustmentConstant();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int CorrectIdentifierToken(string tokenText, int tokenTag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isValidStrippedName(string name, int idx);
    internal static bool isValidActivePatternName(string name);
    internal static FSharpOption`1<char> |Char|_|@81(string lineStr, int p);
    internal static FSharpOption`1<Unit> |IsLongIdentifierPartChar|_|@82(char c);
    internal static FSharpOption`1<Unit> |IsIdentifierPartChar|_|@83(char c);
    internal static int searchLeft@85(string lineStr, int p);
    internal static int searchRight@92(string lineStr, int p);
    internal static FSharpOption`1<Tuple`2<int, int>> walkOutsideBackticks@100(string lineStr, int index, int i);
    internal static FSharpOption`1<Tuple`2<int, int>> walkInsideBackticks@113(string lineStr, int index, int i, int start);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<string, int, bool>> GetCompleteIdentifierIslandImpl(string lineStr, int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Tuple`3<string, int, bool>> GetCompleteIdentifierIsland(bool tolerateJustAfter, string tokenText, int index);
    internal static Tuple`2<FSharpList`1<string>, a> PushName@189(string lineStr, int right, int pos, a residue, FSharpList`1<string> prior, Unit unitVar0);
    internal static Tuple`2<FSharpList`1<string>, a> InLeadingIdentifier@188(string lineStr, int tupledArg0, int tupledArg1, Tuple`2<FSharpList`1<string>, a> tupledArg2);
    internal static Tuple`2<FSharpList`1<string>, string> NameAndResidue@196(string lineStr, int startResidue, int right, int pos, Unit unitVar0);
    internal static Tuple`2<FSharpList`1<string>, string> InName@195(string lineStr, int tupledArg0, int tupledArg1, int tupledArg2);
    internal static Tuple`2<FSharpList`1<string>, string> InResidue@203(string lineStr, int tupledArg0, int tupledArg1);
    public static Tuple`2<FSharpList`1<string>, string> GetPartialLongName(string lineStr, int index);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@212-80(EatCommentCallContext this, EatCommentCallContext obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@212-81(IComparer comp, EatCommentCallContext this, EatCommentCallContext objTemp, Unit unitVar);
    internal static bool IsEndOfComment@227(string lineStr, int index, int pos);
    internal static bool IsStartOfComment@228(string lineStr, int index, int pos);
    internal static PartialLongName SkipWhitespaceBeforeDotIdentifier@231(string lineStr, int index, int tupledArg0, string tupledArg1, FSharpList`1<string> tupledArg2, bool tupledArg3, FSharpOption`1<int> tupledArg4);
    internal static PartialLongName EatComment@238(string lineStr, int index, int tupledArg0, int tupledArg1, EatCommentCallContext tupledArg2, FSharpOption`1<int> tupledArg3);
    internal static PartialLongName InUnquotedIdentifier@259(string lineStr, int index, int tupledArg0, int tupledArg1, FSharpList`1<string> tupledArg2, bool tupledArg3, FSharpOption`1<int> tupledArg4);
    internal static PartialLongName InQuotedIdentifier@278(string lineStr, int index, int tupledArg0, int tupledArg1, FSharpList`1<string> tupledArg2, bool tupledArg3, FSharpOption`1<int> tupledArg4);
    internal static PartialLongName AtStartOfIdentifier@294(string lineStr, int index, int tupledArg0, FSharpList`1<string> tupledArg1, bool tupledArg2, FSharpOption`1<int> tupledArg3);
    [CompilerGeneratedAttribute]
internal static PartialLongName GetPartialLongNameEx$cont@220(string lineStr, int index, Unit unitVar);
    public static PartialLongName GetPartialLongNameEx(string lineStr, int index);
    internal static FSharpList`1<String[]> get_expected();
    public static bool TestMemberOrOverrideDeclaration(FSharpTokenInfo[] tokens);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.QuotationPickler : object {
    internal static string SerializedReflectedDefinitionsResourceNameBase { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ExprData, Byte[]> pickle { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Tuple`2<MethodBaseData, ExprData>>, Byte[]> PickleDefns { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b mkRLinear(FSharpFunc`2<Tuple`2<a, b>, b> mk, FSharpList`1<a> vs, b body);
    internal static TypeData mkVarTy(int v);
    internal static TypeData mkFunTy(Tuple`2<TypeData, TypeData> tupledArg);
    internal static TypeData mkArrayTy(Tuple`2<int, TypeData> tupledArg);
    internal static TypeData mkILNamedTy(Tuple`2<NamedTypeData, FSharpList`1<TypeData>> tupledArg);
    internal static ExprData mkVar(int v);
    internal static ExprData mkHole(TypeData v, int idx);
    internal static ExprData mkApp(ExprData a, ExprData b);
    internal static ExprData mkLambda(VarData a, ExprData b);
    internal static ExprData mkQuote(ExprData a);
    internal static ExprData mkQuoteRaw40(ExprData a);
    internal static ExprData mkCond(ExprData x1, ExprData x2, ExprData x3);
    internal static ExprData mkModuleValueApp(NamedTypeData tcref, string nm, bool isProp, FSharpList`1<TypeData> tyargs, FSharpList`1<FSharpList`1<ExprData>> args);
    internal static ExprData mkTuple(TypeData ty, FSharpList`1<ExprData> x);
    internal static ExprData mkLet(Tuple`2<VarData, ExprData> _arg1, ExprData b);
    internal static ExprData mkUnit();
    internal static ExprData mkNull(TypeData ty);
    internal static ExprData mkLetRecRaw(ExprData e1);
    internal static ExprData mkLetRec(FSharpList`1<Tuple`2<VarData, ExprData>> ves, ExprData body);
    internal static ExprData mkRecdMk(NamedTypeData n, FSharpList`1<TypeData> tys, FSharpList`1<ExprData> args);
    internal static ExprData mkRecdGet(Tuple`2<NamedTypeData, string> _arg1, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkRecdSet(Tuple`2<NamedTypeData, string> _arg1, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkUnion(Tuple`2<NamedTypeData, string> _arg1, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkUnionFieldGet(Tuple`3<NamedTypeData, string, int> _arg1, FSharpList`1<TypeData> tyargs, ExprData arg);
    internal static ExprData mkUnionCaseTagTest(Tuple`2<NamedTypeData, string> _arg1, FSharpList`1<TypeData> tyargs, ExprData arg);
    internal static ExprData mkTupleGet(TypeData ty, int n, ExprData e);
    internal static ExprData mkCoerce(TypeData ty, ExprData arg);
    internal static ExprData mkTypeTest(TypeData ty, ExprData arg);
    internal static ExprData mkAddressOf(ExprData arg);
    internal static ExprData mkAddressSet(ExprData arg1, ExprData arg2);
    internal static ExprData mkVarSet(ExprData arg1, ExprData arg2);
    internal static ExprData mkDefaultValue(TypeData ty);
    internal static ExprData mkThisVar(TypeData ty);
    internal static ExprData mkNewArray(TypeData ty, FSharpList`1<ExprData> args);
    internal static ExprData mkBool(bool v, TypeData ty);
    internal static ExprData mkString(string v, TypeData ty);
    internal static ExprData mkSingle(float v, TypeData ty);
    internal static ExprData mkDouble(double v, TypeData ty);
    internal static ExprData mkChar(char v, TypeData ty);
    internal static ExprData mkSByte(sbyte v, TypeData ty);
    internal static ExprData mkByte(byte v, TypeData ty);
    internal static ExprData mkInt16(short v, TypeData ty);
    internal static ExprData mkUInt16(ushort v, TypeData ty);
    internal static ExprData mkInt32(int v, TypeData ty);
    internal static ExprData mkUInt32(UInt32 v, TypeData ty);
    internal static ExprData mkInt64(long v, TypeData ty);
    internal static ExprData mkUInt64(ulong v, TypeData ty);
    internal static ExprData mkSequential(ExprData e1, ExprData e2);
    internal static ExprData mkForLoop(ExprData x1, ExprData x2, ExprData x3);
    internal static ExprData mkWhileLoop(ExprData e1, ExprData e2);
    internal static ExprData mkTryFinally(ExprData e1, ExprData e2);
    internal static ExprData mkTryWith(ExprData e1, VarData vf, ExprData ef, VarData vh, ExprData eh);
    internal static ExprData mkDelegate(TypeData ty, ExprData e);
    internal static ExprData mkPropGet(Tuple`4<NamedTypeData, string, TypeData, FSharpList`1<TypeData>> d, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkPropSet(Tuple`4<NamedTypeData, string, TypeData, FSharpList`1<TypeData>> d, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkFieldGet(Tuple`2<NamedTypeData, string> _arg1, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkFieldSet(Tuple`2<NamedTypeData, string> _arg1, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkCtorCall(CtorData d, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkMethodCall(MethodData d, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkAttributedExpression(ExprData e, ExprData attr);
    internal static bool isAttributedExpression(ExprData e);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_SerializedReflectedDefinitionsResourceNameBase();
    internal static VarData freshVar(string n, TypeData ty, bool mut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_NamedType(NamedTypeData x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tycon(TypeCombOp x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_type(TypeData x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_types(FSharpList`1<TypeData> x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_varDecl(VarData v, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_recdFieldSpec(NamedTypeData v_0, string v_1, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ucaseSpec(NamedTypeData v_0, string v_1, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_MethodData(MethodData a, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_CtorData(CtorData a, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_PropInfoData(NamedTypeData a_0, string a_1, TypeData a_2, FSharpList`1<TypeData> a_3, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_CombOp(CombOp x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_expr(ExprData x, QuotationPickleOutState st);
    internal static FSharpFunc`2<ExprData, Byte[]> get_pickle();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_MethodBase(MethodBaseData x, QuotationPickleOutState st);
    internal static FSharpFunc`2<FSharpList`1<Tuple`2<MethodBaseData, ExprData>>, Byte[]> get_PickleDefns();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.QuotationTranslator : object {
    [CompilationMappingAttribute("9")]
internal static bool verboseCReflect { get; }
    internal static bool get_verboseCReflect();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QuotationTranslationEnv BindFormalTypars(QuotationTranslationEnv env, FSharpList`1<Typar> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QuotationTranslationEnv BindVal(QuotationTranslationEnv env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QuotationTranslationEnv BindIsInstVal(QuotationTranslationEnv env, Val v, TType ty, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QuotationTranslationEnv BindSubstVal(QuotationTranslationEnv env, Val v, Expr e);
    internal static FSharpOption`1<Tuple`6<ValRef, ValUseFlag, Expr, TType, FSharpList`1<TType>, FSharpList`1<Expr>>> loop@132-72(TcGlobals g, Expr expr, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`6<ValRef, ValUseFlag, Expr, TType, FSharpList`1<TType>, FSharpList`1<Expr>>> |ModuleValueOrMemberUse|_|(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Unit> |SimpleArrayLoopUpperBound|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<Expr, TType, Expr>> |SimpleArrayLoopBody|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Unit> |ObjectInitializationCheck|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSplice(TcGlobals g, ValRef vref);
    internal static Expr mk_tuple@184(TcGlobals g, range m, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData EmitDebugInfoIfNecessary(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, ExprData astExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvExprCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvLdfld(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, ILFieldSpec fspec, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvUnionFieldGet(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, UnionCaseRef ucref, int n, FSharpList`1<TType> tyargs, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvClassOrRecdFieldGet(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, RecdFieldRef rfref, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvClassOrRecdFieldGetCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, RecdFieldRef rfref, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<Tuple`2<VarData, ExprData>>, QuotationTranslationEnv> ConvLetBind(QuotationGenerationScope cenv, QuotationTranslationEnv env, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ExprData> ConvLValueArgs(QuotationGenerationScope cenv, QuotationTranslationEnv env, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvLValueExpr(QuotationGenerationScope cenv, QuotationTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvLValueExprCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvObjectModelCall(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, bool callInfo_0, bool callInfo_1, bool callInfo_2, NamedTypeData callInfo_3, FSharpList`1<TypeData> callInfo_4, TypeData callInfo_5, string callInfo_6, FSharpList`1<TType> callInfo_7, int callInfo_8, FSharpList`1<Expr> callInfo_9);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvObjectModelCallCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, bool isPropGet, bool isPropSet, bool isNewObj, NamedTypeData parentTyconR, FSharpList`1<TypeData> methArgTypesR, TypeData methRetTypeR, string methName, FSharpList`1<TType> tyargs, int numGenericArgs, FSharpList`1<Expr> callArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvModuleValueApp(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, ValRef vref, FSharpList`1<TType> tyargs, FSharpList`1<FSharpList`1<Expr>> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvModuleValueAppCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, ValRef vref, FSharpList`1<TType> tyargs, FSharpList`1<FSharpList`1<Expr>> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ExprData> ConvExprs(QuotationGenerationScope cenv, QuotationTranslationEnv env, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvValRef(bool holeOk, QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, ValRef vref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvValRefCore(bool holeOk, QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, ValRef vref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<NamedTypeData, string> ConvUnionCaseRef(QuotationGenerationScope cenv, UnionCaseRef ucref, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<NamedTypeData, string> ConvRecdFieldRef(QuotationGenerationScope cenv, RecdFieldRef rfref, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static VarData ConvVal(QuotationGenerationScope cenv, QuotationTranslationEnv env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ConvTyparRef(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, Typar tp);
    internal static FSharpList`1<TType> FilterMeasureTyargs(FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeData ConvType(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TypeData> ConvTypes(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvConst(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, Const c, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvDecisionTree(QuotationGenerationScope cenv, QuotationTranslationEnv env, DecisionTreeTarget[] tgs, TypeData typR, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILTypeRefStaticLinkLocal(QuotationGenerationScope cenv, range m, ILTypeRef tr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NamedTypeData ConvILTypeRefUnadjusted(QuotationGenerationScope cenv, range m, ILTypeRef tr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NamedTypeData ConvILTypeRef(QuotationGenerationScope cenv, ILTypeRef tr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeData ConvVoidType(QuotationGenerationScope cenv, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeData ConvILType(QuotationGenerationScope cenv, QuotationTranslationEnv env, range m, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> TryElimErasableTyconRef(QuotationGenerationScope cenv, range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NamedTypeData ConvTyconRef(QuotationGenerationScope cenv, EntityRef tcref, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeData ConvReturnType(QuotationGenerationScope cenv, QuotationTranslationEnv envinner, range m, FSharpOption`1<TType> retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvExprPublic(QuotationGenerationScope cenv, QuotationTranslationEnv env, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodBaseData ConvMethodBase(QuotationGenerationScope cenv, QuotationTranslationEnv env, string methName, Val v);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Range : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int columnBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int lineBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int fileIndexBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int startColumnBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int endColumnBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int startLineBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int heightBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int isSyntheticBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int fileIndexShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int startColumnShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int endColumnShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int startLineShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int heightShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int isSyntheticShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long fileIndexMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long startColumnMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long endColumnMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long startLineMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long heightMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long isSyntheticMask;
    internal static int posBitCount { get; }
    [CompilationMappingAttribute("9")]
internal static long posColumnMask { get; }
    [CompilationMappingAttribute("9")]
internal static long lineColumnMask { get; }
    [CompilationMappingAttribute("9")]
internal static int maxFileIndex { get; }
    [CompilationMappingAttribute("9")]
internal static FileIndexTable fileIndexTable { get; }
    [CompilationMappingAttribute("9")]
public static IComparer`1<pos> posOrder { get; }
    [CompilationMappingAttribute("9")]
public static IComparer`1<range> rangeOrder { get; }
    [CompilationMappingAttribute("9")]
public static pos pos0 { get; }
    [CompilationMappingAttribute("9")]
public static range range0 { get; }
    [CompilationMappingAttribute("9")]
public static range rangeStartup { get; }
    [CompilationMappingAttribute("9")]
public static range rangeCmdArgs { get; }
    private static Range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_posBitCount();
    internal static long get_posColumnMask();
    internal static long get_lineColumnMask();
    internal static string normalizeFilePath(string filePath);
    [CompilerGeneratedAttribute]
internal static int action@1-3(FileIndexTable t, string filePath, string normalizedFilePath, Unit unitVar0);
    internal static int get_maxFileIndex();
    internal static FileIndexTable get_fileIndexTable();
    public static int fileIndexOfFile(string filePath);
    public static string fileOfFileIndex(int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static pos mkPos(int line, int column);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static range mkRange(string filePath, pos startPos, pos endPos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool equals(range r1, range r2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static range mkFileIndexRange(int fileIndex, pos startPos, pos endPos);
    public static IComparer`1<pos> get_posOrder();
    public static IComparer`1<range> get_rangeOrder();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void outputPos(TextWriter os, pos m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void outputRange(TextWriter os, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool posGt(pos p1, pos p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool posEq(pos p1, pos p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool posGeq(pos p1, pos p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool posLt(pos p1, pos p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static range unionRanges(range m1, range m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rangeContainsRange(range m1, range m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rangeContainsPos(range m1, pos p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rangeBeforePos(range m1, pos p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static range rangeN(string filename, int line);
    public static pos get_pos0();
    public static range get_range0();
    public static range get_rangeStartup();
    public static range get_rangeCmdArgs();
    public static range trimRangeToLine(range r);
    public static string stringOfPos(pos pos);
    public static string stringOfRange(range r);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Rational : object {
    [CompilationMappingAttribute("9")]
internal static Rational ZeroRational { get; }
    [CompilationMappingAttribute("9")]
internal static Rational OneRational { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static BigInteger gcd(BigInteger a, BigInteger b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational mkRational(BigInteger p, BigInteger q);
    internal static Rational intToRational(int p);
    internal static Rational get_ZeroRational();
    internal static Rational get_OneRational();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational AddRational(Rational m, Rational n);
    internal static Rational NegRational(Rational m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational MulRational(Rational m, Rational n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational DivRational(Rational m, Rational n);
    internal static Rational AbsRational(Rational m);
    internal static string RationalToString(Rational m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational GcdRational(Rational m, Rational n);
    internal static int GetNumerator(Rational p);
    internal static int GetDenominator(Rational p);
    internal static int SignRational(Rational p);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.RawFSharpAssemblyDataBackedByLanguageService : object {
    internal ILAssemblyRef ilAssemRef;
    internal string assemblyName;
    internal FSharpList`1<Tuple`2<string, FSharpFunc`2<Unit, Byte[]>>> sigData;
    internal FSharpList`1<string> autoOpenAttrs;
    internal FSharpList`1<string> ivtAttrs;
    public RawFSharpAssemblyDataBackedByLanguageService(TcConfig tcConfig, TcGlobals tcGlobals, TcState tcState, string outfile, TopAttribs topAttrs, string assemblyName, ILAssemblyRef ilAssemRef);
    private virtual override FSharpList`1<string> FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-GetAutoOpenAttributes(ILGlobals _ilg);
    private virtual override FSharpList`1<string> FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-GetInternalsVisibleToAttributes(ILGlobals _ilg);
    private virtual override FSharpOption`1<ILModuleDef> FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-TryGetILModuleDef();
    private virtual override FSharpList`1<Tuple`2<string, FSharpFunc`2<Unit, Byte[]>>> FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-GetRawFSharpSignatureData(range _m, string _ilShortAssemName, string _filename);
    private virtual override FSharpList`1<Tuple`2<string, FSharpFunc`2<Unit, Byte[]>>> FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-GetRawFSharpOptimizationData(range _m, string _ilShortAssemName, string _filename);
    private virtual override ILExportedTypesAndForwarders FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-GetRawTypeForwarders();
    private virtual override string FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-get_ShortAssemblyName();
    private virtual override ILScopeRef FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-get_ILScopeRef();
    private virtual override FSharpList`1<ILAssemblyRef> FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-get_ILAssemblyRefs();
    private virtual override bool FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-get_HasAnyFSharpSignatureDataAttribute();
    private virtual override bool FSharp-Compiler-CompileOps-IRawFSharpAssemblyData-HasMatchingFSharpSignatureDataAttribute(ILGlobals _ilg);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.ReferenceResolver : object {
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SignatureConformance : object {
    internal static FSharpFunc`2<Attrib, bool> attribsEq@69(Checker this, FSharpFunc`2<AttribExpr, FSharpFunc`2<AttribExpr, bool>> attribExprEq, FSharpFunc`2<AttribNamedArg, FSharpFunc`2<AttribNamedArg, bool>> attribNamedArgEq, Attrib attrib1);
    internal static FSharpFunc`2<Attrib, bool> attribsHaveSameTycon@76(Checker this, Attrib attrib1);
    internal static FSharpList`1<Attrib> check@84-4(Checker this, FSharpFunc`2<AttribExpr, FSharpFunc`2<AttribExpr, bool>> attribExprEq, FSharpFunc`2<AttribNamedArg, FSharpFunc`2<AttribNamedArg, bool>> attribNamedArgEq, FSharpList`1<Attrib> keptImplAttribsRev, FSharpList`1<Attrib> implAttribs, FSharpList`1<Attrib> sigAttribs);
    internal static FSharpList`1<TType> flatten@186(Checker this, range m, FSharpList`1<TType> tys);
    internal static bool err@304(EntityRef implModRef, Val implVal, Val sigVal, DisplayEnv denv, FSharpFunc`2<Tuple`3<string, string, string>, string> f);
    internal static bool err@345-2(Checker this, UnionCase implUnionCase, UnionCase sigUnionCase, FSharpFunc`2<Tuple`2<string, string>, string> f);
    internal static bool err@355-3(Checker this, RecdField implField, RecdField sigField, FSharpFunc`2<Tuple`2<string, string>, string> f);
    internal static bool reportNiceError@472(range m, Entity implTycon, string k, FSharpList`1<string> s1, FSharpList`1<string> s2);
    internal static FSharpList`1<string> names@505-1(FSharpList`1<UnionCase> l);
    internal static void sigValHadNoMatchingImplementation@581(Checker this, range m, EntityRef implModRef, Val fx, FSharpOption`1<Val> _closeActualVal);
    internal static bool valuesPartiallyMatch@589(Val av, Val fv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckNamesOfModuleOrNamespaceContents(DisplayEnv denv, EntityRef implModRef, ModuleOrNamespaceType signModType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckNamesOfModuleOrNamespace(DisplayEnv denv, EntityRef implModRef, ModuleOrNamespaceType signModType);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SimulatedMSBuildReferenceResolver : object {
    [CompilationMappingAttribute("9")]
internal static Resolver SimulatedMSBuildResolver { get; }
    [CompilationMappingAttribute("9")]
internal static String[] supportedFrameworks@17 { get; }
    internal static Resolver get_SimulatedMSBuildResolver();
    internal static String[] get_supportedFrameworks@17();
    internal static FSharpList`1<string> registrySearchPaths@53(Unit unitVar0);
    internal static void success@96(List`1<ResolvedFile> results, string baggage, FSharpRef`1<bool> found, string path);
    internal static Resolver getResolver();
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.SourceCodeServices.AssemblyContentCacheEntry : object {
    [DebuggerBrowsableAttribute("0")]
internal DateTime FileWriteTime@;
    [DebuggerBrowsableAttribute("0")]
internal AssemblyContentType ContentType@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<AssemblySymbol> Symbols@;
    [CompilationMappingAttribute("4", "0")]
internal DateTime FileWriteTime { get; }
    [CompilationMappingAttribute("4", "1")]
internal AssemblyContentType ContentType { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpList`1<AssemblySymbol> Symbols { get; }
    internal AssemblyContentCacheEntry(DateTime fileWriteTime, AssemblyContentType contentType, FSharpList`1<AssemblySymbol> symbols);
    internal DateTime get_FileWriteTime();
    internal AssemblyContentType get_ContentType();
    internal FSharpList`1<AssemblySymbol> get_Symbols();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.AssemblyContentProvider : object {
    internal static FSharpOption`1<String[]> getNamespace@191(String[] idents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnresolvedSymbol unresolvedSymbol(FSharpOption`1<String[]> topRequireQualifiedAccessParent, String[] cleanedIdents, string fullName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<AssemblySymbol> createEntity(FSharpOption`1<String[]> ns, Parent parent, FSharpEntity entity);
    internal static AssemblySymbol processIdents@240(FSharpOption`1<String[]> ns, Parent parent, FSharpOption`1<String[]> topRequireQualifiedAccessParent, FSharpOption`1<String[]> autoOpenParent, FSharpMemberOrFunctionOrValue func, string fullName, String[] idents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<AssemblySymbol> traverseMemberFunctionAndValues(FSharpOption`1<String[]> ns, Parent parent, IEnumerable`1<FSharpMemberOrFunctionOrValue> membersFunctionsAndValues);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<AssemblySymbol> traverseEntity(AssemblyContentType contentType, Parent parent, FSharpEntity entity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<AssemblySymbol> getAssemblySignatureContent(AssemblyContentType contentType, FSharpAssemblySignature signature);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AssemblySymbol> getAssemblySignaturesContent(AssemblyContentType contentType, FSharpList`1<FSharpAssembly> assemblies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<AssemblySymbol> getAssemblyContent(FSharpFunc`2<FSharpFunc`2<IAssemblyContentCache, FSharpList`1<AssemblySymbol>>, FSharpList`1<AssemblySymbol>> withCache, AssemblyContentType contentType, FSharpOption`1<string> fileName, FSharpList`1<FSharpAssembly> assemblies);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.AssemblyContentType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AssemblyContentType _unique_Public;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AssemblyContentType _unique_Full;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static AssemblyContentType Public { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPublic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static AssemblyContentType Full { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFull { get; }
    private static AssemblyContentType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal AssemblyContentType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static AssemblyContentType get_Public();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPublic();
    [CompilationMappingAttribute("8", "1")]
public static AssemblyContentType get_Full();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFull();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(AssemblyContentType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AssemblyContentType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.AssemblySymbol : object {
    [DebuggerBrowsableAttribute("0")]
internal string FullName@;
    [DebuggerBrowsableAttribute("0")]
internal String[] CleanedIdents@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> Namespace@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> NearestRequireQualifiedAccessParent@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> TopRequireQualifiedAccessParent@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> AutoOpenParent@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpSymbol Symbol@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<LookupType, EntityKind> Kind@;
    [DebuggerBrowsableAttribute("0")]
internal UnresolvedSymbol UnresolvedSymbol@;
    [CompilationMappingAttribute("4", "0")]
public string FullName { get; }
    [CompilationMappingAttribute("4", "1")]
public String[] CleanedIdents { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<String[]> Namespace { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<String[]> NearestRequireQualifiedAccessParent { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpOption`1<String[]> TopRequireQualifiedAccessParent { get; }
    [CompilationMappingAttribute("4", "5")]
public FSharpOption`1<String[]> AutoOpenParent { get; }
    [CompilationMappingAttribute("4", "6")]
public FSharpSymbol Symbol { get; }
    [CompilationMappingAttribute("4", "7")]
public FSharpFunc`2<LookupType, EntityKind> Kind { get; }
    [CompilationMappingAttribute("4", "8")]
public UnresolvedSymbol UnresolvedSymbol { get; }
    public AssemblySymbol(string fullName, String[] cleanedIdents, FSharpOption`1<String[]> namespace, FSharpOption`1<String[]> nearestRequireQualifiedAccessParent, FSharpOption`1<String[]> topRequireQualifiedAccessParent, FSharpOption`1<String[]> autoOpenParent, FSharpSymbol symbol, FSharpFunc`2<LookupType, EntityKind> kind, UnresolvedSymbol unresolvedSymbol);
    public string get_FullName();
    public String[] get_CleanedIdents();
    public FSharpOption`1<String[]> get_Namespace();
    public FSharpOption`1<String[]> get_NearestRequireQualifiedAccessParent();
    public FSharpOption`1<String[]> get_TopRequireQualifiedAccessParent();
    public FSharpOption`1<String[]> get_AutoOpenParent();
    public FSharpSymbol get_Symbol();
    public FSharpFunc`2<LookupType, EntityKind> get_Kind();
    public UnresolvedSymbol get_UnresolvedSymbol();
    public virtual string ToString();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.AstTraversal : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rangeContainsPosLeftEdgeInclusive(range m1, pos p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rangeContainsPosEdgesExclusive(range m1, pos p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rangeContainsPosLeftEdgeExclusiveAndRightEdgeInclusive(range m1, pos p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<b, FSharpFunc`2<Unit, c>> dive(a node, b range, FSharpFunc`2<a, c> project);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<a> pick$cont@129(pos pos, FSharpList`1<Tuple`2<range, FSharpFunc`2<Unit, FSharpOption`1<a>>>> diveResults, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> pick(pos pos, range outerRange, object _debugObj, FSharpList`1<Tuple`2<range, FSharpFunc`2<Unit, FSharpOption`1<a>>>> diveResults);
    internal static FSharpFunc`2<FSharpList`1<Tuple`2<range, FSharpFunc`2<Unit, FSharpOption`1<b>>>>, FSharpOption`1<b>> pick@169-2(pos pos, range x, a _debugObj);
    internal static FSharpFunc`2<SynModuleDecl, FSharpOption`1<T>> traverseSynModuleDecl@170(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, FSharpList`1<TraverseStep> path);
    internal static FSharpOption`1<T> traverseSynModuleOrNamespace@190(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, FSharpList`1<TraverseStep> path, SynModuleOrNamespace _arg1);
    internal static FSharpOption`1<T> diveIntoSeparator@232(AstVisitorBase`1<T> visitor, pos pos, FSharpList`1<TraverseStep> path, int offsideColumn, FSharpOption`1<pos> scPosOpt, FSharpOption`1<SynExpr> copyOpt);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<T> defaultTraverse$cont@359(AstVisitorBase`1<T> visitor, FSharpList`1<TraverseStep> path, SynExpr e, FSharpList`1<TraverseStep> path@359, FSharpFunc`2<SynExpr, FSharpOption`1<T>> traverseSynExpr, Unit unitVar);
    internal static FSharpOption`1<T> traverseSynExpr@197(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, FSharpList`1<TraverseStep> path, SynExpr expr);
    internal static FSharpOption`1<T> traversePat@495(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, SynPat pat);
    internal static FSharpOption`1<T> traverseSynType@515(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, SynType ty);
    internal static FSharpFunc`2<FSharpList`1<SynMemberDefn>, IEnumerable`1<Tuple`2<range, FSharpFunc`2<Unit, FSharpOption`1<T>>>>> normalizeMembersToDealWithPeculiaritiesOfGettersAndSetters@537(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, FSharpList`1<TraverseStep> path, FSharpFunc`2<Tuple`2<SynType, range>, FSharpOption`1<T>> traverseInherit);
    internal static FSharpOption`1<T> traverseSynTypeDefn@577(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, FSharpList`1<TraverseStep> path, SynTypeDefn _arg2);
    internal static FSharpFunc`2<object, FSharpFunc`2<FSharpList`1<Tuple`2<range, FSharpFunc`2<Unit, FSharpOption`1<a>>>>, FSharpOption`1<a>>> pick@604-5(pos pos, SynMemberDefn m);
    internal static FSharpOption`1<T> traverseSynMemberDefn@603(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, FSharpList`1<TraverseStep> path, FSharpFunc`2<Tuple`2<SynType, range>, FSharpOption`1<T>> traverseInherit, SynMemberDefn m);
    internal static FSharpFunc`2<SynMatchClause, FSharpOption`1<T>> traverseSynMatchClause@640(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, FSharpList`1<TraverseStep> path);
    internal static FSharpOption`1<T> traverseSynBinding@657(AstVisitorBase`1<T> visitor, pos pos, FSharpTypeFunc pick, FSharpList`1<TraverseStep> path, SynBinding b);
    public static FSharpOption`1<T> Traverse(pos pos, ParsedInput parseTree, AstVisitorBase`1<T> visitor);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.BackgroundCompiler : object {
    internal FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot;
    internal bool suggestNamesForErrors;
    internal Resolver legacyReferenceResolver;
    internal bool keepAssemblyContents;
    internal bool keepAllBackgroundResolutions;
    internal FSharpRef`1<BackgroundCompiler> self;
    internal Reactor reactor;
    internal FSharpEvent`1<Tuple`2<string, FSharpOption`1<object>>> beforeFileChecked;
    internal FSharpEvent`1<Tuple`2<string, FSharpOption`1<object>>> fileParsed;
    internal FSharpEvent`1<Tuple`2<string, FSharpOption`1<object>>> fileChecked;
    internal FSharpEvent`1<Tuple`2<string, FSharpOption`1<object>>> projectChecked;
    internal bool implicitlyStartBackgroundWork;
    internal IReactorOperations reactorOps;
    internal MruCache`3<ScriptClosureCacheToken, FSharpProjectOptions, LoadClosure> scriptClosureCache;
    internal Lock`1<ScriptClosureCacheToken> scriptClosureCacheLock;
    internal FrameworkImportsCache frameworkTcImportsCache;
    internal MruCache`3<CompilationThreadToken, FSharpProjectOptions, Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpErrorInfo[]>> incrementalBuildersCache;
    internal Lock`1<ParseCacheLockToken> parseCacheLock;
    internal MruCache`3<ParseCacheLockToken, Tuple`3<string, int, FSharpParsingOptions>, FSharpParseFileResults> parseFileCache;
    internal MruCache`3<ParseCacheLockToken, Tuple`2<string, FSharpProjectOptions>, Tuple`3<FSharpParseFileResults, FSharpCheckFileResults, int>> checkFileInProjectCachePossiblyStale;
    internal MruCache`3<ParseCacheLockToken, Tuple`3<string, int, FSharpProjectOptions>, Tuple`4<FSharpParseFileResults, FSharpCheckFileResults, int, DateTime>> checkFileInProjectCache;
    internal ConcurrentDictionary`2<Tuple`3<string, FSharpProjectOptions, int>, Unit> beingCheckedFileTable;
    internal static int foregroundParseCount;
    internal static int foregroundTypeCheckCount;
    internal static int init@252-18;
    internal int init@252-17;
    internal Reactor Reactor { get; }
    internal IReactorOperations ReactorOps { get; }
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> BeforeBackgroundFileCheck { get; }
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> FileParsed { get; }
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> FileChecked { get; }
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> ProjectChecked { get; }
    internal int CurrentQueueLength { get; }
    internal FrameworkImportsCache FrameworkImportsCache { get; }
    internal bool ImplicitlyStartBackgroundWork { get; internal set; }
    internal static int GlobalForegroundParseCountStatistic { get; }
    internal static int GlobalForegroundTypeCheckCountStatistic { get; }
    public BackgroundCompiler(Resolver legacyReferenceResolver, int projectCacheSize, bool keepAssemblyContents, bool keepAllBackgroundResolutions, FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot, bool suggestNamesForErrors);
    private static BackgroundCompiler();
    internal void RecordTypeCheckFileInProjectResults(string filename, FSharpProjectOptions options, FSharpParsingOptions parsingOptions, FSharpParseFileResults parseResults, int fileVersion, DateTime priorTimeStamp, FSharpOption`1<FSharpCheckFileAnswer> checkAnswer, int sourceText);
    internal void ImplicitlyStartCheckProjectInBackground(FSharpProjectOptions options, string userOpName);
    internal FSharpAsync`1<FSharpParseFileResults> ParseFile(string filename, ISourceText sourceText, FSharpParsingOptions options, string userOpName);
    internal FSharpAsync`1<FSharpParseFileResults> ParseFileNoCache(string filename, ISourceText sourceText, FSharpParsingOptions options, string userOpName);
    internal FSharpAsync`1<FSharpParseFileResults> GetBackgroundParseResultsForFileInProject(string filename, FSharpProjectOptions options, string userOpName);
    internal FSharpOption`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileResults>> GetCachedCheckFileResult(IncrementalBuilder builder, string filename, ISourceText sourceText, FSharpProjectOptions options);
    internal FSharpAsync`1<FSharpCheckFileAnswer> CheckOneFileImpl(FSharpParseFileResults parseResults, ISourceText sourceText, string fileName, FSharpProjectOptions options, FSharpOption`1<object> textSnapshotInfo, int fileVersion, IncrementalBuilder builder, PartialCheckResults tcPrior, FSharpErrorInfo[] creationErrors, string userOpName);
    internal FSharpAsync`1<FSharpOption`1<FSharpCheckFileAnswer>> CheckFileInProjectAllowingStaleCachedResults(FSharpParseFileResults parseResults, string filename, int fileVersion, ISourceText sourceText, FSharpProjectOptions options, FSharpOption`1<object> textSnapshotInfo, string userOpName);
    internal FSharpAsync`1<FSharpCheckFileAnswer> CheckFileInProject(FSharpParseFileResults parseResults, string filename, int fileVersion, ISourceText sourceText, FSharpProjectOptions options, FSharpOption`1<object> textSnapshotInfo, string userOpName);
    internal FSharpAsync`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileAnswer>> ParseAndCheckFileInProject(string filename, int fileVersion, ISourceText sourceText, FSharpProjectOptions options, FSharpOption`1<object> textSnapshotInfo, string userOpName);
    internal FSharpAsync`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileResults>> GetBackgroundCheckResultsForFileInProject(string filename, FSharpProjectOptions options, string userOpName);
    internal FSharpOption`1<Tuple`3<FSharpParseFileResults, FSharpCheckFileResults, int>> TryGetRecentCheckResultsForFile(string filename, FSharpProjectOptions options, FSharpOption`1<ISourceText> sourceText, string _userOpName);
    internal Cancellable`1<FSharpCheckProjectResults> ParseAndCheckProjectImpl(FSharpProjectOptions options, CompilationThreadToken ctok, string userOpName);
    internal FSharpOption`1<DateTime> TryGetLogicalTimeStampForProject(TimeStampCache cache, CompilationThreadToken ctok, FSharpProjectOptions options, string userOpName);
    internal FSharpAsync`1<FSharpCheckProjectResults> ParseAndCheckProject(FSharpProjectOptions options, string userOpName);
    internal FSharpAsync`1<Tuple`2<FSharpProjectOptions, FSharpList`1<FSharpErrorInfo>>> GetProjectOptionsFromScript(string filename, ISourceText sourceText, FSharpOption`1<DateTime> loadedTimeStamp, FSharpOption`1<String[]> otherFlags, FSharpOption`1<bool> useFsiAuxLib, FSharpOption`1<bool> useSdkRefs, FSharpOption`1<bool> assumeDotNetFramework, FSharpOption`1<object> extraProjectInfo, FSharpOption`1<long> optionsStamp, string userOpName);
    internal void InvalidateConfiguration(FSharpProjectOptions options, FSharpOption`1<bool> startBackgroundCompileIfAlreadySeen, string userOpName);
    internal FSharpAsync`1<Unit> NotifyProjectCleaned(FSharpProjectOptions options, string userOpName);
    internal void CheckProjectInBackground(FSharpProjectOptions options, string userOpName);
    internal void StopBackgroundCompile();
    internal void WaitForBackgroundCompile();
    internal void CompleteAllQueuedOps();
    internal Reactor get_Reactor();
    internal IReactorOperations get_ReactorOps();
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> get_BeforeBackgroundFileCheck();
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> get_FileParsed();
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> get_FileChecked();
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> get_ProjectChecked();
    internal int get_CurrentQueueLength();
    internal FSharpAsync`1<Unit> ClearCachesAsync(string userOpName);
    internal FSharpAsync`1<Unit> DownsizeCaches(string userOpName);
    internal FrameworkImportsCache get_FrameworkImportsCache();
    internal bool get_ImplicitlyStartBackgroundWork();
    internal void set_ImplicitlyStartBackgroundWork(bool v);
    internal static int get_GlobalForegroundParseCountStatistic();
    internal static int get_GlobalForegroundTypeCheckCountStatistic();
    [CompilerGeneratedAttribute]
internal Cancellable`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpErrorInfo[]>> CreateOneIncrementalBuilder(CompilationThreadToken ctok, FSharpProjectOptions options, string userOpName);
    [CompilerGeneratedAttribute]
internal Cancellable`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpErrorInfo[]>> getOrCreateBuilder(CompilationThreadToken ctok, FSharpProjectOptions options, string userOpName);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.BasicPatterns : object {
    public static FSharpOption`1<FSharpMemberOrFunctionOrValue> |Value|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<object, FSharpType>> |Const|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpList`1<FSharpGenericParameter>, FSharpExpr>> |TypeLambda|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpMemberOrFunctionOrValue, FSharpExpr>> |Lambda|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |Application|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpExpr, FSharpExpr>> |IfThenElse|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<Tuple`2<FSharpMemberOrFunctionOrValue, FSharpExpr>, FSharpExpr>> |Let|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpList`1<Tuple`2<FSharpMemberOrFunctionOrValue, FSharpExpr>>, FSharpExpr>> |LetRec|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpList`1<FSharpExpr>>> |NewRecord|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpList`1<FSharpExpr>>> |NewAnonRecord|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpType, FSharpUnionCase, FSharpList`1<FSharpExpr>>> |NewUnionCase|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpList`1<FSharpExpr>>> |NewTuple|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpType, int, FSharpExpr>> |TupleGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`5<FSharpOption`1<FSharpExpr>, FSharpMemberOrFunctionOrValue, FSharpList`1<FSharpType>, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |Call|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpMemberOrFunctionOrValue, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |NewObject|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpType, FSharpField>> |FSharpFieldGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpType, int>> |AnonRecordGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpOption`1<FSharpExpr>, FSharpType, FSharpField, FSharpExpr>> |FSharpFieldSet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpExpr, FSharpType, FSharpUnionCase, FSharpField>> |UnionCaseGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpType>> |UnionCaseTag|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpType, FSharpUnionCase>> |UnionCaseTest|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpList`1<FSharpExpr>>> |NewArray|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpExpr>> |Coerce|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpExpr> |Quote|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpExpr>> |TypeTest|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> |Sequential|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpExpr, FSharpExpr, FSharpExpr, bool>> |FastIntegerForLoop|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> |WhileLoop|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> |TryFinally|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`5<FSharpExpr, FSharpMemberOrFunctionOrValue, FSharpExpr, FSharpMemberOrFunctionOrValue, FSharpExpr>> |TryWith|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpExpr>> |NewDelegate|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpType> |DefaultValue|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> |AddressSet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpMemberOrFunctionOrValue, FSharpExpr>> |ValueSet|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpExpr> |AddressOf|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpType> |ThisValue|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpType> |BaseValue|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<string, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |ILAsm|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpType, string>> |ILFieldGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpOption`1<FSharpExpr>, FSharpType, string, FSharpExpr>> |ILFieldSet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpType, FSharpExpr, FSharpList`1<FSharpObjectExprOverride>, FSharpList`1<Tuple`2<FSharpType, FSharpList`1<FSharpObjectExprOverride>>>>> |ObjectExpr|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpList`1<Tuple`2<FSharpList`1<FSharpMemberOrFunctionOrValue>, FSharpExpr>>>> |DecisionTree|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<int, FSharpList`1<FSharpExpr>>> |DecisionTreeSuccess|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`5<FSharpExpr, FSharpType, FSharpUnionCase, FSharpField, FSharpExpr>> |UnionCaseSet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`6<FSharpList`1<FSharpType>, string, MemberFlags, FSharpList`1<FSharpType>, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |TraitCall|_|(FSharpExpr e);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.CodeGenerationUtils : object {
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> keywordSet { get; }
    internal static FSharpList`1<SynExpr> |IndexerArg|(SynIndexerArg _arg1);
    internal static FSharpOption`1<FSharpList`1<SynExpr>> |Sequentials|_|(SynExpr _arg1);
    internal static FSharpSet`1<string> get_keywordSet();
    internal static int getAvailableIndex@85(FSharpSet`1<int> indexes, int idx);
    [CompilerGeneratedAttribute]
internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> normalizeArgName$cont@79(FSharpMap`2<string, FSharpSet`1<int>> namesWithIndices, string nm, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> normalizeArgName(FSharpMap`2<string, FSharpSet`1<int>> namesWithIndices, string nm);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.CompilationErrorLogger : ErrorLogger {
    internal FSharpErrorSeverityOptions options;
    internal int errorCount;
    internal List`1<Tuple`2<PhasedDiagnostic, FSharpErrorSeverity>> diagnostics;
    public int ErrorCount { get; }
    public CompilationErrorLogger(string debugName, FSharpErrorSeverityOptions options);
    public virtual void DiagnosticSink(PhasedDiagnostic exn, bool isError);
    public virtual int get_ErrorCount();
    internal Tuple`2[] GetErrors();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.CompilationGlobalsScope : object {
    internal IDisposable unwindEL;
    internal IDisposable unwindBP;
    public CompilationGlobalsScope(ErrorLogger errorLogger, BuildPhase phase);
    private virtual override void System-IDisposable-Dispose();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.CompileHelpers : object {
    internal static void errorSink@136(List`1<FSharpErrorInfo> errors, bool isError, PhasedDiagnostic exn);
    internal static Tuple`3<List`1<FSharpErrorInfo>, ErrorLogger, ErrorLoggerProvider> mkCompilationErorHandlers();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int tryCompile(ErrorLogger errorLogger, FSharpFunc`2<Exiter, Unit> f);
    internal static Tuple`2<FSharpErrorInfo[], int> compileFromArgs(CompilationThreadToken ctok, String[] argv, Resolver legacyReferenceResolver, FSharpOption`1<FSharpFunc`2<TcImports, Unit>> tcImportsCapture, FSharpOption`1<FSharpFunc`2<Tuple`3<TcGlobals, string, ILModuleDef>, Unit>> dynamicAssemblyCreator);
    internal static Tuple`2<FSharpErrorInfo[], int> compileFromAsts(CompilationThreadToken ctok, Resolver legacyReferenceResolver, FSharpList`1<ParsedInput> asts, string assemblyName, string outFile, FSharpList`1<string> dependencies, bool noframework, FSharpOption`1<string> pdbFile, FSharpOption`1<bool> executable, FSharpOption`1<FSharpFunc`2<TcImports, Unit>> tcImportsCapture, FSharpOption`1<FSharpFunc`2<Tuple`3<TcGlobals, string, ILModuleDef>, Unit>> dynamicAssemblyCreator);
    internal static FSharpFunc`2<ILAssemblyRef, FSharpOption`1<FSharpChoice`2<string, a>>> assemblyResolver@208(FSharpRef`1<FSharpOption`1<TcImports>> tcImportsRef, CompilationThreadToken ctok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createDynamicAssembly(CompilationThreadToken ctok, bool debugInfo, FSharpRef`1<FSharpOption`1<TcImports>> tcImportsRef, bool execute, FSharpRef`1<FSharpOption`1<AssemblyBuilder>> assemblyBuilderRef, TcGlobals tcGlobals, string outfile, ILModuleDef ilxMainModule);
    internal static void setOutputStreams(FSharpOption`1<Tuple`2<a, b>> execute);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.CompilerEnvironment : object {
    public static FSharpOption`1<string> BinFolderOfDefaultFSharpCompiler(FSharpOption`1<string> probePoint);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.CompilerEnvironmentModule : object {
    public static FSharpList`1<string> DefaultReferencesForOrphanSources(bool assumeDotNetFramework);
    public static FSharpList`1<string> GetCompilationDefinesForEditing(FSharpParsingOptions parsingOptions);
    public static bool IsCheckerSupportedSubcategory(string subcategory);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.CompletionContext : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_Invalid;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_RangeOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_AttributeApplication;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_OpenDeclaration;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_PatternType;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext Invalid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInvalid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecordField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext RangeOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRangeOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParameterList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext AttributeApplication { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAttributeApplication { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext OpenDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpenDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext PatternType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPatternType { get; }
    private static CompletionContext();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CompletionContext(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static CompletionContext get_Invalid();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInvalid();
    [CompilationMappingAttribute("8", "1")]
public static CompletionContext NewInherit(InheritanceContext item1, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInherit();
    [CompilationMappingAttribute("8", "2")]
public static CompletionContext NewRecordField(RecordContext item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecordField();
    [CompilationMappingAttribute("8", "3")]
public static CompletionContext get_RangeOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRangeOperator();
    [CompilationMappingAttribute("8", "4")]
public static CompletionContext NewParameterList(pos item1, HashSet`1<string> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParameterList();
    [CompilationMappingAttribute("8", "5")]
public static CompletionContext get_AttributeApplication();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAttributeApplication();
    [CompilationMappingAttribute("8", "6")]
public static CompletionContext get_OpenDeclaration();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpenDeclaration();
    [CompilationMappingAttribute("8", "7")]
public static CompletionContext get_PatternType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPatternType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompletionContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.SourceCodeServices.CompletionItem : object {
    [DebuggerBrowsableAttribute("0")]
internal ItemWithInst ItemWithInst@;
    [DebuggerBrowsableAttribute("0")]
internal CompletionItemKind Kind@;
    [DebuggerBrowsableAttribute("0")]
internal bool IsOwnMember@;
    [DebuggerBrowsableAttribute("0")]
internal int MinorPriority@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<EntityRef> Type@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<UnresolvedSymbol> Unresolved@;
    [CompilationMappingAttribute("4", "0")]
internal ItemWithInst ItemWithInst { get; }
    [CompilationMappingAttribute("4", "1")]
internal CompletionItemKind Kind { get; }
    [CompilationMappingAttribute("4", "2")]
internal bool IsOwnMember { get; }
    [CompilationMappingAttribute("4", "3")]
internal int MinorPriority { get; }
    [CompilationMappingAttribute("4", "4")]
internal FSharpOption`1<EntityRef> Type { get; }
    [CompilationMappingAttribute("4", "5")]
internal FSharpOption`1<UnresolvedSymbol> Unresolved { get; }
    internal Item Item { get; }
    internal CompletionItem(ItemWithInst itemWithInst, CompletionItemKind kind, bool isOwnMember, int minorPriority, FSharpOption`1<EntityRef> type, FSharpOption`1<UnresolvedSymbol> unresolved);
    internal ItemWithInst get_ItemWithInst();
    internal CompletionItemKind get_Kind();
    internal bool get_IsOwnMember();
    internal int get_MinorPriority();
    internal FSharpOption`1<EntityRef> get_Type();
    internal FSharpOption`1<UnresolvedSymbol> get_Unresolved();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal Item get_Item();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.CompletionItemKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Field;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Event;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Argument;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_CustomOperation;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Other;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Field { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Event { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Argument { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArgument { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind CustomOperation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCustomOperation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Other { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOther { get; }
    private static CompletionItemKind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CompletionItemKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static CompletionItemKind get_Field();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "1")]
public static CompletionItemKind get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilationMappingAttribute("8", "2")]
public static CompletionItemKind NewMethod(bool _isExtension);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethod();
    [CompilationMappingAttribute("8", "3")]
public static CompletionItemKind get_Event();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEvent();
    [CompilationMappingAttribute("8", "4")]
public static CompletionItemKind get_Argument();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArgument();
    [CompilationMappingAttribute("8", "5")]
public static CompletionItemKind get_CustomOperation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCustomOperation();
    [CompilationMappingAttribute("8", "6")]
public static CompletionItemKind get_Other();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOther();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CompletionItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompletionItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.DebuggerEnvironment : object {
    public static Guid GetLanguageID();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.DescriptionListsImpl : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFunction(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string printCanonicalizedTypeName(TcGlobals g, DisplayEnv denv, TType tau);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMethodGroupItemParameter PrettyParamOfRecdField(TcGlobals g, DisplayEnv denv, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMethodGroupItemParameter PrettyParamOfUnionCaseField(TcGlobals g, DisplayEnv denv, FSharpFunc`2<int, FSharpFunc`2<RecdField, bool>> isGenerated, int i, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<FSharpMethodGroupItemParameter>, Layout, Layout> PrettyParamsOfParamDatas(TcGlobals g, DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> typarInst, FSharpList`1<ParamData> paramDatas, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<FSharpMethodGroupItemParameter>, Layout, Layout> PrettyParamsOfTypes(TcGlobals g, DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> typarInst, FSharpList`1<TType> paramTys, TType retTy);
    [CompilerGeneratedAttribute]
internal static FSharpMethodGroupItemParameter mapping@1-37(range m, DisplayEnv denv, ImportMap amap, Tainted`1<ProvidedParameterInfo> sp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMethodGroupItemParameter[] StaticParamsOfItem(InfoReader infoReader, range m, DisplayEnv denv, Item item);
    internal static Tuple`2<FSharpList`1<FSharpMethodGroupItemParameter>, Layout> getPrettyParamsOfTypes@204(ItemWithInst item, TcGlobals g, DisplayEnv denv, ValRef vref, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpMethodGroupItemParameter>, Layout> PrettyParamsAndReturnTypeOfItem(InfoReader infoReader, range m, DisplayEnv denv, ItemWithInst item);
    internal static FSharpGlyph reprToGlyph@361(TyconRepresentation repr);
    internal static FSharpGlyph typeToGlyph@387(DisplayEnv denv, TType ty);
    [CompilerGeneratedAttribute]
internal static FSharpGlyph GlyphOfItem$cont@425(EntityRef tcref, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpGlyph f@105-42(Item item, DisplayEnv denv, Unit unitVar0);
    internal static FSharpGlyph GlyphOfItem(DisplayEnv denv, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> AnotherFlattenItems(TcGlobals g, range m, Item item);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.SourceCodeServices.E : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static E _unique_Unused;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsThisValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsBaseValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsApplication { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLambda { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTypeLambda { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsQuote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsIfThenElse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDecisionTree { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDecisionTreeSuccess { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCall { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewObject { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLetRec { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsObjectExpr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFSharpFieldGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFSharpFieldSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewUnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewAnonRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAnonRecordGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCaseGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCaseSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCaseTag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCaseTest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTraitCall { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewTuple { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTupleGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCoerce { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTypeTest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAddressSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsValueSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static E Unused { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnused { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDefaultValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsConst { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAddressOf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSequential { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFastIntegerForLoop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWhileLoop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTryFinally { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTryWith { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewDelegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsILFieldGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsILFieldSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsILAsm { get; }
    private static E();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal E(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static E NewValue(FSharpMemberOrFunctionOrValue item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsValue();
    [CompilationMappingAttribute("8", "1")]
internal static E NewThisValue(FSharpType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsThisValue();
    [CompilationMappingAttribute("8", "2")]
internal static E NewBaseValue(FSharpType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsBaseValue();
    [CompilationMappingAttribute("8", "3")]
internal static E NewApplication(FSharpExpr item1, FSharpList`1<FSharpType> item2, FSharpList`1<FSharpExpr> item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsApplication();
    [CompilationMappingAttribute("8", "4")]
internal static E NewLambda(FSharpMemberOrFunctionOrValue item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLambda();
    [CompilationMappingAttribute("8", "5")]
internal static E NewTypeLambda(FSharpList`1<FSharpGenericParameter> item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTypeLambda();
    [CompilationMappingAttribute("8", "6")]
internal static E NewQuote(FSharpExpr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsQuote();
    [CompilationMappingAttribute("8", "7")]
internal static E NewIfThenElse(FSharpExpr item1, FSharpExpr item2, FSharpExpr item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsIfThenElse();
    [CompilationMappingAttribute("8", "8")]
internal static E NewDecisionTree(FSharpExpr item1, FSharpList`1<Tuple`2<FSharpList`1<FSharpMemberOrFunctionOrValue>, FSharpExpr>> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDecisionTree();
    [CompilationMappingAttribute("8", "9")]
internal static E NewDecisionTreeSuccess(int item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDecisionTreeSuccess();
    [CompilationMappingAttribute("8", "10")]
internal static E NewCall(FSharpOption`1<FSharpExpr> item1, FSharpMemberOrFunctionOrValue item2, FSharpList`1<FSharpType> item3, FSharpList`1<FSharpType> item4, FSharpList`1<FSharpExpr> item5);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCall();
    [CompilationMappingAttribute("8", "11")]
internal static E NewNewObject(FSharpMemberOrFunctionOrValue item1, FSharpList`1<FSharpType> item2, FSharpList`1<FSharpExpr> item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewObject();
    [CompilationMappingAttribute("8", "12")]
internal static E NewLetRec(FSharpList`1<Tuple`2<FSharpMemberOrFunctionOrValue, FSharpExpr>> item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLetRec();
    [CompilationMappingAttribute("8", "13")]
internal static E NewLet(Tuple`2<FSharpMemberOrFunctionOrValue, FSharpExpr> item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLet();
    [CompilationMappingAttribute("8", "14")]
internal static E NewNewRecord(FSharpType item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewRecord();
    [CompilationMappingAttribute("8", "15")]
internal static E NewObjectExpr(FSharpType item1, FSharpExpr item2, FSharpList`1<FSharpObjectExprOverride> item3, FSharpList`1<Tuple`2<FSharpType, FSharpList`1<FSharpObjectExprOverride>>> item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsObjectExpr();
    [CompilationMappingAttribute("8", "16")]
internal static E NewFSharpFieldGet(FSharpOption`1<FSharpExpr> item1, FSharpType item2, FSharpField item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFSharpFieldGet();
    [CompilationMappingAttribute("8", "17")]
internal static E NewFSharpFieldSet(FSharpOption`1<FSharpExpr> item1, FSharpType item2, FSharpField item3, FSharpExpr item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFSharpFieldSet();
    [CompilationMappingAttribute("8", "18")]
internal static E NewNewUnionCase(FSharpType item1, FSharpUnionCase item2, FSharpList`1<FSharpExpr> item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewUnionCase();
    [CompilationMappingAttribute("8", "19")]
internal static E NewNewAnonRecord(FSharpType item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewAnonRecord();
    [CompilationMappingAttribute("8", "20")]
internal static E NewAnonRecordGet(FSharpExpr item1, FSharpType item2, int item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAnonRecordGet();
    [CompilationMappingAttribute("8", "21")]
internal static E NewUnionCaseGet(FSharpExpr item1, FSharpType item2, FSharpUnionCase item3, FSharpField item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCaseGet();
    [CompilationMappingAttribute("8", "22")]
internal static E NewUnionCaseSet(FSharpExpr item1, FSharpType item2, FSharpUnionCase item3, FSharpField item4, FSharpExpr item5);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCaseSet();
    [CompilationMappingAttribute("8", "23")]
internal static E NewUnionCaseTag(FSharpExpr item1, FSharpType item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCaseTag();
    [CompilationMappingAttribute("8", "24")]
internal static E NewUnionCaseTest(FSharpExpr item1, FSharpType item2, FSharpUnionCase item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCaseTest();
    [CompilationMappingAttribute("8", "25")]
internal static E NewTraitCall(FSharpList`1<FSharpType> item1, string item2, MemberFlags item3, FSharpList`1<FSharpType> item4, FSharpList`1<FSharpType> item5, FSharpList`1<FSharpExpr> item6);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTraitCall();
    [CompilationMappingAttribute("8", "26")]
internal static E NewNewTuple(FSharpType item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewTuple();
    [CompilationMappingAttribute("8", "27")]
internal static E NewTupleGet(FSharpType item1, int item2, FSharpExpr item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTupleGet();
    [CompilationMappingAttribute("8", "28")]
internal static E NewCoerce(FSharpType item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCoerce();
    [CompilationMappingAttribute("8", "29")]
internal static E NewNewArray(FSharpType item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewArray();
    [CompilationMappingAttribute("8", "30")]
internal static E NewTypeTest(FSharpType item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTypeTest();
    [CompilationMappingAttribute("8", "31")]
internal static E NewAddressSet(FSharpExpr item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAddressSet();
    [CompilationMappingAttribute("8", "32")]
internal static E NewValueSet(FSharpMemberOrFunctionOrValue item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsValueSet();
    [CompilationMappingAttribute("8", "33")]
internal static E get_Unused();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnused();
    [CompilationMappingAttribute("8", "34")]
internal static E NewDefaultValue(FSharpType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDefaultValue();
    [CompilationMappingAttribute("8", "35")]
internal static E NewConst(object item1, FSharpType item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsConst();
    [CompilationMappingAttribute("8", "36")]
internal static E NewAddressOf(FSharpExpr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAddressOf();
    [CompilationMappingAttribute("8", "37")]
internal static E NewSequential(FSharpExpr item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSequential();
    [CompilationMappingAttribute("8", "38")]
internal static E NewFastIntegerForLoop(FSharpExpr item1, FSharpExpr item2, FSharpExpr item3, bool item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFastIntegerForLoop();
    [CompilationMappingAttribute("8", "39")]
internal static E NewWhileLoop(FSharpExpr item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWhileLoop();
    [CompilationMappingAttribute("8", "40")]
internal static E NewTryFinally(FSharpExpr item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTryFinally();
    [CompilationMappingAttribute("8", "41")]
internal static E NewTryWith(FSharpExpr item1, FSharpMemberOrFunctionOrValue item2, FSharpExpr item3, FSharpMemberOrFunctionOrValue item4, FSharpExpr item5);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTryWith();
    [CompilationMappingAttribute("8", "42")]
internal static E NewNewDelegate(FSharpType item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewDelegate();
    [CompilationMappingAttribute("8", "43")]
internal static E NewILFieldGet(FSharpOption`1<FSharpExpr> item1, FSharpType item2, string item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsILFieldGet();
    [CompilationMappingAttribute("8", "44")]
internal static E NewILFieldSet(FSharpOption`1<FSharpExpr> item1, FSharpType item2, string item3, FSharpExpr item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsILFieldSet();
    [CompilationMappingAttribute("8", "45")]
internal static E NewILAsm(string item1, FSharpList`1<FSharpType> item2, FSharpList`1<FSharpExpr> item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsILAsm();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(E obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.Entity : object {
    [DebuggerBrowsableAttribute("0")]
internal string FullRelativeName@;
    [DebuggerBrowsableAttribute("0")]
internal string Qualifier@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Namespace@;
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal string LastIdent@;
    [CompilationMappingAttribute("4", "0")]
public string FullRelativeName { get; }
    [CompilationMappingAttribute("4", "1")]
public string Qualifier { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<string> Namespace { get; }
    [CompilationMappingAttribute("4", "3")]
public string Name { get; }
    [CompilationMappingAttribute("4", "4")]
public string LastIdent { get; }
    public Entity(string fullRelativeName, string qualifier, FSharpOption`1<string> namespace, string name, string lastIdent);
    public string get_FullRelativeName();
    public string get_Qualifier();
    public FSharpOption`1<string> get_Namespace();
    public string get_Name();
    public string get_LastIdent();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Entity obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Entity obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.EntityCache : object {
    internal Dictionary`2<string, AssemblyContentCacheEntry> dic;
    public void Clear();
    public T Locking(FSharpFunc`2<IAssemblyContentCache, T> f);
    private virtual override FSharpOption`1<AssemblyContentCacheEntry> FSharp-Compiler-SourceCodeServices-IAssemblyContentCache-TryGet(string assembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void FSharp-Compiler-SourceCodeServices-IAssemblyContentCache-Set(string assembly, AssemblyContentCacheEntry entry);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.EntityKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static EntityKind _unique_Attribute;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static EntityKind _unique_Type;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static EntityKind Attribute { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAttribute { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static EntityKind Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFunctionOrValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    private static EntityKind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal EntityKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static EntityKind get_Attribute();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAttribute();
    [CompilationMappingAttribute("8", "1")]
public static EntityKind get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "2")]
public static EntityKind NewFunctionOrValue(bool _isActivePattern);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFunctionOrValue();
    [CompilationMappingAttribute("8", "3")]
public static EntityKind NewModule(ModuleKind item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(EntityKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(EntityKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.EntityModule : object {
    internal static String[] loop@401-125(String[] targetNs, String[] sourceNs, int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] getRelativeNamespace(String[] targetNs, String[] sourceNs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] cutAutoOpenModules(FSharpOption`1<String[]> autoOpenParent, String[] candidateNs);
    internal static String[] getRelativeNs@442(String[] targetScope, FSharpOption`1<String[]> targetNamespace, FSharpOption`1<String[]> candidateNamespace, String[] ns);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Entity> tryCreate$cont@455-1(String[] targetScope, FSharpOption`1<String[]> targetNamespace, FSharpOption`1<String[]> candidateNamespace, int identCount, String[] relativeNs, String[] patternInput_0, String[] patternInput_1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Entity> tryCreate$cont@432(String[] targetScope, FSharpOption`1<String[]> targetNamespace, FSharpOption`1<String[]> requiresQualifiedAccessParent, FSharpOption`1<String[]> candidateNamespace, String[] candidate, FSharpOption`1<String[]> autoOpenParent, String[] parts, Unit unitVar);
    internal static Entity[] tryCreate(FSharpOption`1<String[]> targetNamespace, String[] targetScope, MaybeUnresolvedIdent[] partiallyQualifiedName, FSharpOption`1<String[]> requiresQualifiedAccessParent, FSharpOption`1<String[]> autoOpenParent, FSharpOption`1<String[]> candidateNamespace, String[] candidate);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.EnvMisc : object {
    [CompilationMappingAttribute("9")]
internal static int braceMatchCacheSize { get; }
    [CompilationMappingAttribute("9")]
internal static int parseFileCacheSize { get; }
    [CompilationMappingAttribute("9")]
internal static int checkFileInProjectCacheSize { get; }
    [CompilationMappingAttribute("9")]
internal static int projectCacheSizeDefault { get; }
    [CompilationMappingAttribute("9")]
internal static int frameworkTcImportsCacheStrongSize { get; }
    [CompilationMappingAttribute("9")]
internal static int maxMBDefault { get; }
    internal static int get_braceMatchCacheSize();
    internal static int get_parseFileCacheSize();
    internal static int get_checkFileInProjectCacheSize();
    internal static int get_projectCacheSizeDefault();
    internal static int get_frameworkTcImportsCacheStrongSize();
    internal static int get_maxMBDefault();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.EnvMisc2 : object {
    [CompilationMappingAttribute("9")]
internal static int maxMembers { get; }
    internal static int get_maxMembers();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.EnvMisc3 : object {
    [CompilationMappingAttribute("9")]
internal static int dataTipSpinWaitTime { get; }
    internal static int get_dataTipSpinWaitTime();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.ErrorHelpers : object {
    internal static FSharpList`1<FSharpErrorInfo> oneError@179(bool suggestNames, string mainInputFileName, Tuple`2<int, int> fileInfo, bool allErrors, bool isError, PhasedDiagnostic exn);
    internal static FSharpList`1<FSharpErrorInfo> ReportError(FSharpErrorSeverityOptions options, bool allErrors, string mainInputFileName, Tuple`2<int, int> fileInfo, Tuple`2<PhasedDiagnostic, FSharpErrorSeverity> _arg1, bool suggestNames);
    internal static FSharpErrorInfo[] CreateErrorInfos(FSharpErrorSeverityOptions options, bool allErrors, string mainInputFileName, IEnumerable`1<Tuple`2<PhasedDiagnostic, FSharpErrorSeverity>> errors, bool suggestNames);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.ErrorScope : object {
    internal FSharpList`1<FSharpErrorInfo> errors;
    internal FSharpOption`1<string> firstError;
    internal IDisposable unwindBP;
    internal IDisposable unwindEL;
    internal FSharpList`1<FSharpErrorInfo> Errors { get; }
    internal FSharpList`1<FSharpErrorInfo> Warnings { get; }
    internal FSharpList`1<FSharpErrorInfo> Diagnostics { get; }
    internal FSharpOption`1<string> FirstError { get; internal set; }
    internal FSharpList`1<FSharpErrorInfo> get_Errors();
    internal FSharpList`1<FSharpErrorInfo> get_Warnings();
    internal FSharpList`1<FSharpErrorInfo> get_Diagnostics();
    internal FSharpOption`1<string> TryGetFirstErrorText();
    internal FSharpOption`1<string> get_FirstError();
    internal void set_FirstError(FSharpOption`1<string> v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a Protect(range m, FSharpFunc`2<Unit, a> f, FSharpFunc`2<string, a> err);
    private virtual override void System-IDisposable-Dispose();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.ExprTranslationImpl : object {
    internal static a wfail(string msg, range m);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.Extensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> FSharpEntity.TryGetFullName(FSharpEntity );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> FSharpEntity.TryGetFullDisplayName(FSharpEntity );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> FSharpEntity.TryGetFullCompiledName(FSharpEntity );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<FSharpEntity> FSharpEntity.get_PublicNestedEntities(FSharpEntity );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IList`1<FSharpMemberOrFunctionOrValue> FSharpEntity.get_TryGetMembersFunctionsAndValues(FSharpEntity );
    internal static bool isOperator(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<FSharpType> FSharpMemberOrFunctionOrValue.get_FullTypeSafe(FSharpMemberOrFunctionOrValue );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> FSharpMemberOrFunctionOrValue.TryGetFullDisplayName(FSharpMemberOrFunctionOrValue );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<String[]> FSharpMemberOrFunctionOrValue.TryGetFullCompiledOperatorNameIdents(FSharpMemberOrFunctionOrValue );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<FSharpEntity> FSharpAssemblySignature.TryGetEntities(FSharpAssemblySignature );
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{ToDebuggerDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.ExternalSymbol : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ExternalSymbol(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static ExternalSymbol NewType(string _fullName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "1")]
public static ExternalSymbol NewConstructor(string _typeName, FSharpList`1<ParamTypeSymbol> _args);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstructor();
    [CompilationMappingAttribute("8", "2")]
public static ExternalSymbol NewMethod(string _typeName, string _name, FSharpList`1<ParamTypeSymbol> _paramSyms, int _genericArity);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethod();
    [CompilationMappingAttribute("8", "3")]
public static ExternalSymbol NewField(string _typeName, string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "4")]
public static ExternalSymbol NewEvent(string _typeName, string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEvent();
    [CompilationMappingAttribute("8", "5")]
public static ExternalSymbol NewProperty(string _typeName, string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ExternalSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    internal string ToDebuggerDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ExternalSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.ExternalType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPointer { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeVar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ExternalType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static ExternalType NewType(string _fullName, FSharpList`1<ExternalType> _genericArgs);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "1")]
public static ExternalType NewArray(ExternalType _inner);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArray();
    [CompilationMappingAttribute("8", "2")]
public static ExternalType NewPointer(ExternalType _inner);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPointer();
    [CompilationMappingAttribute("8", "3")]
public static ExternalType NewTypeVar(string _typeName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeVar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ExternalType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ExternalType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.ExternalTypeModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ExternalType> tryOfILType(String[] typeVarNames, ILType ilType);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpAbstractParameter : object {
    internal SlotParam info;
    internal SymbolEnv cenv;
    public FSharpOption`1<string> Name { get; }
    public FSharpType Type { get; }
    public bool IsInArg { get; }
    public bool IsOutArg { get; }
    public bool IsOptionalArg { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    internal FSharpAbstractParameter(SymbolEnv cenv, SlotParam info);
    public FSharpOption`1<string> get_Name();
    public FSharpType get_Type();
    public bool get_IsInArg();
    public bool get_IsOutArg();
    public bool get_IsOptionalArg();
    public IList`1<FSharpAttribute> get_Attributes();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpAbstractSignature : object {
    internal SlotSig info;
    internal SymbolEnv cenv;
    public IList`1<IList`1<FSharpAbstractParameter>> AbstractArguments { get; }
    public FSharpType AbstractReturnType { get; }
    public IList`1<FSharpGenericParameter> DeclaringTypeGenericParameters { get; }
    public IList`1<FSharpGenericParameter> MethodGenericParameters { get; }
    public string Name { get; }
    public FSharpType DeclaringType { get; }
    internal FSharpAbstractSignature(SymbolEnv cenv, SlotSig info);
    public IList`1<IList`1<FSharpAbstractParameter>> get_AbstractArguments();
    public FSharpType get_AbstractReturnType();
    public IList`1<FSharpGenericParameter> get_DeclaringTypeGenericParameters();
    public IList`1<FSharpGenericParameter> get_MethodGenericParameters();
    public string get_Name();
    public FSharpType get_DeclaringType();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpAccessibility : object {
    internal Accessibility a;
    internal bool isProtected@24;
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsInternal { get; }
    public bool IsProtected { get; }
    internal Accessibility Contents { get; }
    internal FSharpAccessibility(Accessibility a, FSharpOption`1<bool> isProtected);
    public bool get_IsPublic();
    public bool get_IsPrivate();
    public bool get_IsInternal();
    public bool get_IsProtected();
    internal Accessibility get_Contents();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal bool isInternalCompPath(CompilationPath x);
    [CompilerGeneratedAttribute]
internal FSharpChoice`3<Unit, Unit, Unit> |Public|Internal|Private|(Accessibility _arg1);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpAccessibilityRights : object {
    internal CcuThunk thisCcu;
    internal AccessorDomain ad;
    internal CcuThunk ThisCcu { get; }
    internal AccessorDomain Contents { get; }
    internal FSharpAccessibilityRights(CcuThunk thisCcu, AccessorDomain ad);
    internal CcuThunk get_ThisCcu();
    internal AccessorDomain get_Contents();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpActivePatternCase : FSharpSymbol {
    internal FSharpOption`1<ValRef> valOpt;
    internal TType ty;
    internal int n;
    internal SymbolEnv cenv;
    internal ActivePatternInfo apinfo;
    public string Name { get; }
    public int Index { get; }
    public range DeclarationLocation { get; }
    public FSharpActivePatternGroup Group { get; }
    public IList`1<string> XmlDoc { get; }
    public string XmlDocSig { get; }
    internal FSharpActivePatternCase(SymbolEnv cenv, ActivePatternInfo apinfo, TType ty, int n, FSharpOption`1<ValRef> valOpt, Item item);
    public string get_Name();
    public int get_Index();
    public range get_DeclarationLocation();
    public FSharpActivePatternGroup get_Group();
    public IList`1<string> get_XmlDoc();
    public string get_XmlDocSig();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpActivePatternGroup : object {
    internal FSharpOption`1<ValRef> valOpt;
    internal TType ty;
    internal SymbolEnv cenv;
    internal ActivePatternInfo apinfo;
    public FSharpOption`1<string> Name { get; }
    public IList`1<string> Names { get; }
    public bool IsTotal { get; }
    public FSharpType OverallType { get; }
    public FSharpOption`1<FSharpEntity> DeclaringEntity { get; }
    internal FSharpActivePatternGroup(SymbolEnv cenv, ActivePatternInfo apinfo, TType ty, FSharpOption`1<ValRef> valOpt);
    public FSharpOption`1<string> get_Name();
    public IList`1<string> get_Names();
    public bool get_IsTotal();
    public FSharpType get_OverallType();
    public FSharpOption`1<FSharpEntity> get_DeclaringEntity();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpAnonRecordTypeDetails : object {
    internal SymbolEnv cenv;
    internal AnonRecdTypeInfo anonInfo;
    public FSharpAssembly Assembly { get; }
    public FSharpList`1<string> EnclosingCompiledTypeNames { get; }
    public string CompiledName { get; }
    public String[] SortedFieldNames { get; }
    internal FSharpAnonRecordTypeDetails(SymbolEnv cenv, AnonRecdTypeInfo anonInfo);
    public FSharpAssembly get_Assembly();
    public FSharpList`1<string> get_EnclosingCompiledTypeNames();
    public string get_CompiledName();
    public String[] get_SortedFieldNames();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpAssembly : object {
    internal SymbolEnv cenv;
    internal CcuThunk ccu;
    internal CcuThunk RawCcuThunk { get; }
    public string QualifiedName { get; }
    [ObsoleteAttribute("This item is obsolete, it is not useful")]
public string CodeLocation { get; }
    public FSharpOption`1<string> FileName { get; }
    public string SimpleName { get; }
    public bool IsProviderGenerated { get; }
    public FSharpAssemblySignature Contents { get; }
    internal FSharpAssembly(SymbolEnv cenv, CcuThunk ccu);
    internal FSharpAssembly(TcGlobals tcGlobals, TcImports tcImports, CcuThunk ccu);
    internal CcuThunk get_RawCcuThunk();
    public string get_QualifiedName();
    public string get_CodeLocation();
    public FSharpOption`1<string> get_FileName();
    public string get_SimpleName();
    public bool get_IsProviderGenerated();
    public FSharpAssemblySignature get_Contents();
    public virtual string ToString();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpAssemblyContents : object {
    internal FSharpList`1<TypedImplFile> mimpls;
    internal SymbolEnv cenv;
    public FSharpList`1<FSharpImplementationFileContents> ImplementationFiles { get; }
    internal FSharpAssemblyContents(SymbolEnv cenv, FSharpList`1<TypedImplFile> mimpls);
    internal FSharpAssemblyContents(TcGlobals tcGlobals, CcuThunk thisCcu, FSharpOption`1<ModuleOrNamespaceType> thisCcuType, TcImports tcImports, FSharpList`1<TypedImplFile> mimpls);
    public FSharpList`1<FSharpImplementationFileContents> get_ImplementationFiles();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpAssemblySignature : object {
    internal FSharpOption`1<TopAttribs> topAttribs;
    internal FSharpOption`1<CcuThunk> optViewedCcu;
    internal ModuleOrNamespaceType mtyp;
    internal SymbolEnv cenv;
    public IList`1<FSharpEntity> Entities { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    internal FSharpAssemblySignature(SymbolEnv cenv, FSharpOption`1<TopAttribs> topAttribs, FSharpOption`1<CcuThunk> optViewedCcu, ModuleOrNamespaceType mtyp);
    internal FSharpAssemblySignature(SymbolEnv cenv, CcuThunk ccu);
    internal FSharpAssemblySignature(TcGlobals tcGlobals, CcuThunk thisCcu, ModuleOrNamespaceType thisCcuTyp, TcImports tcImports, FSharpOption`1<TopAttribs> topAttribs, ModuleOrNamespaceType contents);
    public IList`1<FSharpEntity> get_Entities();
    public IList`1<FSharpAttribute> get_Attributes();
    public FSharpOption`1<FSharpEntity> FindEntityByPath(FSharpList`1<string> path);
    public virtual string ToString();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpAttribute : object {
    internal SymbolEnv cenv;
    internal AttribInfo attrib;
    public FSharpEntity AttributeType { get; }
    public bool IsUnresolved { get; }
    public IList`1<Tuple`2<FSharpType, object>> ConstructorArguments { get; }
    public IList`1<Tuple`4<FSharpType, string, bool, object>> NamedArguments { get; }
    internal FSharpAttribute(SymbolEnv cenv, AttribInfo attrib);
    public FSharpEntity get_AttributeType();
    public bool get_IsUnresolved();
    public IList`1<Tuple`2<FSharpType, object>> get_ConstructorArguments();
    public IList`1<Tuple`4<FSharpType, string, bool, object>> get_NamedArguments();
    public string Format(FSharpDisplayContext context);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal object resolveArgObj(object arg);
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpChecker : object {
    internal bool suggestNamesForErrors;
    internal Resolver legacyReferenceResolver;
    internal BackgroundCompiler backgroundCompiler;
    internal static Lazy`1<FSharpChecker> globalInstance;
    internal MruCache`3<AnyCallerThreadToken, Tuple`3<string, int, FSharpParsingOptions>, Tuple`2[]> braceMatchCache;
    internal bool maxMemoryReached;
    internal int maxMB;
    internal FSharpEvent`1<Unit> maxMemEvent;
    internal static int init@902-19;
    internal Resolver ReferenceResolver { get; }
    internal IReactorOperations ReactorOps { get; }
    public int CurrentQueueLength { get; }
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> BeforeBackgroundFileCheck { get; }
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> FileParsed { get; }
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> FileChecked { get; }
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> ProjectChecked { get; }
    public bool ImplicitlyStartBackgroundWork { get; public set; }
    public int PauseBeforeBackgroundWork { get; public set; }
    public static int GlobalForegroundParseCountStatistic { get; }
    public static int GlobalForegroundTypeCheckCountStatistic { get; }
    public IEvent`2<FSharpHandler`1<Unit>, Unit> MaxMemoryReached { get; }
    public int MaxMemory { get; public set; }
    [ObsoleteAttribute("Please create an instance of FSharpChecker using FSharpChecker.Create")]
public static FSharpChecker Instance { get; }
    internal FrameworkImportsCache FrameworkImportsCache { get; }
    internal FSharpChecker(Resolver legacyReferenceResolver, int projectCacheSize, bool keepAssemblyContents, bool keepAllBackgroundResolutions, FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot, bool suggestNamesForErrors);
    private static FSharpChecker();
    public static FSharpChecker Create(FSharpOption`1<int> projectCacheSize, FSharpOption`1<bool> keepAssemblyContents, FSharpOption`1<bool> keepAllBackgroundResolutions, FSharpOption`1<Resolver> legacyReferenceResolver, FSharpOption`1<FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>>> tryGetMetadataSnapshot, FSharpOption`1<bool> suggestNamesForErrors);
    internal Resolver get_ReferenceResolver();
    public FSharpAsync`1<Tuple`2[]> MatchBraces(string filename, ISourceText sourceText, FSharpParsingOptions options, FSharpOption`1<string> userOpName);
    [ObsoleteAttribute("Please pass FSharpParsingOptions to MatchBraces. If necessary generate FSharpParsingOptions from FSharpProjectOptions by calling checker.GetParsingOptionsFromProjectOptions(options)")]
public FSharpAsync`1<Tuple`2[]> MatchBraces(string filename, string source, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public Tuple`2<FSharpParsingOptions, FSharpList`1<FSharpErrorInfo>> GetParsingOptionsFromProjectOptions(FSharpProjectOptions options);
    public FSharpAsync`1<FSharpParseFileResults> ParseFile(string filename, ISourceText sourceText, FSharpParsingOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpParseFileResults> ParseFileNoCache(string filename, ISourceText sourceText, FSharpParsingOptions options, FSharpOption`1<string> userOpName);
    [ObsoleteAttribute("Please call checker.ParseFile instead.  To do this, you must also pass FSharpParsingOptions instead of FSharpProjectOptions. If necessary generate FSharpParsingOptions from FSharpProjectOptions by calling checker.GetParsingOptionsFromProjectOptions(options)")]
public FSharpAsync`1<FSharpParseFileResults> ParseFileInProject(string filename, string source, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpParseFileResults> GetBackgroundParseResultsForFileInProject(string filename, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileResults>> GetBackgroundCheckResultsForFileInProject(string filename, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpOption`1<Tuple`3<FSharpParseFileResults, FSharpCheckFileResults, int>> TryGetRecentCheckResultsForFile(string filename, FSharpProjectOptions options, FSharpOption`1<ISourceText> sourceText, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`2<FSharpErrorInfo[], int>> Compile(String[] argv, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`2<FSharpErrorInfo[], int>> Compile(FSharpList`1<ParsedInput> ast, string assemblyName, string outFile, FSharpList`1<string> dependencies, FSharpOption`1<string> pdbFile, FSharpOption`1<bool> executable, FSharpOption`1<bool> noframework, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`3<FSharpErrorInfo[], int, FSharpOption`1<Assembly>>> CompileToDynamicAssembly(String[] otherFlags, FSharpOption`1<Tuple`2<TextWriter, TextWriter>> execute, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`3<FSharpErrorInfo[], int, FSharpOption`1<Assembly>>> CompileToDynamicAssembly(FSharpList`1<ParsedInput> ast, string assemblyName, FSharpList`1<string> dependencies, FSharpOption`1<Tuple`2<TextWriter, TextWriter>> execute, FSharpOption`1<bool> debug, FSharpOption`1<bool> noframework, FSharpOption`1<string> userOpName);
    public void InvalidateAll();
    internal FSharpAsync`1<Unit> ClearCachesAsync(FSharpOption`1<string> userOpName);
    internal void ClearCaches(FSharpOption`1<string> userOpName);
    internal void CheckMaxMemoryReached();
    public void ClearLanguageServiceRootCachesAndCollectAndFinalizeAllTransients();
    public void InvalidateConfiguration(FSharpProjectOptions options, FSharpOption`1<bool> startBackgroundCompileIfAlreadySeen, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Unit> NotifyProjectCleaned(FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    [ObsoleteAttribute("This member should no longer be used, please use 'CheckFileInProject'")]
public FSharpAsync`1<FSharpOption`1<FSharpCheckFileAnswer>> CheckFileInProjectAllowingStaleCachedResults(FSharpParseFileResults parsed, string filename, int fileversion, string source, FSharpProjectOptions options, FSharpOption`1<object> textSnapshotInfo, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpCheckFileAnswer> CheckFileInProject(FSharpParseFileResults parsed, string filename, int fileversion, ISourceText sourceText, FSharpProjectOptions options, FSharpOption`1<object> textSnapshotInfo, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileAnswer>> ParseAndCheckFileInProject(string filename, int fileversion, ISourceText sourceText, FSharpProjectOptions options, FSharpOption`1<object> textSnapshotInfo, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpCheckProjectResults> ParseAndCheckProject(FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`2<FSharpProjectOptions, FSharpList`1<FSharpErrorInfo>>> GetProjectOptionsFromScript(string filename, ISourceText sourceText, FSharpOption`1<DateTime> loadedTimeStamp, FSharpOption`1<String[]> otherFlags, FSharpOption`1<bool> useFsiAuxLib, FSharpOption`1<bool> useSdkRefs, FSharpOption`1<bool> assumeDotNetFramework, FSharpOption`1<object> extraProjectInfo, FSharpOption`1<long> optionsStamp, FSharpOption`1<string> userOpName);
    public FSharpProjectOptions GetProjectOptionsFromCommandLineArgs(string projectFileName, String[] argv, FSharpOption`1<DateTime> loadedTimeStamp, FSharpOption`1<object> extraProjectInfo);
    public Tuple`2<FSharpParsingOptions, FSharpList`1<FSharpErrorInfo>> GetParsingOptionsFromCommandLineArgs(FSharpList`1<string> sourceFiles, FSharpList`1<string> argv, FSharpOption`1<bool> isInteractive);
    public Tuple`2<FSharpParsingOptions, FSharpList`1<FSharpErrorInfo>> GetParsingOptionsFromCommandLineArgs(FSharpList`1<string> argv, FSharpOption`1<bool> isInteractive);
    internal void StartBackgroundCompile(FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public void CheckProjectInBackground(FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public void StopBackgroundCompile();
    public void WaitForBackgroundCompile();
    internal IReactorOperations get_ReactorOps();
    public int get_CurrentQueueLength();
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> get_BeforeBackgroundFileCheck();
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> get_FileParsed();
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> get_FileChecked();
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpOption`1<object>>>, Tuple`2<string, FSharpOption`1<object>>> get_ProjectChecked();
    public bool get_ImplicitlyStartBackgroundWork();
    public void set_ImplicitlyStartBackgroundWork(bool v);
    public int get_PauseBeforeBackgroundWork();
    public void set_PauseBeforeBackgroundWork(int v);
    public static int get_GlobalForegroundParseCountStatistic();
    public static int get_GlobalForegroundTypeCheckCountStatistic();
    public IEvent`2<FSharpHandler`1<Unit>, Unit> get_MaxMemoryReached();
    public int get_MaxMemory();
    public void set_MaxMemory(int v);
    public static FSharpChecker get_Instance();
    internal FrameworkImportsCache get_FrameworkImportsCache();
    public Tuple`2<FSharpTokenInfo[], FSharpTokenizerLexState> TokenizeLine(string line, FSharpTokenizerLexState state);
    public FSharpTokenInfo[][] TokenizeFile(string source);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.FSharpCheckerResultsSettings : object {
    [CompilationMappingAttribute("9")]
internal static int getToolTipTextSize { get; }
    [CompilationMappingAttribute("9")]
internal static int maxTypeCheckErrorsOutOfProjectContext { get; }
    [CompilationMappingAttribute("9")]
internal static long maxTimeShareMilliseconds { get; }
    [CompilationMappingAttribute("9")]
internal static string matchValue@55 { get; }
    [CompilationMappingAttribute("9")]
internal static string defaultFSharpBinariesDir { get; }
    internal static int get_getToolTipTextSize();
    internal static int get_maxTypeCheckErrorsOutOfProjectContext();
    internal static long get_maxTimeShareMilliseconds();
    internal static string get_matchValue@55();
    internal static string get_defaultFSharpBinariesDir();
}
[RequireQualifiedAccessAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.FSharpCheckFileAnswer : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpCheckFileAnswer _unique_Aborted;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpCheckFileAnswer Aborted { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAborted { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSucceeded { get; }
    private static FSharpCheckFileAnswer();
    [CompilationMappingAttribute("8", "0")]
public static FSharpCheckFileAnswer get_Aborted();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAborted();
    [CompilationMappingAttribute("8", "1")]
public static FSharpCheckFileAnswer NewSucceeded(FSharpCheckFileResults item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSucceeded();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpCheckFileAnswer obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpCheckFileResults : object {
    internal FSharpOption`1<TypeCheckInfo> scopeOptX;
    internal bool keepAssemblyContents;
    internal string filename;
    internal FSharpErrorInfo[] errors;
    internal String[] dependencyFiles;
    internal FSharpOption`1<IncrementalBuilder> builderX;
    internal FSharpOption`1<Tuple`3<TypeCheckInfo, FSharpOption`1<IncrementalBuilder>, IReactorOperations>> details;
    public FSharpErrorInfo[] Errors { get; }
    public bool HasFullTypeCheckInfo { get; }
    public FSharpAssemblySignature PartialAssemblySignature { get; }
    public FSharpProjectContext ProjectContext { get; }
    public String[] DependencyFiles { get; }
    public FSharpOption`1<FSharpImplementationFileContents> ImplementationFile { get; }
    public FSharpOpenDeclaration[] OpenDeclarations { get; }
    internal FSharpCheckFileResults(string filename, FSharpErrorInfo[] errors, FSharpOption`1<TypeCheckInfo> scopeOptX, String[] dependencyFiles, FSharpOption`1<IncrementalBuilder> builderX, IReactorOperations reactorOpsX, bool keepAssemblyContents);
    public FSharpErrorInfo[] get_Errors();
    public bool get_HasFullTypeCheckInfo();
    internal FSharpOption`1<TcImports> TryGetCurrentTcImports();
    public FSharpAsync`1<FSharpDeclarationListInfo> GetDeclarationListInfo(FSharpOption`1<FSharpParseFileResults> ParsedFileResultsOpt, int line, string lineText, PartialLongName partialName, FSharpOption`1<FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>>> getAllEntities, FSharpOption`1<FSharpFunc`2<Tuple`2<object, range>, bool>> hasTextChangedSinceLastTypecheck, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpList`1<FSharpList`1<FSharpSymbolUse>>> GetDeclarationListSymbols(FSharpOption`1<FSharpParseFileResults> ParsedFileResultsOpt, int line, string lineText, PartialLongName partialName, FSharpOption`1<FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>>> getAllEntities, FSharpOption`1<FSharpFunc`2<Tuple`2<object, range>, bool>> hasTextChangedSinceLastTypecheck, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpToolTipText`1<Layout>> GetStructuredToolTipText(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names, int tokenTag, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpToolTipText`1<string>> GetToolTipText(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names, int tokenTag, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpOption`1<string>> GetF1Keyword(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpMethodGroup> GetMethods(int line, int colAtEndOfNames, string lineText, FSharpOption`1<FSharpList`1<string>> names, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpFindDeclResult> GetDeclarationLocation(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names, FSharpOption`1<bool> preferFlag, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpOption`1<FSharpSymbolUse>> GetSymbolUseAtLocation(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpOption`1<FSharpList`1<FSharpSymbolUse>>> GetMethodsAsSymbols(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names, FSharpOption`1<string> userOpName);
    internal FSharpAsync`1<FSharpOption`1<FSharpSymbol>> GetSymbolAtLocation(int line, int colAtEndOfNames, string lineStr, FSharpList`1<string> names, FSharpOption`1<string> userOpName);
    [ObsoleteAttribute("This member has been replaced by GetFormatSpecifierLocationsAndArity, which returns both range and arity of specifiers")]
public range[] GetFormatSpecifierLocations();
    public Tuple`2[] GetFormatSpecifierLocationsAndArity();
    public Tuple`2[] GetSemanticClassification(FSharpOption`1<range> range);
    public FSharpAssemblySignature get_PartialAssemblySignature();
    public FSharpProjectContext get_ProjectContext();
    public String[] get_DependencyFiles();
    public FSharpAsync`1<FSharpSymbolUse[]> GetAllUsesOfAllSymbolsInFile();
    public FSharpAsync`1<FSharpSymbolUse[]> GetUsesOfSymbolInFile(FSharpSymbol symbol);
    internal FSharpAsync`1<EntityRef[]> GetVisibleNamespacesAndModulesAtPoint(pos pos);
    internal FSharpAsync`1<bool> IsRelativeNameResolvable(pos cursorPos, FSharpList`1<string> plid, Item item, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<bool> IsRelativeNameResolvableFromSymbol(pos cursorPos, FSharpList`1<string> plid, FSharpSymbol symbol, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpOption`1<FSharpDisplayContext>> GetDisplayContextForPos(pos pos);
    public FSharpOption`1<FSharpImplementationFileContents> get_ImplementationFile();
    public FSharpOpenDeclaration[] get_OpenDeclarations();
    public virtual string ToString();
    internal static FSharpCheckFileResults MakeEmpty(string filename, FSharpErrorInfo[] creationErrors, IReactorOperations reactorOps, bool keepAssemblyContents);
    internal static FSharpErrorInfo[] JoinErrors(bool isIncompleteTypeCheckEnvironment, FSharpErrorInfo[] creationErrors, FSharpErrorInfo[] parseErrors, FSharpErrorInfo[] tcErrors);
    internal static FSharpCheckFileResults Make(string mainInputFileName, string projectFileName, TcConfig tcConfig, TcGlobals tcGlobals, bool isIncompleteTypeCheckEnvironment, IncrementalBuilder builder, String[] dependencyFiles, FSharpErrorInfo[] creationErrors, FSharpErrorInfo[] parseErrors, FSharpErrorInfo[] tcErrors, IReactorOperations reactorOps, bool keepAssemblyContents, ModuleOrNamespaceType ccuSigForFile, CcuThunk thisCcu, TcImports tcImports, AccessorDomain tcAccessRights, TcResolutions sResolutions, TcSymbolUses sSymbolUses, NameResolutionEnv sFallback, FSharpOption`1<LoadClosure> loadClosure, FSharpOption`1<TypedImplFile> implFileOpt, OpenDeclaration[] openDeclarations);
    internal static FSharpAsync`1<FSharpCheckFileAnswer> CheckOneFile(FSharpParseFileResults parseResults, ISourceText sourceText, string mainInputFileName, string projectFileName, TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, TcState tcState, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, FSharpOption`1<LoadClosure> loadClosure, Tuple`2[] backgroundDiagnostics, IReactorOperations reactorOps, FSharpOption`1<object> textSnapshotInfo, string userOpName, bool isIncompleteTypeCheckEnvironment, IncrementalBuilder builder, String[] dependencyFiles, FSharpErrorInfo[] creationErrors, FSharpErrorInfo[] parseErrors, bool keepAssemblyContents, bool suggestNamesForErrors);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpAsync`1<a> reactorOp(string userOpName, string opName, a dflt, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<TypeCheckInfo, a>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal a threadSafeOp(FSharpFunc`2<Unit, a> dflt, FSharpFunc`2<TypeCheckInfo, a> f);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpCheckProjectResults : object {
    internal FSharpOption`1<TcConfig> tcConfigOption;
    internal string projectFileName;
    internal bool keepAssemblyContents;
    internal FSharpErrorInfo[] errors;
    internal FSharpOption`1<Tuple`8<TcGlobals, TcImports, CcuThunk, ModuleOrNamespaceType, FSharpList`1<TcSymbolUses>, FSharpOption`1<TopAttribs>, FSharpOption`1<IRawFSharpAssemblyData>, Tuple`4<ILAssemblyRef, AccessorDomain, FSharpOption`1<FSharpList`1<TypedImplFile>>, String[]>>> details;
    public FSharpErrorInfo[] Errors { get; }
    public bool HasCriticalErrors { get; }
    public FSharpAssemblySignature AssemblySignature { get; }
    internal Tuple`4<TcGlobals, CcuThunk, TcImports, FSharpList`1<TypedImplFile>> TypedImplementionFiles { get; }
    public FSharpAssemblyContents AssemblyContents { get; }
    public FSharpProjectContext ProjectContext { get; }
    internal FSharpOption`1<IRawFSharpAssemblyData> RawFSharpAssemblyData { get; }
    public String[] DependencyFiles { get; }
    internal string AssemblyFullName { get; }
    internal FSharpCheckProjectResults(string projectFileName, FSharpOption`1<TcConfig> tcConfigOption, bool keepAssemblyContents, FSharpErrorInfo[] errors, FSharpOption`1<Tuple`8<TcGlobals, TcImports, CcuThunk, ModuleOrNamespaceType, FSharpList`1<TcSymbolUses>, FSharpOption`1<TopAttribs>, FSharpOption`1<IRawFSharpAssemblyData>, Tuple`4<ILAssemblyRef, AccessorDomain, FSharpOption`1<FSharpList`1<TypedImplFile>>, String[]>>> details);
    public FSharpErrorInfo[] get_Errors();
    public bool get_HasCriticalErrors();
    public FSharpAssemblySignature get_AssemblySignature();
    internal Tuple`4<TcGlobals, CcuThunk, TcImports, FSharpList`1<TypedImplFile>> get_TypedImplementionFiles();
    public FSharpAssemblyContents get_AssemblyContents();
    public FSharpAssemblyContents GetOptimizedAssemblyContents();
    public FSharpAsync`1<FSharpSymbolUse[]> GetUsesOfSymbol(FSharpSymbol symbol);
    public FSharpAsync`1<FSharpSymbolUse[]> GetAllUsesOfAllSymbols();
    public FSharpProjectContext get_ProjectContext();
    internal FSharpOption`1<IRawFSharpAssemblyData> get_RawFSharpAssemblyData();
    public String[] get_DependencyFiles();
    internal string get_AssemblyFullName();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal Tuple`8<TcGlobals, TcImports, CcuThunk, ModuleOrNamespaceType, FSharpList`1<TcSymbolUses>, FSharpOption`1<TopAttribs>, FSharpOption`1<IRawFSharpAssemblyData>, Tuple`4<ILAssemblyRef, AccessorDomain, FSharpOption`1<FSharpList`1<TypedImplFile>>, String[]>> getDetails();
    [CompilerGeneratedAttribute]
internal TcConfig getTcConfig();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpDeclarationListInfo : object {
    internal bool isForType;
    internal bool isError;
    internal FSharpDeclarationListItem[] declarations;
    internal static String[] fsharpNamespace;
    internal static int init@547-15;
    public FSharpDeclarationListItem[] Items { get; }
    public bool IsForType { get; }
    public bool IsError { get; }
    public static FSharpDeclarationListInfo Empty { get; }
    internal FSharpDeclarationListInfo(FSharpDeclarationListItem[] declarations, bool isForType, bool isError);
    private static FSharpDeclarationListInfo();
    public FSharpDeclarationListItem[] get_Items();
    public bool get_IsForType();
    public bool get_IsError();
    internal static FSharpDeclarationListInfo Create(InfoReader infoReader, range m, DisplayEnv denv, FSharpFunc`2<Item, FSharpOption`1<FSharpAccessibility>> getAccessibility, FSharpList`1<CompletionItem> items, IReactorOperations reactor, FSharpOption`1<String[]> currentNamespace, bool isAttributeApplicationContex);
    internal static FSharpDeclarationListInfo Error(string message);
    public static FSharpDeclarationListInfo get_Empty();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpDeclarationListItem : object {
    internal int priority;
    internal FSharpOption`1<string> namespaceToOpen;
    internal string nameInCode;
    internal string name;
    internal CompletionItemKind kind;
    internal bool isResolved;
    internal bool isOwnMember;
    internal FSharpChoice`2<Tuple`5<FSharpList`1<CompletionItem>, InfoReader, range, DisplayEnv, IReactorOperations>, FSharpToolTipText`1<Layout>> info;
    internal FSharpGlyph glyph;
    internal string fullName;
    internal FSharpOption`1<FSharpAccessibility> accessibility;
    internal FSharpOption`1<FSharpToolTipText`1<Layout>> descriptionTextHolder;
    internal Task task;
    public string Name { get; }
    public string NameInCode { get; }
    public FSharpAsync`1<FSharpToolTipText`1<Layout>> StructuredDescriptionTextAsync { get; }
    public FSharpAsync`1<FSharpToolTipText`1<string>> DescriptionTextAsync { get; }
    public FSharpToolTipText`1<Layout> StructuredDescriptionText { get; }
    public FSharpToolTipText`1<string> DescriptionText { get; }
    public FSharpGlyph Glyph { get; }
    public FSharpOption`1<FSharpAccessibility> Accessibility { get; }
    public CompletionItemKind Kind { get; }
    public bool IsOwnMember { get; }
    public int MinorPriority { get; }
    public string FullName { get; }
    public bool IsResolved { get; }
    public FSharpOption`1<string> NamespaceToOpen { get; }
    internal FSharpDeclarationListItem(string name, string nameInCode, string fullName, FSharpGlyph glyph, FSharpChoice`2<Tuple`5<FSharpList`1<CompletionItem>, InfoReader, range, DisplayEnv, IReactorOperations>, FSharpToolTipText`1<Layout>> info, FSharpOption`1<FSharpAccessibility> accessibility, CompletionItemKind kind, bool isOwnMember, int priority, bool isResolved, FSharpOption`1<string> namespaceToOpen);
    public string get_Name();
    public string get_NameInCode();
    public FSharpAsync`1<FSharpToolTipText`1<Layout>> get_StructuredDescriptionTextAsync();
    public FSharpAsync`1<FSharpToolTipText`1<string>> get_DescriptionTextAsync();
    public FSharpToolTipText`1<Layout> get_StructuredDescriptionText();
    public FSharpToolTipText`1<string> get_DescriptionText();
    public FSharpGlyph get_Glyph();
    public FSharpOption`1<FSharpAccessibility> get_Accessibility();
    public CompletionItemKind get_Kind();
    public bool get_IsOwnMember();
    public int get_MinorPriority();
    public string get_FullName();
    public bool get_IsResolved();
    public FSharpOption`1<string> get_NamespaceToOpen();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpDelegateSignature : object {
    internal SlotSig info;
    internal SymbolEnv cenv;
    public IList`1<Tuple`2<FSharpOption`1<string>, FSharpType>> DelegateArguments { get; }
    public FSharpType DelegateReturnType { get; }
    internal FSharpDelegateSignature(SymbolEnv cenv, SlotSig info);
    public IList`1<Tuple`2<FSharpOption`1<string>, FSharpType>> get_DelegateArguments();
    public FSharpType get_DelegateReturnType();
    public virtual string ToString();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpDisplayContext : object {
    internal FSharpFunc`2<TcGlobals, DisplayEnv> denv;
    public static FSharpDisplayContext Empty { get; }
    internal FSharpDisplayContext(FSharpFunc`2<TcGlobals, DisplayEnv> denv);
    internal DisplayEnv Contents(TcGlobals g);
    public static FSharpDisplayContext get_Empty();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.FSharpEnclosingEntityKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpEnclosingEntityKind _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpEnclosingEntityKind _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpEnclosingEntityKind _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpEnclosingEntityKind _unique_Exception;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpEnclosingEntityKind _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpEnclosingEntityKind _unique_Record;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpEnclosingEntityKind _unique_Enum;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpEnclosingEntityKind _unique_DU;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpEnclosingEntityKind Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpEnclosingEntityKind Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpEnclosingEntityKind Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpEnclosingEntityKind Exception { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpEnclosingEntityKind Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpEnclosingEntityKind Record { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpEnclosingEntityKind Enum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpEnclosingEntityKind DU { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDU { get; }
    private static FSharpEnclosingEntityKind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpEnclosingEntityKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpEnclosingEntityKind get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "1")]
public static FSharpEnclosingEntityKind get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "2")]
public static FSharpEnclosingEntityKind get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "3")]
public static FSharpEnclosingEntityKind get_Exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilationMappingAttribute("8", "4")]
public static FSharpEnclosingEntityKind get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "5")]
public static FSharpEnclosingEntityKind get_Record();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilationMappingAttribute("8", "6")]
public static FSharpEnclosingEntityKind get_Enum();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnum();
    [CompilationMappingAttribute("8", "7")]
public static FSharpEnclosingEntityKind get_DU();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDU();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpEnclosingEntityKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpEnclosingEntityKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpEntity : FSharpSymbol {
    internal EntityRef entity;
    internal SymbolEnv cenv;
    internal EntityRef Entity { get; }
    public string LogicalName { get; }
    public string CompiledName { get; }
    public string DisplayName { get; }
    public string AccessPath { get; }
    public FSharpOption`1<FSharpEntity> DeclaringEntity { get; }
    public FSharpOption`1<string> Namespace { get; }
    public string QualifiedName { get; }
    public string FullName { get; }
    public FSharpOption`1<string> TryFullName { get; }
    public range DeclarationLocation { get; }
    public IList`1<FSharpGenericParameter> GenericParameters { get; }
    public bool IsMeasure { get; }
    public bool IsFSharpModule { get; }
    public bool HasFSharpModuleSuffix { get; }
    public bool IsValueType { get; }
    public bool IsArrayType { get; }
    public int ArrayRank { get; }
    public bool IsProvided { get; }
    public bool IsProvidedAndErased { get; }
    public bool IsStaticInstantiation { get; }
    public bool IsProvidedAndGenerated { get; }
    public bool IsClass { get; }
    public bool IsByRef { get; }
    public bool IsOpaque { get; }
    public bool IsInterface { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsFSharpExceptionDeclaration { get; }
    public bool IsUnresolved { get; }
    public bool IsFSharp { get; }
    public bool IsFSharpAbbreviation { get; }
    public bool IsFSharpRecord { get; }
    public bool IsFSharpUnion { get; }
    public bool HasAssemblyCodeRepresentation { get; }
    public FSharpDelegateSignature FSharpDelegateSignature { get; }
    public FSharpAccessibility Accessibility { get; }
    public FSharpAccessibility RepresentationAccessibility { get; }
    public IList`1<FSharpType> DeclaredInterfaces { get; }
    public IList`1<FSharpType> AllInterfaces { get; }
    public bool IsAttributeType { get; }
    internal bool IsDisposableType { get; }
    public FSharpOption`1<FSharpType> BaseType { get; }
    public bool UsesPrefixDisplay { get; }
    public bool IsNamespace { get; }
    [ObsoleteAttribute("Renamed to MembersFunctionsAndValues")]
public IList`1<FSharpMemberOrFunctionOrValue> MembersOrValues { get; }
    public IList`1<FSharpMemberOrFunctionOrValue> MembersFunctionsAndValues { get; }
    public string XmlDocSig { get; }
    public IList`1<string> XmlDoc { get; }
    public IList`1<FSharpStaticParameter> StaticParameters { get; }
    public IList`1<FSharpEntity> NestedEntities { get; }
    public IList`1<FSharpUnionCase> UnionCases { get; }
    [ObsoleteAttribute("Renamed to FSharpFields")]
public IList`1<FSharpField> RecordFields { get; }
    public IList`1<FSharpField> FSharpFields { get; }
    public FSharpType AbbreviatedType { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public FSharpList`1<string> AllCompilationPaths { get; }
    public FSharpList`1<FSharpActivePatternCase> ActivePatternCases { get; }
    internal FSharpEntity(SymbolEnv cenv, EntityRef entity);
    internal EntityRef get_Entity();
    public string get_LogicalName();
    public string get_CompiledName();
    public string get_DisplayName();
    public string get_AccessPath();
    public FSharpOption`1<FSharpEntity> get_DeclaringEntity();
    public FSharpOption`1<string> get_Namespace();
    public string get_QualifiedName();
    public string get_FullName();
    public FSharpOption`1<string> get_TryFullName();
    public range get_DeclarationLocation();
    public IList`1<FSharpGenericParameter> get_GenericParameters();
    public bool get_IsMeasure();
    public bool get_IsFSharpModule();
    public bool get_HasFSharpModuleSuffix();
    public bool get_IsValueType();
    public bool get_IsArrayType();
    public int get_ArrayRank();
    public bool get_IsProvided();
    public bool get_IsProvidedAndErased();
    public bool get_IsStaticInstantiation();
    public bool get_IsProvidedAndGenerated();
    public bool get_IsClass();
    public bool get_IsByRef();
    public bool get_IsOpaque();
    public bool get_IsInterface();
    public bool get_IsDelegate();
    public bool get_IsEnum();
    public bool get_IsFSharpExceptionDeclaration();
    public bool get_IsUnresolved();
    public bool get_IsFSharp();
    public bool get_IsFSharpAbbreviation();
    public bool get_IsFSharpRecord();
    public bool get_IsFSharpUnion();
    public bool get_HasAssemblyCodeRepresentation();
    public FSharpDelegateSignature get_FSharpDelegateSignature();
    public FSharpAccessibility get_Accessibility();
    public FSharpAccessibility get_RepresentationAccessibility();
    public IList`1<FSharpType> get_DeclaredInterfaces();
    public IList`1<FSharpType> get_AllInterfaces();
    public bool get_IsAttributeType();
    internal bool get_IsDisposableType();
    public FSharpOption`1<FSharpType> get_BaseType();
    public bool get_UsesPrefixDisplay();
    public bool get_IsNamespace();
    public IList`1<FSharpMemberOrFunctionOrValue> get_MembersOrValues();
    public IList`1<FSharpMemberOrFunctionOrValue> get_MembersFunctionsAndValues();
    public string get_XmlDocSig();
    public IList`1<string> get_XmlDoc();
    public IList`1<FSharpStaticParameter> get_StaticParameters();
    public IList`1<FSharpEntity> get_NestedEntities();
    public IList`1<FSharpUnionCase> get_UnionCases();
    public IList`1<FSharpField> get_RecordFields();
    public IList`1<FSharpField> get_FSharpFields();
    public FSharpType get_AbbreviatedType();
    public IList`1<FSharpAttribute> get_Attributes();
    public FSharpList`1<string> get_AllCompilationPaths();
    public FSharpList`1<FSharpActivePatternCase> get_ActivePatternCases();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal bool isResolvedAndFSharp();
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal bool isResolved();
    [CompilerGeneratedAttribute]
internal void checkIsResolved();
    [CompilerGeneratedAttribute]
internal bool isDefinedInFSharpCore();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpErrorInfo : object {
    internal string subcategory;
    internal FSharpErrorSeverity severity;
    internal pos s;
    internal string message;
    internal string fileName;
    internal int errorNum;
    internal pos e;
    internal int StartLine { get; }
    public int StartLineAlternate { get; }
    internal int EndLine { get; }
    public int EndLineAlternate { get; }
    public int StartColumn { get; }
    public int EndColumn { get; }
    public FSharpErrorSeverity Severity { get; }
    public string Message { get; }
    public string Subcategory { get; }
    public string FileName { get; }
    public int ErrorNumber { get; }
    internal FSharpErrorInfo(string fileName, pos s, pos e, FSharpErrorSeverity severity, string message, string subcategory, int errorNum);
    internal int get_StartLine();
    public int get_StartLineAlternate();
    internal int get_EndLine();
    public int get_EndLineAlternate();
    public int get_StartColumn();
    public int get_EndColumn();
    public FSharpErrorSeverity get_Severity();
    public string get_Message();
    public string get_Subcategory();
    public string get_FileName();
    public int get_ErrorNumber();
    internal FSharpErrorInfo WithStart(pos newStart);
    internal FSharpErrorInfo WithEnd(pos newEnd);
    public virtual string ToString();
    internal static FSharpErrorInfo CreateFromException(PhasedDiagnostic exn, bool isError, range fallbackRange, bool suggestNames);
    internal static FSharpErrorInfo CreateFromExceptionAndAdjustEof(PhasedDiagnostic exn, bool isError, range fallbackRange, Tuple`2<int, int> lastPosInFile, bool suggestNames);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.FSharpErrorSeverity : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpErrorSeverity _unique_Warning;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpErrorSeverity _unique_Error;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpErrorSeverity Warning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWarning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpErrorSeverity Error { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsError { get; }
    private static FSharpErrorSeverity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpErrorSeverity(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpErrorSeverity get_Warning();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWarning();
    [CompilationMappingAttribute("8", "1")]
public static FSharpErrorSeverity get_Error();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpErrorSeverity obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpErrorSeverity obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpExpr : object {
    internal TType ty;
    internal range m;
    internal FSharpOption`1<FSharpFunc`2<Unit, FSharpExpr>> f;
    internal E e;
    internal SymbolEnv cenv@127;
    public range Range { get; }
    public FSharpType Type { get; }
    internal SymbolEnv cenv { get; }
    internal E E { get; }
    public FSharpList`1<FSharpExpr> ImmediateSubExpressions { get; }
    internal FSharpExpr(SymbolEnv cenv, FSharpOption`1<FSharpFunc`2<Unit, FSharpExpr>> f, E e, range m, TType ty);
    public range get_Range();
    public FSharpType get_Type();
    internal SymbolEnv get_cenv();
    internal E get_E();
    public virtual string ToString();
    public FSharpList`1<FSharpExpr> get_ImmediateSubExpressions();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.FSharpExprConvert : object {
    internal static bool IsStaticInitializationField(RecdFieldRef rfref);
    internal static FSharpOption`1<Unit> |StaticInitializationCheck|_|(Expr e);
    internal static FSharpOption`1<Unit> |StaticInitializationCount|_|(Expr e);
    internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<range, FSharpFunc`2<TType, FSharpFunc`2<Expr, Expr>>>>> |ILUnaryOp|_|(ILInstr e);
    internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<range, FSharpFunc`2<TType, FSharpFunc`2<Expr, FSharpFunc`2<Expr, Expr>>>>>> |ILBinaryOp|_|(ILInstr e);
    internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<range, FSharpFunc`2<TType, FSharpFunc`2<Expr, Expr>>>>> |ILConvertOp|_|(ILInstr e);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<range, FSharpFunc`2<TType, FSharpFunc`2<Expr, Expr>>>>> |TTypeConvOp|_|$cont@286-1(TcGlobals g, EntityRef tcref, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<range, FSharpFunc`2<TType, FSharpFunc`2<Expr, Expr>>>>> |TTypeConvOp|_|$cont@286(TcGlobals g, EntityRef tcref, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<range, FSharpFunc`2<TType, FSharpFunc`2<Expr, Expr>>>>> |TTypeConvOp|_|(SymbolEnv cenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpType ConvILTypeRefApp(SymbolEnv cenv, range m, ILTypeRef tref, FSharpList`1<TType> tyargs);
    [CompilerGeneratedAttribute]
internal static Expr exprOfExprAddr$cont@323(SymbolEnv cenv, Expr expr, range m, ILArrayShape shape, FSharpList`1<Expr> idxs, TType elemty, Expr arr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr exprOfExprAddr(SymbolEnv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr Mk2(SymbolEnv cenv, Expr orig, E e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr ConvExpr(SymbolEnv cenv, ExprTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvExprLinear(SymbolEnv cenv, ExprTranslationEnv env, Expr expr, FSharpFunc`2<FSharpExpr, E> contf);
    [CompilerGeneratedAttribute]
internal static E func1@1-27(FSharpExpr dtreeR, FSharpList`1<Tuple`2<FSharpList`1<FSharpMemberOrFunctionOrValue>, FSharpExpr>> targetsR);
    [CompilerGeneratedAttribute]
internal static E func1@1-28(FSharpUnionCase mkR, FSharpType typR, FSharpExpr e1R, FSharpExpr e2R);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvExprPrimLinear(SymbolEnv cenv, ExprTranslationEnv env, Expr expr, FSharpFunc`2<E, E> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvModuleValueOrMemberUseLinear(SymbolEnv cenv, ExprTranslationEnv env, Expr expr, ValRef vref, ValUseFlag vFlags, FSharpList`1<TType> tyargs, FSharpList`1<Expr> curriedArgs, FSharpFunc`2<E, E> contf);
    internal static FSharpList`1<FSharpObjectExprOverride> ConvertMethods@550(SymbolEnv cenv, IEnumerable`1<ObjExprMethod> methods);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvExprPrim(SymbolEnv cenv, ExprTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<Tuple`2<FSharpMemberOrFunctionOrValue, FSharpExpr>>, ExprTranslationEnv> ConvLetBind(SymbolEnv cenv, ExprTranslationEnv env, Binding bind);
    internal static E makeCall@895(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<TType> methTypeArgs, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> callArgs, bool isNewObj, FSharpMemberOrFunctionOrValue minfo);
    internal static E makeFSCall@898(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<TType> methTypeArgs, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> callArgs, bool isNewObj, TType enclosingType, bool isMember, ValRef vr);
    internal static E makeFSExpr@908(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<TType> methTypeArgs, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> callArgs, bool isNewObj, bool isPropGet, bool isProp, EntityRef tcref, FSharpOption`1<string> subClass, TType enclosingType, bool isMember, ValRef vr);
    [CompilerGeneratedAttribute]
internal static E ConvILCall$cont@1043(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<TType> methTypeArgs, range m, ILMethodRef ilMethRef, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> callArgs, bool isNewObj, bool isPropGet, bool isProp, EntityRef tcref, FSharpOption`1<string> subClass, TType enclosingType, FSharpOption`1<string> memberParentName, string logicalName, bool isMember, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvILCall(SymbolEnv cenv, ExprTranslationEnv env, bool isNewObj, ValUseFlag valUseFlags, ILMethodRef ilMethRef, FSharpList`1<TType> enclTypeArgs, FSharpList`1<TType> methTypeArgs, FSharpList`1<Expr> callArgs, range m);
    [CompilerGeneratedAttribute]
internal static E func1@1-29(FSharpMemberOrFunctionOrValue v, bool isNewObj, FSharpList`1<FSharpType> enclTyArgsR, FSharpList`1<FSharpType> methTyArgsR, FSharpOption`1<FSharpExpr> objR, FSharpList`1<FSharpExpr> callArgsR);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvObjectModelCallLinear(SymbolEnv cenv, ExprTranslationEnv env, bool isNewObj, FSharpMemberOrFunctionOrValue v, FSharpList`1<TType> enclTyArgs, FSharpList`1<TType> methTyArgs, FSharpList`1<Expr> callArgs, FSharpFunc`2<E, E> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpExpr> ConvExprs(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvExprsLinear(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<Expr> args, FSharpFunc`2<FSharpList`1<FSharpExpr>, E> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvTargetsLinear(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<DecisionTreeTarget> tgs, FSharpFunc`2<FSharpList`1<Tuple`2<FSharpList`1<FSharpMemberOrFunctionOrValue>, FSharpExpr>>, E> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvValRef(SymbolEnv cenv, ExprTranslationEnv env, range m, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMemberOrFunctionOrValue ConvVal(SymbolEnv cenv, Val v);
    [CompilerGeneratedAttribute]
internal static E ConvConst$cont@1140(SymbolEnv cenv, Const c, TType ty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvConst(SymbolEnv cenv, ExprTranslationEnv env, range m, Const c, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr ConvDecisionTree(SymbolEnv cenv, ExprTranslationEnv env, TType dtreeRetTy, DecisionTree x, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvDecisionTreePrim(SymbolEnv cenv, ExprTranslationEnv env, TType dtreeRetTy, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr ConvExprOnDemand(SymbolEnv cenv, ExprTranslationEnv env, Expr expr);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpField : FSharpSymbol {
    internal FSharpFieldData d;
    internal SymbolEnv cenv;
    public FSharpOption`1<FSharpEntity> DeclaringEntity { get; }
    public bool IsUnresolved { get; }
    public bool IsMutable { get; }
    public bool IsLiteral { get; }
    public FSharpOption`1<object> LiteralValue { get; }
    public bool IsVolatile { get; }
    public bool IsDefaultValue { get; }
    public bool IsAnonRecordField { get; }
    public Tuple`3<FSharpAnonRecordTypeDetails, FSharpType[], int> AnonRecordFieldDetails { get; }
    public string XmlDocSig { get; }
    public IList`1<string> XmlDoc { get; }
    public FSharpType FieldType { get; }
    public bool IsStatic { get; }
    public string Name { get; }
    public bool IsCompilerGenerated { get; }
    public bool IsNameGenerated { get; }
    public range DeclarationLocation { get; }
    public IList`1<FSharpAttribute> FieldAttributes { get; }
    public IList`1<FSharpAttribute> PropertyAttributes { get; }
    public FSharpAccessibility Accessibility { get; }
    internal FSharpFieldData V { get; }
    internal FSharpField(SymbolEnv cenv, FSharpFieldData d);
    internal FSharpField(SymbolEnv cenv, UnionCaseRef ucref, int n);
    internal FSharpField(SymbolEnv cenv, RecdFieldRef rfref);
    public FSharpOption`1<FSharpEntity> get_DeclaringEntity();
    public bool get_IsUnresolved();
    public bool get_IsMutable();
    public bool get_IsLiteral();
    public FSharpOption`1<object> get_LiteralValue();
    public bool get_IsVolatile();
    public bool get_IsDefaultValue();
    public bool get_IsAnonRecordField();
    public Tuple`3<FSharpAnonRecordTypeDetails, FSharpType[], int> get_AnonRecordFieldDetails();
    public string get_XmlDocSig();
    public IList`1<string> get_XmlDoc();
    public FSharpType get_FieldType();
    public bool get_IsStatic();
    public string get_Name();
    public bool get_IsCompilerGenerated();
    public bool get_IsNameGenerated();
    public range get_DeclarationLocation();
    public IList`1<FSharpAttribute> get_FieldAttributes();
    public IList`1<FSharpAttribute> get_PropertyAttributes();
    public FSharpAccessibility get_Accessibility();
    internal FSharpFieldData get_V();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal void checkIsResolved();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.SourceCodeServices.FSharpFieldData : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAnonField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsILField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsRecdOrClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnion { get; }
    internal FSharpChoice`3<RecdField, ILFieldInfo, Tuple`4<AnonRecdTypeInfo, FSharpList`1<TType>, int, range>> TryRecdField { get; }
    internal FSharpOption`1<EntityRef> TryDeclaringTyconRef { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFieldData(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static FSharpFieldData NewAnonField(AnonRecdTypeInfo item1, FSharpList`1<TType> item2, int item3, range item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAnonField();
    [CompilationMappingAttribute("8", "1")]
internal static FSharpFieldData NewILField(ILFieldInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsILField();
    [CompilationMappingAttribute("8", "2")]
internal static FSharpFieldData NewRecdOrClass(RecdFieldRef item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsRecdOrClass();
    [CompilationMappingAttribute("8", "3")]
internal static FSharpFieldData NewUnion(UnionCaseRef item1, int item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal FSharpChoice`3<RecdField, ILFieldInfo, Tuple`4<AnonRecdTypeInfo, FSharpList`1<TType>, int, range>> get_TryRecdField();
    internal FSharpOption`1<EntityRef> get_TryDeclaringTyconRef();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.FSharpFileUtilities : object {
    public static bool isScriptFile(string fileName);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.FSharpFindDeclFailureReason : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpFindDeclFailureReason _unique_NoSourceCode;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpFindDeclFailureReason NoSourceCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoSourceCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProvidedType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProvidedMember { get; }
    private static FSharpFindDeclFailureReason();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFindDeclFailureReason(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpFindDeclFailureReason NewUnknown(string _message);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknown();
    [CompilationMappingAttribute("8", "1")]
public static FSharpFindDeclFailureReason get_NoSourceCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoSourceCode();
    [CompilationMappingAttribute("8", "2")]
public static FSharpFindDeclFailureReason NewProvidedType(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProvidedType();
    [CompilationMappingAttribute("8", "3")]
public static FSharpFindDeclFailureReason NewProvidedMember(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProvidedMember();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpFindDeclFailureReason obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpFindDeclFailureReason obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.FSharpFindDeclResult : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDeclNotFound { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDeclFound { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExternalDecl { get; }
    [CompilationMappingAttribute("8", "0")]
public static FSharpFindDeclResult NewDeclNotFound(FSharpFindDeclFailureReason item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDeclNotFound();
    [CompilationMappingAttribute("8", "1")]
public static FSharpFindDeclResult NewDeclFound(range item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDeclFound();
    [CompilationMappingAttribute("8", "2")]
public static FSharpFindDeclResult NewExternalDecl(string _assembly, ExternalSymbol _externalSym);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExternalDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpFindDeclResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpGenericParameter : FSharpSymbol {
    internal Typar v;
    internal SymbolEnv cenv;
    public string Name { get; }
    public range DeclarationLocation { get; }
    public bool IsCompilerGenerated { get; }
    public bool IsMeasure { get; }
    public IList`1<string> XmlDoc { get; }
    public bool IsSolveAtCompileTime { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public IList`1<FSharpGenericParameterConstraint> Constraints { get; }
    internal Typar V { get; }
    internal FSharpGenericParameter(SymbolEnv cenv, Typar v);
    public string get_Name();
    public range get_DeclarationLocation();
    public bool get_IsCompilerGenerated();
    public bool get_IsMeasure();
    public IList`1<string> get_XmlDoc();
    public bool get_IsSolveAtCompileTime();
    public IList`1<FSharpAttribute> get_Attributes();
    public IList`1<FSharpGenericParameterConstraint> get_Constraints();
    internal Typar get_V();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ClassAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpGenericParameterConstraint : object {
    internal TyparConstraint cx;
    internal SymbolEnv cenv;
    public bool IsCoercesToConstraint { get; }
    public FSharpType CoercesToTarget { get; }
    public bool IsDefaultsToConstraint { get; }
    public FSharpGenericParameterDefaultsToConstraint DefaultsToConstraintData { get; }
    public bool IsSupportsNullConstraint { get; }
    public bool IsMemberConstraint { get; }
    public FSharpGenericParameterMemberConstraint MemberConstraintData { get; }
    public bool IsNonNullableValueTypeConstraint { get; }
    public bool IsReferenceTypeConstraint { get; }
    public bool IsSimpleChoiceConstraint { get; }
    public IList`1<FSharpType> SimpleChoices { get; }
    public bool IsRequiresDefaultConstructorConstraint { get; }
    public bool IsEnumConstraint { get; }
    public FSharpType EnumConstraintTarget { get; }
    public bool IsComparisonConstraint { get; }
    public bool IsEqualityConstraint { get; }
    public bool IsUnmanagedConstraint { get; }
    public bool IsDelegateConstraint { get; }
    public FSharpGenericParameterDelegateConstraint DelegateConstraintData { get; }
    internal FSharpGenericParameterConstraint(SymbolEnv cenv, TyparConstraint cx);
    public bool get_IsCoercesToConstraint();
    public FSharpType get_CoercesToTarget();
    public bool get_IsDefaultsToConstraint();
    public FSharpGenericParameterDefaultsToConstraint get_DefaultsToConstraintData();
    public bool get_IsSupportsNullConstraint();
    public bool get_IsMemberConstraint();
    public FSharpGenericParameterMemberConstraint get_MemberConstraintData();
    public bool get_IsNonNullableValueTypeConstraint();
    public bool get_IsReferenceTypeConstraint();
    public bool get_IsSimpleChoiceConstraint();
    public IList`1<FSharpType> get_SimpleChoices();
    public bool get_IsRequiresDefaultConstructorConstraint();
    public bool get_IsEnumConstraint();
    public FSharpType get_EnumConstraintTarget();
    public bool get_IsComparisonConstraint();
    public bool get_IsEqualityConstraint();
    public bool get_IsUnmanagedConstraint();
    public bool get_IsDelegateConstraint();
    public FSharpGenericParameterDelegateConstraint get_DelegateConstraintData();
    public virtual string ToString();
}
[ClassAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpGenericParameterDefaultsToConstraint : object {
    internal TType ty;
    internal int pri;
    internal SymbolEnv cenv;
    public int DefaultsToPriority { get; }
    public FSharpType DefaultsToTarget { get; }
    internal FSharpGenericParameterDefaultsToConstraint(SymbolEnv cenv, int pri, TType ty);
    public int get_DefaultsToPriority();
    public FSharpType get_DefaultsToTarget();
    public virtual string ToString();
}
[ClassAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpGenericParameterDelegateConstraint : object {
    internal TType tupledArgTy;
    internal TType rty;
    internal SymbolEnv cenv;
    public FSharpType DelegateTupledArgumentType { get; }
    public FSharpType DelegateReturnType { get; }
    internal FSharpGenericParameterDelegateConstraint(SymbolEnv cenv, TType tupledArgTy, TType rty);
    public FSharpType get_DelegateTupledArgumentType();
    public FSharpType get_DelegateReturnType();
    public virtual string ToString();
}
[ClassAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpGenericParameterMemberConstraint : object {
    internal SymbolEnv cenv;
    internal FSharpList`1<TType> tys;
    internal FSharpOption`1<TType> rty;
    internal string nm;
    internal MemberFlags flags;
    internal FSharpList`1<TType> atys;
    public IList`1<FSharpType> MemberSources { get; }
    public string MemberName { get; }
    public bool MemberIsStatic { get; }
    public IList`1<FSharpType> MemberArgumentTypes { get; }
    public FSharpType MemberReturnType { get; }
    internal FSharpGenericParameterMemberConstraint(SymbolEnv cenv, TraitConstraintInfo info);
    public IList`1<FSharpType> get_MemberSources();
    public string get_MemberName();
    public bool get_MemberIsStatic();
    public IList`1<FSharpType> get_MemberArgumentTypes();
    public FSharpType get_MemberReturnType();
    public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.FSharpGlyph : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Constant;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Delegate;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Enum;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_EnumMember;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Event;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Exception;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Field;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Method;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_OverridenMethod;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_NameSpace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Struct;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Typedef;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Type;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Union;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Variable;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_ExtensionMethod;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Error;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Constant { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstant { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Delegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDelegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Enum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph EnumMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnumMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Event { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Exception { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Field { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Method { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph OverridenMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOverridenMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph NameSpace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNameSpace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Struct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStruct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Typedef { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypedef { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Union { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Variable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVariable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph ExtensionMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExtensionMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Error { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsError { get; }
    private static FSharpGlyph();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpGlyph(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpGlyph get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "1")]
public static FSharpGlyph get_Constant();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstant();
    [CompilationMappingAttribute("8", "2")]
public static FSharpGlyph get_Delegate();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDelegate();
    [CompilationMappingAttribute("8", "3")]
public static FSharpGlyph get_Enum();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnum();
    [CompilationMappingAttribute("8", "4")]
public static FSharpGlyph get_EnumMember();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnumMember();
    [CompilationMappingAttribute("8", "5")]
public static FSharpGlyph get_Event();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEvent();
    [CompilationMappingAttribute("8", "6")]
public static FSharpGlyph get_Exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilationMappingAttribute("8", "7")]
public static FSharpGlyph get_Field();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "8")]
public static FSharpGlyph get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "9")]
public static FSharpGlyph get_Method();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethod();
    [CompilationMappingAttribute("8", "10")]
public static FSharpGlyph get_OverridenMethod();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOverridenMethod();
    [CompilationMappingAttribute("8", "11")]
public static FSharpGlyph get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "12")]
public static FSharpGlyph get_NameSpace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNameSpace();
    [CompilationMappingAttribute("8", "13")]
public static FSharpGlyph get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilationMappingAttribute("8", "14")]
public static FSharpGlyph get_Struct();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStruct();
    [CompilationMappingAttribute("8", "15")]
public static FSharpGlyph get_Typedef();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypedef();
    [CompilationMappingAttribute("8", "16")]
public static FSharpGlyph get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "17")]
public static FSharpGlyph get_Union();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnion();
    [CompilationMappingAttribute("8", "18")]
public static FSharpGlyph get_Variable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVariable();
    [CompilationMappingAttribute("8", "19")]
public static FSharpGlyph get_ExtensionMethod();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExtensionMethod();
    [CompilationMappingAttribute("8", "20")]
public static FSharpGlyph get_Error();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpGlyph obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpGlyph obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpImplementationFileContents : object {
    internal SymbolEnv cenv;
    internal QualifiedNameOfFile qname;
    internal ModuleOrNamespaceExpr mdef;
    internal bool isScript;
    internal bool hasExplicitEntryPoint;
    public string QualifiedName { get; }
    public string FileName { get; }
    public FSharpList`1<FSharpImplementationFileDeclaration> Declarations { get; }
    public bool HasExplicitEntryPoint { get; }
    public bool IsScript { get; }
    internal FSharpImplementationFileContents(SymbolEnv cenv, TypedImplFile mimpl);
    public string get_QualifiedName();
    public string get_FileName();
    public FSharpList`1<FSharpImplementationFileDeclaration> get_Declarations();
    public bool get_HasExplicitEntryPoint();
    public bool get_IsScript();
    [CompilerGeneratedAttribute]
internal FSharpList`1<FSharpImplementationFileDeclaration> getDecls2(ModuleOrNamespaceExprWithSig _arg1);
    [CompilerGeneratedAttribute]
internal FSharpImplementationFileDeclaration getBind(Binding bind);
    [CompilerGeneratedAttribute]
internal FSharpList`1<FSharpImplementationFileDeclaration> getDecls(ModuleOrNamespaceExpr mdef);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.FSharpImplementationFileDeclaration : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEntity { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMemberOrFunctionOrValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInitAction { get; }
    [CompilationMappingAttribute("8", "0")]
public static FSharpImplementationFileDeclaration NewEntity(FSharpEntity item1, FSharpList`1<FSharpImplementationFileDeclaration> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEntity();
    [CompilationMappingAttribute("8", "1")]
public static FSharpImplementationFileDeclaration NewMemberOrFunctionOrValue(FSharpMemberOrFunctionOrValue item1, FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> item2, FSharpExpr item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMemberOrFunctionOrValue();
    [CompilationMappingAttribute("8", "2")]
public static FSharpImplementationFileDeclaration NewInitAction(FSharpExpr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInitAction();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpImplementationFileDeclaration obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.FSharpInlineAnnotation : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInlineAnnotation _unique_PseudoValue;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInlineAnnotation _unique_AlwaysInline;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInlineAnnotation _unique_OptionalInline;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInlineAnnotation _unique_NeverInline;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInlineAnnotation _unique_AggressiveInline;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpInlineAnnotation PseudoValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPseudoValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpInlineAnnotation AlwaysInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAlwaysInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpInlineAnnotation OptionalInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOptionalInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpInlineAnnotation NeverInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNeverInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpInlineAnnotation AggressiveInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAggressiveInline { get; }
    private static FSharpInlineAnnotation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpInlineAnnotation(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpInlineAnnotation get_PseudoValue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPseudoValue();
    [CompilationMappingAttribute("8", "1")]
public static FSharpInlineAnnotation get_AlwaysInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAlwaysInline();
    [CompilationMappingAttribute("8", "2")]
public static FSharpInlineAnnotation get_OptionalInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOptionalInline();
    [CompilationMappingAttribute("8", "3")]
public static FSharpInlineAnnotation get_NeverInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNeverInline();
    [CompilationMappingAttribute("8", "4")]
public static FSharpInlineAnnotation get_AggressiveInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAggressiveInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpInlineAnnotation obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpInlineAnnotation obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpLineTokenizer : object {
    internal FSharpOption`1<int> maxLength;
    internal LexBuffer`1<char> lexbuf;
    internal lexargs lexArgsLightOn;
    internal lexargs lexArgsLightOff;
    internal bool skip;
    internal SingleLineTokenState singleLineTokenState;
    internal bool fsx;
    internal Stack`1<Tuple`3<token, int, int>> tokenStack;
    internal FSharpLineTokenizer(LexBuffer`1<char> lexbuf, FSharpOption`1<int> maxLength, FSharpOption`1<string> filename, lexargs lexArgsLightOn, lexargs lexArgsLightOff);
    public Tuple`2<FSharpOption`1<FSharpTokenInfo>, FSharpTokenizerLexState> ScanToken(FSharpTokenizerLexState lexState);
    public static FSharpTokenizerColorState ColorStateOfLexState(FSharpTokenizerLexState lexState);
    public static FSharpTokenizerLexState LexStateOfColorState(FSharpTokenizerColorState colorState);
    [CompilerGeneratedAttribute]
internal void delayToken(token tok_0, int tok_1, int tok_2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal int processDirective(string str, int directiveLength, FSharpFunc`2<Tuple`3<token, int, int>, Unit> delay, LexerWhitespaceContinuation cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal void processWhiteAndComment(string str, int offset, FSharpFunc`2<Tuple`3<token, int, int>, Unit> delay, LexerWhitespaceContinuation cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`3<token, int, int> processDirectiveLine(int ofs, FSharpFunc`2<FSharpFunc`2<Tuple`3<token, int, int>, Unit>, Unit> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`3<token, int, int> processHashEndElse(int ofs, string str, int length, LexerWhitespaceContinuation cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`3<token, int, int> processHashIfLine(int ofs, string str, LexerWhitespaceContinuation cont);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpMemberOrFunctionOrValue : FSharpSymbol {
    internal Item item;
    internal FSharpMemberOrValData d;
    internal SymbolEnv cenv;
    public bool IsUnresolved { get; }
    internal FSharpOption`1<range> DeclarationLocationOpt { get; }
    public range DeclarationLocation { get; }
    public FSharpOption`1<FSharpEntity> DeclaringEntity { get; }
    public FSharpEntity ApparentEnclosingEntity { get; }
    public IList`1<FSharpGenericParameter> GenericParameters { get; }
    public FSharpType FullType { get; }
    public bool HasGetterMethod { get; }
    public FSharpMemberOrFunctionOrValue GetterMethod { get; }
    public bool HasSetterMethod { get; }
    public FSharpMemberOrFunctionOrValue SetterMethod { get; }
    public FSharpMemberOrFunctionOrValue EventAddMethod { get; }
    public FSharpMemberOrFunctionOrValue EventRemoveMethod { get; }
    public FSharpType EventDelegateType { get; }
    public bool EventIsStandard { get; }
    public bool IsCompilerGenerated { get; }
    public FSharpInlineAnnotation InlineAnnotation { get; }
    public bool IsMutable { get; }
    public bool IsModuleValueOrMember { get; }
    public bool IsMember { get; }
    public bool IsDispatchSlot { get; }
    public bool IsProperty { get; }
    public bool IsEvent { get; }
    public FSharpOption`1<FSharpMemberOrFunctionOrValue> EventForFSharpProperty { get; }
    public bool IsEventAddMethod { get; }
    public bool IsEventRemoveMethod { get; }
    [ObsoleteAttribute("Renamed to IsPropertyGetterMethod, which returns 'true' only for method symbols, not for property symbols")]
public bool IsGetterMethod { get; }
    [ObsoleteAttribute("Renamed to IsPropertySetterMethod, which returns 'true' only for method symbols, not for property symbols")]
public bool IsSetterMethod { get; }
    public bool IsPropertyGetterMethod { get; }
    public bool IsPropertySetterMethod { get; }
    public bool IsInstanceMember { get; }
    public bool IsInstanceMemberInCompiledCode { get; }
    public bool IsExtensionMember { get; }
    [ObsoleteAttribute("Renamed to IsOverrideOrExplicitInterfaceImplementation")]
public bool IsOverrideOrExplicitMember { get; }
    public bool IsOverrideOrExplicitInterfaceImplementation { get; }
    public bool IsExplicitInterfaceImplementation { get; }
    public IList`1<FSharpAbstractSignature> ImplementedAbstractSignatures { get; }
    public bool IsImplicitConstructor { get; }
    public bool IsTypeFunction { get; }
    public bool IsActivePattern { get; }
    public string CompiledName { get; }
    public string LogicalName { get; }
    public string DisplayName { get; }
    public string XmlDocSig { get; }
    public IList`1<string> XmlDoc { get; }
    public IList`1<IList`1<FSharpParameter>> CurriedParameterGroups { get; }
    public FSharpParameter ReturnParameter { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public bool IsBaseValue { get; }
    public bool IsConstructorThisValue { get; }
    public bool IsMemberThisValue { get; }
    public FSharpOption`1<object> LiteralValue { get; }
    public FSharpAccessibility Accessibility { get; }
    public bool IsConstructor { get; }
    internal FSharpMemberOrValData Data { get; }
    public bool IsValCompiledAsMethod { get; }
    public bool IsValue { get; }
    internal FSharpMemberOrFunctionOrValue(SymbolEnv cenv, FSharpMemberOrValData d, Item item);
    internal FSharpMemberOrFunctionOrValue(SymbolEnv cenv, ValRef vref);
    internal FSharpMemberOrFunctionOrValue(SymbolEnv cenv, MethInfo minfo);
    public bool get_IsUnresolved();
    internal FSharpOption`1<range> get_DeclarationLocationOpt();
    public FSharpOption`1<IList`1<FSharpMemberOrFunctionOrValue>> Overloads(bool matchParameterNumber);
    public range get_DeclarationLocation();
    public FSharpOption`1<FSharpEntity> get_DeclaringEntity();
    public FSharpEntity get_ApparentEnclosingEntity();
    public IList`1<FSharpGenericParameter> get_GenericParameters();
    public FSharpType get_FullType();
    public bool get_HasGetterMethod();
    public FSharpMemberOrFunctionOrValue get_GetterMethod();
    public bool get_HasSetterMethod();
    public FSharpMemberOrFunctionOrValue get_SetterMethod();
    public FSharpMemberOrFunctionOrValue get_EventAddMethod();
    public FSharpMemberOrFunctionOrValue get_EventRemoveMethod();
    public FSharpType get_EventDelegateType();
    public bool get_EventIsStandard();
    public bool get_IsCompilerGenerated();
    public FSharpInlineAnnotation get_InlineAnnotation();
    public bool get_IsMutable();
    public bool get_IsModuleValueOrMember();
    public bool get_IsMember();
    public bool get_IsDispatchSlot();
    public bool get_IsProperty();
    public bool get_IsEvent();
    public FSharpOption`1<FSharpMemberOrFunctionOrValue> get_EventForFSharpProperty();
    public bool get_IsEventAddMethod();
    public bool get_IsEventRemoveMethod();
    public bool get_IsGetterMethod();
    public bool get_IsSetterMethod();
    public bool get_IsPropertyGetterMethod();
    public bool get_IsPropertySetterMethod();
    public bool get_IsInstanceMember();
    public bool get_IsInstanceMemberInCompiledCode();
    public bool get_IsExtensionMember();
    public bool get_IsOverrideOrExplicitMember();
    public bool get_IsOverrideOrExplicitInterfaceImplementation();
    public bool get_IsExplicitInterfaceImplementation();
    public IList`1<FSharpAbstractSignature> get_ImplementedAbstractSignatures();
    public bool get_IsImplicitConstructor();
    public bool get_IsTypeFunction();
    public bool get_IsActivePattern();
    public string get_CompiledName();
    public string get_LogicalName();
    public string get_DisplayName();
    public string get_XmlDocSig();
    public IList`1<string> get_XmlDoc();
    public IList`1<IList`1<FSharpParameter>> get_CurriedParameterGroups();
    public FSharpParameter get_ReturnParameter();
    public IList`1<FSharpAttribute> get_Attributes();
    public bool get_IsBaseValue();
    public bool get_IsConstructorThisValue();
    public bool get_IsMemberThisValue();
    public FSharpOption`1<object> get_LiteralValue();
    public FSharpAccessibility get_Accessibility();
    public bool get_IsConstructor();
    internal FSharpMemberOrValData get_Data();
    public bool get_IsValCompiledAsMethod();
    public bool get_IsValue();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public Layout FormatLayout(FSharpDisplayContext context);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<ValRef> fsharpInfo();
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal void checkIsResolved();
    [CompilerGeneratedAttribute]
internal FSharpMemberOrFunctionOrValue mkMethSym(MethInfo minfo);
    [CompilerGeneratedAttribute]
internal FSharpMemberOrFunctionOrValue mkEventSym(EventInfo einfo);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.SourceCodeServices.FSharpMemberOrValData : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsE { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsP { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsM { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsC { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsV { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpMemberOrValData(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static FSharpMemberOrValData NewE(EventInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsE();
    [CompilationMappingAttribute("8", "1")]
internal static FSharpMemberOrValData NewP(PropInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsP();
    [CompilationMappingAttribute("8", "2")]
internal static FSharpMemberOrValData NewM(MethInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsM();
    [CompilationMappingAttribute("8", "3")]
internal static FSharpMemberOrValData NewC(MethInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsC();
    [CompilationMappingAttribute("8", "4")]
internal static FSharpMemberOrValData NewV(ValRef item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsV();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpMethodGroup : object {
    internal string name;
    internal static ConditionalWeakTable`2<ItemWithInst, FSharpMethodGroupItem[]> methodOverloadsCache;
    internal FSharpMethodGroupItem[] methods;
    internal static int init@748-16;
    public string MethodName { get; }
    public FSharpMethodGroupItem[] Methods { get; }
    internal FSharpMethodGroup(string name, FSharpMethodGroupItem[] unsortedMethods);
    private static FSharpMethodGroup();
    public string get_MethodName();
    public FSharpMethodGroupItem[] get_Methods();
    internal static FSharpMethodGroup Create(InfoReader infoReader, range m, DisplayEnv denv, FSharpList`1<ItemWithInst> items);
}
[SealedAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpMethodGroupItem : object {
    internal FSharpXmlDoc xmlDoc;
    internal FSharpMethodGroupItemParameter[] staticParameters;
    internal Layout returnType;
    internal FSharpMethodGroupItemParameter[] parameters;
    internal bool hasParameters;
    internal bool hasParamArrayArg;
    internal FSharpToolTipText`1<Layout> description;
    public FSharpToolTipText`1<Layout> StructuredDescription { get; }
    public FSharpToolTipText`1<string> Description { get; }
    public FSharpXmlDoc XmlDoc { get; }
    public Layout StructuredReturnTypeText { get; }
    public string ReturnTypeText { get; }
    public FSharpMethodGroupItemParameter[] Parameters { get; }
    public bool HasParameters { get; }
    public bool HasParamArrayArg { get; }
    public FSharpMethodGroupItemParameter[] StaticParameters { get; }
    internal FSharpMethodGroupItem(FSharpToolTipText`1<Layout> description, FSharpXmlDoc xmlDoc, Layout returnType, FSharpMethodGroupItemParameter[] parameters, bool hasParameters, bool hasParamArrayArg, FSharpMethodGroupItemParameter[] staticParameters);
    public FSharpToolTipText`1<Layout> get_StructuredDescription();
    public FSharpToolTipText`1<string> get_Description();
    public FSharpXmlDoc get_XmlDoc();
    public Layout get_StructuredReturnTypeText();
    public string get_ReturnTypeText();
    public FSharpMethodGroupItemParameter[] get_Parameters();
    public bool get_HasParameters();
    public bool get_HasParamArrayArg();
    public FSharpMethodGroupItemParameter[] get_StaticParameters();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpMethodGroupItemParameter : object {
    internal string name;
    internal bool isOptional;
    internal Layout display;
    internal string canonicalTypeTextForSorting;
    public string ParameterName { get; }
    public string CanonicalTypeTextForSorting { get; }
    public Layout StructuredDisplay { get; }
    public string Display { get; }
    public bool IsOptional { get; }
    internal FSharpMethodGroupItemParameter(string name, string canonicalTypeTextForSorting, Layout display, bool isOptional);
    public string get_ParameterName();
    public string get_CanonicalTypeTextForSorting();
    public Layout get_StructuredDisplay();
    public string get_Display();
    public bool get_IsOptional();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.FSharpNavigation : object {
    [CompilationMappingAttribute("9")]
internal static FSharpNavigationItems empty { get; }
    public static FSharpNavigationItems getNavigation(ParsedInput parsedInput);
    internal static FSharpNavigationItems get_empty();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpNavigationDeclarationItem : object {
    internal string uniqueName;
    internal bool singleTopLevel;
    internal range range;
    internal string name;
    internal FSharpNavigationDeclarationItemKind kind;
    internal bool isAbstract;
    internal FSharpGlyph glyph;
    internal FSharpEnclosingEntityKind enclosingEntityKind;
    internal range bodyRange@39;
    internal FSharpOption`1<SynAccess> access;
    internal range bodyRange { get; }
    public string UniqueName { get; }
    public string Name { get; }
    public FSharpGlyph Glyph { get; }
    public FSharpNavigationDeclarationItemKind Kind { get; }
    public range Range { get; }
    public range BodyRange { get; }
    public bool IsSingleTopLevel { get; }
    public FSharpEnclosingEntityKind EnclosingEntityKind { get; }
    public bool IsAbstract { get; }
    public FSharpOption`1<SynAccess> Access { get; }
    internal FSharpNavigationDeclarationItem(string uniqueName, string name, FSharpNavigationDeclarationItemKind kind, FSharpGlyph glyph, range range, range bodyRange, bool singleTopLevel, FSharpEnclosingEntityKind enclosingEntityKind, bool isAbstract, FSharpOption`1<SynAccess> access);
    internal range get_bodyRange();
    public string get_UniqueName();
    public string get_Name();
    public FSharpGlyph get_Glyph();
    public FSharpNavigationDeclarationItemKind get_Kind();
    public range get_Range();
    public range get_BodyRange();
    public bool get_IsSingleTopLevel();
    public FSharpEnclosingEntityKind get_EnclosingEntityKind();
    public bool get_IsAbstract();
    public FSharpOption`1<SynAccess> get_Access();
    internal FSharpNavigationDeclarationItem WithUniqueName(string uniqueName);
    internal static FSharpNavigationDeclarationItem Create(string name, FSharpNavigationDeclarationItemKind kind, FSharpGlyph glyph, range range, range bodyRange, bool singleTopLevel, FSharpEnclosingEntityKind enclosingEntityKind, bool isAbstract, FSharpOption`1<SynAccess> access);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.FSharpNavigationDeclarationItemKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpNavigationDeclarationItemKind _unique_NamespaceDecl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpNavigationDeclarationItemKind _unique_ModuleFileDecl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpNavigationDeclarationItemKind _unique_ExnDecl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpNavigationDeclarationItemKind _unique_ModuleDecl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpNavigationDeclarationItemKind _unique_TypeDecl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpNavigationDeclarationItemKind _unique_MethodDecl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpNavigationDeclarationItemKind _unique_PropertyDecl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpNavigationDeclarationItemKind _unique_FieldDecl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpNavigationDeclarationItemKind _unique_OtherDecl;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpNavigationDeclarationItemKind NamespaceDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespaceDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpNavigationDeclarationItemKind ModuleFileDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleFileDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpNavigationDeclarationItemKind ExnDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExnDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpNavigationDeclarationItemKind ModuleDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpNavigationDeclarationItemKind TypeDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpNavigationDeclarationItemKind MethodDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethodDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpNavigationDeclarationItemKind PropertyDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPropertyDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpNavigationDeclarationItemKind FieldDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFieldDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpNavigationDeclarationItemKind OtherDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOtherDecl { get; }
    private static FSharpNavigationDeclarationItemKind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpNavigationDeclarationItemKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpNavigationDeclarationItemKind get_NamespaceDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespaceDecl();
    [CompilationMappingAttribute("8", "1")]
public static FSharpNavigationDeclarationItemKind get_ModuleFileDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleFileDecl();
    [CompilationMappingAttribute("8", "2")]
public static FSharpNavigationDeclarationItemKind get_ExnDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExnDecl();
    [CompilationMappingAttribute("8", "3")]
public static FSharpNavigationDeclarationItemKind get_ModuleDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleDecl();
    [CompilationMappingAttribute("8", "4")]
public static FSharpNavigationDeclarationItemKind get_TypeDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeDecl();
    [CompilationMappingAttribute("8", "5")]
public static FSharpNavigationDeclarationItemKind get_MethodDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethodDecl();
    [CompilationMappingAttribute("8", "6")]
public static FSharpNavigationDeclarationItemKind get_PropertyDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPropertyDecl();
    [CompilationMappingAttribute("8", "7")]
public static FSharpNavigationDeclarationItemKind get_FieldDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFieldDecl();
    [CompilationMappingAttribute("8", "8")]
public static FSharpNavigationDeclarationItemKind get_OtherDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOtherDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpNavigationDeclarationItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpNavigationDeclarationItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpNavigationItems : object {
    internal FSharpNavigationTopLevelDeclaration[] declarations;
    public FSharpNavigationTopLevelDeclaration[] Declarations { get; }
    internal FSharpNavigationItems(FSharpNavigationTopLevelDeclaration[] declarations);
    public FSharpNavigationTopLevelDeclaration[] get_Declarations();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.FSharpNavigationTopLevelDeclaration : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpNavigationDeclarationItem Declaration@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpNavigationDeclarationItem[] Nested@;
    [CompilationMappingAttribute("4", "0")]
public FSharpNavigationDeclarationItem Declaration { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpNavigationDeclarationItem[] Nested { get; }
    public FSharpNavigationTopLevelDeclaration(FSharpNavigationDeclarationItem declaration, FSharpNavigationDeclarationItem[] nested);
    public FSharpNavigationDeclarationItem get_Declaration();
    public FSharpNavigationDeclarationItem[] get_Nested();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpNoteworthyParamInfoLocations : object {
    internal pos openParenLocation;
    internal range longIdRange;
    internal FSharpList`1<string> longId;
    internal bool isThereACloseParen;
    internal pos[] tupleEndLocations@11;
    internal FSharpOption`1[] namedParamNames@13-1;
    public FSharpList`1<string> LongId { get; }
    public pos LongIdStartLocation { get; }
    public pos LongIdEndLocation { get; }
    public pos OpenParenLocation { get; }
    public pos[] TupleEndLocations { get; }
    public bool IsThereACloseParen { get; }
    public FSharpOption`1[] NamedParamNames { get; }
    internal FSharpNoteworthyParamInfoLocations(FSharpList`1<string> longId, range longIdRange, pos openParenLocation, FSharpList`1<pos> tupleEndLocations, bool isThereACloseParen, FSharpList`1<FSharpOption`1<string>> namedParamNames);
    public FSharpList`1<string> get_LongId();
    public pos get_LongIdStartLocation();
    public pos get_LongIdEndLocation();
    public pos get_OpenParenLocation();
    public pos[] get_TupleEndLocations();
    public bool get_IsThereACloseParen();
    public FSharpOption`1[] get_NamedParamNames();
    public static FSharpOption`1<FSharpNoteworthyParamInfoLocations> Find(pos pos, ParsedInput parseTree);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpObjectExprOverride : object {
    internal FSharpAbstractSignature sgn;
    internal FSharpList`1<FSharpGenericParameter> gps;
    internal FSharpExpr body;
    internal FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> args;
    public FSharpAbstractSignature Signature { get; }
    public FSharpList`1<FSharpGenericParameter> GenericParameters { get; }
    public FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> CurriedParameterGroups { get; }
    public FSharpExpr Body { get; }
    internal FSharpObjectExprOverride(FSharpAbstractSignature sgn, FSharpList`1<FSharpGenericParameter> gps, FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> args, FSharpExpr body);
    public FSharpAbstractSignature get_Signature();
    public FSharpList`1<FSharpGenericParameter> get_GenericParameters();
    public FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> get_CurriedParameterGroups();
    public FSharpExpr get_Body();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpOpenDeclaration : object {
    internal FSharpOption`1<range> range;
    internal FSharpList`1<FSharpEntity> modules;
    internal FSharpList`1<Ident> longId;
    internal bool isOwnNamespace;
    internal range appliedScope;
    public FSharpList`1<Ident> LongId { get; }
    public FSharpOption`1<range> Range { get; }
    public FSharpList`1<FSharpEntity> Modules { get; }
    public range AppliedScope { get; }
    public bool IsOwnNamespace { get; }
    internal FSharpOpenDeclaration(FSharpList`1<Ident> longId, FSharpOption`1<range> range, FSharpList`1<FSharpEntity> modules, range appliedScope, bool isOwnNamespace);
    public FSharpList`1<Ident> get_LongId();
    public FSharpOption`1<range> get_Range();
    public FSharpList`1<FSharpEntity> get_Modules();
    public range get_AppliedScope();
    public bool get_IsOwnNamespace();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpParameter : FSharpSymbol {
    internal ArgReprInfo topArgInfo;
    internal TType paramTy;
    internal FSharpOption`1<range> mOpt;
    internal bool isParamArrayArg;
    internal bool isOutArg;
    internal bool isOptionalArg;
    internal bool isInArg;
    internal SymbolEnv cenv@2331;
    internal FSharpList`1<Attrib> attribs;
    internal FSharpOption`1<Ident> idOpt;
    internal range m;
    public FSharpOption`1<string> Name { get; }
    internal SymbolEnv cenv { get; }
    public FSharpType Type { get; }
    internal TType V { get; }
    public range DeclarationLocation { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public bool IsParamArrayArg { get; }
    public bool IsInArg { get; }
    public bool IsOutArg { get; }
    public bool IsOptionalArg { get; }
    internal ArgReprInfo ValReprInfo { get; }
    internal FSharpParameter(SymbolEnv cenv, TType paramTy, ArgReprInfo topArgInfo, FSharpOption`1<range> mOpt, bool isParamArrayArg, bool isInArg, bool isOutArg, bool isOptionalArg);
    public FSharpOption`1<string> get_Name();
    internal SymbolEnv get_cenv();
    internal FSharpParameter AdjustType(TType t);
    public FSharpType get_Type();
    internal TType get_V();
    public range get_DeclarationLocation();
    public IList`1<FSharpAttribute> get_Attributes();
    public bool get_IsParamArrayArg();
    public bool get_IsInArg();
    public bool get_IsOutArg();
    public bool get_IsOptionalArg();
    internal ArgReprInfo get_ValReprInfo();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpParseFileResults : object {
    internal bool parseHadErrors;
    internal FSharpOption`1<ParsedInput> input;
    internal FSharpErrorInfo[] errors;
    internal String[] dependencyFiles;
    public FSharpErrorInfo[] Errors { get; }
    public bool ParseHadErrors { get; }
    public FSharpOption`1<ParsedInput> ParseTree { get; }
    public String[] DependencyFiles { get; }
    public string FileName { get; }
    internal FSharpParseFileResults(FSharpErrorInfo[] errors, FSharpOption`1<ParsedInput> input, bool parseHadErrors, String[] dependencyFiles);
    public FSharpErrorInfo[] get_Errors();
    public bool get_ParseHadErrors();
    public FSharpOption`1<ParsedInput> get_ParseTree();
    public FSharpOption`1<FSharpNoteworthyParamInfoLocations> FindNoteworthyParamInfoLocations(pos pos);
    internal FSharpNavigationItems GetNavigationItemsImpl();
    internal FSharpOption`1<range> ValidateBreakpointLocationImpl(pos pos);
    public String[] get_DependencyFiles();
    public string get_FileName();
    public FSharpNavigationItems GetNavigationItems();
    public FSharpOption`1<range> ValidateBreakpointLocation(pos pos);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.FSharpParsingOptions : object {
    [DebuggerBrowsableAttribute("0")]
internal String[] SourceFiles@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> ConditionalCompilationDefines@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpErrorSeverityOptions ErrorSeverityOptions@;
    [DebuggerBrowsableAttribute("0")]
internal bool IsInteractive@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<bool> LightSyntax@;
    [DebuggerBrowsableAttribute("0")]
internal bool CompilingFsLib@;
    [DebuggerBrowsableAttribute("0")]
internal bool IsExe@;
    [CompilationMappingAttribute("4", "0")]
public String[] SourceFiles { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<string> ConditionalCompilationDefines { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpErrorSeverityOptions ErrorSeverityOptions { get; }
    [CompilationMappingAttribute("4", "3")]
public bool IsInteractive { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpOption`1<bool> LightSyntax { get; }
    [CompilationMappingAttribute("4", "5")]
public bool CompilingFsLib { get; }
    [CompilationMappingAttribute("4", "6")]
public bool IsExe { get; }
    internal string LastFileName { get; }
    public static FSharpParsingOptions Default { get; }
    public FSharpParsingOptions(String[] sourceFiles, FSharpList`1<string> conditionalCompilationDefines, FSharpErrorSeverityOptions errorSeverityOptions, bool isInteractive, FSharpOption`1<bool> lightSyntax, bool compilingFsLib, bool isExe);
    public String[] get_SourceFiles();
    public FSharpList`1<string> get_ConditionalCompilationDefines();
    public FSharpErrorSeverityOptions get_ErrorSeverityOptions();
    public bool get_IsInteractive();
    public FSharpOption`1<bool> get_LightSyntax();
    public bool get_CompilingFsLib();
    public bool get_IsExe();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpParsingOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal string get_LastFileName();
    public static FSharpParsingOptions get_Default();
    internal static FSharpParsingOptions FromTcConfig(TcConfig tcConfig, String[] sourceFiles, bool isInteractive);
    internal static FSharpParsingOptions FromTcConfigBuidler(TcConfigBuilder tcConfigB, String[] sourceFiles, bool isInteractive);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpParsingOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpProjectContext : object {
    internal CcuThunk thisCcu;
    internal FSharpList`1<FSharpAssembly> assemblies;
    internal AccessorDomain ad;
    public FSharpAccessibilityRights AccessibilityRights { get; }
    internal FSharpProjectContext(CcuThunk thisCcu, FSharpList`1<FSharpAssembly> assemblies, AccessorDomain ad);
    public FSharpList`1<FSharpAssembly> GetReferencedAssemblies();
    public FSharpAccessibilityRights get_AccessibilityRights();
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.FSharpProjectOptions : object {
    [DebuggerBrowsableAttribute("0")]
internal string ProjectFileName@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ProjectId@;
    [DebuggerBrowsableAttribute("0")]
internal String[] SourceFiles@;
    [DebuggerBrowsableAttribute("0")]
internal String[] OtherOptions@;
    [DebuggerBrowsableAttribute("0")]
internal Tuple`2[] ReferencedProjects@;
    [DebuggerBrowsableAttribute("0")]
internal bool IsIncompleteTypeCheckEnvironment@;
    [DebuggerBrowsableAttribute("0")]
internal bool UseScriptResolutionRules@;
    [DebuggerBrowsableAttribute("0")]
internal DateTime LoadTime@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<UnresolvedReferencesSet> UnresolvedReferences@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2<range, string>> OriginalLoadReferences@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<object> ExtraProjectInfo@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<long> Stamp@;
    [CompilationMappingAttribute("4", "0")]
public string ProjectFileName { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<string> ProjectId { get; }
    [CompilationMappingAttribute("4", "2")]
public String[] SourceFiles { get; }
    [CompilationMappingAttribute("4", "3")]
public String[] OtherOptions { get; }
    [CompilationMappingAttribute("4", "4")]
public Tuple`2[] ReferencedProjects { get; }
    [CompilationMappingAttribute("4", "5")]
public bool IsIncompleteTypeCheckEnvironment { get; }
    [CompilationMappingAttribute("4", "6")]
public bool UseScriptResolutionRules { get; }
    [CompilationMappingAttribute("4", "7")]
public DateTime LoadTime { get; }
    [CompilationMappingAttribute("4", "8")]
public FSharpOption`1<UnresolvedReferencesSet> UnresolvedReferences { get; }
    [CompilationMappingAttribute("4", "9")]
public FSharpList`1<Tuple`2<range, string>> OriginalLoadReferences { get; }
    [CompilationMappingAttribute("4", "10")]
public FSharpOption`1<object> ExtraProjectInfo { get; }
    [CompilationMappingAttribute("4", "11")]
public FSharpOption`1<long> Stamp { get; }
    internal String[] ProjectOptions { get; }
    internal string ProjectDirectory { get; }
    public FSharpProjectOptions(string projectFileName, FSharpOption`1<string> projectId, String[] sourceFiles, String[] otherOptions, Tuple`2[] referencedProjects, bool isIncompleteTypeCheckEnvironment, bool useScriptResolutionRules, DateTime loadTime, FSharpOption`1<UnresolvedReferencesSet> unresolvedReferences, FSharpList`1<Tuple`2<range, string>> originalLoadReferences, FSharpOption`1<object> extraProjectInfo, FSharpOption`1<long> stamp);
    public string get_ProjectFileName();
    public FSharpOption`1<string> get_ProjectId();
    public String[] get_SourceFiles();
    public String[] get_OtherOptions();
    public Tuple`2[] get_ReferencedProjects();
    public bool get_IsIncompleteTypeCheckEnvironment();
    public bool get_UseScriptResolutionRules();
    public DateTime get_LoadTime();
    public FSharpOption`1<UnresolvedReferencesSet> get_UnresolvedReferences();
    public FSharpList`1<Tuple`2<range, string>> get_OriginalLoadReferences();
    public FSharpOption`1<object> get_ExtraProjectInfo();
    public FSharpOption`1<long> get_Stamp();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal String[] get_ProjectOptions();
    internal static bool UseSameProject(FSharpProjectOptions options1, FSharpProjectOptions options2);
    internal static bool AreSameForChecking(FSharpProjectOptions options1, FSharpProjectOptions options2);
    internal string get_ProjectDirectory();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpProjectOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpSourceTokenizer : object {
    internal FSharpOption`1<string> filename;
    internal lexargs lexArgsLightOn;
    internal lexargs lexArgsLightOff;
    public FSharpSourceTokenizer(FSharpList`1<string> conditionalDefines, FSharpOption`1<string> fileName);
    public FSharpLineTokenizer CreateLineTokenizer(string lineText);
    public FSharpLineTokenizer CreateBufferTokenizer(FSharpFunc`2<Tuple`3<Char[], int, int>, int> bufferFiller);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpStaticParameter : FSharpSymbol {
    internal Tainted`1<ProvidedParameterInfo> sp;
    internal range m;
    internal SymbolEnv cenv;
    public string Name { get; }
    public range DeclarationLocation { get; }
    public FSharpType Kind { get; }
    public bool IsOptional { get; }
    [ObsoleteAttribute("This member is no longer used, use IsOptional instead")]
public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    internal FSharpStaticParameter(SymbolEnv cenv, Tainted`1<ProvidedParameterInfo> sp, range m);
    public string get_Name();
    public range get_DeclarationLocation();
    public FSharpType get_Kind();
    public bool get_IsOptional();
    public bool get_HasDefaultValue();
    public object get_DefaultValue();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpSymbol : object {
    internal FSharpFunc`2<Unit, Item> item;
    internal SymbolEnv cenv;
    internal FSharpFunc`2<FSharpSymbol, FSharpFunc`2<CcuThunk, FSharpFunc`2<AccessorDomain, bool>>> access;
    public FSharpAssembly Assembly { get; }
    public bool IsExplicitlySuppressed { get; }
    public string FullName { get; }
    public FSharpOption`1<range> DeclarationLocation { get; }
    public FSharpOption`1<range> ImplementationLocation { get; }
    public FSharpOption`1<range> SignatureLocation { get; }
    internal Item Item { get; }
    public string DisplayName { get; }
    internal FSharpSymbol(SymbolEnv cenv, FSharpFunc`2<Unit, Item> item, FSharpFunc`2<FSharpSymbol, FSharpFunc`2<CcuThunk, FSharpFunc`2<AccessorDomain, bool>>> access);
    public FSharpAssembly get_Assembly();
    public bool IsAccessible(FSharpAccessibilityRights rights);
    public bool get_IsExplicitlySuppressed();
    public string get_FullName();
    public FSharpOption`1<range> get_DeclarationLocation();
    public FSharpOption`1<range> get_ImplementationLocation();
    public FSharpOption`1<range> get_SignatureLocation();
    public bool IsEffectivelySameAs(FSharpSymbol other);
    public int GetEffectivelySameAsHash();
    internal Item get_Item();
    public string get_DisplayName();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static FSharpSymbol Create(TcGlobals g, CcuThunk thisCcu, ModuleOrNamespaceType thisCcuTyp, TcImports tcImports, Item item);
    internal static FSharpSymbol Create(SymbolEnv cenv, Item item);
    public static FSharpOption`1<FSharpAccessibility> GetAccessibility(FSharpSymbol symbol);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpSymbolUse : object {
    internal FSharpSymbol symbol;
    internal range range;
    internal ItemOccurence itemOcc;
    internal TcGlobals g;
    internal DisplayEnv denv;
    public FSharpSymbol Symbol { get; }
    public FSharpDisplayContext DisplayContext { get; }
    internal bool IsDefinition { get; }
    public bool IsFromDefinition { get; }
    public bool IsFromPattern { get; }
    public bool IsFromType { get; }
    public bool IsFromAttribute { get; }
    public bool IsFromDispatchSlotImplementation { get; }
    public bool IsFromComputationExpression { get; }
    public bool IsFromOpenStatement { get; }
    public string FileName { get; }
    internal Tuple`2<Tuple`2<int, int>, Tuple`2<int, int>> Range { get; }
    public range RangeAlternate { get; }
    internal FSharpSymbolUse(TcGlobals g, DisplayEnv denv, FSharpSymbol symbol, ItemOccurence itemOcc, range range);
    public FSharpSymbol get_Symbol();
    public FSharpDisplayContext get_DisplayContext();
    internal bool get_IsDefinition();
    public bool get_IsFromDefinition();
    public bool get_IsFromPattern();
    public bool get_IsFromType();
    public bool get_IsFromAttribute();
    public bool get_IsFromDispatchSlotImplementation();
    public bool get_IsFromComputationExpression();
    public bool get_IsFromOpenStatement();
    public string get_FileName();
    internal Tuple`2<Tuple`2<int, int>, Tuple`2<int, int>> get_Range();
    public range get_RangeAlternate();
    public virtual string ToString();
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.SourceCodeServices.FSharpTokenCharKind : Enum {
    public int value__;
    public static FSharpTokenCharKind Default;
    public static FSharpTokenCharKind Text;
    public static FSharpTokenCharKind Keyword;
    public static FSharpTokenCharKind Identifier;
    public static FSharpTokenCharKind String;
    public static FSharpTokenCharKind Literal;
    public static FSharpTokenCharKind Operator;
    public static FSharpTokenCharKind Delimiter;
    public static FSharpTokenCharKind WhiteSpace;
    public static FSharpTokenCharKind LineComment;
    public static FSharpTokenCharKind Comment;
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.SourceCodeServices.FSharpTokenColorKind : Enum {
    public int value__;
    public static FSharpTokenColorKind Default;
    public static FSharpTokenColorKind Text;
    public static FSharpTokenColorKind Keyword;
    public static FSharpTokenColorKind Comment;
    public static FSharpTokenColorKind Identifier;
    public static FSharpTokenColorKind String;
    public static FSharpTokenColorKind UpperIdentifier;
    public static FSharpTokenColorKind InactiveCode;
    public static FSharpTokenColorKind PreprocessorKeyword;
    public static FSharpTokenColorKind Number;
    public static FSharpTokenColorKind Operator;
    public static FSharpTokenColorKind Punctuation;
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.FSharpTokenInfo : object {
    [DebuggerBrowsableAttribute("0")]
internal int LeftColumn@;
    [DebuggerBrowsableAttribute("0")]
internal int RightColumn@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpTokenColorKind ColorClass@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpTokenCharKind CharClass@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpTokenTriggerClass FSharpTokenTriggerClass@;
    [DebuggerBrowsableAttribute("0")]
internal int Tag@;
    [DebuggerBrowsableAttribute("0")]
internal string TokenName@;
    [DebuggerBrowsableAttribute("0")]
internal int FullMatchedLength@;
    [CompilationMappingAttribute("4", "0")]
public int LeftColumn { get; }
    [CompilationMappingAttribute("4", "1")]
public int RightColumn { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpTokenColorKind ColorClass { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpTokenCharKind CharClass { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpTokenTriggerClass FSharpTokenTriggerClass { get; }
    [CompilationMappingAttribute("4", "5")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "6")]
public string TokenName { get; }
    [CompilationMappingAttribute("4", "7")]
public int FullMatchedLength { get; }
    public FSharpTokenInfo(int leftColumn, int rightColumn, FSharpTokenColorKind colorClass, FSharpTokenCharKind charClass, FSharpTokenTriggerClass fSharpTokenTriggerClass, int tag, string tokenName, int fullMatchedLength);
    public int get_LeftColumn();
    public int get_RightColumn();
    public FSharpTokenColorKind get_ColorClass();
    public FSharpTokenCharKind get_CharClass();
    public FSharpTokenTriggerClass get_FSharpTokenTriggerClass();
    public int get_Tag();
    public string get_TokenName();
    public int get_FullMatchedLength();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpTokenInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpTokenInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.SourceCodeServices.FSharpTokenizerColorState : Enum {
    public int value__;
    public static FSharpTokenizerColorState Token;
    public static FSharpTokenizerColorState IfDefSkip;
    public static FSharpTokenizerColorState String;
    public static FSharpTokenizerColorState Comment;
    public static FSharpTokenizerColorState StringInComment;
    public static FSharpTokenizerColorState VerbatimStringInComment;
    public static FSharpTokenizerColorState CamlOnly;
    public static FSharpTokenizerColorState VerbatimString;
    public static FSharpTokenizerColorState SingleLineComment;
    public static FSharpTokenizerColorState EndLineThenSkip;
    public static FSharpTokenizerColorState EndLineThenToken;
    public static FSharpTokenizerColorState TripleQuoteString;
    public static FSharpTokenizerColorState TripleQuoteStringInComment;
    public static FSharpTokenizerColorState InitialState;
}
[StructAttribute]
[CustomEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.FSharpTokenizerLexState : ValueType {
    [DebuggerBrowsableAttribute("0")]
internal long PosBits@;
    [DebuggerBrowsableAttribute("0")]
internal long OtherBits@;
    [CompilationMappingAttribute("4", "0")]
public long PosBits { get; }
    [CompilationMappingAttribute("4", "1")]
public long OtherBits { get; }
    public static FSharpTokenizerLexState Initial { get; }
    public FSharpTokenizerLexState(long posBits, long otherBits);
    public long get_PosBits();
    public long get_OtherBits();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static FSharpTokenizerLexState get_Initial();
    public bool Equals(FSharpTokenizerLexState other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.FSharpTokenTag : object {
    [CompilationMappingAttribute("9")]
public static int Identifier { get; }
    [CompilationMappingAttribute("9")]
public static int String { get; }
    [CompilationMappingAttribute("9")]
public static int IDENT { get; }
    [CompilationMappingAttribute("9")]
public static int STRING { get; }
    [CompilationMappingAttribute("9")]
public static int LPAREN { get; }
    [CompilationMappingAttribute("9")]
public static int RPAREN { get; }
    [CompilationMappingAttribute("9")]
public static int LBRACK { get; }
    [CompilationMappingAttribute("9")]
public static int RBRACK { get; }
    [CompilationMappingAttribute("9")]
public static int LBRACE { get; }
    [CompilationMappingAttribute("9")]
public static int RBRACE { get; }
    [CompilationMappingAttribute("9")]
public static int LBRACK_LESS { get; }
    [CompilationMappingAttribute("9")]
public static int GREATER_RBRACK { get; }
    [CompilationMappingAttribute("9")]
public static int LESS { get; }
    [CompilationMappingAttribute("9")]
public static int GREATER { get; }
    [CompilationMappingAttribute("9")]
public static int LBRACK_BAR { get; }
    [CompilationMappingAttribute("9")]
public static int BAR_RBRACK { get; }
    [CompilationMappingAttribute("9")]
public static int PLUS_MINUS_OP { get; }
    [CompilationMappingAttribute("9")]
public static int MINUS { get; }
    [CompilationMappingAttribute("9")]
public static int STAR { get; }
    [CompilationMappingAttribute("9")]
public static int INFIX_STAR_DIV_MOD_OP { get; }
    [CompilationMappingAttribute("9")]
public static int PERCENT_OP { get; }
    [CompilationMappingAttribute("9")]
public static int INFIX_AT_HAT_OP { get; }
    [CompilationMappingAttribute("9")]
public static int QMARK { get; }
    [CompilationMappingAttribute("9")]
public static int COLON { get; }
    [CompilationMappingAttribute("9")]
public static int EQUALS { get; }
    [CompilationMappingAttribute("9")]
public static int SEMICOLON { get; }
    [CompilationMappingAttribute("9")]
public static int COMMA { get; }
    [CompilationMappingAttribute("9")]
public static int DOT { get; }
    [CompilationMappingAttribute("9")]
public static int DOT_DOT { get; }
    [CompilationMappingAttribute("9")]
public static int INT32_DOT_DOT { get; }
    [CompilationMappingAttribute("9")]
public static int UNDERSCORE { get; }
    [CompilationMappingAttribute("9")]
public static int BAR { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_GREATER { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_QMARK_GREATER { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_QMARK { get; }
    [CompilationMappingAttribute("9")]
public static int INFIX_BAR_OP { get; }
    [CompilationMappingAttribute("9")]
public static int INFIX_COMPARE_OP { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_COLON { get; }
    [CompilationMappingAttribute("9")]
public static int AMP_AMP { get; }
    [CompilationMappingAttribute("9")]
public static int PREFIX_OP { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_EQUALS { get; }
    [CompilationMappingAttribute("9")]
public static int BAR_BAR { get; }
    [CompilationMappingAttribute("9")]
public static int RARROW { get; }
    [CompilationMappingAttribute("9")]
public static int LARROW { get; }
    [CompilationMappingAttribute("9")]
public static int QUOTE { get; }
    [CompilationMappingAttribute("9")]
public static int WHITESPACE { get; }
    [CompilationMappingAttribute("9")]
public static int COMMENT { get; }
    [CompilationMappingAttribute("9")]
public static int LINE_COMMENT { get; }
    [CompilationMappingAttribute("9")]
public static int BEGIN { get; }
    [CompilationMappingAttribute("9")]
public static int DO { get; }
    [CompilationMappingAttribute("9")]
public static int FUNCTION { get; }
    [CompilationMappingAttribute("9")]
public static int THEN { get; }
    [CompilationMappingAttribute("9")]
public static int ELSE { get; }
    [CompilationMappingAttribute("9")]
public static int STRUCT { get; }
    [CompilationMappingAttribute("9")]
public static int CLASS { get; }
    [CompilationMappingAttribute("9")]
public static int TRY { get; }
    [CompilationMappingAttribute("9")]
public static int NEW { get; }
    [CompilationMappingAttribute("9")]
public static int WITH { get; }
    [CompilationMappingAttribute("9")]
public static int OWITH { get; }
    public static int get_Identifier();
    public static int get_String();
    public static int get_IDENT();
    public static int get_STRING();
    public static int get_LPAREN();
    public static int get_RPAREN();
    public static int get_LBRACK();
    public static int get_RBRACK();
    public static int get_LBRACE();
    public static int get_RBRACE();
    public static int get_LBRACK_LESS();
    public static int get_GREATER_RBRACK();
    public static int get_LESS();
    public static int get_GREATER();
    public static int get_LBRACK_BAR();
    public static int get_BAR_RBRACK();
    public static int get_PLUS_MINUS_OP();
    public static int get_MINUS();
    public static int get_STAR();
    public static int get_INFIX_STAR_DIV_MOD_OP();
    public static int get_PERCENT_OP();
    public static int get_INFIX_AT_HAT_OP();
    public static int get_QMARK();
    public static int get_COLON();
    public static int get_EQUALS();
    public static int get_SEMICOLON();
    public static int get_COMMA();
    public static int get_DOT();
    public static int get_DOT_DOT();
    public static int get_INT32_DOT_DOT();
    public static int get_UNDERSCORE();
    public static int get_BAR();
    public static int get_COLON_GREATER();
    public static int get_COLON_QMARK_GREATER();
    public static int get_COLON_QMARK();
    public static int get_INFIX_BAR_OP();
    public static int get_INFIX_COMPARE_OP();
    public static int get_COLON_COLON();
    public static int get_AMP_AMP();
    public static int get_PREFIX_OP();
    public static int get_COLON_EQUALS();
    public static int get_BAR_BAR();
    public static int get_RARROW();
    public static int get_LARROW();
    public static int get_QUOTE();
    public static int get_WHITESPACE();
    public static int get_COMMENT();
    public static int get_LINE_COMMENT();
    public static int get_BEGIN();
    public static int get_DO();
    public static int get_FUNCTION();
    public static int get_THEN();
    public static int get_ELSE();
    public static int get_STRUCT();
    public static int get_CLASS();
    public static int get_TRY();
    public static int get_NEW();
    public static int get_WITH();
    public static int get_OWITH();
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.SourceCodeServices.FSharpTokenTriggerClass : Enum {
    public int value__;
    public static FSharpTokenTriggerClass None;
    public static FSharpTokenTriggerClass MemberSelect;
    public static FSharpTokenTriggerClass MatchBraces;
    public static FSharpTokenTriggerClass ChoiceSelect;
    public static FSharpTokenTriggerClass MethodTip;
    public static FSharpTokenTriggerClass ParamStart;
    public static FSharpTokenTriggerClass ParamNext;
    public static FSharpTokenTriggerClass ParamEnd;
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.FSharpToolTipElement`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpToolTipElement`1<T> _unique_None;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpToolTipElement`1<T> None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGroup { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCompositionError { get; }
    private static FSharpToolTipElement`1();
    [CompilationMappingAttribute("8", "0")]
public static FSharpToolTipElement`1<T> get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNone();
    [CompilationMappingAttribute("8", "1")]
public static FSharpToolTipElement`1<T> NewGroup(FSharpList`1<FSharpToolTipElementData`1<T>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGroup();
    [CompilationMappingAttribute("8", "2")]
public static FSharpToolTipElement`1<T> NewCompositionError(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCompositionError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpToolTipElement`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static FSharpToolTipElement`1<T> Single(T layout, FSharpXmlDoc xml, FSharpOption`1<FSharpList`1<T>> typeMapping, FSharpOption`1<string> paramName, FSharpOption`1<T> remarks);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpToolTipElement`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.FSharpToolTipElementData`1 : object {
    [DebuggerBrowsableAttribute("0")]
internal T MainDescription@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpXmlDoc XmlDoc@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<T> TypeMapping@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<T> Remarks@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ParamName@;
    [CompilationMappingAttribute("4", "0")]
public T MainDescription { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpXmlDoc XmlDoc { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpList`1<T> TypeMapping { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<T> Remarks { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpOption`1<string> ParamName { get; }
    public FSharpToolTipElementData`1(T mainDescription, FSharpXmlDoc xmlDoc, FSharpList`1<T> typeMapping, FSharpOption`1<T> remarks, FSharpOption`1<string> paramName);
    public T get_MainDescription();
    public FSharpXmlDoc get_XmlDoc();
    public FSharpList`1<T> get_TypeMapping();
    public FSharpOption`1<T> get_Remarks();
    public FSharpOption`1<string> get_ParamName();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpToolTipElementData`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal static FSharpToolTipElementData`1<T> Create(T layout, FSharpXmlDoc xml, FSharpOption`1<FSharpList`1<T>> typeMapping, FSharpOption`1<string> paramName, FSharpOption`1<T> remarks);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpToolTipElementData`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.FSharpToolTipText`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<FSharpToolTipElement`1<T>> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FSharpToolTipElement`1<T>> Item { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpToolTipText`1(FSharpList`1<FSharpToolTipElement`1<T>> item);
    [CompilationMappingAttribute("8", "0")]
public static FSharpToolTipText`1<T> NewFSharpToolTipText(FSharpList`1<FSharpToolTipElement`1<T>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FSharpToolTipElement`1<T>> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpToolTipText`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpToolTipText`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpType : object {
    internal TType ty;
    internal SymbolEnv cenv@2042;
    public bool IsUnresolved { get; }
    public bool HasTypeDefinition { get; }
    public bool IsTupleType { get; }
    public bool IsStructTupleType { get; }
    [ObsoleteAttribute("Renamed to HasTypeDefinition")]
public bool IsNamedType { get; }
    [ObsoleteAttribute("Renamed to TypeDefinition")]
public FSharpEntity NamedEntity { get; }
    public FSharpEntity TypeDefinition { get; }
    public IList`1<FSharpType> GenericArguments { get; }
    public bool IsAbbreviation { get; }
    public FSharpType AbbreviatedType { get; }
    public bool IsFunctionType { get; }
    public bool IsAnonRecordType { get; }
    public FSharpAnonRecordTypeDetails AnonRecordTypeDetails { get; }
    public bool IsGenericParameter { get; }
    public FSharpGenericParameter GenericParameter { get; }
    public IList`1<FSharpType> AllInterfaces { get; }
    public FSharpOption`1<FSharpType> BaseType { get; }
    internal TType V { get; }
    internal SymbolEnv cenv { get; }
    internal FSharpType(SymbolEnv cenv, TType ty);
    internal FSharpType(TcGlobals g, CcuThunk thisCcu, ModuleOrNamespaceType thisCcuTyp, TcImports tcImports, TType ty);
    public bool get_IsUnresolved();
    public bool get_HasTypeDefinition();
    public bool get_IsTupleType();
    public bool get_IsStructTupleType();
    public bool get_IsNamedType();
    public FSharpEntity get_NamedEntity();
    public FSharpEntity get_TypeDefinition();
    public IList`1<FSharpType> get_GenericArguments();
    public bool get_IsAbbreviation();
    public FSharpType get_AbbreviatedType();
    public bool get_IsFunctionType();
    public bool get_IsAnonRecordType();
    public FSharpAnonRecordTypeDetails get_AnonRecordTypeDetails();
    public bool get_IsGenericParameter();
    public FSharpGenericParameter get_GenericParameter();
    public IList`1<FSharpType> get_AllInterfaces();
    public FSharpOption`1<FSharpType> get_BaseType();
    public FSharpType Instantiate(FSharpList`1<Tuple`2<FSharpGenericParameter, FSharpType>> instantiation);
    internal TType get_V();
    internal SymbolEnv get_cenv();
    internal FSharpType AdjustType(TType t);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public string Format(FSharpDisplayContext context);
    public Layout FormatLayout(FSharpDisplayContext context);
    public virtual string ToString();
    public static FSharpType Prettify(FSharpType ty);
    public static IList`1<FSharpType> Prettify(IList`1<FSharpType> types);
    public static FSharpParameter Prettify(FSharpParameter parameter);
    public static IList`1<FSharpParameter> Prettify(IList`1<FSharpParameter> parameters);
    public static IList`1<IList`1<FSharpParameter>> Prettify(IList`1<IList`1<FSharpParameter>> parameters);
    public static Tuple`2<IList`1<IList`1<FSharpParameter>>, FSharpParameter> Prettify(IList`1<IList`1<FSharpParameter>> parameters, FSharpParameter returnParameter);
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal bool isResolved();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.SourceCodeServices.FSharpUnionCase : FSharpSymbol {
    internal UnionCaseRef v;
    internal SymbolEnv cenv;
    public bool IsUnresolved { get; }
    public string Name { get; }
    public range DeclarationLocation { get; }
    public IList`1<FSharpField> UnionCaseFields { get; }
    public FSharpType ReturnType { get; }
    public string CompiledName { get; }
    public string XmlDocSig { get; }
    public IList`1<string> XmlDoc { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public FSharpAccessibility Accessibility { get; }
    internal UnionCaseRef V { get; }
    internal FSharpUnionCase(SymbolEnv cenv, UnionCaseRef v);
    public bool get_IsUnresolved();
    public string get_Name();
    public range get_DeclarationLocation();
    public IList`1<FSharpField> get_UnionCaseFields();
    public FSharpType get_ReturnType();
    public string get_CompiledName();
    public string get_XmlDocSig();
    public IList`1<string> get_XmlDoc();
    public IList`1<FSharpAttribute> get_Attributes();
    public FSharpAccessibility get_Accessibility();
    internal UnionCaseRef get_V();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal void checkIsResolved();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.FSharpXmlDoc : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpXmlDoc _unique_None;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpXmlDoc None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsText { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXmlDocFileSignature { get; }
    private static FSharpXmlDoc();
    [CompilationMappingAttribute("8", "0")]
public static FSharpXmlDoc get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNone();
    [CompilationMappingAttribute("8", "1")]
public static FSharpXmlDoc NewText(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsText();
    [CompilationMappingAttribute("8", "2")]
public static FSharpXmlDoc NewXmlDocFileSignature(string item1, string item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXmlDocFileSignature();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpXmlDoc obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpXmlDoc obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.FsiInteractiveChecker : object {
    internal TcState tcState;
    internal TcImports tcImports;
    internal TcGlobals tcGlobals;
    internal TcConfig tcConfig;
    internal IReactorOperations reactorOps;
    internal Resolver legacyReferenceResolver;
    internal bool keepAssemblyContents;
    public FsiInteractiveChecker(Resolver legacyReferenceResolver, IReactorOperations ops, TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, TcState tcState);
    internal FSharpAsync`1<Tuple`3<FSharpParseFileResults, FSharpCheckFileResults, FSharpCheckProjectResults>> ParseAndCheckInteraction(CompilationThreadToken ctok, ISourceText sourceText, FSharpOption`1<string> userOpName);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.SourceCodeServices.GetPreciseCompletionListFromExprTypingsResult : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static GetPreciseCompletionListFromExprTypingsResult _unique_NoneBecauseTypecheckIsStaleAndTextChanged;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static GetPreciseCompletionListFromExprTypingsResult _unique_NoneBecauseThereWereTypeErrors;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static GetPreciseCompletionListFromExprTypingsResult _unique_None;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static GetPreciseCompletionListFromExprTypingsResult NoneBecauseTypecheckIsStaleAndTextChanged { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoneBecauseTypecheckIsStaleAndTextChanged { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static GetPreciseCompletionListFromExprTypingsResult NoneBecauseThereWereTypeErrors { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoneBecauseThereWereTypeErrors { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static GetPreciseCompletionListFromExprTypingsResult None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSome { get; }
    private static GetPreciseCompletionListFromExprTypingsResult();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal GetPreciseCompletionListFromExprTypingsResult(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static GetPreciseCompletionListFromExprTypingsResult get_NoneBecauseTypecheckIsStaleAndTextChanged();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoneBecauseTypecheckIsStaleAndTextChanged();
    [CompilationMappingAttribute("8", "1")]
internal static GetPreciseCompletionListFromExprTypingsResult get_NoneBecauseThereWereTypeErrors();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoneBecauseThereWereTypeErrors();
    [CompilationMappingAttribute("8", "2")]
internal static GetPreciseCompletionListFromExprTypingsResult get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNone();
    [CompilationMappingAttribute("8", "3")]
internal static GetPreciseCompletionListFromExprTypingsResult NewSome(Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, range> item1, TType item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSome();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.Helpers : object {
    internal static bool AreSameForChecking2(Tuple`2<string, FSharpProjectOptions> _arg1, Tuple`2<string, FSharpProjectOptions> _arg2);
    internal static bool AreSubsumable2(Tuple`2<string, FSharpProjectOptions> _arg1, Tuple`2<string, FSharpProjectOptions> _arg2);
    internal static bool AreSameForParsing(Tuple`3<string, int, a> _arg1, Tuple`3<string, int, a> _arg2);
    internal static bool AreSimilarForParsing(Tuple`3<a, b, c> _arg1, Tuple`3<a, d, e> _arg2);
    internal static bool AreSameForChecking3(Tuple`3<string, int, FSharpProjectOptions> _arg1, Tuple`3<string, int, FSharpProjectOptions> _arg2);
    internal static bool AreSubsumable3(Tuple`3<string, a, FSharpProjectOptions> _arg1, Tuple`3<string, b, FSharpProjectOptions> _arg2);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("3")]
public interface FSharp.Compiler.SourceCodeServices.IAssemblyContentCache {
    public abstract virtual FSharpOption`1<AssemblyContentCacheEntry> TryGet(string );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void Set(string , AssemblyContentCacheEntry );
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.Impl : object {
    internal static a dflt@112(string tupledArg0, string tupledArg1);
    internal static a protect(FSharpFunc`2<Unit, a> f);
    internal static IList`1<string> makeXmlDoc(XmlDoc _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef rescopeEntity(FSharpOption`1<CcuThunk> optViewedCcu, Entity entity);
    internal static bool entityIsUnresolved(EntityRef entity);
    internal static void checkEntityIsResolved(EntityRef entity);
    internal static string nameOfScoRef@105(CcuThunk thisCcu, ILScopeRef scoref);
    internal static bool loop@111-100(FSharpList`1<Tuple`2<a, b>> p1, FSharpList`1<Tuple`2<a, b>> p2);
    internal static bool canAccessCompPathFromCrossProject@110(CcuThunk thisCcu2, CcuThunk thisCcu1, CompilationPath _arg2, CompilationPath _arg1);
    internal static FSharpFunc`2<CompilationPath, bool> canAccessFromCrossProject@118(CcuThunk thisCcu2, CcuThunk thisCcu1, Accessibility _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkForCrossProjectAccessibility(CcuThunk thisCcu2, AccessorDomain ad2, CcuThunk thisCcu1, Accessibility taccess1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility getApproxFSharpAccessibilityOfMember(EntityRef declaringEntity, ILMemberAccess ilAccess);
    internal static Accessibility getApproxFSharpAccessibilityOfEntity(EntityRef entity);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<object> getLiteralValue$cont@162(FSharpOption`1<Const> _arg1, Unit unitVar);
    internal static FSharpOption`1<object> getLiteralValue(FSharpOption`1<Const> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getXmlDocSigForEntity(SymbolEnv cenv, EntityRef ent);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.InheritanceContext : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceContext _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceContext _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceContext _unique_Unknown;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InheritanceContext Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InheritanceContext Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InheritanceContext Unknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknown { get; }
    private static InheritanceContext();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InheritanceContext(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static InheritanceContext get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "1")]
public static InheritanceContext get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "2")]
public static InheritanceContext get_Unknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InheritanceContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InheritanceContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.SourceCodeServices.InheritanceOrigin : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceOrigin _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceOrigin _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceOrigin _unique_Unknown;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static InheritanceOrigin Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static InheritanceOrigin Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static InheritanceOrigin Unknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnknown { get; }
    private static InheritanceOrigin();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InheritanceOrigin(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static InheritanceOrigin get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsClass();
    [CompilationMappingAttribute("8", "1")]
internal static InheritanceOrigin get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInterface();
    [CompilationMappingAttribute("8", "2")]
internal static InheritanceOrigin get_Unknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InheritanceOrigin obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InheritanceOrigin obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.InsertContext : object {
    [DebuggerBrowsableAttribute("0")]
internal ScopeKind ScopeKind@;
    [DebuggerBrowsableAttribute("0")]
internal pos Pos@;
    [CompilationMappingAttribute("4", "0")]
public ScopeKind ScopeKind { get; }
    [CompilationMappingAttribute("4", "1")]
public pos Pos { get; }
    public InsertContext(ScopeKind scopeKind, pos pos);
    public ScopeKind get_ScopeKind();
    public pos get_Pos();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InsertContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.InterfaceData : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsObjExpr { get; }
    public range Range { get; }
    public String[] TypeParameters { get; }
    [CompilationMappingAttribute("8", "0")]
public static InterfaceData NewInterface(SynType item1, FSharpOption`1<FSharpList`1<SynMemberDefn>> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "1")]
public static InterfaceData NewObjExpr(SynType item1, FSharpList`1<SynBinding> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsObjExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public range get_Range();
    public String[] get_TypeParameters();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.InterfaceStubGenerator : object {
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@172-17(IEqualityComparer comp, Context this, Unit unitVar);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<T>, T>> |AllAndLast|_|(FSharpList`1<T> xs);
    internal static string getTypeParameterName(FSharpGenericParameter typar);
    internal static string bracket(string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string formatType(Context ctx, FSharpType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> formatArgUsage(Context ctx, bool hasTypeAnnotation, FSharpMap`2<string, FSharpSet`1<int>> namesWithIndices, FSharpParameter arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> formatArgsUsage(Context ctx, bool hasTypeAnnotation, FSharpMemberOrFunctionOrValue v, FSharpList`1<FSharpList`1<a>> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<FSharpParameter>>, string> getArgTypes(Context ctx, FSharpMemberOrFunctionOrValue v);
    internal static string normalizePropertyName(FSharpMemberOrFunctionOrValue v);
    internal static bool isEventMember(FSharpMemberOrFunctionOrValue m);
    internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> getParamArgs@302(bool verboseMode, FSharpList`1<FSharpList`1<FSharpParameter>> argInfos, Context ctx, FSharpMemberOrFunctionOrValue v);
    internal static string buildUsage@319(bool verboseMode, Context ctx, FSharpMemberOrFunctionOrValue v, FSharpList`1<FSharpList`1<FSharpParameter>> argInfos);
    internal static Tuple`4<string, FSharpList`1<string>, FSharpList`1<FSharpList`1<FSharpParameter>>, string> preprocess@318(bool verboseMode, Context ctx, FSharpMemberOrFunctionOrValue v);
    internal static FSharpFunc`2<ColumnIndentedTextWriter, Unit> closeDeclaration@345(bool verboseMode, string returnType);
    internal static FSharpFunc`2<ColumnIndentedTextWriter, Unit> writeImplementation@349(bool verboseMode, Context ctx);
    [CompilerGeneratedAttribute]
internal static void formatMember$cont@406-1(Context ctx, bool verboseMode, FSharpMemberOrFunctionOrValue v, string usage, string retType, FSharpList`1<FSharpList`1<FSharpParameter>> argInfos, FSharpFunc`2<ColumnIndentedTextWriter, Unit> writeImplementation, ColumnIndentedTextWriter writer, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void formatMember$cont@390(Context ctx, MemberInfo m, bool verboseMode, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void formatMember$cont@360-2(Context ctx, MemberInfo m, bool verboseMode, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void formatMember(Context ctx, MemberInfo m, bool verboseMode);
    internal static FSharpType getNonAbbreviatedType(FSharpType ty);
    internal static FSharpOption`1<FSharpType> |MemberFunctionType|_|(FSharpType ty);
    internal static FSharpOption`1<FSharpType> |TypeOfMember|_|(FSharpMemberOrFunctionOrValue m);
    internal static IEnumerable`1<Tuple`2<FSharpEntity, IEnumerable`1<Tuple`2<FSharpGenericParameter, FSharpType>>>> getInterfaces(FSharpEntity e);
    public static IEnumerable`1<Tuple`2<FSharpMemberOrFunctionOrValue, IEnumerable`1<Tuple`2<FSharpGenericParameter, FSharpType>>>> getInterfaceMembers(FSharpEntity e);
    public static bool hasNoInterfaceMember(FSharpEntity e);
    internal static FSharpOption`1<Tuple`2<string, range>> |LongIdentPattern|_|(SynPat _arg1);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<string, range>> |MemberNameAndRange|_|$cont@511(SynBinding _arg1, Unit unitVar);
    internal static FSharpOption`1<Tuple`2<string, range>> |MemberNameAndRange|_|(SynBinding _arg1);
    public static FSharpList`1<Tuple`2<string, range>> getMemberNameAndRanges(InterfaceData _arg1);
    internal static string normalizeEventName(FSharpMemberOrFunctionOrValue m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpSet`1<string>> getImplementedMemberSignatures(FSharpFunc`2<Tuple`2<string, range>, FSharpAsync`1<FSharpOption`1<FSharpSymbolUse>>> getMemberByLocation, FSharpDisplayContext displayContext, InterfaceData interfaceData);
    public static bool isInterface(FSharpEntity e);
    internal static void formatMembers@638(int indentation, string objectIdent, FSharpDisplayContext displayContext, bool verboseMode, String[] lines, ColumnIndentedTextWriter writer, FSharpMap`2<string, string> instantiations, Context ctx, FSharpSet`1<string> duplicatedMembers, FSharpList`1<Tuple`2<FSharpMemberOrFunctionOrValue, a>> members);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string formatInterface(int startColumn, int indentation, String[] typeInstances, string objectIdent, string methodBody, FSharpDisplayContext displayContext, FSharpSet`1<string> excludedMemberSignatures, FSharpEntity e, bool verboseMode);
    internal static FSharpOption`1<InterfaceData> walkSynModuleOrNamespace@672-7(pos pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynModuleOrNamespace _arg2);
    internal static FSharpOption`1<InterfaceData> walkSynTypeDefn@702-1(pos pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynTypeDefn _arg3);
    internal static FSharpOption`1<InterfaceData> walkSynTypeDefnRepr@709-1(pos pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynTypeDefnRepr typeDefnRepr);
    internal static FSharpOption`1<InterfaceData> walkBinding@747-5(pos pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynBinding _arg4);
    internal static FSharpOption`1<InterfaceData> walkExpr@750-63(pos pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<InterfaceData> tryFindInterfaceDeclaration(pos pos, ParsedInput parsedInput);
}
[CompilationMappingAttribute("3")]
internal interface FSharp.Compiler.SourceCodeServices.IReactorOperations {
    public abstract virtual FSharpAsync`1<T> EnqueueAndAwaitOpAsync(string userOpName, string opName, string opArg, FSharpFunc`2<CompilationThreadToken, Cancellable`1<T>> action);
    public abstract virtual void EnqueueOp(string userOpName, string opName, string opArg, FSharpFunc`2<CompilationThreadToken, Unit> action);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.SourceCodeServices.IsResultObsolete : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<Unit, bool> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<Unit, bool> Item { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IsResultObsolete(FSharpFunc`2<Unit, bool> item);
    [CompilationMappingAttribute("8", "0")]
internal static IsResultObsolete NewIsResultObsolete(FSharpFunc`2<Unit, bool> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<Unit, bool> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.Keywords : object {
    [CompilationMappingAttribute("9")]
public static FSharpList`1<Tuple`2<string, string>> KeywordsWithDescription { get; }
    public static bool DoesIdentifierNeedQuotation(string s);
    public static string QuoteIdentifierIfNeeded(string s);
    public static string NormalizeIdentifierBackticks(string s);
    public static FSharpList`1<Tuple`2<string, string>> get_KeywordsWithDescription();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.LexerStateEncoding : object {
    [CompilationMappingAttribute("9")]
internal static LexerWhitespaceContinuation revertToDefaultLexCont { get; }
    internal static int lexstateNumBits { get; }
    internal static int ncommentsNumBits { get; }
    internal static int hardwhiteNumBits { get; }
    internal static int ifdefstackCountNumBits { get; }
    internal static int ifdefstackNumBits { get; }
    internal static int lexstateStart { get; }
    internal static int ncommentsStart { get; }
    internal static int hardwhitePosStart { get; }
    internal static int ifdefstackCountStart { get; }
    internal static int ifdefstackStart { get; }
    [CompilationMappingAttribute("9")]
internal static long lexstateMask { get; }
    [CompilationMappingAttribute("9")]
internal static long ncommentsMask { get; }
    [CompilationMappingAttribute("9")]
internal static long hardwhitePosMask { get; }
    [CompilationMappingAttribute("9")]
internal static long ifdefstackCountMask { get; }
    [CompilationMappingAttribute("9")]
internal static long ifdefstackMask { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LexerWhitespaceContinuation computeNextLexState(token token, LexerWhitespaceContinuation prevLexcont);
    internal static LexerWhitespaceContinuation get_revertToDefaultLexCont();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_lexstateNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ncommentsNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_hardwhiteNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ifdefstackCountNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ifdefstackNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_lexstateStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ncommentsStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_hardwhitePosStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ifdefstackCountStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ifdefstackStart();
    internal static long get_lexstateMask();
    internal static long get_ncommentsMask();
    internal static long get_hardwhitePosMask();
    internal static long get_ifdefstackCountMask();
    internal static long get_ifdefstackMask();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpTokenizerLexState encodeLexCont(FSharpTokenizerColorState colorState, long ncomments, pos b, IEnumerable`1<Tuple`2<LexerIfdefStackEntry, a>> ifdefStack, bool light);
    internal static Tuple`5<FSharpTokenizerColorState, int, pos, FSharpList`1<Tuple`2<LexerIfdefStackEntry, range>>, bool> decodeLexCont(FSharpTokenizerLexState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpTokenizerLexState encodeLexInt(bool lightSyntaxStatus, LexerWhitespaceContinuation lexcont);
    internal static Tuple`2<bool, LexerWhitespaceContinuation> decodeLexInt(FSharpTokenizerLexState state);
    internal static lexargs argsWithIfDefs@475(lexargs args, FSharpList`1<Tuple`2<LexerIfdefStackEntry, range>> ifd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token callLexCont(LexerWhitespaceContinuation lexcont, lexargs args, bool skip, LexBuffer`1<char> lexbuf);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.LookupType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LookupType _unique_Fuzzy;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LookupType _unique_Precise;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LookupType Fuzzy { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFuzzy { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LookupType Precise { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPrecise { get; }
    private static LookupType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal LookupType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static LookupType get_Fuzzy();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFuzzy();
    [CompilationMappingAttribute("8", "1")]
public static LookupType get_Precise();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPrecise();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(LookupType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LookupType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.MaybeUnresolvedIdent : object {
    [DebuggerBrowsableAttribute("0")]
internal string Ident@;
    [DebuggerBrowsableAttribute("0")]
internal bool Resolved@;
    [CompilationMappingAttribute("4", "0")]
public string Ident { get; }
    [CompilationMappingAttribute("4", "1")]
public bool Resolved { get; }
    public MaybeUnresolvedIdent(string ident, bool resolved);
    public string get_Ident();
    public bool get_Resolved();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MaybeUnresolvedIdent obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MaybeUnresolvedIdent obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.SourceCodeServices.Module : object {
    [DebuggerBrowsableAttribute("0")]
internal String[] Idents@;
    [DebuggerBrowsableAttribute("0")]
internal range Range@;
    [CompilationMappingAttribute("4", "0")]
internal String[] Idents { get; }
    [CompilationMappingAttribute("4", "1")]
internal range Range { get; }
    internal Module(String[] idents, range range);
    internal String[] get_Idents();
    internal range get_Range();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Module obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.ModuleKind : object {
    [DebuggerBrowsableAttribute("0")]
internal bool IsAutoOpen@;
    [DebuggerBrowsableAttribute("0")]
internal bool HasModuleSuffix@;
    [CompilationMappingAttribute("4", "0")]
public bool IsAutoOpen { get; }
    [CompilationMappingAttribute("4", "1")]
public bool HasModuleSuffix { get; }
    public ModuleKind(bool isAutoOpen, bool hasModuleSuffix);
    public bool get_IsAutoOpen();
    public bool get_HasModuleSuffix();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ModuleKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.SourceCodeServices.NameResResult : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NameResResult _unique_Empty;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NameResResult _unique_TypecheckStaleAndTextChanged;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsMembers { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCancel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NameResResult Empty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NameResResult TypecheckStaleAndTextChanged { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTypecheckStaleAndTextChanged { get; }
    private static NameResResult();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NameResResult(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static NameResResult NewMembers(Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, range> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsMembers();
    [CompilationMappingAttribute("8", "1")]
internal static NameResResult NewCancel(DisplayEnv item1, range item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCancel();
    [CompilationMappingAttribute("8", "2")]
internal static NameResResult get_Empty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsEmpty();
    [CompilationMappingAttribute("8", "3")]
internal static NameResResult get_TypecheckStaleAndTextChanged();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTypecheckStaleAndTextChanged();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.NavigateTo : object {
    internal static FSharpOption`1<Ident> lastInLid@492(FSharpList`1<Ident> lid);
    internal static string formatLongIdent@498(FSharpList`1<Ident> lid);
    internal static void addIdent@501(List`1<NavigableItem> result, NavigableItemKind kind, Ident id, bool isSignature, Container container);
    internal static void addModule@511(List`1<NavigableItem> result, FSharpList`1<Ident> lid, bool isSig, Container container);
    internal static Container addExceptionRepr@519(List`1<NavigableItem> result, SynExceptionDefnRepr _arg1, bool isSig, Container container);
    internal static Container addComponentInfo@523(List`1<NavigableItem> result, ContainerType containerType, NavigableItemKind kind, SynComponentInfo _arg2, bool isSig, Container container);
    internal static void addField@532(List`1<NavigableItem> result, SynField _arg4, bool isSig, Container container);
    internal static FSharpFunc`2<Container, Unit> addEnumCase@537(FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynEnumCase _arg5, bool isSig);
    internal static NavigableItemKind mapMemberKind@543(MemberKind mk);
    internal static void addBinding@552(List`1<NavigableItem> result, SynBinding _arg7, FSharpOption`1<NavigableItemKind> itemKind, Container container);
    internal static void walkSigFileInput@578(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, ParsedSigFileInput _arg8);
    internal static void walkSynModuleOrNamespaceSig@582(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynModuleOrNamespaceSig _arg9, Container container);
    internal static void walkSynModuleSigDecl@592(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynModuleSigDecl decl, Container container);
    internal static void walkSynTypeDefnSig@612(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynTypeDefnSig _arg10, Container container);
    internal static void walkSynMemberSig@624(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynMemberSig synMemberSig, Container container);
    internal static void walkImplFileInpit@635(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, ParsedImplFileInput _arg11);
    internal static void walkSynModuleOrNamespace@640(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynModuleOrNamespace _arg12, Container container);
    internal static void walkSynModuleDecl@650(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynModuleDecl decl, Container container);
    internal static void walkSynTypeDefn@675(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynTypeDefn _arg13, Container container);
    internal static void walkSynTypeDefnRepr@681(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynTypeDefnRepr typeDefnRepr, Container container);
    internal static void walkSynTypeDefnSimpleRepr@690(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynTypeDefnSimpleRepr repr, bool isSig, Container container);
    internal static void walkSynMemberDefn@708(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<Container, Unit>>>> addIdent, SynMemberDefn memberDefn, Container container);
    public static NavigableItem[] getNavigableItems(ParsedInput parsedInput);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.NavigationImpl : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>, range> rangeOfDecls { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range unionRangesChecked(range r1, range r2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range rangeOfDecls2(FSharpFunc`2<a, FSharpNavigationDeclarationItem> f, FSharpList`1<a> decls);
    internal static FSharpFunc`2<FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>, range> get_rangeOfDecls();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range moduleRange(range idm, FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, a, b>> others);
    internal static range fldspecRange(SynUnionCaseType fldspec);
    internal static int addItemName@102(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string name);
    internal static string uniqueName@107(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string name, int idx);
    internal static Tuple`3<FSharpNavigationDeclarationItem, int, a> createDeclLid@112(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string tupledArg0, FSharpList`1<Ident> tupledArg1, FSharpNavigationDeclarationItemKind tupledArg2, FSharpGlyph tupledArg3, range tupledArg4, range tupledArg5, a tupledArg6, FSharpEnclosingEntityKind tupledArg7, bool tupledArg8, FSharpOption`1<SynAccess> tupledArg9);
    internal static Tuple`3<FSharpNavigationDeclarationItem, int, a> createDecl@117(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string tupledArg0, Ident tupledArg1, FSharpNavigationDeclarationItemKind tupledArg2, FSharpGlyph tupledArg3, range tupledArg4, range tupledArg5, a tupledArg6, FSharpEnclosingEntityKind tupledArg7, bool tupledArg8, FSharpOption`1<SynAccess> tupledArg9);
    internal static Tuple`2<FSharpNavigationDeclarationItem, int> createMemberLid@123(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpList`1<Ident> tupledArg0, FSharpNavigationDeclarationItemKind tupledArg1, FSharpGlyph tupledArg2, range tupledArg3, FSharpEnclosingEntityKind tupledArg4, bool tupledArg5, FSharpOption`1<SynAccess> tupledArg6);
    internal static Tuple`2<FSharpNavigationDeclarationItem, int> createMember@126-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, Ident tupledArg0, FSharpNavigationDeclarationItemKind tupledArg1, FSharpGlyph tupledArg2, range tupledArg3, FSharpEnclosingEntityKind tupledArg4, bool tupledArg5, FSharpOption`1<SynAccess> tupledArg6);
    internal static FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>> processBinding@130(FSharpRef`1<FSharpMap`2<string, int>> nameMap, bool isMember, FSharpEnclosingEntityKind enclosingEntityKind, bool isAbstract, SynBinding _arg1);
    internal static FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, a>> processExnDefnRepr@161(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpFunc`2<bool, FSharpFunc`2<FSharpEnclosingEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>>>> processBinding, string baseName, a nested, SynExceptionDefnRepr _arg2);
    internal static FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>> processExnDefn@166(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpFunc`2<bool, FSharpFunc`2<FSharpEnclosingEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>>>> processBinding, string baseName, SynExceptionDefn _arg3);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>> processTycon$cont@181(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, SynTypeDefnRepr repr, range m, FSharpList`1<Ident> lid, FSharpOption`1<SynAccess> access, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>> topMembers, Unit unitVar);
    internal static FSharpFunc`2<SynTypeDefn, FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>>> processTycon@170(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpFunc`2<bool, FSharpFunc`2<FSharpEnclosingEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>>>> processBinding, string baseName);
    internal static Tuple`2<range, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>> processMembers@210(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpFunc`2<bool, FSharpFunc`2<FSharpEnclosingEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>>>> processBinding, FSharpList`1<SynMemberDefn> members, FSharpEnclosingEntityKind enclosingEntityKind);
    internal static FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>> processNestedDeclarations@249(FSharpFunc`2<bool, FSharpFunc`2<FSharpEnclosingEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>>>> processBinding, FSharpList`1<SynModuleDecl> decls);
    internal static FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>> processFSharpNavigationTopLevelDeclarations@255(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpFunc`2<bool, FSharpFunc`2<FSharpEnclosingEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>>>> processBinding, string tupledArg0, FSharpList`1<SynModuleDecl> tupledArg1);
    internal static FSharpNavigationDeclarationItem mapping@1-32(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpNavigationDeclarationItem d, FSharpNavigationDeclarationItem tupledArg0, int tupledArg1);
    internal static FSharpNavigationTopLevelDeclaration mapping@1-31(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpNavigationDeclarationItem tupledArg0, int tupledArg1, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>> tupledArg2);
    internal static FSharpNavigationItems getNavigationFromImplFile(FSharpList`1<SynModuleOrNamespace> modules);
    internal static int addItemName@309-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string name);
    internal static string uniqueName@313-4(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string name, int idx);
    internal static Tuple`3<FSharpNavigationDeclarationItem, int, a> createDeclLid@318-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string tupledArg0, FSharpList`1<Ident> tupledArg1, FSharpNavigationDeclarationItemKind tupledArg2, FSharpGlyph tupledArg3, range tupledArg4, range tupledArg5, a tupledArg6, FSharpEnclosingEntityKind tupledArg7, bool tupledArg8, FSharpOption`1<SynAccess> tupledArg9);
    internal static Tuple`3<FSharpNavigationDeclarationItem, int, a> createDecl@323-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string tupledArg0, Ident tupledArg1, FSharpNavigationDeclarationItemKind tupledArg2, FSharpGlyph tupledArg3, range tupledArg4, range tupledArg5, a tupledArg6, FSharpEnclosingEntityKind tupledArg7, bool tupledArg8, FSharpOption`1<SynAccess> tupledArg9);
    internal static Tuple`2<FSharpNavigationDeclarationItem, int> createMember@328-2(FSharpRef`1<FSharpMap`2<string, int>> nameMap, Ident tupledArg0, FSharpNavigationDeclarationItemKind tupledArg1, FSharpGlyph tupledArg2, range tupledArg3, FSharpEnclosingEntityKind tupledArg4, bool tupledArg5, FSharpOption`1<SynAccess> tupledArg6);
    internal static FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, a>> processExnRepr@331(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, a nested, SynExceptionDefnRepr _arg1);
    internal static FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>> processExnSig@335(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, SynExceptionSig _arg2);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>> processTycon$cont@350-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, SynTypeDefnSigRepr repr, range m, FSharpList`1<Ident> lid, FSharpOption`1<SynAccess> access, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>> topMembers, Unit unitVar);
    internal static FSharpFunc`2<SynTypeDefnSig, FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>>> processTycon@339-2(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName);
    internal static FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>> processSigMembers@378(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpList`1<SynMemberSig> members);
    internal static FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>> processNestedSigDeclarations@388(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpList`1<SynModuleSigDecl> decls);
    internal static FSharpList`1<Tuple`3<FSharpNavigationDeclarationItem, int, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>>>> processFSharpNavigationTopLevelSigDeclarations@395(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string tupledArg0, FSharpList`1<SynModuleSigDecl> tupledArg1);
    internal static FSharpNavigationDeclarationItem mapping@1-35(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpNavigationDeclarationItem d, FSharpNavigationDeclarationItem tupledArg0, int tupledArg1);
    internal static FSharpNavigationTopLevelDeclaration mapping@1-34(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpNavigationDeclarationItem tupledArg0, int tupledArg1, FSharpList`1<Tuple`2<FSharpNavigationDeclarationItem, int>> tupledArg2);
    internal static FSharpNavigationItems getNavigationFromSigFile(FSharpList`1<SynModuleOrNamespaceSig> modules);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.NoteworthyParamInfoLocationsImpl : object {
    internal static bool isStaticArg(SynType a);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<string>, range>> digOutIdentFromFuncExpr(SynExpr synExpr);
    internal static FSharpOption`1<string> digOutIdentFromStaticArg(SynType synType);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<string> getNamedParamName$cont@61(SynExpr e, Unit unitVar);
    internal static FSharpOption`1<string> getNamedParamName(SynExpr e);
    internal static FSharpList`1<string> getTypeName(SynType synType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FindResult, FSharpOption`1<c>> handleSingleArg(FSharpFunc`2<SynExpr, FSharpOption`1<a>> traverseSynExpr, pos pos, SynExpr synExpr, range parenRange, FSharpOption`1<b> rpRangeOpt);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FindResult, FSharpOption`1<FSharpOption`1<a>>> searchSynArgExpr$cont@98(FSharpFunc`2<SynExpr, FSharpOption`1<a>> traverseSynExpr, pos pos, SynExpr expr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FindResult, FSharpOption`1<FSharpOption`1<a>>> searchSynArgExpr(FSharpFunc`2<SynExpr, FSharpOption`1<a>> traverseSynExpr, pos pos, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpNoteworthyParamInfoLocations> |StaticParameters|_|(pos pos, SynType synType);
    internal static FSharpOption`1<FSharpNoteworthyParamInfoLocations> traverseInput(pos pos, ParsedInput parseTree);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.OpenStatementInsertionPoint : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static OpenStatementInsertionPoint _unique_TopLevel;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static OpenStatementInsertionPoint _unique_Nearest;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static OpenStatementInsertionPoint TopLevel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTopLevel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static OpenStatementInsertionPoint Nearest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNearest { get; }
    private static OpenStatementInsertionPoint();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal OpenStatementInsertionPoint(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static OpenStatementInsertionPoint get_TopLevel();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTopLevel();
    [CompilationMappingAttribute("8", "1")]
public static OpenStatementInsertionPoint get_Nearest();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNearest();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(OpenStatementInsertionPoint obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OpenStatementInsertionPoint obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.Option : object {
    internal static FSharpOption`1<FSharpList`1<a>> ofOptionList(FSharpList`1<FSharpOption`1<a>> xs);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.ParamTypeSymbol : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParam { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsByref { get; }
    [CompilationMappingAttribute("8", "0")]
public static ParamTypeSymbol NewParam(ExternalType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParam();
    [CompilationMappingAttribute("8", "1")]
public static ParamTypeSymbol NewByref(ExternalType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsByref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ParamTypeSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ParamTypeSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.ParamTypeSymbolModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ParamTypeSymbol> tryOfILType(String[] typeVarNames, ILType _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<ParamTypeSymbol>> tryOfILTypes(String[] typeVarNames, FSharpList`1<ILType> ilTypes);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.SourceCodeServices.Parent : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> Namespace@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> ThisRequiresQualifiedAccess@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> TopRequiresQualifiedAccess@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> AutoOpen@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> WithModuleSuffix@;
    [DebuggerBrowsableAttribute("0")]
internal bool IsModule@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpOption`1<String[]> Namespace { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> ThisRequiresQualifiedAccess { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> TopRequiresQualifiedAccess { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpOption`1<String[]> AutoOpen { get; }
    [CompilationMappingAttribute("4", "4")]
internal FSharpOption`1<String[]> WithModuleSuffix { get; }
    [CompilationMappingAttribute("4", "5")]
internal bool IsModule { get; }
    internal static Parent Empty { get; }
    internal Parent(FSharpOption`1<String[]> namespace, FSharpFunc`2<bool, FSharpOption`1<String[]>> thisRequiresQualifiedAccess, FSharpFunc`2<bool, FSharpOption`1<String[]>> topRequiresQualifiedAccess, FSharpOption`1<String[]> autoOpen, FSharpOption`1<String[]> withModuleSuffix, bool isModule);
    internal FSharpOption`1<String[]> get_Namespace();
    internal FSharpFunc`2<bool, FSharpOption`1<String[]>> get_ThisRequiresQualifiedAccess();
    internal FSharpFunc`2<bool, FSharpOption`1<String[]>> get_TopRequiresQualifiedAccess();
    internal FSharpOption`1<String[]> get_AutoOpen();
    internal FSharpOption`1<String[]> get_WithModuleSuffix();
    internal bool get_IsModule();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal static Parent get_Empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] RewriteParentIdents(FSharpOption`1<String[]> parentIdents, String[] idents);
    internal String[] FixParentModuleSuffix(String[] idents);
    internal FSharpOption`1<Tuple`2<string, String[]>> FormatEntityFullName(FSharpEntity entity);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.ParseAndCheckFile : object {
    internal static void report@1476-2(ErrorHandler this, FSharpErrorSeverity sev, PhasedDiagnostic exn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LightSyntaxStatus getLightSyntaxStatus(string fileName, FSharpParsingOptions options);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<a, token> createLexerFunction(string fileName, FSharpParsingOptions options, LexBuffer`1<char> lexbuf, ErrorHandler errHandler);
    internal static bool parenTokensBalance@1547(token t1, token t2);
    internal static void matchBraces@1561-1(List`1<Tuple`2<range, range>> matchingBraces, LexBuffer`1<char> lexbuf, FSharpFunc`2<LexBuffer`1<char>, token> lexfun, FSharpList`1<Tuple`2<token, range>> stack);
    internal static Tuple`2[] matchBraces(ISourceText sourceText, string fileName, FSharpParsingOptions options, string userOpName, bool suggestNamesForErrors);
    internal static Tuple`3<FSharpErrorInfo[], FSharpOption`1<ParsedInput>, bool> parseFile(ISourceText sourceText, string fileName, FSharpParsingOptions options, string userOpName, bool suggestNamesForErrors);
    internal static string fileOfBackgroundError@1604(PhasedDiagnostic err0, a err1);
    internal static FSharpFunc`2<string, bool> sameFile@1605(string file);
    internal static Tuple`2<Exception, FSharpErrorSeverity> mapping@1-41(string tupledArg0, Tuple`2<PhasedDiagnostic, FSharpErrorSeverity> tupledArg1);
    [CompilerGeneratedAttribute]
internal static void ApplyLoadClosure$cont@1599(TcImports tcImports, FSharpOption`1<LoadClosure> loadClosure, Tuple`2[] backgroundDiagnostics, Unit unitVar);
    internal static void ApplyLoadClosure(TcConfig tcConfig, ParsedInput parsedMainInput, string mainInputFileName, FSharpOption`1<LoadClosure> loadClosure, TcImports tcImports, Tuple`2[] backgroundDiagnostics);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpOption`1<Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpList`1<TypedImplFile>, FSharpList`1<ModuleOrNamespaceType>>, TcState>>> catchHandler@1(TcState tcState, Exception _arg7);
    internal static FSharpAsync`1<Tuple`2<FSharpErrorInfo[], FSharpResult`2<TypeCheckInfo, Unit>>> CheckOneFile(FSharpParseFileResults parseResults, ISourceText sourceText, string mainInputFileName, string projectFileName, TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, TcState tcState, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, FSharpOption`1<LoadClosure> loadClosure, Tuple`2[] backgroundDiagnostics, IReactorOperations reactorOps, FSharpOption`1<object> textSnapshotInfo, string userOpName, bool suggestNamesForErrors);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.ParseCacheLockToken : object {
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.ParsedInput : object {
    internal static FSharpOption`1<FSharpList`1<SynExpr>> |Sequentials|_|(SynExpr _arg1);
    internal static FSharpList`1<SynPat> |ConstructorPats|(SynConstructorArgs _arg1);
    internal static void addLongIdent@513(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpList`1<Ident> longIdent);
    internal static void addLongIdentWithDots@517(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, LongIdentWithDots _arg1);
    internal static void addIdent@526-2(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, Ident ident);
    internal static void walkSynModuleOrNamespace@532-2(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynModuleOrNamespace _arg3);
    internal static void walkPat@557(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynPat _arg16);
    internal static void walkTypar@583-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynTypar _arg5);
    internal static void walkBinding@585-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynBinding _arg6);
    internal static void walkType@597-2(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynType _arg18);
    internal static void walkSimplePats@616(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynSimplePats _arg19);
    internal static void walkExpr@622-58(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynExpr _arg20);
    internal static void walkMeasure@718(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynMeasure _arg21);
    internal static void walkSimplePat@728-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynSimplePat _arg22);
    internal static void walkField@737-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynField _arg9);
    internal static void walkValSig@741-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynValSig _arg10);
    internal static void walkMemberSig@749-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynMemberSig _arg23);
    internal static void walkUnionCaseType@787-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynUnionCaseType _arg25);
    internal static void walkTypeDefnSimple@795-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynTypeDefnSimpleRepr _arg26);
    internal static void walkComponentInfo@802-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, bool isTypeExtensionOrAlias, SynComponentInfo _arg13);
    internal static void walkTypeDefnRepr@809-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynTypeDefnRepr _arg27);
    internal static void walkTypeDefnSigRepr@814-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynTypeDefnSigRepr _arg28);
    internal static void walkTypeDefn@819-1(Dictionary`2<pos, FSharpList`1<Ident>> identsByEndPos, FSharpFunc`2<Ident, Unit> addIdent, FSharpFunc`2<SynAttribute, Unit> walkAttribute, FSharpFunc`2<SynTyparDecl, Unit> walkTyparDecl, FSharpFunc`2<SynTypeConstraint, Unit> walkTypeConstraint, FSharpFunc`2<SynInterfaceImpl, Unit> walkInterfaceImpl, FSharpFunc`2<SynIndexerArg, Unit> walkIndexerArg, FSharpFunc`2<SynMatchClause, Unit> walkClause, FSharpFunc`2<SynMemberDefn, Unit> walkMember, FSharpFunc`2<SynEnumCase, Unit> walkEnumCase, FSharpFunc`2<SynUnionCase, Unit> walkUnionCase, FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl, SynTypeDefn _arg14);
    internal static IDictionary`2<pos, FSharpList`1<Ident>> getLongIdents(FSharpOption`1<ParsedInput> input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<FSharpList`1<Ident>> getLongIdentAt(ParsedInput ast, pos pos);
    internal static void addModule@871-1(List`1<Module> modules, FSharpList`1<Ident> tupledArg0, range tupledArg1);
    [CompilerGeneratedAttribute]
internal static void doRange$cont@885(FSharpRef`1<FSharpOption`1<Tuple`3<Scope, pos, bool>>> result, ScopeKind kind, FSharpList`1<Ident> scope, int line, int col, FSharpOption`1<Tuple`3<Scope, pos, bool>> matchValue_0, Unit unitVar);
    internal static void doRange@876(int currentLine, OpenStatementInsertionPoint insertionPoint, FSharpRef`1<FSharpOption`1<Tuple`3<Scope, pos, bool>>> result, ScopeKind kind, FSharpList`1<Ident> scope, int line, int col);
    internal static FSharpOption`1<int> getMinColumn@898(FSharpList`1<SynModuleDecl> decls);
    internal static void walkImplFileInput@914(int currentLine, OpenStatementInsertionPoint insertionPoint, FSharpRef`1<FSharpOption`1<Tuple`3<Scope, pos, bool>>> result, FSharpRef`1<FSharpOption`1<String[]>> ns, List`1<Module> modules, ParsedImplFileInput _arg1);
    [CompilerGeneratedAttribute]
internal static void walkSynModuleOrNamespace$cont@919(int currentLine, OpenStatementInsertionPoint insertionPoint, FSharpRef`1<FSharpOption`1<Tuple`3<Scope, pos, bool>>> result, FSharpRef`1<FSharpOption`1<String[]>> ns, List`1<Module> modules, FSharpList`1<Ident> parent, range range, SynModuleOrNamespaceKind kind, FSharpList`1<Ident> ident, FSharpList`1<SynModuleDecl> decls, Unit unitVar);
    internal static void walkSynModuleOrNamespace@917-4(int currentLine, OpenStatementInsertionPoint insertionPoint, FSharpRef`1<FSharpOption`1<Tuple`3<Scope, pos, bool>>> result, FSharpRef`1<FSharpOption`1<String[]>> ns, List`1<Module> modules, FSharpList`1<Ident> parent, SynModuleOrNamespace _arg2);
    internal static FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl@944-3(int currentLine, OpenStatementInsertionPoint insertionPoint, FSharpRef`1<FSharpOption`1<Tuple`3<Scope, pos, bool>>> result, FSharpRef`1<FSharpOption`1<String[]>> ns, List`1<Module> modules, FSharpList`1<Ident> parent);
    [CompilerGeneratedAttribute]
internal static String[] clo0@965-1495(IEnumerable`1<string> ident);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<Tuple`3<Scope, FSharpOption`1<String[]>, pos>>, FSharpList`1<Module>> tryFindNearestPointAndModules(int currentLine, ParsedInput ast, OpenStatementInsertionPoint insertionPoint);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InsertContext findBestPositionToInsertOpenDeclaration(FSharpList`1<Module> modules, Scope scope, pos pos, String[] entity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<Tuple`4<FSharpOption`1<String[]>, FSharpOption`1<String[]>, FSharpOption`1<String[]>, String[]>, Tuple`2[]> tryFindInsertionContext(int currentLine, ParsedInput ast, MaybeUnresolvedIdent[] partiallyQualifiedName, OpenStatementInsertionPoint insertionPoint);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static pos adjustInsertionPoint(FSharpFunc`2<int, string> getLineStr, InsertContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InsertContext findNearestPointToInsertOpenDeclaration(int currentLine, ParsedInput ast, String[] entity, OpenStatementInsertionPoint insertionPoint);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.PrettyNaming : object {
    [CompilationMappingAttribute("9")]
public static FSharpList`1<string> KeywordNames { get; }
    public static bool IsIdentifierPartCharacter(char x);
    public static bool IsLongIdentifierPartCharacter(char x);
    public static bool IsOperatorName(string x);
    public static FSharpList`1<string> GetLongNameFromString(string x);
    public static string FormatAndOtherOverloadsString(int remainingOverloads);
    public static string QuoteIdentifierIfNeeded(string id);
    public static FSharpList`1<string> get_KeywordNames();
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.Reactor : object {
    internal static int pauseBeforeBackgroundWorkDefault;
    internal static Reactor theReactor;
    internal int pauseBeforeBackgroundWork;
    internal CultureInfo culture;
    internal CancellationTokenSource bgOpCts;
    internal FSharpMailboxProcessor`1<ReactorCommands> builder;
    internal static int init@31-14;
    internal int CurrentQueueLength { get; }
    internal int PauseBeforeBackgroundWork { get; internal set; }
    internal static Reactor Singleton { get; }
    private static Reactor();
    internal void SetPreferredUILang(FSharpOption`1<string> preferredUiLang);
    internal void SetBackgroundOp(FSharpOption`1<Tuple`4<string, string, string, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<CancellationToken, bool>>>> bgOpOpt);
    internal void CancelBackgroundOp();
    internal void EnqueueOp(string userOpName, string opName, string opArg, FSharpFunc`2<CompilationThreadToken, Unit> op);
    internal void EnqueueOpPrim(string userOpName, string opName, string opArg, CancellationToken ct, FSharpFunc`2<CompilationThreadToken, Unit> op, FSharpFunc`2<Unit, Unit> ccont);
    internal int get_CurrentQueueLength();
    internal void WaitForBackgroundOpCompletion();
    internal void CompleteAllQueuedOps();
    internal FSharpAsync`1<T> EnqueueAndAwaitOpAsync(string userOpName, string opName, string opArg, FSharpFunc`2<CompilationThreadToken, Cancellable`1<T>> f);
    internal int get_PauseBeforeBackgroundWork();
    internal void set_PauseBeforeBackgroundWork(int v);
    internal static Reactor get_Singleton();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.SourceCodeServices.ReactorCommands : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSetBackgroundOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWaitForBackgroundOpCompletion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCompleteAllQueuedOps { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ReactorCommands(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static ReactorCommands NewSetBackgroundOp(FSharpOption`1<Tuple`4<string, string, string, FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<CancellationToken, bool>>>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSetBackgroundOp();
    [CompilationMappingAttribute("8", "1")]
internal static ReactorCommands NewOp(string _userOpName, string _opName, string _opArg, CancellationToken item4, FSharpFunc`2<CompilationThreadToken, Unit> item5, FSharpFunc`2<Unit, Unit> item6);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsOp();
    [CompilationMappingAttribute("8", "2")]
internal static ReactorCommands NewWaitForBackgroundOpCompletion(FSharpAsyncReplyChannel`1<Unit> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWaitForBackgroundOpCompletion();
    [CompilationMappingAttribute("8", "3")]
internal static ReactorCommands NewCompleteAllQueuedOps(FSharpAsyncReplyChannel`1<Unit> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCompleteAllQueuedOps();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SourceCodeServices.RecordContext : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCopyOnUpdate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNew { get; }
    [CompilationMappingAttribute("8", "0")]
public static RecordContext NewCopyOnUpdate(range item1, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCopyOnUpdate();
    [CompilationMappingAttribute("8", "1")]
public static RecordContext NewConstructor(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstructor();
    [CompilationMappingAttribute("8", "2")]
public static RecordContext NewNew(Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNew();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RecordContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.SourceCodeServices.ResolveOverloads : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ResolveOverloads _unique_Yes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ResolveOverloads _unique_No;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ResolveOverloads Yes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ResolveOverloads No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNo { get; }
    private static ResolveOverloads();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ResolveOverloads(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static ResolveOverloads get_Yes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
internal static ResolveOverloads get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ResolveOverloads obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ResolveOverloads obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.ScopeKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_TopModule;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_NestedModule;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_OpenDeclaration;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_HashDirective;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind TopModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTopModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind NestedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNestedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind OpenDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpenDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind HashDirective { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashDirective { get; }
    private static ScopeKind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ScopeKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static ScopeKind get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "1")]
public static ScopeKind get_TopModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTopModule();
    [CompilationMappingAttribute("8", "2")]
public static ScopeKind get_NestedModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNestedModule();
    [CompilationMappingAttribute("8", "3")]
public static ScopeKind get_OpenDeclaration();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpenDeclaration();
    [CompilationMappingAttribute("8", "4")]
public static ScopeKind get_HashDirective();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashDirective();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ScopeKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ScopeKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.ScriptClosureCacheToken : object {
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.SemanticClassificationType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_ReferenceType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_ValueType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_UnionCase;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_Function;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_MutableVar;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_Printf;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_ComputationExpression;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_IntrinsicFunction;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_Enumeration;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_TypeArgument;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_Operator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemanticClassificationType _unique_Disposable;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType ReferenceType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsReferenceType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType ValueType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsValueType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType UnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType Function { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFunction { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType MutableVar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMutableVar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType Printf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPrintf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType ComputationExpression { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsComputationExpression { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType IntrinsicFunction { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIntrinsicFunction { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType Enumeration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnumeration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType TypeArgument { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeArgument { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType Operator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemanticClassificationType Disposable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDisposable { get; }
    private static SemanticClassificationType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SemanticClassificationType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SemanticClassificationType get_ReferenceType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsReferenceType();
    [CompilationMappingAttribute("8", "1")]
public static SemanticClassificationType get_ValueType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsValueType();
    [CompilationMappingAttribute("8", "2")]
public static SemanticClassificationType get_UnionCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnionCase();
    [CompilationMappingAttribute("8", "3")]
public static SemanticClassificationType get_Function();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFunction();
    [CompilationMappingAttribute("8", "4")]
public static SemanticClassificationType get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilationMappingAttribute("8", "5")]
public static SemanticClassificationType get_MutableVar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMutableVar();
    [CompilationMappingAttribute("8", "6")]
public static SemanticClassificationType get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "7")]
public static SemanticClassificationType get_Printf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPrintf();
    [CompilationMappingAttribute("8", "8")]
public static SemanticClassificationType get_ComputationExpression();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsComputationExpression();
    [CompilationMappingAttribute("8", "9")]
public static SemanticClassificationType get_IntrinsicFunction();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIntrinsicFunction();
    [CompilationMappingAttribute("8", "10")]
public static SemanticClassificationType get_Enumeration();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnumeration();
    [CompilationMappingAttribute("8", "11")]
public static SemanticClassificationType get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "12")]
public static SemanticClassificationType get_TypeArgument();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeArgument();
    [CompilationMappingAttribute("8", "13")]
public static SemanticClassificationType get_Operator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOperator();
    [CompilationMappingAttribute("8", "14")]
public static SemanticClassificationType get_Disposable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDisposable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SemanticClassificationType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SemanticClassificationType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal enum FSharp.Compiler.SourceCodeServices.SingleLineTokenState : Enum {
    public int value__;
    public static SingleLineTokenState BeforeHash;
    public static SingleLineTokenState NoFurtherMatchPossible;
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.SourceFile : object {
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> compilableExtensions { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> singleFileProjectExtensions { get; }
    internal static FSharpList`1<string> get_compilableExtensions();
    internal static FSharpList`1<string> get_singleFileProjectExtensions();
    public static bool IsCompilable(string file);
    public static bool MustBeSingleFileProject(string file);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.SourceFileImpl : object {
    internal static bool IsInterfaceFile(string file);
    internal static FSharpList`1<string> AdditionalDefinesForUseInEditor(bool isInteractive);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.Structure : object {
    internal static range longIdentRange(FSharpList`1<Ident> longId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range rangeOfTypeArgsElse(range other, FSharpList`1<SynTyparDecl> typeArgs);
    [CompilerGeneratedAttribute]
internal static void parseExpr$cont@303(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, SynExpr expression, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void parseExpr$cont@315-1(List`1<ScopeRange> acc, range wholeRange, range withRange, range tryRange, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void parseExpr$cont@343-2(List`1<ScopeRange> acc, SynExpr thenExpr, SequencePointInfoForBinding spIfToThen, range r, range ifToThenRange, SynExpr ifExpr, Unit unitVar);
    internal static void parseExpr@219(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, SynExpr expression);
    internal static void attrListRange@409(List`1<ScopeRange> acc, FSharpList`1<SynAttribute> activePatternResult87666, Unit unitVar0);
    internal static void parseAttributes@408(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, FSharpList`1<SynAttributeList> _arg2);
    [CompilerGeneratedAttribute]
internal static void parseBinding$cont@432(List`1<ScopeRange> acc, SynBinding _arg3, FSharpOption`1<MemberFlags> memberFlags, SynExpr expr, range br, Unit unitVar);
    internal static void parseBinding@429(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, SynBinding _arg3);
    internal static void parseBindings@448(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, FSharpList`1<SynBinding> sqs);
    internal static void parseExprInterfaces@455(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, FSharpList`1<SynInterfaceImpl> intfs);
    internal static FSharpFunc`2<SynMemberDefn, Unit> parseSynMemberDefn@457(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, range objectModelRange);
    internal static void parseSimpleRepr@509(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, SynTypeDefnSimpleRepr simple);
    internal static void parseTypeDefn@527(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, SynTypeDefn _arg5);
    internal static SynPat getLastPat@399(SynPat _arg9);
    internal static FSharpList`1<FSharpList`1<range>> loop@548-138(String[] sourceLines, FSharpList`1<range> input, FSharpList`1<FSharpList`1<range>> res, FSharpList`1<range> currentBulk);
    internal static FSharpList`1<FSharpList`1<range>> groupConsecutiveDecls@547(String[] sourceLines, FSharpList`1<range> input);
    internal static FSharpFunc`2<FSharpList`1<SynModuleDecl>, Unit> getConsecutiveModuleDecls@546(String[] sourceLines, List`1<ScopeRange> acc, FSharpFunc`2<SynModuleDecl, FSharpOption`1<range>> predicate, Scope scope);
    internal static FSharpOption`1<CommentType> |Comment|_|@628(string line);
    internal static Tuple`3<int, FSharpOption`1<CommentList>, FSharpList`1<CommentList>> loop@634-140(Tuple`3<int, FSharpOption`1<CommentList>, FSharpList`1<CommentList>> _arg13, FSharpList`1<string> lines, int lineNum);
    internal static void getCommentRanges@633(List`1<ScopeRange> acc, String[] lines);
    internal static range lastMemberSigRangeElse@696(range r, FSharpList`1<SynMemberSig> memberSigs);
    internal static range lastTypeDefnSigRangeElse@707(range range, FSharpList`1<SynTypeDefnSig> typeSigs);
    internal static range lastModuleSigDeclRangeElse@714(range range, FSharpList`1<SynModuleSigDecl> sigDecls);
    internal static Tuple`2<range, range> makeRanges@743(FSharpList`1<SynTyparDecl> typeArgs, range r, FSharpList`1<Ident> longId, FSharpList`1<SynMemberSig> memberSigs);
    internal static void parseTypeDefnSig@740(List`1<ScopeRange> acc, FSharpFunc`2<SynMatchClause, Unit> parseMatchClause, FSharpFunc`2<SynInterfaceImpl, Unit> parseExprInterface, FSharpFunc`2<SynMemberSig, Unit> parseSynMemberDefnSig, SynTypeDefnSig _arg14);
    internal static FSharpList`1<FSharpList`1<range>> loop@776-141(FSharpList`1<range> input, FSharpList`1<FSharpList`1<range>> res, FSharpList`1<range> currentBulk);
    internal static FSharpList`1<FSharpList`1<range>> groupConsecutiveSigDecls@775(FSharpList`1<range> input);
    internal static FSharpFunc`2<FSharpList`1<SynModuleSigDecl>, Unit> getConsecutiveSigModuleDecls@774(List`1<ScopeRange> acc, FSharpFunc`2<SynModuleSigDecl, FSharpOption`1<range>> predicate, Scope scope);
    internal static void collectSigHashDirectives@804(List`1<ScopeRange> acc, FSharpList`1<SynModuleSigDecl> decls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<ScopeRange> getOutliningRanges(String[] sourceLines, ParsedInput parsedInput);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.Symbol : object {
    [CompilationMappingAttribute("9")]
internal static Regex UnnamedUnionFieldRegex { get; }
    public static bool isAttribute(FSharpAttribute attribute);
    public static FSharpOption`1<FSharpAttribute> tryGetAttribute(IEnumerable`1<FSharpAttribute> attributes);
    public static bool hasModuleSuffixAttribute(FSharpEntity entity);
    public static bool isOperator(string name);
    internal static Regex get_UnnamedUnionFieldRegex();
    public static bool isUnnamedUnionCaseField(FSharpField field);
    public static FSharpOption`1<FSharpType> |AbbreviatedType|_|(FSharpEntity entity);
    public static FSharpOption`1<FSharpEntity> |TypeWithDefinition|_|(FSharpType ty);
    public static Tuple`2<FSharpEntity, FSharpOption`1<FSharpType>> getEntityAbbreviatedType(FSharpEntity entity);
    public static FSharpType getAbbreviatedType(FSharpType fsharpType);
    internal static FSharpOption`1<FSharpEntity> getBaseType@70(FSharpEntity entity);
    internal static bool isAttributeType@77(FSharpOption`1<FSharpEntity> ty);
    internal static bool isAttribute@69(FSharpEntity entity);
    public static FSharpOption`1<Unit> |Attribute|_|(FSharpEntity entity);
    public static bool hasAttribute(IEnumerable`1<FSharpAttribute> attributes);
    public static FSharpOption`1<Unit> |ValueType|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |Class|_|(FSharpEntity original, FSharpEntity abbreviated, a _arg1);
    public static FSharpOption`1<Unit> |Record|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |UnionType|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |Delegate|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |FSharpException|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |Interface|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |AbstractClass|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |FSharpType|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |ProvidedType|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |ByRef|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |Array|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |FSharpModule|_|(FSharpEntity entity);
    public static FSharpOption`1<Unit> |Namespace|_|(FSharpEntity entity);
    public static FSharpOption`1<Unit> |ProvidedAndErasedType|_|(FSharpEntity entity);
    public static FSharpOption`1<Unit> |Enum|_|(FSharpEntity entity);
    public static FSharpOption`1<Unit> |Tuple|_|(FSharpType ty);
    public static FSharpOption`1<Unit> |RefCell|_|(FSharpType ty);
    public static FSharpOption`1<Unit> |FunctionType|_|(FSharpType ty);
    public static FSharpOption`1<Unit> |Pattern|_|(FSharpSymbol symbol);
    public static FSharpOption`1<Tuple`2<FSharpField, FSharpType>> |Field|_|(FSharpSymbol symbol);
    public static FSharpOption`1<Unit> |MutableVar|_|(FSharpSymbol symbol);
    public static FSharpOption`1<Tuple`3<FSharpEntity, FSharpEntity, FSharpOption`1<FSharpType>>> |FSharpEntity|_|(FSharpSymbol symbol);
    public static FSharpOption`1<Unit> |Parameter|_|(FSharpSymbol symbol);
    public static FSharpOption`1<FSharpUnionCase> |UnionCase|_|(FSharpSymbol e);
    public static FSharpOption`1<FSharpField> |RecordField|_|(FSharpSymbol e);
    public static FSharpOption`1<FSharpActivePatternCase> |ActivePatternCase|_|(FSharpSymbol symbol);
    public static FSharpOption`1<FSharpMemberOrFunctionOrValue> |MemberFunctionOrValue|_|(FSharpSymbol symbol);
    public static FSharpOption`1<FSharpEntity> |Constructor|_|(FSharpMemberOrFunctionOrValue func);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Unit> |Function|_|(bool excluded, FSharpMemberOrFunctionOrValue func);
    public static FSharpOption`1<Unit> |ExtensionMember|_|(FSharpMemberOrFunctionOrValue func);
    public static FSharpOption`1<Unit> |Event|_|(FSharpMemberOrFunctionOrValue func);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.SymbolEnv : object {
    internal FSharpOption`1<ModuleOrNamespaceType> thisCcuTy@52;
    internal CcuThunk thisCcu@52;
    internal TcImports tcImports@52;
    internal InfoReader infoReaderV;
    internal TcGlobals g@52;
    internal ImportMap amapV;
    internal TcGlobals g { get; }
    internal ImportMap amap { get; }
    internal CcuThunk thisCcu { get; }
    internal FSharpOption`1<ModuleOrNamespaceType> thisCcuTy { get; }
    internal InfoReader infoReader { get; }
    internal TcImports tcImports { get; }
    public SymbolEnv(TcGlobals g, CcuThunk thisCcu, FSharpOption`1<ModuleOrNamespaceType> thisCcuTyp, TcImports tcImports, ImportMap amap, InfoReader infoReader);
    public SymbolEnv(TcGlobals g, CcuThunk thisCcu, FSharpOption`1<ModuleOrNamespaceType> thisCcuTyp, TcImports tcImports);
    internal TcGlobals get_g();
    internal ImportMap get_amap();
    internal CcuThunk get_thisCcu();
    internal FSharpOption`1<ModuleOrNamespaceType> get_thisCcuTy();
    internal InfoReader get_infoReader();
    internal TcImports get_tcImports();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.SymbolHelpers : object {
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> ToolTipFault { get; internal set; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFunction(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout OutputFullName(bool isListItem, FSharpFunc`2<a, FSharpOption`1<b>> ppF, FSharpFunc`2<a, Layout> fnF, a r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range rangeOfValRef(FSharpOption`1<bool> preferFlag, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range rangeOfEntityRef(FSharpOption`1<bool> preferFlag, EntityRef eref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<range> rangeOfPropInfo(FSharpOption`1<bool> preferFlag, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<range> rangeOfMethInfo(TcGlobals g, FSharpOption`1<bool> preferFlag, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<range> rangeOfEventInfo(FSharpOption`1<bool> preferFlag, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range rangeOfUnionCaseInfo(FSharpOption`1<bool> preferFlag, UnionCaseInfo ucinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range rangeOfRecdFieldInfo(FSharpOption`1<bool> preferFlag, RecdFieldInfo rfinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<range> rangeOfItem(TcGlobals g, FSharpOption`1<bool> preferFlag, Item d);
    internal static FSharpOption`1<CcuThunk> computeCcuOfTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<CcuThunk> ccuOfMethInfo(TcGlobals g, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<CcuThunk> ccuOfItem(TcGlobals g, Item d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string fileNameOfItem(TcGlobals g, FSharpOption`1<string> qualProjectDir, range m, Item h);
    internal static FSharpOption`1<string> libFileOfEntityRef(EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ParamNameAndType> ParamNameAndTypesOfUnaryCustomOperation(TcGlobals g, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<FSharpOption`1<string>, FSharpList`1<Typar>, ILTypeInfo>> metaInfoOfEntityRef(InfoReader infoReader, range m, EntityRef tcref);
    internal static FSharpXmlDoc mkXmlComment(FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> thing);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfEntityRef(InfoReader infoReader, range m, EntityRef eref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfScopedValRef(TcGlobals g, EntityRef tcref, ValRef vref);
    internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfRecdFieldInfo(RecdFieldInfo rfinfo);
    internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfUnionCaseInfo(UnionCaseInfo ucinfo);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfMethInfo$cont@536(InfoReader infoReader, range m, MethInfo minfo, ImportMap amap, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfMethInfo(InfoReader infoReader, range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfProp(InfoReader infoReader, range m, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfEvent(InfoReader infoReader, range m, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfILFieldInfo(InfoReader infoReader, range m, ILFieldInfo finfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpXmlDoc GetXmlDocHelpSigOfItemForLookup(InfoReader infoReader, range m, Item d);
    [CompilerGeneratedAttribute]
internal static void f@311-26(String[] l, StringBuilder os);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpXmlDoc GetXmlCommentForItemAux(FSharpOption`1<XmlDoc> xmlDoc, InfoReader infoReader, range m, Item d);
    internal static FSharpOption`1<string> get_ToolTipFault();
    internal static void set_ToolTipFault(FSharpOption`1<string> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpXmlDoc GetXmlCommentForMethInfoItem(InfoReader infoReader, range m, Item d, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Layout> FormatTyparMapping(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> prettyTyparInst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpToolTipElement`1<Layout> FormatOverloadsToList(InfoReader infoReader, range m, DisplayEnv denv, ItemWithInst item, IEnumerable`1<MethInfo> minfos);
    internal static FSharpOption`1<TType> |ItemWhereTypIsPreferred|_|(Item item);
    internal static bool equalHeadTypes@722(TcGlobals g, TType tupledArg0, TType tupledArg1);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@733-18(TcGlobals g, Item item2, Item item1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@733-17(TcGlobals g, Item item2, Item item1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool f@105-27(TcGlobals g, Item item2, Item item1, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@782-10(Item item, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int f@105-28(TcGlobals g, Item item, Unit unitVar0);
    internal static IPartialEqualityComparer`1<Item> ItemDisplayPartialEquality(TcGlobals g);
    internal static IPartialEqualityComparer`1<CompletionItem> CompletionItemDisplayPartialEquality(TcGlobals g);
    internal static FSharpList`1<EntityRef> RemoveDuplicateModuleRefs(FSharpList`1<EntityRef> modrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ItemWithInst> RemoveDuplicateItems(TcGlobals g, FSharpList`1<ItemWithInst> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<CompletionItem> RemoveDuplicateCompletionItems(TcGlobals g, FSharpList`1<CompletionItem> items);
    [CompilerGeneratedAttribute]
internal static bool f@105-29(TcGlobals g, Item item, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsExplicitlySuppressed(TcGlobals g, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ItemWithInst> RemoveExplicitlySuppressed(TcGlobals g, FSharpList`1<ItemWithInst> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<CompletionItem> RemoveExplicitlySuppressedCompletionItems(TcGlobals g, FSharpList`1<CompletionItem> items);
    internal static DisplayEnv SimplerDisplayEnv(DisplayEnv denv);
    [CompilerGeneratedAttribute]
internal static void f@311-30(DisplayEnv denv, ILFieldInfo finfo, StringBuilder os);
    [CompilerGeneratedAttribute]
internal static void f@311-31(DisplayEnv denv, EventInfo einfo, StringBuilder os);
    [CompilerGeneratedAttribute]
internal static void f@311-32(DisplayEnv denv, PropInfo pinfo, StringBuilder os);
    [CompilerGeneratedAttribute]
internal static void f@311-33(DisplayEnv denv, MethInfo minfo, StringBuilder os);
    [CompilerGeneratedAttribute]
internal static void f@311-34(DisplayEnv denv, MethInfo minfo, StringBuilder os);
    [CompilerGeneratedAttribute]
internal static void f@311-35(DisplayEnv denv, MethInfo minfo, StringBuilder os);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string FullNameOfItem(TcGlobals g, Item item);
    [CompilerGeneratedAttribute]
internal static FSharpXmlDoc GetXmlCommentForItem$cont@968(InfoReader infoReader, range m, Item item, TcGlobals g, FSharpOption`1<ArgumentContainer> argContainer, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpXmlDoc GetXmlCommentForItem(InfoReader infoReader, range m, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsAttribute(InfoReader infoReader, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpToolTipElement`1<Layout> FormatItemDescriptionToToolTipElement(bool isListItem, InfoReader infoReader, range m, DisplayEnv denv, ItemWithInst item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<EntityRef> |ItemIsProvidedType|_|(TcGlobals g, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tainted`1[]> |ItemIsProvidedTypeWithStaticArguments|_|(range m, TcGlobals g, Item item);
    internal static FSharpOption`1<Tainted`1[]> |ItemIsProvidedMethodWithStaticArguments|_|(Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tainted`1[]> |ItemIsWithStaticArguments|_|(range m, TcGlobals g, Item item);
    internal static FSharpOption`1<string> getKeywordForMethInfo@1307(TcGlobals g, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> GetF1Keyword(TcGlobals g, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpToolTipElement`1<Layout> FormatStructuredDescriptionOfItem(bool isDecl, InfoReader infoReader, range m, DisplayEnv denv, ItemWithInst item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> FlattenItems(TcGlobals g, range m, Item item);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.TestExpose : object {
    internal static Tuple`3<FSharpTokenColorKind, FSharpTokenCharKind, FSharpTokenTriggerClass> TokenInfo(token tok);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.TokenClassifications : object {
    internal static Tuple`3<FSharpTokenColorKind, FSharpTokenCharKind, FSharpTokenTriggerClass> tokenInfo(token token);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.Tooltips : object {
    public static FSharpToolTipElement`1<string> ToFSharpToolTipElement(FSharpToolTipElement`1<Layout> tooltip);
    public static FSharpToolTipText`1<string> ToFSharpToolTipText(FSharpToolTipText`1<Layout> _arg1);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<T2> func2@1-5(T2 arg00);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<T2> Map(FSharpFunc`2<T1, T2> f, FSharpAsync`1<T1> a);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.SourceCodeServices.TypeCheckInfo : object {
    internal CcuThunk thisCcu;
    internal TcImports tcImports;
    internal AccessorDomain tcAccessRights;
    internal TcSymbolUses sSymbolUses;
    internal TcResolutions sResolutions;
    internal NameResolutionEnv sFallback;
    internal IReactorOperations reactorOps;
    internal string projectFileName;
    internal OpenDeclaration[] openDeclarations;
    internal string mainInputFileName;
    internal FSharpOption`1<LoadClosure> loadClosure;
    internal FSharpOption`1<TypedImplFile> implFileOpt;
    internal TcGlobals g;
    internal ModuleOrNamespaceType ccuSigForFile;
    internal object textSnapshotInfo@156;
    internal AgedLookup`3<CompilationThreadToken, Tuple`3<int, int, string>, FSharpToolTipText`1<Layout>> getToolTipTextCache;
    internal ImportMap amap;
    internal InfoReader infoReader;
    internal NameResolver ncenv;
    internal SymbolEnv cenv;
    internal FSharpAssemblySignature PartialAssemblySignatureForFile { get; }
    internal AccessorDomain AccessRights { get; }
    internal TcResolutions ScopeResolutions { get; }
    internal TcSymbolUses ScopeSymbolUses { get; }
    internal TcGlobals TcGlobals { get; }
    internal TcImports TcImports { get; }
    internal ModuleOrNamespaceType CcuSigForFile { get; }
    internal CcuThunk ThisCcu { get; }
    internal FSharpOption`1<TypedImplFile> ImplementationFile { get; }
    internal OpenDeclaration[] OpenDeclarations { get; }
    internal SymbolEnv SymbolEnv { get; }
    public TypeCheckInfo(TcConfig _sTcConfig, TcGlobals g, ModuleOrNamespaceType ccuSigForFile, CcuThunk thisCcu, TcImports tcImports, AccessorDomain tcAccessRights, string projectFileName, string mainInputFileName, TcResolutions sResolutions, TcSymbolUses sSymbolUses, NameResolutionEnv sFallback, FSharpOption`1<LoadClosure> loadClosure, IReactorOperations reactorOps, FSharpOption`1<object> textSnapshotInfo, FSharpOption`1<TypedImplFile> implFileOpt, OpenDeclaration[] openDeclarations);
    internal Tuple`2<Tuple`2<NameResolutionEnv, AccessorDomain>, range> GetBestDisplayEnvForPos(pos cursorPos);
    internal FSharpList`1<EntityRef> GetVisibleNamespacesAndModulesAtPosition(pos cursorPos);
    internal bool IsRelativeNameResolvable(pos cursorPos, FSharpList`1<string> plid, Item item);
    internal bool IsRelativeNameResolvableFromSymbol(pos cursorPos, FSharpList`1<string> plid, FSharpSymbol symbol);
    internal FSharpDeclarationListInfo GetDeclarations(CompilationThreadToken ctok, FSharpOption`1<FSharpParseFileResults> parseResultsOpt, int line, string lineStr, PartialLongName partialName, FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>> getAllEntities, FSharpFunc`2<Tuple`2<object, range>, bool> hasTextChangedSinceLastTypecheck);
    internal FSharpList`1<FSharpList`1<FSharpSymbolUse>> GetDeclarationListSymbols(CompilationThreadToken ctok, FSharpOption`1<FSharpParseFileResults> parseResultsOpt, int line, string lineStr, PartialLongName partialName, FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>> getAllEntities, FSharpFunc`2<Tuple`2<object, range>, bool> hasTextChangedSinceLastTypecheck);
    internal FSharpToolTipText`1<Layout> GetReferenceResolutionStructuredToolTipText(CompilationThreadToken ctok, int line, int col);
    internal FSharpToolTipText`1<Layout> GetStructuredToolTipText(CompilationThreadToken ctok, int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names);
    internal FSharpOption`1<string> GetF1Keyword(CompilationThreadToken ctok, int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names);
    internal FSharpMethodGroup GetMethods(CompilationThreadToken ctok, int line, string lineStr, int colAtEndOfNames, FSharpOption`1<FSharpList`1<string>> namesOpt);
    internal FSharpOption`1<Tuple`3<FSharpList`1<FSharpSymbol>, DisplayEnv, range>> GetMethodsAsSymbols(CompilationThreadToken ctok, int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names);
    internal FSharpFindDeclResult GetDeclarationLocation(CompilationThreadToken ctok, int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names, FSharpOption`1<bool> preferFlag);
    internal FSharpOption`1<Tuple`3<FSharpSymbol, DisplayEnv, range>> GetSymbolUseAtLocation(CompilationThreadToken ctok, int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names);
    internal FSharpAssemblySignature get_PartialAssemblySignatureForFile();
    internal AccessorDomain get_AccessRights();
    internal FSharpList`1<FSharpAssembly> GetReferencedAssemblies();
    internal Tuple`2[] GetFormatSpecifierLocationsAndArity();
    internal Tuple`2[] GetSemanticClassification(FSharpOption`1<range> range);
    internal TcResolutions get_ScopeResolutions();
    internal TcSymbolUses get_ScopeSymbolUses();
    internal TcGlobals get_TcGlobals();
    internal TcImports get_TcImports();
    internal ModuleOrNamespaceType get_CcuSigForFile();
    internal CcuThunk get_ThisCcu();
    internal FSharpOption`1<TypedImplFile> get_ImplementationFile();
    internal OpenDeclaration[] get_OpenDeclarations();
    internal SymbolEnv get_SymbolEnv();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal Tuple`7<pos, Item, ItemOccurence, DisplayEnv, NameResolutionEnv, AccessorDomain, range> |CNR|(CapturedNameResolution cnr);
    [CompilerGeneratedAttribute]
internal Tuple`2<Tuple`2<NameResolutionEnv, AccessorDomain>, range> GetBestEnvForPos(pos cursorPos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<ItemWithInst> FilterItemsForCtors(TypeNameResolutionFlag filterCtors, FSharpList`1<ItemWithInst> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal NameResResult ReturnItemsOfType(FSharpList`1<ItemWithInst> items, TcGlobals g, DisplayEnv denv, range m, TypeNameResolutionFlag filterCtors, FSharpFunc`2<Tuple`2<object, range>, bool> hasTextChangedSinceLastTypecheck);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal List`1<CapturedNameResolution> GetCapturedNameResolutions(pos endOfNamesPos, ResolveOverloads resolveOverloads);
    [CompilerGeneratedAttribute]
internal NameResResult GetPreciseItemsFromNameResolution(int line, int colAtEndOfNames, FSharpOption`1<a> membersByResidue, TypeNameResolutionFlag filterCtors, ResolveOverloads resolveOverloads, FSharpFunc`2<Tuple`2<object, range>, bool> hasTextChangedSinceLastTypecheck);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<TType> TryGetTypeFromNameResolution(int line, int colAtEndOfNames, FSharpOption`1<a> membersByResidue, ResolveOverloads resolveOverloads);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<Item> CollectParameters(FSharpList`1<MethInfo> methods, ImportMap amap, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal NameResResult GetNamedParametersAndSettableFields(pos endOfExprPos, FSharpFunc`2<Tuple`2<object, range>, bool> hasTextChangedSinceLastTypecheck);
    [CompilerGeneratedAttribute]
internal Tuple`2<bool, Tuple`6[]> GetExprTypingForPosition(pos endOfExprPos);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<Item>, DisplayEnv, range>> GetRecdFieldsForExpr(range r);
    [CompilerGeneratedAttribute]
internal GetPreciseCompletionListFromExprTypingsResult GetPreciseCompletionListFromExprTypings(FSharpParseFileResults parseResults, pos endOfExprPos, TypeNameResolutionFlag filterCtors, FSharpFunc`2<Tuple`2<object, range>, bool> hasTextChangedSinceLastTypecheck);
    [CompilerGeneratedAttribute]
internal Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, range> GetEnvironmentLookupResolutions(NameResolutionEnv nenv, AccessorDomain ad, range m, FSharpList`1<string> plid, TypeNameResolutionFlag filterCtors, bool showObsolete);
    [CompilerGeneratedAttribute]
internal Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, range> GetEnvironmentLookupResolutionsAtPosition(pos cursorPos, FSharpList`1<string> plid, TypeNameResolutionFlag filterCtors, bool showObsolete);
    [CompilerGeneratedAttribute]
internal Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, range> GetClassOrRecordFieldsEnvironmentLookupResolutions(pos cursorPos, FSharpList`1<string> plid);
    [CompilerGeneratedAttribute]
internal bool GetBaseClassCandidates(Item _arg1);
    [CompilerGeneratedAttribute]
internal bool GetInterfaceCandidates(Item _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<a> FilterDeclItemsByResidue(FSharpFunc`2<a, Item> getItem, string residue, FSharpList`1<a> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<a>, a, b>> FilterRelevantItemsBy(FSharpFunc`2<a, Item> getItem, FSharpOption`1<string> exactMatchResidueOpt, FSharpFunc`2<a, bool> check, FSharpList`1<a> items, a denv, b m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<a>, b, c>> |FilterRelevantItems|_|(FSharpFunc`2<a, Item> getItem, FSharpOption`1<string> exactMatchResidueOpt, FSharpList`1<a> orig_0, b orig_1, c orig_2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<int> FindFirstNonWhitespacePosition(string lineStr, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal CompletionItem CompletionItem(FSharpValueOption`1<EntityRef> ty, FSharpValueOption`1<AssemblySymbol> assemblySymbol, ItemWithInst item);
    [CompilerGeneratedAttribute]
internal CompletionItem DefaultCompletionItem(ItemWithInst item);
    [CompilerGeneratedAttribute]
internal Item getItem(ItemWithInst x);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<CompletionItem>, DisplayEnv, range>> GetDeclaredItems(FSharpOption`1<FSharpParseFileResults> parseResultsOpt, string lineStr, FSharpOption`1<FSharpList`1<string>> origLongIdentOpt, int colAtEndOfNamesAndResidue, FSharpOption`1<a> residueOpt, FSharpOption`1<int> lastDotPos, int line, int loc, TypeNameResolutionFlag filterCtors, ResolveOverloads resolveOverloads, FSharpFunc`2<Tuple`2<object, range>, bool> hasTextChangedSinceLastTypecheck, bool isInRangeOperator, FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>> allSymbols);
    [CompilerGeneratedAttribute]
internal Tuple`3<FSharpList`1<CompletionItem>, DisplayEnv, range> toCompletionItems(FSharpList`1<ItemWithInst> items, DisplayEnv denv, range m);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`4<FSharpList`1<CompletionItem>, DisplayEnv, FSharpOption`1<CompletionContext>, range>> GetDeclItemsForNamesAtPosition(CompilationThreadToken ctok, FSharpOption`1<FSharpParseFileResults> parseResultsOpt, FSharpOption`1<FSharpList`1<string>> origLongIdentOpt, FSharpOption`1<string> residueOpt, FSharpOption`1<int> lastDotPos, int line, string lineStr, int colAtEndOfNamesAndResidue, TypeNameResolutionFlag filterCtors, ResolveOverloads resolveOverloads, FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>> getAllSymbols, FSharpFunc`2<Tuple`2<object, range>, bool> hasTextChangedSinceLastTypecheck);
    [CompilerGeneratedAttribute]
internal bool IsValidSignatureFileItem(Item item);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
public class FSharp.Compiler.SourceCodeServices.UnresolvedReferencesSet : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<UnresolvedAssemblyReference> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<UnresolvedAssemblyReference> Item { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UnresolvedReferencesSet(FSharpList`1<UnresolvedAssemblyReference> item);
    [CompilationMappingAttribute("8", "0")]
internal static UnresolvedReferencesSet NewUnresolvedReferencesSet(FSharpList`1<UnresolvedAssemblyReference> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<UnresolvedAssemblyReference> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnresolvedReferencesSet obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SourceCodeServices.UnresolvedSymbol : object {
    [DebuggerBrowsableAttribute("0")]
internal string FullName@;
    [DebuggerBrowsableAttribute("0")]
internal string DisplayName@;
    [DebuggerBrowsableAttribute("0")]
internal String[] Namespace@;
    [CompilationMappingAttribute("4", "0")]
public string FullName { get; }
    [CompilationMappingAttribute("4", "1")]
public string DisplayName { get; }
    [CompilationMappingAttribute("4", "2")]
public String[] Namespace { get; }
    public UnresolvedSymbol(string fullName, string displayName, String[] namespace);
    public string get_FullName();
    public string get_DisplayName();
    public String[] get_Namespace();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(UnresolvedSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnresolvedSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.UntypedParseImpl : object {
    [CompilationMappingAttribute("9")]
internal static HashSet`1<string> emptyStringSet { get; }
    [CompilationMappingAttribute("9")]
internal static Regex insideAttributeApplicationRegex { get; }
    internal static HashSet`1<string> get_emptyStringSet();
    internal static Tuple`2<bool, range> CheckLongIdent@460(pos pos, FSharpList`1<Ident> longIdent);
    public static FSharpOption`1<range> GetRangeOfExprLeftOfDot(pos pos, FSharpOption`1<ParsedInput> parseTreeOpt);
    internal static FSharpList`1<string> getLidParts@557(pos pos, FSharpList`1<Ident> lid);
    internal static FSharpOption`1<FSharpList`1<string>> TryGetExpression@566(pos pos, bool foundCandidate, SynExpr expr);
    public static FSharpOption`1<string> TryFindExpressionIslandInPosition(pos pos, FSharpOption`1<ParsedInput> parseTreeOpt);
    internal static FSharpFunc`2<b, FSharpFunc`2<FSharpFunc`2<a, c>, Tuple`2<b, FSharpFunc`2<Unit, c>>>> dive@613-1(a x);
    internal static FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<Tuple`2<range, FSharpFunc`2<Unit, FSharpOption`1<b>>>>, FSharpOption`1<b>>> pick@614-7(pos pos, range x);
    internal static FSharpOption`1<Tuple`2<pos, bool>> traverseLidOrElse@635(pos pos, FSharpOption`1<SynExpr> optExprIfLeftOfLongId, LongIdentWithDots _arg1);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<pos, bool>> VisitExpr$cont@635(pos pos, FSharpFunc`2<SynExpr, FSharpOption`1<Tuple`2<pos, bool>>> traverseSynExpr, SynExpr expr, FSharpFunc`2<SynExpr, FSharpOption`1<Tuple`2<pos, bool>>> defaultTraverse, FSharpFunc`2<SynExpr, FSharpFunc`2<FSharpList`1<Tuple`2<range, FSharpFunc`2<Unit, FSharpOption`1<Tuple`2<pos, bool>>>>>, FSharpOption`1<Tuple`2<pos, bool>>>> pick, Unit unitVar);
    public static FSharpOption`1<Tuple`2<pos, bool>> TryFindExpressionASTLeftOfDotLeftOfCursor(pos pos, FSharpOption`1<ParsedInput> parseTreeOpt);
    internal static FSharpList`1<SynPat> |ConstructorPats|@707(SynConstructorArgs _arg1);
    internal static FSharpOption`1<FSharpList`1<SynExpr>> |Sequentials|_|@712(SynExpr _arg2);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<EntityKind> f@719-41(FSharpFunc`2<FSharpOption`1<EntityKind>, FSharpFunc`2<SynExpr, FSharpOption`1<EntityKind>>> walkExprWithKind, FSharpOption`1<EntityKind> parentKind, FSharpList`1<Tuple`3<Tuple`2<LongIdentWithDots, bool>, FSharpOption`1<SynExpr>, FSharpOption`1<Tuple`2<range, FSharpOption`1<pos>>>>> fields, Unit _arg9);
    public static FSharpOption`1<EntityKind> GetEntityKind(pos pos, ParsedInput input);
    internal static Regex get_insideAttributeApplicationRegex();
    internal static FSharpOption`1<Tuple`2<FSharpList`1<string>, FSharpOption`1<string>>> collect@1000-8(pos pos, FSharpList`1<string> plid, FSharpList`1<Ident> parts, FSharpList`1<range> dots);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<string>, FSharpOption`1<string>>> parseLid@999(pos pos, LongIdentWithDots _arg1);
    internal static FSharpFunc`2<SynAttribute, FSharpOption`1<Unit>> |SynAttr|_|@1033(string name);
    internal static Tuple`3<bool, bool, bool> getKind@1038(bool isClass, bool isInterface, bool isStruct, FSharpList`1<SynAttribute> _arg2);
    internal static FSharpChoice`5<Unit, Unit, Unit, Unit, Unit> |Class|Interface|Struct|Unknown|Invalid|@1032(FSharpList`1<SynAttribute> synAttributes);
    internal static FSharpOption`1<CompletionContext> GetCompletionContextForInheritSynMember@1054(SynComponentInfo tupledArg0, SynTypeDefnKind tupledArg1, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> tupledArg2);
    internal static FSharpFunc`2<SynExpr, FSharpOption`1<Tuple`2<SynExpr, SynExpr>>> |Operator|_|@1086(string name);
    internal static bool isInRhsOfRangeOp@1093(FSharpList`1<TraverseStep> p);
    internal static FSharpOption`1<Ident> |Setter|_|@1098(SynExpr e);
    internal static HashSet`1<string> findSetters@1103(SynExpr argList);
    internal static pos endOfLastIdent@1114(LongIdentWithDots lid);
    internal static pos endOfClosingTokenOrLastIdent@1118(FSharpOption`1<range> mClosing, LongIdentWithDots lid);
    internal static pos endOfClosingTokenOrIdent@1123(FSharpOption`1<range> mClosing, Ident id);
    internal static FSharpOption`1<Tuple`2<pos, HashSet`1<string>>> |NewObjectOrMethodCall|_|@1128(SynExpr e);
    internal static bool loop@1151-124(pos pos, SynExpr current, FSharpList`1<SynExpr> elements, FSharpList`1<range> commas);
    internal static bool isOnTheRightOfComma@1150(pos pos, FSharpList`1<SynExpr> elements, FSharpList`1<range> commas, SynExpr current);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<pos, HashSet`1<string>>> |PartOfParameterList|_|$cont@1163(pos pos, FSharpOption`1<SynExpr> precedingArgument, FSharpList`1<TraverseStep> path, Unit unitVar);
    internal static FSharpFunc`2<FSharpList`1<TraverseStep>, FSharpOption`1<Tuple`2<pos, HashSet`1<string>>>> |PartOfParameterList|_|@1162(pos pos, FSharpOption`1<SynExpr> precedingArgument);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<CompletionContext> VisitExpr$cont@1189-1(pos pos, FSharpList`1<TraverseStep> path, SynExpr expr, FSharpFunc`2<SynExpr, FSharpOption`1<CompletionContext>> defaultTraverse, Unit unitVar);
    internal static RecordContext contextFromTreePath@1217(FSharpList`1<TraverseStep> path, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> completionPath);
    internal static FSharpOption`1<CompletionContext> visitParam@1251(pos pos, FSharpFunc`2<SynBinding, FSharpOption`1<CompletionContext>> defaultTraverse, SynBinding _arg5, SynPat _arg10);
    internal static string cutLeadingAttributes@1341(string str);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<CompletionContext> TryGetCompletionContext$cont@1371(pos pos, string lineStr, FSharpFunc`2<string, bool> isLongIdent, Unit unitVar);
    public static FSharpOption`1<CompletionContext> TryGetCompletionContext(pos pos, ParsedInput parsedInput, string lineStr);
    public static String[] GetFullNameOfSmallestModuleOrNamespaceAtPoint(ParsedInput parsedInput, pos pos);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.UnusedOpens : object {
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<FSharpSymbol> symbolHash { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpSymbol, FSharpFunc`2<FSharpSymbol, bool>> equality@1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`3<FSharpSymbol, FSharpSymbol, bool> eq@1 { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<FSharpEntity> entityHash { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpEntity, FSharpFunc`2<FSharpEntity, bool>> equality@1-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`3<FSharpEntity, FSharpEntity, bool> eq@1-1 { get; }
    internal static IEqualityComparer`1<FSharpSymbol> get_symbolHash();
    internal static FSharpFunc`2<FSharpSymbol, FSharpFunc`2<FSharpSymbol, bool>> get_equality@1();
    internal static FSharpFunc`3<FSharpSymbol, FSharpSymbol, bool> get_eq@1();
    internal static FSharpList`1<OpenedModule> getModuleAndItsAutoOpens@61(bool isNestedAutoOpen, FSharpEntity modul);
    internal static OpenStatement[] getOpenStatements(FSharpOpenDeclaration[] openDeclarations);
    [CompilerGeneratedAttribute]
internal static bool filterSymbolUses$cont@98(FSharpFunc`2<int, string> getSourceLineStr, FSharpSymbolUse su, FSharpSymbol matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpSymbolUse[] filterSymbolUses(FSharpFunc`2<int, string> getSourceLineStr, FSharpSymbolUse[] symbolUses);
    internal static Tuple`2<FSharpSymbolUse[], FSharpSymbolUse[]> splitSymbolUses(FSharpSymbolUse[] symbolUses);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOpenStatementUsed(FSharpSymbolUse[] symbolUses2, Dictionary`2<FSharpEntity, FSharpList`1<range>> symbolUsesRangesByDeclaringEntity, Dictionary`2<FSharpEntity, FSharpList`1<range>> usedModules, OpenStatement openStatement);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<FSharpList`1<OpenStatement>> filterOpenStatementsIncremental(FSharpSymbolUse[] symbolUses2, Dictionary`2<FSharpEntity, FSharpList`1<range>> symbolUsesRangesByDeclaringEntity, FSharpList`1<OpenStatement> openStatements, Dictionary`2<FSharpEntity, FSharpList`1<range>> usedModules, FSharpList`1<OpenStatement> acc);
    internal static IEqualityComparer`1<FSharpEntity> get_entityHash();
    internal static FSharpFunc`2<FSharpEntity, FSharpFunc`2<FSharpEntity, bool>> get_equality@1-1();
    internal static FSharpFunc`3<FSharpEntity, FSharpEntity, bool> get_eq@1-1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<FSharpList`1<range>> filterOpenStatements(FSharpSymbolUse[] symbolUses1, FSharpSymbolUse[] symbolUses2, OpenStatement[] openStatements);
    public static FSharpAsync`1<FSharpList`1<range>> getUnusedOpens(FSharpCheckFileResults checkFileResults, FSharpFunc`2<int, string> getSourceLineStr);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SourceCodeServices.XmlDocable : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _line;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _indent;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<string> _paramNames;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int line { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int indent { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> paramNames { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal XmlDocable(int _line, int _indent, FSharpList`1<string> _paramNames);
    [CompilationMappingAttribute("8", "0")]
public static XmlDocable NewXmlDocable(int _line, int _indent, FSharpList`1<string> _paramNames);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_line();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_indent();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_paramNames();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(XmlDocable obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(XmlDocable obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.XmlDocComment : object {
    internal static FSharpOption`1<Tuple`2<string, int>> ws(string s, int pos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<string, int>> str(string prefix, string s, int pos);
    internal static FSharpOption`1<Tuple`2<string, a>> eol(string s, a pos);
    public static FSharpOption`1<int> isBlank(string s);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.SourceCodeServices.XmlDocParser : object {
    public static FSharpList`1<XmlDocable> getXmlDocables(ISourceText sourceText, FSharpOption`1<ParsedInput> input);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SourceCodeServices.XmlDocParsing : object {
    internal static FSharpList`1<SynPat> |ConstructorPats|(SynConstructorArgs _arg1);
    internal static FSharpList`1<string> digNamesFrom(SynPat _arg1);
    internal static int indentOf@44(ISourceText sourceText, int lineNum);
    internal static bool isEmptyXmlDoc@51(PreXmlDoc preXmlDoc);
    internal static FSharpList`1<XmlDocable> getXmlDocablesSynModuleOrNamespace@97(ISourceText sourceText, FSharpFunc`2<SynModuleDecl, FSharpList`1<XmlDocable>> getXmlDocablesSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpList`1<XmlDocable>> getXmlDocablesSynMemberDefn, SynModuleOrNamespace _arg1);
    internal static FSharpList`1<XmlDocable> getXmlDocablesSynTypeDefn@100(ISourceText sourceText, FSharpFunc`2<SynModuleDecl, FSharpList`1<XmlDocable>> getXmlDocablesSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpList`1<XmlDocable>> getXmlDocablesSynMemberDefn, SynTypeDefn _arg2);
    internal static FSharpList`1<XmlDocable> getXmlDocablesInput@149(ISourceText sourceText, FSharpFunc`2<SynModuleDecl, FSharpList`1<XmlDocable>> getXmlDocablesSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpList`1<XmlDocable>> getXmlDocablesSynMemberDefn, ParsedInput input);
    internal static FSharpList`1<XmlDocable> getXmlDocablesImpl(ISourceText sourceText, FSharpOption`1<ParsedInput> input);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SR : object {
    [CompilationMappingAttribute("9")]
internal static Lazy`1<ResourceManager> resources { get; }
    internal static Lazy`1<ResourceManager> get_resources();
    internal static string GetString(string name);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.StableNiceNameGenerator : object {
    internal object lockObj;
    internal Dictionary`2<Tuple`2<string, long>, string> names;
    internal Dictionary`2<string, int> basicNameCounts;
    public string GetUniqueCompilerGeneratedName(string name, range m, long uniq);
    public void Reset();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Tainted : object {
    internal static FSharpOption`1<Unit> |Null|_|(Tainted`1<T> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Eq(Tainted`1<T> p, T v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EqTainted(Tainted`1<T> t1, Tainted`1<T> t2);
    internal static int GetHashCodeTainted(Tainted`1<T> t);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[ClassAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Tainted`1 : object {
    internal T value;
    internal TaintedContext context;
    internal string TypeProviderDesignation { get; }
    internal ILScopeRef TypeProviderAssemblyRef { get; }
    internal Tainted`1<ITypeProvider> TypeProvider { get; }
    internal T AccessObjectDirectly { get; }
    public Tainted`1(TaintedContext context, T value);
    internal string get_TypeProviderDesignation();
    internal ILScopeRef get_TypeProviderAssemblyRef();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal a Protect(FSharpFunc`2<T, a> f, range range);
    internal Tainted`1<ITypeProvider> get_TypeProvider();
    internal Tainted`1<U> PApply(FSharpFunc`2<T, U> f, range range);
    internal Tuple`2<Tainted`1<U1>, Tainted`1<U2>> PApply2(FSharpFunc`2<T, Tuple`2<U1, U2>> f, range range);
    internal Tuple`3<Tainted`1<U1>, Tainted`1<U2>, Tainted`1<U3>> PApply3(FSharpFunc`2<T, Tuple`3<U1, U2, U3>> f, range range);
    internal Tuple`4<Tainted`1<U1>, Tainted`1<U2>, Tainted`1<U3>, Tainted`1<U4>> PApply4(FSharpFunc`2<T, Tuple`4<U1, U2, U3, U4>> f, range range);
    internal Tainted`1<U> PApplyNoFailure(FSharpFunc`2<T, U> f);
    internal Tainted`1<U> PApplyWithProvider(FSharpFunc`2<Tuple`2<T, ITypeProvider>, U> f, range range);
    internal Tainted`1[] PApplyArray(FSharpFunc`2<T, U[]> f, string methodName, range range);
    internal FSharpOption`1<Tainted`1<U>> PApplyOption(FSharpFunc`2<T, FSharpOption`1<U>> f, range range);
    internal U PUntaint(FSharpFunc`2<T, U> f, range range);
    internal U PUntaintNoFailure(FSharpFunc`2<T, U> f);
    internal T get_AccessObjectDirectly();
    internal static FSharpList`1<Tainted`1<ITypeProvider>> CreateAll(FSharpList`1<Tuple`2<ITypeProvider, ILScopeRef>> providerSpecs);
    internal FSharpOption`1<Tainted`1<U>> OfType();
    internal Tainted`1<U> Coerce(range range);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.TaintedContext : object {
    [DebuggerBrowsableAttribute("0")]
internal ITypeProvider TypeProvider@;
    [DebuggerBrowsableAttribute("0")]
internal ILScopeRef TypeProviderAssemblyRef@;
    [CompilationMappingAttribute("4", "0")]
internal ITypeProvider TypeProvider { get; }
    [CompilationMappingAttribute("4", "1")]
internal ILScopeRef TypeProviderAssemblyRef { get; }
    internal TaintedContext(ITypeProvider typeProvider, ILScopeRef typeProviderAssemblyRef);
    internal ITypeProvider get_TypeProvider();
    internal ILScopeRef get_TypeProviderAssemblyRef();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TaintedContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Tast : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, long> newUnique { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<long> i@39-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, long> newStamp { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<long> i@45-2 { get; }
    internal static string unassignedTyparName { get; }
    [CompilationMappingAttribute("9")]
internal static TupInfo tupInfoRef { get; }
    [CompilationMappingAttribute("9")]
internal static TupInfo tupInfoStruct { get; }
    internal static bool structnessDefault { get; }
    [CompilationMappingAttribute("9")]
internal static Accessibility taccessPublic { get; }
    [CompilationMappingAttribute("9")]
internal static CompilationPath compPathInternal { get; }
    [CompilationMappingAttribute("9")]
internal static Accessibility taccessInternal { get; }
    internal static string FSharpOptimizationDataResourceName { get; }
    internal static string FSharpSignatureDataResourceName { get; }
    internal static string FSharpOptimizationDataResourceName2 { get; }
    internal static string FSharpSignatureDataResourceName2 { get; }
    internal static FSharpFunc`2<Unit, long> get_newUnique();
    internal static FSharpRef`1<long> get_i@39-1();
    internal static FSharpFunc`2<Unit, long> get_newStamp();
    internal static FSharpRef`1<long> get_i@45-2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_unassignedTyparName();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static KeyValuePair`2<NameArityPair, b> KeyTyconByDemangledNameAndArity(string nm, FSharpList`1<a> typars, b x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static KeyValuePair`2[] KeyTyconByAccessNames(string nm, a x);
    internal static string getNameOfScopeRef(ILScopeRef sref);
    internal static FSharpOption`1<range> ComputeDefinitionLocationOfProvidedItem(Tainted`1<a> p);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2442-42(ValLinkagePartialKey this, ValLinkagePartialKey obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2442-43(IComparer comp, ValLinkagePartialKey this, object obj, ValLinkagePartialKey objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@4408-44(Const this, Const obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@4408-45(IComparer comp, Const this, Const objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@4408-5(IEqualityComparer comp, Const this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@4408-9(Const this, Const that, Unit unitVar);
    internal static string getName@701(Entity x, bool withUnderscoreTypars, string nm, Unit unitVar0);
    internal static ILTypeRef top@1209(string item, ILScopeRef sref, FSharpList`1<string> racc, FSharpList`1<Tuple`2<string, ModuleOrNamespaceKind>> p);
    internal static ILTypeRef ilTypeRefForCompilationPath@1208(CompilationPath _arg1, string item);
    [CompilerGeneratedAttribute]
internal static CompiledTypeRepr resf@381(Entity x, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static FSharpMap`2<NameArityPair, Entity> f@390-6(ModuleOrNamespaceType mtyp, range m, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static LayeredMultiMap`2<string, Entity> f@390-7(ModuleOrNamespaceType mtyp, Unit unitVar0);
    internal static FSharpFunc`2<CustomAttributeData, bool> findAttrib@2023-2(Type ty);
    internal static FSharpValueOption`1<Entity> tryResolveNestedTypeOf@3110(CcuThunk ccu, String[] path, Entity tupledArg0, ResolutionEnvironment tupledArg1, Tainted`1<ProvidedType> tupledArg2, int tupledArg3);
    internal static Entity injectNamespacesFromIToJ@3155(CcuThunk ccu, String[] path, ResolutionEnvironment resolutionEnvironment, int j, Tainted`1<ProvidedType> st, Entity entity, int k);
    internal static FSharpValueOption`1<Entity> tryResolvePrefix@3139(CcuThunk ccu, String[] path, int i, Entity entity, FSharpList`1<Tainted`1<ITypeProvider>> resolvers, ResolutionEnvironment resolutionEnvironment, int j);
    internal static FSharpValueOption`1<Entity> tryResolvePrefixes@3177(CcuThunk ccu, String[] path, int i, Entity entity, FSharpList`1<Tainted`1<ITypeProvider>> resolvers, ResolutionEnvironment resolutionEnvironment, int j);
    internal static FSharpValueOption`1<Entity> tryForwardPrefixPath@3201(String[] path, CcuThunk ccu, int i);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<UnionCase> f@495-8(UnionCaseRef x, Entity tcref);
    [CompilerGeneratedAttribute]
internal static FSharpValueOption`1<RecdField> f@495-9(RecdFieldRef x, Entity tcref);
    internal static int loop@4609-42(FSharpList`1<FSharpList`1<ArgReprInfo>> args, int acc);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@4408-10(Const this, Const obj, Unit unitVar);
    internal static TType typeOfVal(Val v);
    internal static FSharpList`1<TType> typesOfVals(FSharpList`1<Val> v);
    internal static string nameOfVal(Val v);
    internal static ValReprInfo arityOfVal(Val v);
    internal static TupInfo get_tupInfoRef();
    internal static TupInfo get_tupInfoStruct();
    internal static TupInfo mkTupInfo(bool b);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_structnessDefault();
    internal static TType mkRawRefTupleTy(FSharpList`1<TType> tys);
    internal static TType mkRawStructTupleTy(FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypedImplFile mapTImplFile(FSharpFunc`2<ModuleOrNamespaceExprWithSig, ModuleOrNamespaceExprWithSig> f, TypedImplFile _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TypedImplFile, b> mapAccImplFile(FSharpFunc`2<a, FSharpFunc`2<ModuleOrNamespaceExprWithSig, Tuple`2<ModuleOrNamespaceExprWithSig, b>>> f, a z, TypedImplFile _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b foldTImplFile(FSharpFunc`2<a, FSharpFunc`2<ModuleOrNamespaceExprWithSig, b>> f, a z, TypedImplFile _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarEq(Typar lv1, Typar lv2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarRefEq(Typar tp1, Typar tp2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valEq(Val lv1, Val lv2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ccuEq(CcuThunk mv1, CcuThunk mv2);
    internal static Val |ValDeref|(ValRef vr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdFieldRef mkRecdFieldRef(EntityRef tcref, string f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseRef mkUnionCaseRef(EntityRef tcref, string c);
    internal static EntityRef ERefLocal(Entity x);
    internal static EntityRef ERefNonLocal(NonLocalEntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ERefNonLocalPreResolved(Entity x, NonLocalEntityRef xref);
    internal static FSharpChoice`2<Entity, NonLocalEntityRef> |ERefLocal|ERefNonLocal|(EntityRef x);
    internal static EntityRef mkLocalTyconRef(Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef mkNonLocalEntityRef(CcuThunk ccu, String[] mp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef mkNestedNonLocalEntityRef(NonLocalEntityRef nleref, string id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkNonLocalTyconRef(NonLocalEntityRef nleref, string id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkNonLocalTyconRefPreResolved(Entity x, NonLocalEntityRef nleref, string id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseRef mkModuleUnionCaseRef(EntityRef modref, Entity tycon, UnionCase uc);
    internal static ValRef VRefLocal(Val x);
    internal static ValRef VRefNonLocal(NonLocalValOrMemberRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef VRefNonLocalPreResolved(Val x, NonLocalValOrMemberRef xref);
    internal static FSharpChoice`2<Val, NonLocalValOrMemberRef> |VRefLocal|VRefNonLocal|(ValRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef mkNonLocalValRef(NonLocalEntityRef mp, ValLinkageFullKey id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef mkNonLocalValRefPreResolved(Val x, NonLocalEntityRef mp, ValLinkageFullKey id);
    internal static FSharpOption`1<CcuThunk> ccuOfValRef(ValRef vref);
    internal static FSharpOption`1<CcuThunk> ccuOfTyconRef(EntityRef eref);
    internal static TType mkTyparTy(Typar tp);
    internal static Typar copyTypar(Typar tp);
    internal static FSharpList`1<Typar> copyTypars(FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure tryShortcutSolvedUnitPar(bool canShortcut, Typar r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure stripUnitEqnsAux(bool canShortcut, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyparEqnsAux(bool canShortcut, TType ty);
    internal static TType stripTyparEqns(TType ty);
    internal static Measure stripUnitEqns(Measure unt);
    internal static ValRef mkLocalValRef(Val v);
    internal static EntityRef mkLocalModRef(Entity v);
    internal static EntityRef mkLocalEntityRef(Entity v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkNonLocalCcuRootEntityRef(CcuThunk ccu, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef mkNestedValRef(EntityRef cref, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef rescopePubPathToParent(CcuThunk viewedCcu, PublicPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef rescopePubPath(CcuThunk viewedCcu, PublicPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valRefInThisAssembly(bool compilingFslib, ValRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyconRefUsesLocalXmlDoc(bool compilingFslib, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool entityRefInThisAssembly(bool compilingFslib, EntityRef x);
    internal static bool loop@5472-43(String[] y1, String[] y2, int len1, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool arrayPathEq(String[] y1, String[] y2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool nonLocalRefEq(NonLocalEntityRef _arg2, NonLocalEntityRef _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool nonLocalRefDefinitelyNotEq(NonLocalEntityRef _arg2, NonLocalEntityRef _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool pubPathEq(PublicPath _arg2, PublicPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool fslibRefEq(NonLocalEntityRef nlr1, PublicPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool fslibEntityRefEq(CcuThunk fslibCcu, EntityRef eref1, EntityRef eref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool fslibValRefEq(CcuThunk fslibCcu, ValRef vref1, ValRef vref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool primEntityRefEq(bool compilingFslib, CcuThunk fslibCcu, EntityRef x, EntityRef y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool primUnionCaseRefEq(bool compilingFslib, CcuThunk fslibCcu, UnionCaseRef _arg2, UnionCaseRef _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool primValRefEq(bool compilingFslib, CcuThunk fslibCcu, ValRef x, ValRef y);
    internal static CompilationPath fullCompPathOfModuleOrNamespace(Entity m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canAccessCompPathFrom(CompilationPath _arg2, CompilationPath _arg1);
    [CompilerGeneratedAttribute]
internal static bool loop@5596-45(FSharpList`1<Tuple`2<a, b>> p1, FSharpList`1<Tuple`2<a, b>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canAccessFromOneOf(FSharpList`1<CompilationPath> cpaths, CompilationPath cpathTest);
    [CompilerGeneratedAttribute]
internal static bool loop@5596-46(FSharpList`1<Tuple`2<a, b>> p1, FSharpList`1<Tuple`2<a, b>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canAccessFrom(Accessibility _arg1, CompilationPath cpath);
    internal static bool canAccessFromEverywhere(Accessibility _arg1);
    internal static bool canAccessFromSomewhere(Accessibility _arg1);
    [CompilerGeneratedAttribute]
internal static bool loop@5596-47(FSharpList`1<Tuple`2<a, b>> p1, FSharpList`1<Tuple`2<a, b>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isLessAccessible(Accessibility _arg2, Accessibility _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility accessSubstPaths(CompilationPath newPath, CompilationPath oldPath, Accessibility _arg1);
    internal static CompilationPath compPathOfCcu(CcuThunk ccu);
    internal static Accessibility get_taccessPublic();
    internal static Accessibility taccessPrivate(CompilationPath accessPath);
    internal static CompilationPath get_compPathInternal();
    internal static Accessibility get_taccessInternal();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility combineAccess(Accessibility _arg2, Accessibility _arg1);
    internal static cache`1<a> NewFreeVarsCache();
    internal static TyconUnionCases MakeUnionCasesTable(FSharpList`1<UnionCase> ucs);
    internal static TyconRecdFields MakeRecdFieldsTable(FSharpList`1<RecdField> ucs);
    internal static TyconUnionData MakeUnionCases(FSharpList`1<UnionCase> ucs);
    internal static TyconRepresentation MakeUnionRepr(FSharpList`1<UnionCase> ucs);
    internal static Typar NewTypar(TyparKind kind, TyparRigidity rigid, SynTypar _arg1, bool isFromError, TyparDynamicReq dynamicReq, FSharpList`1<Attrib> attribs, bool eqDep, bool compDep);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar NewRigidTypar(string nm, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCase NewUnionCase(Ident id, FSharpList`1<RecdField> tys, TType rty, FSharpList`1<Attrib> attribs, XmlDoc docOption, Accessibility access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType NewModuleOrNamespaceType(ModuleOrNamespaceKind mkind, FSharpList`1<Entity> tycons, FSharpList`1<Val> vals);
    internal static ModuleOrNamespaceType NewEmptyModuleOrNamespaceType(ModuleOrNamespaceKind mkind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity NewExn(FSharpOption`1<CompilationPath> cpath, Ident id, Accessibility access, ExceptionInfo repr, FSharpList`1<Attrib> attribs, XmlDoc doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdField NewRecdField(bool stat, FSharpOption`1<Const> konst, Ident id, bool nameGenerated, TType ty, bool isMutable, bool isVolatile, FSharpList`1<Attrib> pattribs, FSharpList`1<Attrib> fattribs, XmlDoc docOption, Accessibility access, bool secret);
    internal static Entity NewTycon(FSharpOption`1<CompilationPath> cpath, string nm, range m, Accessibility access, Accessibility reprAccess, TyparKind kind, LazyWithContext`2<FSharpList`1<Typar>, range> typars, XmlDoc docOption, bool usesPrefixDisplay, bool preEstablishedHasDefaultCtor, bool hasSelfReferentialCtor, MaybeLazy`1<ModuleOrNamespaceType> mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity NewILTycon(FSharpOption`1<CompilationPath> nlpath, string nm, range m, LazyWithContext`2<FSharpList`1<Typar>, range> tps, ILScopeRef scoref, FSharpList`1<ILTypeDef> enc, ILTypeDef tdef, MaybeLazy`1<ModuleOrNamespaceType> mtyp);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@5747-6(IEqualityComparer comp, Exception this, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity NewModuleOrNamespace(FSharpOption`1<CompilationPath> cpath, Accessibility access, Ident id, XmlDoc xml, FSharpList`1<Attrib> attribs, MaybeLazy`1<ModuleOrNamespaceType> mtype);
    internal static Val NewVal(string logicalName, range m, FSharpOption`1<string> compiledName, TType ty, ValMutability isMutable, bool isCompGen, FSharpOption`1<ValReprInfo> arity, Accessibility access, ValRecursiveScopeInfo recValInfo, FSharpOption`1<ValMemberInfo> specialRepr, ValBaseOrThisInfo baseOrThis, FSharpList`1<Attrib> attribs, ValInline inlineInfo, XmlDoc doc, bool isModuleOrMemberBinding, bool isExtensionMember, bool isIncrClassSpecialMember, bool isTyFunc, bool allowTypeInst, bool isGeneratedEventVal, FSharpOption`1<Const> konst, ParentRef actualParent);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity NewCcuContents(ILScopeRef sref, range m, string nm, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity NewModifiedTycon(FSharpFunc`2<Entity, Entity> f, Entity orig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity NewModifiedModuleOrNamespace(FSharpFunc`2<ModuleOrNamespaceType, ModuleOrNamespaceType> f, Entity orig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val NewModifiedVal(FSharpFunc`2<Val, Val> f, Val orig);
    internal static Entity NewClonedModuleOrNamespace(Entity orig);
    internal static Entity NewClonedTycon(Entity orig);
    internal static ModuleOrNamespaceType CombineModuleOrNamespaceTypes@5824(FSharpList`1<string> path, range m, ModuleOrNamespaceType mty1, ModuleOrNamespaceType mty2);
    internal static Entity CombineEntites@5850(FSharpList`1<string> path, Entity entity1, Entity entity2);
    internal static ModuleOrNamespaceType CombineModuleOrNamespaceTypeList@5868(FSharpList`1<string> path, range m, FSharpList`1<ModuleOrNamespaceType> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType CombineCcuContentFragments(range m, FSharpList`1<ModuleOrNamespaceType> l);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpOptimizationDataResourceName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpSignatureDataResourceName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpOptimizationDataResourceName2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpSignatureDataResourceName2();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Tastops : object {
    [CompilationMappingAttribute("9")]
internal static TyconRefMap`1<EntityRef> emptyTyconRefRemap { get; }
    internal static FSharpList`1<Tuple`2<Typar, TType>> emptyTyparInst { get; }
    [CompilationMappingAttribute("9")]
internal static Remap emptyRemap { get; }
    internal static int maxTuple { get; }
    internal static int goodTupleFields { get; }
    [CompilationMappingAttribute("9")]
internal static TypeEquivEnv typeEquivEnvEmpty { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<Val> valOrder { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<Entity> tyconOrder { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<RecdFieldRef> recdFieldRefOrder { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<UnionCaseRef> unionCaseRefOrder { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<Val, IComparer`1<Val>> emptyFreeLocals { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> emptyFreeRecdFields { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> emptyFreeUnionCases { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<Entity, IComparer`1<Entity>> emptyFreeTycons { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<Typar> typarOrder { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<Typar, IComparer`1<Typar>> emptyFreeTypars { get; }
    [CompilationMappingAttribute("9")]
internal static FreeTyvars emptyFreeTyvars { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectAllNoCaching { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectTyparsNoCaching { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectLocalsNoCaching { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectTyparsAndLocalsNoCaching { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectAll { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectTyparsAndLocals { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectTypars { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectLocals { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVars emptyFreeVars { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr box { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr isinst { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr unbox { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<TcGlobals, FSharpFunc`2<range, FSharpFunc`2<Expr, FSharpFunc`2<Expr, Expr>>>> mkGetStringChar { get; }
    [CompilationMappingAttribute("9")]
internal static string tnameCompilationSourceNameAttr { get; }
    [CompilationMappingAttribute("9")]
internal static string tnameCompilationArgumentCountsAttr { get; }
    [CompilationMappingAttribute("9")]
internal static string tnameCompilationMappingAttr { get; }
    [CompilationMappingAttribute("9")]
internal static string tnameSourceConstructFlags { get; }
    [CompilationMappingAttribute("9")]
internal static string tname_SignatureDataVersionAttr { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpList`1<string>, string> tnames_SignatureDataVersionAttr { get; }
    [CompilationMappingAttribute("9")]
internal static string tname_AutoOpenAttr { get; }
    internal static string tname_InternalsVisibleToAttr { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<string>, string> XmlDocSigOfUnionCase { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<string>, string> XmlDocSigOfField { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<string>, string> XmlDocSigOfProperty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<string>, string> XmlDocSigOfTycon { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<string>, string> XmlDocSigOfSubModul { get; }
    internal static int enum_CompilationRepresentationAttribute_Static { get; }
    internal static int enum_CompilationRepresentationAttribute_Instance { get; }
    internal static int enum_CompilationRepresentationAttribute_StaticInstanceMask { get; }
    internal static int enum_CompilationRepresentationAttribute_ModuleSuffix { get; }
    internal static int enum_CompilationRepresentationAttribute_PermitNull { get; }
    internal static TyconRefMap`1<EntityRef> get_emptyTyconRefRemap();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpList`1<Tuple`2<Typar, TType>> get_emptyTyparInst();
    internal static Remap get_emptyRemap();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap addTyconRefRemap(EntityRef tcref1, EntityRef tcref2, Remap tmenv);
    internal static bool isRemapEmpty(Remap remap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a instTyparRef(FSharpList`1<Tuple`2<Typar, a>> tpinst, a ty, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef remapTyconRef(TyconRefMap`1<EntityRef> tcmap, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseRef remapUnionCaseRef(TyconRefMap`1<EntityRef> tcmap, UnionCaseRef _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdFieldRef remapRecdFieldRef(TyconRefMap`1<EntityRef> tcmap, RecdFieldRef _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> mkTyparInst(FSharpList`1<Typar> typars, FSharpList`1<TType> tyargs);
    internal static FSharpList`1<TType> generalizeTypars(FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType remapTypeAux(Remap tyenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure remapMeasureAux(Remap tyenv, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TupInfo remapTupInfoAux(Remap _tyenv, TupInfo unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> remapTypesAux(Remap tyenv, FSharpList`1<TType> types);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TyparConstraint> remapTyparConstraintsAux(Remap tyenv, FSharpList`1<TyparConstraint> cs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TraitConstraintInfo remapTraitAux(Remap tyenv, TraitConstraintInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<a, b>> bindTypars(FSharpList`1<a> tps, FSharpList`1<b> tyargs, FSharpList`1<Tuple`2<a, b>> tpinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, Remap> copyAndRemapAndBindTyparsFull(FSharpFunc`2<FSharpList`1<Attrib>, FSharpList`1<Attrib>> remapAttrib, Remap tyenv, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, Remap> copyAndRemapAndBindTypars(Remap tyenv, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValLinkageFullKey remapValLinkage(Remap tyenv, ValLinkageFullKey vlink);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalValOrMemberRef remapNonLocalValRef(Remap tyenv, NonLocalValOrMemberRef nlvref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef remapValRef(Remap tmenv, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType remapType(Remap tyenv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> remapTypes(Remap tyenv, FSharpList`1<TType> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType remapTypeFull(FSharpFunc`2<FSharpList`1<Attrib>, FSharpList`1<Attrib>> remapAttrib, Remap tyenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotParam remapParam(Remap tyenv, SlotParam _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig remapSlotSig(FSharpFunc`2<FSharpList`1<Attrib>, FSharpList`1<Attrib>> remapAttrib, Remap tyenv, SlotSig _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType instType(FSharpList`1<Tuple`2<Typar, TType>> tpinst, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> instTypes(FSharpList`1<Tuple`2<Typar, TType>> tpinst, FSharpList`1<TType> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TraitConstraintInfo instTrait(FSharpList`1<Tuple`2<Typar, TType>> tpinst, TraitConstraintInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TyparConstraint> instTyparConstraints(FSharpList`1<Tuple`2<Typar, TType>> tpinst, FSharpList`1<TyparConstraint> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig instSlotSig(FSharpList`1<Tuple`2<Typar, TType>> tpinst, SlotSig ss);
    internal static SlotSig copySlotSig(SlotSig ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>> mkTyparToTyparRenaming(FSharpList`1<Typar> tpsOrig, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> mkTyconRefInst(EntityRef tcref, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyconRefEq(TcGlobals g, EntityRef tcref1, EntityRef tcref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valRefEq(TcGlobals g, ValRef vref1, ValRef vref2);
    internal static Measure reduceTyconRefAbbrevMeasureable(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure stripUnitEqnsFromMeasureAux(bool canShortcut, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational MeasureExprConExponent(TcGlobals g, bool abbrev, EntityRef ucref, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational MeasureConExponentAfterRemapping(TcGlobals g, FSharpFunc`2<EntityRef, EntityRef> r, EntityRef ucref, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational MeasureVarExponent(Typar tp, Measure unt);
    internal static FSharpList`1<Typar> gather@457(FSharpList`1<Typar> acc, Measure unt);
    internal static FSharpList`1<Typar> ListMeasureVarOccs(Measure unt);
    internal static FSharpList`1<Tuple`2<Typar, Rational>> gather@468-2(Measure untexpr, FSharpList`1<Tuple`2<Typar, Rational>> acc, Measure unt);
    internal static FSharpList`1<Tuple`2<Typar, Rational>> ListMeasureVarOccsWithNonZeroExponents(Measure untexpr);
    internal static FSharpList`1<Tuple`2<EntityRef, Rational>> gather@483-4(TcGlobals g, bool eraseAbbrevs, Measure untexpr, FSharpList`1<Tuple`2<EntityRef, Rational>> acc, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<EntityRef, Rational>> ListMeasureConOccsWithNonZeroExponents(TcGlobals g, bool eraseAbbrevs, Measure untexpr);
    internal static FSharpList`1<EntityRef> gather@498-6(TcGlobals g, FSharpFunc`2<EntityRef, EntityRef> r, FSharpList`1<EntityRef> acc, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<EntityRef> ListMeasureConOccsAfterRemapping(TcGlobals g, FSharpFunc`2<EntityRef, EntityRef> r, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure MeasurePower(Measure u, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure MeasureProdOpt(Measure m1, Measure m2);
    internal static Measure ProdMeasures(FSharpList`1<Measure> ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDimensionless(TcGlobals g, TType tyarg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar destUnitParMeasure(TcGlobals g, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnitParMeasure(TcGlobals g, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure normalizeMeasure(TcGlobals g, Measure ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType tryNormalizeMeasureInType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkNativePtrTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkInByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkOutByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkByrefTyWithFlag(TcGlobals g, bool readonly, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkByref2Ty(TcGlobals g, TType ty1, TType ty2);
    internal static TType mkVoidPtrTy(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkByrefTyWithInference(TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkArrayTy(TcGlobals g, int rank, TType ty, range m);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_maxTuple();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_goodTupleFields();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isCompiledTupleTyconRef(TcGlobals g, EntityRef tcref);
    [CompilerGeneratedAttribute]
internal static EntityRef mkCompiledTupleTyconRef$cont@646(TcGlobals g, bool isStruct, int n, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkCompiledTupleTyconRef(TcGlobals g, bool isStruct, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkCompiledTupleTy(TcGlobals g, bool isStruct, FSharpList`1<TType> tupElemTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkOuterCompiledTupleTy(TcGlobals g, bool isStruct, FSharpList`1<TType> tupElemTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType applyTyconAbbrev(TType abbrevTy, Entity tycon, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceTyconAbbrev(Entity tycon, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceTyconRefAbbrev(EntityRef tcref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceTyconMeasureableOrProvided(TcGlobals g, Entity tycon, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceTyconRefMeasureableOrProvided(TcGlobals g, EntityRef tcref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqnsA(TcGlobals g, bool canShortcut, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqns(TcGlobals g, TType ty);
    internal static bool evalTupInfoIsStruct(TupInfo aexpr);
    internal static bool evalAnonInfoIsStruct(AnonRecdTypeInfo anonInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqnsAndErase(bool eraseFuncAndTuple, TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqnsAndMeasureEqns(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqnsWrtErasure(Erasure erasureFlag, TcGlobals g, TType ty);
    internal static Entity stripExnEqns(EntityRef eref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, TType> primDestForallTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, TType> destFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TupInfo, FSharpList`1<TType>> destAnyTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> destRefTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> destStructTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar destTyparTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar destAnyParTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure destMeasureTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isForallTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAnyTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRefTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAnonRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructAnonRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isReprHiddenTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpObjModelTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpStructOrEnumTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpEnumTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTyparTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAnyParTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isMeasureTy(TcGlobals g, TType ty);
    internal static bool isProvenUnionCaseTy(TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkAppTy(EntityRef tcref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkProvenUnionCaseTy(UnionCaseRef ucref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Tuple`2<EntityRef, FSharpList`1<TType>>> tryAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<EntityRef, FSharpList`1<TType>> destAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef tcrefOfAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> argsOfAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Typar> tryDestTyparTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Tuple`2<TType, TType>> tryDestFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<EntityRef> tryDestAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Tuple`2<AnonRecdTypeInfo, FSharpList`1<TType>>> tryDestAnonRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Typar> tryAnyParTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Typar> tryAnyParTyOption(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<EntityRef, FSharpList`1<TType>>> |AppTy|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<TType>> |RefTupleTy|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<TType, TType>> |FunTy|_|(TcGlobals g, TType ty);
    internal static FSharpValueOption`1<EntityRef> tryNiceEntityRefOfTy(TType ty);
    internal static FSharpOption`1<EntityRef> tryNiceEntityRefOfTyOption(TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> mkInstForAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType domainOfFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType rangeOfFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType convertToTypeWithMetadataIfPossible(TcGlobals g, TType ty);
    internal static TypeEquivEnv get_typeEquivEnvEmpty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool traitsAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, TraitConstraintInfo _arg2, TraitConstraintInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool returnTypesAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, FSharpOption`1<TType> rty, FSharpOption`1<TType> rty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarConstraintsAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, TyparConstraint tpc1, TyparConstraint tpc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarConstraintSetsAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, Typar tp1, Typar tp2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarsAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, FSharpList`1<Typar> tps1, FSharpList`1<Typar> tps2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tcrefAEquiv(TcGlobals g, TypeEquivEnv aenv, EntityRef tc1, EntityRef tc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typeAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool anonInfoEquiv(AnonRecdTypeInfo anonInfo1, AnonRecdTypeInfo anonInfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool structnessAEquiv(TupInfo un1, TupInfo un2);
    internal static Typar trans@995(TcGlobals g, TypeEquivEnv aenv, Typar tp1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool measureAEquiv(TcGlobals g, TypeEquivEnv aenv, Measure un1, Measure un2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typesAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, FSharpList`1<TType> l1, FSharpList`1<TType> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typeEquivAux(Erasure erasureFlag, TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typeAEquiv(TcGlobals g, TypeEquivEnv aenv, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typeEquiv(TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool traitsAEquiv(TcGlobals g, TypeEquivEnv aenv, TraitConstraintInfo t1, TraitConstraintInfo t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarConstraintsAEquiv(TcGlobals g, TypeEquivEnv aenv, TyparConstraint c1, TyparConstraint c2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarsAEquiv(TcGlobals g, TypeEquivEnv aenv, FSharpList`1<Typar> d1, FSharpList`1<Typar> d2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool returnTypesAEquiv(TcGlobals g, TypeEquivEnv aenv, FSharpOption`1<TType> t1, FSharpOption`1<TType> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool measureEquiv(TcGlobals g, Measure m1, Measure m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isErasedType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> getErasedTypes(TcGlobals g, TType ty);
    internal static IComparer`1<Val> get_valOrder();
    internal static IComparer`1<Entity> get_tyconOrder();
    internal static IComparer`1<RecdFieldRef> get_recdFieldRefOrder();
    internal static IComparer`1<UnionCaseRef> get_unionCaseRefOrder();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFunTy(TType d, TType r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType op_MinusMinusGreater(TType d, TType r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkForallTyIfNeeded(FSharpList`1<Typar> d, TType r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType op_PlusMinusGreater(FSharpList`1<Typar> d, TType r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIteratedFunTy(FSharpList`1<TType> dl, TType r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkLambdaArgTy(range m, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType typeOfLambdaArg(range m, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkMultiLambdaTy(range m, FSharpList`1<Val> vs, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkLambdaTy(FSharpList`1<Typar> tps, FSharpList`1<TType> tys, TType rty);
    internal static void loop@1095-48(XmlDoc xml, ILScopeRef scoref, FSharpList`1<Tuple`2<string, ModuleOrNamespaceKind>> prior_cpath, FSharpList`1<Ident> path, FSharpList`1<Tuple`2<a, ModuleOrNamespaceKind>> cpath, Entity modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ensureCcuHasModuleOrNamespaceAtPath(CcuThunk ccu, FSharpList`1<Ident> path, CompilationPath _arg1, XmlDoc xml);
    internal static Expr stripExpr(Expr e);
    internal static DecisionTreeCase mkCase(DecisionTreeTest a, DecisionTree b);
    internal static bool isRefTupleExpr(Expr e);
    internal static FSharpList`1<Expr> tryDestRefTupleExpr(Expr e);
    internal static range rangeOfExpr(Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static range Expr.get_Range(Expr );
    internal static Expr primMkMatch(SequencePointInfoForBinding spBind, range exprm, DecisionTree tree, DecisionTreeTarget[] targets, range matchm, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree mkBoolSwitch(range m, Expr g, DecisionTree t, DecisionTree e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr primMkCond(SequencePointInfoForBinding spBind, SequencePointInfoForTarget spTarget1, SequencePointInfoForTarget spTarget2, range m, TType ty, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCond(SequencePointInfoForBinding spBind, SequencePointInfoForTarget spTarget, range m, TType ty, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr exprForValRef(range m, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr exprForVal(range m, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkLocalAux(range m, string s, TType ty, ValMutability mut, bool compgen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkLocal(range m, string s, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkCompGenLocal(range m, string s, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkMutableCompGenLocal(range m, string s, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkMultiLambda(range m, FSharpList`1<Val> vs, Expr b, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr rebuildLambda(range m, FSharpOption`1<Val> ctorThisValOpt, FSharpOption`1<Val> baseValOpt, FSharpList`1<Val> vs, Expr b, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLambda(range m, Val v, Expr b, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTypeLambda(range m, FSharpList`1<Typar> vs, Expr b, TType tau_ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTypeChoose(range m, FSharpList`1<Typar> vs, Expr b);
    internal static Expr mkObjExpr(TType ty, FSharpOption`1<Val> basev, Expr basecall, FSharpList`1<ObjExprMethod> overrides, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> iimpls, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLambdas(range m, FSharpList`1<Typar> tps, FSharpList`1<Val> vs, Expr b, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> mkMultiLambdasCore(range m, FSharpList`1<FSharpList`1<Val>> vsl, Expr b, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkMultiLambdas(range m, FSharpList`1<Typar> tps, FSharpList`1<FSharpList`1<Val>> vsl, Expr b, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkMemberLambdas(range m, FSharpList`1<Typar> tps, FSharpOption`1<Val> ctorThisValOpt, FSharpOption`1<Val> baseValOpt, FSharpList`1<FSharpList`1<Val>> vsl, Expr b, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding mkMultiLambdaBind(Val v, SequencePointInfoForBinding letSeqPtOpt, range m, FSharpList`1<Typar> tps, FSharpList`1<FSharpList`1<Val>> vsl, Expr b, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding mkBind(SequencePointInfoForBinding seqPtOpt, Val v, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLetBind(range m, Binding bind, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLetsBind(range m, FSharpList`1<Binding> binds, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLetsFromBindings(range m, FSharpList`1<Binding> binds, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLet(SequencePointInfoForBinding seqPtOpt, range m, Val v, Expr x, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding mkCompGenBind(Val v, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> mkCompGenBinds(FSharpList`1<Val> vs, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCompGenLet(range m, Val v, Expr x, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding mkInvisibleBind(Val v, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> mkInvisibleBinds(FSharpList`1<Val> vs, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkInvisibleLet(range m, Val v, Expr x, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkInvisibleLets(range m, FSharpList`1<Val> vs, FSharpList`1<Expr> xs, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkInvisibleLetsFromBindings(range m, FSharpList`1<Val> vs, FSharpList`1<Expr> xs, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLetRecBinds(range m, FSharpList`1<Binding> binds, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> NormalizeDeclaredTyparsForEquiRecursiveInference(TcGlobals g, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGenericBindRhs(TcGlobals g, range m, FSharpList`1<Typar> generalizedTyparsForRecursiveBlock, TypeScheme typeScheme, Expr bodyExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isBeingGeneralized(Typar tp, TypeScheme typeScheme);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLazyAnd(TcGlobals g, range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLazyOr(TcGlobals g, range m, Expr e1, Expr e2);
    internal static Expr mkCoerceExpr(Expr e, TType to_ty, range m, TType from_ty);
    internal static Expr mkAsmExpr(FSharpList`1<ILInstr> code, FSharpList`1<TType> tinst, FSharpList`1<Expr> args, FSharpList`1<TType> rettys, range m);
    internal static Expr mkUnionCaseExpr(UnionCaseRef uc, FSharpList`1<TType> tinst, FSharpList`1<Expr> args, range m);
    internal static Expr mkExnExpr(EntityRef uc, FSharpList`1<Expr> args, range m);
    internal static Expr mkTupleFieldGetViaExprAddr(TupInfo tupInfo, Expr e, FSharpList`1<TType> tinst, int i, range m);
    internal static Expr mkAnonRecdFieldGetViaExprAddr(AnonRecdTypeInfo anonInfo, Expr e, FSharpList`1<TType> tinst, int i, range m);
    internal static Expr mkRecdFieldGetViaExprAddr(Expr e, RecdFieldRef fref, FSharpList`1<TType> tinst, range m);
    internal static Expr mkRecdFieldGetAddrViaExprAddr(bool readonly, Expr e, RecdFieldRef fref, FSharpList`1<TType> tinst, range m);
    internal static Expr mkStaticRecdFieldGetAddr(bool readonly, RecdFieldRef fref, FSharpList`1<TType> tinst, range m);
    internal static Expr mkStaticRecdFieldGet(RecdFieldRef fref, FSharpList`1<TType> tinst, range m);
    internal static Expr mkStaticRecdFieldSet(RecdFieldRef fref, FSharpList`1<TType> tinst, Expr e, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkArrayElemAddress(TcGlobals g, bool readonly, ILReadonly ilInstrReadOnlyAnnotation, bool isNativePtr, ILArrayShape shape, TType elemTy, FSharpList`1<Expr> exprs, range m);
    internal static Expr mkRecdFieldSetViaExprAddr(Expr e1, RecdFieldRef fref, FSharpList`1<TType> tinst, Expr e2, range m);
    internal static Expr mkUnionCaseTagGetViaExprAddr(Expr e1, EntityRef cref, FSharpList`1<TType> tinst, range m);
    internal static Expr mkUnionCaseProof(Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, range m);
    internal static Expr mkUnionCaseFieldGetProvenViaExprAddr(Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, range m);
    internal static Expr mkUnionCaseFieldGetAddrProvenViaExprAddr(bool readonly, Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, range m);
    internal static Expr mkUnionCaseFieldGetUnprovenViaExprAddr(Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, range m);
    internal static Expr mkUnionCaseFieldSet(Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, Expr e2, range m);
    internal static Expr mkExnCaseFieldGet(Expr e1, EntityRef ecref, int j, range m);
    internal static Expr mkExnCaseFieldSet(Expr e1, EntityRef ecref, int j, Expr e2, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkDummyLambda(TcGlobals g, Expr e, TType ety);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkWhile(TcGlobals g, SequencePointInfoForWhileLoop spWhile, SpecialWhileLoopMarker marker, Expr e1, Expr e2, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkFor(TcGlobals g, SequencePointInfoForForLoop spFor, Val v, Expr e1, ForLoopStyle dir, Expr e2, Expr e3, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTryWith(TcGlobals g, Expr e1, Val vf, Expr ef, Val vh, Expr eh, range m, TType ty, SequencePointInfoForTry spTry, SequencePointInfoForWith spWith);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTryFinally(TcGlobals g, Expr e1, Expr e2, range m, TType ty, SequencePointInfoForTry spTry, SequencePointInfoForFinally spFinally);
    internal static Expr mkDefault(range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkValSet(range m, ValRef v, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAddrSet(range m, ValRef v, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAddrGet(range m, ValRef v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkValAddr(range m, bool readonly, ValRef v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<EntityRef> tryRescopeEntity(CcuThunk viewedCcu, Entity entity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<ValRef> tryRescopeVal(CcuThunk viewedCcu, Remap entityRemap, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualTyOfRecdField(FSharpList`1<Tuple`2<Typar, TType>> inst, RecdField fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> actualTysOfRecdFields(FSharpList`1<Tuple`2<Typar, TType>> inst, FSharpList`1<RecdField> rfields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> actualTysOfInstanceRecdFields(FSharpList`1<Tuple`2<Typar, TType>> inst, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> actualTysOfUnionCaseFields(FSharpList`1<Tuple`2<Typar, TType>> inst, UnionCaseRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualResultTyOfUnionCase(FSharpList`1<TType> tinst, UnionCaseRef x);
    internal static FSharpList`1<RecdField> recdFieldsOfExnDefRef(EntityRef x);
    internal static FSharpList`1<TType> recdFieldTysOfExnDefRef(EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType recdFieldTyOfExnDefRefByIdx(EntityRef x, int j);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualTyOfRecdFieldForTycon(Entity tycon, FSharpList`1<TType> tinst, RecdField fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualTyOfRecdFieldRef(RecdFieldRef fref, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualTyOfUnionFieldRef(UnionCaseRef fref, int n, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, TType> destForallTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, TType> tryDestForallTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, TType> stripFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType applyForallTy(TcGlobals g, TType ty, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceIteratedFunTy(TcGlobals g, TType ty, FSharpList`1<a> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType applyTyArgs(TcGlobals g, TType functy, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType applyTys(TcGlobals g, TType functy, FSharpList`1<TType> tyargs, FSharpList`1<T> argtys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType formalApplyTys(TcGlobals g, TType functy, FSharpList`1<a> tyargs, FSharpList`1<b> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, TType> stripFunTyN(TcGlobals g, int n, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TupInfo, FSharpList`1<TType>> tryDestAnyTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> tryDestRefTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, TType> GetTopTauTypeInFSharpForm(TcGlobals g, FSharpList`1<FSharpList`1<ArgReprInfo>> curriedArgInfos, TType tau, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, TType> destTopForallTy(TcGlobals g, ValReprInfo _arg1, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, TType, ArgReprInfo> GetTopValTypeInFSharpForm(TcGlobals g, ValReprInfo _arg1, TType ty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsCompiledAsStaticProperty(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsCompiledAsStaticPropertyWithField(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isArrayTyconRef(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int rankOfArrayTyconRef(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destArrayTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destListTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyconRefEqOpt(TcGlobals g, FSharpOption`1<EntityRef> tcOpt, EntityRef tc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStringTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isListTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isArrayTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isArray1DTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnitTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isObjTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isVoidTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNativePtrTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isInByrefTag(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isInByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOutByrefTag(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOutByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconRepresentation extensionInfoOfTy(TcGlobals g, TType ty);
    internal static TypeDefMetadata metadataOfTycon(Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeDefMetadata metadataOfTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILReferenceTy(TcGlobals g, TType ty);
    internal static bool isILInterfaceTycon(Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int rankOfArrayTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpObjModelRefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpClassTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpStructTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpInterfaceTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDelegateTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isInterfaceTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isClassTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructOrEnumTyconTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructRecordOrUnionTyconTy(TcGlobals g, TType ty);
    internal static bool isStructTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnmanagedTy(TcGlobals g, TType ty);
    internal static bool isInterfaceTycon(Entity x);
    internal static bool isInterfaceTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isEnumTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> actualReturnTyOfSlotSig(FSharpList`1<TType> parentTyInst, FSharpList`1<TType> methTyInst, SlotSig _arg1);
    internal static bool slotSigHasVoidReturnTy(SlotSig _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> returnTyOfMethod(TcGlobals g, ObjExprMethod _arg1);
    internal static bool isAbstractTycon(Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberIsExplicitImpl(TcGlobals g, ValMemberInfo membInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValIsExplicitImpl(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRefIsExplicitImpl(TcGlobals g, ValRef vref);
    internal static Set`2<Val, IComparer`1<Val>> get_emptyFreeLocals();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> unionFreeLocals(Set`2<Val, IComparer`1<Val>> s1, Set`2<Val, IComparer`1<Val>> s2);
    internal static Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> get_emptyFreeRecdFields();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> unionFreeRecdFields(Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> s1, Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> s2);
    internal static Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> get_emptyFreeUnionCases();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> unionFreeUnionCases(Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> s1, Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> s2);
    internal static Set`2<Entity, IComparer`1<Entity>> get_emptyFreeTycons();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Entity, IComparer`1<Entity>> unionFreeTycons(Set`2<Entity, IComparer`1<Entity>> s1, Set`2<Entity, IComparer`1<Entity>> s2);
    internal static IComparer`1<Typar> get_typarOrder();
    internal static Set`2<Typar, IComparer`1<Typar>> get_emptyFreeTypars();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Typar, IComparer`1<Typar>> unionFreeTypars(Set`2<Typar, IComparer`1<Typar>> s1, Set`2<Typar, IComparer`1<Typar>> s2);
    internal static FreeTyvars get_emptyFreeTyvars();
    internal static bool isEmptyFreeTyvars(FreeTyvars ftyvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars unionFreeTyvars(FreeTyvars fvs1, FreeTyvars fvs2);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1916-47(FreeVarOptions this, FreeVarOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1916-46(FreeVarOptions this, FreeVarOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1916-49(FreeVarOptions this, FreeVarOptions objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1916-48(FreeVarOptions this, FreeVarOptions objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1916-11(FreeVarOptions this, object obj, Unit unitVar);
    internal static FreeVarOptions get_CollectAllNoCaching();
    internal static FreeVarOptions get_CollectTyparsNoCaching();
    internal static FreeVarOptions get_CollectLocalsNoCaching();
    internal static FreeVarOptions get_CollectTyparsAndLocalsNoCaching();
    internal static FreeVarOptions get_CollectAll();
    internal static FreeVarOptions get_CollectTyparsAndLocals();
    internal static FreeVarOptions get_CollectTypars();
    internal static FreeVarOptions get_CollectLocals();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeLocalTycon(FreeVarOptions opts, Entity x, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeTycon(FreeVarOptions opts, EntityRef tcref, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars boundTypars(FreeVarOptions opts, FSharpList`1<Typar> tps, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTyparConstraints(FreeVarOptions opts, FSharpList`1<TyparConstraint> cxs, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTyparConstraint(FreeVarOptions opts, TyparConstraint tpc, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTrait(FreeVarOptions opts, TraitConstraintInfo _arg1, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTraitSln(FreeVarOptions opts, TraitConstraintSln sln, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeLocalValInTraitSln(a _opts, Val v, FreeTyvars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeValRefInTraitSln(FreeVarOptions opts, ValRef vref, FreeTyvars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeTyparRef(FreeVarOptions opts, Typar tp, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInType(FreeVarOptions opts, TType ty, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTupInfo(FreeVarOptions _opts, TupInfo unt, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInMeasure(FreeVarOptions opts, Measure unt, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTypes(FreeVarOptions opts, FSharpList`1<TType> tys, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars freeInType(FreeVarOptions opts, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars freeInTypes(FreeVarOptions opts, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars freeInVal(FreeVarOptions opts, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTypars(FreeVarOptions opts, FSharpList`1<Typar> tps, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars addFreeInModuleTy(ModuleOrNamespaceType mtyp, FreeTyvars acc);
    internal static FreeTyvars freeInModuleTy(ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> boundTyparsLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTyparConstraintsLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, FSharpList`1<TyparConstraint> cxs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTyparConstraintLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, TyparConstraint tpc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTraitLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, TraitConstraintInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeTyparRefLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTypeLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTupInfoLeftToRight(TcGlobals _g, bool _cxFlag, bool _thruFlag, FSharpList`1<Typar> acc, TupInfo unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTypesLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> freeInTypeLeftToRight(TcGlobals g, bool thruFlag, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> freeInTypesLeftToRight(TcGlobals g, bool thruFlag, FSharpList`1<TType> ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> freeInTypesLeftToRightSkippingConstraints(TcGlobals g, FSharpList`1<TType> ty);
    internal static FSharpList`1<Val> valsOfBinds(FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, TType, ArgReprInfo> GetMemberTypeInFSharpForm(TcGlobals g, MemberFlags memberFlags, ValReprInfo arities, TType ty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<a, b> checkMemberVal(FSharpOption`1<a> membInfo, FSharpOption`1<b> arity, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, FSharpOption`1<TType>, ArgReprInfo> GetTopValTypeInCompiledForm(TcGlobals g, ValReprInfo topValInfo, TType ty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, FSharpOption`1<TType>, ArgReprInfo> GetMemberTypeInMemberForm(TcGlobals g, MemberFlags memberFlags, ValReprInfo topValInfo, TType ty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, FSharpOption`1<TType>, ArgReprInfo> GetTypeOfMemberInMemberForm(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, TType, ArgReprInfo> GetTypeOfMemberInFSharpForm(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>>> PartitionValTyparsForApparentEnclosingType(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>>> PartitionValTypars(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>>> PartitionValRefTypars(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> ArgInfosOfMemberVal(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> ArgInfosOfMember(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType GetFSharpViewOfReturnType(TcGlobals g, FSharpOption`1<TType> retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ReturnTypeOfPropertyVal(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TType, ArgReprInfo>> ArgInfosOfPropertyVal(TcGlobals g, Val v);
    internal static Tuple`2<FSharpList`1<TType>, TType> generalizeTyconRef(EntityRef tc);
    internal static TType generalizedTyconRef(EntityRef tc);
    internal static string prefixOfStaticReq(TyparStaticReq s);
    internal static string prefixOfRigidTypar(Typar typar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string op_PlusDotPlus(string s1, string s2);
    internal static Layout layoutOfPath(FSharpList`1<string> p);
    internal static FSharpValueOption`1<string> fullNameOfParentOfPubPath(PublicPath pp);
    internal static FSharpValueOption`1<Layout> fullNameOfParentOfPubPathAsLayout(PublicPath pp);
    internal static FSharpValueOption`1<string> fullNameOfParentOfNonLocalEntityRef(NonLocalEntityRef nlr);
    internal static FSharpValueOption`1<Layout> fullNameOfParentOfNonLocalEntityRefAsLayout(NonLocalEntityRef nlr);
    internal static FSharpValueOption`1<string> fullNameOfParentOfEntityRef(EntityRef eref);
    internal static FSharpValueOption`1<Layout> fullNameOfParentOfEntityRefAsLayout(EntityRef eref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string fullNameOfEntityRef(FSharpFunc`2<EntityRef, string> nmF, EntityRef xref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedText tagEntityRefName(EntityRef xref, string name);
    internal static string fullDisplayTextOfTyconRef(EntityRef tc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout fullNameOfEntityRefAsLayout(FSharpFunc`2<EntityRef, string> nmF, EntityRef xref);
    internal static FSharpValueOption`1<string> fullNameOfParentOfValRef(ValRef vref);
    internal static FSharpValueOption`1<Layout> fullNameOfParentOfValRefAsLayout(ValRef vref);
    internal static FSharpValueOption`1<string> fullDisplayTextOfParentOfModRef(EntityRef r);
    internal static string fullDisplayTextOfModRef(EntityRef r);
    internal static Layout fullDisplayTextOfTyconRefAsLayout(EntityRef r);
    internal static string fullDisplayTextOfExnRef(EntityRef r);
    internal static Layout fullDisplayTextOfExnRefAsLayout(EntityRef r);
    internal static string fullDisplayTextOfUnionCaseRef(UnionCaseRef ucref);
    internal static string fullDisplayTextOfRecdFieldRef(RecdFieldRef rfref);
    internal static string fullDisplayTextOfValRef(ValRef vref);
    internal static Layout fullDisplayTextOfValRefAsLayout(ValRef vref);
    internal static String[] fullMangledPathToTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string qualifiedMangledNameOfTyconRef(EntityRef tcref, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool firstEq(FSharpList`1<a> p1, FSharpList`1<a> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<b> firstRem(FSharpList`1<a> p1, FSharpList`1<b> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string trimPathByDisplayEnv(DisplayEnv denv, FSharpList`1<string> path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType superOfTycon(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILAttribByName(FSharpList`1<string> tencl, string tname, ILAttribute attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>>> TryDecodeILAttribute(TcGlobals g, ILTypeRef tref, ILAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsMatchingFSharpAttribute(TcGlobals g, BuiltinAttribInfo _arg2, Attrib _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasFSharpAttribute(TcGlobals g, BuiltinAttribInfo tref, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Attrib> TryFindFSharpAttribute(TcGlobals g, BuiltinAttribInfo tref, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Attrib> TryFindFSharpAttributeOpt(TcGlobals g, FSharpOption`1<BuiltinAttribInfo> tref, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasFSharpAttributeOpt(TcGlobals g, FSharpOption`1<BuiltinAttribInfo> trefOpt, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsMatchingFSharpAttributeOpt(TcGlobals g, FSharpOption`1<BuiltinAttribInfo> attrOpt, Attrib _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<AttribExpr> |ExtractAttribNamedArg|_|(string nm, FSharpList`1<AttribNamedArg> args);
    internal static FSharpOption`1<int> |AttribInt32Arg|_|(AttribExpr _arg1);
    internal static FSharpOption`1<short> |AttribInt16Arg|_|(AttribExpr _arg1);
    internal static FSharpOption`1<bool> |AttribBoolArg|_|(AttribExpr _arg1);
    internal static FSharpOption`1<string> |AttribStringArg|_|(AttribExpr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindFSharpBoolAttributeWithDefault(bool dflt, TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindFSharpBoolAttribute(TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindFSharpBoolAttributeAssumeFalse(TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<int> TryFindFSharpInt32Attribute(TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindFSharpStringAttribute(TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TryFindILAttribute(BuiltinAttribInfo _arg1, ILAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TryFindILAttributeOpt(FSharpOption`1<BuiltinAttribInfo> attr, ILAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> TryBindTyconRefAttribute(TcGlobals g, range m, BuiltinAttribInfo _arg1, EntityRef tcref, FSharpFunc`2<Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>>, FSharpOption`1<a>> f1, FSharpFunc`2<Attrib, FSharpOption`1<a>> f2, FSharpFunc`2<Tuple`2<FSharpList`1<FSharpOption`1<object>>, FSharpList`1<Tuple`2<string, FSharpOption`1<object>>>>, FSharpOption`1<a>> f3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindTyconRefBoolAttribute(TcGlobals g, range m, BuiltinAttribInfo attribSpec, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindAttributeUsageAttribute(TcGlobals g, range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindTyconRefStringAttribute(TcGlobals g, range m, BuiltinAttribInfo attribSpec, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconRefHasAttribute(TcGlobals g, range m, BuiltinAttribInfo attribSpec, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isByrefTyconRef(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isByrefLikeTyconRef(TcGlobals g, range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpanLikeTyconRef(TcGlobals g, range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isByrefLikeTy(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpanLikeTy(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpanTyconRef(TcGlobals g, range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpanTy(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<ValueTuple`2<EntityRef, TType>> tryDestSpanTy(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueTuple`2<EntityRef, TType> destSpanTy(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isReadOnlySpanTyconRef(TcGlobals g, range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isReadOnlySpanTy(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<ValueTuple`2<EntityRef, TType>> tryDestReadOnlySpanTy(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueTuple`2<EntityRef, TType> destReadOnlySpanTy(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |ByrefTy|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destNativePtrTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRefCellTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destRefCellTy(TcGlobals g, TType ty);
    internal static TType StripSelfRefCell(TcGlobals g, ValBaseOrThisInfo baseOrThisInfo, TType tau);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkRefCellTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkLazyTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkPrintfFormatTy(TcGlobals g, TType aty, TType bty, TType cty, TType dty, TType ety);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkListTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<TType> tryDestOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNullableTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<TType> tryDestNullableTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destNullableTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |NullableTy|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType |StripNullableTy|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isLinqExpressionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> tryDestLinqExpressionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destLinqExpressionTy(TcGlobals g, TType ty);
    internal static UnionCaseRef mkNoneCase(TcGlobals g);
    internal static UnionCaseRef mkSomeCase(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSome(TcGlobals g, TType ty, Expr arg, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNone(TcGlobals g, TType ty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.get_IsDispatchSlot(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<ValRef, Expr>> |UnopExpr|_|(a _g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<ValRef, Expr, Expr>> |BinopExpr|_|(a _g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> |SpecificUnopExpr|_|(TcGlobals g, ValRef vrefReqd, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Expr>> |SpecificBinopExpr|_|(TcGlobals g, ValRef vrefReqd, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> |EnumExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Expr>> |AttribBitwiseOrExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUncheckedDefaultOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTypeOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSizeOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTypeDefOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |UncheckedDefaultOfExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |TypeOfExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |SizeOfExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |TypeDefOfExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity wrapModuleOrNamespaceType(Ident id, CompilationPath cpath, ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceType, Entity> wrapModuleOrNamespaceTypeInNamespace(Ident id, CompilationPath cpath, ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceExpr wrapModuleOrNamespaceExprInNamespace(Ident id, CompilationPath cpath, ModuleOrNamespaceExpr mexpr);
    internal static ModuleOrNamespaceType SigTypeOfImplFile(TypedImplFile _arg1);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@3969-50(SignatureHidingInfo this, SignatureHidingInfo obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@3969-51(IComparer comp, SignatureHidingInfo this, SignatureHidingInfo objTemp, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap addValRemap(Val v, Val vNew, Remap tmenv);
    internal static Remap mkRepackageRemapping(SignatureRepackageInfo mrpi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemap(ModuleOrNamespaceType msigty, Entity entity, SignatureRepackageInfo mrpi, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accSubEntityRemap(ModuleOrNamespaceType msigty, Entity entity, SignatureRepackageInfo mrpi, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valLinkageAEquiv(TcGlobals g, TypeEquivEnv aenv, Val v1, Val v2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemap(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType msigty, Val implVal, SignatureRepackageInfo mrpi, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType getCorrespondingSigTy(string nm, ModuleOrNamespaceType msigty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemapFromModuleOrNamespaceType(ModuleOrNamespaceType mty, ModuleOrNamespaceType msigty, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemapFromModuleOrNamespaceType(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType mty, ModuleOrNamespaceType msigty, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> ComputeRemappingFromInferredSignatureToExplicitSignature(TcGlobals g, ModuleOrNamespaceType mty, ModuleOrNamespaceType msigty);
    internal static FSharpList`1<Val> abstractSlotValsOfTycons(FSharpList`1<Entity> tycons);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemapFromModuleOrNamespace(ModuleOrNamespaceType msigty, ModuleOrNamespaceExpr x, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemapFromModuleOrNamespaceDefs(ModuleOrNamespaceType msigty, FSharpList`1<ModuleOrNamespaceExpr> mdefs, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemapFromModuleOrNamespaceBind(ModuleOrNamespaceType msigty, ModuleOrNamespaceBinding x, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemapFromModuleOrNamespace(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType msigty, ModuleOrNamespaceExpr x, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemapFromModuleOrNamespaceBind(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType msigty, ModuleOrNamespaceBinding x, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemapFromModuleOrNamespaceDefs(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType msigty, FSharpList`1<ModuleOrNamespaceExpr> mdefs, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> ComputeRemappingFromImplementationToSignature(TcGlobals g, ModuleOrNamespaceExpr mdef, ModuleOrNamespaceType msigty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo accTyconHidingInfoAtAssemblyBoundary(Entity tycon, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo accValHidingInfoAtAssemblyBoundary(Val vspec, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo accModuleOrNamespaceHidingInfoAtAssemblyBoundary(ModuleOrNamespaceType mty, SignatureHidingInfo acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo ComputeHidingInfoAtAssemblyBoundary(ModuleOrNamespaceType mty, SignatureHidingInfo acc);
    internal static bool check@4217-2(FSharpFunc`2<a, Set`2<b, IComparer`1<b>>> setF, FSharpFunc`2<b, Accessibility> accessF, FSharpFunc`2<c, FSharpFunc`2<b, b>> remapF, FSharpList`1<Tuple`2<c, a>> mrmi, b x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpList`1<Tuple`2<c, a>>, FSharpFunc`2<b, bool>> IsHidden(FSharpFunc`2<a, Set`2<b, IComparer`1<b>>> setF, FSharpFunc`2<b, Accessibility> accessF, FSharpFunc`2<c, FSharpFunc`2<b, b>> remapF, FSharpFunc`2<b, Layout> debugF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsHiddenTycon(TcGlobals g, FSharpList`1<Tuple`2<Remap, SignatureHidingInfo>> mrmi, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsHiddenTyconRepr(TcGlobals g, FSharpList`1<Tuple`2<Remap, SignatureHidingInfo>> mrmi, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsHiddenVal(FSharpList`1<Tuple`2<Remap, SignatureHidingInfo>> mrmi, Val x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsHiddenRecdField(FSharpList`1<Tuple`2<Remap, SignatureHidingInfo>> mrmi, RecdFieldRef x);
    internal static a go@4247-7(FSharpFunc`2<Entity, FSharpFunc`2<a, a>> ft, FSharpFunc`2<Val, FSharpFunc`2<a, a>> fv, ModuleOrNamespaceType mty, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldModuleOrNamespaceTy(FSharpFunc`2<Entity, FSharpFunc`2<a, a>> ft, FSharpFunc`2<Val, FSharpFunc`2<a, a>> fv, ModuleOrNamespaceType mty, a acc);
    internal static FSharpList`1<Val> allValsOfModuleOrNamespaceTy(ModuleOrNamespaceType m);
    internal static FSharpList`1<Entity> allEntitiesOfModuleOrNamespaceTy(ModuleOrNamespaceType m);
    internal static bool isPublicUnionCase(UnionCaseRef ucr);
    internal static bool isPublicRecdField(RecdFieldRef rfr);
    internal static bool freeVarsAllPublic(FreeVars fvs);
    internal static bool freeTyvarsAllPublic(FreeTyvars tyvars);
    internal static FSharpOption`1<Tuple`8<SequencePointInfoForBinding, range, DecisionTree, DecisionTreeTarget, Expr, SequencePointInfoForTarget, range, Tuple`1<TType>>> |LinearMatchExpr|_|(Expr expr);
    internal static Expr rebuildLinearMatchExpr(Tuple`8<SequencePointInfoForBinding, range, DecisionTree, DecisionTreeTarget, Expr, SequencePointInfoForTarget, range, Tuple`1<TType>> tupledArg);
    internal static FSharpOption`1<Tuple`5<TOp, FSharpList`1<TType>, FSharpList`1<Expr>, Expr, range>> |LinearOpExpr|_|(Expr expr);
    internal static Expr rebuildLinearOpExpr(Tuple`5<TOp, FSharpList`1<TType>, FSharpList`1<Expr>, Expr, range> tupledArg);
    internal static FreeVars get_emptyFreeVars();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars unionFreeVars(FreeVars fvs1, FreeVars fvs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeVarsInTy(FreeVarOptions opts, TType ty, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeVarsInTys(FreeVarOptions opts, FSharpList`1<TType> tys, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreevarsInTycon(FreeVarOptions opts, EntityRef tcref, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreevarsInVal(FreeVarOptions opts, Val v, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeVarsInTraitSln(FreeVarOptions opts, TraitConstraintSln tys, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars boundLocalVal(FreeVarOptions opts, Val v, FreeVars fvs);
    internal static FreeVars boundProtect(FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accUsesFunctionLocalConstructs(bool flg, FreeVars fvs);
    internal static FreeVars bound_rethrow(FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accUsesRethrow(bool flg, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars boundLocalVals(FreeVarOptions opts, FSharpList`1<Val> vs, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a freeVarsCacheCompute(FreeVarOptions opts, cache`1<a> cache, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInSwitchCases(FreeVarOptions opts, FSharpList`1<DecisionTreeCase> csl, FSharpOption`1<DecisionTree> dflt, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInSwitchCase(FreeVarOptions opts, DecisionTreeCase _arg2, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInTest(FreeVarOptions opts, DecisionTreeTest discrim, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInDecisionTree(FreeVarOptions opts, DecisionTree x, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInValFlags(FreeVarOptions opts, ValUseFlag flag, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeLocalVal(FreeVarOptions opts, Val v, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accLocalTyconRepr(FreeVarOptions opts, Entity b, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accUsedRecdOrUnionTyconRepr(FreeVarOptions opts, Entity tc, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeUnionCaseRef(FreeVarOptions opts, UnionCaseRef ucref, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeRecdFieldRef(FreeVarOptions opts, RecdFieldRef rfref, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeValRef(FreeVarOptions opts, ValRef vref, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInMethod(FreeVarOptions opts, ObjExprMethod _arg3, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInMethods(FreeVarOptions opts, FSharpList`1<ObjExprMethod> methods, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInExpr(FreeVarOptions opts, Expr x, FreeVars acc);
    [CompilerGeneratedAttribute]
internal static FreeVars func1@1(FreeVarOptions opts, FreeVars acc, cache`1<FreeVars> cache, Binding bind, FreeVars free);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInExprLinear(FreeVarOptions opts, Expr x, FreeVars acc, FSharpFunc`2<FreeVars, FreeVars> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInExprNonLinear(FreeVarOptions opts, Expr x, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInOp(FreeVarOptions opts, TOp op, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInTargets(FreeVarOptions opts, DecisionTreeTarget[] targets, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInTarget(FreeVarOptions opts, DecisionTreeTarget _arg4, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInFlatExprs(FreeVarOptions opts, FSharpList`1<Expr> exprs, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInExprs(FreeVarOptions opts, FSharpList`1<Expr> exprs, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInSlotSig(FreeVarOptions opts, SlotSig _arg5, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars freeInDecisionTree(FreeVarOptions opts, DecisionTree dtree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars freeInExpr(FreeVarOptions opts, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInModuleOrNamespace(FreeVarOptions opts, ModuleOrNamespaceExpr mexpr, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInModuleOrNamespaceBind(FreeVarOptions opts, ModuleOrNamespaceBinding mbind, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInModuleOrNamespaces(FreeVarOptions opts, FSharpList`1<ModuleOrNamespaceExpr> mexprs, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars freeInBindingRhs(FreeVarOptions opts, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars freeInModuleOrNamespace(FreeVarOptions opts, ModuleOrNamespaceExpr mdef);
    internal static Tuple`3<FSharpList`1<FSharpList`1<Val>>, Expr, TType> stripLambda(Expr expr, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<FSharpList`1<Val>>, Expr, int> stripLambdaN(int n, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpList`1<FSharpList`1<Val>>, Expr>> tryStripLambdaN(int n, Expr expr);
    internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Val>>, Expr, TType> stripTopLambda(Expr expr, TType ty);
    internal static Tuple`2<FSharpList`1<FSharpList`1<Val>>, Expr> stripLambda_notypes@4732(Expr e);
    internal static Tuple`3<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Val>>, Expr> stripTopLambdaNoTypes@4740(Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValReprInfo InferArityOfExpr(TcGlobals g, AllowTypeDirectedDetupling allowTypeDirectedDetupling, TType ty, FSharpList`1<FSharpList`1<FSharpList`1<Attrib>>> partialArgAttribsL, FSharpList`1<Attrib> retAttribs, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValReprInfo InferArityOfExprBinding(TcGlobals g, AllowTypeDirectedDetupling allowTypeDirectedDetupling, Val v, Expr expr);
    [CompilerGeneratedAttribute]
internal static TType underlyingTypeOfEnumTy$cont@4788(TcGlobals g, TypeDefMetadata matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType underlyingTypeOfEnumTy(TcGlobals g, TType ty);
    internal static Val setValHasNoArity(Val f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType normalizeEnumTy(TcGlobals g, TType ty);
    internal static StaticOptimizationAnswer checkTypes@4829(TcGlobals g, TType a, TType b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StaticOptimizationAnswer decideStaticOptimizationConstraint(TcGlobals g, StaticOptimization c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StaticOptimizationAnswer DecideStaticOptimizations(TcGlobals g, FSharpList`1<StaticOptimization> cs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticOptimizationExpr(TcGlobals g, FSharpList`1<StaticOptimization> cs, Expr e1, Expr e2, range m);
    internal static ValCopyFlag fixValCopyFlagForQuotations(ValCopyFlag _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val markAsCompGen(ValCopyFlag compgen, Val d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap bindLocalVal(Val v, Val v', Remap tmenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap bindLocalVals(FSharpList`1<Val> vs, FSharpList`1<Val> vs', Remap tmenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap bindTycons(FSharpList`1<Entity> tcs, FSharpList`1<Entity> tcs', Remap tyenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AttribKind remapAttribKind(Remap tmenv, AttribKind k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, Remap> tmenvCopyRemapAndBindTypars(FSharpFunc`2<FSharpList`1<Attrib>, FSharpList`1<Attrib>> remapAttrib, Remap tmenv, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Attrib remapAttrib(TcGlobals g, Remap tmenv, Attrib _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AttribExpr remapAttribExpr(TcGlobals g, Remap tmenv, AttribExpr _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Attrib> remapAttribs(TcGlobals g, Remap tmenv, FSharpList`1<Attrib> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType remapPossibleForallTy(TcGlobals g, Remap tmenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArgReprInfo remapArgData(TcGlobals g, Remap tmenv, ArgReprInfo argInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValReprInfo remapValReprInfo(TcGlobals g, Remap tmenv, ValReprInfo _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val remapValData(TcGlobals g, Remap tmenv, Val d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParentRef remapParentRef(Remap tyenv, ParentRef p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType mapImmediateValsAndTycons(FSharpFunc`2<Entity, Entity> ft, FSharpFunc`2<Val, Val> fv, ModuleOrNamespaceType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val copyVal(ValCopyFlag compgen, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void fixupValData(TcGlobals g, ValCopyFlag compgen, Remap tmenv, Val v2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, Remap> copyAndRemapAndBindVals(TcGlobals g, ValCopyFlag compgen, Remap tmenv, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Remap> copyAndRemapAndBindVal(TcGlobals g, ValCopyFlag compgen, Remap tmenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remapExpr(TcGlobals g, ValCopyFlag compgen, Remap tmenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTreeTarget remapTarget(TcGlobals g, ValCopyFlag compgen, Remap tmenv, DecisionTreeTarget _arg4);
    [CompilerGeneratedAttribute]
internal static Expr func1@1-1(SequencePointInfoForBinding spBind, SequencePointInfoForTarget sp2, range m2, range exprm, DecisionTree dtree', DecisionTreeTarget tg1', TType ty', Expr expr2');
    [CompilerGeneratedAttribute]
internal static Expr func1@1-2(Expr expr, FSharpList`1<TType> tyargs, TOp op, range m, FSharpList`1<Expr> argsFront, Expr argLast, TOp op', FSharpList`1<TType> tinst', FSharpList`1<Expr> argsFront', Expr argLast');
    [CompilerGeneratedAttribute]
internal static Expr func1@1-3(Expr expr, SequencePointInfoForSeq spSeq, range m, Expr expr2, Expr expr1, SequentialOpKind dir, Expr expr1', Expr expr2');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remapLinearExpr(TcGlobals g, ValCopyFlag compgen, Remap tmenv, Expr expr, FSharpFunc`2<Expr, Expr> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StaticOptimization remapConstraint(Remap tyenv, StaticOptimization c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TOp remapOp(Remap tmenv, TOp op);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValUseFlag remapValFlags(Remap tmenv, ValUseFlag x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Expr> remapExprs(TcGlobals g, ValCopyFlag compgen, Remap tmenv, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree remapDecisionTree(TcGlobals g, ValCopyFlag compgen, Remap tmenv, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Binding, Remap> copyAndRemapAndBindBinding(TcGlobals g, ValCopyFlag compgen, Remap tmenv, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, Remap> copyAndRemapAndBindBindings(TcGlobals g, ValCopyFlag compgen, Remap tmenv, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> remapAndRenameBinds(TcGlobals g, ValCopyFlag compgen, Remap tmenvinner, FSharpList`1<Binding> binds, FSharpList`1<Val> vs');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding remapAndRenameBind(TcGlobals g, ValCopyFlag compgen, Remap tmenvinner, Binding _arg5, Val v');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ObjExprMethod remapMethod(TcGlobals g, ValCopyFlag compgen, Remap tmenv, ObjExprMethod _arg6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, FSharpList`1<ObjExprMethod>> remapInterfaceImpl(TcGlobals g, ValCopyFlag compgen, Remap tmenv, TType ty, FSharpList`1<ObjExprMethod> overrides);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdField remapRecdField(TcGlobals g, Remap tmenv, RecdField x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconRecdFields remapRecdFields(TcGlobals g, Remap tmenv, TyconRecdFields x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCase remapUnionCase(TcGlobals g, Remap tmenv, UnionCase x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconUnionData remapUnionCases(TcGlobals g, Remap tmenv, TyconUnionData x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconObjModelData remapFsObjData(TcGlobals g, Remap tmenv, TyconObjModelData x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconRepresentation remapTyconRepr(TcGlobals g, Remap tmenv, TyconRepresentation repr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconAugmentation remapTyconAug(Remap tmenv, TyconAugmentation x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExceptionInfo remapTyconExnInfo(TcGlobals g, Remap tmenv, ExceptionInfo inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValMemberInfo remapMemberInfo(TcGlobals g, range m, FSharpOption`1<ValReprInfo> topValInfo, TType ty, TType ty', Remap tmenv, ValMemberInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceType, Remap> copyAndRemapAndBindModTy(TcGlobals g, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType remapModTy(TcGlobals g, ValCopyFlag _compgen, Remap tmenv, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity renameTycon(TcGlobals g, Remap tyenv, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val renameVal(Remap tmenv, Val x);
    internal static Entity lookupTycon@5361(Remap tmenvinner, TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<Entity>, FSharpList`1<Val>, Remap> copyAndRemapAndBindTyconsAndVals(TcGlobals g, ValCopyFlag compgen, Remap tmenv, FSharpList`1<Entity> tycons, FSharpList`1<Val> vs);
    internal static IEnumerable`1<Entity> allTyconsOfTycon(Entity tycon);
    internal static IEnumerable`1<Entity> allEntitiesOfModDef(ModuleOrNamespaceExpr mdef);
    internal static IEnumerable`1<Val> allValsOfModDef(ModuleOrNamespaceExpr mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceExprWithSig, Remap> remapAndBindModuleOrNamespaceExprWithSig(TcGlobals g, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceExprWithSig _arg7);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceExprWithSig remapModuleOrNamespaceExprWithSig(TcGlobals g, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceExprWithSig _arg8);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceExpr copyAndRemapModDef(TcGlobals g, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceExpr mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceExpr remapAndRenameModDef(TcGlobals g, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceExpr mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceBinding remapAndRenameModBind(TcGlobals g, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType copyModuleOrNamespaceType(TcGlobals g, ValCopyFlag compgen, ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr copyExpr(TcGlobals g, ValCopyFlag compgen, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypedImplFile copyImplFile(TcGlobals g, ValCopyFlag compgen, TypedImplFile e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr instExpr(TcGlobals g, FSharpList`1<Tuple`2<Typar, TType>> tpinst, Expr e);
    [CompilerGeneratedAttribute]
internal static DecisionTreeTarget mapping@1-16(range m, DecisionTreeTarget _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remarkExpr(range m, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ObjExprMethod remarkObjExprMethod(range m, ObjExprMethod _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, FSharpList`1<ObjExprMethod>> remarkInterfaceImpl(range m, TType ty, FSharpList`1<ObjExprMethod> overrides);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Expr> remarkExprs(range m, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree remarkDecisionTree(range m, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> remarkBinds(range m, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding remarkBind(range m, Binding _arg2);
    internal static bool isRecdOrStructFieldDefinitelyMutable(RecdField f);
    internal static bool isUnionCaseDefinitelyMutable(UnionCase uc);
    internal static bool isUnionCaseRefDefinitelyMutable(UnionCaseRef uc);
    internal static bool isRecdOrUnionOrStructTyconRefDefinitelyMutable(EntityRef tcref);
    internal static bool isExnDefinitelyMutable(EntityRef _ecref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnionCaseFieldMutable(TcGlobals g, UnionCaseRef ucref, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isExnFieldMutable(EntityRef ecref, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool useGenuineField(Entity tycon, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ComputeFieldName(Entity tycon, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isQuotedExprTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destQuotedExprTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkQuotedExprTy(TcGlobals g, TType ty);
    internal static TType mkRawQuotedExprTy(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkAnyTupledTy(TcGlobals g, TupInfo tupInfo, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkAnyAnonRecdTy(TcGlobals _g, AnonRecdTypeInfo anonInfo, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkRefTupledTy(TcGlobals g, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkRefTupledVarsTy(TcGlobals g, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkMethodTy(TcGlobals g, FSharpList`1<FSharpList`1<TType>> argtys, TType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkArrayType(TcGlobals g, TType ty);
    internal static TType mkByteArrayTy(TcGlobals g);
    [CompilerGeneratedAttribute]
internal static TType tyOfExpr$cont@5679(TcGlobals g, Expr e, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType tyOfExpr(TcGlobals g, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr primMkApp(Tuple`2<Expr, TType> tupledArg, FSharpList`1<TType> tyargs, FSharpList`1<Expr> argsl, range m);
    internal static bool loop@5729-49(TcGlobals g, TType fty, FSharpList`1<d> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isExpansiveUnderInstantiation(TcGlobals g, TType fty0, FSharpList`1<a> tyargs, FSharpList`1<b> pargs, FSharpList`1<c> argsl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkExprApplAux(TcGlobals g, Expr f, TType fty, FSharpList`1<Expr> argsl, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAppsAux(TcGlobals g, Expr f, TType fty, FSharpList`1<FSharpList`1<TType>> tyargsl, FSharpList`1<Expr> argsl, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkApps(TcGlobals g, Tuple`2<Expr, TType> _arg1, FSharpList`1<FSharpList`1<TType>> tyargsl, FSharpList`1<Expr> argl, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTyAppExpr(range m, Expr f, TType fty, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<int> accTargetsOfDecisionTree(DecisionTree tree, FSharpList`1<int> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree mapTargetsOfDecisionTree(FSharpFunc`2<int, int> f, DecisionTree tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTreeCase mapTargetsOfDecisionTreeCase(FSharpFunc`2<int, int> f, DecisionTreeCase _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, a[]> eliminateDeadTargetsFromMatch(DecisionTree tree, a[] targets);
    internal static FSharpOption`1<int> targetOfSuccessDecisionTree(DecisionTree tree);
    internal static bool decisionTreeHasNonTrivialBindings(DecisionTree tree);
    internal static void accumulateTipsOfDecisionTree@5841(FSharpList`1[] branchesToTargets, FSharpList`1<Binding> accBinds, DecisionTree tree);
    internal static bool isLinearTarget@5856(FSharpList`1<a> bs);
    internal static DecisionTree rebuildDecisionTree@5868(FSharpList`1[] branchesToTargets, FSharpFunc`2<DecisionTreeCase, DecisionTreeCase> rebuildDecisionTreeEdge, DecisionTree tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, DecisionTreeTarget[]> foldLinearBindingTargetsOfMatch(DecisionTree tree, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr simplifyTrivialMatch(SequencePointInfoForBinding spBind, range exprm, range matchm, TType ty, DecisionTree tree, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAndSimplifyMatch(SequencePointInfoForBinding spBind, range exprm, range matchm, TType ty, DecisionTree tree, FSharpList`1<DecisionTreeTarget> targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdOrStructTyconRefAssumedImmutable(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdOrStructTyconRefReadOnly(TcGlobals g, range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdOrStructTyReadOnly(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOf(TcGlobals g, range m, TType ty, Mutates mut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOfImmutableVal(TcGlobals g, range m, ValRef vref, Mutates mut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MustTakeAddressOfVal(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MustTakeAddressOfByrefGet(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOfByrefGet(TcGlobals g, ValRef vref, Mutates mut);
    internal static bool MustTakeAddressOfRecdField(RecdField rfref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOfRecdFieldRef(TcGlobals g, range m, RecdFieldRef rfref, FSharpList`1<TType> tinst, Mutates mut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOfUnionFieldRef(TcGlobals g, range m, UnionCaseRef uref, int cidx, FSharpList`1<TType> tinst, Mutates mut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpOption`1<Tuple`2<Val, Expr>>, Expr, bool, bool> mkExprAddrOfExprAux(TcGlobals g, bool mustTakeAddress, bool useReadonlyForGenericArrayAddress, Mutates mut, Expr expr, FSharpOption`1<ValRef> addrExprVal, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpFunc`2<Expr, Expr>, Expr, bool, bool> mkExprAddrOfExpr(TcGlobals g, bool mustTakeAddress, bool useReadonlyForGenericArrayAddress, Mutates mut, Expr e, FSharpOption`1<ValRef> addrExprVal, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTupleFieldGet(TcGlobals g, TupInfo tupInfo, Expr e, FSharpList`1<TType> tinst, int i, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAnonRecdFieldGet(TcGlobals g, AnonRecdTypeInfo anonInfo, Expr e, FSharpList`1<TType> tinst, int i, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRecdFieldGet(TcGlobals g, Expr e, RecdFieldRef fref, FSharpList`1<TType> tinst, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnionCaseFieldGetUnproven(TcGlobals g, Expr e, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, range m);
    internal static Expr mkArray(TType argty, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IterateRecursiveFixups(TcGlobals g, FSharpOption`1<Val> selfv, FSharpFunc`2<FSharpOption`1<Val>, FSharpFunc`2<Expr, FSharpFunc`2<FSharpFunc`2<Expr, Expr>, FSharpFunc`2<Expr, Unit>>>> rvs, Expr access, FSharpFunc`2<Expr, Expr> set, Expr exprToFix);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyparStaticReq JoinTyparStaticReq(TyparStaticReq r1, TyparStaticReq r2);
    internal static ExprFolder`1<State> ExprFolder0();
    internal static FSharpFunc`2<State, FSharpFunc`2<Expr, State>> FoldExpr(ExprFolder`1<State> folders);
    internal static FSharpFunc`2<State, FSharpFunc`2<TypedImplFile, State>> FoldImplFile(ExprFolder`1<State> folders);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkString(TcGlobals g, range m, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBool(TcGlobals g, range m, bool b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkByte(TcGlobals g, range m, byte b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUInt16(TcGlobals g, range m, ushort b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTrue(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkFalse(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnit(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkInt32(TcGlobals g, range m, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkInt(TcGlobals g, range m, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkZero(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkOne(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTwo(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkMinusOne(TcGlobals g, range m);
    internal static FSharpOption`1<int> destInt32(Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isIDelegateEventType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destIDelegateEventType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIEventType(TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIObservableType(TcGlobals g, TType ty1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIObserverType(TcGlobals g, TType ty1);
    internal static RecdFieldRef mkRefCellContentsRef(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSequential(SequencePointInfoForSeq spSeq, range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCompGenSequential(range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSequentials(SequencePointInfoForSeq spSeq, TcGlobals g, range m, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGetArg0(range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAnyTupled(TcGlobals g, range m, TupInfo tupInfo, FSharpList`1<Expr> es, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefTupled(TcGlobals g, range m, FSharpList`1<Expr> es, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefTupledNoTypes(TcGlobals g, range m, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefTupledVars(TcGlobals g, range m, FSharpList`1<Val> vs);
    internal static Int32[] inversePerm(Int32[] sigma);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T[] permute(Int32[] sigma, T[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsR(int a, int b, FSharpFunc`2<int, bool> pred);
    internal static int liftAllBefore(Int32[] sigma);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Expr>> permuteExprList(Int32[] sigma, FSharpList`1<Expr> exprs, FSharpList`1<TType> ty, FSharpList`1<string> names);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRecordExpr(TcGlobals g, RecordConstructionInfo lnk, EntityRef tcref, FSharpList`1<TType> tinst, FSharpList`1<RecdFieldRef> unsortedRecdFields, FSharpList`1<Expr> unsortedFieldExprs, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAnonRecd(TcGlobals _g, range m, AnonRecdTypeInfo anonInfo, Ident[] unsortedIds, FSharpList`1<Expr> unsortedFieldExprs, FSharpList`1<TType> unsortedArgTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefCell(TcGlobals g, range m, TType ty, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefCellGet(TcGlobals g, range m, TType ty, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefCellSet(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNil(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCons(TcGlobals g, TType ty, Expr h, Expr t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Expr, Binding> mkCompGenLocalAndInvisbleBind(TcGlobals g, string nm, range m, Expr e);
    internal static ILInstr get_box();
    internal static ILInstr get_isinst();
    internal static ILInstr get_unbox();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnbox(TType ty, Expr e, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBox(TType ty, Expr e, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkIsInst(TType ty, Expr e, range m);
    internal static ILMethodSpec mspec_Type_GetTypeFromHandle(TcGlobals g);
    internal static ILMethodSpec mspec_String_Length(TcGlobals g);
    internal static ILMethodSpec mspec_String_Concat2(TcGlobals g);
    internal static ILMethodSpec mspec_String_Concat3(TcGlobals g);
    internal static ILMethodSpec mspec_String_Concat4(TcGlobals g);
    internal static ILMethodSpec mspec_String_Concat_Array(TcGlobals g);
    internal static ILFieldSpec fspec_Missing_Value(TcGlobals g);
    internal static ILMethodSpec mkInitializeArrayMethSpec(TcGlobals g);
    internal static ILInstr mkInvalidCastExnNewobj(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> typedExprForIntrinsic(a _g, range m, IntrinsicValRef _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGetGenericComparer(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGetGenericEREqualityComparer(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGetGenericPEREqualityComparer(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnbox(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnboxFast(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallTypeTest(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallTypeOf(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallTypeDefOf(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallDispose(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeq(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallCreateInstance(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGetQuerySourceAsEnumerable(TcGlobals g, range m, TType ty1, TType ty2, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallNewQuerySource(TcGlobals g, range m, TType ty1, TType ty2, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallCreateEvent(TcGlobals g, range m, TType ty1, TType ty2, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGenericComparisonWithComparerOuter(TcGlobals g, range m, TType ty, Expr comp, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGenericEqualityEROuter(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGenericEqualityWithComparerOuter(TcGlobals g, range m, TType ty, Expr comp, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGenericHashWithComparerOuter(TcGlobals g, range m, TType ty, Expr comp, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallEqualsOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallNotEqualsOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallLessThanOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallLessThanOrEqualsOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGreaterThanOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGreaterThanOrEqualsOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallAdditionOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSubtractionOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallMultiplyOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallDivisionOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallModulusOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallBitwiseAndOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallBitwiseOrOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallBitwiseXorOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallShiftLeftOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallShiftRightOperator(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnaryNegOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnaryNotOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallAdditionChecked(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSubtractionChecked(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallMultiplyChecked(TcGlobals g, range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnaryNegChecked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToByteChecked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToSByteChecked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt16Checked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt16Checked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToIntChecked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt32Checked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt32Checked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt64Checked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt64Checked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToIntPtrChecked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUIntPtrChecked(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToByteOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToSByteOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt16Operator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt16Operator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToIntOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt32Operator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt32Operator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt64Operator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt64Operator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToSingleOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToDoubleOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToIntPtrOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUIntPtrOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToCharOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToEnumOperator(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArrayLength(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArrayGet(TcGlobals g, range m, TType ty, Expr e1, Expr idx1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray2DGet(TcGlobals g, range m, TType ty, Expr e1, Expr idx1, Expr idx2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray3DGet(TcGlobals g, range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr idx3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray4DGet(TcGlobals g, range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr idx3, Expr idx4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArraySet(TcGlobals g, range m, TType ty, Expr e1, Expr idx1, Expr v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray2DSet(TcGlobals g, range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray3DSet(TcGlobals g, range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr idx3, Expr v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray4DSet(TcGlobals g, range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr idx3, Expr idx4, Expr v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallHash(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallBox(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallIsNull(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallIsNotNull(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallRaise(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallNewDecimal(TcGlobals g, range m, Expr e1, Expr e2, Expr e3, Expr e4, Expr e5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallNewFormat(TcGlobals g, range m, TType aty, TType bty, TType cty, TType dty, TType ety, Expr e1);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Expr> TryEliminateDesugaredConstants$cont@6851(TcGlobals g, range m, Const c, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryEliminateDesugaredConstants(TcGlobals g, range m, Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkSeqTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIEnumeratorTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqCollect(TcGlobals g, range m, TType alphaTy, TType betaTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqUsing(TcGlobals g, range m, TType resourceTy, TType elemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqDelay(TcGlobals g, range m, TType elemTy, Expr arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqAppend(TcGlobals g, range m, TType elemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqGenerated(TcGlobals g, range m, TType elemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqFinally(TcGlobals g, range m, TType elemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqOfFunctions(TcGlobals g, range m, TType ty1, TType ty2, Expr arg1, Expr arg2, Expr arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqToArray(TcGlobals g, range m, TType elemTy, Expr arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqToList(TcGlobals g, range m, TType elemTy, Expr arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqMap(TcGlobals g, range m, TType inpElemTy, TType genElemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqSingleton(TcGlobals g, range m, TType ty1, Expr arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqEmpty(TcGlobals g, range m, TType ty1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallDeserializeQuotationFSharp20Plus(TcGlobals g, range m, Expr e1, Expr e2, Expr e3, Expr e4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallDeserializeQuotationFSharp40Plus(TcGlobals g, range m, Expr e1, Expr e2, Expr e3, Expr e4, Expr e5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallCastQuotation(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallLiftValueWithName(TcGlobals g, range m, TType ty, string nm, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallLiftValueWithDefn(TcGlobals g, range m, TType qty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallCheckThis(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallFailInit(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallFailStaticInit(TcGlobals g, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallQuoteToLinqLambdaExpression(TcGlobals g, range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLazyDelayed(TcGlobals g, range m, TType ty, Expr f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLazyForce(TcGlobals g, range m, TType ty, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGetString(TcGlobals g, range m, Expr e1, Expr e2);
    internal static FSharpFunc`2<TcGlobals, FSharpFunc`2<range, FSharpFunc`2<Expr, FSharpFunc`2<Expr, Expr>>>> get_mkGetStringChar();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGetStringLength(TcGlobals g, range m, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticCall_String_Concat2(TcGlobals g, range m, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticCall_String_Concat3(TcGlobals g, range m, Expr arg1, Expr arg2, Expr arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticCall_String_Concat4(TcGlobals g, range m, Expr arg1, Expr arg2, Expr arg3, Expr arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticCall_String_Concat_Array(TcGlobals g, range m, Expr arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkDecr(TcGlobals g, range m, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkIncr(TcGlobals g, range m, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLdlen(TcGlobals g, range m, Expr arre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLdelem(TcGlobals _g, range m, TType ty, Expr arre, Expr idxe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkILAsmCeq(TcGlobals g, range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkILAsmClt(TcGlobals g, range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNull(range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkThrow(range m, TType ty, Expr e);
    internal static FSharpOption`1<Tuple`3<range, TType, Expr>> destThrow(Expr _arg1);
    internal static bool isThrow(Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkReraiseLibCall(TcGlobals g, TType ty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkReraise(range m, TType returnTy);
    internal static string get_tnameCompilationSourceNameAttr();
    internal static string get_tnameCompilationArgumentCountsAttr();
    internal static string get_tnameCompilationMappingAttr();
    internal static string get_tnameSourceConstructFlags();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttrPrim(TcGlobals g, int k, FSharpList`1<int> nums);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttr(TcGlobals g, int kind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttrWithSeqNum(TcGlobals g, int kind, int seqNum);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttrWithVariantNumAndSeqNum(TcGlobals g, int kind, int varNum, int seqNum);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationArgumentCountsAttr(TcGlobals g, FSharpList`1<int> nums);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationSourceNameAttr(TcGlobals g, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttrForQuotationResource(TcGlobals g, string nm, FSharpList`1<ILTypeRef> tys);
    internal static bool isTypeProviderAssemblyAttr(ILAttribute cattr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryDecodeTypeProviderAssemblyAttr(ILGlobals ilg, ILAttribute cattr);
    internal static string get_tname_SignatureDataVersionAttr();
    internal static Tuple`2<FSharpList`1<string>, string> get_tnames_SignatureDataVersionAttr();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkSignatureDataVersionAttr(TcGlobals g, ILVersionInfo version);
    internal static string get_tname_AutoOpenAttr();
    internal static bool IsSignatureDataVersionAttr(ILAttribute cattr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindAutoOpenAttr(ILGlobals ilg, ILAttribute cattr);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tname_InternalsVisibleToAttr();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindInternalsVisibleToAttr(ILGlobals ilg, ILAttribute cattr);
    [CompilerGeneratedAttribute]
internal static bool IsMatchingSignatureDataVersionAttr$cont@7134(ILGlobals ilg, ILVersionInfo version, ILAttribute cattr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsMatchingSignatureDataVersionAttr(ILGlobals ilg, ILVersionInfo version, ILAttribute cattr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilerGeneratedAttr(TcGlobals g, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, FSharpFunc`2<Expr, Expr>> untupledToRefTupled(TcGlobals g, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, Expr> AdjustArityOfLambdaBody(TcGlobals g, int arity, FSharpList`1<Val> vs, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> MultiLambdaToTupledLambda(TcGlobals g, FSharpList`1<Val> vs, Expr body);
    internal static FSharpOption`1<FSharpList`1<Expr>> |RefTuple|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Val, Expr>>, Expr> MultiLambdaToTupledLambdaIfNeeded(TcGlobals g, FSharpList`1<Val> vs, Expr arg, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeApplicationAndBetaReduceAux(TcGlobals g, Expr f, TType fty, FSharpList`1<FSharpList`1<TType>> tyargsl, FSharpList`1<Expr> argsl, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeApplicationAndBetaReduce(TcGlobals g, Expr f, TType fty, FSharpList`1<FSharpList`1<TType>> tyargsl, FSharpList`1<Expr> argl, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Val>> MakeArgsForTopArgs(a _g, range m, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> argtysl, FSharpList`1<Tuple`2<Typar, TType>> tpenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> AdjustValForExpectedArity(TcGlobals g, range m, ValRef vref, ValUseFlag flags, ValReprInfo topValInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<TType>>, TType> stripTupledFunTy(TcGlobals g, TType ty);
    internal static FSharpOption`1<Tuple`4<ValRef, ValUseFlag, FSharpList`1<TType>, range>> |ExprValWithPossibleTypeInst|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCoerceIfNeeded(TcGlobals g, TType tgtTy, TType srcTy, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCompGenLetIn(range m, string nm, TType ty, Expr e, FSharpFunc`2<Tuple`2<Val, Expr>, Expr> f);
    internal static Expr CoerceDetupled@7421(TcGlobals g, FSharpList`1<TType> argTys, FSharpList`1<Expr> detupledArgs, FSharpList`1<TType> actualTys);
    internal static Expr CoerceBoundTuple@7431(TcGlobals g, range appm, Expr tupleVar, FSharpList`1<TType> argTys, FSharpList`1<TType> actualTys);
    internal static Tuple`2<FSharpFunc`2<Expr, Expr>, Expr> CoerceTupled@7442(TcGlobals g, range appm, bool buildingLambdas, FSharpList`1<string> niceNames, Expr argExpr, FSharpList`1<TType> actualTys);
    internal static FSharpFunc`2<a, a> binderBuilder@7577();
    internal static FSharpFunc`2<a, a> lambdaBuilder@7571-1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, FSharpList`1<Expr>>> AdjustPossibleSubsumptionExpr(TcGlobals g, Expr expr, FSharpList`1<Expr> suppliedArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr NormalizeAndAdjustPossibleSubsumptionExprs(TcGlobals g, Expr inputExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr etaExpandTypeLambda(TcGlobals g, range m, FSharpList`1<Typar> tps, Expr tm, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AdjustValToTopVal(Val tmp, ParentRef parent, ValReprInfo valData);
    internal static Expr itemsProj@7662(range m, FSharpList`1<TType> tys, int i, Expr x);
    internal static bool isThrowingTarget@7667(DecisionTreeTarget _arg1);
    internal static DecisionTreeTarget fixup@7680(TType tmpTy, DecisionTreeTarget newTg, DecisionTreeTarget _arg2);
    [CompilerGeneratedAttribute]
internal static Expr LinearizeTopMatchAux$cont@7670(TcGlobals g, ParentRef parent, DecisionTree tree, DecisionTreeTarget[] targets, SequencePointInfoForBinding spBind, range m2, range m, FSharpList`1<DecisionTreeTarget> targetsL, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr LinearizeTopMatchAux(TcGlobals g, ParentRef parent, SequencePointInfoForBinding spBind, range m, DecisionTree tree, DecisionTreeTarget[] targets, range m2, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr LinearizeTopMatch(TcGlobals g, ParentRef parent, Expr _arg1);
    internal static string ticksAndArgCountTextOfTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string typarEnc(a _g, FSharpList`1<Typar> gtpsType, FSharpList`1<Typar> gtpsMethod, Typar typar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string typeEnc(TcGlobals g, FSharpList`1<Typar> gtpsType, FSharpList`1<Typar> gtpsMethod, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string tyargsEnc(TcGlobals g, FSharpList`1<Typar> gtpsType, FSharpList`1<Typar> gtpsMethod, FSharpList`1<TType> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string XmlDocArgsEnc(TcGlobals g, FSharpList`1<Typar> gtpsType, FSharpList`1<Typar> gtpsMethod, FSharpList`1<TType> argTs);
    internal static string buildAccessPath(FSharpOption`1<CompilationPath> cp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string prependPath(string path, string name);
    [CompilerGeneratedAttribute]
internal static Tuple`6<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, string, string, string> XmlDocSigOfVal$cont@7814(TcGlobals g, string path, Val v, ValMemberInfo membInfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string XmlDocSigOfVal(TcGlobals g, string path, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string BuildXmlDocSig(string prefix, FSharpList`1<string> paths);
    internal static FSharpFunc`2<FSharpList`1<string>, string> get_XmlDocSigOfUnionCase();
    internal static FSharpFunc`2<FSharpList`1<string>, string> get_XmlDocSigOfField();
    internal static FSharpFunc`2<FSharpList`1<string>, string> get_XmlDocSigOfProperty();
    internal static FSharpFunc`2<FSharpList`1<string>, string> get_XmlDocSigOfTycon();
    internal static FSharpFunc`2<FSharpList`1<string>, string> get_XmlDocSigOfSubModul();
    internal static string XmlDocSigOfEntity(EntityRef eref);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_enum_CompilationRepresentationAttribute_Static();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_enum_CompilationRepresentationAttribute_Instance();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_enum_CompilationRepresentationAttribute_StaticInstanceMask();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_enum_CompilationRepresentationAttribute_ModuleSuffix();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_enum_CompilationRepresentationAttribute_PermitNull();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasUseNullAsTrueValueAttribute(TcGlobals g, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconHasUseNullAsTrueValueAttribute(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanHaveUseNullAsTrueValueAttribute(TcGlobals _g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsUnionTypeWithNullAsTrueValue(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeNullNever(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeNullIsExtraValue(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeNullIsTrueValue(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeNullNotLiked(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeSatisfiesNullConstraint(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeHasDefaultValue(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<TType>> |SpecialComparableHeadType|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<TType>> |SpecialEquatableHeadType|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Unit> |SpecialNotEquatableHeadType|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canUseTypeTestFast(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canUseUnboxFast(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkIsInstConditional(TcGlobals g, range m, TType tgty, Expr vinpe, Val v, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNullTest(TcGlobals g, range m, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNonNullTest(TcGlobals g, range m, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNonNullCond(TcGlobals g, range m, TType ty, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkIfThen(TcGlobals g, range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ModuleNameIsMangled(TcGlobals g, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CompileAsEvent(TcGlobals g, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberIsCompiledAsInstance(TcGlobals g, EntityRef parent, bool isExtensionMember, ValMemberInfo membInfo, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSealedTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isComInteropTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValSpecIsCompiledAsInstance(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRefIsCompiledAsInstanceMember(TcGlobals g, ValRef vref);
    [CompilerGeneratedAttribute]
internal static Tuple`8<int, bool, bool, bool, bool, bool, bool, Tuple`1<bool>> GetMemberCallInfo$cont@8108(TcGlobals g, ValRef vref, ValUseFlag vFlags, ValMemberInfo membInfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<int, bool, bool, bool, bool, bool, bool, Tuple`1<bool>> GetMemberCallInfo(TcGlobals g, ValRef vref, ValUseFlag vFlags);
    internal static FSharpOption`1<ActivePatternInfo> TryGetActivePatternInfo(ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ActivePatternElemRef.get_Name(ActivePatternElemRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkChoiceTyconRef(TcGlobals g, range m, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkChoiceTy(TcGlobals g, range m, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseRef mkChoiceCaseRef(TcGlobals g, range m, int n, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> ActivePatternInfo.get_Names(ActivePatternInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ActivePatternInfo.ResultType(ActivePatternInfo apinfo, TcGlobals g, range m, FSharpList`1<TType> rtys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ActivePatternInfo.OverallType(ActivePatternInfo apinfo, TcGlobals g, range m, TType dty, FSharpList`1<TType> rtys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool doesActivePatternHaveFreeTypars(TcGlobals g, ValRef v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding rewriteBind(ExprRewritingEnv env, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding rewriteBindStructure(ExprRewritingEnv env, Binding _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr RewriteExpr(ExprRewritingEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> preRewriteExpr(ExprRewritingEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr postRewriteExpr(ExprRewritingEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr rewriteExprStructure(ExprRewritingEnv env, Expr expr);
    [CompilerGeneratedAttribute]
internal static Expr func1@1-4(Expr expr, FSharpList`1<TType> tyargs, TOp op, range m, FSharpList`1<Expr> argsFront, Expr argLast, FSharpList`1<Expr> argsFront', Expr argLast');
    [CompilerGeneratedAttribute]
internal static Expr func1@1-5(TType ty, SequencePointInfoForBinding spBind, SequencePointInfoForTarget sp2, range m2, range exprm, DecisionTree dtree, DecisionTreeTarget tg1', Expr expr2');
    [CompilerGeneratedAttribute]
internal static Expr func1@1-6(range m, Binding bind, Expr bodyExpr');
    [CompilerGeneratedAttribute]
internal static Expr func1@1-7(Expr expr, SequencePointInfoForSeq spSeq, range m, Expr expr2, Expr expr1, SequentialOpKind dir, Expr expr1', Expr expr2');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr rewriteLinearExpr(ExprRewritingEnv env, Expr expr, FSharpFunc`2<Expr, Expr> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Expr> rewriteExprs(ExprRewritingEnv env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree rewriteDecisionTree(ExprRewritingEnv env, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTreeTarget rewriteTarget(ExprRewritingEnv env, DecisionTreeTarget _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<DecisionTreeTarget> rewriteTargets(ExprRewritingEnv env, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ObjExprMethod rewriteObjExprOverride(ExprRewritingEnv env, ObjExprMethod _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, FSharpList`1<ObjExprMethod>> rewriteObjExprInterfaceImpl(ExprRewritingEnv env, TType ty, FSharpList`1<ObjExprMethod> overrides);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceExprWithSig rewriteModuleOrNamespaceExpr(ExprRewritingEnv env, ModuleOrNamespaceExprWithSig x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceExpr rewriteModuleOrNamespaceDef(ExprRewritingEnv env, ModuleOrNamespaceExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceBinding rewriteModuleOrNamespaceBinding(ExprRewritingEnv env, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ModuleOrNamespaceBinding> rewriteModuleOrNamespaceBindings(ExprRewritingEnv env, FSharpList`1<ModuleOrNamespaceBinding> mbinds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypedImplFile RewriteImplFile(ExprRewritingEnv env, TypedImplFile mv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap MakeExportRemapping(CcuThunk viewedCcu, Entity mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity remapEntityDataToNonLocal(TcGlobals g, Remap tmenv, Entity d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity remapTyconToNonLocal(TcGlobals g, Remap tmenv, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val remapValToNonLocal(TcGlobals g, Remap tmenv, Val inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity ApplyExportRemappingToEntity(TcGlobals g, Remap tmenv, Entity x);
    internal static bool isCompiledConstraint(TyparConstraint cx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsGenericValWithGenericContraints(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Entity.HasInterface(Entity tycon, TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Entity.HasOverride(Entity tycon, TcGlobals g, string nm, FSharpList`1<TType> argtys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Entity.HasMember(Entity tycon, TcGlobals g, string nm, FSharpList`1<TType> argtys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EntityRef.HasInterface(EntityRef tcref, TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EntityRef.HasOverride(EntityRef tcref, TcGlobals g, string nm, FSharpList`1<TType> argtys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EntityRef.HasMember(EntityRef tcref, TcGlobals g, string nm, FSharpList`1<TType> argtys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkFastForLoop(TcGlobals g, SequencePointInfoForForLoop spLet, range m, Val idv, Expr start, bool dir, Expr finish, Expr body);
    internal static bool checkExpr@8530(TcGlobals g, FSharpSet`1<long> vrefs, Expr x);
    internal static bool checkDecisionTree@8575(TcGlobals g, FSharpSet`1<long> vrefs, DecisionTree x);
    internal static FSharpFunc`2<DecisionTreeCase, bool> checkDecisionTreeCase@8580(TcGlobals g, FSharpSet`1<long> vrefs);
    internal static FSharpFunc`2<DecisionTreeTarget, bool> checkDecisionTreeTarget@8582(TcGlobals g, FSharpSet`1<long> vrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsSimpleSyntacticConstantExpr(TcGlobals g, Expr inputExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr EvalArithBinOp(FSharpFunc`2<sbyte, FSharpFunc`2<sbyte, sbyte>> opInt8, FSharpFunc`2<short, FSharpFunc`2<short, short>> opInt16, FSharpFunc`2<int, FSharpFunc`2<int, int>> opInt32, FSharpFunc`2<long, FSharpFunc`2<long, long>> opInt64, FSharpFunc`2<byte, FSharpFunc`2<byte, byte>> opUInt8, FSharpFunc`2<ushort, FSharpFunc`2<ushort, ushort>> opUInt16, FSharpFunc`2<UInt32, FSharpFunc`2<UInt32, UInt32>> opUInt32, FSharpFunc`2<ulong, FSharpFunc`2<ulong, ulong>> opUInt64, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr EvalAttribArgExpr(TcGlobals g, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EvaledAttribExprEquality(TcGlobals g, Expr e1, Expr e2);
    internal static FSharpOption`1<ILFieldInit> |ConstToILFieldInit|_|(Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr EvalLiteralExprOrAttribArg(TcGlobals g, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, FSharpOption`1<TType>, ArgReprInfo> GetTypeOfIntrinsicMemberInCompiledForm(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<EntityRef, FSharpList`1<TType>, FSharpList`1<Expr>, range> mkCompiledTuple(TcGlobals g, bool isStruct, FSharpList`1<TType> argtys, FSharpList`1<Expr> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodSpec mkILMethodSpecForTupleItem(TcGlobals _g, ILType ty, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec mkILFieldSpecForTupleItem(ILType ty, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGetTupleItemN(TcGlobals g, range m, int n, ILType ty, bool isStruct, Expr te, TType retty);
    internal static FSharpOption`1<int> |Int32Expr|_|(Expr expr);
    internal static FSharpOption`1<Tuple`2<Expr, Expr>> |TryFinally|_|(Expr expr);
    internal static FSharpOption`1<Tuple`3<Expr, Expr, range>> |WhileLoopForCompiledForEachExpr|_|(Expr expr);
    internal static FSharpOption`1<Tuple`4<Val, Expr, SequencePointInfoForBinding, Expr>> |Let|_|(Expr expr);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`3<Expr, int, Expr>> |RangeInt32Step|_|$cont@8789(TcGlobals g, Expr expr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<Expr, int, Expr>> |RangeInt32Step|_|(TcGlobals g, Expr expr);
    internal static FSharpOption`1<ValRef> |GetEnumeratorCall|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<TType, Expr, Val, Expr, Tuple`6<range, range, SequencePointInfoForForLoop, range, SequencePointInfoForWhileLoop, range>>> |CompiledForEachExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`6<Expr, int, Expr, Val, Expr, Tuple`6<range, range, SequencePointInfoForForLoop, range, SequencePointInfoForWhileLoop, range>>> |CompiledInt32RangeForEachExpr|_|(TcGlobals g, Expr expr);
    [CompilerGeneratedAttribute]
internal static Expr DetectAndOptimizeForExpression$cont@8890-1(TcGlobals g, TType enumerableTy, Expr enumerableExpr, Val elemVar, Expr bodyExpr, SequencePointInfoForWhileLoop spWhileLoop, SequencePointInfoForForLoop spForLoop, range mForLoop, range mEnumExpr, range mBody, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Expr DetectAndOptimizeForExpression$cont@8854(TcGlobals g, Expr expr, Tuple`6<range, range, SequencePointInfoForForLoop, range, SequencePointInfoForWhileLoop, range> ranges, TType enumerableTy, Expr enumerableExpr, Val elemVar, Expr bodyExpr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr DetectAndOptimizeForExpression(TcGlobals g, OptimizeForExpressionOptions option, Expr expr);
    internal static Expr |InnerExprPat|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, Expr> BindUnitVars(TcGlobals g, Tuple`3<FSharpList`1<Val>, FSharpList`1<ArgReprInfo>, Expr> tupledArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isThreadOrContextStatic(TcGlobals g, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnitDelayLambda(TcGlobals g, range m, Expr e);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TastPickle : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_nop;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldarg;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldnull;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ilzero;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_call;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_add;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_sub;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_mul;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_div;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_div_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_rem;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_rem_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_and;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_or;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_xor;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_shl;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_shr;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_shr_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_neg;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_not;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_conv;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_conv_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_conv_ovf;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_conv_ovf_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_callvirt;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldobj;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldstr;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_castclass;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_isinst;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_unbox;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_throw;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldfld;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldflda;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_stfld;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldsfld;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldsflda;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_stsfld;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_stobj;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_box;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_newarr;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldlen;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldelema;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ckfinite;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldtoken;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_add_ovf;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_add_ovf_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_mul_ovf;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_mul_ovf_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_sub_ovf;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_sub_ovf_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ceq;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_cgt;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_cgt_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_clt;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_clt_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldvirtftn;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_localloc;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_rethrow;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_sizeof;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldelem_any;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_stelem_any;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_unbox_any;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldlen_multi;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_initobj;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_initblk;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_cpobj;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_cpblk;
    internal static bool verbose { get; }
    internal static Unit space { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, string> u_encoded_string { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<string>> u_strings { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<int>> u_ints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, FSharpFunc`2<WriterState, Unit>> p_encoded_string { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpFunc`2<WriterState, Unit>> p_strings { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<int>, FSharpFunc`2<WriterState, Unit>> p_ints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Int32[]> u_encoded_pubpath { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Int32[], FSharpFunc`2<WriterState, Unit>> p_encoded_pubpath { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Tuple`2<int, Int32[]>> u_encoded_nleref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Int32[]> p2@336 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<int, Int32[]>, FSharpFunc`2<WriterState, Unit>> p_encoded_nleref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Int32[], FSharpFunc`2<WriterState, Unit>> p2@232-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ILArrayShape, FSharpFunc`2<WriterState, Unit>> p_ILArrayShape { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpOption`1<int>, FSharpFunc`2<WriterState, Unit>> p1@232 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpOption`1<int>, FSharpFunc`2<WriterState, Unit>> p2@232-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, ILArrayShape> u_ILArrayShape { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpOption`1<int>> p1@336-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpOption`1<int>> p2@336-3 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, ILCallingSignature> u_ILCallSig { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, ILInstr>> simple_instrs { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<ILInstr, int> encode_table { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> decoders { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2[] decode_tab { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2[] tab@1257-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2[] arr@1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<UnionCaseRef, FSharpFunc`2<WriterState, Unit>> p_ucref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, EntityRef> u_tcref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, UnionCaseRef> u_ucref { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>, Unit>, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>> patternInput@1363 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>> p_ty2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>, Unit> fill_p_ty2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>> p_ty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<WriterState, Unit>> p_tys { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>> patternInput@1368-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>> p_attribs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_attribs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, TType>, Unit>, FSharpFunc`2<ReaderState, TType>> patternInput@1399-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, TType> u_ty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, TType>, Unit> fill_u_ty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<TType>> u_tys { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>> patternInput@1401-3 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Attrib>> u_attribs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>, Unit> fill_u_attribs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, ValRef> u_vref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<ValRef>> u_vrefs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, Expr>, Unit>, FSharpFunc`2<ReaderState, Expr>> patternInput@1467-4 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Expr> u_expr_fwd { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, Expr>, Unit> fill_u_Expr_hole { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>> patternInput@1468-5 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>> p_expr_fwd { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_Expr_hole { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<WriterState, Unit> p_measure_one { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<TyparConstraint>, FSharpFunc`2<WriterState, Unit>> p_tyar_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<TyparConstraint>> u_tyar_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Typar>, FSharpFunc`2<WriterState, Unit>> p_tyar_specs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Typar>> u_tyar_specs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>> patternInput@1724-6 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>> p_binds { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_binds { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>> patternInput@1725-7 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>> p_targets { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_targets { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>> patternInput@1726-8 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>> p_Exprs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_Exprs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>> patternInput@1727-9 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>> p_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>> patternInput@1728-10 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>> p_Vals { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_Vals { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Binding>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Binding>>> patternInput@1730-11 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Binding>> u_binds { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Binding>>, Unit> fill_u_binds { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, DecisionTreeTarget[]>, Unit>, FSharpFunc`2<ReaderState, DecisionTreeTarget[]>> patternInput@1731-12 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, DecisionTreeTarget[]> u_targets { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, DecisionTreeTarget[]>, Unit> fill_u_targets { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Expr>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Expr>>> patternInput@1732-13 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Expr>> u_Exprs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Expr>>, Unit> fill_u_Exprs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>> patternInput@1733-14 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>> u_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>, Unit> fill_u_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Val>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Val>>> patternInput@1734-15 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Val>> u_Vals { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Val>>, Unit> fill_u_Vals { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Const, FSharpFunc`2<WriterState, Unit>> p_const { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Const> u_const { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>> p_expr { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Expr> u_expr { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<PickledCcuInfo, FSharpFunc`2<WriterState, Unit>> pickleCcuInfo { get; }
    private static TastPickle();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_verbose();
    [CompilerGeneratedAttribute]
internal static void action@1-10(FSharpFunc`2<string, FSharpOption`1<CcuThunk>> loader, CcuThunk reqd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_byte(int b, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_bool(bool b, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void prim_p_int32(int i, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_int32(int n, WriterState st);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Unit get_space();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_space(int n, Unit unitVar1, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_bytes(Byte[] s, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_prim_string(string s, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_int(int c, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_int64(long i, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Tuple`2<T1, T2>, FSharpFunc`2<WriterState, Unit>> p_tup2(FSharpFunc`2<T1, FSharpFunc`2<WriterState, Unit>> p1, FSharpFunc`2<T2, FSharpFunc`2<WriterState, Unit>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Tuple`3<T1, T2, T3>, FSharpFunc`2<WriterState, Unit>> p_tup3(FSharpFunc`2<T1, FSharpFunc`2<WriterState, Unit>> p1, FSharpFunc`2<T2, FSharpFunc`2<WriterState, Unit>> p2, FSharpFunc`2<T3, FSharpFunc`2<WriterState, Unit>> p3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Tuple`4<T1, T2, T3, T4>, FSharpFunc`2<WriterState, Unit>> p_tup4(FSharpFunc`2<T1, FSharpFunc`2<WriterState, Unit>> p1, FSharpFunc`2<T2, FSharpFunc`2<WriterState, Unit>> p2, FSharpFunc`2<T3, FSharpFunc`2<WriterState, Unit>> p3, FSharpFunc`2<T4, FSharpFunc`2<WriterState, Unit>> p4);
    internal static int u_byte(ReaderState st);
    internal static bool u_bool(ReaderState st);
    internal static int prim_u_int32(ReaderState st);
    internal static int u_int32(ReaderState st);
    internal static int u_int(ReaderState st);
    internal static long u_int64(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void u_space(int n, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> u_used_space1(FSharpFunc`2<ReaderState, a> f, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<ReaderState, Tuple`2<T2, T3>> u_tup2(FSharpFunc`2<ReaderState, T2> p1, FSharpFunc`2<ReaderState, T3> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<ReaderState, Tuple`3<T2, T3, T4>> u_tup3(FSharpFunc`2<ReaderState, T2> p1, FSharpFunc`2<ReaderState, T3> p2, FSharpFunc`2<ReaderState, T4> p3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<ReaderState, Tuple`4<T2, T3, T4, T5>> u_tup4(FSharpFunc`2<ReaderState, T2> p1, FSharpFunc`2<ReaderState, T3> p2, FSharpFunc`2<ReaderState, T4> p3, FSharpFunc`2<ReaderState, T5> p4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_osgn_decl(NodeOutTable`2<a, b> outMap, FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> p, b x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b u_osgn_ref(NodeInTable`2<a, b> inMap, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b u_osgn_decl(NodeInTable`2<a, b> inMap, FSharpFunc`2<ReaderState, a> u, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a lookup_uniq(ReaderState st, InputTable`1<a> tbl, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_array_core(FSharpFunc`2<T, FSharpFunc`2<a, Unit>> f, T[] x, a st);
    internal static FSharpFunc`2<T[], FSharpFunc`2<WriterState, Unit>> p_array(FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_list_core(FSharpFunc`2<T, FSharpFunc`2<a, Unit>> f, FSharpList`1<T> xs, a st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_list_ext(FSharpOption`1<FSharpFunc`2<WriterState, Unit>> extraf, FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> f, FSharpList`1<a> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_List(FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>> f, FSharpList`1<T> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_option(FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> f, FSharpOption`1<a> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_lazy_impl(FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> p, a v, WriterState st);
    internal static FSharpFunc`2<Lazy`1<T>, FSharpFunc`2<WriterState, Unit>> p_lazy(FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>> p);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>>> p_hole();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<Arg, FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>>>, Unit>, FSharpFunc`2<Arg, FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>>>> p_hole2();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b[] u_array_core(FSharpFunc`2<a, b> f, int n, a st);
    internal static FSharpFunc`2<ReaderState, T[]> u_array(FSharpFunc`2<ReaderState, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<b> u_list_core(FSharpFunc`2<a, b> f, int n, a st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<a>, FSharpList`1<b>> u_list_ext(FSharpFunc`2<ReaderState, a> extra, FSharpFunc`2<ReaderState, b> f, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> u_list_revi(FSharpFunc`2<ReaderState, FSharpFunc`2<int, a>> f, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> u_option(FSharpFunc`2<ReaderState, a> f, ReaderState st);
    internal static FSharpFunc`2<ReaderState, Lazy`1<T>> u_lazy(FSharpFunc`2<ReaderState, T> u);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, T>, Unit>, FSharpFunc`2<ReaderState, T>> u_hole();
    internal static FSharpFunc`2<ReaderState, string> get_u_encoded_string();
    internal static string u_string(ReaderState st);
    internal static FSharpFunc`2<ReaderState, FSharpList`1<string>> get_u_strings();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<int>> get_u_ints();
    internal static FSharpFunc`2<string, FSharpFunc`2<WriterState, Unit>> get_p_encoded_string();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_string(string s, WriterState st);
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpFunc`2<WriterState, Unit>> get_p_strings();
    internal static FSharpFunc`2<FSharpList`1<int>, FSharpFunc`2<WriterState, Unit>> get_p_ints();
    internal static string u_encoded_ccuref(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PublicPath decode_pubpath(ReaderState st, InputTable`1<string> stringTab, Int32[] a);
    internal static FSharpFunc`2<ReaderState, Int32[]> get_u_encoded_pubpath();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int encode_pubpath(Table`1<string> stringTab, Table`1<Int32[]> pubpathTab, PublicPath _arg1);
    internal static FSharpFunc`2<Int32[], FSharpFunc`2<WriterState, Unit>> get_p_encoded_pubpath();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef decode_nleref(ReaderState st, InputTable`1<CcuThunk> ccuTab, InputTable`1<string> stringTab, int a, Int32[] b);
    internal static FSharpFunc`2<ReaderState, Tuple`2<int, Int32[]>> get_u_encoded_nleref();
    internal static FSharpFunc`2<ReaderState, Int32[]> get_p2@336();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int encode_nleref(Table`1<string> ccuTab, Table`1<string> stringTab, Table`1<Tuple`2<int, Int32[]>> nlerefTab, CcuThunk thisCcu, NonLocalEntityRef nleref);
    internal static FSharpFunc`2<Tuple`2<int, Int32[]>, FSharpFunc`2<WriterState, Unit>> get_p_encoded_nleref();
    internal static FSharpFunc`2<Int32[], FSharpFunc`2<WriterState, Unit>> get_p2@232-1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_nleref(NonLocalEntityRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType decode_simpletyp(ReaderState st, a _ccuTab, b _stringTab, InputTable`1<NonLocalEntityRef> nlerefTab, int a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_simpletyp(NonLocalEntityRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] pickleObjWithDanglingCcus(bool inMem, string file, TcGlobals g, CcuThunk scope, FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>> p, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void check(ILScopeRef ilscope, NodeInTable`2<a, b> inMap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PickledDataWithReferences`1<T> unpickleObjWithDanglingCcus(string file, ILScopeRef viewedScope, FSharpOption`1<ILModuleDef> ilModule, FSharpFunc`2<ReaderState, T> u, Byte[] phase2bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILPublicKey(PublicKey x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILVersion(ILVersionInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILModuleRef(ILModuleRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILAssemblyRef(ILAssemblyRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILScopeRef(ILScopeRef x, WriterState st);
    internal static PublicKey u_ILPublicKey(ReaderState st);
    internal static ILVersionInfo u_ILVersion(ReaderState st);
    internal static ILModuleRef u_ILModuleRef(ReaderState st);
    internal static ILAssemblyRef u_ILAssemblyRef(ReaderState st);
    internal static ILScopeRef u_ILScopeRef(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILHasThis(ILThisConvention x, WriterState st);
    internal static FSharpFunc`2<ILArrayShape, FSharpFunc`2<WriterState, Unit>> get_p_ILArrayShape();
    internal static FSharpFunc`2<FSharpOption`1<int>, FSharpFunc`2<WriterState, Unit>> get_p1@232();
    internal static FSharpFunc`2<FSharpOption`1<int>, FSharpFunc`2<WriterState, Unit>> get_p2@232-2();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILType(ILType ty, WriterState st);
    internal static FSharpFunc`2<WriterState, Unit> p_ILTypes(FSharpList`1<ILType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILBasicCallConv(ILArgConvention x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILCallConv(ILCallingConv _arg1, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILCallSig(ILCallingSignature x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILTypeRef(ILTypeRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILTypeSpec(ILTypeSpec a, WriterState st);
    internal static ILArgConvention u_ILBasicCallConv(ReaderState st);
    internal static ILThisConvention u_ILHasThis(ReaderState st);
    internal static ILCallingConv u_ILCallConv(ReaderState st);
    internal static ILTypeRef u_ILTypeRef(ReaderState st);
    internal static FSharpFunc`2<ReaderState, ILArrayShape> get_u_ILArrayShape();
    internal static FSharpFunc`2<ReaderState, FSharpOption`1<int>> get_p1@336-1();
    internal static FSharpFunc`2<ReaderState, FSharpOption`1<int>> get_p2@336-3();
    internal static ILType u_ILType(ReaderState st);
    internal static FSharpFunc`2<ReaderState, ILCallingSignature> get_u_ILCallSig();
    internal static ILTypeSpec u_ILTypeSpec(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILMethodRef(ILMethodRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILFieldRef(ILFieldRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILMethodSpec(ILMethodSpec x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILFieldSpec(ILFieldSpec x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILBasicType(ILBasicType x, WriterState st);
    internal static ILMethodRef u_ILMethodRef(ReaderState st);
    internal static ILFieldRef u_ILFieldRef(ReaderState st);
    internal static ILMethodSpec u_ILMethodSpec(ReaderState st);
    internal static ILFieldSpec u_ILFieldSpec(ReaderState st);
    internal static ILBasicType u_ILBasicType(ReaderState st);
    internal static ILVolatility u_ILVolatility(ReaderState st);
    internal static ILReadonly u_ILReadonly(ReaderState st);
    internal static FSharpList`1<Tuple`2<int, ILInstr>> get_simple_instrs();
    internal static Dictionary`2<ILInstr, int> get_encode_table();
    internal static FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> get_decoders();
    internal static ILInstr func2@1(ILVolatility tupledArg0, ILFieldSpec tupledArg1);
    internal static ILInstr func2@1-1(ILVolatility tupledArg0, ILFieldSpec tupledArg1);
    internal static FSharpFunc`2[] get_decode_tab();
    internal static FSharpFunc`2[] get_tab@1257-1();
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<ReaderState, ILInstr> initializer@1-5(int n);
    internal static FSharpFunc`2[] get_arr@1();
    internal static void add_instr@1258(int tupledArg_0, FSharpFunc`2<ReaderState, ILInstr> tupledArg_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILInstr(ILInstr x, WriterState st);
    internal static ILInstr u_ILInstr(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpMap`2<a, b>, FSharpFunc`2<WriterState, Unit>> p_Map(FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> pk, FSharpFunc`2<b, FSharpFunc`2<WriterState, Unit>> pv);
    internal static FSharpFunc`2<FSharpMap`2<string, T>, FSharpFunc`2<WriterState, Unit>> p_namemap(FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<ReaderState, FSharpMap`2<a, b>> u_Map(FSharpFunc`2<ReaderState, a> uk, FSharpFunc`2<ReaderState, b> uv);
    internal static FSharpFunc`2<ReaderState, FSharpMap`2<string, T>> u_namemap(FSharpFunc`2<ReaderState, T> u);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_pos(pos x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_range(range x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ident(Ident x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_xmldoc(XmlDoc _arg1, WriterState st);
    internal static range u_range(ReaderState st);
    internal static Ident u_ident(ReaderState st);
    internal static XmlDoc u_xmldoc(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<WriterState, Unit> p_local_item_ref(string ctxt, NodeOutTable`2<a, b> tab, b st);
    internal static FSharpFunc`2<EntityRef, FSharpFunc`2<WriterState, Unit>> p_tcref(string ctxt);
    internal static FSharpFunc`2<UnionCaseRef, FSharpFunc`2<WriterState, Unit>> get_p_ucref();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_rfref(RecdFieldRef _arg1, WriterState st);
    internal static FSharpFunc`2<ReaderState, EntityRef> get_u_tcref();
    internal static FSharpFunc`2<ReaderState, UnionCaseRef> get_u_ucref();
    internal static RecdFieldRef u_rfref(ReaderState st);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>, Unit>, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>> get_patternInput@1363();
    internal static FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>> get_p_ty2();
    internal static FSharpFunc`2<FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>, Unit> get_fill_p_ty2();
    internal static FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>> get_p_ty();
    internal static FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<WriterState, Unit>> get_p_tys();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1368-1();
    internal static FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>> get_p_attribs();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_attribs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkForInRefStructThisArg(WriterState st, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_nonlocal_val_ref(NonLocalValOrMemberRef nlv, WriterState st);
    internal static FSharpFunc`2<ValRef, FSharpFunc`2<WriterState, Unit>> p_vref(string ctxt);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, TType>, Unit>, FSharpFunc`2<ReaderState, TType>> get_patternInput@1399-2();
    internal static FSharpFunc`2<ReaderState, TType> get_u_ty();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, TType>, Unit> get_fill_u_ty();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<TType>> get_u_tys();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>> get_patternInput@1401-3();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Attrib>> get_u_attribs();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>, Unit> get_fill_u_attribs();
    internal static NonLocalValOrMemberRef u_nonlocal_val_ref(ReaderState st);
    internal static FSharpFunc`2<ReaderState, ValRef> get_u_vref();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<ValRef>> get_u_vrefs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_member_kind(MemberKind x, WriterState st);
    internal static TyparKind u_kind(ReaderState st);
    internal static MemberKind u_member_kind(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_MemberFlags(MemberFlags x, WriterState st);
    internal static MemberFlags u_MemberFlags(ReaderState st);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, Expr>, Unit>, FSharpFunc`2<ReaderState, Expr>> get_patternInput@1467-4();
    internal static FSharpFunc`2<ReaderState, Expr> get_u_expr_fwd();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, Expr>, Unit> get_fill_u_Expr_hole();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1468-5();
    internal static FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>> get_p_expr_fwd();
    internal static FSharpFunc`2<FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_Expr_hole();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_anonInfo_data(AnonRecdTypeInfo anonInfo, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_trait_sln(TraitConstraintSln sln, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_trait(TraitConstraintInfo _arg1, WriterState st);
    internal static AnonRecdTypeInfo u_anonInfo_data(ReaderState st);
    internal static TraitConstraintSln u_trait_sln(ReaderState st);
    internal static TraitConstraintInfo u_trait(ReaderState st);
    internal static FSharpFunc`2<WriterState, Unit> get_p_measure_one();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_measure_varcon(Measure unt, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_measure_pospower(Measure unt, int n, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_measure_intpower(Measure unt, int n, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_measure_power(Measure unt, Rational q, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_normalized_measure(Measure unt, WriterState st);
    internal static Rational u_rational(ReaderState st);
    internal static Measure u_measure_expr(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tyar_constraint(TyparConstraint x, WriterState st);
    internal static FSharpFunc`2<FSharpList`1<TyparConstraint>, FSharpFunc`2<WriterState, Unit>> get_p_tyar_constraints();
    internal static FSharpFunc`2<int, TyparConstraint> u_tyar_constraint(ReaderState st);
    internal static FSharpFunc`2<ReaderState, FSharpList`1<TyparConstraint>> get_u_tyar_constraints();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tyar_spec_data(Typar x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tyar_spec(Typar x, WriterState st);
    internal static FSharpFunc`2<FSharpList`1<Typar>, FSharpFunc`2<WriterState, Unit>> get_p_tyar_specs();
    internal static Typar u_tyar_spec_data(ReaderState st);
    internal static Typar u_tyar_spec(ReaderState st);
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Typar>> get_u_tyar_specs();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1724-6();
    internal static FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>> get_p_binds();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_binds();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>> get_patternInput@1725-7();
    internal static FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>> get_p_targets();
    internal static FSharpFunc`2<FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_targets();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1726-8();
    internal static FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>> get_p_Exprs();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_Exprs();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1727-9();
    internal static FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>> get_p_constraints();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_constraints();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1728-10();
    internal static FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>> get_p_Vals();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_Vals();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Binding>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Binding>>> get_patternInput@1730-11();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Binding>> get_u_binds();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Binding>>, Unit> get_fill_u_binds();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, DecisionTreeTarget[]>, Unit>, FSharpFunc`2<ReaderState, DecisionTreeTarget[]>> get_patternInput@1731-12();
    internal static FSharpFunc`2<ReaderState, DecisionTreeTarget[]> get_u_targets();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, DecisionTreeTarget[]>, Unit> get_fill_u_targets();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Expr>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Expr>>> get_patternInput@1732-13();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Expr>> get_u_Exprs();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Expr>>, Unit> get_fill_u_Exprs();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>> get_patternInput@1733-14();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>> get_u_constraints();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>, Unit> get_fill_u_constraints();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Val>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Val>>> get_patternInput@1734-15();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Val>> get_u_Vals();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Val>>, Unit> get_fill_u_Vals();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ArgReprInfo(ArgReprInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_TyparReprInfo(TyparReprInfo _arg1, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ValReprInfo(ValReprInfo _arg1, WriterState st);
    internal static ArgReprInfo u_ArgReprInfo(ReaderState st);
    internal static ValReprInfo u_ValReprInfo(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ranges(FSharpOption`1<Tuple`2<range, range>> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_istype(ModuleOrNamespaceKind x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_cpath(CompilationPath _arg1, WriterState st);
    internal static FSharpOption`1<Tuple`2<range, range>> u_ranges(ReaderState st);
    internal static ModuleOrNamespaceKind u_istype(ReaderState st);
    internal static CompilationPath u_cpath(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool p_tycon_repr(TyconRepresentation x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tycon_objmodel_data(TyconObjModelData x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_attribs_ext(FSharpOption`1<FSharpFunc`2<WriterState, Unit>> f, FSharpList`1<Attrib> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_unioncase_spec(UnionCase x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_exnc_repr(ExceptionInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_access(Accessibility _arg1, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_recdfield_spec(RecdField x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_rfield_table(TyconRecdFields x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_entity_spec_data(Entity x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tcaug(TyconAugmentation p, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_entity_spec(Entity x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_parentref(ParentRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_attribkind(AttribKind x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_attrib(Attrib _arg2, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_attrib_expr(AttribExpr _arg3, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_attrib_arg(AttribNamedArg _arg4, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_member_info(ValMemberInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tycon_objmodel_kind(TyconObjModelKind x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_vrefFlags(ValUseFlag x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ValData(Val x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_Val(Val x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_modul_typ(ModuleOrNamespaceType x, WriterState st);
    internal static Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef> find@2024(ILTypeRef iltref, FSharpList`1<ILTypeDef> acc, FSharpList`1<string> enclosingTypeNames, ILTypeDefs tdefs);
    internal static FSharpFunc`2<bool, TyconRepresentation> u_tycon_repr(ReaderState st);
    internal static TyconObjModelData u_tycon_objmodel_data(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<a>, FSharpList`1<Attrib>> u_attribs_ext(FSharpFunc`2<ReaderState, a> extraf, ReaderState st);
    internal static UnionCase u_unioncase_spec(ReaderState st);
    internal static ExceptionInfo u_exnc_repr(ReaderState st);
    internal static Accessibility u_access(ReaderState st);
    internal static RecdField u_recdfield_spec(ReaderState st);
    internal static TyconRecdFields u_rfield_table(ReaderState st);
    internal static Entity u_entity_spec_data(ReaderState st);
    internal static TyconAugmentation u_tcaug(ReaderState st);
    internal static Entity u_entity_spec(ReaderState st);
    internal static ParentRef u_parentref(ReaderState st);
    internal static AttribKind u_attribkind(ReaderState st);
    internal static Attrib u_attrib(ReaderState st);
    internal static AttribExpr u_attrib_expr(ReaderState st);
    internal static AttribNamedArg u_attrib_arg(ReaderState st);
    internal static ValMemberInfo u_member_info(ReaderState st);
    internal static TyconObjModelKind u_tycon_objmodel_kind(ReaderState st);
    internal static ValUseFlag u_vrefFlags(ReaderState st);
    internal static Val u_ValData(ReaderState st);
    internal static Val u_Val(ReaderState st);
    internal static ModuleOrNamespaceType u_modul_typ(ReaderState st);
    internal static FSharpFunc`2<Const, FSharpFunc`2<WriterState, Unit>> get_p_const();
    internal static FSharpFunc`2<ReaderState, Const> get_u_const();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_dtree(DecisionTree x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_dtree_case(DecisionTreeCase _arg5, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_dtree_discrim(DecisionTreeTest x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_target(DecisionTreeTarget _arg6, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_bind(Binding _arg7, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_lval_op_kind(LValueOperation x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_recdInfo(RecordConstructionInfo x, WriterState st);
    internal static DecisionTree u_dtree(ReaderState st);
    internal static DecisionTreeCase u_dtree_case(ReaderState st);
    internal static DecisionTreeTest u_dtree_discrim(ReaderState st);
    internal static DecisionTreeTarget u_target(ReaderState st);
    internal static Binding u_bind(ReaderState st);
    internal static LValueOperation u_lval_op_kind(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_op(TOp x, WriterState st);
    internal static TOp u_op(ReaderState st);
    internal static FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>> get_p_expr();
    internal static FSharpFunc`2<ReaderState, Expr> get_u_expr();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_static_optimization_constraint(StaticOptimization x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_slotparam(SlotParam _arg8, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_slotsig(SlotSig _arg9, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_method(ObjExprMethod _arg10, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_methods(FSharpList`1<ObjExprMethod> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_intf(TType x_0, FSharpList`1<ObjExprMethod> x_1, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_intfs(FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> x, WriterState st);
    internal static StaticOptimization u_static_optimization_constraint(ReaderState st);
    internal static SlotParam u_slotparam(ReaderState st);
    internal static SlotSig u_slotsig(ReaderState st);
    internal static ObjExprMethod u_method(ReaderState st);
    internal static FSharpList`1<ObjExprMethod> u_methods(ReaderState st);
    internal static Tuple`2<TType, FSharpList`1<ObjExprMethod>> u_intf(ReaderState st);
    internal static FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> u_intfs(ReaderState st);
    internal static FSharpFunc`2<PickledCcuInfo, FSharpFunc`2<WriterState, Unit>> get_pickleCcuInfo();
    internal static PickledCcuInfo unpickleCcuInfo(ReaderState st);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TcGlobals : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerNonUserCodeAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggableAttribute_DebuggingModes;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerHiddenAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerDisplayAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerTypeProxyAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerStepThroughAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerBrowsableAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerBrowsableState;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_StringBuilder;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_IComparable;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Exception;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Missing;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Activator;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_SerializationInfo;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_StreamingContext;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_SecurityPermissionAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Delegate;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_ValueType;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Enum;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Array;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_RuntimeArgumentHandle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_RuntimeTypeHandle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_RuntimeMethodHandle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_RuntimeFieldHandle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_CompilerGeneratedAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggableAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_AsyncCallback;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_IAsyncResult;
    internal static string DummyFileNameForRangesWithoutASpecificLocation { get; }
    [CompilationMappingAttribute("9")]
internal static range envRange { get; }
    private static TcGlobals();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_DummyFileNameForRangesWithoutASpecificLocation();
    internal static range get_envRange();
    internal static ValRef ValRefForIntrinsic(IntrinsicValRef _arg1);
    internal static TType mkNonGenericTy(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkNonLocalTyconRef2(CcuThunk ccu, String[] path, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mk_MFCore_tcref(CcuThunk ccu, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mk_MFQuotations_tcref(CcuThunk ccu, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mk_MFLinq_tcref(CcuThunk ccu, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mk_MFCollections_tcref(CcuThunk ccu, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mk_MFCompilerServices_tcref(CcuThunk ccu, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mk_MFRuntimeHelpers_tcref(CcuThunk ccu, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mk_MFControl_tcref(CcuThunk ccu, string n);
    [CompilerGeneratedAttribute]
internal static EntityRef initializer@1-4(TcGlobals this, int idx);
    internal static Tuple`3<string, EntityRef, FSharpFunc`2<FSharpList`1<TType>, TType>> mapping@1-14(TcGlobals this, FSharpList`1<string> sys, string tupledArg0, EntityRef tupledArg1);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<string, string> clo0@243-1491(TcGlobals this, IEnumerable`1<string> path);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<string, string> clo0@259-1492(TcGlobals this, IEnumerable`1<string> path);
}
[DefaultMemberAttribute("Item")]
[CompilationMappingAttribute("3")]
public interface FSharp.Compiler.Text.ISourceText {
    public char Item { get; }
    public int Length { get; }
    public abstract virtual char get_Item(int );
    public abstract virtual string GetLineString(int lineIndex);
    public abstract virtual int GetLineCount();
    public abstract virtual Tuple`2<int, int> GetLastCharacterPosition();
    public abstract virtual string GetSubTextString(int start, int length);
    public abstract virtual bool SubTextEquals(string target, int startIndex);
    public abstract virtual int get_Length();
    public abstract virtual bool ContentEquals(ISourceText sourceText);
    public abstract virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Text.SourceText : object {
    public static ISourceText ofString(string str);
}
[DefaultMemberAttribute("Item")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Text.StringText : object {
    internal string str;
    internal Lazy`1<String[]> getLines@46;
    internal string String { get; }
    public StringText(string str);
    internal string get_String();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private virtual override char FSharp-Compiler-Text-ISourceText-get_Item(int index);
    private virtual override Tuple`2<int, int> FSharp-Compiler-Text-ISourceText-GetLastCharacterPosition();
    private virtual override string FSharp-Compiler-Text-ISourceText-GetLineString(int lineIndex);
    private virtual override int FSharp-Compiler-Text-ISourceText-GetLineCount();
    private virtual override string FSharp-Compiler-Text-ISourceText-GetSubTextString(int start, int length);
    private virtual override bool FSharp-Compiler-Text-ISourceText-SubTextEquals(string target, int startIndex);
    private virtual override int FSharp-Compiler-Text-ISourceText-get_Length();
    private virtual override bool FSharp-Compiler-Text-ISourceText-ContentEquals(ISourceText sourceText);
    private virtual override void FSharp-Compiler-Text-ISourceText-CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    [CompilerGeneratedAttribute]
internal String[] getLines(string str);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.TypeCheckAccumulator : object {
    [DebuggerBrowsableAttribute("0")]
internal TcState tcState@;
    [DebuggerBrowsableAttribute("0")]
internal TcImports tcImports@;
    [DebuggerBrowsableAttribute("0")]
internal TcGlobals tcGlobals@;
    [DebuggerBrowsableAttribute("0")]
internal TcConfig tcConfig@;
    [DebuggerBrowsableAttribute("0")]
internal TcEnv tcEnvAtEndOfFile@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<TcResolutions> tcResolutionsRev@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<TcSymbolUses> tcSymbolUsesRev@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<OpenDeclaration[]> tcOpenDeclarationsRev@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<TopAttribs> topAttribs@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<TypedImplFile> latestImplFile@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<ModuleOrNamespaceType> latestCcuSigForFile@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> tcDependencyFiles@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> tcModuleNamesDict@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2[]> tcErrorsRev@;
    [CompilationMappingAttribute("4", "0")]
internal TcState tcState { get; }
    [CompilationMappingAttribute("4", "1")]
internal TcImports tcImports { get; }
    [CompilationMappingAttribute("4", "2")]
internal TcGlobals tcGlobals { get; }
    [CompilationMappingAttribute("4", "3")]
internal TcConfig tcConfig { get; }
    [CompilationMappingAttribute("4", "4")]
internal TcEnv tcEnvAtEndOfFile { get; }
    [CompilationMappingAttribute("4", "5")]
internal FSharpList`1<TcResolutions> tcResolutionsRev { get; }
    [CompilationMappingAttribute("4", "6")]
internal FSharpList`1<TcSymbolUses> tcSymbolUsesRev { get; }
    [CompilationMappingAttribute("4", "7")]
internal FSharpList`1<OpenDeclaration[]> tcOpenDeclarationsRev { get; }
    [CompilationMappingAttribute("4", "8")]
internal FSharpOption`1<TopAttribs> topAttribs { get; }
    [CompilationMappingAttribute("4", "9")]
internal FSharpOption`1<TypedImplFile> latestImplFile { get; }
    [CompilationMappingAttribute("4", "10")]
internal FSharpOption`1<ModuleOrNamespaceType> latestCcuSigForFile { get; }
    [CompilationMappingAttribute("4", "11")]
internal FSharpList`1<string> tcDependencyFiles { get; }
    [CompilationMappingAttribute("4", "12")]
internal FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> tcModuleNamesDict { get; }
    [CompilationMappingAttribute("4", "13")]
internal FSharpList`1<Tuple`2[]> tcErrorsRev { get; }
    internal TypeCheckAccumulator(TcState tcState, TcImports tcImports, TcGlobals tcGlobals, TcConfig tcConfig, TcEnv tcEnvAtEndOfFile, FSharpList`1<TcResolutions> tcResolutionsRev, FSharpList`1<TcSymbolUses> tcSymbolUsesRev, FSharpList`1<OpenDeclaration[]> tcOpenDeclarationsRev, FSharpOption`1<TopAttribs> topAttribs, FSharpOption`1<TypedImplFile> latestImplFile, FSharpOption`1<ModuleOrNamespaceType> latestCcuSigForFile, FSharpList`1<string> tcDependencyFiles, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> tcModuleNamesDict, FSharpList`1<Tuple`2[]> tcErrorsRev);
    internal TcState get_tcState();
    internal TcImports get_tcImports();
    internal TcGlobals get_tcGlobals();
    internal TcConfig get_tcConfig();
    internal TcEnv get_tcEnvAtEndOfFile();
    internal FSharpList`1<TcResolutions> get_tcResolutionsRev();
    internal FSharpList`1<TcSymbolUses> get_tcSymbolUsesRev();
    internal FSharpList`1<OpenDeclaration[]> get_tcOpenDeclarationsRev();
    internal FSharpOption`1<TopAttribs> get_topAttribs();
    internal FSharpOption`1<TypedImplFile> get_latestImplFile();
    internal FSharpOption`1<ModuleOrNamespaceType> get_latestCcuSigForFile();
    internal FSharpList`1<string> get_tcDependencyFiles();
    internal FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> get_tcModuleNamesDict();
    internal FSharpList`1<Tuple`2[]> get_tcErrorsRev();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TypeChecker : object {
    [CompilationMappingAttribute("9")]
internal static ExplicitTyparInfo permitInferTypars { get; }
    [CompilationMappingAttribute("9")]
internal static ExplicitTyparInfo dontInferTypars { get; }
    [CompilationMappingAttribute("9")]
internal static ArgAndRetAttribs noArgOrRetAttribs { get; }
    [CompilationMappingAttribute("9")]
internal static SyntacticUnscopedTyparEnv emptyUnscopedTyparEnv { get; }
    [CompilationMappingAttribute("9")]
internal static ContainerInfo ExprContainerInfo { get; }
    [CompilationMappingAttribute("9")]
internal static TopAttribs EmptyTopAttrs { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pattern mkNilListPat(TcGlobals g, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pattern mkConsListPat(TcGlobals g, TType ty, Pattern ph, Pattern pt);
    internal static TcEnv emptyTcEnv(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv EnterFamilyRegion(EntityRef tcref, TcEnv env);
    internal static TcEnv ExitFamilyRegion(TcEnv env);
    internal static bool AreWithinCtorShape(TcEnv env);
    internal static int GetCtorShapeCounter(TcEnv env);
    internal static RecordConstructionInfo GetRecdInfo(TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AdjustCtorShapeCounter(FSharpFunc`2<int, int> f, TcEnv env);
    internal static TcEnv ExitCtorShapeRegion(TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<UngeneralizableItem> addFreeItemOfTy(TType ty, FSharpList`1<UngeneralizableItem> eUngeneralizableItems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<UngeneralizableItem> addFreeItemOfModuleTy(ModuleOrNamespaceType mtyp, FSharpList`1<UngeneralizableItem> eUngeneralizableItems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddValMapToNameEnv(FSharpMap`2<string, Val> vs, NameResolutionEnv nenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddValListToNameEnv(FSharpList`1<Val> vs, NameResolutionEnv nenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv addInternalsAccessibility(TcEnv env, CcuThunk ccu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalValPrimitive(Val v, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalValMap(TcResultsSink tcSink, range scopem, FSharpMap`2<string, Val> vals, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalVals(TcResultsSink tcSink, range scopem, FSharpList`1<Val> vals, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalVal(TcResultsSink tcSink, range scopem, Val v, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalExnDefnAndReport(TcResultsSink tcSink, range scopem, TcEnv env, Entity exnc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalTyconRefs(bool ownDefinition, TcGlobals g, ImportMap amap, range m, FSharpList`1<EntityRef> tcrefs, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalTycons(TcGlobals g, ImportMap amap, range m, FSharpList`1<Entity> tycons, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalTyconsAndReport(TcResultsSink tcSink, range scopem, TcGlobals g, ImportMap amap, range m, FSharpList`1<Entity> tycons, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv OpenModulesOrNamespaces(TcResultsSink tcSink, TcGlobals g, ImportMap amap, range scopem, bool root, TcEnv env, FSharpList`1<EntityRef> mvvs, OpenDeclaration openDeclaration);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddRootModuleOrNamespaceRefs(TcGlobals g, ImportMap amap, range m, TcEnv env, FSharpList`1<EntityRef> modrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddNonLocalCcu(TcGlobals g, ImportMap amap, range scopem, TcEnv env, string assemblyName, CcuThunk ccu, FSharpList`1<string> internalsVisibleToAttributes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalRootModuleOrNamespace(TcResultsSink tcSink, TcGlobals g, ImportMap amap, range scopem, TcEnv env, ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddModuleAbbreviationAndReport(TcResultsSink tcSink, range scopem, Ident id, FSharpList`1<EntityRef> modrefs, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalSubModule(TcGlobals g, ImportMap amap, range m, TcEnv env, Entity modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalSubModuleAndReport(TcResultsSink tcSink, range scopem, TcGlobals g, ImportMap amap, range m, TcEnv env, Entity modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddDeclaredTypars(CheckForDuplicateTyparFlag check, FSharpList`1<Typar> typars, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UnifyTypes(cenv cenv, TcEnv env, range m, TType actualTy, TType expectedTy);
    internal static Tuple`2<TcEnv, FSharpRef`1<ModuleOrNamespaceType>> MakeInitialEnv(TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv MakeInnerEnvWithAcc(TcEnv env, Ident nm, FSharpRef`1<ModuleOrNamespaceType> mtypeAcc, ModuleOrNamespaceKind modKind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TcEnv, FSharpRef`1<ModuleOrNamespaceType>> MakeInnerEnv(TcEnv env, Ident nm, ModuleOrNamespaceKind modKind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv MakeInnerEnvForTyconRef(TcEnv env, EntityRef tcref, bool isExtrinsicExtension);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv MakeInnerEnvForMember(TcEnv env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv LocateEnv(CcuThunk ccu, TcEnv env, FSharpList`1<Ident> enclosingNamespacePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceType, FSharpList`1<Entity>> BuildRootModuleType(FSharpList`1<Ident> enclosingNamespacePath, CompilationPath cpath, ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceExpr BuildRootModuleExpr(FSharpList`1<Ident> enclosingNamespacePath, CompilationPath cpath, ModuleOrNamespaceExpr mexpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Ident, FSharpList`1<Ident>>> TryStripPrefixPath(TcGlobals g, FSharpList`1<Ident> enclosingNamespacePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv ImplicitlyOpenOwnNamespace(TcResultsSink tcSink, TcGlobals g, ImportMap amap, range scopem, FSharpList`1<Ident> enclosingNamespacePath, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv ShrinkContext(TcEnv env, range oldRange, range newRange);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> UnifyRefTupleType(ContextInfo contextInfo, cenv cenv, DisplayEnv denv, range m, TType ty, FSharpList`1<a> ps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TupInfo, FSharpList`1<TType>> UnifyTupleTypeAndInferCharacteristics(ContextInfo contextInfo, cenv cenv, DisplayEnv denv, range m, TType knownTy, bool isExplicitStruct, FSharpList`1<a> ps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<AnonRecdTypeInfo, FSharpList`1<TType>> UnifyAnonRecdTypeAndInferCharacteristics(ContextInfo contextInfo, cenv cenv, DisplayEnv denv, range m, TType ty, bool isExplicitStruct, Ident[] unsortedNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Tuple`2<TType, TType>> UnifyFunctionTypeUndoIfFailed(cenv cenv, DisplayEnv denv, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, TType> UnifyFunctionType(FSharpOption`1<range> extraInfo, cenv cenv, DisplayEnv denv, range mFunExpr, TType ty);
    [CompilerGeneratedAttribute]
internal static Exception checkExpr$cont@784(DisplayEnv denv, TType ty, range m, FSharpList`1<Expr> exprs, Unit unitVar);
    internal static Exception checkExpr@781-2(DisplayEnv denv, TType ty, range m, Expr expr);
    internal static Exception extractNext@811(DisplayEnv denv, TType ty, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception ReportImplicitlyIgnoredBoolExpression(DisplayEnv denv, range m, TType ty, Expr expr);
    internal static void reportImplicitlyDiscardError@828(cenv cenv, range m, TType ty, Expr expr, DisplayEnv denv, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static bool UnifyUnitType$cont@823(cenv cenv, TcEnv env, range m, TType ty, Expr expr, DisplayEnv denv, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool UnifyUnitType(cenv cenv, TcEnv env, range m, TType ty, Expr expr);
    internal static void callSink@861-2(TcResultsSink tcSink, TcEnv env, range mObjTy, Item origItem, Item tupledArg0, FSharpList`1<Tuple`2<Typar, TType>> tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AfterResolution ForNewConstructors(TcResultsSink tcSink, TcEnv env, range mObjTy, string methodName, FSharpList`1<MethInfo> meths);
    internal static Rational TcSynRationalConst(SynRationalConst c);
    internal static Measure tcMeasure@882(cenv cenv, range m, TcEnv env, SynMeasure ms);
    internal static void unifyMeasureArg@905(cenv cenv, TType ty, range m, TcEnv env, bool iszero, EntityRef tcr, SynConst c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Const TcConst(cenv cenv, TType ty, range m, TcEnv env, SynConst c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Const TcFieldInit(range _m, ILFieldInit lit);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynValInfo AdjustValSynInfoInSignature(TcGlobals g, TType ty, SynValInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArgReprInfo TranslateTopArgSynInfo(bool isArg, range m, FSharpFunc`2<FSharpList`1<SynAttribute>, FSharpList`1<Attrib>> tcAttributes, SynArgInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PartialValReprInfo TranslateTopValSynInfo(range m, FSharpFunc`2<AttributeTargets, FSharpFunc`2<FSharpList`1<SynAttribute>, FSharpList`1<Attrib>>> tcAttributes, SynValInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValReprInfo TranslatePartialArity(FSharpList`1<Typar> tps, PartialValReprInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ComputeLogicalName(Ident id, MemberFlags memberFlags);
    [CompilerGeneratedAttribute]
internal static void MakeMemberDataAndMangledNameForMemberVal$cont@1053(SynValInfo valSynData, Ident id, Unit unitVar);
    internal static ValMemberInfoTransient MakeMemberDataAndMangledNameForMemberVal(TcGlobals g, EntityRef tcref, bool isExtrinsic, FSharpList`1<Attrib> attrs, FSharpList`1<TType> optImplSlotTys, MemberFlags memberFlags, SynValInfo valSynData, Ident id, bool isCompGen);
    internal static ExplicitTyparInfo get_permitInferTypars();
    internal static ExplicitTyparInfo get_dontInferTypars();
    internal static ArgAndRetAttribs get_noArgOrRetAttribs();
    [CompilerGeneratedAttribute]
internal static AttributeTargets AllowedAttribTargets$cont@1136(FSharpOption`1<MemberFlags> memberFlagsOpt, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UpdateAccModuleOrNamespaceType(cenv cenv, TcEnv env, FSharpFunc`2<bool, FSharpFunc`2<ModuleOrNamespaceType, ModuleOrNamespaceType>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishModuleDefn(cenv cenv, TcEnv env, Entity mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishTypeDefn(cenv cenv, TcEnv env, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishValueDefnPrim(cenv cenv, TcEnv env, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishValueDefn(cenv cenv, TcEnv env, DeclKind declKind, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> CombineVisibilityAttribs(FSharpOption`1<a> vis1, FSharpOption`1<a> vis2, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Accessibility, FSharpOption`1<CompilationPath>> ComputeAccessAndCompPath(TcEnv env, FSharpOption`1<DeclKind> declKindOpt, range m, FSharpOption`1<SynAccess> vis, FSharpOption`1<Accessibility> overrideVis, ParentRef actualParent);
    [CompilerGeneratedAttribute]
internal static void CheckForAbnormalOperatorNames$cont@1378(range idRange, string coreDisplayName, FSharpOption`1<ValMemberInfo> memberInfoOpt, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForAbnormalOperatorNames(cenv cenv, range idRange, string coreDisplayName, FSharpOption`1<ValMemberInfo> memberInfoOpt);
    internal static bool shouldNotifySink@1517(Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val MakeAndPublishVal(cenv cenv, TcEnv env, ParentRef altActualParent, bool inSig, DeclKind declKind, ValRecursiveScopeInfo vrec, ValScheme vscheme, FSharpList`1<Attrib> attrs, XmlDoc doc, FSharpOption`1<Const> konst, bool isGeneratedEventVal);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<a, Tuple`2<Val, TypeScheme>> MakeAndPublishVals(cenv cenv, TcEnv env, ParentRef altActualParent, bool inSig, DeclKind declKind, ValRecursiveScopeInfo vrec, FSharpMap`2<a, ValScheme> valSchemes, FSharpList`1<Attrib> attrs, XmlDoc doc, FSharpOption`1<Const> konst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Val> MakeAndPublishBaseVal(cenv cenv, TcEnv env, FSharpOption`1<Ident> baseIdOpt, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool InstanceMembersNeedSafeInitCheck(cenv cenv, range m, TType thisTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdField MakeSafeInitField(TcGlobals g, TcEnv env, range m, bool isStatic);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SafeInitData ComputeInstanceSafeInitInfo(cenv cenv, TcEnv env, range m, TType thisTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Val> MakeAndPublishSafeThisVal(cenv cenv, TcEnv env, FSharpOption`1<Ident> thisIdOpt, TType thisTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AdjustAndForgetUsesOfRecValue(cenv cenv, ValRef vrefTgt, ValScheme valScheme);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AdjustRecType(a _cenv, Val vspec, ValScheme _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr RecordUseOfRecValue(cenv cenv, ValRecursiveScopeInfo vrec, ValRef vrefTgt, Expr vexp, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecursiveUseFixupPoints GetAllUsesOfRecValue(cenv cenv, Val vrefTgt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> ChooseCanonicalDeclaredTyparsAfterInference(TcGlobals g, DisplayEnv denv, FSharpList`1<Typar> declaredTypars, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValScheme ChooseCanonicalValSchemeAfterInference(TcGlobals g, DisplayEnv denv, ValScheme valscheme, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> PlaceTyparsInDeclarationOrder(FSharpList`1<Typar> declaredTypars, FSharpList`1<Typar> generalizedTypars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetTyparRigid(a _g, DisplayEnv denv, range m, Typar tp);
    internal static FSharpList`1<Typar> computeRelevantTypars@1707(cenv cenv, FSharpList`1<Typar> generalizedTyparsForThisBinding, TType ty, FSharpList`1<Typar> allDeclaredTypars, bool thruFlag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PrelimValScheme2 GeneralizeVal(cenv cenv, DisplayEnv denv, FSharpList`1<Typar> enclosingDeclaredTypars, FSharpList`1<Typar> generalizedTyparsForThisBinding, PrelimValScheme1 _arg1);
    internal static FSharpMap`2<string, PrelimValScheme2> DontGeneralizeVals(FSharpMap`2<string, PrelimValScheme1> types);
    internal static bool ComputeIsTyFunc(Ident id, bool hasDeclaredTypars, FSharpOption`1<ValReprInfo> arityInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ValReprInfo> UseSyntacticArity(DeclKind declKind, TypeScheme typeScheme, PartialValReprInfo partialValReprInfo);
    internal static FSharpList`1<a> choose@1804-5(FSharpList`1<a> ai1, FSharpList`1<a> ai2);
    internal static FSharpList`1<FSharpList`1<a>> loop@1812-73(FSharpList`1<FSharpList`1<a>> ais1, FSharpList`1<FSharpList`1<a>> ais2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<PartialValReprInfo> CombineSyntacticAndInferredArities(TcGlobals g, DeclKind declKind, Expr rhsExpr, PrelimValScheme2 prelimScheme);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValScheme BuildValScheme(DeclKind declKind, FSharpOption`1<PartialValReprInfo> partialArityInfoOpt, PrelimValScheme2 prelimScheme);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpMap`2<string, Tuple`2<Val, TypeScheme>>, FSharpMap`2<string, Val>> MakeSimpleVals(cenv cenv, TcEnv env, FSharpMap`2<string, PrelimValScheme1> names);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpMap`2<string, Tuple`2<Val, TypeScheme>>, FSharpMap`2<string, Val>> MakeAndPublishSimpleVals$cont@1865(cenv cenv, TcEnv env, FSharpMap`2<string, PrelimValScheme1> names, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TcEnv, FSharpMap`2<string, Tuple`2<Val, TypeScheme>>, FSharpMap`2<string, Val>> MakeAndPublishSimpleVals(cenv cenv, TcEnv env, range m, FSharpMap`2<string, PrelimValScheme1> names, bool mergeNamesInOneNameresEnv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<TType, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, TType> FreshenTyconRef(range m, TyparRigidity rigid, EntityRef tcref, FSharpList`1<Typar> declaredTyconTypars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<TType>, TType> FreshenPossibleForallTy(TcGlobals g, range m, TyparRigidity rigid, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>, TType> infoOfTyconRef(range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<bool, FSharpList`1<Typar>, FSharpList`1<FSharpList`1<TType>>, TType> FreshenAbstractSlot(TcGlobals g, ImportMap amap, range m, SynValTyparDecls synTyparDecls, MethInfo absMethInfo);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpMap`2<string, a>, FSharpList`1<Tuple`2<string, a>>> BuildFieldMap$cont@2009(cenv cenv, TcEnv env, range m, AccessorDomain ad, FSharpList`1<Tuple`3<Tuple`2<FSharpList`1<Ident>, Ident>, FSharpList`1<FieldResolution>, a>> frefSets, EntityRef tcref, FSharpList`1<Tuple`2<string, a>> rfldsList, FSharpMap`2<string, a> fs, a fldExpr, Tuple`2<FSharpList`1<Ident>, Ident> fld, bool showDeprecated, RecdFieldRef fref2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<EntityRef, FSharpMap`2<string, a>, FSharpList`1<Tuple`2<string, a>>> BuildFieldMap(cenv cenv, TcEnv env, bool isPartial, TType ty, FSharpList`1<Tuple`2<Tuple`2<FSharpList`1<Ident>, Ident>, a>> flds, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<a, FSharpList`1<TType>, FSharpList`1<Ident>> ApplyUnionCaseOrExn(FSharpFunc`2<Tuple`2<UnionCaseRef, FSharpList`1<TType>>, a> makerForUnionCase, FSharpFunc`2<EntityRef, a> makerForExnTag, range m, cenv cenv, TcEnv env, TType overallTy, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpFunc`2<range, FSharpFunc`2<FSharpList`1<Expr>, Expr>>, FSharpList`1<TType>, FSharpList`1<Ident>> ApplyUnionCaseOrExnTypes(range m, cenv cenv, TcEnv env, TType overallTy, Item c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpFunc`2<range, FSharpFunc`2<FSharpList`1<Pattern>, Pattern>>, FSharpList`1<TType>, FSharpList`1<Ident>> ApplyUnionCaseOrExnTypesForPat(range m, cenv cenv, TcEnv env, TType overallTy, Item c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UnionCaseOrExnCheck(TcEnv env, int numArgTys, int numArgs, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<a, TType> TcUnionCaseOrExnField(cenv cenv, TcEnv env, TType ty1, range m, FSharpList`1<Ident> c, int n, FSharpFunc`2<Tuple`2<UnionCaseRef, FSharpList`1<TType>>, a> funcs_0, FSharpFunc`2<EntityRef, a> funcs_1);
    internal static SyntacticUnscopedTyparEnv get_emptyUnscopedTyparEnv();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SyntacticUnscopedTyparEnv AddUnscopedTypar(string n, Typar p, SyntacticUnscopedTyparEnv _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SyntacticUnscopedTyparEnv HideUnscopedTypars(FSharpList`1<Typar> typars, SyntacticUnscopedTyparEnv _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValInline ComputeInlineFlag(FSharpOption`1<MemberFlags> memFlagsOption, bool isInline, bool isMutable, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NormalizedBindingRhs PushOnePatternToRhs(cenv cenv, bool isMember, SynPat p, NormalizedBindingRhs _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<TType, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, TType, TType> FreshenObjectArgType(cenv cenv, range m, TyparRigidity rigid, EntityRef tcref, bool isExtrinsic, FSharpList`1<Typar> declaredTyconTypars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TcValEarlyGeneralizationConsistencyCheck(cenv cenv, TcEnv env, Val v, ValRecursiveScopeInfo vrec, FSharpList`1<TType> tinst, TType vty, TType tau, range m);
    internal static void checkInst@2805(range m, Val v, FSharpList`1<TType> tinst);
    [CompilerGeneratedAttribute]
internal static Tuple`5<FSharpList`1<Typar>, ValUseFlag, FSharpList`1<TType>, TType, a> res$cont@2805-1(cenv cenv, TcEnv env, a tpenv, ValRef vref, FSharpOption`1<Tuple`2<ValUseFlag, FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<TyparKind>, Tuple`2<FSharpList`1<TType>, a>>>>> optInst, range m, Val v, ValRecursiveScopeInfo vrec, TType vty, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`6<FSharpList`1<Typar>, Expr, bool, TType, FSharpList`1<TType>, a> res$cont@2785(cenv cenv, TcEnv env, a tpenv, ValRef vref, FSharpOption`1<Tuple`2<ValUseFlag, FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<TyparKind>, Tuple`2<FSharpList`1<TType>, a>>>>> optInst, range m, Val v, ValRecursiveScopeInfo vrec, TType vty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<Typar>, Expr, bool, TType, FSharpList`1<TType>, a> TcVal(bool checkAttributes, cenv cenv, TcEnv env, a tpenv, ValRef vref, FSharpOption`1<Tuple`2<ValUseFlag, FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<TyparKind>, Tuple`2<FSharpList`1<TType>, a>>>>> optInst, FSharpOption`1<AfterResolution> optAfterResolution, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> LightweightTcValForUsingInBuildMethodCall(TcGlobals g, ValRef vref, ValUseFlag vrefFlags, FSharpList`1<TType> vrefTypeInst, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ApplicableExpr MakeApplicableExprWithFlex(cenv cenv, TcEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TcRuntimeTypeTest(bool isCast, bool isOperator, cenv cenv, DisplayEnv denv, range m, TType tgtTy, TType srcTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TcStaticUpcast(cenv cenv, DisplayEnv denv, range m, TType tgtTy, TType srcTy);
    [CompilerGeneratedAttribute]
internal static bool contains@1-3(a e, FSharpList`1<a> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildPossiblyConditionalMethodCall(cenv cenv, TcEnv env, Mutates isMutable, range m, bool isProp, MethInfo minfo, ValUseFlag valUseFlags, FSharpList`1<TType> minst, FSharpList`1<Expr> objArgs, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> TryFindIntrinsicOrExtensionMethInfo(ResultCollectionSettings collectionSettings, cenv cenv, TcEnv env, range m, AccessorDomain ad, string nm, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<PropInfo> TryFindFSharpSignatureInstanceGetterProperty(cenv cenv, TcEnv env, range m, string nm, TType ty, FSharpList`1<TType> sigTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildDisposableCleanup(cenv cenv, TcEnv env, range m, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildOffsetToStringData(cenv cenv, TcEnv env, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildILFieldGet(TcGlobals g, ImportMap amap, range m, Expr objExpr, ILFieldInfo finfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildILFieldSet(TcGlobals g, range m, Expr objExpr, ILFieldInfo finfo, Expr argExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildILStaticFieldSet(range m, ILFieldInfo finfo, Expr argExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildRecdFieldSet(TcGlobals g, range m, Expr objExpr, RecdFieldInfo rfinfo, Expr argExpr);
    internal static FSharpOption`1<Tuple`3<Ident, SynExpr, SynExpr>> |BinOpExpr|_|(SynExpr e);
    internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |SimpleEqualsExpr|_|(SynExpr e);
    internal static bool isOpName@3184(cenv cenv, TcEnv env, range m, AccessorDomain ad, string opName, ValRef vref, string s);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |JoinRelation|_|$cont@3190(cenv cenv, TcEnv env, SynExpr e, range m, AccessorDomain ad, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |JoinRelation|_|(cenv cenv, TcEnv env, SynExpr e);
    internal static FSharpOption`1<Tuple`3<bool, Ident, SynExpr>> TryGetNamedArg(SynExpr e);
    internal static Tuple`2<FSharpList`1<SynExpr>, FSharpList`1<Tuple`3<bool, Ident, SynExpr>>> GetMethodArgs(SynExpr arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr CompilePatternForMatch(cenv cenv, TcEnv env, range mExpr, range matchm, bool warnOnUnused, ActionOnFailure actionOnFailure, Val inputVal, FSharpList`1<Typar> generalizedTypars, FSharpOption`1<Expr> inputExprOpt, FSharpList`1<TypedMatchClause> clauses, TType inputTy, TType resultTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> CompilePatternForMatchClauses(cenv cenv, TcEnv env, range mExpr, range matchm, bool warnOnUnused, ActionOnFailure actionOnFailure, FSharpOption`1<Expr> inputExprOpt, TType inputTy, TType resultTy, FSharpList`1<TypedMatchClause> tclauses);
    internal static ResultOrException`1<a> err@3278-4(TcEnv env, range m, bool k, TType ty);
    internal static ResultOrException`1<MethInfo> findMethInfo@3283(cenv cenv, TcEnv env, range m, AccessorDomain ad, bool k, range m@3283, string nm, TType ty);
    internal static bool hasArgs@3289(cenv cenv, range m, MethInfo minfo, FSharpList`1<TType> minst);
    internal static bool allEquivReturnTypes@3332(cenv cenv, range m, MethInfo minfo, FSharpList`1<MethInfo> others);
    [CompilerGeneratedAttribute]
internal static TType enumElemTy$cont@3332(cenv cenv, TcEnv env, range m, AccessorDomain ad, TType tyToSearchForGetEnumeratorAndItem, TType enumElemTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ResultOrException`1<Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>>> tryType$cont@3318-1(cenv cenv, TcEnv env, bool localAlloc, range m, AccessorDomain ad, TType tyToSearchForGetEnumeratorAndItem, Expr exprToSearchForGetEnumeratorAndItem, MethInfo getEnumerator_minfo, FSharpList`1<TType> getEnumerator_minst, TType retTypeOfGetEnumerator, MethInfo moveNext_minfo, FSharpList`1<TType> moveNext_minst, MethInfo get_Current_minfo, FSharpList`1<TType> get_Current_minst, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ResultOrException`1<Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>>> tryType$cont@3299(cenv cenv, TcEnv env, bool localAlloc, range m, AccessorDomain ad, TType tyToSearchForGetEnumeratorAndItem, Expr exprToSearchForGetEnumeratorAndItem, ResultOrException`1<MethInfo> matchValue, Unit unitVar);
    internal static ResultOrException`1<Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>>> tryType@3294(cenv cenv, TcEnv env, bool localAlloc, range m, AccessorDomain ad, Expr tupledArg0, TType tupledArg1);
    internal static FSharpOption`1<Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>>> probe@3405(cenv cenv, TcEnv env, bool localAlloc, range m, TType exprty, Expr expr, AccessorDomain ad, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>> AnalyzeArbitraryExprAsEnumerable(cenv cenv, TcEnv env, bool localAlloc, range m, TType exprty, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> ConvertArbitraryExprToEnumerable(cenv cenv, TType ty, TcEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqEmpty(cenv cenv, TcEnv env, range m, TType genTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqCollect(cenv cenv, TcEnv env, range m, TType enumElemTy, TType genTy, Expr lam, Expr enumExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqUsing(cenv cenv, TcEnv env, range m, TType resourceTy, TType genTy, Expr resourceExpr, Expr lam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqDelay(cenv cenv, TcEnv env, range m, TType genTy, Expr lam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqAppend(cenv cenv, TcEnv env, range m, TType genTy, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqFromFunctions(cenv cenv, TcEnv env, range m, TType genTy, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqFinally(cenv cenv, TcEnv env, range m, TType genTy, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TypedMatchClause> mkSeqExprMatchClauses(Pattern pat', FSharpList`1<Val> vspecs, Expr innerExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> compileSeqExprMatchClauses(cenv cenv, TcEnv env, range inputExprMark, Pattern pat, FSharpList`1<Val> vspecs, Expr innerExpr, FSharpOption`1<Expr> inputExprOpt, TType bindPatTy, TType genInnerTy);
    internal static SynExpr elimFastIntegerForLoop(SequencePointInfoForForLoop spBind, Ident id, SynExpr start, bool dir, SynExpr finish, SynExpr innerExpr, range m);
    internal static FSharpOption`1<SynPat> |ExprAsPat|_|(SynExpr f);
    internal static bool YieldFree@3522(SynExpr expr);
    internal static bool IsSimpleSemicolonSequenceElement@3541(bool acceptDeprecated, SynExpr expr);
    internal static FSharpOption`1<FSharpList`1<SynExpr>> GetSimpleSemicolonSequenceOfComprehension@3560(bool acceptDeprecated, SynExpr expr, FSharpList`1<SynExpr> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<SynExpr>> |SimpleSemicolonSequence|_|(bool acceptDeprecated, SynExpr c);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@3584-54(MutRecShape`5<TypeData, LetsData, ModuleData, ModuleAbbrevData, OpenData> this, MutRecShape`5<TypeData, LetsData, ModuleData, ModuleAbbrevData, OpenData> obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@3584-55(IComparer comp, MutRecShape`5<TypeData, LetsData, ModuleData, ModuleAbbrevData, OpenData> this, MutRecShape`5<TypeData, LetsData, ModuleData, ModuleAbbrevData, OpenData> objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@3584-7(IEqualityComparer comp, MutRecShape`5<TypeData, LetsData, ModuleData, ModuleAbbrevData, OpenData> this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@3584-12(MutRecShape`5<TypeData, LetsData, ModuleData, ModuleAbbrevData, OpenData> this, MutRecShape`5<TypeData, LetsData, ModuleData, ModuleAbbrevData, OpenData> that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@3584-13(MutRecShape`5<TypeData, LetsData, ModuleData, ModuleAbbrevData, OpenData> this, MutRecShape`5<TypeData, LetsData, ModuleData, ModuleAbbrevData, OpenData> obj, Unit unitVar);
    internal static Expr stripChooseAndExpr@3743(Expr e);
    internal static InitializationGraphAnalysisState strict@3750(InitializationGraphAnalysisState _arg1);
    internal static InitializationGraphAnalysisState lzy@3754(InitializationGraphAnalysisState _arg2);
    internal static InitializationGraphAnalysisState fixable@3757(InitializationGraphAnalysisState _arg3);
    internal static void CheckExpr@3763-13(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, ValHash`1<int> availIfInOrder, ValRef boundv, InitializationGraphAnalysisState st, Expr e);
    internal static void CheckBinding@3820-7(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, ValHash`1<int> availIfInOrder, ValRef boundv, InitializationGraphAnalysisState st, Binding _arg4);
    internal static void CheckDecisionTree@3821-1(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, ValHash`1<int> availIfInOrder, ValRef boundv, InitializationGraphAnalysisState st, DecisionTree _arg6);
    internal static FSharpFunc`2<DecisionTreeTarget, Unit> CheckDecisionTreeTarget@3825-2(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, ValHash`1<int> availIfInOrder, ValRef boundv, InitializationGraphAnalysisState st);
    internal static void CheckExprOp@3827-24(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, ValHash`1<int> availIfInOrder, ValRef boundv, InitializationGraphAnalysisState st, TOp op, range m);
    internal static void CheckValRef@3832(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, ValHash`1<int> availIfInOrder, ValRef boundv, InitializationGraphAnalysisState st, ValRef v, range m);
    internal static void checkDelayed@3853(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, ValHash`1<int> availIfInOrder, ValRef boundv, InitializationGraphAnalysisState st, Expr b);
    internal static void check@3749-6(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, ValHash`1<int> availIfInOrder, ValRef boundv, Expr expr);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Binding>> morphBinding$cont@3888(TcGlobals g, bool mustHaveArity, FSharpList`1<Tuple`2<FSharpRef`1<Expr>, range>> fixupPoints, Val v, SequencePointInfoForBinding seqPtOpt, Expr e, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MutRecShape`5<TyconDataOut, FSharpList`1<Binding>, a, b, c>> EliminateInitializationGraphs(FSharpFunc`2<TyconDataIn, FSharpList`1<PreInitializationGraphEliminationBinding>> getTyconBinds, FSharpFunc`2<FSharpFunc`2<FSharpList`1<PreInitializationGraphEliminationBinding>, FSharpList`1<Binding>>, FSharpFunc`2<TyconDataIn, TyconDataOut>> morphTyconBinds, FSharpFunc`2<FSharpList`1<LetDataIn>, FSharpList`1<PreInitializationGraphEliminationBinding>> getLetBinds, FSharpFunc`2<FSharpFunc`2<FSharpList`1<PreInitializationGraphEliminationBinding>, FSharpList`1<Binding>>, FSharpFunc`2<FSharpList`1<LetDataIn>, FSharpList`1<Binding>>> morphLetBinds, TcGlobals g, bool mustHaveArity, DisplayEnv denv, FSharpList`1<MutRecShape`5<TyconDataIn, FSharpList`1<LetDataIn>, a, b, c>> fixupsAndBindingsWithoutLaziness, range bindsm);
    internal static Expr error@3926-1(Expr expr);
    internal static Expr rewriteConstruction@3932(TcGlobals g, TcEnv env, range m, Expr recdExpr);
    [CompilerGeneratedAttribute]
internal static DecisionTreeTarget mapping@1-22(TcGlobals g, TcEnv env, range m, DecisionTreeTarget _arg1);
    internal static Expr checkAndRewrite@3956(TcGlobals g, TcEnv env, range m, Expr expr);
    internal static Expr checkAndRewriteCtorUsage@3987(TcGlobals g, TcEnv env, range m, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr CheckAndRewriteObjectCtor(TcGlobals g, TcEnv env, Expr ctorLambaExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ApplicableExpr, TType> buildApp(cenv cenv, ApplicableExpr expr, TType resultTy, Expr arg, range m);
    internal static DelayedItem MakeDelayedSet(SynExpr e, range m);
    internal static ContainerInfo get_ExprContainerInfo();
    internal static ContainerInfo ModuleOrNamespaceContainerInfo(EntityRef modref);
    internal static ContainerInfo TyconContainerInfo(ParentRef parent, EntityRef tcref, FSharpList`1<Typar> declaredTyconTypars, SafeInitData safeInitInfo);
    internal static bool CanInferExtraGeneralizedTyparsForRecBinding(PreGeneralizationRecursiveBinding pgrbind);
    internal static FSharpOption`1<Val> firstArg@4263(Expr e);
    internal static FSharpOption`1<Val> GetInstanceMemberThisVariable(Val v, Expr x);
    internal static SyntacticUnscopedTyparEnv checkSimpleConstraint@4279(cenv cenv, ImplictlyBoundTyparsAllowed newOk, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynTypar tp, a2 m, FSharpFunc`2<DisplayEnv, FSharpFunc`2<ConstraintSolverState, FSharpFunc`2<a2, FSharpFunc`2<OptionalTrace, FSharpFunc`2<TType, Unit>>>>> constraintAdder);
    [CompilerGeneratedAttribute]
internal static SyntacticUnscopedTyparEnv TcTyparConstraint$cont@4326(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynTypeConstraint c, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static SyntacticUnscopedTyparEnv TcTyparConstraint$cont@4338-1(cenv cenv, ImplictlyBoundTyparsAllowed newOk, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynTypeConstraint c, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SyntacticUnscopedTyparEnv TcTyparConstraint(int ridx, cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynTypeConstraint c);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TraitConstraintInfo, SyntacticUnscopedTyparEnv> TcPseudoMemberSpec$cont@4362(cenv cenv, ImplictlyBoundTyparsAllowed newOk, TcEnv env, SynMemberSig memSpfn, FSharpList`1<TType> tys, SyntacticUnscopedTyparEnv tpenv, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TraitConstraintInfo, SyntacticUnscopedTyparEnv> TcPseudoMemberSpec(cenv cenv, ImplictlyBoundTyparsAllowed newOk, TcEnv env, FSharpList`1<SynType> synTypes, SyntacticUnscopedTyparEnv tpenv, SynMemberSig memSpfn, range m);
    internal static ValSpecResult reallyGenerateOneMember@4456(cenv cenv, TcEnv env, FSharpList`1<Attrib> attrs, range m, FSharpList`1<Typar> declaredTypars, ParentRef altActualParent, FSharpOption`1<EntityRef> memberContainerInfo, FSharpList`1<Typar> enclosingDeclaredTypars, DeclKind declKind, Ident tupledArg0, SynValInfo tupledArg1, TType tupledArg2, MemberFlags tupledArg3);
    internal static FSharpList`1<ValSpecResult> generateOneMember@4420(cenv cenv, TcEnv env, FSharpList`1<Attrib> attrs, SynValInfo valSynInfo, range m, Ident id, FSharpList`1<Typar> declaredTypars, ParentRef altActualParent, FSharpOption`1<EntityRef> memberContainerInfo, FSharpList`1<Typar> enclosingDeclaredTypars, DeclKind declKind, TType declaredTy, TType thisTy, MemberFlags memberFlags);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<ValSpecResult>, SyntacticUnscopedTyparEnv> TcValSpec(cenv cenv, TcEnv env, DeclKind declKind, ImplictlyBoundTyparsAllowed newOk, ContainerInfo containerInfo, FSharpOption`1<MemberFlags> memFlagsOpt, FSharpOption`1<TType> thisTyOpt, SyntacticUnscopedTyparEnv tpenv, SynValSig valSpfn, FSharpList`1<Attrib> attrs);
    internal static Tuple`2<Typar, SyntacticUnscopedTyparEnv> checkRes@4529(FSharpOption`1<TyparKind> optKind, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, Ident id, Typar res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Typar, SyntacticUnscopedTyparEnv> TcTyparOrMeasurePar(FSharpOption`1<TyparKind> optKind, cenv cenv, TcEnv env, ImplictlyBoundTyparsAllowed newOk, SyntacticUnscopedTyparEnv tpenv, SynTypar _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Typar, SyntacticUnscopedTyparEnv> TcTypar(cenv cenv, TcEnv env, ImplictlyBoundTyparsAllowed newOk, SyntacticUnscopedTyparEnv tpenv, SynTypar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar TcTyparDecl(cenv cenv, TcEnv env, SynTyparDecl _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> TcTyparDecls(cenv cenv, TcEnv env, FSharpList`1<SynTyparDecl> synTypars);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TType, SyntacticUnscopedTyparEnv> TcTypeOrMeasure$cont@4617(FSharpOption`1<TyparKind> optKind, cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<Ident> tc, bool postfix, range m, FSharpList`1<SynType> args, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TType, SyntacticUnscopedTyparEnv> TcTypeOrMeasure$cont@4753-1(FSharpOption`1<TyparKind> optKind, cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, bool postfix, range m1, range m, FSharpList`1<SynType> args, SynType arg1, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, SyntacticUnscopedTyparEnv> TcTypeOrMeasure(FSharpOption`1<TyparKind> optKind, cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, SyntacticUnscopedTyparEnv> TcType(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Measure, SyntacticUnscopedTyparEnv> TcMeasure(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynType ty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar TcAnonTypeOrMeasure(FSharpOption`1<TyparKind> optKind, cenv _cenv, TyparRigidity rigid, TyparDynamicReq dyn, ImplictlyBoundTyparsAllowed newOk, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, SyntacticUnscopedTyparEnv> TcTypes(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<SynType> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, SyntacticUnscopedTyparEnv> TcTypesAsTuple(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<Tuple`2<bool, SynType>> args, range m);
    internal static Tuple`2<Measure, SyntacticUnscopedTyparEnv> gather@4803-8(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, range m, FSharpList`1<Tuple`2<bool, SynType>> args, SyntacticUnscopedTyparEnv tpenv, bool isquot, Measure acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Measure, SyntacticUnscopedTyparEnv> TcMeasuresAsTuple(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<Tuple`2<bool, SynType>> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, SyntacticUnscopedTyparEnv> TcTypesOrMeasures(FSharpOption`1<FSharpList`1<TyparKind>> optKinds, cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<SynType> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SyntacticUnscopedTyparEnv TcTyparConstraints(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<SynTypeConstraint> wcs);
    internal static a2 fail@4830-4(TcEnv env, TType kind, SynType v, Unit unitVar0);
    internal static void record@4831(cenv cenv, TcEnv env, FSharpOption`1<Ident> idOpt, ArgumentContainer container, TType ttype);
    [CompilerGeneratedAttribute]
internal static object v$cont@4841-2(cenv cenv, TcEnv env, TType kind, SynType v, FSharpOption`1<Ident> idOpt, ArgumentContainer container, TcGlobals g, SynConst sc, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static object v$cont@4841-1(cenv cenv, TcEnv env, TType kind, SynType v, FSharpOption`1<Ident> idOpt, ArgumentContainer container, TcGlobals g, SynConst sc, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static object v$cont@4841(cenv cenv, TcEnv env, TType kind, SynType v, FSharpOption`1<Ident> idOpt, ArgumentContainer container, TcGlobals g, SynConst sc, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static object v$cont@4869-3(cenv cenv, TcEnv env, TType kind, SynType v, FSharpOption`1<Ident> idOpt, ArgumentContainer container, TcGlobals g, Expr matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<object, SyntacticUnscopedTyparEnv> TcStaticConstantParameter(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, TType kind, SynType v, FSharpOption`1<Ident> idOpt, ArgumentContainer container);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Object[] CrackStaticConstantArgs(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, Tainted`1[] staticParameters, FSharpList`1<SynType> args, ArgumentContainer container, string containerName, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<bool, Tainted`1<ProvidedType>, FSharpFunc`2<Unit, Unit>> TcProvidedTypeAppToStaticConstantArgs(cenv cenv, TcEnv env, FSharpOption`1<FSharpList`1<string>> optGeneratedTypePath, SyntacticUnscopedTyparEnv tpenv, EntityRef tcref, FSharpList`1<SynType> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MethInfo> TryTcMethodAppToStaticConstantArgs(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<MethInfo> minfos, FSharpOption`1<Tuple`2<FSharpList`1<SynType>, a>> argsOpt, range mExprAndArg, range mItem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tainted`1<ProvidedMethodBase> TcProvidedMethodAppToStaticConstantArgs(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, MethInfo minfo, Tainted`1<ProvidedMethodBase> methBeforeArguments, Tainted`1[] staticParams, FSharpList`1<SynType> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, SyntacticUnscopedTyparEnv> TcProvidedTypeApp(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, EntityRef tcref, FSharpList`1<SynType> args, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, SyntacticUnscopedTyparEnv> TcTypeApp(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range m, EntityRef tcref, FSharpList`1<TType> pathTypeArgs, FSharpList`1<SynType> synArgTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, SyntacticUnscopedTyparEnv> TcTypeOrMeasureAndRecover(FSharpOption`1<TyparKind> optKind, cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, SyntacticUnscopedTyparEnv> TcTypeAndRecover(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, SyntacticUnscopedTyparEnv> TcNestedTypeApplication(cenv cenv, ImplictlyBoundTyparsAllowed newOk, CheckConstraints checkCxs, ItemOccurence occ, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mWholeTypeApp, TType ty, FSharpList`1<SynType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Ident> TryAdjustHiddenVarNameToCompGenName(cenv cenv, TcEnv env, Ident id, FSharpOption`1<FSharpRef`1<SynSimplePatAlternativeIdInfo>> altNameRefCellOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, Tuple`3<SyntacticUnscopedTyparEnv, FSharpMap`2<string, PrelimValScheme1>, FSharpSet`1<string>>> TcSimplePat(bool optArgsOK, CheckConstraints checkCxs, cenv cenv, TType ty, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpMap`2<string, PrelimValScheme1> names, FSharpSet`1<string> takenNames, SynSimplePat p);
    internal static Tuple`2<FSharpList`1<SynSimplePat>, range> getPats@5118(SynSimplePats spats);
    internal static bool isOptArg@5123(SynSimplePat pat);
    internal static void ValidateOptArgOrder(SynSimplePats spats);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<string>, Tuple`3<SyntacticUnscopedTyparEnv, FSharpMap`2<string, PrelimValScheme1>, FSharpSet`1<string>>> TcSimplePats(cenv cenv, bool optArgsOK, CheckConstraints checkCxs, TType ty, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpMap`2<string, PrelimValScheme1> names, FSharpSet`1<string> takenNames, SynSimplePats p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpFunc`2<TcPatPhase2Input, PatternValBinding>, FSharpMap`2<string, PrelimValScheme1>, FSharpSet`1<string>> TcPatBindingName(cenv cenv, TcEnv env, Ident id, TType ty, bool isMemberThis, FSharpOption`1<SynAccess> vis1, FSharpOption`1<PartialValReprInfo> topValData, ValInline inlineFlag, ExplicitTyparInfo declaredTypars, ArgAndRetAttribs argAttribs, bool isMutable, FSharpOption`1<SynAccess> vis2, bool compgen, FSharpMap`2<string, PrelimValScheme1> names, FSharpSet`1<string> takenNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, Tuple`3<SyntacticUnscopedTyparEnv, FSharpMap`2<string, PrelimValScheme1>, FSharpSet`1<string>>> TcPatAndRecover(WarnOnUpperFlag warnOnUpper, cenv cenv, TcEnv env, FSharpOption`1<PartialValReprInfo> topValInfo, ValInline vFlags_0, ExplicitTyparInfo vFlags_1, ArgAndRetAttribs vFlags_2, bool vFlags_3, FSharpOption`1<SynAccess> vFlags_4, bool vFlags_5, SyntacticUnscopedTyparEnv tpenv, FSharpMap`2<string, PrelimValScheme1> names, FSharpSet`1<string> takenNames, TType ty, SynPat pat);
    internal static void checkNoArgsForLiteral@5302(range m, SynConstructorArgs args, Unit unitVar0);
    internal static SynExpr convSynPatToSynExpr@5342(SynPat x);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynPat> args$cont@5398-1(cenv cenv, TcEnv env, AccessorDomain ad, SynConstructorArgs args, Item item, FSharpList`1<TType> argTys, FSharpList`1<Ident> argNames, int numArgTys, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynPat> args$cont@5431-2(range m, int numArgTys, FSharpList`1<SynPat> args, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, Tuple`3<SyntacticUnscopedTyparEnv, FSharpMap`2<string, PrelimValScheme1>, FSharpSet`1<string>>> TcPat$cont@5386(WarnOnUpperFlag warnOnUpper, cenv cenv, TcEnv env, Tuple`6<ValInline, ExplicitTyparInfo, ArgAndRetAttribs, bool, FSharpOption`1<SynAccess>, bool> vFlags, SyntacticUnscopedTyparEnv tpenv, FSharpMap`2<string, PrelimValScheme1> names, FSharpSet`1<string> takenNames, TType ty, AccessorDomain ad, range m, FSharpList`1<Ident> longId, SynConstructorArgs args, Item item, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, Tuple`3<SyntacticUnscopedTyparEnv, FSharpMap`2<string, PrelimValScheme1>, FSharpSet`1<string>>> TcPat$cont@5452-1(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpMap`2<string, PrelimValScheme1> names, FSharpSet`1<string> takenNames, TType ty, range m, SynConstructorArgs args, Item matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, Tuple`3<SyntacticUnscopedTyparEnv, FSharpMap`2<string, PrelimValScheme1>, FSharpSet`1<string>>> TcPat$cont@5467-2(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpMap`2<string, PrelimValScheme1> names, FSharpSet`1<string> takenNames, TType ty, range m, SynConstructorArgs args, Item matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, Tuple`3<SyntacticUnscopedTyparEnv, FSharpMap`2<string, PrelimValScheme1>, FSharpSet`1<string>>> TcPat(WarnOnUpperFlag warnOnUpper, cenv cenv, TcEnv env, FSharpOption`1<PartialValReprInfo> topValInfo, ValInline vFlags_0, ExplicitTyparInfo vFlags_1, ArgAndRetAttribs vFlags_2, bool vFlags_3, FSharpOption`1<SynAccess> vFlags_4, bool vFlags_5, SyntacticUnscopedTyparEnv tpenv, FSharpMap`2<string, PrelimValScheme1> names, FSharpSet`1<string> takenNames, TType ty, SynPat pat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpFunc`2<TcPatPhase2Input, Pattern>>, Tuple`3<SyntacticUnscopedTyparEnv, FSharpMap`2<string, PrelimValScheme1>, FSharpSet`1<string>>> TcPatterns(WarnOnUpperFlag warnOnUpper, cenv cenv, TcEnv env, ValInline vFlags_0, ExplicitTyparInfo vFlags_1, ArgAndRetAttribs vFlags_2, bool vFlags_3, FSharpOption`1<SynAccess> vFlags_4, bool vFlags_5, SyntacticUnscopedTyparEnv s_0, FSharpMap`2<string, PrelimValScheme1> s_1, FSharpSet`1<string> s_2, FSharpList`1<TType> argTys, FSharpList`1<SynPat> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void solveTypAsError(cenv cenv, DisplayEnv denv, range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr expr);
    internal static void dummyCheckedDelayed@5577(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void RecordNameAndTypeResolutions_IdeallyWithoutHavingOtherEffects_Delayed(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UnifyTypesAndRecover(cenv cenv, TcEnv env, range m, TType expectedTy, TType actualTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Expr, TType, SyntacticUnscopedTyparEnv> TcExprOfUnknownType(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcExprFlex(cenv cenv, bool flex, bool compat, TType ty, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcExpr(cenv cenv, TType ty, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcExprNoRecover(cenv cenv, TType ty, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Expr, TType, SyntacticUnscopedTyparEnv> TcExprOfUnknownTypeThen(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr expr, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcExprThatIsCtorBody(FSharpOption`1<Val> safeInitInfo_0, SafeInitData safeInitInfo_1, cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcExprThatCanBeCtorBody(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcExprThatCantBeCtorBody(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcStmtThatCantBeCtorBody(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcStmt(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcExprThen(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr synExpr, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Expr>, SyntacticUnscopedTyparEnv> TcExprs(cenv cenv, TcEnv env, range m, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<bool> flexes, FSharpList`1<TType> argTys, FSharpList`1<SynExpr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckSuperInit(cenv cenv, TType objTy, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Expr, TType, SyntacticUnscopedTyparEnv> TcExprUndelayedNoType(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcExprUndelayed$cont@5751(SynExpr synExpr, Unit unitVar);
    internal static TcEnv getInitEnv@5891(TcEnv env, bool isArray, FSharpRef`1<bool> first, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcExprUndelayed(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcIteratedLambdas(cenv cenv, bool isFirst, TcEnv env, TType overallTy, FSharpSet`1<string> takenNames, SyntacticUnscopedTyparEnv tpenv, SynExpr e);
    internal static FSharpList`1<SynExpr> GetIndexArgs@6258(FSharpList`1<SynIndexerArg> es);
    internal static SynExpr MakeIndexParam@6259(FSharpList`1<SynIndexerArg> indexArgs, range idxRange, FSharpOption`1<SynExpr> vopt);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcIndexerThen$cont@6311(cenv cenv, TcEnv env, TType overallTy, range mWholeExpr, range mDot, SynExpr wholeExpr, FSharpList`1<SynIndexerArg> indexArgs, FSharpList`1<DelayedItem> delayed, SyntacticUnscopedTyparEnv tpenv, TType e1ty, Expr e1', FSharpOption`1<string> propName, range idxRange, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcIndexerThen(cenv cenv, TcEnv env, TType overallTy, range mWholeExpr, range mDot, SyntacticUnscopedTyparEnv tpenv, SynExpr wholeExpr, SynExpr e1, FSharpList`1<SynIndexerArg> indexArgs, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcNewExpr(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, TType objTy, FSharpOption`1<range> mObjTyOpt, bool superInit, SynExpr arg, range mWholeExprOrObjTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcCtorCall(bool isNaked, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, TType overallTy, TType objTy, FSharpOption`1<range> mObjTyOpt, Item item, bool superInit, FSharpList`1<SynExpr> args, range mWholeCall, FSharpList`1<DelayedItem> delayed, FSharpOption`1<AfterResolution> afterTcOverloadResolutionOpt);
    internal static bool fieldNameUnbound@6431(FSharpList`1<Tuple`2<string, Expr>> fldsList, string nom);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcRecordConstruction(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpOption`1<Tuple`3<Expr, Val, Expr>> optOrigExprInfo, TType objTy, IEnumerable`1<Tuple`2<string, SynExpr>> fldsList, range m);
    internal static Tuple`2<string, SynValInfo> lookPat@6502(NormalizedBindingRhs rhsExpr, range mBinding, SynPat pat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, SynValInfo> GetNameAndArityOfObjExprBinding(b _cenv, c _env, NormalizedBinding b);
    internal static string getSignature@6525(cenv cenv, TcEnv env, range mBinding, MethInfo absSlot);
    internal static string getDetails@6526(cenv cenv, range mBinding, MethInfo absSlot);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<bool, FSharpList`1<Typar>, TType>> FreshenObjExprAbstractSlot(cenv cenv, TcEnv env, TType implty, FSharpList`1<Tuple`2<Tuple`2<string, d>, MethInfo>> virtNameAndArityPairs, NormalizedBinding bind, FSharpList`1<Attrib> bindAttribs, string bindName, FSharpList`1<Tuple`2<e, MethInfo>> absSlots);
    internal static Tuple`3<NormalizedBindingRhs, Ident, MemberFlags> lookPat@6580-1(cenv cenv, range mBinding, NormalizedBindingRhs bindingRhs, FSharpOption`1<MemberFlags> memberFlagsOpt, SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`5<Ident, MemberFlags, TType, FSharpList`1<Attrib>, Expr>, SyntacticUnscopedTyparEnv> TcObjectExprBinding(cenv cenv, TcEnv env, TType implty, SyntacticUnscopedTyparEnv tpenv, FSharpOption`1<Tuple`3<bool, FSharpList`1<Typar>, TType>> absSlotInfo, NormalizedBinding bind);
    internal static bool func2@1-2(Tuple`2<string, FSharpList`1<int>> bkey, string y0, FSharpList`1<int> y1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`6<range, TType, FSharpList`1<RequiredSlot>, FSharpMap`2<string, FSharpList`1<RequiredSlot>>, FSharpList`1<OverrideInfo>, FSharpList`1<Tuple`2<OverrideInfo, Tuple`5<FSharpOption`1<Val>, Val, FSharpList`1<FSharpList`1<Val>>, FSharpList`1<Attrib>, Expr>>>>>, SyntacticUnscopedTyparEnv> ComputeObjectExprOverrides(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<Tuple`3<range, TType, FSharpList`1<SynBinding>>> impls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckSuperType(cenv cenv, TType ty, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcObjectExpr(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynType synObjTy, FSharpOption`1<Tuple`2<SynExpr, FSharpOption`1<Ident>>> argopt, FSharpList`1<SynBinding> binds, FSharpList`1<SynInterfaceImpl> extraImpls, range mNewExpr, range mWholeExpr);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcConstStringExpr$cont@6857(cenv cenv, TcEnv env, range m, SyntacticUnscopedTyparEnv tpenv, string s, TType aty, TType bty, TType cty, TType dty, TType ety, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcConstStringExpr(cenv cenv, TType overallTy, TcEnv env, range m, SyntacticUnscopedTyparEnv tpenv, string s);
    [CompilerGeneratedAttribute]
internal static SynExpr expr$cont@6899(cenv cenv, range m, string suffix, string s, string modName, EntityRef mref, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcConstExpr(cenv cenv, TType overallTy, TcEnv env, range m, SyntacticUnscopedTyparEnv tpenv, SynConst c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcAssertExpr(cenv cenv, TType overallTy, TcEnv env, range m, SyntacticUnscopedTyparEnv tpenv, SynExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcRecdExpr(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpOption`1<Tuple`5<SynType, SynExpr, range, FSharpOption`1<Tuple`2<range, FSharpOption`1<pos>>>, range>> inherits, FSharpOption`1<Tuple`2<SynExpr, Tuple`2<range, FSharpOption`1<pos>>>> optOrigExpr, FSharpList`1<Tuple`3<Tuple`2<LongIdentWithDots, bool>, FSharpOption`1<SynExpr>, FSharpOption`1<Tuple`2<range, FSharpOption`1<pos>>>>> flds, range mWholeExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcAnonRecdExpr(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, bool isStruct, FSharpOption`1<Tuple`2<SynExpr, Tuple`2<range, FSharpOption`1<pos>>>> optOrigSynExpr, FSharpList`1<Tuple`2<Ident, SynExpr>> unsortedFieldIdsAndSynExprsGiven, range mWholeExpr);
    internal static FSharpValueOption`1<ValueTuple`3<MethInfo, MethInfo, bool>> tryGetOptimizeSpanMethodsAux@7176(cenv cenv, TcEnv env, TcGlobals g, range m, TType ty, bool isReadOnlySpan);
    internal static FSharpValueOption`1<ValueTuple`3<MethInfo, MethInfo, bool>> tryGetOptimizeSpanMethods@7188(cenv cenv, TcEnv env, TcGlobals g, range m, TType ty);
    [CompilerGeneratedAttribute]
internal static Tuple`4<TType, FSharpFunc`2<Val, FSharpFunc`2<Expr, Expr>>, FSharpFunc`2<Expr, Expr>, FSharpChoice`3<Tuple`2<Expr, Expr>, Tuple`3<Val, Expr, Expr>, Tuple`7<Val, Val, Expr, Expr, TType, Expr, Expr>>> TcForEachExpr$cont@7233-1(cenv cenv, range mWholeExpr, range mPat, range mEnumExpr, range mForLoopStart, TType enumExprTy, Expr enumExpr, FSharpValueOption`1<ValueTuple`3<MethInfo, MethInfo, bool>> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`4<TType, FSharpFunc`2<Val, FSharpFunc`2<Expr, Expr>>, FSharpFunc`2<Expr, Expr>, FSharpChoice`3<Tuple`2<Expr, Expr>, Tuple`3<Val, Expr, Expr>, Tuple`7<Val, Val, Expr, Expr, TType, Expr, Expr>>> TcForEachExpr$cont@7207(cenv cenv, TcEnv env, range mWholeExpr, range mPat, range mEnumExpr, range mForLoopStart, TType enumExprTy, Expr enumExpr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcForEachExpr(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynPat pat, SynExpr enumSynExpr, SynExpr bodySynExpr, range mWholeExpr, SequencePointInfoForForLoop spForLoop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcQuotationExpr(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr _oper, bool raw, SynExpr ast, bool isFromQueryExpression, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcComputationOrSequenceExpression(cenv cenv, TcEnv env, TType overallTy, range m, FSharpOption`1<Tuple`2<Expr, TType>> interpValOpt, SyntacticUnscopedTyparEnv tpenv, SynExpr comp);
    internal static SynExpr mkSynCall@7374(string builderValName, string nm, range m, FSharpList`1<SynExpr> args);
    internal static SynExpr mkSourceExpr@7387(string builderValName, FSharpList`1<MethInfo> sourceMethInfo, SynExpr callExpr);
    internal static FSharpOption`1<bool> flagSearch@7418(cenv cenv, range mBuilderVal, MethInfo methInfo, string propName);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>> tryGetDataForCustomOperation$cont@7452(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm, Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>> opData, Unit unitVar);
    internal static FSharpOption`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>> tryGetDataForCustomOperation@7448(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool isCustomOperation@7464(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationMaintainsVarSpace@7467(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationMaintainsVarSpaceUsingBind@7472(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationIsLikeZip@7477(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationIsLikeJoin@7482(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationIsLikeGroupJoin@7487(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static string customOperationJoinConditionWord@7492(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationAllowsInto@7497(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static FSharpOption`1<string> customOpUsageText@7502(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static FSharpOption`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> tryGetArgInfosForCustomOperator@7530(cenv cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static int expectedArgCountForCustomOperator@7541(cenv cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool isCustomOperationProjectionParameter@7547(cenv cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, int i, Ident nm);
    internal static FSharpOption`1<Tuple`5<bool, SynPat, SynExpr, SynExpr, SynExpr>> |ForEachThen|_|@7556(SynExpr e);
    internal static FSharpFunc`2<SynExpr, FSharpOption`1<Ident>> |CustomOpId|_|@7561(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> predicate);
    internal static FSharpOption`1<Tuple`3<SynExpr, SynExpr, range>> |InExpr|_|@7567(SynExpr e);
    internal static FSharpFunc`2<SynExpr, FSharpOption`1<Tuple`2<SynExpr, SynExpr>>> |OnExpr|_|@7573(cenv cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, TcEnv env, Ident nm);
    internal static FSharpOption`1<Tuple`3<SynExpr, range, SynPat>> |IntoSuffix|_|@7585(SynExpr e);
    internal static SynPat arbPat@7592(range m);
    internal static Tuple`3<SynExpr, SynPat, bool> MatchIntoSuffixOrRecover@7594(cenv cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, TcEnv env, bool alreadyGivenError, Ident nm, SynExpr e);
    internal static Tuple`2<SynExpr, SynExpr> MatchOnExprOrRecover@7606(cenv cenv, SyntacticUnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, TcEnv env, bool alreadyGivenError, Ident nm, SynExpr onExpr);
    internal static FSharpOption`1<Tuple`4<Ident, SynPat, range, bool>> JoinOrGroupJoinOp@7616(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> detector, SynExpr e);
    internal static SynExpr arbKeySelectors@7635(range m);
    internal static FSharpOption`1<Tuple`5<Ident, SynPat, SynExpr, SynExpr, range>> |JoinExpr|_|@7637(cenv cenv, SyntacticUnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, TcEnv env, SynExpr e);
    internal static FSharpOption`1<Tuple`6<Ident, SynPat, SynExpr, SynExpr, SynPat, range>> |GroupJoinExpr|_|@7648(cenv cenv, SyntacticUnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, SynExpr e);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`6<Ident, SynPat, SynExpr, FSharpOption`1<SynExpr>, FSharpOption`1<SynPat>, range>> |JoinOrGroupJoinOrZipClause|_|$cont@7663(IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, SynExpr e, Unit unitVar);
    internal static FSharpOption`1<Tuple`6<Ident, SynPat, SynExpr, FSharpOption`1<SynExpr>, FSharpOption`1<SynPat>, range>> |JoinOrGroupJoinOrZipClause|_|@7662(cenv cenv, SyntacticUnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, SynExpr e);
    internal static FSharpOption`1<Tuple`8<bool, SynPat, SynExpr, Ident, SynPat, SynExpr, FSharpOption`1<SynExpr>, Tuple`3<FSharpOption`1<SynPat>, range, SynExpr>>> |ForEachThenJoinOrGroupJoinOrZipClause|_|@7690(cenv cenv, SyntacticUnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, SynExpr e);
    internal static Tuple`2<SynExpr, FSharpList`1<SynExpr>> strip@7710-1(SynExpr e);
    internal static Tuple`2<SynExpr, FSharpList`1<SynExpr>> |StripApps|@7709(SynExpr e);
    internal static Tuple`2<SynExpr, FSharpOption`1<Tuple`2<range, SynPat>>> |OptionalIntoSuffix|@7720(SynExpr e);
    internal static FSharpOption`1<Tuple`5<Ident, Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>, SynExpr, range, FSharpOption`1<SynPat>>> |CustomOperationClause|_|@7725(cenv cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, TcEnv env, SynExpr e);
    internal static SynExpr mkExprForVarSpace@7742(range m, FSharpList`1<Val> patvs);
    internal static SynSimplePats mkSimplePatForVarSpace@7748(range m, FSharpList`1<Val> patvs);
    internal static SynPat mkPatForVarSpace@7756(range m, FSharpList`1<Val> patvs);
    internal static Tuple`2<SynExpr, FSharpOption`1<SynExpr>> |OptionalSequential|@7762(SynExpr e);
    internal static bool checkForBinaryApp@7768(cenv cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, SynExpr comp);
    internal static LazyWithContext`2<Tuple`2<FSharpList`1<Val>, a2>, range> addVarsToVarSpace@7786(LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpace, FSharpFunc`2<range, FSharpFunc`2<TcEnv, Tuple`2<FSharpList`1<Val>, a2>>> f);
    internal static FSharpFunc`2<SynExpr, SynExpr> mkJoinExpr@7870(string builderValName, range mOpCore, SynExpr firstSource, SynExpr secondSource, SynSimplePats firstSourceSimplePats, SynSimplePats secondSourceSimplePats, MethInfo methInfo, SynExpr keySelector1, SynExpr keySelector2, SynSimplePats innerPat);
    internal static SynExpr wrapInArbErrSequence@7899(SynExpr l, string caption);
    internal static bool isNullableOp@7903(string opId);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<SynExpr, SynExpr>, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range>> tryTrans$cont@7908-2(cenv cenv, string builderValName, TcEnv env, Ident nm, range mOpCore, SynExpr firstSource, SynExpr secondSource, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpaceWithGroupJoinVars, SynSimplePats firstSourceSimplePats, SynSimplePats secondSourceSimplePats, MethInfo methInfo, SynPat secondResultPat, SynExpr relExpr, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<SynExpr, SynExpr>, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range>> tryTrans$cont@7932-3(cenv cenv, string builderValName, TcEnv env, Ident nm, range mOpCore, SynExpr firstSource, SynExpr secondSource, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpaceWithSecondVars, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpaceWithGroupJoinVars, SynSimplePats firstSourceSimplePats, SynSimplePats secondSourceSimplePats, MethInfo methInfo, SynExpr relExpr, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@7864-1(cenv cenv, TType builderTy, SyntacticUnscopedTyparEnv tpenv, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> emptyVarSpace, bool q, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, FSharpOption`1<SynPat> secondResultPatOpt, Ident nm, range mOpCore, FSharpOption`1<SynExpr> keySelectorsOpt, SynExpr innerComp, SynExpr firstSource, SynExpr secondSource, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpaceWithSecondVars, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpaceWithGroupJoinVars, SynSimplePats firstSourceSimplePats, SynSimplePats secondSourceSimplePats, FSharpOption`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@7826(cenv cenv, TType builderTy, SyntacticUnscopedTyparEnv tpenv, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> emptyVarSpace, bool q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpace, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, SynPat secondSourcePat, SynExpr secondSource, FSharpOption`1<SynPat> secondResultPatOpt, Ident nm, range mOpCore, FSharpOption`1<SynExpr> keySelectorsOpt, bool isFromSource, SynExpr innerComp, SynPat firstSourcePat, SynExpr firstSource, Unit unitVar);
    internal static SynExpr consumeClauses@8046(cenv cenv, TType builderTy, SyntacticUnscopedTyparEnv tpenv, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> emptyVarSpace, bool q, SynExpr comp, range mClause, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpace, SynExpr dataCompPrior, SynExpr compClausesExpr, bool lastUsesBind);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@8163-4(cenv cenv, TType builderTy, SyntacticUnscopedTyparEnv tpenv, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> emptyVarSpace, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, range m, SynExpr innerComp2, SynExpr innerComp1, FSharpOption`1<SynExpr> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@8265-5(cenv cenv, TType builderTy, SyntacticUnscopedTyparEnv tpenv, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> emptyVarSpace, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, SequencePointInfoForBinding spBind, SynExpr rhsExpr, SynPat pat, bool isFromSource, SynExpr innerComp, Ident id, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@8295-6(cenv cenv, TType builderTy, SyntacticUnscopedTyparEnv tpenv, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> emptyVarSpace, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, SequencePointInfoForTry spTry, range mTryToLast, SynExpr innerComp, FSharpList`1<SynMatchClause> clauses, Unit unitVar);
    internal static FSharpOption`1<SynExpr> tryTrans@7802(cenv cenv, TType builderTy, SyntacticUnscopedTyparEnv tpenv, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> emptyVarSpace, bool firstTry, bool q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpace, SynExpr comp, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt);
    internal static SynExpr transNoQueryOps@8327(cenv cenv, TType builderTy, SyntacticUnscopedTyparEnv tpenv, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> emptyVarSpace, SynExpr comp);
    internal static SynExpr trans@8328-2(cenv cenv, TType builderTy, SyntacticUnscopedTyparEnv tpenv, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> emptyVarSpace, bool firstTry, bool q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, range> varSpace, SynExpr comp, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcComputationExpression(cenv cenv, TcEnv env, TType overallTy, range mWhole, Expr interpExpr, TType builderTy, SyntacticUnscopedTyparEnv tpenv, SynExpr comp);
    internal static Expr mkDelayedExpr@8408(cenv cenv, TcEnv env, Expr coreExpr);
    internal static FSharpOption`1<Tuple`2<Expr, SyntacticUnscopedTyparEnv>> tryTcSequenceExprBody@8413(cenv cenv, TcEnv env, TType overallTy, range m, bool flex, TcEnv env@8413, TType genOuterTy, SyntacticUnscopedTyparEnv tpenv, SynExpr comp);
    internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> tcSequenceExprBody@8562(cenv cenv, TcEnv env, TType overallTy, range m, bool flex, TcEnv env@8562-1, TType genOuterTy, SyntacticUnscopedTyparEnv tpenv, SynExpr comp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcSequenceExpression(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr comp, TType overallTy, range m);
    internal static void propagate@8588(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, ApplicableExpr expr, FSharpList`1<DelayedItem> delayed, bool isAddrOf, FSharpList`1<DelayedItem> delayedList, range mExpr, TType exprty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void Propagate(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, ApplicableExpr expr, TType exprty, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> PropagateThenTcDelayed(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mExpr, ApplicableExpr expr, TType exprty, ExprAtomicFlag atomicFlag, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcDelayed(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mExpr, ApplicableExpr expr, TType exprty, ExprAtomicFlag atomicFlag, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<DelayedItem> delayRest(FSharpList`1<Ident> rest, range mPrior, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcFunctionApplicationThen(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mExprAndArg, ApplicableExpr expr, TType exprty, SynExpr synArg, ExprAtomicFlag atomicFlag, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcLongIdentThen(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, LongIdentWithDots _arg4, FSharpList`1<DelayedItem> delayed);
    internal static FSharpFunc`2<a2, FSharpFunc`2<FSharpList`1<a3>, a3>> mkConstrApp@8791(range mItem);
    internal static FSharpOption`1<FSharpList`1<SynExpr>> |FittedArgs|_|@8804(int numArgTys, SynExpr arg);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynExpr> args$cont@8831-3(cenv cenv, TcEnv env, TcGlobals g, AccessorDomain ad, Item item, FSharpList`1<TType> argTys, FSharpList`1<Ident> argNames, int numArgTys, FSharpList`1<SynExpr> args, FSharpList`1<SynExpr> unnamedArgs, FSharpList`1<Tuple`3<bool, Ident, SynExpr>> namedCallerArgs, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcItemThen$cont@8969(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mItem, AfterResolution afterResolution, AccessorDomain ad, FSharpList`1<MethInfo> minfos, string methodName, FSharpList`1<DelayedItem> otherDelayed, range mExprAndTypeArgs, FSharpOption`1<MethInfo> matchValue, Unit unitVar);
    internal static bool isSimpleArgument@9081(SynExpr e);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcItemThen$cont@9243-2(cenv cenv, TType overallTy, TcEnv env, range mItem, AfterResolution afterResolution, TcGlobals g, AccessorDomain ad, FSharpList`1<PropInfo> pinfos, string nm, PropInfo pinfo, FSharpOption`1<FSharpList`1<TType>> tyargsOpt, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<DelayedItem> delayed, FSharpList`1<SynExpr> args, FSharpList`1<DelayedItem> otherDelayed, range mStmt, SynExpr e2, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcItemThen$cont@9232-1(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mItem, AfterResolution afterResolution, TcGlobals g, FSharpList`1<DelayedItem> delayed, AccessorDomain ad, FSharpList`1<PropInfo> pinfos, string nm, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcItemThen(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, Item item, range mItem, FSharpList`1<Ident> rest, AfterResolution afterResolution, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<ExprAtomicFlag, FSharpOption`1<Tuple`2<FSharpList`1<SynType>, range>>, FSharpList`1<SynExpr>, FSharpList`1<DelayedItem>, h> GetSynMemberApplicationArgs(FSharpList`1<DelayedItem> delayed, h tpenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<FSharpList`1<TType>>, SyntacticUnscopedTyparEnv> TcMemberTyArgsOpt(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpOption`1<Tuple`2<FSharpList`1<SynType>, range>> tyargsOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<ExprAtomicFlag, FSharpOption`1<FSharpList`1<TType>>, FSharpList`1<SynExpr>, FSharpList`1<DelayedItem>, SyntacticUnscopedTyparEnv> GetMemberApplicationArgs(FSharpList`1<DelayedItem> delayed, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcLookupThen$cont@9428(cenv cenv, TType overallTy, TcEnv env, Expr objExpr, FSharpList`1<Expr> objArgs, AccessorDomain ad, range mItem, AfterResolution afterResolution, range mExprAndItem, FSharpList`1<PropInfo> pinfos, string nm, PropInfo pinfo, FSharpOption`1<FSharpList`1<TType>> tyargsOpt, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<DelayedItem> delayed, ExprAtomicFlag atomicFlag, FSharpList`1<SynExpr> args, FSharpList`1<DelayedItem> otherDelayed, range mStmt, SynExpr e2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcLookupThen(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mObjExpr, Expr objExpr, TType objExprTy, FSharpList`1<Ident> longId, FSharpList`1<DelayedItem> delayed, range mExprAndLongId);
    internal static Expr bindObjArgs@9530(range mItem, FSharpOption`1<Tuple`2<Expr, TType>> objDetails, FSharpFunc`2<FSharpList`1<Expr>, Expr> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcEventValueThen(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mItem, range mExprAndItem, FSharpOption`1<Tuple`2<Expr, TType>> objDetails, EventInfo einfo, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcMethodApplicationThen(cenv cenv, TcEnv env, TType overallTy, FSharpOption`1<TType> objTyOpt, SyntacticUnscopedTyparEnv tpenv, FSharpOption`1<FSharpList`1<TType>> callerTyArgs, FSharpList`1<Expr> objArgs, range m, range mItem, string methodName, AccessorDomain ad, Mutates mut, bool isProp, FSharpList`1<Tuple`2<MethInfo, FSharpOption`1<PropInfo>>> meths, AfterResolution afterResolution, ValUseFlag isSuperInit, FSharpList`1<SynExpr> args, ExprAtomicFlag atomicFlag, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType GetNewInferenceTypeForMethodArg(cenv cenv, i env, j tpenv, SynExpr x);
    internal static bool isSimpleFormalArg@9642(Tuple`6<bool, a2, bool, OptionalArgInfo, CallerInfo, ReflectedArgInfo> tupledArg);
    internal static Tuple`3<SynExpr, TType, range> MakeUnnamedCallerArgInfo@9692(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynExpr x);
    internal static FSharpFunc`2<MethInfo, bool> CalledMethHasSingleArgumentGroupOfThisLength@9744(cenv cenv, range mItem, int n);
    internal static FSharpList`1<FSharpList`1<TType>> GenerateMatchingSimpleArgumentTypes@9749(cenv cenv, range mItem, FSharpTypeFunc isSimpleFormalArg, MethInfo calledMeth);
    internal static Tuple`2<FSharpList`1<FSharpList`1<TType>>, TType> UnifyMatchingSimpleArgumentTypes@9754(cenv cenv, TcEnv env, range mMethExpr, range mItem, DisplayEnv denv, FSharpTypeFunc isSimpleFormalArg, TType exprTy, MethInfo calledMeth);
    internal static CalledMeth`1<SynExpr> makeOneCalledMeth@9818(bool isCheckingAttributeCall, cenv cenv, TcEnv env, FSharpOption`1<FSharpList`1<TType>> tyargsOpt, range mMethExpr, range mItem, FSharpOption`1<TType> objTyOpt, AccessorDomain ad, FSharpList`1<TType> callerObjArgTys, FSharpList`1<Tuple`2<FSharpList`1<CallerArg`1<SynExpr>>, FSharpList`1<CallerNamedArg`1<SynExpr>>>> callerArgs, MethInfo tupledArg0, FSharpOption`1<PropInfo> tupledArg1, bool tupledArg2);
    [CompilerGeneratedAttribute]
internal static Tuple`5<FSharpList`1<FSharpList`1<CallerArg`1<Expr>>>, FSharpList`1<FSharpList`1<CallerNamedArg`1<Expr>>>, FSharpOption`1<FSharpList`1<FSharpList`1<Val>>>, TType, SyntacticUnscopedTyparEnv> TcMethodApplication$cont@9846(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mMethExpr, range mItem, DisplayEnv denv, FSharpTypeFunc isSimpleFormalArg, FSharpList`1<MethInfo> candidates, TType exprTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void finalCalledMeth$cont@9946(cenv cenv, Item unrefinedItem, CalledMeth`1<Expr> result, FSharpFunc`2<Tuple`3<MethInfo, FSharpOption`1<PropInfo>, FSharpList`1<Tuple`2<Typar, TType>>>, Unit> callSink, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`3<Expr, FSharpList`1<CallerNamedArg`1<Expr>>, FSharpList`1<DelayedItem>>, SyntacticUnscopedTyparEnv> TcMethodApplication(bool isCheckingAttributeCall, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpOption`1<FSharpList`1<TType>> tyargsOpt, FSharpList`1<Expr> objArgs, range mMethExpr, range mItem, string methodName, FSharpOption`1<TType> objTyOpt, AccessorDomain ad, Mutates mut, bool isProp, FSharpList`1<Tuple`2<MethInfo, FSharpOption`1<PropInfo>>> calledMethsAndProps, AfterResolution afterResolution, ValUseFlag isSuperInit, FSharpList`1<SynExpr> curriedCallerArgs, TType exprTy, FSharpList`1<DelayedItem> delayed);
    [CompilerGeneratedAttribute]
internal static Tuple`3<FSharpOption`1<FSharpFunc`2<Expr, Expr>>, Expr, Item> TcSetterArgExpr$cont@10131(cenv cenv, TcEnv env, Expr objExpr, AccessorDomain ad, AssignedItemSetterTarget setter, range m, TType callerArgTy, Expr argExpr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpOption`1<FSharpFunc`2<Expr, Expr>>, Expr, range> TcSetterArgExpr(cenv cenv, TcEnv env, DisplayEnv denv, Expr objExpr, AccessorDomain ad, AssignedItemSetter`1<Expr> _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<CallerArg`1<Expr>>>, Tuple`2<Tuple`2[], SyntacticUnscopedTyparEnv>> TcUnnamedMethodArgs(cenv cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<FSharpList`1<CallerArg`1<SynExpr>>> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CallerArg`1<Expr>, Tuple`2<Tuple`2[], SyntacticUnscopedTyparEnv>> TcUnnamedMethodArg(cenv cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, SyntacticUnscopedTyparEnv tpenv, int i, int j, CallerArg`1<SynExpr> _arg6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<CallerNamedArg`1<Expr>>>, Tuple`2<Tuple`2[], SyntacticUnscopedTyparEnv>> TcMethodNamedArgs(cenv cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<FSharpList`1<CallerNamedArg`1<SynExpr>>> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CallerNamedArg`1<Expr>, Tuple`2<Tuple`2[], SyntacticUnscopedTyparEnv>> TcMethodNamedArg(cenv cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, SyntacticUnscopedTyparEnv tpenv, CallerNamedArg`1<SynExpr> _arg7);
    internal static void loop@10206-74(cenv cenv, TcEnv env, range mArg, TType[][] prefixOfLambdaArgsForEachOverload, int numLambdaVars, TType callerLambdaTy, int lambdaVarNum);
    [CompilerGeneratedAttribute]
internal static void TcMethodArg$cont@10196(cenv cenv, TcEnv env, ArgumentAnalysis[] lambdaPropagationInfoForArg, range mArg, TType argTy, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CallerArg`1<Expr>, Tuple`2<Tuple`2[], SyntacticUnscopedTyparEnv>> TcMethodArg(cenv cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, SyntacticUnscopedTyparEnv tpenv, ArgumentAnalysis[] lambdaPropagationInfoForArg, CallerArg`1<SynExpr> _arg8);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcNewDelegateThen(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, range mDelTy, range mExprAndArg, TType delegateTy, SynExpr arg, ExprAtomicFlag atomicFlag, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr bindLetRec(FSharpList`1<Binding> binds, range m, Expr e);
    internal static void CheckRecursiveBindingIds(IEnumerable`1<SynBinding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> TcLinearExprs(FSharpFunc`2<TType, FSharpFunc`2<TcEnv, FSharpFunc`2<SyntacticUnscopedTyparEnv, FSharpFunc`2<SynExpr, Tuple`2<Expr, SyntacticUnscopedTyparEnv>>>>> bodyChecker, cenv cenv, TcEnv env, TType overallTy, SyntacticUnscopedTyparEnv tpenv, bool isCompExpr, SynExpr expr, FSharpFunc`2<Tuple`2<Expr, SyntacticUnscopedTyparEnv>, Tuple`2<Expr, SyntacticUnscopedTyparEnv>> cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Expr, SyntacticUnscopedTyparEnv> TcAndPatternCompileMatchClauses(range mExpr, range matchm, ActionOnFailure actionOnFailure, cenv cenv, FSharpOption`1<Expr> inputExprOpt, TType inputTy, TType resultTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<SynMatchClause> synClauses);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<Pattern, FSharpOption`1<Expr>, FSharpList`1<Val>, TcEnv, SyntacticUnscopedTyparEnv> TcMatchPattern(cenv cenv, TType inputTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynPat pat, FSharpOption`1<SynExpr> optWhenExpr);
    internal static bool isFirst@10361(FSharpRef`1<bool> first, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TypedMatchClause>, SyntacticUnscopedTyparEnv> TcMatchClauses(cenv cenv, TType inputTy, TType resultTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<SynMatchClause> clauses);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TypedMatchClause, SyntacticUnscopedTyparEnv> TcMatchClause(cenv cenv, TType inputTy, TType resultTy, TcEnv env, bool isFirst, SyntacticUnscopedTyparEnv tpenv, SynMatchClause _arg9);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<StaticOptimization, SyntacticUnscopedTyparEnv> TcStaticOptimizationConstraint(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynStaticOptimizationConstraint c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkConvToNativeInt(TcGlobals g, Expr e, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr TcAndBuildFixedExpr(cenv cenv, TcEnv env, TType overallPatTy, Expr fixedExpr, TType overallExprTy, range mBinding);
    internal static FSharpList`1<Attrib> TcAttrs@10497(cenv cenv, range mBinding, TcEnv envinner, AttributeTargets attrTgt, AttributeTargets tgt, FSharpList`1<SynAttribute> attrs);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, SyntacticUnscopedTyparEnv> f@514-18(cenv cenv, FSharpOption`1<Val> safeThisValOpt, SafeInitData safeInitInfo, SynExpr rhsExpr, TType overallExprTy, SyntacticUnscopedTyparEnv tpenv, TcEnv envinner, bool isCtor, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CheckedBindingInfo, SyntacticUnscopedTyparEnv> TcNormalizedBinding(DeclKind declKind, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, TType overallTy, FSharpOption`1<Val> safeThisValOpt, SafeInitData safeInitInfo, FSharpList`1<Typar> enclosingDeclaredTypars, ExplicitTyparInfo _arg10, NormalizedBinding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, FSharpOption`1<Const>> TcLiteral(cenv cenv, TType overallTy, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<Attrib> attrs, SynExpr synLiteralValExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ExplicitTyparInfo, SyntacticUnscopedTyparEnv> TcBindingTyparDecls(bool alwaysRigid, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, SynValTyparDecls _arg11);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ExplicitTyparInfo, SyntacticUnscopedTyparEnv> TcNonrecBindingTyparDecls(cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, NormalizedBinding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CheckedBindingInfo, SyntacticUnscopedTyparEnv> TcNonRecursiveBinding(DeclKind declKind, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, TType ty, SynBinding b);
    internal static ResultOrException`1<Tuple`2<TType, SyntacticUnscopedTyparEnv>> try1@10708(cenv cenv, TcEnv env, range mAttr, FSharpList`1<Ident> typath, Ident tyid, string n);
    [CompilerGeneratedAttribute]
internal static bool contains@1-4(a e, FSharpList`1<a> xs1);
    [CompilerGeneratedAttribute]
internal static Tuple`2<int, bool> TcAttribute$cont@10734(cenv cenv, EntityRef tcref, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<int, bool> TcAttribute$cont@10749-1(cenv cenv, range mAttr, EntityRef tcref, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static AttributeTargets directedTgts$cont@10763-1(FSharpOption`1<Ident> targetIndicator, AttributeTargets possibleTgts, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static AttributeTargets directedTgts$cont@10763(FSharpOption`1<Ident> targetIndicator, AttributeTargets possibleTgts, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<AttributeTargets, Attrib>>, bool> TcAttribute(bool canFail, cenv cenv, TcEnv env, AttributeTargets attrTgt, SynAttribute synAttr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<AttributeTargets, Attrib>>, bool> TcAttributesWithPossibleTargets(bool canFail, cenv cenv, TcEnv env, AttributeTargets attrTgt, FSharpList`1<SynAttribute> synAttribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Attrib>, bool> TcAttributesMaybeFail(bool canFail, cenv cenv, TcEnv env, AttributeTargets attrTgt, FSharpList`1<SynAttribute> synAttribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Attrib>, FSharpFunc`2<Unit, FSharpList`1<Attrib>>> TcAttributesCanFail(cenv cenv, TcEnv env, AttributeTargets attrTgt, FSharpList`1<SynAttribute> synAttribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Attrib> TcAttributes(cenv cenv, TcEnv env, AttributeTargets attrTgt, FSharpList`1<SynAttribute> synAttribs);
    internal static Tuple`2<Expr, a2> mkRhsBind@10976(SequencePointInfoForBinding spBind, range m, Expr rhsExpr, Val patternInputTmp, Tuple`2<Expr, a2> tupledArg);
    internal static Tuple`2<Expr, TType> mkPatBind@10983(cenv cenv, DeclKind declKind, ParentRef altActualParent, TcEnv env, TType tauTy, range m, FSharpList`1<Typar> generalizedTypars, Expr rhsExpr, Val patternInputTmp, Pattern checkedPat2, FSharpList`1<Val> allValsDefinedByPattern, Expr tupledArg0, TType tupledArg1);
    internal static Tuple`2<Expr, TType> mkCleanup@10991(cenv cenv, bool isUse, DisplayEnv denv, TcEnv env, range m, bool isFixed, FSharpList`1<Val> allValsDefinedByPattern, Expr tupledArg0, TType tupledArg1);
    internal static Tuple`2<Expr, a2> mkSequentialBind@10944(range m, Expr rhsExpr, Tuple`2<Expr, a2> tupledArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpFunc`2<Tuple`2<Expr, TType>, Tuple`2<Expr, TType>>, TcEnv, SyntacticUnscopedTyparEnv> TcLetBinding(cenv cenv, bool isUse, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<SynBinding> synBinds, range synBindsRange, range scopem);
    internal static FSharpList`1<ModuleOrNamespaceExpr> stripLets@11017(FSharpList`1<ModuleOrNamespaceExpr> acc, Expr _arg31);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<ModuleOrNamespaceExpr>, TcEnv, SyntacticUnscopedTyparEnv> TcLetBindings(cenv cenv, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<SynBinding> binds, range bindsm, range scopem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMemberFlags(FSharpOption`1<k> optIntfSlotTy, NewSlotsOK newslotsOK, OverridesOK overridesOK, MemberFlags memberFlags, range m);
    internal static void ApplyTypesFromArgumentPatterns(cenv cenv, TcEnv env, bool optArgsOK, TType ty, range m, SyntacticUnscopedTyparEnv tpenv, NormalizedBindingRhs _arg12, FSharpOption`1<MemberFlags> memberFlagsOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ComputeIsComplete(FSharpList`1<Typar> enclosingDeclaredTypars, FSharpList`1<Typar> declaredTypars, TType ty);
    internal static bool methInfosEquivByNameAndSig@11089(cenv cenv, range m, FSharpList`1<MethInfo> meths);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<TType>, FSharpList`1<Typar>> ApplyAbstractSlotInference$cont@11097-1(cenv cenv, TcEnv envinner, TType bindingTy, range m, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, Ident memberId, FSharpList`1<Tuple`2<Typar, TType>> renaming, FSharpOption`1<Tuple`2<TType, SlotImplSet>> optIntfSlotTy, SynValInfo valSynData, AccessorDomain ad, Tuple`2<TType, FSharpOption`1<SlotImplSet>> typToSearchForAbstractMembers, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<TType>, FSharpList`1<Typar>> ApplyAbstractSlotInference$cont@11089(cenv cenv, TcEnv envinner, TType bindingTy, range m, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, Ident memberId, FSharpList`1<Tuple`2<Typar, TType>> renaming, FSharpOption`1<Tuple`2<TType, SlotImplSet>> optIntfSlotTy, SynValInfo valSynData, MemberFlags memberFlags, FSharpList`1<Attrib> attribs, AccessorDomain ad, Tuple`2<TType, FSharpOption`1<SlotImplSet>> typToSearchForAbstractMembers, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, FSharpList`1<Typar>> ApplyAbstractSlotInference(cenv cenv, TcEnv envinner, TType bindingTy, range m, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, Ident memberId, TType tcrefObjTy, FSharpList`1<Tuple`2<Typar, TType>> renaming, l _objTy, FSharpOption`1<Tuple`2<TType, SlotImplSet>> optIntfSlotTy, SynValInfo valSynData, MemberFlags memberFlags, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForNonAbstractInterface(DeclKind declKind, EntityRef tcref, MemberFlags memberFlags, range m);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpOption`1<Val>, FSharpOption`1<Val>> AnalyzeRecursiveStaticMemberOrValDecl$cont@11275(cenv cenv, Ident id, FSharpOption`1<Ident> thisIdOpt, SynValInfo valSynInfo, TType ty, range mBinding, EntityRef tcref, FSharpOption`1<Val> baseValOpt, TType thisTy, TType objTy, TcEnv envinner, Unit unitVar);
    internal static Tuple`8<TcEnv, m, Ident, FSharpOption`1<r>, FSharpOption`1<ValMemberInfoTransient>, FSharpOption`1<n>, FSharpOption`1<n>, Tuple`6<FSharpOption`1<Val>, FSharpList`1<Typar>, FSharpOption`1<Val>, q, p, o>> AnalyzeRecursiveStaticMemberOrValDecl(cenv cenv, TcEnv envinner, m tpenv, DeclKind declKind, NewSlotsOK newslotsOK, OverridesOK overridesOK, FSharpOption`1<MemberOrValContainerInfo> tcrefContainerInfo, FSharpOption`1<n> vis1, Ident id, FSharpOption`1<n> vis2, o declaredTypars, FSharpOption`1<MemberFlags> memberFlagsOpt, FSharpOption`1<Ident> thisIdOpt, FSharpList`1<Attrib> bindingAttribs, SynValInfo valSynInfo, TType ty, p bindingRhs, range mBinding, q flex);
    internal static Tuple`8<TcEnv, s, Ident, FSharpOption`1<Ident>, FSharpOption`1<ValMemberInfoTransient>, FSharpOption`1<t>, FSharpOption`1<t>, Tuple`6<FSharpOption`1<a1>, FSharpList`1<Typar>, FSharpOption`1<Val>, ExplicitTyparInfo, NormalizedBindingRhs, FSharpList`1<Typar>>> AnalyzeRecursiveInstanceMemberDecl(cenv cenv, TcEnv envinner, s tpenv, DeclKind declKind, SynValTyparDecls synTyparDecls, SynValInfo valSynInfo, ExplicitTyparInfo flex, NewSlotsOK newslotsOK, OverridesOK overridesOK, FSharpOption`1<t> vis1, Ident thisId, Ident memberId, FSharpOption`1<Ident> toolId, FSharpList`1<Attrib> bindingAttribs, FSharpOption`1<t> vis2, FSharpOption`1<MemberOrValContainerInfo> tcrefContainerInfo, FSharpOption`1<MemberFlags> memberFlagsOpt, TType ty, NormalizedBindingRhs bindingRhs, range mBinding);
    internal static Tuple`8<TcEnv, SyntacticUnscopedTyparEnv, Ident, FSharpOption`1<Ident>, FSharpOption`1<ValMemberInfoTransient>, FSharpOption`1<SynAccess>, FSharpOption`1<SynAccess>, Tuple`6<FSharpOption`1<Val>, FSharpList`1<Typar>, FSharpOption`1<Val>, ExplicitTyparInfo, NormalizedBindingRhs, FSharpList`1<Typar>>> analyzeRecursiveDeclPat@11381(cenv cenv, TcEnv envinner, DeclKind declKind, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, FSharpOption`1<Ident> thisIdOpt, SynValInfo valSynInfo, ExplicitTyparInfo flex, NewSlotsOK newslotsOK, OverridesOK overridesOK, FSharpOption`1<SynAccess> vis1, FSharpList`1<Attrib> bindingAttribs, FSharpOption`1<MemberOrValContainerInfo> tcrefContainerInfo, FSharpOption`1<MemberFlags> memberFlagsOpt, TType ty, NormalizedBindingRhs bindingRhs, range mBinding, SyntacticUnscopedTyparEnv tpenv, SynPat p);
    internal static Tuple`8<TcEnv, SyntacticUnscopedTyparEnv, Ident, FSharpOption`1<Ident>, FSharpOption`1<ValMemberInfoTransient>, FSharpOption`1<SynAccess>, FSharpOption`1<SynAccess>, Tuple`6<FSharpOption`1<Val>, FSharpList`1<Typar>, FSharpOption`1<Val>, ExplicitTyparInfo, NormalizedBindingRhs, FSharpList`1<Typar>>> AnalyzeRecursiveDecl(cenv cenv, TcEnv envinner, SyntacticUnscopedTyparEnv tpenv, DeclKind declKind, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, FSharpOption`1<Ident> thisIdOpt, SynValInfo valSynInfo, ExplicitTyparInfo flex, NewSlotsOK newslotsOK, OverridesOK overridesOK, FSharpOption`1<SynAccess> vis1, SynPat declPattern, FSharpList`1<Attrib> bindingAttribs, FSharpOption`1<MemberOrValContainerInfo> tcrefContainerInfo, FSharpOption`1<MemberFlags> memberFlagsOpt, TType ty, NormalizedBindingRhs bindingRhs, range mBinding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpList`1<PreCheckingRecursiveBinding>, FSharpList`1<Val>>, Tuple`2<SyntacticUnscopedTyparEnv, int>> AnalyzeAndMakeAndPublishRecursiveValue(OverridesOK overridesOK, bool isGeneratedEventVal, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, int recBindIdx, NormalizedRecBindingDefn _arg13);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<PreCheckingRecursiveBinding>, FSharpList`1<Val>, Tuple`2<SyntacticUnscopedTyparEnv, int>> AnalyzeAndMakeAndPublishRecursiveValues(OverridesOK overridesOK, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<NormalizedRecBindingDefn> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<TcEnv, FSharpList`1<PostGeneralizationRecursiveBinding>, FSharpList`1<PreGeneralizationRecursiveBinding>, SyntacticUnscopedTyparEnv, FSharpMap`2<long, PreCheckingRecursiveBinding>> TcLetrecBinding(cenv cenv, TcEnv envRec, range scopem, FSharpList`1<Typar> extraGeneralizableTypars, FSharpOption`1<TType> reqdThisValTyOpt, TcEnv envNonRec, FSharpList`1<PostGeneralizationRecursiveBinding> generalizedRecBinds, FSharpList`1<PreGeneralizationRecursiveBinding> preGeneralizationRecBinds, SyntacticUnscopedTyparEnv tpenv, FSharpMap`2<long, PreCheckingRecursiveBinding> uncheckedRecBindsTable, PreCheckingRecursiveBinding rbind);
    internal static Tuple`2<FSharpList`1<PreGeneralizationRecursiveBinding>, FSharpList`1<PreGeneralizationRecursiveBinding>> loop@11668-76(cenv cenv, Set`2<Typar, IComparer`1<Typar>> freeInEnv, Lazy`1<FreeTyvars> freeInUncheckedRecBinds, FSharpList`1<PreGeneralizationRecursiveBinding> tupledArg0, FSharpList`1<PreGeneralizationRecursiveBinding> tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<TcEnv, FSharpList`1<PostGeneralizationRecursiveBinding>, FSharpList`1<PreGeneralizationRecursiveBinding>, SyntacticUnscopedTyparEnv, FSharpMap`2<long, PreCheckingRecursiveBinding>> TcIncrementalLetRecGeneralization(cenv cenv, range scopem, TcEnv envNonRec, FSharpList`1<PostGeneralizationRecursiveBinding> generalizedRecBinds, FSharpList`1<PreGeneralizationRecursiveBinding> preGeneralizationRecBinds, SyntacticUnscopedTyparEnv tpenv, FSharpMap`2<long, PreCheckingRecursiveBinding> uncheckedRecBindsTable);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> TcLetrecComputeAndGeneralizeGenericTyparsForBinding(cenv cenv, DisplayEnv denv, Set`2<Typar, IComparer`1<Typar>> freeInEnv, PreGeneralizationRecursiveBinding pgrbind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> TcLetrecComputeSupportForBinding(cenv cenv, PreGeneralizationRecursiveBinding pgrbind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PostGeneralizationRecursiveBinding TcLetrecGeneralizeBinding(cenv cenv, DisplayEnv denv, FSharpList`1<Typar> generalizedTypars, PreGeneralizationRecursiveBinding pgrbind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Binding> TcLetrecComputeCtorSafeThisValBind(cenv cenv, FSharpOption`1<Val> safeThisValOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeCheckSafeInitField(TcGlobals g, FSharpList`1<TType> tinst, FSharpOption`1<Val> thisValOpt, RecdFieldRef rfref, Expr reqExpr, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeCheckSafeInit(TcGlobals g, FSharpList`1<TType> tinst, SafeInitData safeInitInfo, Expr reqExpr, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PostBindCtorThisVarRefCellRecursiveBinding TcLetrecAdjustMemberForSpecialVals(cenv cenv, PostGeneralizationRecursiveBinding pgrbind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PreInitializationGraphEliminationBinding FixupLetrecBind(cenv cenv, DisplayEnv denv, FSharpList`1<Typar> generalizedTyparsForRecursiveBlock, PostBindCtorThisVarRefCellRecursiveBinding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<Binding>, TcEnv, SyntacticUnscopedTyparEnv> TcLetrec(OverridesOK overridesOK, cenv cenv, TcEnv env, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<RecDefnBindingInfo> binds, range bindsm, range scopem);
    internal static Tuple`2<FSharpList`1<Val>, SyntacticUnscopedTyparEnv> TcAndPublishValSpec(cenv cenv, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, FSharpOption`1<MemberFlags> memFlagsOpt, SyntacticUnscopedTyparEnv tpenv, SynValSig valSpfn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckNamespaceModuleOrTypeName(TcGlobals g, Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> CheckDuplicates(FSharpFunc`2<a, Ident> idf, string k, FSharpList`1<a> elems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishInterface(cenv cenv, DisplayEnv denv, EntityRef tcref, range m, bool compgen, TType ty');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, SyntacticUnscopedTyparEnv> TcAndPublishMemberSpec(cenv cenv, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, SyntacticUnscopedTyparEnv tpenv, SynMemberSig memb);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, SyntacticUnscopedTyparEnv> TcTyconMemberSpecs(cenv cenv, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, SyntacticUnscopedTyparEnv tpenv, FSharpList`1<SynMemberSig> augSpfn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>> TcModuleOrNamespaceLidAndPermitAutoResolve(TcResultsSink tcSink, TcEnv env, ImportMap amap, FSharpList`1<Ident> longId);
    internal static bool IsPartiallyQualifiedNamespace@12312(TcGlobals g, FSharpList`1<Ident> longId, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv TcOpenDecl(TcResultsSink tcSink, TcGlobals g, ImportMap amap, range m, range scopem, TcEnv env, FSharpList`1<Ident> longId);
    internal static FSharpList`1<Tuple`3<TType, FSharpList`1<SynMemberDefn>, range>> interfacesFromTypeDefn@14041(cenv cenv, TcGlobals g, TcEnv envForTycon, MutRecDefnsPhase2DataForTycon tyconMembersData);
    internal static FSharpFunc`2<Tuple`3<TType, FSharpList`1<SynMemberDefn>, a>, FSharpFunc`2<SlotImplSet, FSharpList`1<TyconBindingDefn>>> interfaceMembersFromTypeDefn@14074(MutRecDefnsPhase2DataForTycon tyconMembersData);
    internal static FSharpList`1<TyconBindingDefn> tyconBindingsOfTypeDefn@14083(MutRecDefnsPhase2DataForTycon _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<MutRecShape`5<Tuple`2<FSharpOption`1<Entity>, FSharpList`1<Binding>>, FSharpList`1<Binding>, Tuple`2<MutRecDefnsPhase2DataForModule, TcEnv>, MutRecDataForModuleAbbrev, MutRecDataForOpen>>, TcEnv> TcMutRecDefns_Phase2(cenv cenv, TcEnv envInitial, range bindsm, range scopem, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, TcEnv envMutRec, FSharpList`1<MutRecShape`5<MutRecDefnsPhase2DataForTycon, FSharpList`1<RecDefnBindingInfo>, Tuple`2<MutRecDefnsPhase2DataForModule, TcEnv>, MutRecDataForModuleAbbrev, MutRecDataForOpen>> mutRecDefns);
    internal static Ident ComputeModuleName(FSharpList`1<Ident> longPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForDuplicateConcreteType(TcEnv env, string nm, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForDuplicateModule(TcEnv env, string nm, range m);
    [CompilerGeneratedAttribute]
internal static Eventually`1<TcEnv> TcSignatureElementNonMutRec$cont@16653(cenv cenv, range endm, TcEnv env, SynModuleSigDecl synSigDecl, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Eventually`1<TcEnv> TcSignatureElementNonMutRec$cont@16679-1(cenv cenv, TcEnv env, SynModuleSigDecl synSigDecl, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<TcEnv> TcSignatureElementNonMutRec(cenv cenv, ParentRef parent, FSharpSet`1<string> typeNames, range endm, TcEnv env, SynModuleSigDecl synSigDecl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<TcEnv> TcSignatureElements(cenv cenv, ParentRef parent, range endm, TcEnv env, PreXmlDoc xml, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, FSharpList`1<SynModuleSigDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<TcEnv> TcSignatureElementsNonMutRec(cenv cenv, ParentRef parent, FSharpSet`1<string> typeNames, range endm, TcEnv env, FSharpList`1<SynModuleSigDecl> defs);
    internal static FSharpList`1<MutRecShape`5<a, b, c, d, MutRecDataForOpen>> decls@16777(range m, FSharpList`1<Ident> lid);
    internal static FSharpList`1<MutRecShape`5<SynTypeDefnSig, a, b, c, d>> decls@16783-1(FSharpList`1<SynMemberSig> members, SynExceptionDefnRepr exnRepr, range m, SynComponentInfo compInfo);
    internal static FSharpList`1<MutRecShape`5<a, SynValSig, b, c, d>> decls@16788-2(SynValSig vspec);
    internal static FSharpList`1<MutRecShape`5<a, b, c, MutRecDataForModuleAbbrev, d>> decls@16802-3(FSharpList`1<Ident> p, range m, Ident id);
    internal static FSharpList`1<MutRecShape`5<SynTypeDefnSig, SynValSig, SynComponentInfo, MutRecDataForModuleAbbrev, MutRecDataForOpen>> loop@16768-80(bool isNamespace, FSharpList`1<SynModuleSigDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<TcEnv> TcSignatureElementsMutRec(cenv cenv, ParentRef parent, FSharpSet`1<string> typeNames, range endm, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, TcEnv envInitial, FSharpList`1<SynModuleSigDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<Tuple`2<ModuleOrNamespaceType, TcEnv>> TcModuleOrNamespaceSignatureElementsNonMutRec(cenv cenv, ParentRef parent, TcEnv env, Ident id, ModuleOrNamespaceKind modKind, FSharpList`1<SynModuleSigDecl> defs, range m, PreXmlDoc xml);
    internal static SynModuleDecl ElimModuleDoBinding(SynModuleDecl bind);
    internal static void checkBinds@16852(Set`2<Val, IComparer`1<Val>> freeInEnv, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TcMutRecDefnsEscapeCheck(FSharpList`1<MutRecShape`5<Tuple`2<FSharpOption`1<Entity>, FSharpList`1<Binding>>, FSharpList`1<Binding>, a, b, c>> binds, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckLetOrDoInNamespace(FSharpList`1<SynBinding> binds, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<Tuple`3<Tuple`2<FSharpFunc`2<FSharpList`1<ModuleOrNamespaceExpr>, FSharpList`1<ModuleOrNamespaceExpr>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>, TcEnv, TcEnv>> TcModuleOrNamespaceElementNonMutRec(cenv cenv, ParentRef parent, FSharpSet`1<string> typeNames, range scopem, TcEnv env, SynModuleDecl synDecl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<Tuple`2<FSharpList`1<Tuple`2<FSharpFunc`2<FSharpList`1<ModuleOrNamespaceExpr>, FSharpList`1<ModuleOrNamespaceExpr>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>>, TcEnv>> TcModuleOrNamespaceElementsNonMutRec(cenv cenv, ParentRef parent, FSharpSet`1<string> typeNames, range endm, FSharpList`1<Tuple`2<FSharpFunc`2<FSharpList`1<ModuleOrNamespaceExpr>, FSharpList`1<ModuleOrNamespaceExpr>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>> defsSoFar, TcEnv env, TcEnv envAtEnd, FSharpList`1<SynModuleDecl> moreDefs);
    internal static FSharpList`1<MutRecShape`5<a, b, c, d, MutRecDataForOpen>> decls@17107-4(range m, FSharpList`1<Ident> lid);
    internal static FSharpList`1<MutRecShape`5<SynTypeDefn, a, b, c, d>> decls@17113-5(SynExceptionDefnRepr repr, FSharpList`1<SynMemberDefn> members, range m, SynComponentInfo compInfo);
    internal static FSharpList`1<MutRecShape`5<a, b, c, MutRecDataForModuleAbbrev, d>> decls@17124-6(FSharpList`1<Ident> p, range m, Ident id);
    internal static Tuple`2<FSharpList`1<MutRecShape`5<SynTypeDefn, FSharpList`1<SynBinding>, SynComponentInfo, MutRecDataForModuleAbbrev, MutRecDataForOpen>>, Tuple`3<bool, bool, FSharpList`1<SynAttributeList>>> loop@17082-84(bool isNamespace, FSharpList`1<SynAttributeList> attrs, FSharpList`1<SynModuleDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<Tuple`3<Tuple`2<FSharpFunc`2<FSharpList`1<ModuleOrNamespaceExpr>, FSharpList`1<ModuleOrNamespaceExpr>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>, TcEnv, TcEnv>> TcModuleOrNamespaceElementsMutRec(cenv cenv, ParentRef parent, FSharpSet`1<string> typeNames, range endm, TcEnv envInitial, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, FSharpList`1<SynModuleDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceExpr TcMutRecDefsFinish(cenv cenv, FSharpList`1<MutRecShape`5<Tuple`2<FSharpOption`1<Entity>, FSharpList`1<Binding>>, FSharpList`1<Binding>, Tuple`2<MutRecDefnsPhase2DataForModule, TcEnv>, MutRecDataForModuleAbbrev, MutRecDataForOpen>> defs, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<Tuple`3<ModuleOrNamespaceExpr, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>, TcEnv>> TcModuleOrNamespaceElements(cenv cenv, ParentRef parent, range endm, TcEnv env, PreXmlDoc xml, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, FSharpList`1<SynModuleDecl> defs);
    internal static TcEnv warn@17200(CcuThunk ccu, range scopem, TcEnv env, string p, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv ApplyAssemblyLevelAutoOpenAttributeToTcEnv(TcGlobals g, ImportMap amap, CcuThunk ccu, range scopem, TcEnv env, string p, bool root);
    internal static TcEnv AddCcuToTcEnv(TcGlobals g, ImportMap amap, range scopem, TcEnv env, string assemblyName, CcuThunk ccu, FSharpList`1<string> autoOpens, FSharpList`1<string> internalsVisibleToAttributes);
    internal static TcEnv CreateInitialTcEnv(TcGlobals g, ImportMap amap, range scopem, string assemblyName, FSharpList`1<Tuple`3<CcuThunk, FSharpList`1<string>, FSharpList`1<string>>> ccus);
    internal static TopAttribs get_EmptyTopAttrs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TopAttribs CombineTopAttrs(TopAttribs topAttrs1, TopAttribs topAttrs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IterTyconsOfModuleOrNamespaceType(FSharpFunc`2<Entity, Unit> f, ModuleOrNamespaceType mty);
    internal static void applyDefaults@17274(cenv cenv, TcGlobals g, DisplayEnv denvAtEnd, FSharpList`1<Typar> unsolved, int priority);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ApplyDefaults(cenv cenv, TcGlobals g, DisplayEnv denvAtEnd, range m, ModuleOrNamespaceExpr mexpr, FSharpList`1<Attrib> extraAttribs);
    internal static void check@17303-7(DisplayEnv denvAtEnd, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValueRestriction(DisplayEnv denvAtEnd, FSharpOption`1<a> rootSigOpt, ModuleOrNamespaceType implFileTypePriorToSig, range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SolveInternalUnknowns(TcGlobals g, cenv cenv, DisplayEnv denvAtEnd, ModuleOrNamespaceExpr mexpr, FSharpList`1<Attrib> extraAttribs);
    [CompilerGeneratedAttribute]
internal static ModuleOrNamespaceExprWithSig CheckModuleSignature$cont@17339(cenv cenv, range m, DisplayEnv denvAtEnd, FSharpOption`1<ModuleOrNamespaceType> rootSigOpt, ModuleOrNamespaceType implFileTypePriorToSig, Entity implFileSpecPriorToSig, ModuleOrNamespaceExpr mexpr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceExprWithSig CheckModuleSignature(TcGlobals g, cenv cenv, range m, DisplayEnv denvAtEnd, FSharpOption`1<ModuleOrNamespaceType> rootSigOpt, ModuleOrNamespaceType implFileTypePriorToSig, Entity implFileSpecPriorToSig, ModuleOrNamespaceExpr mexpr);
    [CompilerGeneratedAttribute]
internal static void f@514-22(cenv cenv, TcEnv envAtEnd, ModuleOrNamespaceType implFileTypePriorToSig, DisplayEnv denvAtEnd, range m, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static ModuleOrNamespaceExprWithSig f@514-23(TcGlobals g, FSharpOption`1<ModuleOrNamespaceType> rootSigOpt, cenv cenv, ModuleOrNamespaceExpr mexpr, ModuleOrNamespaceType implFileTypePriorToSig, DisplayEnv denvAtEnd, range m, Entity implFileSpecPriorToSig, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void f@514-24(cenv cenv, range m, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static Tuple`2<bool, FSharpMap`2<long, AnonRecdTypeInfo>> f@514-25(bool isInternalTestSpanStackReferring, TcGlobals g, FSharpFunc`2<Unit, bool> checkForErrors, TcEnv env, Tuple`2<bool, bool> isLastCompiland, cenv cenv, TcEnv envAtEnd, range m, FSharpList`1<Attrib> extraAttribs, ModuleOrNamespaceExprWithSig implFileExprAfterSig, Unit unitVar0);
    internal static bool isValid@17455(string version, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<Tuple`5<TopAttribs, TypedImplFile, ModuleOrNamespaceType, TcEnv, bool>> TypeCheckOneImplFile(TcGlobals g, NiceNameGenerator niceNameGen, ImportMap amap, CcuThunk topCcu, FSharpFunc`2<Unit, bool> checkForErrors, FSharpOption`1<FSharpList`1<string>> conditionalDefines, TcResultsSink tcSink, bool isInternalTestSpanStackReferring, TcEnv env, FSharpOption`1<ModuleOrNamespaceType> rootSigOpt, ParsedImplFileInput _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Eventually`1<Tuple`3<TcEnv, ModuleOrNamespaceType, bool>> TypeCheckOneSigFile(TcGlobals g, NiceNameGenerator niceNameGen, ImportMap amap, CcuThunk topCcu, FSharpFunc`2<Unit, bool> checkForErrors, FSharpOption`1<FSharpList`1<string>> conditionalDefines, TcResultsSink tcSink, bool isInternalTestSpanStackReferring, TcEnv tcEnv, ParsedSigFileInput _arg1);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.TypeProviderError : Exception {
    internal FSharpOption`1<string> typeNameContext;
    internal string tpDesignation;
    internal FSharpOption`1<string> methodNameContext;
    internal range m;
    internal FSharpList`1<string> errors;
    internal int errNum;
    internal int Number { get; }
    internal range Range { get; }
    public string Message { get; }
    internal string ContextualErrorMessage { get; }
    public TypeProviderError(int errNum, string tpDesignation, range m, FSharpList`1<string> errors, FSharpOption`1<string> typeNameContext, FSharpOption`1<string> methodNameContext);
    public TypeProviderError(Tuple`2<int, string> _arg1, string tpDesignation, range m);
    public TypeProviderError(int errNum, string tpDesignation, range m, IEnumerable`1<string> messages);
    internal int get_Number();
    internal range get_Range();
    public virtual string get_Message();
    internal TypeProviderError MapText(FSharpFunc`2<string, Tuple`2<int, string>> f, string tpDesignation, range m);
    internal TypeProviderError WithContext(string typeNameContext, string methodNameContext);
    internal string get_ContextualErrorMessage();
    internal void Iter(FSharpFunc`2<TypeProviderError, Unit> f);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TypeRelations : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeDefinitelySubsumesTypeNoCoercion(int ndeep, TcGlobals g, ImportMap amap, range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypesFeasiblyEquiv(int ndeep, TcGlobals g, a amap, range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeFeasiblySubsumesType(int ndeep, TcGlobals g, ImportMap amap, range m, TType ty1, CanCoerce canCoerce, TType ty2);
    internal static TType join@128(TcGlobals g, ImportMap amap, TType maxSoFar, range m, TType x);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TType, range> ChooseTyparSolutionAndRange$cont@134(TcGlobals g, ImportMap amap, TType maxSoFar, TyparConstraint tpc, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, range> ChooseTyparSolutionAndRange(TcGlobals g, ImportMap amap, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ChooseTyparSolution(TcGlobals g, ImportMap amap, Typar tp);
    internal static FSharpList`1<TType> loop@183-57(TcGlobals g, FSharpList`1<Tuple`2<Typar, TType>> tpenv, int n, FSharpList`1<TType> curr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> IterativelySubstituteTyparSolutions(TcGlobals g, FSharpList`1<Typar> tps, FSharpList`1<TType> solutions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr ChooseTyparSolutionsForFreeChoiceTypars(TcGlobals g, ImportMap amap, Expr e);
    internal static Tuple`3<FSharpList`1<FSharpList`1<Val>>, Expr, TType> stripLambdaUpto@219(int n, Expr tupledArg0, TType tupledArg1);
    internal static Tuple`5<FSharpOption`1<Val>, FSharpOption`1<Val>, FSharpList`1<FSharpList`1<Val>>, Expr, TType> startStripLambdaUpto@227(TcGlobals g, ImportMap amap, int n, Expr tupledArg0, TType tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`6<FSharpList`1<Typar>, FSharpOption`1<Val>, FSharpOption`1<Val>, FSharpList`1<FSharpList`1<Val>>, Expr, TType>> tryDestTopLambda(TcGlobals g, ImportMap amap, ValReprInfo _arg1, Expr e, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<Typar>, FSharpOption`1<Val>, FSharpOption`1<Val>, FSharpList`1<FSharpList`1<Val>>, Expr, TType> destTopLambda(TcGlobals g, ImportMap amap, ValReprInfo topValInfo, Expr e, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<Val>>, Expr> IteratedAdjustArityOfLambdaBody(TcGlobals g, FSharpList`1<int> arities, FSharpList`1<FSharpList`1<Val>> vsl, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<Typar>, FSharpOption`1<Val>, FSharpOption`1<Val>, FSharpList`1<FSharpList`1<Val>>, Expr, TType> IteratedAdjustArityOfLambda(TcGlobals g, ImportMap amap, ValReprInfo topValInfo, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> FindUniqueFeasibleSupertype(TcGlobals g, ImportMap amap, range m, TType ty1, TType ty2);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.UnicodeLexing : object {
    internal static int retryDelayMilliseconds { get; }
    internal static int numRetries { get; }
    internal static LexBuffer`1<char> StringAsLexbuf(string s);
    internal static LexBuffer`1<char> FunctionAsLexbuf(FSharpFunc`2<Tuple`3<Char[], int, int>, int> bufferFiller);
    internal static LexBuffer`1<char> SourceTextAsLexbuf(ISourceText sourceText);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_retryDelayMilliseconds();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_numRetries();
    internal static string getSource@46(bool retryLocked, string filename, FSharpOption`1<int> codePage, int retryNumber);
    internal static LexBuffer`1<char> UnicodeFileAsLexbuf(string filename, FSharpOption`1<int> codePage, bool retryLocked);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Utilities : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindFSharpStringAttribute(TcGlobals tcGlobals, BuiltinAttribInfo attribSpec, FSharpList`1<Attrib> attribs);
}
[CompilationMappingAttribute("3")]
internal class FSIstrings.SR : object {
    internal static Lazy`1<ResourceManager> resources;
    internal static Type funTyC;
    internal static bool swallowResourceText;
    internal static int init@14-1;
    internal static bool SwallowResourceText { get; internal set; }
    private static SR();
    internal static bool get_SwallowResourceText();
    internal static void set_SwallowResourceText(bool b);
    internal static string stoppedDueToError();
    internal static string fsiUsage(string a0);
    internal static string fsiInputFiles();
    internal static string fsiCodeGeneration();
    internal static string fsiErrorsAndWarnings();
    internal static string fsiLanguage();
    internal static string fsiMiscellaneous();
    internal static string fsiAdvanced();
    internal static string fsiExceptionRaisedStartingServer(string a0);
    internal static string fsiUse();
    internal static string fsiLoad();
    internal static string fsiRemaining();
    internal static string fsiHelp();
    internal static string fsiExec();
    internal static string fsiGui();
    internal static string fsiQuiet();
    internal static string fsiReadline();
    internal static string fsiEmitDebugInfoInQuotations();
    internal static string fsiBanner3();
    internal static string fsiConsoleProblem();
    internal static Tuple`2<int, string> fsiInvalidAssembly(string a0);
    internal static Tuple`2<int, string> fsiDirectoryDoesNotExist(string a0);
    internal static string fsiInvalidDirective(string a0, string a1);
    internal static string fsiLineTooLong();
    internal static string fsiTimeInfoMainString(string a0, string a1, string a2);
    internal static string fsiTimeInfoGCGenerationLabelSomeShorthandForTheWordGeneration();
    internal static string fsiExceptionDuringPrettyPrinting(string a0);
    internal static string fsiIntroTextHeader1directives();
    internal static string fsiIntroTextHashrInfo();
    internal static string fsiIntroTextHashIInfo();
    internal static string fsiIntroTextHashloadInfo();
    internal static string fsiIntroTextHashtimeInfo();
    internal static string fsiIntroTextHashhelpInfo();
    internal static string fsiIntroTextHashquitInfo();
    internal static string fsiIntroTextHeader2commandLine();
    internal static string fsiIntroTextHeader3(string a0);
    internal static string fsiLoadingFilesPrefixText();
    internal static string fsiInterrupt();
    internal static string fsiExit();
    internal static string fsiAbortingMainThread();
    internal static string fsiCouldNotInstallCtrlCHandler(string a0);
    internal static string fsiDidAHashr(string a0);
    internal static string fsiDidAHashrWithLockWarning(string a0);
    internal static string fsiDidAHashrWithStaleWarning(string a0);
    internal static string fsiDidAHashI(string a0);
    internal static string fsiTurnedTimingOn();
    internal static string fsiTurnedTimingOff();
    internal static string fsiUnexpectedThreadAbortException();
    internal static string fsiFailedToResolveAssembly(string a0);
    internal static string fsiBindingSessionTo(string a0);
    internal static string fsiProductName(string a0);
    internal static string fsiProductNameCommunity(string a0);
    internal static string shadowCopyReferences();
    internal static void RunStartupValidation();
    [CompilerGeneratedAttribute]
internal static Assembly getCurrentAssembly();
    [CompilerGeneratedAttribute]
internal static Type getTypeInfo(Type t);
    [CompilerGeneratedAttribute]
internal static string GetString(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object mkFunctionValue(Type[] tys, FSharpFunc`2<object, object> impl);
    [CompilerGeneratedAttribute]
internal static bool isNamedType(Type ty);
    [CompilerGeneratedAttribute]
internal static bool isFunctionType(Type ty1);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Type, Type[]> destFunTy(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object buildFunctionForOneArgPat(Type ty, FSharpFunc`2<Type, FSharpFunc`2<object, object>> impl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object capture1(string fmt, int i, FSharpList`1<object> args, Type ty, FSharpFunc`2<FSharpList`1<object>, FSharpFunc`2<Type, FSharpFunc`2<int, object>>> go);
    [CompilerGeneratedAttribute]
internal static string postProcessString(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static T createMessageString(string messageString, PrintfFormat`4<T, Unit, string, string> fmt);
    [CompilerGeneratedAttribute]
internal static T GetStringFunc(string messageID, PrintfFormat`4<T, Unit, string, string> fmt);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.AgedLookup`3 : object {
    internal FSharpOption`1<FSharpFunc`2<Value, Unit>> onStrongDiscard;
    internal FSharpFunc`2<Tuple`2<Key, Key>, bool> areSimilar;
    internal FSharpList`1<Tuple`2<Key, ValueStrength`1<Value>>> refs;
    internal int keepStrongly@21;
    internal int keepMax@32-1;
    internal FSharpFunc`2<Value, bool> requiredToKeep@33;
    public AgedLookup`3(int keepStrongly, FSharpFunc`2<Tuple`2<Key, Key>, bool> areSimilar, FSharpOption`1<FSharpFunc`2<Value, bool>> requiredToKeep, FSharpOption`1<FSharpFunc`2<Value, Unit>> onStrongDiscard, FSharpOption`1<int> keepMax);
    internal FSharpOption`1<Tuple`2<Key, Value>> TryPeekKeyValue(Token tok, Key key);
    internal FSharpOption`1<Tuple`2<Key, Value>> TryGetKeyValue(Token tok, Key key);
    internal FSharpOption`1<Value> TryGet(Token tok, Key key);
    internal void Put(Token tok, Key key, Value value);
    internal void Remove(Token tok, Key key);
    internal void Clear(Token tok);
    internal void Resize(Token tok, int keepStrongly, FSharpOption`1<int> keepMax);
    [CompilerGeneratedAttribute]
internal void strongDiscard(Value x);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`2<Key, d>> TryPeekKeyValueImpl(FSharpList`1<Tuple`2<Key, d>> data, Key key);
    [CompilerGeneratedAttribute]
internal bool Exists(FSharpList`1<Tuple`2<Key, d>> data, Key key);
    [CompilerGeneratedAttribute]
internal FSharpList`1<Tuple`2<d, e>> Add(FSharpList`1<Tuple`2<d, e>> data, d key, e value);
    [CompilerGeneratedAttribute]
internal FSharpList`1<Tuple`2<Key, a>> Promote(FSharpList`1<Tuple`2<Key, a>> data, Key key, a value);
    [CompilerGeneratedAttribute]
internal Tuple`2<FSharpList`1<Tuple`2<Key, d>>, FSharpList`1<Tuple`2<Key, d>>> RemoveImpl(FSharpList`1<Tuple`2<Key, d>> data, Key key);
    [CompilerGeneratedAttribute]
internal Tuple`2<FSharpOption`1<Tuple`2<Key, d>>, FSharpList`1<Tuple`2<Key, d>>> TryGetKeyValueImpl(FSharpList`1<Tuple`2<Key, d>> data, Key key);
    [CompilerGeneratedAttribute]
internal FSharpList`1<Tuple`2<Key, Value>> FilterAndHold(Token tok);
    [CompilerGeneratedAttribute]
internal void AssignWithStrength(d tok, FSharpList`1<Tuple`2<Key, Value>> newdata, FSharpList`1<Tuple`2<e, Value>> discard1);
}
[DefaultMemberAttribute("Item")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.HashMultiMap`2 : object {
    internal Dictionary`2<Key, Value> firstEntries;
    internal Dictionary`2<Key, FSharpList`1<Value>> rest;
    internal int init@12-3;
    internal Dictionary`2<Key, Value> FirstEntries { get; }
    internal Dictionary`2<Key, FSharpList`1<Value>> Rest { get; }
    internal Value Item { get; internal set; }
    internal int Count { get; }
    public HashMultiMap`2(int size, IEqualityComparer`1<Key> comparer);
    public HashMultiMap`2(IEqualityComparer`1<Key> comparer);
    public HashMultiMap`2(IEnumerable`1<Tuple`2<Key, Value>> entries, IEqualityComparer`1<Key> comparer);
    internal FSharpList`1<Value> GetRest(Key k);
    internal void Add(Key y, Value z);
    internal void Clear();
    internal Dictionary`2<Key, Value> get_FirstEntries();
    internal Dictionary`2<Key, FSharpList`1<Value>> get_Rest();
    internal HashMultiMap`2<Key, Value> Copy();
    internal Value get_Item(Key y);
    internal void set_Item(Key y, Value z);
    internal FSharpList`1<Value> FindAll(Key y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal State Fold(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<State, State>>> f, State acc);
    internal void Iterate(FSharpFunc`2<Key, FSharpFunc`2<Value, Unit>> f);
    internal bool Contains(Key y);
    internal bool ContainsKey(Key y);
    internal void Remove(Key y);
    internal void Replace(Key y, Value z);
    internal FSharpOption`1<Value> TryFind(Key y);
    internal int get_Count();
    private virtual override IEnumerator`1<KeyValuePair`2<Key, Value>> System-Collections-Generic-IEnumerable`1-GetEnumerator();
    private virtual override IEnumerator System-Collections-IEnumerable-GetEnumerator();
    private virtual override Value System-Collections-Generic-IDictionary`2-get_Item(Key x);
    private virtual override void System-Collections-Generic-IDictionary`2-set_Item(Key x, Value v);
    private virtual override ICollection`1<Key> System-Collections-Generic-IDictionary`2-get_Keys();
    private virtual override ICollection`1<Value> System-Collections-Generic-IDictionary`2-get_Values();
    private virtual override void System-Collections-Generic-IDictionary`2-Add(Key k, Value v);
    private virtual override bool System-Collections-Generic-IDictionary`2-ContainsKey(Key k);
    private virtual override bool System-Collections-Generic-IDictionary`2-TryGetValue(Key k, Value& r);
    private virtual override bool System-Collections-Generic-IDictionary`2-Remove(Key k);
    private virtual override void System-Collections-Generic-ICollection`1-Add(KeyValuePair`2<Key, Value> x);
    private virtual override void System-Collections-Generic-ICollection`1-Clear();
    private virtual override bool System-Collections-Generic-ICollection`1-Remove(KeyValuePair`2<Key, Value> x);
    private virtual override bool System-Collections-Generic-ICollection`1-Contains(KeyValuePair`2<Key, Value> x);
    private virtual override void System-Collections-Generic-ICollection`1-CopyTo(KeyValuePair`2[] arr, int arrIndex);
    private virtual override bool System-Collections-Generic-ICollection`1-get_IsReadOnly();
    private virtual override int System-Collections-Generic-ICollection`1-get_Count();
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.MruCache`3 : object {
    internal FSharpFunc`2<Tuple`2<Key, Key>, bool> areSame;
    internal AgedLookup`3<Token, Key, Value> cache;
    internal FSharpFunc`2<Tuple`2<Key, Value>, bool> isStillValid@168;
    public MruCache`3(int keepStrongly, FSharpFunc`2<Tuple`2<Key, Key>, bool> areSame, FSharpOption`1<FSharpFunc`2<Tuple`2<Key, Value>, bool>> isStillValid, FSharpOption`1<FSharpFunc`2<Tuple`2<Key, Key>, bool>> areSimilar, FSharpOption`1<FSharpFunc`2<Value, bool>> requiredToKeep, FSharpOption`1<FSharpFunc`2<Value, Unit>> onDiscard, FSharpOption`1<int> keepMax);
    internal bool ContainsSimilarKey(Token tok, Key key);
    internal FSharpOption`1<Value> TryGetAny(Token tok, Key key);
    internal FSharpOption`1<Value> TryGet(Token tok, Key key);
    internal void Set(Token tok, Key key, Value value);
    internal void RemoveAnySimilar(Token tok, Key key);
    internal void Clear(Token tok);
    internal void Resize(Token tok, int keepStrongly, FSharpOption`1<int> keepMax);
}
[DefaultMemberAttribute("Item")]
[SealedAttribute]
[DebuggerDisplayAttribute("Count = {Count}")]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.Tagged.Map`3 : object {
    internal MapTree`2<Key, Value> tree;
    internal IComparer`1<Key> comparer;
    internal MapTree`2<Key, Value> Tree { get; }
    internal IComparer`1<Key> Comparer { get; }
    internal bool IsEmpty { get; }
    internal Value Item { get; }
    internal int Count { get; }
    public Map`3(IComparer`1<Key> comparer, MapTree`2<Key, Value> tree);
    private static Map`3();
    internal MapTree`2<Key, Value> get_Tree();
    internal IComparer`1<Key> get_Comparer();
    internal static Map`3<Key, Value, ComparerTag> Empty(ComparerTag comparer);
    internal Map`3<Key, Value, ComparerTag> Add(Key k, Value v);
    internal bool get_IsEmpty();
    internal Value get_Item(Key k);
    internal FSharpOption`1<T> First(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpOption`1<T>>> f);
    internal bool Exists(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    internal Map`3<Key, Value, ComparerTag> Filter(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    internal bool ForAll(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal State Fold(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<State, State>>> folder, State acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal State FoldSection(Key lo, Key hi, FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<State, State>>> f, State acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Tuple`2<Map`3<Key, T, ComparerTag>, State> FoldAndMap(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<State, Tuple`2<T, State>>>> f, State z);
    internal void Iterate(FSharpFunc`2<Key, FSharpFunc`2<Value, Unit>> action);
    internal Map`3<Key, T, ComparerTag> MapRange(FSharpFunc`2<Value, T> mapping);
    internal Map`3<Key, T, ComparerTag> Map(FSharpFunc`2<Key, FSharpFunc`2<Value, T>> mapping);
    internal Tuple`2<Map`3<Key, Value, ComparerTag>, Map`3<Key, Value, ComparerTag>> Partition(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    internal int get_Count();
    internal bool ContainsKey(Key k);
    internal Map`3<Key, Value, ComparerTag> Remove(Key k);
    internal FSharpOption`1<Value> TryFind(Key k);
    internal FSharpList`1<Tuple`2<Key, Value>> ToList();
    internal Tuple`2[] ToArray();
    internal static Map`3<Key, Value, ComparerTag> FromList(ComparerTag comparer, FSharpList`1<Tuple`2<Key, Value>> l);
    internal static Map`3<Key, Value, ComparerTag> Create(ComparerTag comparer, IEnumerable`1<Tuple`2<Key, Value>> ie);
    public virtual bool Equals(object that);
    internal int ComputeHashCode();
    public virtual int GetHashCode();
    private virtual override IEnumerator`1<KeyValuePair`2<Key, Value>> System-Collections-Generic-IEnumerable`1-GetEnumerator();
    private virtual override IEnumerator System-Collections-IEnumerable-GetEnumerator();
    private virtual override int System-IComparable-CompareTo(object m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static Map`3<Key, e, ComparerTag> refresh(Map`3<Key, d, ComparerTag> m, MapTree`2<Key, e> t);
}
[CompilationRepresentationAttribute("8")]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class Internal.Utilities.Collections.Tagged.MapTree`2 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Key item1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T item2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MapTree`2<Key, T> item3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MapTree`2<Key, T> item4;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item5;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static MapTree`2<Key, T> MapEmpty { get; }
    [CompilationMappingAttribute("4", "1", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Key Item1 { get; }
    [CompilationMappingAttribute("4", "1", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T Item2 { get; }
    [CompilationMappingAttribute("4", "1", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MapTree`2<Key, T> Item3 { get; }
    [CompilationMappingAttribute("4", "1", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MapTree`2<Key, T> Item4 { get; }
    [CompilationMappingAttribute("4", "1", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int Item5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MapTree`2(Key item1, T item2, MapTree`2<Key, T> item3, MapTree`2<Key, T> item4, int item5);
    [CompilationMappingAttribute("8", "0")]
internal static MapTree`2<Key, T> get_MapEmpty();
    [CompilationMappingAttribute("8", "1")]
internal static MapTree`2<Key, T> NewMapNode(Key item1, T item2, MapTree`2<Key, T> item3, MapTree`2<Key, T> item4, int item5);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Key get_Item1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T get_Item2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MapTree`2<Key, T> get_Item3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MapTree`2<Key, T> get_Item4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Item5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int GetTag(MapTree`2<Key, T> );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Collections.Tagged.MapTreeModule : object {
    [CompilerGeneratedAttribute]
internal static MapTree`2<a, b> rebalance$cont@753-2(MapTree`2<a, b> t1, a k, b v, b t2v, MapTree`2<a, b> t2r, MapTree`2<a, b> t2l, a t2k, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static MapTree`2<a, b> rebalance$cont@750-1(MapTree`2<a, b> t1, a k, b v, MapTree`2<a, b> t2, int t1h, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static MapTree`2<a, b> rebalance$cont@767-4(a k, b v, MapTree`2<a, b> t2, b t1v, MapTree`2<a, b> t1r, MapTree`2<a, b> t1l, a t1k, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static MapTree`2<a, b> rebalance$cont@763-3(MapTree`2<a, b> t1, a k, b v, MapTree`2<a, b> t2, int t2h, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> rebalance(MapTree`2<a, b> t1, a k, b v, MapTree`2<a, b> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int sizeAux(int acc, MapTree`2<a, b> m);
    internal static MapTree`2<a, b> MapOne(a k, b v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<T, a> add(IComparer`1<T> comparer, T k, a v, MapTree`2<T, a> m);
    internal static a indexNotFound();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a find(IComparer`1<T> comparer, T k, MapTree`2<T, a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> tryFind(IComparer`1<T> comparer, T k, MapTree`2<T, a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MapTree`2<T, a>, MapTree`2<T, a>> partition1(IComparer`1<T> comparer, FSharpFunc`2<T, FSharpFunc`2<a, bool>> f, T k, a v, MapTree`2<T, a> acc1, MapTree`2<T, a> acc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MapTree`2<T, a>, MapTree`2<T, a>> partitionAux(IComparer`1<T> comparer, FSharpFunc`2<T, FSharpFunc`2<a, bool>> f, MapTree`2<T, a> s, MapTree`2<T, a> acc_0, MapTree`2<T, a> acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<T, a> filter1(IComparer`1<T> comparer, FSharpFunc`2<T, FSharpFunc`2<a, bool>> f, T k, a v, MapTree`2<T, a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<T, a> filterAux(IComparer`1<T> comparer, FSharpFunc`2<T, FSharpFunc`2<a, bool>> f, MapTree`2<T, a> s, MapTree`2<T, a> acc);
    internal static Tuple`3<a, b, MapTree`2<a, b>> spliceOutSuccessor(MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<T, a> remove(IComparer`1<T> comparer, T k, MapTree`2<T, a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool containsKey(IComparer`1<T> comparer, T k, MapTree`2<T, a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<a, FSharpFunc`2<b, Unit>> f, MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<c> first(FSharpFunc`2<a, FSharpFunc`2<b, FSharpOption`1<c>>> f, MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forAll(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<c, b> map(FSharpFunc`2<a, b> f, MapTree`2<c, a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, c> mapi(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c fold(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, c>>> f, MapTree`2<a, b> m, c x);
    internal static d fold_from_to@976(IComparer`1<T> comparer, T lo, T hi, FSharpFunc`2<T, FSharpFunc`2<c, FSharpFunc`2<d, d>>> f, MapTree`2<T, c> m, d x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b foldSection(IComparer`1<T> comparer, T lo, T hi, FSharpFunc`2<T, FSharpFunc`2<a, FSharpFunc`2<b, b>>> f, MapTree`2<T, a> m, b x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MapTree`2<T, c>, b> foldMap(IComparer`1<T> comparer, FSharpFunc`2<T, FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<c, b>>>> f, MapTree`2<T, a> m, b z, MapTree`2<T, c> acc);
    internal static FSharpList`1<Tuple`2<a, b>> toList(MapTree`2<a, b> m);
    internal static Tuple`2[] toArray(MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> ofList(IComparer`1<a> comparer, FSharpList`1<Tuple`2<a, b>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> mkFromEnumerator(IComparer`1<a> comparer, MapTree`2<a, b> acc, IEnumerator`1<Tuple`2<a, b>> e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> ofSeq(IComparer`1<a> comparer, IEnumerable`1<Tuple`2<a, b>> c);
    internal static IEnumerator`1<KeyValuePair`2<a, b>> toSeq(MapTree`2<a, b> s);
}
[SealedAttribute]
[DebuggerDisplayAttribute("Count = {Count}")]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.Tagged.Set`2 : object {
    internal SetTree`1<T> tree;
    internal IComparer`1<T> comparer;
    internal SetTree`1<T> Tree { get; }
    internal IComparer`1<T> Comparer { get; }
    internal int Count { get; }
    internal bool IsEmpty { get; }
    internal T Choose { get; }
    internal T MinimumElement { get; }
    internal T MaximumElement { get; }
    public Set`2(IComparer`1<T> comparer, SetTree`1<T> tree);
    private static Set`2();
    internal SetTree`1<T> get_Tree();
    internal IComparer`1<T> get_Comparer();
    internal static Set`2<T, ComparerTag> Empty(ComparerTag comparer);
    internal Set`2<T, ComparerTag> Add(T x);
    internal Set`2<T, ComparerTag> Remove(T x);
    internal int get_Count();
    internal bool Contains(T x);
    internal void Iterate(FSharpFunc`2<T, Unit> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal State Fold(FSharpFunc`2<T, FSharpFunc`2<State, State>> f, State x);
    internal bool get_IsEmpty();
    internal Tuple`2<Set`2<T, ComparerTag>, Set`2<T, ComparerTag>> Partition(FSharpFunc`2<T, bool> predicate);
    internal Set`2<T, ComparerTag> Filter(FSharpFunc`2<T, bool> predicate);
    internal bool Exists(FSharpFunc`2<T, bool> predicate);
    internal bool ForAll(FSharpFunc`2<T, bool> predicate);
    internal static Set`2<T, ComparerTag> op_Subtraction(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static Set`2<T, ComparerTag> op_Addition(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static Set`2<T, ComparerTag> Intersection(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static Set`2<T, ComparerTag> Union(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static Set`2<T, ComparerTag> Difference(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static bool Equality(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static int Compare(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal T get_Choose();
    internal T get_MinimumElement();
    internal T get_MaximumElement();
    internal bool IsSubsetOf(Set`2<T, ComparerTag> y);
    internal bool IsSupersetOf(Set`2<T, ComparerTag> y);
    internal FSharpList`1<T> ToList();
    internal T[] ToArray();
    public virtual bool Equals(object that);
    internal int ComputeHashCode();
    public virtual int GetHashCode();
    internal static Set`2<T, ComparerTag> Singleton(ComparerTag comparer, T x);
    internal static Set`2<T, ComparerTag> Create(ComparerTag comparer, IEnumerable`1<T> l);
    private virtual override int System-IComparable-CompareTo(object s2);
    private virtual override void System-Collections-Generic-ICollection`1-Add(T _arg1);
    private virtual override void System-Collections-Generic-ICollection`1-Clear();
    private virtual override bool System-Collections-Generic-ICollection`1-Remove(T _arg2);
    private virtual override bool System-Collections-Generic-ICollection`1-Contains(T x);
    private virtual override void System-Collections-Generic-ICollection`1-CopyTo(T[] arr, int i);
    private virtual override bool System-Collections-Generic-ICollection`1-get_IsReadOnly();
    private virtual override int System-Collections-Generic-ICollection`1-get_Count();
    private virtual override IEnumerator`1<T> System-Collections-Generic-IEnumerable`1-GetEnumerator();
    private virtual override IEnumerator System-Collections-IEnumerable-GetEnumerator();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static Set`2<c, e> refresh(Set`2<c, d> s, SetTree`1<c> t);
}
[CompilationRepresentationAttribute("8")]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class Internal.Utilities.Collections.Tagged.SetTree`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T item1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SetTree`1<T> item2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SetTree`1<T> item3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int item4;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static SetTree`1<T> SetEmpty { get; }
    [CompilationMappingAttribute("4", "1", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T Item1 { get; }
    [CompilationMappingAttribute("4", "1", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SetTree`1<T> Item2 { get; }
    [CompilationMappingAttribute("4", "1", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SetTree`1<T> Item3 { get; }
    [CompilationMappingAttribute("4", "1", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int Item4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SetTree`1(T item1, SetTree`1<T> item2, SetTree`1<T> item3, int item4);
    [CompilationMappingAttribute("8", "0")]
internal static SetTree`1<T> get_SetEmpty();
    [CompilationMappingAttribute("8", "1")]
internal static SetTree`1<T> NewSetNode(T item1, SetTree`1<T> item2, SetTree`1<T> item3, int item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T get_Item1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SetTree`1<T> get_Item2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SetTree`1<T> get_Item3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Item4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int GetTag(SetTree`1<T> );
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Collections.Tagged.SetTreeModule : object {
    internal static int tolerance { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_tolerance();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> mk(SetTree`1<a> l, int hl, a k, SetTree`1<a> r, int hr);
    [CompilerGeneratedAttribute]
internal static SetTree`1<a> rebalance$cont@88(SetTree`1<a> t1, a k, SetTree`1<a> t2, int t1h, int t2h, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> rebalance(SetTree`1<a> t1, a k, SetTree`1<a> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> add(IComparer`1<T> comparer, T k, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> balance(IComparer`1<a> comparer, SetTree`1<a> t1, a k, SetTree`1<a> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<SetTree`1<T>, bool, SetTree`1<T>> split(IComparer`1<T> comparer, T pivot, SetTree`1<T> t);
    internal static Tuple`2<a, SetTree`1<a>> spliceOutSuccessor(SetTree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> remove(IComparer`1<T> comparer, T k, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool contains(IComparer`1<T> comparer, T k, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<a, Unit> f, SetTree`1<a> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b fold(FSharpFunc`2<a, FSharpFunc`2<b, b>> f, SetTree`1<a> m, b x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forAll(FSharpFunc`2<a, bool> f, SetTree`1<a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<a, bool> f, SetTree`1<a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool subset(IComparer`1<a> comparer, SetTree`1<a> a, SetTree`1<a> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> elementsAux(SetTree`1<a> m, FSharpList`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> filterAux(IComparer`1<a> comparer, FSharpFunc`2<a, bool> f, SetTree`1<a> s, SetTree`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> diffAux(IComparer`1<a> comparer, SetTree`1<a> m, SetTree`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int countAux(SetTree`1<a> s, int acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> union(IComparer`1<a> comparer, SetTree`1<a> t1, SetTree`1<a> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> intersectionAux(IComparer`1<a> comparer, SetTree`1<a> b, SetTree`1<a> m, SetTree`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SetTree`1<a>, SetTree`1<a>> partition1(IComparer`1<a> comparer, FSharpFunc`2<a, bool> f, a k, SetTree`1<a> acc1, SetTree`1<a> acc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SetTree`1<a>, SetTree`1<a>> partitionAux(IComparer`1<a> comparer, FSharpFunc`2<a, bool> f, SetTree`1<a> s, SetTree`1<a> acc_0, SetTree`1<a> acc_1);
    internal static FSharpChoice`2<Tuple`3<a, SetTree`1<a>, SetTree`1<a>>, Unit> |MatchSetNode|MatchSetEmpty|(SetTree`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<T> nextElemCont(IComparer`1<T> comparer, T k, SetTree`1<T> s, FSharpFunc`2<FSharpOption`1<T>, FSharpOption`1<T>> cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<T> prevElemCont(IComparer`1<T> comparer, T k, SetTree`1<T> s, FSharpFunc`2<FSharpOption`1<T>, FSharpOption`1<T>> cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a minimumElementAux(SetTree`1<a> s, a n);
    internal static FSharpOption`1<T> minimumElementOpt(SetTree`1<T> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a maximumElementAux(SetTree`1<a> s, a n);
    internal static FSharpOption`1<T> maximumElementOpt(SetTree`1<T> s);
    internal static a minimumElement(SetTree`1<a> s);
    internal static a maximumElement(SetTree`1<a> s);
    internal static IEnumerator`1<a> toSeq(SetTree`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int compareStacks(IComparer`1<T> comparer, FSharpList`1<SetTree`1<T>> l1, FSharpList`1<SetTree`1<T>> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int compare(IComparer`1<a> comparer, SetTree`1<a> s1, SetTree`1<a> s2);
    internal static FSharpList`1<b> loop@542-10(SetTree`1<b> m, FSharpList`1<b> x);
    internal static FSharpList`1<a> toList(SetTree`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void copyToArray(SetTree`1<a> s, a[] arr, int i);
    internal static a[] toArray(SetTree`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> mkFromEnumerator(IComparer`1<a> comparer, SetTree`1<a> acc, IEnumerator`1<a> e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> ofSeq(IComparer`1<a> comparer, IEnumerable`1<a> c);
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class Internal.Utilities.Collections.ValueStrength`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStrong { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWeak { get; }
    [CompilationMappingAttribute("8", "0")]
internal static ValueStrength`1<T> NewStrong(T item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStrong();
    [CompilationMappingAttribute("8", "1")]
internal static ValueStrength`1<T> NewWeak(WeakReference`1<T> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWeak();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueStrength`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.EditDistance : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsInWin(char mChar, string str, int offset, int rad);
    [CompilerGeneratedAttribute]
internal static bool exists@15-1(string s2, char c, int endAt, int index);
    internal static ValueTuple`2<int, char> nextChar@27(int matchRadius, string s1, string s2, int i, char c);
    internal static ValueTuple`5<int, int, int, int, int> loop@40-8(string s1, string s2, int matchRadius, int i, int j, int mismatches, int c1length, int c2length);
    [CompilerGeneratedAttribute]
internal static bool exists@15-2(string s2, char c, int endAt, int index);
    internal static int loop@52-9(int matchRadius, string s1, string s2, int i, int length);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static double jaro(string s1, string s2);
    internal static double calcL@80(string s1, string s2, int maxLength, int i, double acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static double JaroWinklerDistance(string s1, string s2);
    internal static int calcDamerauLevenshtein(string a, string b);
    internal static int CalcEditDistance(string a, string b);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Filename : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> checkPathForIllegalChars { get; }
    [CompilationMappingAttribute("9")]
internal static HashSet`1<char> chars@11 { get; }
    internal static FSharpFunc`2<string, Unit> get_checkPathForIllegalChars();
    internal static HashSet`1<char> get_chars@11();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkSuffix(string x, string y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool hasExtensionWithValidate(bool validate, string s);
    internal static bool hasExtension(string s);
    internal static string chopExtension(string s);
    internal static string directoryName(string s);
    internal static string fileNameOfPath(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string fileNameWithoutExtensionWithValidate(bool validate, string s);
    internal static string fileNameWithoutExtension(string s);
    internal static string trimQuotes(string s);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.FSharpEnvironment : object {
    [CompilationMappingAttribute("9")]
internal static string FSharpBannerVersion { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> FSharpCoreLibRunningVersion { get; }
    internal static string FSharpBinaryMetadataFormatRevision { get; }
    internal static int maxPath { get; }
    [CompilationMappingAttribute("9")]
internal static int maxDataLength { get; }
    internal static int KEY_WOW64_DEFAULT { get; }
    internal static int KEY_WOW64_32KEY { get; }
    [CompilationMappingAttribute("9")]
internal static UIntPtr HKEY_LOCAL_MACHINE { get; }
    internal static int KEY_QUERY_VALUE { get; }
    internal static UInt32 REG_SZ { get; }
    [CompilationMappingAttribute("9")]
internal static bool is32Bit { get; }
    [CompilationMappingAttribute("9")]
internal static bool runningOnMono { get; }
    [CompilationMappingAttribute("9")]
internal static bool IsNetFx45OrAboveInstalled { get; }
    [CompilationMappingAttribute("9")]
internal static bool IsRunningOnNetFx45OrAbove { get; }
    [CompilationMappingAttribute("9")]
internal static Version version@254-3 { get; }
    [CompilationMappingAttribute("9")]
internal static int major@255 { get; }
    internal static string get_FSharpBannerVersion();
    internal static string versionOf();
    internal static FSharpOption`1<string> get_FSharpCoreLibRunningVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpBinaryMetadataFormatRevision();
    internal static UInt32 RegOpenKeyExW(UIntPtr _hKey, string _lpSubKey, UInt32 _ulOptions, int _samDesired, UIntPtr& _phkResult);
    internal static UInt32 RegQueryValueExW(UIntPtr _hKey, string _lpValueName, UInt32 _lpReserved, UInt32& _lpType, IntPtr _lpData, Int32& _lpchData);
    internal static UInt32 RegCloseKey(UIntPtr _hKey);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_maxPath();
    internal static int get_maxDataLength();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_KEY_WOW64_DEFAULT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_KEY_WOW64_32KEY();
    internal static UIntPtr get_HKEY_LOCAL_MACHINE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_KEY_QUERY_VALUE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UInt32 get_REG_SZ();
    internal static FSharpOption`1<string> GetDefaultRegistryStringValueViaDotNet(string subKey);
    internal static FSharpOption`1<string> Get32BitRegistryStringValueViaPInvoke(string subKey);
    internal static bool get_is32Bit();
    internal static bool get_runningOnMono();
    internal static FSharpOption`1<string> tryRegKey(string subKey);
    internal static FSharpOption`1<string> tryCurrentDomain();
    internal static FSharpOption`1<string> tryAppConfig(string _appConfigKey);
    internal static FSharpOption`1<string> BinFolderOfDefaultFSharpCompiler(FSharpOption`1<string> probePoint);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a useKey(string subkey, FSharpFunc`2<RegistryKey, a> f);
    internal static bool IsNetFx45OrAboveInstalledAt(string subkey);
    internal static bool get_IsNetFx45OrAboveInstalled();
    internal static bool get_IsRunningOnNetFx45OrAbove();
    internal static Version get_version@254-3();
    internal static int get_major@255();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
public class Internal.Utilities.PathMap : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpMap`2<string, string> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpMap`2<string, string> Item { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PathMap(FSharpMap`2<string, string> item);
    [CompilationMappingAttribute("8", "0")]
internal static PathMap NewPathMap(FSharpMap`2<string, string> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpMap`2<string, string> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PathMap obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PathMap obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.PathMapModule : object {
    [CompilationMappingAttribute("9")]
internal static string dirSepStr { get; }
    [CompilationMappingAttribute("9")]
internal static char copyOfStruct@14 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static PathMap empty { get; }
    internal static string get_dirSepStr();
    internal static char get_copyOfStruct@14();
    internal static void set_copyOfStruct@14(char value);
    internal static PathMap get_empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PathMap addMapping(string src, string dst, PathMap _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string apply(PathMap _arg1, string filePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string applyDir(PathMap pathMap, string dirName);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.QueueList`1 : object {
    internal int numLastElementsIn;
    internal bool push;
    internal FSharpList`1<T> firstElements;
    internal FSharpList`1<T> lastElementsRev;
    internal int numLastElements;
    internal static QueueList`1<T> empty;
    internal static int init@13-4;
    internal static QueueList`1<T> Empty { get; }
    internal FSharpList`1<T> FirstElements { get; }
    internal FSharpList`1<T> LastElements { get; }
    public QueueList`1(FSharpList`1<T> firstElementsIn, FSharpList`1<T> lastElementsRevIn, int numLastElementsIn);
    private static QueueList`1();
    public QueueList`1(FSharpList`1<T> xs);
    internal static QueueList`1<T> get_Empty();
    internal FSharpList`1<T> ToList();
    internal FSharpList`1<T> get_FirstElements();
    internal FSharpList`1<T> get_LastElements();
    internal QueueList`1<T> AppendOne(T y);
    internal QueueList`1<T> Append(IEnumerable`1<T> ys);
    private virtual override IEnumerator`1<T> System-Collections-Generic-IEnumerable`1-GetEnumerator();
    private virtual override IEnumerator System-Collections-IEnumerable-GetEnumerator();
    [CompilerGeneratedAttribute]
internal FSharpList`1<T> lastElements();
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.QueueListModule : object {
    internal static QueueList`1<T> empty();
    internal static QueueList`1<a> ofSeq(IEnumerable`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<a, Unit> f, QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueueList`1<b> map(FSharpFunc`2<a, b> f, QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<a, bool> f, QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueueList`1<a> filter(FSharpFunc`2<a, bool> f, QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b foldBack(FSharpFunc`2<a, FSharpFunc`2<b, b>> f, QueueList`1<a> x, b acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<a, bool> f, QueueList`1<a> x);
    internal static QueueList`1<a> ofList(FSharpList`1<a> x);
    internal static FSharpList`1<a> toList(QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> tryFind(FSharpFunc`2<a, bool> f, QueueList`1<a> x);
    internal static QueueList`1<a> one(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueueList`1<a> appendOne(QueueList`1<a> x, a y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueueList`1<a> append(QueueList`1<a> x, QueueList`1<a> ys);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.ResizeArrayModule : object {
    internal static int length(List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T get(List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void set(List`1<T> arr, int n, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> create(int n, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> init(int n, FSharpFunc`2<int, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void blit(List`1<T> arr1, int start1, List`1<T> arr2, int start2, int len);
    internal static List`1<T> concat(FSharpList`1<List`1<T>> arrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> append(List`1<T> arr1, List`1<T> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> sub(List`1<T> arr, int start, int len);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void fill(List`1<T> arr, int start, int len, T x);
    internal static List`1<T> copy(List`1<T> arr);
    internal static FSharpList`1<T> toList(List`1<T> arr);
    internal static void add@59(List`1<T> res, FSharpList`1<T> _arg1);
    internal static List`1<T> ofList(FSharpList`1<T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<T, Unit> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<U> map(FSharpFunc`2<T, U> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<U> mapi(FSharpFunc`2<int, FSharpFunc`2<T, U>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iteri(FSharpFunc`2<int, FSharpFunc`2<T, Unit>> f, List`1<T> arr);
    internal static bool loop@91-1(FSharpFunc`2<T, bool> f, List`1<T> arr, int len, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static bool loop@96-2(FSharpFunc`2<T, bool> f, List`1<T> arr, int len, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static a indexNotFound();
    internal static T loop@102-3(FSharpFunc`2<T, bool> f, List`1<T> arr, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T find(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static FSharpOption`1<U> loop@109-4(FSharpFunc`2<T, FSharpOption`1<U>> f, List`1<T> arr, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<U> tryPick(FSharpFunc`2<T, FSharpOption`1<U>> f, List`1<T> arr);
    internal static FSharpOption`1<T> loop@117-5(FSharpFunc`2<T, bool> f, List`1<T> arr, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<T> tryFind(FSharpFunc`2<T, bool> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter2(FSharpFunc`2<T, FSharpFunc`2<U, Unit>> f, List`1<T> arr1, List`1<U> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<c> map2(FSharpFunc`2<T, FSharpFunc`2<U, c>> f, List`1<T> arr1, List`1<U> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<U> choose(FSharpFunc`2<T, FSharpOption`1<U>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> filter(FSharpFunc`2<T, bool> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<List`1<T>, List`1<T>> partition(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static List`1<T> rev(List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static U foldBack(FSharpFunc`2<T, FSharpFunc`2<U, U>> f, List`1<T> arr, U acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T fold(FSharpFunc`2<T, FSharpFunc`2<U, T>> f, T acc, List`1<U> arr);
    internal static T[] toArray(List`1<T> arr);
    internal static List`1<T> ofArray(T[] arr);
    internal static IEnumerable`1<T> toSeq(List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sort(FSharpFunc`2<T, FSharpFunc`2<T, int>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sortBy(FSharpFunc`2<T, Key> f, List`1<T> arr);
    internal static bool loop@197-6(FSharpFunc`2<T, FSharpFunc`2<U, bool>> f, List`1<T> arr1, List`1<U> arr2, int len1, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists2(FSharpFunc`2<T, FSharpFunc`2<U, bool>> f, List`1<T> arr1, List`1<U> arr2);
    internal static int go@201(FSharpFunc`2<T, bool> f, List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int findIndex(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static int go@205-1(FSharpFunc`2<int, FSharpFunc`2<T, bool>> f, List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int findIndexi(FSharpFunc`2<int, FSharpFunc`2<T, bool>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldSub(FSharpFunc`2<a, FSharpFunc`2<b, a>> f, a acc, List`1<b> arr, int start, int fin);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b foldBackSub(FSharpFunc`2<a, FSharpFunc`2<b, b>> f, List`1<a> arr, int start, int fin, b acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T reduce(FSharpFunc`2<T, FSharpFunc`2<T, T>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T reduceBack(FSharpFunc`2<T, FSharpFunc`2<T, T>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static state fold2(FSharpFunc`2<state, FSharpFunc`2<b1, FSharpFunc`2<b2, state>>> f, state acc, List`1<b1> arr1, List`1<b2> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static U foldBack2(FSharpFunc`2<a1, FSharpFunc`2<a2, FSharpFunc`2<U, U>>> f, List`1<a1> arr1, List`1<a2> arr2, U acc);
    internal static bool loop@251-7(FSharpFunc`2<T, FSharpFunc`2<U, bool>> f, List`1<T> arr1, List`1<U> arr2, int len1, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall2(FSharpFunc`2<T, FSharpFunc`2<U, bool>> f, List`1<T> arr1, List`1<U> arr2);
    internal static bool isEmpty(List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iteri2(FSharpFunc`2<int, FSharpFunc`2<T, FSharpFunc`2<U, Unit>>> f, List`1<T> arr1, List`1<U> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<c> mapi2(FSharpFunc`2<int, FSharpFunc`2<T, FSharpFunc`2<U, c>>> f, List`1<T> arr1, List`1<U> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<a> scanBackSub(FSharpFunc`2<T, FSharpFunc`2<a, a>> f, List`1<T> arr, int start, int fin, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<a> scanSub(FSharpFunc`2<a, FSharpFunc`2<T, a>> f, a acc, List`1<T> arr, int start, int fin);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<U> scan(FSharpFunc`2<U, FSharpFunc`2<T, U>> f, U acc, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<c> scanBack(FSharpFunc`2<T, FSharpFunc`2<c, c>> f, List`1<T> arr, c acc);
    internal static List`1<T> singleton(T x);
    internal static FSharpOption`1<int> go@301-2(FSharpFunc`2<T, bool> f, List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<int> tryFindIndex(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static FSharpOption`1<int> go@305-3(FSharpFunc`2<int, FSharpFunc`2<T, bool>> f, List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<int> tryFindIndexi(FSharpFunc`2<int, FSharpFunc`2<T, bool>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<Tuple`2<T, U>> zip(List`1<T> arr1, List`1<U> arr2);
    internal static Tuple`2<List`1<T>, List`1<U>> unzip(List`1<Tuple`2<T, U>> arr);
}
[CompilationMappingAttribute("7")]
public static class Internal.Utilities.StructuredFormat.Display : object {
    internal static int chunkN { get; }
    [CompilationMappingAttribute("9")]
internal static Layout nullL { get; }
    [CompilationMappingAttribute("9")]
internal static Layout measureL { get; }
    internal static bool typeUsesSystemObjectToString(Type ty);
    internal static FSharpChoice`2<a, Exception> catchExn(FSharpFunc`2<Unit, a> f);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_chunkN();
    [CompilerGeneratedAttribute]
internal static int initializer@1(Int32[] stack, int next, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Breaks pushBreak(int saving, Breaks _arg1);
    internal static Tuple`2<Breaks, bool> popBreak(Breaks _arg1);
    internal static FSharpOption`1<Tuple`2<Breaks, int>> forceBreak(Breaks _arg1);
    internal static Tuple`4<Breaks, Layout, int, int> fitLeaf@593(int maxWidth, Layout layout, int textWidth, Breaks breaks, int pos);
    internal static Tuple`4<Breaks, Layout, int, int> fit@570(int maxWidth, FSharpFunc`2<object, TaggedText> leafFormatter, Breaks breaks, int tupledArg0, Layout tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout squashTo(int maxWidth, FSharpFunc`2<object, TaggedText> leafFormatter, Layout layout);
    internal static Tuple`2<FSharpList`1<string>, int> addText@652(FSharpList`1<string> tupledArg0, int tupledArg1, string text);
    internal static Tuple`2<FSharpList`1<string>, int> newLine@655(FSharpList`1<string> tupledArg0, a tupledArg1, int n);
    internal static Tuple`2<FSharpList`1<string>, int> addL@662(FormatOptions opts, FSharpFunc`2<object, string> leafFormatter, Tuple`2<FSharpList`1<string>, int> z, int pos, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string showL(FormatOptions opts, FSharpFunc`2<object, string> leafFormatter, Layout layout);
    internal static int newLine@700-1(TaggedTextWriter chan, c _arg1, int n);
    internal static int addL@707-1(FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, a>>> outAttribute, FSharpFunc`2<object, b> leafFormatter, TaggedTextWriter chan, FSharpFunc`2<int, FSharpFunc`2<TaggedText, int>> addText, int z, int pos, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outL(FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, a>>> outAttribute, FSharpFunc`2<object, b> leafFormatter, TaggedTextWriter chan, Layout layout);
    internal static Tuple`2<b, b> unpackCons(FSharpList`1<Tuple`2<a, b>> recd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Tuple`2<object, Type>, Tuple`2<object, Type>>> getListValueInfo(BindingFlags bindingFlags, object x, Type ty);
    internal static Layout get_nullL();
    internal static Layout get_measureL();
    internal static Layout itemL@763(TaggedText tupledArg0, Layout tupledArg1);
    internal static Layout makeRecordL(FSharpList`1<Tuple`2<a, Layout>> nameXs);
    internal static Layout itemL@772-1(TaggedText tupledArg0, FSharpOption`1<Layout> tupledArg1);
    internal static Layout makePropertiesL(FSharpList`1<Tuple`2<a, FSharpOption`1<Layout>>> nameXs);
    internal static Layout makeListL(FSharpList`1<Layout> itemLs);
    internal static Layout makeArrayL(FSharpList`1<Layout> xs);
    internal static Layout makeArray2L(FSharpList`1<Layout> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string formatChar(bool isChar, char c);
    internal static bool check@829(string s, int i);
    internal static string conv@830(string s, int i, FSharpList`1<string> acc);
    internal static string formatString(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string formatStringInWidth(int width, string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout polyL(BindingFlags bindingFlags, FSharpFunc`2<ShowMode, FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<ValueInfo, FSharpFunc`2<object, Layout>>>>> objL, ShowMode showMode, int i, Precedence prec, a x, Type ty);
    internal static void countNodes@882(FSharpRef`1<int> size, int n);
    internal static FSharpFunc`2<b, bool> stopShort@883(FSharpRef`1<int> size);
    internal static Layout objL@886(ShowMode showMode, BindingFlags bindingFlags, FormatOptions opts, FSharpRef`1<int> size, FSharpFunc`2<ShowMode, FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<ValueInfo, FSharpFunc`2<object, Layout>>>>> objWithReprL, int depthLim, Precedence prec, Tuple`2<object, Type> tupledArg);
    internal static Layout sameObjL@887(ShowMode showMode, BindingFlags bindingFlags, FormatOptions opts, FSharpRef`1<int> size, FSharpFunc`2<ShowMode, FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<ValueInfo, FSharpFunc`2<object, Layout>>>>> objWithReprL, int depthLim, Precedence prec, object x, Type ty);
    internal static Layout recdAtomicTupleL@1021(ShowMode showMode, BindingFlags bindingFlags, FormatOptions opts, FSharpRef`1<int> size, FSharpFunc`2<ShowMode, FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<ValueInfo, FSharpFunc`2<object, Layout>>>>> objWithReprL, int depthLim, FSharpList`1<Tuple`2<b, Tuple`2<c, d>>> recd);
    internal static Layout bracketIfL@1027(ShowMode showMode, BindingFlags bindingFlags, FormatOptions opts, FSharpRef`1<int> size, FSharpFunc`2<ShowMode, FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<ValueInfo, FSharpFunc`2<object, Layout>>>>> objWithReprL, bool b, Layout basicL);
    internal static FSharpFunc`2<int, FSharpOption`1<Tuple`2<Tuple`2<object, Type>, int>>> project2@1110(Array arr, Type ty, int n1, int n2, int b1, int b2, int x);
    internal static FSharpFunc`2<e, Layout> possibleKeyValueL@1125(FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>>> objL, int depthLim, string word);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TaggedText, FSharpOption`1<Layout>> mapping@1-1(ShowMode showMode, BindingFlags bindingFlags, FormatOptions opts, FSharpRef`1<int> size, FSharpFunc`2<ShowMode, FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<ValueInfo, FSharpFunc`2<object, Layout>>>>> objWithReprL, object obj, Type ty, int nDepth, MemberInfo m);
    internal static FSharpFunc`2<Tuple`3<string, e, Type>, Tuple`2<TaggedText, Layout>> itemL@1038-2(FSharpRef`1<int> size, FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>>> objL, int depthLim);
    internal static FSharpFunc`2<Tuple`2<e, Type>, FSharpOption`1<Tuple`2<Tuple`2<object, Type>, Tuple`2<object, Type>>>> project@1048-1(BindingFlags bindingFlags);
    internal static Layout reprL@1030(ShowMode showMode, BindingFlags bindingFlags, FormatOptions opts, FSharpRef`1<int> size, FSharpFunc`2<ShowMode, FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<ValueInfo, FSharpFunc`2<object, Layout>>>>> objWithReprL, ShowMode showMode@1030, int depthLim, Precedence prec, ValueInfo repr, object x);
    internal static FSharpOption`1<Layout> buildObjMessageL@918(ShowMode showMode, BindingFlags bindingFlags, FormatOptions opts, FSharpRef`1<int> size, FSharpFunc`2<ShowMode, FSharpFunc`2<int, FSharpFunc`2<Precedence, FSharpFunc`2<ValueInfo, FSharpFunc`2<object, Layout>>>>> objWithReprL, int depthLim, object x, Type ty, string txt, FSharpList`1<Layout> layouts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout anyL(ShowMode showMode, BindingFlags bindingFlags, FormatOptions opts, a x, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedText leafFormatter(FormatOptions opts, object obj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout any_to_layout(FormatOptions options, T value, Type x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout squash_layout(FormatOptions options, Layout layout);
    public static TaggedTextWriter asTaggedTextWriter(TextWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void output_layout_tagged(FormatOptions options, TaggedTextWriter writer, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void output_layout(FormatOptions options, TextWriter writer, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string layout_to_string(FormatOptions options, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void output_any_ex(FormatOptions opts, TextWriter oc, a x_0, Type x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void output_any(TextWriter writer, T value, Type x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string layout_as_string(FormatOptions options, T value, Type x_1);
    public static string any_to_string(T value, Type x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout fsi_any_to_layout(FormatOptions options, T value, Type x_1);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class Internal.Utilities.StructuredFormat.FormatOptions : object {
    [DebuggerBrowsableAttribute("0")]
internal string FloatingPointFormat@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> AttributeProcessor@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<FSharpFunc`2<IEnvironment, FSharpFunc`2<object, FSharpOption`1<Layout>>>> PrintIntercepts@;
    [DebuggerBrowsableAttribute("0")]
internal int StringLimit@;
    [DebuggerBrowsableAttribute("0")]
internal IFormatProvider FormatProvider@;
    [DebuggerBrowsableAttribute("0")]
internal BindingFlags BindingFlags@;
    [DebuggerBrowsableAttribute("0")]
internal int PrintWidth@;
    [DebuggerBrowsableAttribute("0")]
internal int PrintDepth@;
    [DebuggerBrowsableAttribute("0")]
internal int PrintLength@;
    [DebuggerBrowsableAttribute("0")]
internal int PrintSize@;
    [DebuggerBrowsableAttribute("0")]
internal bool ShowProperties@;
    [DebuggerBrowsableAttribute("0")]
internal bool ShowIEnumerable@;
    [CompilationMappingAttribute("4", "0")]
public string FloatingPointFormat { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> AttributeProcessor { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpList`1<FSharpFunc`2<IEnvironment, FSharpFunc`2<object, FSharpOption`1<Layout>>>> PrintIntercepts { get; }
    [CompilationMappingAttribute("4", "3")]
public int StringLimit { get; }
    [CompilationMappingAttribute("4", "4")]
public IFormatProvider FormatProvider { get; }
    [CompilationMappingAttribute("4", "5")]
public BindingFlags BindingFlags { get; }
    [CompilationMappingAttribute("4", "6")]
public int PrintWidth { get; }
    [CompilationMappingAttribute("4", "7")]
public int PrintDepth { get; }
    [CompilationMappingAttribute("4", "8")]
public int PrintLength { get; }
    [CompilationMappingAttribute("4", "9")]
public int PrintSize { get; }
    [CompilationMappingAttribute("4", "10")]
public bool ShowProperties { get; }
    [CompilationMappingAttribute("4", "11")]
public bool ShowIEnumerable { get; }
    public static FormatOptions Default { get; }
    public FormatOptions(string floatingPointFormat, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> attributeProcessor, FSharpList`1<FSharpFunc`2<IEnvironment, FSharpFunc`2<object, FSharpOption`1<Layout>>>> printIntercepts, int stringLimit, IFormatProvider formatProvider, BindingFlags bindingFlags, int printWidth, int printDepth, int printLength, int printSize, bool showProperties, bool showIEnumerable);
    public string get_FloatingPointFormat();
    public FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> get_AttributeProcessor();
    public FSharpList`1<FSharpFunc`2<IEnvironment, FSharpFunc`2<object, FSharpOption`1<Layout>>>> get_PrintIntercepts();
    public int get_StringLimit();
    public IFormatProvider get_FormatProvider();
    public BindingFlags get_BindingFlags();
    public int get_PrintWidth();
    public int get_PrintDepth();
    public int get_PrintLength();
    public int get_PrintSize();
    public bool get_ShowProperties();
    public bool get_ShowIEnumerable();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static FormatOptions get_Default();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public interface Internal.Utilities.StructuredFormat.IEnvironment {
    public int MaxColumns { get; }
    public int MaxRows { get; }
    public abstract virtual Layout GetLayout(object );
    public abstract virtual int get_MaxColumns();
    public abstract virtual int get_MaxRows();
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Internal.Utilities.StructuredFormat.Joint : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Joint _unique_Unbreakable;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Joint Unbreakable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnbreakable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBreakable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBroken { get; }
    private static Joint();
    [CompilationMappingAttribute("8", "0")]
public static Joint get_Unbreakable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnbreakable();
    [CompilationMappingAttribute("8", "1")]
public static Joint NewBreakable(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBreakable();
    [CompilationMappingAttribute("8", "2")]
public static Joint NewBroken(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBroken();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Joint obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Internal.Utilities.StructuredFormat.Layout : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsObjLeaf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeaf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAttr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Layout(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static Layout NewObjLeaf(bool item1, object item2, bool item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsObjLeaf();
    [CompilationMappingAttribute("8", "1")]
public static Layout NewLeaf(bool item1, TaggedText item2, bool item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeaf();
    [CompilationMappingAttribute("8", "2")]
public static Layout NewNode(bool item1, Layout item2, bool item3, Layout item4, bool item5, Joint item6);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNode();
    [CompilationMappingAttribute("8", "3")]
public static Layout NewAttr(string item1, FSharpList`1<Tuple`2<string, string>> item2, Layout item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAttr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("7")]
public static class Internal.Utilities.StructuredFormat.LayoutOps : object {
    [CompilationMappingAttribute("9")]
public static Layout emptyL { get; }
    internal static bool juxtLeft(Layout _arg1);
    internal static bool juxtRight(Layout _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout mkNode(Layout l, Layout r, Joint joint);
    public static Layout objL(object value);
    public static Layout wordL(TaggedText text);
    public static Layout sepL(TaggedText text);
    public static Layout rightL(TaggedText text);
    public static Layout leftL(TaggedText text);
    public static Layout get_emptyL();
    public static bool isEmptyL(Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout aboveL(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout tagAttrL(string text, FSharpList`1<Tuple`2<string, string>> maps, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout apply2(FSharpFunc`2<Layout, FSharpFunc`2<Layout, Layout>> f, Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_HatHat(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_PlusPlus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_MinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_MinusMinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_AtAt(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_AtAtMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout op_AtAtMinusMinus(Layout layout1, Layout layout2);
    internal static Layout process'@270(FSharpFunc`2<Layout, Layout> tagger, Layout prefixL, FSharpList`1<Layout> _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout tagListL(FSharpFunc`2<Layout, Layout> tagger, FSharpList`1<Layout> _arg1);
    public static Layout commaListL(FSharpList`1<Layout> layouts);
    public static Layout semiListL(FSharpList`1<Layout> layouts);
    public static Layout spaceListL(FSharpList`1<Layout> layouts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout sepListL(Layout layout1, FSharpList`1<Layout> layouts);
    public static Layout bracketL(Layout layout);
    public static Layout tupleL(FSharpList`1<Layout> layouts);
    public static Layout aboveListL(FSharpList`1<Layout> layouts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout optionL(FSharpFunc`2<T, Layout> selector, FSharpOption`1<T> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Layout listL(FSharpFunc`2<T, Layout> selector, FSharpList`1<T> value);
    public static Layout squareBracketL(Layout layout);
    public static Layout braceL(Layout layout);
    internal static FSharpList`1<Layout> consume@304(FSharpFunc`2<a, Layout> itemL, FSharpFunc`2<z, FSharpOption`1<Tuple`2<a, z>>> project, FSharpFunc`2<z, bool> stopShort, int n, z z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Layout> boundedUnfoldL(FSharpFunc`2<a, Layout> itemL, FSharpFunc`2<z, FSharpOption`1<Tuple`2<a, z>>> project, FSharpFunc`2<z, bool> stopShort, z z, int maxLength);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<Layout> unfoldL(FSharpFunc`2<T, Layout> selector, FSharpFunc`2<State, FSharpOption`1<Tuple`2<T, State>>> folder, State state, int count);
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Internal.Utilities.StructuredFormat.LayoutTag : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_ActivePatternCase;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_ActivePatternResult;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Alias;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Union;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_UnionCase;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Delegate;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Enum;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Event;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Field;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Keyword;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_LineBreak;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Local;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Record;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_RecordField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Method;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Member;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_ModuleBinding;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_NumericLiteral;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Operator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Parameter;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Space;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_StringLiteral;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Struct;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_TypeParameter;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Text;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_Punctuation;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_UnknownType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LayoutTag _unique_UnknownEntity;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag ActivePatternCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsActivePatternCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag ActivePatternResult { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsActivePatternResult { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Alias { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAlias { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Union { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag UnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Delegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDelegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Enum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Event { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Field { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Keyword { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsKeyword { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag LineBreak { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLineBreak { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Local { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLocal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Record { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag RecordField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecordField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Method { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Member { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag ModuleBinding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleBinding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag NumericLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNumericLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Operator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Parameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Space { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSpace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag StringLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStringLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Struct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStruct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag TypeParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Text { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsText { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag Punctuation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPunctuation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag UnknownType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknownType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LayoutTag UnknownEntity { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknownEntity { get; }
    private static LayoutTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal LayoutTag(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static LayoutTag get_ActivePatternCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsActivePatternCase();
    [CompilationMappingAttribute("8", "1")]
public static LayoutTag get_ActivePatternResult();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsActivePatternResult();
    [CompilationMappingAttribute("8", "2")]
public static LayoutTag get_Alias();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAlias();
    [CompilationMappingAttribute("8", "3")]
public static LayoutTag get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "4")]
public static LayoutTag get_Union();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnion();
    [CompilationMappingAttribute("8", "5")]
public static LayoutTag get_UnionCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnionCase();
    [CompilationMappingAttribute("8", "6")]
public static LayoutTag get_Delegate();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDelegate();
    [CompilationMappingAttribute("8", "7")]
public static LayoutTag get_Enum();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnum();
    [CompilationMappingAttribute("8", "8")]
public static LayoutTag get_Event();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEvent();
    [CompilationMappingAttribute("8", "9")]
public static LayoutTag get_Field();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "10")]
public static LayoutTag get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "11")]
public static LayoutTag get_Keyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsKeyword();
    [CompilationMappingAttribute("8", "12")]
public static LayoutTag get_LineBreak();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLineBreak();
    [CompilationMappingAttribute("8", "13")]
public static LayoutTag get_Local();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLocal();
    [CompilationMappingAttribute("8", "14")]
public static LayoutTag get_Record();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilationMappingAttribute("8", "15")]
public static LayoutTag get_RecordField();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecordField();
    [CompilationMappingAttribute("8", "16")]
public static LayoutTag get_Method();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethod();
    [CompilationMappingAttribute("8", "17")]
public static LayoutTag get_Member();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMember();
    [CompilationMappingAttribute("8", "18")]
public static LayoutTag get_ModuleBinding();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleBinding();
    [CompilationMappingAttribute("8", "19")]
public static LayoutTag get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "20")]
public static LayoutTag get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "21")]
public static LayoutTag get_NumericLiteral();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNumericLiteral();
    [CompilationMappingAttribute("8", "22")]
public static LayoutTag get_Operator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOperator();
    [CompilationMappingAttribute("8", "23")]
public static LayoutTag get_Parameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParameter();
    [CompilationMappingAttribute("8", "24")]
public static LayoutTag get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilationMappingAttribute("8", "25")]
public static LayoutTag get_Space();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSpace();
    [CompilationMappingAttribute("8", "26")]
public static LayoutTag get_StringLiteral();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStringLiteral();
    [CompilationMappingAttribute("8", "27")]
public static LayoutTag get_Struct();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStruct();
    [CompilationMappingAttribute("8", "28")]
public static LayoutTag get_TypeParameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeParameter();
    [CompilationMappingAttribute("8", "29")]
public static LayoutTag get_Text();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsText();
    [CompilationMappingAttribute("8", "30")]
public static LayoutTag get_Punctuation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPunctuation();
    [CompilationMappingAttribute("8", "31")]
public static LayoutTag get_UnknownType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknownType();
    [CompilationMappingAttribute("8", "32")]
public static LayoutTag get_UnknownEntity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknownEntity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LayoutTag obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.StructuredFormat.ReflectUtils : object {
    [CompilationMappingAttribute("9")]
internal static Type option { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@1 { get; }
    [CompilationMappingAttribute("9")]
internal static Type func { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@1-1 { get; }
    internal static bool isNamedType(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equivHeadTypes(Type ty1, Type ty2);
    internal static Type get_option();
    internal static Type get_ty@1();
    internal static Type get_func();
    internal static Type get_ty@1-1();
    internal static bool isListType(Type ty);
}
[CompilationMappingAttribute("3")]
public interface Internal.Utilities.StructuredFormat.TaggedText {
    public LayoutTag Tag { get; }
    public string Text { get; }
    public abstract virtual LayoutTag get_Tag();
    public abstract virtual string get_Text();
}
[CompilationMappingAttribute("7")]
public static class Internal.Utilities.StructuredFormat.TaggedTextOps : object {
    [CompilationMappingAttribute("9")]
public static FSharpSet`1<string> keywordFunctions { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> keywordTypes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> arg@1 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TaggedText tag(LayoutTag tag, string text);
    public static TaggedText tagAlias(string t);
    public static FSharpSet`1<string> get_keywordFunctions();
    internal static FSharpSet`1<string> get_keywordTypes();
    internal static FSharpList`1<string> get_arg@1();
    public static TaggedText tagClass(string name);
    public static TaggedText tagUnionCase(string t);
    public static TaggedText tagDelegate(string t);
    public static TaggedText tagEnum(string t);
    public static TaggedText tagEvent(string t);
    public static TaggedText tagField(string t);
    public static TaggedText tagInterface(string t);
    public static TaggedText tagKeyword(string t);
    public static TaggedText tagLineBreak(string t);
    public static TaggedText tagLocal(string t);
    public static TaggedText tagRecord(string t);
    public static TaggedText tagRecordField(string t);
    public static TaggedText tagMethod(string t);
    public static TaggedText tagModule(string t);
    public static TaggedText tagModuleBinding(string name);
    public static TaggedText tagNamespace(string t);
    public static TaggedText tagNumericLiteral(string t);
    public static TaggedText tagOperator(string t);
    public static TaggedText tagParameter(string t);
    public static TaggedText tagProperty(string t);
    public static TaggedText tagSpace(string t);
    public static TaggedText tagStringLiteral(string t);
    public static TaggedText tagStruct(string t);
    public static TaggedText tagTypeParameter(string t);
    public static TaggedText tagText(string t);
    public static TaggedText tagPunctuation(string t);
}
[CompilationMappingAttribute("3")]
public interface Internal.Utilities.StructuredFormat.TaggedTextWriter {
    public abstract virtual void Write(TaggedText t);
    public abstract virtual void WriteLine();
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Text.Lexing.GenericImplFragments : object {
    internal static void startInterpret(LexBuffer`1<char> lexBuffer);
    internal static a afterRefill(UInt16[][] trans, int sentinel, LexBuffer`1<char> lexBuffer, FSharpFunc`2<LexBuffer`1<char>, FSharpFunc`2<int, a>> scanUntilSentinel, FSharpFunc`2<Unit, a> endOfScan, int state, int eofPos);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Lexing.LexBuffer`1 : object {
    internal FSharpFunc`2<LexBuffer`1<Char>, Unit> filler;
    internal Dictionary`2<string, object> context;
    internal Char[] buffer;
    internal int bufferMaxScanLength;
    internal int bufferScanStart;
    internal int bufferScanLength;
    internal int lexemeLength;
    internal int bufferAcceptAction;
    internal bool eof;
    internal Position startPos;
    internal Position endPos;
    internal Position StartPos { get; internal set; }
    internal Position EndPos { get; internal set; }
    internal Char[] Lexeme { get; }
    internal IDictionary`2<string, object> BufferLocalStore { get; }
    internal int LexemeLength { get; internal set; }
    internal Char[] Buffer { get; internal set; }
    internal int BufferMaxScanLength { get; internal set; }
    internal int BufferScanLength { get; internal set; }
    internal int BufferScanStart { get; internal set; }
    internal int BufferAcceptAction { get; internal set; }
    internal bool IsPastEndOfStream { get; internal set; }
    internal int BufferScanPos { get; }
    public LexBuffer`1(FSharpFunc`2<LexBuffer`1<Char>, Unit> filler);
    internal int EndOfScan();
    internal Position get_StartPos();
    internal void set_StartPos(Position b);
    internal Position get_EndPos();
    internal void set_EndPos(Position b);
    internal Char[] get_Lexeme();
    internal IDictionary`2<string, object> get_BufferLocalStore();
    internal int get_LexemeLength();
    internal void set_LexemeLength(int v);
    internal Char[] get_Buffer();
    internal void set_Buffer(Char[] v);
    internal int get_BufferMaxScanLength();
    internal void set_BufferMaxScanLength(int v);
    internal int get_BufferScanLength();
    internal void set_BufferScanLength(int v);
    internal int get_BufferScanStart();
    internal void set_BufferScanStart(int v);
    internal int get_BufferAcceptAction();
    internal void set_BufferAcceptAction(int v);
    internal void RefillBuffer();
    internal static string LexemeString(LexBuffer`1<char> lexbuf);
    internal bool get_IsPastEndOfStream();
    internal void set_IsPastEndOfStream(bool b);
    internal void DiscardInput();
    internal int get_BufferScanPos();
    internal void EnsureBufferSize(int n);
    internal static LexBuffer`1<Char> FromFunction(FSharpFunc`2<Tuple`3<Char[], int, int>, int> f);
    internal static LexBuffer`1<Char> FromArrayNoCopy(Char[] buffer);
    internal static LexBuffer`1<Char> FromArray(Char[] s);
    internal static LexBuffer`1<char> FromChars(Char[] arr);
    internal static LexBuffer`1<char> FromSourceText(ISourceText sourceText);
    [CompilerGeneratedAttribute]
internal void discardInput();
}
[StructAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Lexing.Position : ValueType {
    internal int FileIndex@;
    internal int Line@;
    internal int OriginalLine@;
    internal int AbsoluteOffset@;
    internal int StartOfLineAbsoluteOffset@;
    [CompilationMappingAttribute("4", "0")]
internal int FileIndex { get; }
    [CompilationMappingAttribute("4", "1")]
internal int Line { get; }
    [CompilationMappingAttribute("4", "2")]
internal int OriginalLine { get; }
    [CompilationMappingAttribute("4", "3")]
internal int AbsoluteOffset { get; }
    [CompilationMappingAttribute("4", "4")]
internal int StartOfLineAbsoluteOffset { get; }
    internal int Column { get; }
    internal Position NextLine { get; }
    internal Position ColumnMinusOne { get; }
    internal static Position Empty { get; }
    public Position(int fileIndex, int line, int originalLine, int startOfLineAbsoluteOffset, int absoluteOffset);
    internal int get_FileIndex();
    internal int get_Line();
    internal int get_OriginalLine();
    internal int get_AbsoluteOffset();
    internal int get_StartOfLineAbsoluteOffset();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Position obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal int get_Column();
    internal Position get_NextLine();
    internal Position EndOfToken(int n);
    internal Position ShiftColumnBy(int by);
    internal Position get_ColumnMinusOne();
    internal Position ApplyLineDirective(int fileIdx, int line);
    internal static Position get_Empty();
    internal static Position FirstLine(int fileIdx);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Position obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Lexing.UnicodeTables : object {
    internal UInt16[][] trans;
    internal UInt16[] accept;
    internal int sentinel;
    internal int numLowUnicodeChars;
    internal int numSpecificUnicodeChars;
    internal int eofPos;
    public UnicodeTables(UInt16[][] trans, UInt16[] accept);
    internal int Interpret(int initialState, LexBuffer`1<char> lexBuffer);
    internal static UnicodeTables Create(UInt16[][] trans, UInt16[] accept);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal int lookupUnicodeCharacters(int state, char inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal int scanUntilSentinel(LexBuffer`1<char> lexBuffer, int state);
}
[CompilationMappingAttribute("5")]
internal class Internal.Utilities.Text.Parsing.Accept : Exception {
    internal object Data0@;
    [CompilationMappingAttribute("4", "0")]
internal object Data0 { get; }
    internal Accept(object data0);
    protected Accept(SerializationInfo info, StreamingContext context);
    internal object get_Data0();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
internal bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Text.Parsing.Implementation : object {
    internal static int anyMarker { get; }
    internal static int shiftFlag { get; }
    internal static int reduceFlag { get; }
    internal static int errorFlag { get; }
    internal static int acceptFlag { get; }
    internal static int actionMask { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_anyMarker();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_shiftFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_reduceFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_errorFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_acceptFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_actionMask();
    internal static void popStackUntilErrorShifted@255(Tables`1<tok> tables, LexBuffer`1<char> lexbuf, Stack`1<int> stateStack, Stack`1<ValueInfo> valueStack, AssocTable actionTable, FSharpOption`1<tok> tokenOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object interpret(Tables`1<tok> tables, FSharpFunc`2<LexBuffer`1<char>, tok> lexer, LexBuffer`1<char> lexbuf, int initialState);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Parsing.IParseState : object {
    internal Object[] ruleValues;
    internal Position[] ruleStartPoss;
    internal Position[] ruleEndPoss;
    internal Position[] lhsPos;
    internal LexBuffer`1<char> lexbuf;
    internal LexBuffer`1<char> LexBuffer { get; }
    internal Position ResultStartPosition { get; }
    internal Position ResultEndPosition { get; }
    internal Tuple`2<Position, Position> ResultRange { get; }
    public IParseState(Position[] ruleStartPoss, Position[] ruleEndPoss, Position[] lhsPos, Object[] ruleValues, LexBuffer`1<char> lexbuf);
    internal LexBuffer`1<char> get_LexBuffer();
    internal Tuple`2<Position, Position> InputRange(int index);
    internal Position InputStartPosition(int n);
    internal Position InputEndPosition(int n);
    internal Position get_ResultStartPosition();
    internal Position get_ResultEndPosition();
    internal object GetInput(int n);
    internal Tuple`2<Position, Position> get_ResultRange();
    internal b RaiseError();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Parsing.ParseErrorContext`1 : object {
    internal FSharpList`1<int> stateStack;
    internal FSharpList`1<int> shiftableTokens;
    internal FSharpList`1<FSharpList`1<int>> reducibleProductions;
    internal FSharpList`1<int> reduceTokens;
    internal IParseState parseState;
    internal string message;
    internal FSharpOption`1<tok> currentToken;
    internal FSharpList`1<int> StateStack { get; }
    internal FSharpList`1<int> ReduceTokens { get; }
    internal FSharpOption`1<tok> CurrentToken { get; }
    internal IParseState ParseState { get; }
    internal FSharpList`1<FSharpList`1<int>> ReducibleProductions { get; }
    internal FSharpList`1<int> ShiftTokens { get; }
    internal string Message { get; }
    public ParseErrorContext`1(FSharpList`1<int> stateStack, IParseState parseState, FSharpList`1<int> reduceTokens, FSharpOption`1<tok> currentToken, FSharpList`1<FSharpList`1<int>> reducibleProductions, FSharpList`1<int> shiftableTokens, string message);
    internal FSharpList`1<int> get_StateStack();
    internal FSharpList`1<int> get_ReduceTokens();
    internal FSharpOption`1<tok> get_CurrentToken();
    internal IParseState get_ParseState();
    internal FSharpList`1<FSharpList`1<int>> get_ReducibleProductions();
    internal FSharpList`1<int> get_ShiftTokens();
    internal string get_Message();
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Text.Parsing.ParseHelpers : object {
    internal static void parse_error(string _s);
    internal static FSharpOption`1<FSharpFunc`2<ParseErrorContext`1<tok>, Unit>> parse_error_rich();
}
[CompilationMappingAttribute("5")]
internal class Internal.Utilities.Text.Parsing.RecoverableParseError : Exception {
    protected RecoverableParseError(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
internal bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Parsing.Stack`1 : object {
    internal a[] contents;
    internal int count;
    internal int Count { get; }
    internal bool IsEmpty { get; }
    public Stack`1(int n);
    internal void Ensure(int newSize);
    internal int get_Count();
    internal void Pop();
    internal a Peep();
    internal FSharpList`1<a> Top(int n);
    internal void Push(a x);
    internal bool get_IsEmpty();
    internal void PrintStack();
}
[CompilationMappingAttribute("34")]
internal class Internal.Utilities.Text.Parsing.Tables`1 : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2[] reductions@;
    [DebuggerBrowsableAttribute("0")]
internal int endOfInputTag@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<tok, int> tagOfToken@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<tok, object> dataOfToken@;
    [DebuggerBrowsableAttribute("0")]
internal UInt16[] actionTableElements@;
    [DebuggerBrowsableAttribute("0")]
internal UInt16[] actionTableRowOffsets@;
    [DebuggerBrowsableAttribute("0")]
internal UInt16[] reductionSymbolCounts@;
    [DebuggerBrowsableAttribute("0")]
internal UInt16[] immediateActions@;
    [DebuggerBrowsableAttribute("0")]
internal UInt16[] gotos@;
    [DebuggerBrowsableAttribute("0")]
internal UInt16[] sparseGotoTableRowOffsets@;
    [DebuggerBrowsableAttribute("0")]
internal UInt16[] stateToProdIdxsTableElements@;
    [DebuggerBrowsableAttribute("0")]
internal UInt16[] stateToProdIdxsTableRowOffsets@;
    [DebuggerBrowsableAttribute("0")]
internal UInt16[] productionToNonTerminalTable@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<ParseErrorContext`1<tok>, Unit> parseError@;
    [DebuggerBrowsableAttribute("0")]
internal int numTerminals@;
    [DebuggerBrowsableAttribute("0")]
internal int tagOfErrorTerminal@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpFunc`2[] reductions { get; }
    [CompilationMappingAttribute("4", "1")]
internal int endOfInputTag { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpFunc`2<tok, int> tagOfToken { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpFunc`2<tok, object> dataOfToken { get; }
    [CompilationMappingAttribute("4", "4")]
internal UInt16[] actionTableElements { get; }
    [CompilationMappingAttribute("4", "5")]
internal UInt16[] actionTableRowOffsets { get; }
    [CompilationMappingAttribute("4", "6")]
internal UInt16[] reductionSymbolCounts { get; }
    [CompilationMappingAttribute("4", "7")]
internal UInt16[] immediateActions { get; }
    [CompilationMappingAttribute("4", "8")]
internal UInt16[] gotos { get; }
    [CompilationMappingAttribute("4", "9")]
internal UInt16[] sparseGotoTableRowOffsets { get; }
    [CompilationMappingAttribute("4", "10")]
internal UInt16[] stateToProdIdxsTableElements { get; }
    [CompilationMappingAttribute("4", "11")]
internal UInt16[] stateToProdIdxsTableRowOffsets { get; }
    [CompilationMappingAttribute("4", "12")]
internal UInt16[] productionToNonTerminalTable { get; }
    [CompilationMappingAttribute("4", "13")]
internal FSharpFunc`2<ParseErrorContext`1<tok>, Unit> parseError { get; }
    [CompilationMappingAttribute("4", "14")]
internal int numTerminals { get; }
    [CompilationMappingAttribute("4", "15")]
internal int tagOfErrorTerminal { get; }
    internal Tables`1(FSharpFunc`2[] reductions, int endOfInputTag, FSharpFunc`2<tok, int> tagOfToken, FSharpFunc`2<tok, object> dataOfToken, UInt16[] actionTableElements, UInt16[] actionTableRowOffsets, UInt16[] reductionSymbolCounts, UInt16[] immediateActions, UInt16[] gotos, UInt16[] sparseGotoTableRowOffsets, UInt16[] stateToProdIdxsTableElements, UInt16[] stateToProdIdxsTableRowOffsets, UInt16[] productionToNonTerminalTable, FSharpFunc`2<ParseErrorContext`1<tok>, Unit> parseError, int numTerminals, int tagOfErrorTerminal);
    internal FSharpFunc`2[] get_reductions();
    internal int get_endOfInputTag();
    internal FSharpFunc`2<tok, int> get_tagOfToken();
    internal FSharpFunc`2<tok, object> get_dataOfToken();
    internal UInt16[] get_actionTableElements();
    internal UInt16[] get_actionTableRowOffsets();
    internal UInt16[] get_reductionSymbolCounts();
    internal UInt16[] get_immediateActions();
    internal UInt16[] get_gotos();
    internal UInt16[] get_sparseGotoTableRowOffsets();
    internal UInt16[] get_stateToProdIdxsTableElements();
    internal UInt16[] get_stateToProdIdxsTableRowOffsets();
    internal UInt16[] get_productionToNonTerminalTable();
    internal FSharpFunc`2<ParseErrorContext`1<tok>, Unit> get_parseError();
    internal int get_numTerminals();
    internal int get_tagOfErrorTerminal();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal object Interpret(FSharpFunc`2<LexBuffer`1<char>, tok> lexer, LexBuffer`1<char> lexbuf, int startState);
}
[CompilationMappingAttribute("7")]
internal static class Microsoft.FSharp.Core.XmlAdapters : object {
    [CompilationMappingAttribute("9")]
internal static Char[] s_escapeChars { get; }
    internal static Char[] get_s_escapeChars();
    internal static string getEscapeSequence(char c);
    internal static string escape(string str);
}
