[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target")]
[CompilationMappingAttribute("7")]
public static class Fake.AdditionalSyntax : object {
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, string> sameLevels { get; }
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.TargetOperators.(?)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b op_Dynamic(FSharpFunc`2<a, b> f, a s);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.TargetOperators.(?<-)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c op_DynamicAssignment(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, a str, b action);
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - no longer supported)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void For(string x, FSharpList`1<string> y);
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - no longer supported)")]
public static FSharpList`1<a> Dependency(a x);
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - no longer supported)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<a> And(a x, FSharpList`1<a> y);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.run)")]
public static void Run(string targetName);
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - no longer supported)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RunParameterTargetOrDefault(string parameterName, string defaultTarget);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.runOrDefault)")]
public static void RunTargetOrDefault(string defaultTarget);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.runOrList)")]
public static void RunTargetOrListTargets();
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.runOrDefault with "" default target)")]
public static void RunTarget();
    internal static Dictionary`2<string, string> get_sameLevels();
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void targetsAreOnSameLevel(string x, string y);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void addDependenciesOnSameLevel(string target, string dependency);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void addSoftDependenciesOnSameLevel(string target, string dependency);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.TargetOperators.(==>)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_EqualsEqualsGreater(string x, string y);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.TargetOperators.(?=>)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_QmarkEqualsGreater(string x, string y);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.TargetOperators.(<=?)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_LessEqualsQmark(string y, string x);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.TargetOperators.(<=>)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_LessEqualsGreater(string x, string y);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.TargetOperators.(=?>)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_EqualsQmarkGreater(string x, string y, bool condition);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.AndroidPublisher : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static AndroidPublishParams ProductionSettings { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static AndroidPublishParams AlphaSettings { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static AndroidPublishParams BetaSettings { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static AndroidPublishParams RolloutSettings { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string AndroidPublisherScope { get; public set; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string TokenServerUrl { get; public set; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string AndroidPublisherBaseUrl { get; public set; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string AndroidUploadApkBaseUrl { get; public set; }
    [CompilationMappingAttribute("9")]
internal static JwtHeader ServiceAccountHeader { get; }
    public static AndroidPublishParams get_ProductionSettings();
    public static AndroidPublishParams get_AlphaSettings();
    public static AndroidPublishParams get_BetaSettings();
    public static AndroidPublishParams get_RolloutSettings();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@74-466(JwtClaimSet this, JwtClaimSet obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@74-467(JwtClaimSet this, JwtClaimSet objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@74-96(JwtClaimSet this, Unit unitVar);
    public static string get_AndroidPublisherScope();
    public static void set_AndroidPublisherScope(string value);
    public static string get_TokenServerUrl();
    public static void set_TokenServerUrl(string value);
    public static string get_AndroidPublisherBaseUrl();
    public static void set_AndroidPublisherBaseUrl(string value);
    public static string get_AndroidUploadApkBaseUrl();
    public static void set_AndroidUploadApkBaseUrl(string value);
    internal static JwtHeader get_ServiceAccountHeader();
    internal static string toJson(a arg00);
    internal static t fromJson(string v);
    internal static string clean@165(string name);
    internal static FSharpOption`1<Byte[]> searchEntry@166(string path, ZipInputStream tupledArg0, ZipEntry tupledArg1);
    internal static FSharpOption`1<Byte[]> getZipEntry@164(string tupledArg0, string tupledArg1);
    internal static int lew@189(Byte[] tupledArg0, int tupledArg1);
    internal static FSharpOption`1<int> scanStartOfFirstTag@197(Byte[] data, int offset);
    internal static string readStringAt@207(Byte[] data, int offset);
    internal static string readString@211(Byte[] data, int tupledArg0, int tupledArg1, int tupledArg2);
    internal static string readNode@218(Byte[] data, int stOff, string acc, int off);
    internal static string manifestDecode@183(Byte[] data);
    internal static FSharpOption`1<XDocument> getManifest@249(string filepath);
    internal static string header@254-3(ServiceSession s);
    internal static RSACryptoServiceProvider createRsaCrypto@257(ServiceCredentials credentials);
    internal static string base64EncodeUrl@265(string s);
    internal static long toUnixTime@267(DateTime d);
    internal static Byte[] postUrl@269(string tupledArg0, NameValueCollection tupledArg1);
    internal static ServiceSession googleAuthenticate@273(ServiceCredentials credentials);
    internal static EditResourceModel appEditInsert@289(ServiceSession tupledArg0, string tupledArg1);
    internal static AppEditListApksResult appListApks@294(ServiceSession tupledArg0, string tupledArg1, string tupledArg2);
    internal static EditResourceModel validateAppEdit@299(ServiceSession tupledArg0, string tupledArg1, string tupledArg2);
    internal static EditResourceModel commitAppEdit@304(ServiceSession tupledArg0, string tupledArg1, string tupledArg2);
    internal static EditResourceModel setAppTrack@309(ServiceSession tupledArg0, string tupledArg1, string tupledArg2, string tupledArg3, int tupledArg4);
    internal static Result`1<ApkVersion> uploadApk@319(ServiceSession tupledArg0, string tupledArg1, string tupledArg2, string tupledArg3);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void PublishApk(AndroidPublishParams param);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Api.GitHub : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-188(CreateReleaseParams this, CreateReleaseParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-189(CreateReleaseParams this, CreateReleaseParams objTemp, int n, Unit unitVar);
    internal static a captureAndReraise(Exception ex);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<a> catchHandler@1-7(int count, FSharpAsync`1<a> asyncF, Exception _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<a> retry(int count, FSharpAsync`1<a> asyncF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<b> retryWithArg(int count, FSharpAsync`1<a> input, FSharpFunc`2<a, FSharpAsync`1<b>> asycnF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<GitHubClient> createClient(string user, string password);
    public static FSharpAsync`1<GitHubClient> createClientWithToken(string token);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<GitHubClient> createGHEClient(string url, string user, string password);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<GitHubClient> createGHEClientWithToken(string url, string token);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Release> createRelease(string owner, string repoName, string tagName, FSharpFunc`2<CreateReleaseParams, CreateReleaseParams> setParams, FSharpAsync`1<GitHubClient> client);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Release> draftNewRelease(string owner, string repoName, string tagName, bool prerelease, IEnumerable`1<string> notes, FSharpAsync`1<GitHubClient> client);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Release> uploadFile(string fileName, FSharpAsync`1<Release> release);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Release> uploadFiles(IEnumerable`1<string> fileNames, FSharpAsync`1<Release> release);
    public static FSharpAsync`1<Unit> publishDraft(FSharpAsync`1<Release> release);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Release> getLastRelease(string owner, string repoName, FSharpAsync`1<GitHubClient> client);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Release> getReleaseByTag(string owner, string repoName, string tagName, FSharpAsync`1<GitHubClient> client);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Unit> downloadAsset(int id, string destination, FSharpAsync`1<Release> release);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Unit> downloadAssets(string destination, FSharpAsync`1<Release> release);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Api.HockeyApp : object {
    [CompilationMappingAttribute("9")]
public static HockeyAppUploadParams HockeyAppUploadDefaults { get; }
    [CompilationMappingAttribute("9")]
public static HockeyAppVersionParams HockeyAppVersionDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string nl { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@49-197(HockeyResponse this, HockeyResponse obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@49-196(HockeyResponse this, HockeyResponse obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@49-199(HockeyResponse this, HockeyResponse objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@49-198(HockeyResponse this, HockeyResponse objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@49-38(HockeyResponse this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@49-81(HockeyResponse this, HockeyResponse that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@49-82(HockeyResponse this, HockeyResponse obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@82-200(HockeyVersionResponse this, HockeyVersionResponse obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@82-201(HockeyVersionResponse this, HockeyVersionResponse objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@82-39(HockeyVersionResponse this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@82-83(HockeyVersionResponse this, object obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@135-205(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@135-204(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@135-203(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@135-202(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@135-209(IComparer comp, HockeyAppUploadParams this, HockeyAppUploadParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@135-208(IComparer comp, HockeyAppUploadParams this, HockeyAppUploadParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@135-207(IComparer comp, HockeyAppUploadParams this, HockeyAppUploadParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@135-206(IComparer comp, HockeyAppUploadParams this, HockeyAppUploadParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@135-40(IEqualityComparer comp, HockeyAppUploadParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@135-85(HockeyAppUploadParams this, HockeyAppUploadParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@135-84(HockeyAppUploadParams this, HockeyAppUploadParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@135-86(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    public static HockeyAppUploadParams get_HockeyAppUploadDefaults();
    public static HockeyAppVersionParams get_HockeyAppVersionDefaults();
    internal static string get_nl();
    internal static HockeyAppUploadParams validateParams(HockeyAppUploadParams param);
    internal static HockeyAppVersionParams validateVersionParams(HockeyAppVersionParams param);
    internal static IEnumerable`1<string> toCurlArgs(HockeyAppUploadParams param);
    internal static IEnumerable`1<string> toVersionCurlArgs(HockeyAppVersionParams param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TResponse processHockeyAppCmd(TParam defaults, FSharpFunc`2<TParam, TParam> setParams, FSharpFunc`2<TParam, TParam> validateParam, FSharpFunc`2<TParam, IEnumerable`1<string>> toCurlArgs);
    public static HockeyResponse uploadApp(FSharpFunc`2<HockeyAppUploadParams, HockeyAppUploadParams> setParams);
    public static HockeyVersionResponse createAppVersion(FSharpFunc`2<HockeyAppVersionParams, HockeyAppVersionParams> setParams);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Api.Slack : object {
    [CompilationMappingAttribute("9")]
public static NotificationParams NotificationDefaults { get; }
    [CompilationMappingAttribute("9")]
public static NotificationAttachmentParams NotificationAttachmentDefaults { get; }
    [CompilationMappingAttribute("9")]
public static NotificationAttachmentFieldParams NotificationAttachmentFieldDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static DefaultContractResolver lowerCaseContractResolver { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@24-190(NotificationAttachmentParams this, NotificationAttachmentParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@24-191(IComparer comp, NotificationAttachmentParams this, NotificationAttachmentParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@24-32(IEqualityComparer comp, NotificationAttachmentParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@42-192(NotificationParams this, NotificationParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@42-193(IComparer comp, NotificationParams this, NotificationParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@42-33(IEqualityComparer comp, NotificationParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@42-77(NotificationParams this, object obj, IEqualityComparer comp, Unit unitVar);
    public static NotificationParams get_NotificationDefaults();
    public static NotificationAttachmentParams get_NotificationAttachmentDefaults();
    public static NotificationAttachmentFieldParams get_NotificationAttachmentFieldDefaults();
    internal static DefaultContractResolver get_lowerCaseContractResolver();
    internal static void validateField@101(NotificationAttachmentFieldParams field);
    internal static void validateAttachment@104(NotificationAttachmentParams attachment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NotificationParams ValidateParams(string webhookURL, NotificationParams param);
    internal static string SerializeData(a data);
    internal static string sendNotification@120(string webhookURL, a param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string sendNotification(string webhookURL, FSharpFunc`2<NotificationParams, NotificationParams> setParams);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.Appcast : object {
    [CompilationMappingAttribute("9")]
internal static XNamespace sparkle { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XDeclaration XDeclaration(string version, string encoding, string standalone);
    internal static XName XName(string expandedName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XDocument XDocument(XDeclaration xdecl, IEnumerable`1<a> content);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object XElement(string expandedName, IEnumerable`1<a> content);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object XAttribute(string expandedName, a value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object XAttributeXName(XName expandedName, a value);
    internal static XNamespace get_sparkle();
    internal static string mtToString@113(MimeType mimetype);
    internal static FSharpFunc`2<FSharpList`1<b>, FSharpList`1<b>> appendSome@121(FSharpOption`1<a> option, FSharpFunc`2<a, b> consequence);
    internal static XDocument toXml@112(Appcast cast);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeAppcast(string path, Appcast cast);
}
[ObsoleteAttribute("please use nuget 'Fake.BuildServer.AppVeyor', open Fake.BuildServer and use AppVeyor instead")]
[CompilationMappingAttribute("7")]
public static class Fake.AppVeyor : object {
    [CompilationMappingAttribute("9")]
internal static BuildServer y@1-3 { get; }
    [ObsoleteAttribute("This should no longer be required (use 'Fake.BuildServer.AppVeyor').")]
[CompilationMappingAttribute("9")]
public static PushArtifactParams defaultPushArtifactParams { get; }
    [CompilationMappingAttribute("9")]
internal static UpdateBuildParams defaultUpdateBuildParams { get; }
    internal static void sendToAppVeyor(string args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void add(string msg, string category);
    internal static void addNoCategory(string msg);
    internal static BuildServer get_y@1-3();
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.AppVeyor', install the build-server and use 'use dis = Trace.traceTag (KnownTags.TestSuite name)' instead")]
public static void FinishTestSuite(a testSuiteName);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.AppVeyor', install the build-server and use 'use dis = Trace.traceTag (KnownTags.TestSuite name)' instead")]
public static void StartTestSuite(a testSuiteName);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.AppVeyor', install the build-server and use 'use dis = Trace.traceTag (KnownTags.Test name)' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void StartTestCase(string testSuiteName, string testCaseName);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.AppVeyor', install the build-server and use 'Trace.testStatus testName (TestStatus.Failed(message, details, None))' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void TestFailed(string testSuiteName, string testCaseName, string message, string details);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.AppVeyor', install the build-server and use 'Trace.testStatus testName (TestStatus.Ignore(message))' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void IgnoreTestCase(string testSuiteName, string testCaseName, a message);
    [ObsoleteAttribute("please remove this call, success is implicit.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void TestSucceeded(string testSuiteName, string testCaseName);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.AppVeyor', install the build-server and use 'use dis = Trace.traceTag (KnownTags.Test name)' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FinishTestCase(string testSuiteName, string testCaseName, TimeSpan duration);
    [ObsoleteAttribute("This should no longer be required (install 'Fake.BuildServer.AppVeyor') and use 'Trace.publish (ImportData.<type>) file'.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void UploadTestResultsFile(TestResultsType testResultsType, string file);
    [ObsoleteAttribute("This should no longer be required (install 'Fake.BuildServer.AppVeyor') and use 'Trace.publish (ImportData.<type>) file'.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void UploadTestResultsXml(TestResultsType testResultsType, string outputDir);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.AppVeyor', open Fake.BuildServer and use AppVeyor.setVariable instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SetVariable(string name, string value);
    public static PushArtifactParams get_defaultPushArtifactParams();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StringBuilder appendArgIfNotNullOrEmpty(string value, string name, StringBuilder builder);
    [ObsoleteAttribute("This should no longer be required (install 'Fake.BuildServer.AppVeyor') and use 'Trace.publish ImportData.BuildArtifact file'.")]
public static void PushArtifact(FSharpFunc`2<PushArtifactParams, PushArtifactParams> setParams);
    [ObsoleteAttribute("This should no longer be required (install 'Fake.BuildServer.AppVeyor') and use 'Trace.publish ImportData.BuildArtifact file'.")]
public static void PushArtifacts(IEnumerable`1<string> paths);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@335-236(UpdateBuildParams this, UpdateBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@335-237(IComparer comp, UpdateBuildParams this, UpdateBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@335-49(IEqualityComparer comp, UpdateBuildParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@335-97(UpdateBuildParams this, object obj, IEqualityComparer comp, Unit unitVar);
    internal static UpdateBuildParams get_defaultUpdateBuildParams();
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.AppVeyor', open Fake.BuildServer and use AppVeyor.updateBuild instead")]
public static void UpdateBuild(FSharpFunc`2<UpdateBuildParams, UpdateBuildParams> setParams);
    [ObsoleteAttribute("This should no longer be required (install 'Fake.BuildServer.AppVeyor') and use 'Trace.setBuildNumber version'.")]
public static void UpdateBuildVersion(string version);
}
[ObsoleteAttribute("Please use Fake.IO.Zip instead and extend it via Pull Request if required")]
[CompilationMappingAttribute("7")]
public static class Fake.ArchiveHelper : object {
    [LiteralAttribute]
[ObsoleteAttribute("Please use Fake.IO.Zip instead and extend it via Pull Request if required")]
[DebuggerBrowsableAttribute("0")]
internal static int DefaultBufferSize;
    private static ArchiveHelper();
    internal static void doCopy@18(Byte[] buffer, c outStream, d inStream, long length);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void copyStreamBuffered(int bufferSize, a outStream, b inStream, long length);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void copyFileBuffered(int bufferSize, a outStream, b inStream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c addEntry(FSharpFunc`2<FileInfo, FSharpFunc`2<string, a>> prepareEntry, FSharpFunc`2<b, c> afterEntry, b outStream, ArchiveFileSpec _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void extractEntry(a inStream, ExtractEntrySpec entry);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a createArchiveStream(FSharpFunc`2<Stream, a> streamCreator, FileInfo archiveFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a openArchiveStream(FSharpFunc`2<Stream, a> streamCreator, FileInfo archiveFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createArchive(FSharpFunc`2<FileInfo, a> streamCreator, FSharpFunc`2<a, FSharpFunc`2<b, Unit>> addEntry, FileInfo archiveFile, IEnumerable`1<b> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void extractEntries(FSharpFunc`2<a, FSharpOption`1<ExtractEntrySpec>> getNextEntry, a inStream);
    [ObsoleteAttribute("Please use Fake.IO.Zip instead and extend it via Pull Request if required")]
public static ArchiveFileSpec archiveFileSpec(FileInfo file);
    [ObsoleteAttribute("Please use Fake.IO.Zip instead and extend it via Pull Request if required")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArchiveFileSpec archiveFileSpecWithBaseDir(DirectoryInfo baseDir, FileInfo file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<IEnumerable`1<d>, c> doCompression(FSharpFunc`2<a, FSharpFunc`2<IEnumerable`1<b>, c>> compressor, a archivePath, FSharpFunc`2<d, b> fileSpecGenerator);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FileInfo, ArchiveFileSpec> buildFileSpec(bool flatten, DirectoryInfo baseDir);
    internal static IEnumerable`1<FileInfo> allFilesInDirectory(DirectoryInfo baseDir);
}
[ObsoleteAttribute("FAKE0001 Use Fake.DotNet.AssemblyInfoFile instead")]
[CompilationMappingAttribute("7")]
public static class Fake.AssemblyInfoFile : object {
    [CompilationMappingAttribute("9")]
internal static Regex assemblyVersionRegex { get; }
    internal static string regexAttrNameValueCs { get; }
    internal static string regexAttrNameValueFs { get; }
    internal static string regexAttrNameValueCpp { get; }
    internal static string regexAttrNameValueVb { get; }
    [ObsoleteAttribute("FAKE0001 Use Fake.DotNet.AssemblyInfoFile instead")]
public static FSharpChoice`4<Unit, Unit, Unit, Unit> |Fsproj|Csproj|Vbproj|Shproj|(string projFileName);
    internal static Regex get_assemblyVersionRegex();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_regexAttrNameValueCs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_regexAttrNameValueFs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_regexAttrNameValueCpp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_regexAttrNameValueVb();
    internal static string regexAttrValueCs(string name);
    internal static string regexAttrValueFs(string name);
    internal static string regexAttrValueCpp(string name);
    internal static string regexAttrValueVb(string name);
    internal static string NormalizeVersion(string version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeToFile(string outputFileName, IEnumerable`1<string> lines);
    internal static FSharpList`1<string> getDependencies(IEnumerable`1<Attribute> attributes);
    internal static string getAssemblyVersionInfo(IEnumerable`1<Attribute> attributes);
    internal static string getAssemblyInformationalVersion(IEnumerable`1<Attribute> attributes);
    internal static IEnumerable`1<Tuple`3<string, string, string>> getSortedAndNumberedAttributes(IEnumerable`1<Attribute> attrs);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.createCSharpWithConfig' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateCSharpAssemblyInfoWithConfig(string outputFileName, IEnumerable`1<Attribute> attributes, AssemblyInfoFileConfig config);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.createFSharpWithConfig' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateFSharpAssemblyInfoWithConfig(string outputFileName, IEnumerable`1<Attribute> attributes, AssemblyInfoFileConfig config);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.createVisualBasicWithConfig' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateVisualBasicAssemblyInfoWithConfig(string outputFileName, IEnumerable`1<Attribute> attributes, AssemblyInfoFileConfig config);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.createCppCliWithConfig' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateCppCliAssemblyInfoWithConfig(string outputFileName, IEnumerable`1<Attribute> attributes, AssemblyInfoFileConfig config);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.createCSharp' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateCSharpAssemblyInfo(string outputFileName, IEnumerable`1<Attribute> attributes);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.createFSharp' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateFSharpAssemblyInfo(string outputFileName, IEnumerable`1<Attribute> attributes);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.createVisualBasic' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateVisualBasicAssemblyInfo(string outputFileName, IEnumerable`1<Attribute> attributes);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.createCppCli' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateCppCliAssemblyInfo(string outputFileName, IEnumerable`1<Attribute> attributes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string removeAtEnd(string textToRemove, string text);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.getAttributes' instead")]
public static IEnumerable`1<Attribute> GetAttributes(string assemblyInfoFile);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.getAttribute' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Attribute> GetAttribute(string attrName, string assemblyInfoFile);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.getAttributeValue' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> GetAttributeValue(string attrName, string assemblyInfoFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string updateAttr(FSharpFunc`2<string, string> regexFactory, RegexOptions additionalRegexOptions, string text, Attribute attribute);
    [ObsoleteAttribute("FAKE0001 Use 'open Fake.DotNet' and 'AssemblyInfoFile.updateAttributes' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void UpdateAttributes(string assemblyInfoFile, IEnumerable`1<Attribute> attributes);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.DotNet.AssemblyInfoFile instead")]
[CompilationMappingAttribute("7")]
public static class Fake.AssemblyInfoHelper : object {
    [ObsoleteAttribute("Use Fake.DotNet.AssemblyInfoFile instead")]
[CompilationMappingAttribute("9")]
public static AssemblyInfoParams AssemblyInfoDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static Guid copyOfStruct@50-3 { get; internal set; }
    [ObsoleteAttribute("Use Fake.DotNet.AssemblyInfoFile instead, generating files is safer than replacing contents")]
[CompilationMappingAttribute("9")]
public static AssemblyInfoReplacementParams AssemblyInfoReplacementDefaults { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@22-291(AssemblyInfoParams this, AssemblyInfoParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@22-290(AssemblyInfoParams this, AssemblyInfoParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@22-289(AssemblyInfoParams this, AssemblyInfoParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@22-294(IComparer comp, AssemblyInfoParams this, AssemblyInfoParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@22-293(IComparer comp, AssemblyInfoParams this, AssemblyInfoParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@22-292(IComparer comp, AssemblyInfoParams this, AssemblyInfoParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@22-121(AssemblyInfoParams this, AssemblyInfoParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@22-122(AssemblyInfoParams this, AssemblyInfoParams obj, Unit unitVar);
    public static AssemblyInfoParams get_AssemblyInfoDefaults();
    internal static Guid get_copyOfStruct@50-3();
    internal static void set_copyOfStruct@50-3(Guid value);
    [CompilerGeneratedAttribute]
internal static string addString$cont@95(Dictionary`2<string, string> attributes, CodeCompileUnit codeCompileUnit, Unit unitVar);
    [ObsoleteAttribute("Use Fake.DotNet.AssemblyInfoFile instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void generateFile(AssemblyInfoParams param, Dictionary`2<string, string> attributes, IEnumerable`1<string> imports, TextWriter writer);
    internal static void writeAttribute@152(Dictionary`2<string, string> attributes, string name, string attribute);
    internal static void writeAttributeOption@155(FSharpFunc`2<string, FSharpFunc`2<string, Unit>> writeAttribute, string name, FSharpOption`1<a> _arg1);
    [ObsoleteAttribute("Please use the new AssemblyInfoFile tasks")]
public static void AssemblyInfo(FSharpFunc`2<AssemblyInfoParams, AssemblyInfoParams> setParams);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@210-295(AssemblyInfoReplacementParams this, AssemblyInfoReplacementParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@210-296(IComparer comp, AssemblyInfoReplacementParams this, AssemblyInfoReplacementParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@210-59(IEqualityComparer comp, AssemblyInfoReplacementParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@210-123(AssemblyInfoReplacementParams this, object obj, IEqualityComparer comp, Unit unitVar);
    public static AssemblyInfoReplacementParams get_AssemblyInfoReplacementDefaults();
    internal static FSharpFunc`2<string, string> replaceAttribute@236(string attributeName, string value);
    internal static FSharpFunc`2<string, string> replaceSingleMetadataAttribute@241(string key, string value);
    internal static FSharpFunc`2<string, string> replaceMetadataAttributes@240(FSharpList`1<Tuple`2<string, string>> metadata);
    [ObsoleteAttribute("Use Fake.DotNet.AssemblyInfoFile instead, generating files is safer than replacing contents")]
public static void ReplaceAssemblyInfoVersions(FSharpFunc`2<AssemblyInfoReplacementParams, AssemblyInfoReplacementParams> param);
    [CompilerGeneratedAttribute]
internal static AssemblyInfoReplacementParams func1@1-29(string file, AssemblyInfoReplacementParams p);
    [ObsoleteAttribute("Use Fake.DotNet.AssemblyInfoFile instead, generating files is safer than replacing contents")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void BulkReplaceAssemblyInfoVersions(string dir, FSharpFunc`2<AssemblyInfoReplacementParams, AssemblyInfoReplacementParams> replacementParameters);
    [CompilerGeneratedAttribute]
internal static AssemblyInfoReplacementParams func1@1-30(string file, AssemblyInfoReplacementParams p);
    [ObsoleteAttribute("Use Fake.DotNet.AssemblyInfoFile instead, generating files is safer than replacing contents")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ReplaceAssemblyInfoVersionsBulk(FileIncludes fileIncludes, FSharpFunc`2<AssemblyInfoReplacementParams, AssemblyInfoReplacementParams> replacementParameters);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Azure.CloudServices : object {
    [CompilationMappingAttribute("9")]
public static PackageCloudServiceParams DefaultCloudServiceParams { get; }
    public static PackageCloudServiceParams get_DefaultCloudServiceParams();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void modifyVMSize(VmSize _arg1, string cloudService);
    [CompilerGeneratedAttribute]
internal static void func2@1-6(DirectoryInfo dir);
    public static FSharpOption`1<int> packageRole(PackageCloudServiceParams packageCloudServiceParams);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Azure.Emulators : object {
    [CompilationMappingAttribute("9")]
public static string msSdkBasePath { get; }
    [CompilationMappingAttribute("9")]
internal static AzureEmulatorParams AzureEmulatorDefaults { get; }
    public static string get_msSdkBasePath();
    internal static AzureEmulatorParams get_AzureEmulatorDefaults();
    internal static FSharpChoice`4<Unit, Unit, Unit, Unit> |StorageAlreadyStarted|StorageAlreadyStopped|Ok|OtherError|(int _arg1);
    public static void stopStorageEmulator(a _arg1);
    public static void startStorageEmulator(a _arg1);
    public static void stopComputeEmulator(a _arg1);
    public static void startComputeEmulator(a _arg1);
    public static void resetDevStorage(a _arg1);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Azure.Kudu : object {
    [CompilationMappingAttribute("9")]
public static string deploymentTemp { get; }
    [CompilationMappingAttribute("9")]
public static string deploymentTarget { get; }
    [CompilationMappingAttribute("9")]
public static string nextManifestPath { get; }
    [CompilationMappingAttribute("9")]
public static string previousManifestPath { get; }
    [CompilationMappingAttribute("9")]
public static DirectoryInfo kuduPath { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> arg@1-6 { get; }
    [CompilationMappingAttribute("9")]
internal static DirectoryInfo arg@1-7 { get; }
    [CompilationMappingAttribute("9")]
internal static DirectoryInfo arg@1-8 { get; }
    public static string get_deploymentTemp();
    public static string get_deploymentTarget();
    public static string get_nextManifestPath();
    public static string get_previousManifestPath();
    public static DirectoryInfo get_kuduPath();
    internal static FSharpOption`1<string> get_arg@1-6();
    internal static DirectoryInfo get_arg@1-7();
    internal static DirectoryInfo get_arg@1-8();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void stageFolder(string source, FSharpFunc`2<string, bool> shouldInclude);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getWebJobPath(WebJobType webJobType, string webJobName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void stageWebJob(WebJobType webJobType, string webJobName, IEnumerable`1<string> files);
    public static void kuduSync();
    public static void zipDeploy(ZipDeployParams _arg1);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Azure.WebJobs : object {
    internal static string jobTypePath(WebJobType webJobType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void zipWebJob(a webSite, WebJob webJob);
    public static void packageWebJobs(FSharpList`1<WebSite> webSites);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void deployWebJobToWebSite(WebSite webSite, WebJob webJob);
    internal static void deployWebJobsToWebSite(WebSite webSite);
    public static void deployWebJobs(FSharpList`1<WebSite> webSites);
}
[ObsoleteAttribute("Please use one of the Fake 5 Fake.Azure.* modules")]
[CompilationMappingAttribute("7")]
public static class Fake.AzureHelper : object {
    [CompilationMappingAttribute("9")]
internal static AzureEmulatorParams AzureEmulatorDefaults { get; }
    internal static AzureEmulatorParams get_AzureEmulatorDefaults();
    internal static FSharpChoice`4<Unit, Unit, Unit, Unit> |StorageAlreadyStarted|StorageAlreadyStopped|Ok|OtherError|(int _arg1);
    [ObsoleteAttribute("Please use one of the Fake 5 Fake.Azure.* modules")]
public static void StopStorageEmulator(a _arg1);
    [ObsoleteAttribute("Please use one of the Fake 5 Fake.Azure.* modules")]
public static void StartStorageEmulator(a _arg1);
    [ObsoleteAttribute("Please use one of the Fake 5 Fake.Azure.* modules")]
public static void StopComputeEmulator(a _arg1);
    [ObsoleteAttribute("Please use one of the Fake 5 Fake.Azure.* modules")]
public static void StartComputeEmulator(a _arg1);
    [ObsoleteAttribute("Please use one of the Fake 5 Fake.Azure.* modules")]
public static void ResetDevStorage(a _arg1);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.BitbucketPipelines : object {
}
[ObsoleteAttribute("Fake.Boot is no longer supported")]
[CompilationMappingAttribute("7")]
public static class Fake.Boot : object {
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@47-70(IEqualityComparer comp, Config this, Unit unitVar);
    [ObsoleteAttribute("Fake.Boot is no longer supported")]
public static CommandHandler HandlerForArgs(FSharpList`1<string> args);
    [ObsoleteAttribute("Fake.Boot is no longer supported")]
public static FSharpOption`1<CommandHandler> ParseCommandLine(IEnumerable`1<string> args);
    [ObsoleteAttribute("Fake.Boot is no longer supported")]
public static void Prepare(Config config);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.BowerHelper : object {
    [CompilationMappingAttribute("9")]
internal static string bowerFileName { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static BowerParams defaultBowerParams { get; }
    internal static string get_bowerFileName();
    public static BowerParams get_defaultBowerParams();
    internal static string parseInstallArgs(InstallArgs _arg1);
    internal static string parse(BowerCommand _arg1);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void run(BowerParams bowerParams);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void Bower(FSharpFunc`2<BowerParams, BowerParams> setParams);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.BuildServer.AppVeyor : object {
    [CompilationMappingAttribute("9")]
internal static UpdateBuildParams defaultUpdateBuildParams { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>>> appendArgIfNotNullOrEmpty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> environVar { get; }
    [CompilationMappingAttribute("9")]
public static ITraceListener defaultTraceListener { get; }
    [CompilationMappingAttribute("9")]
public static BuildServerInstaller Installer { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-194(UpdateBuildParams this, UpdateBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-195(IComparer comp, UpdateBuildParams this, UpdateBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@50-34(IEqualityComparer comp, UpdateBuildParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@50-78(UpdateBuildParams this, object obj, IEqualityComparer comp, Unit unitVar);
    internal static UpdateBuildParams get_defaultUpdateBuildParams();
    internal static FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>>> get_appendArgIfNotNullOrEmpty();
    public static void updateBuild(FSharpFunc`2<UpdateBuildParams, UpdateBuildParams> setParams);
    internal static void updateBuildVersion(string version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setVariable(string name, string value);
    internal static FSharpFunc`2<string, string> get_environVar();
    public static ITraceListener get_defaultTraceListener();
    public static bool detect();
    public static void install(bool force);
    public static BuildServerInstaller get_Installer();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.BuildServer.AppVeyorImportExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string DotNetCoverageTool.get_AppVeyorName(DotNetCoverageTool );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string ImportData.get_AppVeyorName(ImportData );
}
[CompilationMappingAttribute("7")]
internal static class Fake.BuildServer.AppVeyorInternal : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> environVar { get; }
    [CompilationMappingAttribute("9")]
internal static PushArtifactParams defaultPushArtifactParams { get; }
    internal static FSharpFunc`2<string, string> get_environVar();
    internal static string getJobId();
    internal static void sendToAppVeyor(string args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddMessage(MessageCategory category, string details, string msg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void StartTestCase(string testSuiteName, string testCaseName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UpdateTest(string testSuiteName, string testCaseName, string outcome);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UpdateTestEx(string testSuiteName, string testCaseName, string outcome, string message, string stackTrace, string stdOut, string stdErr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TestFailed(string testSuiteName, string testCaseName, string message, string details);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IgnoreTestCase(string testSuiteName, string testCaseName, a message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TestSucceeded(string testSuiteName, string testCaseName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void FinishTestCase(string testSuiteName, string testCaseName, TimeSpan duration);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UploadTestResultsFile(TestResultsType testResultsType, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UploadTestResultsXml(TestResultsType testResultsType, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetVariable(string name, string value);
    internal static PushArtifactParams get_defaultPushArtifactParams();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StringBuilder appendArgIfNotNullOrEmpty(string value, string name, StringBuilder builder);
    internal static void PushArtifact(FSharpFunc`2<PushArtifactParams, PushArtifactParams> setParams);
    internal static void PushArtifacts(IEnumerable`1<string> paths);
}
[CompilationMappingAttribute("7")]
internal static class Fake.BuildServer.JavaPropertiesFile : object {
    internal static IEnumerable`1<PropertiesFileEntry> parseTextReader(TextReader reader);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.BuildServer.TeamCity : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> sendTeamCityDotCoverHome { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> sendTeamCityNCover3Home { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> sendTeamCityNCover3ReporterArgs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> sendTeamCityNCoverExplorerTool { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> sendTeamCityNCoverExplorerToolArgs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<int, Unit> sendTeamCityNCoverReportType { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> func2@1-7 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<int, Unit> sendTeamCityNCoverReportOrder { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> func2@1-8 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, Unit> sendTeamCityPartCoverReportXslts { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, string> func1@1-21 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, IEnumerable`1<string>> func1@1-22 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<string>, string> func2@1-9 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> func2@1-10 { get; }
    [CompilationMappingAttribute("9")]
public static ITraceListener defaultTraceListener { get; }
    [CompilationMappingAttribute("9")]
public static BuildServerInstaller Installer { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IDisposable block(string name, string description);
    public static void sendTeamCityError(string error);
    public static void reportBuildProblem(string message);
    internal static FSharpFunc`2<string, Unit> get_sendTeamCityDotCoverHome();
    internal static FSharpFunc`2<string, Unit> get_sendTeamCityNCover3Home();
    internal static FSharpFunc`2<string, Unit> get_sendTeamCityNCover3ReporterArgs();
    internal static FSharpFunc`2<string, Unit> get_sendTeamCityNCoverExplorerTool();
    internal static FSharpFunc`2<string, Unit> get_sendTeamCityNCoverExplorerToolArgs();
    internal static FSharpFunc`2<int, Unit> get_sendTeamCityNCoverReportType();
    [CompilerGeneratedAttribute]
internal static string func1@1-19(int value);
    internal static FSharpFunc`2<string, Unit> get_func2@1-7();
    internal static FSharpFunc`2<int, Unit> get_sendTeamCityNCoverReportOrder();
    [CompilerGeneratedAttribute]
internal static string func1@1-20(int value);
    internal static FSharpFunc`2<string, Unit> get_func2@1-8();
    internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, Unit> get_sendTeamCityPartCoverReportXslts();
    internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, string> get_func1@1-21();
    internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, IEnumerable`1<string>> get_func1@1-22();
    internal static FSharpFunc`2<IEnumerable`1<string>, string> get_func2@1-9();
    internal static FSharpFunc`2<string, Unit> get_func2@1-10();
    internal static void startTestCase(string testCaseName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void finishTestCase(string testCaseName, TimeSpan duration);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ignoreTestCase(string name, string message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void reportTestOutput(string name, string output);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void reportTestError(string name, string output);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ignoreTestCaseWithDetails(string name, string message, string details);
    internal static void finishTestSuite(string testSuiteName);
    internal static void startTestSuite(string testSuiteName);
    public static void reportProgress(string message);
    public static void reportProgressStart(string message);
    public static void reportProgressFinish(string message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void reportBuildStatus(string status, string message);
    internal static void publishArtifact(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void publishNamedArtifact(string name, string path);
    internal static void setBuildNumber(string buildNumber);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setBuildStatistic(string key, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setParameter(string name, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void testFailed(string name, string message, string details);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void comparisonFailure(string name, string message, string details, string expected, string actual);
    internal static void warning(string message);
    internal static void error(string message);
    public static ITraceListener get_defaultTraceListener();
    public static bool detect();
    public static void install(bool force);
    public static BuildServerInstaller get_Installer();
}
[CompilationMappingAttribute("7")]
internal static class Fake.BuildServer.TeamCityBuildParameters : object {
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> systemFile { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpMap`2<string, string>> system { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpOption`1<string>> configurationFile { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpMap`2<string, string>> configuration { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpOption`1<string>> runnerFile { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpMap`2<string, string>> runner { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpMap`2<string, string>> all { get; }
    internal static FSharpMap`2<string, string> get(FSharpOption`1<string> fileName);
    internal static FSharpOption`1<string> get_systemFile();
    internal static Lazy`1<FSharpMap`2<string, string>> get_system();
    internal static FSharpMap`2<string, string> getAllSystem();
    internal static Lazy`1<FSharpOption`1<string>> get_configurationFile();
    internal static Lazy`1<FSharpMap`2<string, string>> get_configuration();
    internal static FSharpMap`2<string, string> getAllConfiguration();
    internal static Lazy`1<FSharpOption`1<string>> get_runnerFile();
    internal static Lazy`1<FSharpMap`2<string, string>> get_runner();
    internal static FSharpMap`2<string, string> getAllRunner();
    internal static Lazy`1<FSharpMap`2<string, string>> get_all();
    internal static FSharpMap`2<string, string> getAll();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.BuildServer.TeamCityImportExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string DotNetCoverageTool.get_TeamCityName(DotNetCoverageTool );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string ImportData.get_TeamCityName(ImportData );
}
[CompilationMappingAttribute("7")]
internal static class Fake.BuildServer.TeamCityRest : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string prepareURL(string restURL, string serverURL);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getRESTVersion(string serverURL, string username, string password);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@362-36(IEqualityComparer comp, BuildConfiguration this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@372-37(IEqualityComparer comp, Project this, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XmlElement getFirstNode(string serverURL, string username, string password, string url);
    internal static bool parseBooleanOrFalse(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static BuildConfiguration getBuildConfig(string serverURL, string username, string password, string id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Project getProject(string serverURL, string username, string password, string id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<string> getProjects(string serverURL, string username, string password);
}
[CompilationMappingAttribute("7")]
internal static class Fake.BuildServer.TeamCityWriter : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> singleLine { get; }
    internal static string encapsulateSpecialChars(string text);
    internal static FSharpFunc`2<string, string> get_singleLine();
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@22-35(IEqualityComparer comp, TeamCityMessage this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@22-79(TeamCityMessage this, TeamCityMessage that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@22-80(TeamCityMessage this, TeamCityMessage obj, Unit unitVar);
    internal static void sendToTeamCity(TeamCityMessage message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendOpenBlock(string name, string description);
    internal static void sendCloseBlock(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendBuildStatus(string status, string text);
    internal static void sendBuildProblem(string description);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendImportData(string typ, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendImportDataWithTool(string typ, string tool, string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendDotNetCoverage(string typ, string value);
    internal static void sendTestStarted(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendTestFinished(string name, string duration);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendTestIgnored(string name, string message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendTestStdOut(string name, string out);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendTestStdError(string name, string out);
    internal static void sendTestSuiteFinished(string name);
    internal static void sendTestSuiteStarted(string name);
    internal static void sendProgressMessage(string message);
    internal static void sendProgressStart(string message);
    internal static void sendProgressFinish(string message);
    internal static void sendPublishArtifact(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendPublishNamedArtifact(string name, string path);
    internal static void sendBuildNumber(string buildNumber);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendBuildStatistic(string key, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendSetParameter(string name, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendTestFailed(string name, string message, string details);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendComparisonFailed(string name, string message, string details, string expected, string actual);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sendMessage(string status, string text);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.BuildServer.TeamFoundation : object {
    [CompilationMappingAttribute("9")]
public static Vault variables { get; }
    [CompilationMappingAttribute("9")]
public static ITraceListener defaultTraceListener { get; }
    [CompilationMappingAttribute("9")]
public static BuildServerInstaller Installer { get; }
    internal static string ensurePropName@51(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void write(string action, IEnumerable`1<Tuple`2<string, string>> properties, string message);
    internal static string seqToPropValue(IEnumerable`1<string> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setVariable(string variableName, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<a, b>> toType(a t, FSharpOption`1<b> o);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<a, b>> toList(a t, FSharpOption`1<b> o);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void logIssue(bool isWarning, FSharpOption`1<string> sourcePath, FSharpOption`1<string> lineNumber, FSharpOption`1<string> columnNumber, FSharpOption`1<string> code, string message);
    internal static void uploadFile(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void publishArtifact(string artifactFolder, FSharpOption`1<string> artifactName, string path);
    internal static void setBuildNumber(string number);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setBuildState(string state, string message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void publishTests(string runnerType, IEnumerable`1<string> resultsFiles, bool mergeResults, string platform, string config, string runTitle, bool publishRunAttachments);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void logDetailRaw(Guid id, FSharpOption`1<Guid> parentId, FSharpOption`1<string> typ, FSharpOption`1<string> name, FSharpOption`1<int> order, FSharpOption`1<DateTime> startTime, FSharpOption`1<DateTime> finishTime, FSharpOption`1<int> progress, FSharpOption`1<LogDetailState> state, FSharpOption`1<LogDetailResult> result, string message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createLogDetail(Guid id, FSharpOption`1<Guid> parentId, string typ, string name, int order, string message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setLogDetailProgress(Guid id, int progress);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void setLogDetailFinished(Guid id, LogDetailResult result);
    public static Vault get_variables();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void publishArtifactIfOk(string artifactFolder, FSharpOption`1<string> artifactName, string path);
    public static ITraceListener get_defaultTraceListener();
    public static bool detect();
    public static void install(bool force);
    public static BuildServerInstaller get_Installer();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.BuildServer.Travis : object {
    [CompilationMappingAttribute("9")]
public static ITraceListener defaultTraceListener { get; }
    [CompilationMappingAttribute("9")]
public static BuildServerInstaller Installer { get; }
    public static ITraceListener get_defaultTraceListener();
    public static bool detect();
    public static void install(bool force);
    public static BuildServerInstaller get_Installer();
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("7")]
public static class Fake.BuildServerHelper : object {
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool verbose { get; public set; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static string localBuildLabel { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string xmlOutputFile { get; public set; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string bambooBuildNumber { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool isBambooBuild { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool isTFBuild { get; }
    [CompilationMappingAttribute("9")]
internal static string tfbuild@56-1 { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string tfBuildNumber { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string tcBuildNumber { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string travisBuildNumber { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool isGitlabCI { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string gitlabCIBuildNumber { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string jenkinsBuildNumber { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string ccBuildLabel { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string appVeyorBuildVersion { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static BuildServer buildServer { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string buildVersion { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool isLocalBuild { get; }
    public static bool get_verbose();
    public static void set_verbose(bool value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_localBuildLabel();
    public static string get_xmlOutputFile();
    public static void set_xmlOutputFile(string value);
    public static string get_bambooBuildNumber();
    public static bool get_isBambooBuild();
    public static bool get_isTFBuild();
    internal static string get_tfbuild@56-1();
    public static string get_tfBuildNumber();
    public static string get_tcBuildNumber();
    public static string get_travisBuildNumber();
    public static bool get_isGitlabCI();
    public static string get_gitlabCIBuildNumber();
    public static string get_jenkinsBuildNumber();
    public static string get_ccBuildLabel();
    public static string get_appVeyorBuildVersion();
    public static BuildServer get_buildServer();
    public static string get_buildVersion();
    internal static string getVersion@116-8(string defaultParam);
    public static bool get_isLocalBuild();
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.CacheHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b lookup(a key, FSharpFunc`2<Unit, b> newValueF, IDictionary`2<a, b> cache);
}
[ObsoleteAttribute("Open Fake.Core instead (FAKE0001 - package: Fake.Core.ReleaseNotes, module: Changelog)")]
[CompilationMappingAttribute("7")]
public static class Fake.ChangeLogHelper : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> trimLine { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> func1@1-32 { get; }
    [CompilationMappingAttribute("9")]
internal static Char[] chars@220-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> func2@1-21 { get; }
    [CompilationMappingAttribute("9")]
internal static Char[] chars@226-3 { get; }
    [ObsoleteAttribute("Open Fake.Core instead (FAKE0001 - package: Fake.Core.ReleaseNotes, module: Changelog, function: parseVersions)")]
[CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Tuple`2<Match, Match>> parseVersions { get; }
    [CompilationMappingAttribute("9")]
internal static Regex nugetRegex@181-2 { get; }
    internal static FSharpFunc`2<string, string> get_trimLine();
    internal static FSharpFunc`2<string, string> get_func1@1-32();
    internal static Char[] get_chars@220-2();
    internal static FSharpFunc`2<string, string> get_func2@1-21();
    internal static Char[] get_chars@226-3();
    internal static FSharpList`1<string> trimLines(IEnumerable`1<string> lines);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@37-511(Change this, Change obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@37-512(Change this, Change objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@37-109(Change this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@37-209(Change this, Change that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@37-210(Change this, Change obj, Unit unitVar);
    internal static Tuple`2<string, string> makeEntry(Change change);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@91-513(ChangeLogEntry this, ChangeLogEntry obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@91-514(IComparer comp, ChangeLogEntry this, ChangeLogEntry objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@91-110(IEqualityComparer comp, ChangeLogEntry this, Unit unitVar);
    internal static FSharpFunc`2<string, Tuple`2<Match, Match>> get_parseVersions();
    internal static Regex get_nugetRegex@181-2();
    [CompilerGeneratedAttribute]
internal static bool func1@1-33(string value);
    internal static FSharpFunc`2<FSharpList`1<string>, Tuple`2<FSharpList`1<string>, FSharpList`1<string>>> findFirstHeader@279-2(FSharpList`1<string> accumulator);
    [CompilerGeneratedAttribute]
internal static bool func1@1-34(string value);
    [CompilerGeneratedAttribute]
internal static bool func1@1-35(string value);
    internal static bool isUnreleasedHeader@293(string line);
    internal static bool isBlockHeader@294(string line);
    internal static bool isAnyHeader@296(string line);
    internal static Tuple`2<FSharpList`1<a>, FSharpList`1<a>> findEnd@298-4(FSharpFunc`2<a, bool> headerPredicate, FSharpList`1<a> accumulator, FSharpList`1<a> lines);
    internal static FSharpFunc`2<FSharpList`1<string>, Tuple`2<FSharpList`1<string>, FSharpList`1<string>>> findBlockEnd@304-3(FSharpFunc`2<string, bool> isBlockHeader, FSharpList`1<string> accumulator);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<string>, FSharpList`1<string>>> findUnreleasedBlock@306-1(FSharpFunc`2<string, bool> isBlockHeader, FSharpList`1<string> text);
    internal static FSharpOption`1<Tuple`2<string, Tuple`2<FSharpList`1<string>, FSharpList`1<string>>>> findNextChangesBlock@312-1(FSharpFunc`2<string, bool> isBlockHeader, FSharpList`1<string> text);
    internal static Tuple`2<FSharpList`1<string>, FSharpList`1<string>> findCategoryEnd@319-2(FSharpList`1<string> changes, FSharpList`1<string> text);
    internal static FSharpOption`1<Tuple`2<string, Tuple`2<FSharpList`1<string>, FSharpList`1<string>>>> findNextCategoryBlock@318-1(FSharpList`1<string> text);
    internal static FSharpList`1<Change> categoryLoop@330-2(FSharpList`1<Change> changes, FSharpList`1<string> text);
    internal static FSharpList`1<ChangeLogEntry> loop@336-30(FSharpFunc`2<string, FSharpOption`1<DateTime>> parseDate, FSharpFunc`2<string, bool> isBlockHeader, FSharpList`1<ChangeLogEntry> changeLogEntries, FSharpList`1<string> text);
    [ObsoleteAttribute("Open Fake.Core instead (FAKE0001 - package: Fake.Core.ReleaseNotes, module: Changelog, function: parse)")]
public static ChangeLog parseChangeLog(IEnumerable`1<string> data);
    [ObsoleteAttribute("Open Fake.Core instead (FAKE0001 - package: Fake.Core.ReleaseNotes, module: Changelog, function: load)")]
public static ChangeLog LoadChangeLog(string fileName);
    [ObsoleteAttribute("Open Fake.Core instead (FAKE0001 - package: Fake.Core.ReleaseNotes, module: Changelog, function: save)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SaveChangeLog(string fileName, ChangeLog changeLog);
    [ObsoleteAttribute("Open Fake.Core instead (FAKE0001 - package: Fake.Core.ReleaseNotes, module: Changelog, function: promoteUnreleased)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ChangeLog PromoteUnreleased(string version, ChangeLog changeLog);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Open Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem, module: ChangeWatcher)")]
[CompilationMappingAttribute("7")]
public static class Fake.ChangeWatcher : object {
    [ObsoleteAttribute("Open Fake.IO and use ChangeWatcher.run instead (FAKE0001 - package: Fake.IO.FileSystem, module Fake.IO.ChangeWatcher, function: run)")]
[CompilationMappingAttribute("9")]
public static FSharpFunc`2<FSharpFunc`2<IEnumerable`1<FileChange>, Unit>, FSharpFunc`2<FileIncludes, IDisposable>> WatchChanges { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void handleWatcherEvents(FileStatus status, FSharpFunc`2<FileChange, Unit> onChange, FileSystemEventArgs e);
    internal static FSharpList`1<string> calcDirsToWatch(FileIncludes fileIncludes);
    [CompilerGeneratedAttribute]
internal static void action@1-15(FSharpFunc`2<IEnumerable`1<FileChange>, Unit> onChange, FSharpRef`1<FSharpList`1<FileChange>> unNotifiedChanges, FSharpRef`1<bool> runningHandlers, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void action@1-16(FSharpRef`1<FSharpList`1<FileChange>> unNotifiedChanges, Timer timer, FileChange fileChange, Unit unitVar0);
    internal static void acumChanges@91-1(FileIncludes fileIncludes, FSharpRef`1<FSharpList`1<FileChange>> unNotifiedChanges, FSharpRef`1<bool> runningHandlers, Timer timer, FileChange fileChange);
    [ObsoleteAttribute("Open Fake.IO and use ChangeWatcher.runWithOptions instead (FAKE0001 - package: Fake.IO.FileSystem, module Fake.IO.ChangeWatcher, function: runWithOptions)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IDisposable WatchChangesWithOptions(WatchChangesOption options, FSharpFunc`2<IEnumerable`1<FileChange>, Unit> onChange, FileIncludes fileIncludes);
    public static FSharpFunc`2<FSharpFunc`2<IEnumerable`1<FileChange>, Unit>, FSharpFunc`2<FileIncludes, IDisposable>> get_WatchChanges();
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("3")]
public class Fake.Checksum : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string CalculateFileHash(string filePath, FSharpOption`1<ChecksumHashAlgorithm> hashAlgorithm);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static bool CheckFileHash(string filepath, string hash, FSharpOption`1<ChecksumHashAlgorithm> hashAlgorithm);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.ChecksumHashAlgorithm : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ChecksumHashAlgorithm _unique_MD5;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ChecksumHashAlgorithm _unique_SHA1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ChecksumHashAlgorithm _unique_SHA256;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ChecksumHashAlgorithm _unique_SHA384;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ChecksumHashAlgorithm _unique_SHA512;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ChecksumHashAlgorithm MD5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMD5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ChecksumHashAlgorithm SHA1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSHA1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ChecksumHashAlgorithm SHA256 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSHA256 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ChecksumHashAlgorithm SHA384 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSHA384 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ChecksumHashAlgorithm SHA512 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSHA512 { get; }
    private static ChecksumHashAlgorithm();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ChecksumHashAlgorithm(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static ChecksumHashAlgorithm get_MD5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMD5();
    [CompilationMappingAttribute("8", "1")]
public static ChecksumHashAlgorithm get_SHA1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSHA1();
    [CompilationMappingAttribute("8", "2")]
public static ChecksumHashAlgorithm get_SHA256();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSHA256();
    [CompilationMappingAttribute("8", "3")]
public static ChecksumHashAlgorithm get_SHA384();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSHA384();
    [CompilationMappingAttribute("8", "4")]
public static ChecksumHashAlgorithm get_SHA512();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSHA512();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ChecksumHashAlgorithm obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ChecksumHashAlgorithm obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Choco : object {
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationMappingAttribute("9")]
public static ChocoInstallParams ChocoInstallDefaults { get; }
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationMappingAttribute("9")]
public static ChocoPackParams ChocoPackDefaults { get; }
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationMappingAttribute("9")]
public static ChocoPushParams ChocoPushDefaults { get; }
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationMappingAttribute("9")]
internal static FSharpList`1<IEnumerable`1<string>> getPaths { get; }
    [CompilationMappingAttribute("9")]
internal static string programDataPath@332-1 { get; }
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationMappingAttribute("9")]
public static FSharpOption`1<string> FindExe { get; }
    [CompilationMappingAttribute("9")]
internal static string getTempFolder { get; }
    [CompilationMappingAttribute("9")]
internal static DirectoryInfo tempFolder@377-1 { get; }
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationMappingAttribute("9")]
public static bool IsAvailable { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-487(ChocoInstallParams this, ChocoInstallParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-486(ChocoInstallParams this, ChocoInstallParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-485(ChocoInstallParams this, ChocoInstallParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-490(IComparer comp, ChocoInstallParams this, ChocoInstallParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-489(IComparer comp, ChocoInstallParams this, ChocoInstallParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-488(IComparer comp, ChocoInstallParams this, ChocoInstallParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@30-102(IEqualityComparer comp, ChocoInstallParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@30-198(ChocoInstallParams this, ChocoInstallParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@30-199(ChocoInstallParams this, ChocoInstallParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@207-491(ChocoPushParams this, ChocoPushParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@207-492(IComparer comp, ChocoPushParams this, ChocoPushParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@207-103(IEqualityComparer comp, ChocoPushParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-497(NuspecData this, NuspecData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-496(NuspecData this, NuspecData obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-495(NuspecData this, NuspecData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-494(NuspecData this, NuspecData obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-493(NuspecData this, NuspecData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-502(NuspecData this, NuspecData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-501(NuspecData this, NuspecData objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-500(NuspecData this, NuspecData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-499(NuspecData this, NuspecData objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@227-498(NuspecData this, NuspecData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@227-104(NuspecData this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@227-201(NuspecData this, NuspecData that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@227-200(NuspecData this, NuspecData that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@227-203(NuspecData this, NuspecData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@227-202(NuspecData this, NuspecData obj, Unit unitVar);
    public static ChocoInstallParams get_ChocoInstallDefaults();
    public static ChocoPackParams get_ChocoPackDefaults();
    public static ChocoPushParams get_ChocoPushDefaults();
    internal static FSharpList`1<IEnumerable`1<string>> get_getPaths();
    internal static string get_programDataPath@332-1();
    public static FSharpOption`1<string> get_FindExe();
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void callChoco(string exePath, string args, TimeSpan timeout);
    internal static string get_getTempFolder();
    internal static DirectoryInfo get_tempFolder@377-1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StringBuilder appendLine(string line, StringBuilder builder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StringBuilder appendFormattedLine(PrintfFormat`4<FSharpFunc`2<a, string>, Unit, string, string> format, a value, StringBuilder builder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StringBuilder appendFormattedLineIfNotNull(PrintfFormat`4<FSharpFunc`2<a, string>, Unit, string, string> format, a value, StringBuilder builder);
    internal static string getFrameworkGroup@402-12(IEnumerable`1<Tuple`2<string, string>> frameworkTags);
    internal static string getGroup@409-3(FSharpList`1<a> items, FSharpFunc`2<FSharpList`1<a>, string> toTags);
    internal static string getReferencesTags@413-6(IEnumerable`1<string> references);
    internal static string getFrameworkAssemblyTags@427-12(IEnumerable`1<NugetFrameworkAssemblyReferences> references);
    internal static string getDependenciesTags@438-12(IEnumerable`1<Tuple`2<string, string>> dependencies);
    internal static string xmlEncode@466-5(string notEncodedText);
    internal static string toSingleLine@470-3(string text);
    internal static NuspecData getNuspecData(ChocoPackParams parameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string createNuSpecFromTemplate(ChocoPackParams parameters, FileInfo templateNuSpec, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string createNuSpec(ChocoPackParams parameters, string outputDir);
    internal static string installerTypeToString(a x);
    internal static string checksumTypeToString(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createChocolateyInstallPs1(ChocoPackParams parameters, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createChocolateyInstallPs1FromTemplate(ChocoPackParams parameters, string templatePath, string outputDir);
    [CompilerGeneratedAttribute]
internal static void createChocolateyUninstallPs1$cont@651-1(ChocoPackParams parameters, string outputDir, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createChocolateyUninstallPs1(ChocoPackParams parameters, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createChocolateyUninstallPs1FromTemplate(ChocoPackParams parameters, string templatePath, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void callChocoPack(string nuspecFile, ChocoPackParams parameters);
    public static bool get_IsAvailable();
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Install(FSharpFunc`2<ChocoInstallParams, ChocoInstallParams> setParams, string packages);
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
public static void Pack(FSharpFunc`2<ChocoPackParams, ChocoPackParams> setParams);
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void PackFromTemplate(FSharpFunc`2<ChocoPackParams, ChocoPackParams> setParams, string nuspecPath);
    [ObsoleteAttribute("Use Fake.Windows.Choco instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Push(FSharpFunc`2<ChocoPushParams, ChocoPushParams> setParams, string nupkgPath);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.CMakeSupport.CMake : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static CMakeGenerateParams CMakeGenerateDefaults { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static CMakeBuildParams CMakeBuildDefaults { get; }
    public static CMakeGenerateParams get_CMakeGenerateDefaults();
    public static CMakeBuildParams get_CMakeBuildDefaults();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpOption`1<string> FindExe(string exeName);
    internal static string FormatCMakePath(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallCMake(string toolPath, string binaryDir, string args, TimeSpan timeout);
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<a>> argsIfNotEmpty@191(PrintfFormat`4<FSharpFunc`2<string, a>, Unit, string, string> format);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void Generate(FSharpFunc`2<CMakeGenerateParams, CMakeGenerateParams> setParams);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void Build(FSharpFunc`2<CMakeBuildParams, CMakeBuildParams> setParams);
}
[CLIMutableAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("2")]
public class Fake.CMakeSupport.CMakeBuildParams : object {
    [DebuggerBrowsableAttribute("0")]
internal string ToolPath@;
    [DebuggerBrowsableAttribute("0")]
internal string BinaryDirectory@;
    [DebuggerBrowsableAttribute("0")]
internal string Target@;
    [DebuggerBrowsableAttribute("0")]
internal string Config@;
    [DebuggerBrowsableAttribute("0")]
internal TimeSpan Timeout@;
    [DebuggerBrowsableAttribute("0")]
internal string AdditionalArgs@;
    [CompilationMappingAttribute("4", "0")]
public string ToolPath { get; public set; }
    [CompilationMappingAttribute("4", "1")]
public string BinaryDirectory { get; public set; }
    [CompilationMappingAttribute("4", "2")]
public string Target { get; public set; }
    [CompilationMappingAttribute("4", "3")]
public string Config { get; public set; }
    [CompilationMappingAttribute("4", "4")]
public TimeSpan Timeout { get; public set; }
    [CompilationMappingAttribute("4", "5")]
public string AdditionalArgs { get; public set; }
    public CMakeBuildParams(string toolPath, string binaryDirectory, string target, string config, TimeSpan timeout, string additionalArgs);
    public string get_ToolPath();
    public string get_BinaryDirectory();
    public string get_Target();
    public string get_Config();
    public TimeSpan get_Timeout();
    public string get_AdditionalArgs();
    public void set_ToolPath(string value);
    public void set_BinaryDirectory(string value);
    public void set_Target(string value);
    public void set_Config(string value);
    public void set_Timeout(TimeSpan value);
    public void set_AdditionalArgs(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CMakeBuildParams obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CMakeBuildParams obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CLIMutableAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("2")]
public class Fake.CMakeSupport.CMakeGenerateParams : object {
    [DebuggerBrowsableAttribute("0")]
internal string ToolPath@;
    [DebuggerBrowsableAttribute("0")]
internal string SourceDirectory@;
    [DebuggerBrowsableAttribute("0")]
internal string BinaryDirectory@;
    [DebuggerBrowsableAttribute("0")]
internal string Toolchain@;
    [DebuggerBrowsableAttribute("0")]
internal string Generator@;
    [DebuggerBrowsableAttribute("0")]
internal string Toolset@;
    [DebuggerBrowsableAttribute("0")]
internal string Platform@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Caches@;
    [DebuggerBrowsableAttribute("0")]
internal string InstallDirectory@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<CMakeVariable> Variables@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> CacheEntriesToRemove@;
    [DebuggerBrowsableAttribute("0")]
internal TimeSpan Timeout@;
    [DebuggerBrowsableAttribute("0")]
internal string AdditionalArgs@;
    [CompilationMappingAttribute("4", "0")]
public string ToolPath { get; public set; }
    [CompilationMappingAttribute("4", "1")]
public string SourceDirectory { get; public set; }
    [CompilationMappingAttribute("4", "2")]
public string BinaryDirectory { get; public set; }
    [CompilationMappingAttribute("4", "3")]
public string Toolchain { get; public set; }
    [CompilationMappingAttribute("4", "4")]
public string Generator { get; public set; }
    [CompilationMappingAttribute("4", "5")]
public string Toolset { get; public set; }
    [CompilationMappingAttribute("4", "6")]
public string Platform { get; public set; }
    [CompilationMappingAttribute("4", "7")]
public FSharpList`1<string> Caches { get; public set; }
    [CompilationMappingAttribute("4", "8")]
public string InstallDirectory { get; public set; }
    [CompilationMappingAttribute("4", "9")]
public FSharpList`1<CMakeVariable> Variables { get; public set; }
    [CompilationMappingAttribute("4", "10")]
public FSharpList`1<string> CacheEntriesToRemove { get; public set; }
    [CompilationMappingAttribute("4", "11")]
public TimeSpan Timeout { get; public set; }
    [CompilationMappingAttribute("4", "12")]
public string AdditionalArgs { get; public set; }
    public CMakeGenerateParams(string toolPath, string sourceDirectory, string binaryDirectory, string toolchain, string generator, string toolset, string platform, FSharpList`1<string> caches, string installDirectory, FSharpList`1<CMakeVariable> variables, FSharpList`1<string> cacheEntriesToRemove, TimeSpan timeout, string additionalArgs);
    public string get_ToolPath();
    public string get_SourceDirectory();
    public string get_BinaryDirectory();
    public string get_Toolchain();
    public string get_Generator();
    public string get_Toolset();
    public string get_Platform();
    public FSharpList`1<string> get_Caches();
    public string get_InstallDirectory();
    public FSharpList`1<CMakeVariable> get_Variables();
    public FSharpList`1<string> get_CacheEntriesToRemove();
    public TimeSpan get_Timeout();
    public string get_AdditionalArgs();
    public void set_ToolPath(string value);
    public void set_SourceDirectory(string value);
    public void set_BinaryDirectory(string value);
    public void set_Toolchain(string value);
    public void set_Generator(string value);
    public void set_Toolset(string value);
    public void set_Platform(string value);
    public void set_Caches(FSharpList`1<string> value);
    public void set_InstallDirectory(string value);
    public void set_Variables(FSharpList`1<CMakeVariable> value);
    public void set_CacheEntriesToRemove(FSharpList`1<string> value);
    public void set_Timeout(TimeSpan value);
    public void set_AdditionalArgs(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CMakeGenerateParams obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CMakeGenerateParams obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Fake.CMakeSupport.CMakeValue : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCMakeBoolean { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCMakeString { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCMakeFilePath { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCMakeDirPath { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CMakeValue(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static CMakeValue NewCMakeBoolean(bool item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCMakeBoolean();
    [CompilationMappingAttribute("8", "1")]
public static CMakeValue NewCMakeString(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCMakeString();
    [CompilationMappingAttribute("8", "2")]
public static CMakeValue NewCMakeFilePath(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCMakeFilePath();
    [CompilationMappingAttribute("8", "3")]
public static CMakeValue NewCMakeDirPath(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCMakeDirPath();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CMakeValue obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CMakeValue obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("2")]
public class Fake.CMakeSupport.CMakeVariable : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal CMakeValue Value@;
    [CompilationMappingAttribute("4", "0")]
public string Name { get; }
    [CompilationMappingAttribute("4", "1")]
public CMakeValue Value { get; }
    public CMakeVariable(string name, CMakeValue value);
    public string get_Name();
    public CMakeValue get_Value();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CMakeVariable obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CMakeVariable obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.ConfigurationHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static XmlDocument readConfig(string fileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeConfig(string fileName, XmlDocument config);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument updateConfig(string xpath, string attribute, string value, XmlDocument config);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void updateConfigSetting(string fileName, string xpath, string attribute, string value);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void updateAppSetting(string key, string value, string fileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void updateApplicationSetting(string fileName, string settingName, string value);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void updateConnectionString(string connectionStringKey, string value, string fileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void applyXslOnConfig(string xsl, string fileName);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.Args : object {
    public static string toWindowsCommandLine(IEnumerable`1<string> args);
    public static string toLinuxShellCommandLine(IEnumerable`1<string> args);
    public static String[] fromWindowsCommandLine(string cmd);
}
[CompilationMappingAttribute("34")]
public class Fake.Core.Arguments : object {
    [DebuggerBrowsableAttribute("0")]
internal String[] Args@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Original@;
    [CompilationMappingAttribute("4", "0")]
internal String[] Args { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpOption`1<string> Original { get; }
    public static Arguments Empty { get; }
    public string ToWindowsCommandLine { get; }
    public string ToLinuxShellCommandLine { get; }
    public string ToStartInfo { get; }
    internal Arguments(String[] args, FSharpOption`1<string> original);
    internal String[] get_Args();
    internal FSharpOption`1<string> get_Original();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Arguments obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static Arguments get_Empty();
    public static Arguments OfWindowsCommandLine(string cmd);
    public string get_ToWindowsCommandLine();
    public string get_ToLinuxShellCommandLine();
    public static Arguments OfArgs(IEnumerable`1<string> args);
    public static Arguments OfStartInfo(string cmd);
    public string get_ToStartInfo();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Arguments obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.ArgumentsModule : object {
    public static string toWindowsCommandLine(Arguments a);
    public static string toLinuxShellCommandLine(Arguments a);
    public static string toStartInfo(Arguments a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Arguments withPrefix(IEnumerable`1<string> s, Arguments a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Arguments append(IEnumerable`1<string> s, Arguments a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Arguments appendOption(string paramName, FSharpOption`1<string> paramValue, Arguments a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Arguments appendIf(bool value, string paramName, Arguments a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Arguments appendNotEmpty(string paramName, string paramValue, Arguments a);
    public static FSharpList`1<string> toList(Arguments a);
    public static String[] toArray(Arguments a);
    public static Arguments ofList(FSharpList`1<string> a);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.AsyncProcessResult`1 : object {
    [DebuggerBrowsableAttribute("0")]
internal Task`1<a> Result@;
    [DebuggerBrowsableAttribute("0")]
internal Task`1<RawProcessResult> Raw@;
    [CompilationMappingAttribute("4", "0")]
public Task`1<a> Result { get; }
    [CompilationMappingAttribute("4", "1")]
public Task`1<RawProcessResult> Raw { get; }
    public AsyncProcessResult`1(Task`1<a> result, Task`1<RawProcessResult> raw);
    public Task`1<a> get_Result();
    public Task`1<RawProcessResult> get_Raw();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AsyncProcessResult`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SerializableAttribute]
[CompilationMappingAttribute("3")]
public class Fake.Core.BuildFailedException : Exception {
    internal FSharpOption`1<TargetContext> info@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpOption`1<TargetContext> info { get; }
    public FSharpOption`1<TargetContext> Info { get; }
    public BuildFailedException(string msg, Exception inner);
    public BuildFailedException(TargetContext info, string msg, Exception inner);
    public BuildFailedException(SerializationInfo info, StreamingContext context);
    internal FSharpOption`1<TargetContext> get_info();
    public FSharpOption`1<TargetContext> get_Info();
    public BuildFailedException Wrap();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.Core.BuildServer : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_TeamFoundation;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_TeamCity;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_CCNet;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_Jenkins;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_Travis;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_AppVeyor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_GitLabCI;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_Bamboo;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_BitbucketPipelines;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildServer _unique_LocalBuild;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer TeamFoundation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTeamFoundation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer TeamCity { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTeamCity { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer CCNet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCCNet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer Jenkins { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsJenkins { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer Travis { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTravis { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer AppVeyor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAppVeyor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer GitLabCI { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGitLabCI { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer Bamboo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBamboo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer BitbucketPipelines { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBitbucketPipelines { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildServer LocalBuild { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLocalBuild { get; }
    private static BuildServer();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal BuildServer(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static BuildServer get_TeamFoundation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTeamFoundation();
    [CompilationMappingAttribute("8", "1")]
public static BuildServer get_TeamCity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTeamCity();
    [CompilationMappingAttribute("8", "2")]
public static BuildServer get_CCNet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCCNet();
    [CompilationMappingAttribute("8", "3")]
public static BuildServer get_Jenkins();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsJenkins();
    [CompilationMappingAttribute("8", "4")]
public static BuildServer get_Travis();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTravis();
    [CompilationMappingAttribute("8", "5")]
public static BuildServer get_AppVeyor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAppVeyor();
    [CompilationMappingAttribute("8", "6")]
public static BuildServer get_GitLabCI();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGitLabCI();
    [CompilationMappingAttribute("8", "7")]
public static BuildServer get_Bamboo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBamboo();
    [CompilationMappingAttribute("8", "8")]
public static BuildServer get_BitbucketPipelines();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBitbucketPipelines();
    [CompilationMappingAttribute("8", "9")]
public static BuildServer get_LocalBuild();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLocalBuild();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(BuildServer obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BuildServer obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AbstractClassAttribute]
[CompilationMappingAttribute("3")]
public abstract class Fake.Core.BuildServerInstaller : object {
    public abstract virtual void Install();
    public abstract virtual bool Detect();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.BuildServerModule : object {
    [CompilationMappingAttribute("9")]
public static bool verbose { get; public set; }
    public static string localBuildLabel { get; }
    [CompilationMappingAttribute("9")]
public static string xmlOutputFile { get; public set; }
    [CompilationMappingAttribute("9")]
public static string bambooBuildNumber { get; }
    [CompilationMappingAttribute("9")]
public static bool isBambooBuild { get; }
    [CompilationMappingAttribute("9")]
public static bool isTFBuild { get; }
    [CompilationMappingAttribute("9")]
internal static string tfbuild@55 { get; }
    [CompilationMappingAttribute("9")]
public static string tfBuildNumber { get; }
    [CompilationMappingAttribute("9")]
public static string tcBuildNumber { get; }
    [CompilationMappingAttribute("9")]
public static string travisBuildNumber { get; }
    [CompilationMappingAttribute("9")]
public static bool isGitlabCI { get; }
    [CompilationMappingAttribute("9")]
public static string gitlabCIBuildNumber { get; }
    [CompilationMappingAttribute("9")]
public static string jenkinsBuildNumber { get; }
    [CompilationMappingAttribute("9")]
public static string ccBuildLabel { get; }
    [CompilationMappingAttribute("9")]
public static string appVeyorBuildVersion { get; }
    [CompilationMappingAttribute("9")]
public static BuildServer buildServer { get; }
    [CompilationMappingAttribute("9")]
public static string buildVersion { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> getVersion@113 { get; }
    [CompilationMappingAttribute("9")]
public static bool isLocalBuild { get; }
    [CompilationMappingAttribute("9")]
public static bool ansiColorSupport { get; public set; }
    public static bool get_verbose();
    public static void set_verbose(bool value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_localBuildLabel();
    public static string get_xmlOutputFile();
    public static void set_xmlOutputFile(string value);
    public static string get_bambooBuildNumber();
    public static bool get_isBambooBuild();
    public static bool get_isTFBuild();
    internal static string get_tfbuild@55();
    public static string get_tfBuildNumber();
    public static string get_tcBuildNumber();
    public static string get_travisBuildNumber();
    public static bool get_isGitlabCI();
    public static string get_gitlabCIBuildNumber();
    public static string get_jenkinsBuildNumber();
    public static string get_ccBuildLabel();
    public static string get_appVeyorBuildVersion();
    public static BuildServer get_buildServer();
    public static string get_buildVersion();
    internal static FSharpFunc`2<string, string> get_getVersion@113();
    public static bool get_isLocalBuild();
    public static bool get_ansiColorSupport();
    public static void set_ansiColorSupport(bool value);
    public static void install(FSharpList`1<BuildServerInstaller> servers);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.Changelog : object {
    [CompilationMappingAttribute("9")]
internal static Regex multiNewLineRegex { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> trimEnd { get; }
    [CompilationMappingAttribute("9")]
internal static Char[] chars@108 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> trimLine { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> func1@1-3 { get; }
    [CompilationMappingAttribute("9")]
internal static Char[] chars@103-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, bool> isNotNullOrWhitespace { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> appendNewlines { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> func2@1-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> clo1@44 { get; }
    [CompilationMappingAttribute("9")]
internal static Regex nugetRegex { get; }
    [CompilationMappingAttribute("9")]
internal static Regex assemblyVersionRegex { get; }
    internal static Regex get_multiNewLineRegex();
    internal static FSharpFunc`2<string, string> get_trimEnd();
    internal static Char[] get_chars@108();
    internal static FSharpFunc`2<string, string> get_trimLine();
    internal static FSharpFunc`2<string, string> get_func1@1-3();
    internal static Char[] get_chars@103-1();
    internal static FSharpList`1<string> trimLines(IEnumerable`1<string> lines);
    internal static string joinLines(IEnumerable`1<string> lines);
    internal static string concat(IEnumerable`1<string> strings);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool contains(string search, string line);
    internal static FSharpFunc`2<string, bool> get_isNotNullOrWhitespace();
    [CompilerGeneratedAttribute]
internal static bool func1@1-4(string value);
    internal static string fixMultipleNewlines(string x);
    internal static string betweenNewlines(string x);
    internal static FSharpFunc`2<string, string> get_appendNewlines();
    [CompilerGeneratedAttribute]
internal static string func1@1-5(string x);
    internal static FSharpFunc`2<string, string> get_func2@1-2();
    internal static FSharpFunc`2<string, string> get_clo1@44();
    internal static string bullet@92(ChangeText text);
    internal static Tuple`2<string, string> makeEntry(Change change);
    internal static string makeDescriptionText(FSharpOption`1<string> text);
    internal static string makeChangesText(FSharpList`1<Change> changes);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@120-26(ChangelogEntry this, ChangelogEntry obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@120-27(IComparer comp, ChangelogEntry this, ChangelogEntry objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@120-5(IEqualityComparer comp, ChangelogEntry this, Unit unitVar);
    internal static Regex get_nugetRegex();
    internal static Regex get_assemblyVersionRegex();
    public static Tuple`2<Match, Match> parseVersions(string line);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Changelog createWithCustomHeader(string header, FSharpOption`1<string> description, FSharpOption`1<Unreleased> unreleased, FSharpList`1<ChangelogEntry> entries);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Changelog create(FSharpOption`1<string> description, FSharpOption`1<Unreleased> unreleased, FSharpList`1<ChangelogEntry> entries);
    public static Changelog fromEntries(FSharpList`1<ChangelogEntry> entries);
    internal static bool isMainHeader(string line);
    internal static bool isVersionHeader(string line);
    internal static bool isCategoryHeader(string line);
    internal static bool containsUnreleasedHeader(string line);
    internal static bool isUnreleasedHeader(string line);
    internal static bool isBlockHeader(string line);
    internal static bool isAnyHeader(string line);
    internal static FSharpFunc`2<FSharpList`1<string>, Tuple`2<a, FSharpList`1<string>>> findFirstHeader@285(a accumulator);
    internal static Tuple`2<FSharpList`1<a>, FSharpList`1<a>> findEnd@302-1(FSharpFunc`2<a, bool> headerPredicate, FSharpList`1<a> accumulator, FSharpList`1<a> lines);
    internal static FSharpFunc`2<FSharpList`1<string>, Tuple`2<FSharpList`1<string>, FSharpList`1<string>>> findBlockEnd@308(FSharpList`1<string> accumulator);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<string>, FSharpList`1<string>>> findUnreleasedBlock@310(FSharpList`1<string> text);
    internal static FSharpOption`1<Tuple`2<string, Tuple`2<FSharpList`1<string>, FSharpList`1<string>>>> findNextChangesBlock@316(FSharpList`1<string> text);
    internal static Tuple`2<FSharpList`1<string>, FSharpList`1<string>> findCategoryEnd@323(FSharpList`1<string> changes, FSharpList`1<string> text);
    internal static FSharpOption`1<Tuple`2<string, Tuple`2<FSharpList`1<string>, FSharpList`1<string>>>> findNextCategoryBlock@322(FSharpList`1<string> text);
    internal static FSharpList`1<Change> categoryLoop@334(FSharpList`1<Change> changes, FSharpList`1<string> text);
    internal static FSharpList`1<ChangelogEntry> loop@340-1(FSharpFunc`2<string, FSharpOption`1<DateTime>> parseDate, FSharpList`1<ChangelogEntry> changeLogEntries, FSharpList`1<string> text);
    public static Changelog parse(IEnumerable`1<string> data);
    public static Changelog load(string filename);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void save(string filename, Changelog changelog);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Changelog promoteUnreleased(string version, Changelog changelog);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.CmdLineParsing : object {
    internal static string escapeCommandLineForShell(string cmdLine);
    internal static void escapeBackslashes@10(StringBuilder sb, string s, int lastSearchIndex);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string windowsArgvToCommandLine(bool shorten, IEnumerable`1<string> args);
    internal static String[] windowsCommandLineToArgv(string arguments);
    internal static string toProcessStartInfo(IEnumerable`1<string> args);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Fake.Core.Command : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsShellCommand { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRawCommand { get; }
    public string CommandLine { get; }
    [CompilationMappingAttribute("8", "0")]
public static Command NewShellCommand(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsShellCommand();
    [CompilationMappingAttribute("8", "1")]
public static Command NewRawCommand(string _executable, Arguments _arguments);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRawCommand();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Command obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_CommandLine();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Command obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.CommandLineParsing.ArgParser : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Reply`1<a> preturn(a x, IArgumentStream`1<b> stream);
    public static Reply`1<b> pzero(IArgumentStream`1<a> stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Reply`1<b> op_GreaterGreaterEquals(FSharpFunc`2<IArgumentStream`1<u>, Reply`1<a>> p, FSharpFunc`2<a, FSharpFunc`2<IArgumentStream`1<u>, Reply`1<b>>> f, IArgumentStream`1<u> stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<c>> op_GreaterGreaterPercent(FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> p, c x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<c>> op_GreaterGreaterDot(FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> p1, FSharpFunc`2<IArgumentStream`1<a>, Reply`1<c>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> op_DotGreaterGreater(FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> p1, FSharpFunc`2<IArgumentStream`1<a>, Reply`1<c>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<Tuple`2<b, c>>> op_DotGreaterGreaterDot(FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> p1, FSharpFunc`2<IArgumentStream`1<a>, Reply`1<c>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<u>, Reply`1<b>> between(FSharpFunc`2<IArgumentStream`1<u>, Reply`1<u>> popen, FSharpFunc`2<IArgumentStream`1<u>, Reply`1<a>> pclose, FSharpFunc`2<IArgumentStream`1<u>, Reply`1<b>> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<c>> op_BarGreaterGreater(FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> p, FSharpFunc`2<b, c> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<u>, Reply`1<a>> op_LessQmarkGreater(FSharpFunc`2<IArgumentStream`1<u>, Reply`1<a>> p, string label);
    internal static Tuple`2<int, int> projection@324(int maxArgLength, IArgumentStream`1<u> tupledArg0, Reply`1<a> tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Reply`1<a> choiceBest(IEnumerable`1<FSharpFunc`2<IArgumentStream`1<u>, Reply`1<a>>> ps, IArgumentStream`1<u> stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Reply`1<a> choice(IEnumerable`1<FSharpFunc`2<IArgumentStream`1<u>, Reply`1<a>>> ps, IArgumentStream`1<u> stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> op_LessBarGreater(FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> p1, FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> p2);
    public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<FSharpList`1<b>>> many(FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> p);
    public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<FSharpList`1<b>>> many1(FSharpFunc`2<IArgumentStream`1<a>, Reply`1<b>> p);
    public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<FSharpMap`2<b, c>>> pseq(IEnumerable`1<FSharpFunc`2<IArgumentStream`1<a>, Reply`1<FSharpMap`2<b, c>>>> ps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Reply`1<a> mapParserToUnorderedState(int i, FSharpFunc`2<IArgumentStream`1<u>, Reply`1<a>> p, IArgumentStream`1<UnorderedState`2<u, b>> innerStream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Reply`1<FSharpList`1<a>> punorderedseqWithMany(bool allowEmpty, bool allowMissing, IEnumerable`1<Tuple`2<bool, FSharpFunc`2<IArgumentStream`1<u>, Reply`1<a>>>> ps, IArgumentStream`1<u> stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<u>, Reply`1<FSharpList`1<a>>> punorderedseq(bool allowEmpty, bool allowMissing, IEnumerable`1<FSharpFunc`2<IArgumentStream`1<u>, Reply`1<a>>> ps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Reply`1<a> chooseParser(string itemType, FSharpFunc`2<FSharpOption`1<string>, FSharpOption`1<a>> chooser, IArgumentStream`1<b> stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Reply`1<a> chooseParserFull(string itemType, FSharpFunc`2<FSharpOption`1<string>, FSharpOption`1<a>> chooser, IArgumentStream`1<b> stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<b>, Reply`1<a>> chooseParser'(string itemType, FSharpFunc`2<string, FSharpOption`1<a>> chooser);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<b>, Reply`1<a>> chooseParserFull'(string itemType, FSharpFunc`2<string, FSharpOption`1<a>> chooser);
    public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<string>> pcmd(string cmd);
    public static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<string>> parg(string argName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Reply`1<FSharpMap`2<string, DocoptResult>> updateUserState(FSharpFunc`2<a, FSharpFunc`2<FSharpMap`2<string, DocoptResult>, FSharpMap`2<string, DocoptResult>>> map', a arg', IArgumentStream`1<FSharpMap`2<string, DocoptResult>> stream');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Reply`1<a> debug(FSharpFunc`2<a, FSharpFunc`2<IArgumentStream`1<state>, Unit>> map', a arg', IArgumentStream`1<state> stream');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpMap`2<string, DocoptResult> updateMap(string key, DocoptResult newItem, FSharpMap`2<string, DocoptResult> map);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<a, FSharpFunc`2<IArgumentStream`1<FSharpMap`2<string, DocoptResult>>, Reply`1<FSharpMap`2<string, DocoptResult>>>> saveInMap(string key, FSharpFunc`2<a, DocoptResult> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<a, FSharpFunc`2<IArgumentStream`1<FSharpMap`2<string, DocoptResult>>, Reply`1<FSharpMap`2<string, DocoptResult>>>> saveInMapM(IEnumerable`1<string> keys, FSharpFunc`2<a, DocoptResult> f);
    public static FSharpFunc`2<a, FSharpFunc`2<IArgumentStream`1<FSharpMap`2<string, DocoptResult>>, Reply`1<FSharpMap`2<string, DocoptResult>>>> multipleSaveInMap(FSharpFunc`2<a, b> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpMap`2<a, b> mergeMap(FSharpMap`2<a, b> m1, FSharpMap`2<a, b> m2);
    public static FSharpMap`2<a, b> mergeMaps(IEnumerable`1<FSharpMap`2<a, b>> maps);
    public static FSharpFunc`2<IArgumentStream`1<FSharpMap`2<string, DocoptResult>>, Reply`1<FSharpMap`2<string, DocoptResult>>> pLongFlag(SafeOption flag);
    internal static FSharpFunc`2<IArgumentStream`1<a>, Reply`1<FSharpOption`1<string>>> chooseCmd@590-3(SafeOption flag);
    public static FSharpFunc`2<IArgumentStream`1<FSharpMap`2<string, DocoptResult>>, Reply`1<FSharpMap`2<string, DocoptResult>>> pShortFlag(SafeOption flag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<FSharpMap`2<string, DocoptResult>>, Reply`1<FSharpMap`2<string, DocoptResult>>> pOption(bool includeShort, SafeOption o');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IArgumentStream`1<FSharpMap`2<string, DocoptResult>>, Reply`1<FSharpMap`2<string, DocoptResult>>> pOptions(bool allowMissing, SafeOptions flags);
    public static FSharpFunc`2<IArgumentStream`1<FSharpMap`2<string, DocoptResult>>, Reply`1<FSharpMap`2<string, DocoptResult>>> getParser(UsageAst ast);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.CommandLineParsing.ArgumentArray : object {
    public static bool isShortArgument(string arg);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.CommandLineParsing.ArgumentStream : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IArgumentStream`1<TUserState> create(String[] argv, TUserState initState);
    public static IArgumentStream`1<TUserState> clone(IArgumentStream`1<TUserState> stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IArgumentStream`1<un> map(un newState, FSharpFunc`2<uo, FSharpFunc`2<un, uo>> map, IArgumentStream`1<uo> inner);
}
[CompilationMappingAttribute("3")]
public class Fake.Core.CommandLineParsing.ArgumentStream`1 : object {
    internal String[] argv;
    internal ArgumentStreamPosition pos;
    internal long stateTag;
    internal TUserState state;
    internal ArgumentStream`1(String[] argv, TUserState initState);
    public static ArgumentStream`1<TUserState> Create(String[] argv, TUserState initState);
    public virtual string ToString();
    private virtual override IArgumentStreamState`1<TUserState> Fake-Core-CommandLineParsing-IArgumentStream`1-get_CurrentState();
    private virtual override ArgumentStreamPosition Fake-Core-CommandLineParsing-IArgumentStream`1-get_Position();
    private virtual override void Fake-Core-CommandLineParsing-IArgumentStream`1-RestoreState(IArgumentStreamState`1<TUserState> oldState);
    private virtual override long Fake-Core-CommandLineParsing-IArgumentStream`1-get_StateTag();
    private virtual override TUserState Fake-Core-CommandLineParsing-IArgumentStream`1-get_UserState();
    private virtual override void Fake-Core-CommandLineParsing-IArgumentStream`1-set_UserState(TUserState v);
    private virtual override void Fake-Core-CommandLineParsing-IArgumentStream`1-UpdateStateTag();
    private virtual override void Fake-Core-CommandLineParsing-IArgumentStream`1-Seek(ArgumentStreamPosition newPos);
    private virtual override FSharpOption`1<string> Fake-Core-CommandLineParsing-IArgumentStream`1-Peek();
    private virtual override FSharpOption`1<string> Fake-Core-CommandLineParsing-IArgumentStream`1-PeekFull();
    private virtual override bool Fake-Core-CommandLineParsing-IArgumentStream`1-get_IsEnd();
    private virtual override void Fake-Core-CommandLineParsing-IArgumentStream`1-Skip();
    private virtual override void Fake-Core-CommandLineParsing-IArgumentStream`1-SkipFull();
    private virtual override FSharpOption`1<string> Fake-Core-CommandLineParsing-IArgumentStream`1-SkipAndPeek();
    private virtual override FSharpOption`1<string> Fake-Core-CommandLineParsing-IArgumentStream`1-SkipAndPeekFull();
    private virtual override FSharpOption`1<string> Fake-Core-CommandLineParsing-IArgumentStream`1-Read();
    private virtual override FSharpOption`1<string> Fake-Core-CommandLineParsing-IArgumentStream`1-ReadFull();
    private virtual override String[] Fake-Core-CommandLineParsing-IArgumentStream`1-get_Argv();
    [CompilerGeneratedAttribute]
internal void markChange();
    [CompilerGeneratedAttribute]
internal void inc();
    [CompilerGeneratedAttribute]
internal void incFull();
    [CompilerGeneratedAttribute]
internal FSharpOption`1<string> current();
    [CompilerGeneratedAttribute]
internal FSharpOption`1<string> currentFull();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Fake.Core.CommandLineParsing.ArgumentStreamPosition : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArgumentPos { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsShortArgumentPartialPos { get; }
    public int ArgIndex { get; }
    public int InnerIndex { get; }
    [CompilationMappingAttribute("8", "0")]
public static ArgumentStreamPosition NewArgumentPos(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArgumentPos();
    [CompilationMappingAttribute("8", "1")]
public static ArgumentStreamPosition NewShortArgumentPartialPos(int item1, int item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsShortArgumentPartialPos();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ArgumentStreamPosition obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public int get_ArgIndex();
    public int get_InnerIndex();
    public bool IsEndOf(String[] argv);
    public ArgumentStreamPosition Next(String[] argv);
    public ArgumentStreamPosition NextArg(String[] argv);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ArgumentStreamPosition obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.CommandLineParsing.ArgumentStreamState`1 : object {
    [DebuggerBrowsableAttribute("0")]
internal ArgumentStreamPosition Pos@;
    [DebuggerBrowsableAttribute("0")]
internal long StateTag@;
    [DebuggerBrowsableAttribute("0")]
internal TUserState UserState@;
    [CompilationMappingAttribute("4", "0")]
public ArgumentStreamPosition Pos { get; }
    [CompilationMappingAttribute("4", "1")]
public long StateTag { get; }
    [CompilationMappingAttribute("4", "2")]
public TUserState UserState { get; }
    public ArgumentStreamState`1(ArgumentStreamPosition pos, long stateTag, TUserState userState);
    public ArgumentStreamPosition get_Pos();
    public long get_StateTag();
    public TUserState get_UserState();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ArgumentStreamState`1<TUserState> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ArgumentStreamState`1<TUserState> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.CommandLineParsing.Helpers : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<object, ErrorMessageList> unexpectedShort { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<object, string> func1@1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, ErrorMessageList> unexpectedLong { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, ErrorMessageList> expectedArg { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, ErrorMessageList> unexpectedArg { get; }
    internal static a raiseArgvException(ErrorMessageList errlist');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string improveErrorText(long lnNr, long colNr, string arg, string oldText);
    internal static FSharpFunc`2<object, ErrorMessageList> get_unexpectedShort();
    internal static FSharpFunc`2<object, string> get_func1@1();
    [CompilerGeneratedAttribute]
internal static string func1@1-1(object value);
    internal static FSharpFunc`2<string, ErrorMessageList> get_unexpectedLong();
    internal static FSharpFunc`2<string, ErrorMessageList> get_expectedArg();
    internal static FSharpFunc`2<string, ErrorMessageList> get_unexpectedArg();
    internal static a raiseInternal(ErrorMessageList exn');
    internal static a raiseUnexpectedShort(object s');
    internal static a raiseUnexpectedLong(string l');
    internal static a raiseUnexpectedArg(string a');
    internal static string printSOption(FSharpOption`1<string> s);
    internal static string printReplyStatus(ReplyStatus r);
}
[CompilationMappingAttribute("3")]
public interface Fake.Core.CommandLineParsing.IArgumentStream`1 {
    public IArgumentStreamState`1<TUserState> CurrentState { get; }
    public ArgumentStreamPosition Position { get; }
    public long StateTag { get; }
    public TUserState UserState { get; public set; }
    public bool IsEnd { get; }
    public String[] Argv { get; }
    public abstract virtual IArgumentStreamState`1<TUserState> get_CurrentState();
    public abstract virtual ArgumentStreamPosition get_Position();
    public abstract virtual void RestoreState(IArgumentStreamState`1<TUserState> );
    public abstract virtual long get_StateTag();
    public abstract virtual TUserState get_UserState();
    public abstract virtual void set_UserState(TUserState );
    public abstract virtual void UpdateStateTag();
    public abstract virtual void Seek(ArgumentStreamPosition );
    public abstract virtual FSharpOption`1<string> Peek();
    public abstract virtual FSharpOption`1<string> PeekFull();
    public abstract virtual bool get_IsEnd();
    public abstract virtual void Skip();
    public abstract virtual void SkipFull();
    public abstract virtual FSharpOption`1<string> SkipAndPeek();
    public abstract virtual FSharpOption`1<string> SkipAndPeekFull();
    public abstract virtual FSharpOption`1<string> Read();
    public abstract virtual FSharpOption`1<string> ReadFull();
    public abstract virtual String[] get_Argv();
}
[CompilationMappingAttribute("3")]
public interface Fake.Core.CommandLineParsing.IArgumentStreamState`1 {
}
[CompilationMappingAttribute("5")]
internal class Fake.Core.CommandLineParsing.InternalException : Exception {
    internal ErrorMessageList Data0@;
    [CompilationMappingAttribute("4", "0")]
internal ErrorMessageList Data0 { get; }
    internal InternalException(ErrorMessageList data0);
    protected InternalException(SerializationInfo info, StreamingContext context);
    internal ErrorMessageList get_Data0();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
internal bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.CommandLineParsing.OptionSection : object {
    [DebuggerBrowsableAttribute("0")]
internal string Title@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Lines@;
    [CompilationMappingAttribute("4", "0")]
public string Title { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<string> Lines { get; }
    public OptionSection(string title, FSharpList`1<string> lines);
    public string get_Title();
    public FSharpList`1<string> get_Lines();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(OptionSection obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OptionSection obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
public class Fake.Core.CommandLineParsing.OptionsParser : object {
    internal string soptChars';
    internal FSharpFunc`2<CharStream`1<Unit>, Reply`1<string>> pParam;
    internal FSharpFunc`2<CharStream`1<Unit>, Reply`1<string>> parg;
    internal Regex defaultRegex;
    public OptionsParser(string soptChars');
    public FSharpList`1<SafeOption> Parse(IEnumerable`1<string> optionStrings');
    [CompilerGeneratedAttribute]
internal Reply`1<a> replyErr(ErrorMessage err');
    [CompilerGeneratedAttribute]
internal bool loptPredicate(char c');
    [CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> start(CharStream`1<Unit> stream');
    [CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> short or long option(CharStream`1<Unit> stream');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> short option(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> expecting arg (short)(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> argument or hyphens or space(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> short option plus arg(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> expecting space(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> expecting hyphen 1(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> expecting hyphen 2(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> expecting long option(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> long option (+short?)(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> expecting arg or space (long)(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> expecting arg (long)(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> long option plus arg (+short?)(CharStream`1<Unit> stream, OptionsParserState state, FSharpOption`1<string> newa');
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> parameters and end(CharStream`1<Unit> stream', OptionsParserState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<OptionsParserState> poptLine(FSharpOption`1<string> dflt, CharStream`1<Unit> stream');
}
[CompilationMappingAttribute("2")]
public class Fake.Core.CommandLineParsing.OptionsParserState : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<char> ShortName@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> LongName@;
    [DebuggerBrowsableAttribute("0")]
internal bool IsRequired@;
    [DebuggerBrowsableAttribute("0")]
public FSharpOption`1<string> DefaultValue@;
    [DebuggerBrowsableAttribute("0")]
internal bool AllowMultiple@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ArgName@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<char> ShortName { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<string> LongName { get; }
    [CompilationMappingAttribute("4", "2")]
public bool IsRequired { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<string> DefaultValue { get; public set; }
    [CompilationMappingAttribute("4", "4")]
public bool AllowMultiple { get; }
    [CompilationMappingAttribute("4", "5")]
public FSharpOption`1<string> ArgName { get; }
    public OptionsParserState(FSharpOption`1<char> shortName, FSharpOption`1<string> longName, bool isRequired, FSharpOption`1<string> defaultValue, bool allowMultiple, FSharpOption`1<string> argName);
    public FSharpOption`1<char> get_ShortName();
    public FSharpOption`1<string> get_LongName();
    public bool get_IsRequired();
    public FSharpOption`1<string> get_DefaultValue();
    public bool get_AllowMultiple();
    public FSharpOption`1<string> get_ArgName();
    public void set_DefaultValue(FSharpOption`1<string> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(OptionsParserState obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static OptionsParserState CreateEmpty();
    public static SafeOption Build(OptionsParserState x);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OptionsParserState obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class Fake.Core.CommandLineParsing.PoptLineResult : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PoptLineResult _unique_Nil;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOpt { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static PoptLineResult Nil { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNil { get; }
    private static PoptLineResult();
    [CompilationMappingAttribute("8", "0")]
internal static PoptLineResult NewOpt(OptionsParserState item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsOpt();
    [CompilationMappingAttribute("8", "1")]
internal static PoptLineResult NewVal(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsVal();
    [CompilationMappingAttribute("8", "2")]
internal static PoptLineResult get_Nil();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNil();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PoptLineResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.CommandLineParsing.SafeOption : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<char> Short@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Long@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ArgumentName@;
    [DebuggerBrowsableAttribute("0")]
internal bool AllowMultiple@;
    [DebuggerBrowsableAttribute("0")]
internal bool IsRequired@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> DefaultValue@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<char> Short { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<string> Long { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<string> ArgumentName { get; }
    [CompilationMappingAttribute("4", "3")]
public bool AllowMultiple { get; }
    [CompilationMappingAttribute("4", "4")]
public bool IsRequired { get; }
    [CompilationMappingAttribute("4", "5")]
public FSharpOption`1<string> DefaultValue { get; }
    public static SafeOption Empty { get; }
    public string FullShort { get; }
    public string FullLong { get; }
    public bool IsEmpty { get; }
    public bool HasArgument { get; }
    public bool HasDefault { get; }
    public bool IsShort { get; }
    public bool IsLong { get; }
    public SafeOption(FSharpOption`1<char> short, FSharpOption`1<string> long, FSharpOption`1<string> argumentName, bool allowMultiple, bool isRequired, FSharpOption`1<string> defaultValue);
    public FSharpOption`1<char> get_Short();
    public FSharpOption`1<string> get_Long();
    public FSharpOption`1<string> get_ArgumentName();
    public bool get_AllowMultiple();
    public bool get_IsRequired();
    public FSharpOption`1<string> get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SafeOption obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static SafeOption get_Empty();
    public string get_FullShort();
    public string get_FullLong();
    public bool get_IsEmpty();
    public bool get_HasArgument();
    public bool get_HasDefault();
    public bool get_IsShort();
    public bool get_IsLong();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SafeOption obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
public class Fake.Core.CommandLineParsing.SafeOptions : object {
    internal FSharpList`1<SafeOption> list;
    public SafeOption Last { get; }
    public SafeOptions(FSharpList`1<SafeOption> list);
    public FSharpOption`1<SafeOption> Find(char s');
    public SafeOptions AddRange(FSharpList`1<SafeOption> opts);
    public FSharpOption`1<Tuple`2<SafeOptions, SafeOption>> FindAndRemove(char s');
    public FSharpOption`1<SafeOption> Find(string l');
    public FSharpOption`1<SafeOption> FindLast(string l');
    public SafeOption get_Last();
    private virtual override IEnumerator System-Collections-IEnumerable-GetEnumerator();
    private virtual override IEnumerator`1<SafeOption> System-Collections-Generic-IEnumerable`1-GetEnumerator();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<SafeOption> findIn(string l', FSharpList`1<SafeOption> list);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("3")]
public enum Fake.Core.CommandLineParsing.Tag : Enum {
    public int value__;
    public static Tag Eps;
    public static Tag Ano;
    public static Tag Sop;
    public static Tag Lop;
    public static Tag Sqb;
    public static Tag Req;
    public static Tag Arg;
    public static Tag Xor;
    public static Tag Seq;
    public static Tag Cmd;
    public static Tag Ell;
    public static Tag Sdh;
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.Core.CommandLineParsing.UsageAst : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UsageAst _unique_Eps;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UsageAst _unique_XorEmpty;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UsageAst _unique_Sdh;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UsageAst Eps { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEps { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAno { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSqb { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsReq { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArg { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UsageAst XorEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXorEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSeq { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCmd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEll { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UsageAst Sdh { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSdh { get; }
    public bool InstanceOfSop { get; }
    public bool ContainsOnlyOptions { get; }
    private static UsageAst();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UsageAst(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static UsageAst get_Eps();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEps();
    [CompilationMappingAttribute("8", "1")]
public static UsageAst NewAno(string _title, SafeOptions _o');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAno();
    [CompilationMappingAttribute("8", "2")]
public static UsageAst NewSop(SafeOptions _o');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSop();
    [CompilationMappingAttribute("8", "3")]
public static UsageAst NewLop(SafeOption _o');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLop();
    [CompilationMappingAttribute("8", "4")]
public static UsageAst NewSqb(UsageAst _ast');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSqb();
    [CompilationMappingAttribute("8", "5")]
public static UsageAst NewReq(UsageAst _ast');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsReq();
    [CompilationMappingAttribute("8", "6")]
public static UsageAst NewArg(string _name');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArg();
    [CompilationMappingAttribute("8", "7")]
public static UsageAst get_XorEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXorEmpty();
    [CompilationMappingAttribute("8", "8")]
public static UsageAst NewXor(UsageAst _l', UsageAst _r');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXor();
    [CompilationMappingAttribute("8", "9")]
public static UsageAst NewSeq(FSharpList`1<UsageAst> _asts');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSeq();
    [CompilationMappingAttribute("8", "10")]
public static UsageAst NewCmd(string _cmd');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCmd();
    [CompilationMappingAttribute("8", "11")]
public static UsageAst NewEll(UsageAst _ast');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEll();
    [CompilationMappingAttribute("8", "12")]
public static UsageAst get_Sdh();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSdh();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool get_InstanceOfSop();
    public bool get_ContainsOnlyOptions();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UsageAst obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.Core.CommandLineParsing.UsageAstBuilder : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UsageAstBuilder _unique_Eps;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UsageAstBuilder _unique_XorEmpty;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UsageAstBuilder _unique_Sdh;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UsageAstBuilder Eps { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEps { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAno { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSqb { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsReq { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArg { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UsageAstBuilder XorEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXorEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSeq { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCmd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEll { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UsageAstBuilder Sdh { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSdh { get; }
    public Tag UsageTag { get; }
    private static UsageAstBuilder();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UsageAstBuilder(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static UsageAstBuilder get_Eps();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEps();
    [CompilationMappingAttribute("8", "1")]
public static UsageAstBuilder NewAno(string _title, SafeOptions _o');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAno();
    [CompilationMappingAttribute("8", "2")]
public static UsageAstBuilder NewSop(SafeOptions _o');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSop();
    [CompilationMappingAttribute("8", "3")]
public static UsageAstBuilder NewLop(SafeOption _o');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLop();
    [CompilationMappingAttribute("8", "4")]
public static UsageAstBuilder NewSqb(UsageAstCell _ast');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSqb();
    [CompilationMappingAttribute("8", "5")]
public static UsageAstBuilder NewReq(UsageAstCell _ast');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsReq();
    [CompilationMappingAttribute("8", "6")]
public static UsageAstBuilder NewArg(string _name');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArg();
    [CompilationMappingAttribute("8", "7")]
public static UsageAstBuilder get_XorEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXorEmpty();
    [CompilationMappingAttribute("8", "8")]
public static UsageAstBuilder NewXor(UsageAstCell _l', UsageAstCell _r');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXor();
    [CompilationMappingAttribute("8", "9")]
public static UsageAstBuilder NewSeq(FSharpList`1<UsageAstCell> _asts');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSeq();
    [CompilationMappingAttribute("8", "10")]
public static UsageAstBuilder NewCmd(string _cmd');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCmd();
    [CompilationMappingAttribute("8", "11")]
public static UsageAstBuilder NewEll(UsageAstCell _ast');
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEll();
    [CompilationMappingAttribute("8", "12")]
public static UsageAstBuilder get_Sdh();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSdh();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static UsageAstCell ToCell(UsageAstBuilder x);
    public Tag get_UsageTag();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UsageAstBuilder obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.CommandLineParsing.UsageAstCell : object {
    [DebuggerBrowsableAttribute("0")]
public FSharpOption`1<UsageAstBuilder> Content@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<UsageAstBuilder> Content { get; public set; }
    public UsageAstCell(FSharpOption`1<UsageAstBuilder> content);
    public FSharpOption`1<UsageAstBuilder> get_Content();
    public void set_Content(FSharpOption`1<UsageAstBuilder> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static UsageAstCell FromBuilder(UsageAstBuilder x);
    public UsageAst Build();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UsageAstCell obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("5")]
public class Fake.Core.CommandLineParsing.UsageException : Exception {
    internal string Data0@;
    [CompilationMappingAttribute("4", "0")]
public string Data0 { get; }
    public string Message { get; }
    public UsageException(string data0);
    protected UsageException(SerializationInfo info, StreamingContext context);
    public string get_Data0();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
public class Fake.Core.CommandLineParsing.UsageParser : object {
    internal FSharpFunc`2<CharStream`1<UsageAstCell>, Reply`1<UsageAstCell>> pusageLine;
    internal UsageAst[] asts;
    internal FSharpFunc`2<IArgumentStream`1<FSharpMap`2<string, DocoptResult>>, Reply`1<FSharpMap`2<string, DocoptResult>>> pAstParser;
    public UsageAst[] Asts { get; }
    public UsageParser(String[] usageStrings', FSharpList`1<Tuple`2<string, SafeOptions>> sections);
    public FSharpMap`2<string, DocoptResult> ParseCommandLine(String[] argv);
    public UsageAst[] get_Asts();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Reply`1<UsageAstCell> updateUserState(FSharpFunc`2<a, FSharpFunc`2<UsageAstCell, UsageAstCell>> map', a arg', CharStream`1<UsageAstCell> stream');
    [CompilerGeneratedAttribute]
internal bool isLetterOrDigit(char c');
    [CompilerGeneratedAttribute]
internal FSharpFunc`2<CharStream`1<UsageAstCell>, Reply`1<UsageAstCell>> pano(string title, SafeOptions so);
    [CompilerGeneratedAttribute]
internal FSharpAsync`1<UsageAst> parseAsync(string _arg2);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.ConsoleMessage : object {
    [DebuggerBrowsableAttribute("0")]
internal bool IsError@;
    [DebuggerBrowsableAttribute("0")]
internal string Message@;
    [DebuggerBrowsableAttribute("0")]
internal DateTimeOffset Timestamp@;
    [CompilationMappingAttribute("4", "0")]
public bool IsError { get; }
    [CompilationMappingAttribute("4", "1")]
public string Message { get; }
    [CompilationMappingAttribute("4", "2")]
public DateTimeOffset Timestamp { get; }
    public ConsoleMessage(bool isError, string message, DateTimeOffset timestamp);
    public bool get_IsError();
    public string get_Message();
    public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ConsoleMessage obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ConsoleMessage Create(bool isError, string msg);
    public static ConsoleMessage CreateError(string msg);
    public static ConsoleMessage CreateOut(string msg);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ConsoleMessage obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
public class Fake.Core.ConsoleTraceListener : object {
    internal bool importantMessagesToStdErr;
    internal FSharpFunc`2<TraceData, ConsoleColor> colorMap;
    internal bool ansiColor;
    public ConsoleTraceListener(bool importantMessagesToStdErr, FSharpFunc`2<TraceData, ConsoleColor> colorMap, bool ansiColor);
    private virtual override void Fake-Core-ITraceListener-Write(TraceData msg);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.ConsoleWriter : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void write(bool toStdErr, ConsoleColor color, bool newLine, string text);
    internal static FSharpList`1<int> colorCode@234(ConsoleColor _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeAnsiColor(bool toStdErr, ConsoleColor color, bool newLine, string text);
    public static ConsoleColor colorMap(TraceData traceData);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.Context : object {
    internal static string fake_ExecutionType { get; }
    internal static void cleanSeq@15(IEnumerable s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void setContext(string name, object o);
    internal static object getContext(string name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_fake_ExecutionType();
    public static RuntimeContext getExecutionContext();
    public static void setExecutionContext(RuntimeContext e);
    public static void removeExecutionContext();
    public static FSharpOption`1<FakeExecutionContext> getFakeExecutionContext(RuntimeContext e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<object> getFakeContext(string name, FakeExecutionContext f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<object> removeFakeContext(string name, FakeExecutionContext f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static object setFakeContext(string name, object v, FSharpFunc`2<object, object> updateF, FakeExecutionContext f);
    public static bool isFakeContext();
    public static FakeExecutionContext forceFakeContext();
    [ObsoleteAttribute("Please use 'Fake.Core.FakeVar.get' instead")]
public static FSharpOption`1<a> getFakeVar(string name);
    [ObsoleteAttribute("Please use 'Fake.Core.FakeVar.remove' instead")]
public static FSharpOption`1<a> removeFakeVar(string name);
    [ObsoleteAttribute("Please use 'Fake.Core.FakeVar.set' instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a setFakeVar(string name, a v);
    [ObsoleteAttribute("Please use 'Fake.Core.FakeVar.define' instead")]
public static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<a>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<a, Unit>> fakeVar(string name);
    [ObsoleteAttribute("Please use 'Fake.Core.FakeVar.defineAllowNoContext' instead")]
public static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<a>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<a, Unit>> fakeVarAllowNoContext(string name);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.CoreTracing : object {
    [CompilationMappingAttribute("9")]
public static bool importantMessagesToStdErr { get; }
    [CompilationMappingAttribute("9")]
internal static BuildServer y@1 { get; }
    [CompilationMappingAttribute("9")]
public static ITraceListener defaultConsoleTraceListener { get; }
    internal static string traceListenersVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<FSharpList`1<ITraceListener>>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<FSharpList`1<ITraceListener>, Unit>> patternInput@348-1 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<FSharpList`1<ITraceListener>, Unit> setTraceListenersPrivate { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, FSharpOption`1<FSharpList`1<ITraceListener>>> getTraceListeners { get; }
    public static bool get_importantMessagesToStdErr();
    internal static BuildServer get_y@1();
    public static ITraceListener get_defaultConsoleTraceListener();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_traceListenersVar();
    internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<FSharpList`1<ITraceListener>>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<FSharpList`1<ITraceListener>, Unit>> get_patternInput@348-1();
    public static FSharpFunc`2<FSharpList`1<ITraceListener>, Unit> get_setTraceListenersPrivate();
    internal static FSharpFunc`2<Unit, FSharpOption`1<FSharpList`1<ITraceListener>>> get_getTraceListeners();
    public static bool areListenersSet();
    public static FSharpList`1<ITraceListener> getListeners();
    public static void setTraceListeners(FSharpList`1<ITraceListener> l);
    public static void addListener(ITraceListener l);
    public static void ensureConsoleListener();
    public static void postMessage(TraceData x);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.CreateProcess : object {
    [CompilationMappingAttribute("9")]
internal static IProcessHook`1<ProcessResult`1<Unit>> emptyHook { get; }
    internal static IProcessHook`1<ProcessResult`1<Unit>> get_emptyHook();
    public static CreateProcess`1<ProcessResult`1<Unit>> fromCommand(Command command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<ProcessResult`1<Unit>> fromRawCommandLine(string command, string windowsCommandLine);
    [ObsoleteAttribute("Use fromRawCommandLine instead.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<ProcessResult`1<Unit>> fromRawWindowsCommandLine(string command, string windowsCommandLine);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<ProcessResult`1<Unit>> fromRawCommand(string command, IEnumerable`1<string> args);
    public static CreateProcess`1<ProcessResult`1<Unit>> ofStartInfo(ProcessStartInfo p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StreamSpecification interceptStreamFallback(FSharpFunc`2<Unit, StreamSpecification> onInherit, Stream target, StreamSpecification s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StreamSpecification interceptStream(Stream target, StreamSpecification s);
    public static CreateProcess`1<a> copyRedirectedProcessOutputsToStandardOutputs(CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withWorkingDirectory(string workDir, CreateProcess`1<a> c);
    public static CreateProcess`1<a> disableTraceCommand(CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withCommand(Command command, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> replaceFilePath(string newFilePath, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> mapFilePath(FSharpFunc`2<string, string> f, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CreateProcess`1<a> withHook(IProcessHook`1<a> h, CreateProcess`1<b> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CreateProcess`1<b> withHookImpl(IProcessHookImpl`2<a, b> h, CreateProcess`1<c> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IProcessHookImpl`2<a, b> simpleHook(FSharpFunc`2<Unit, a> prepareState, FSharpFunc`2<a, FSharpFunc`2<StreamSpecs, StreamSpecs>> prepareStreams, FSharpFunc`2<a, FSharpFunc`2<Process, Unit>> onStart, FSharpFunc`2<a, FSharpFunc`2<Task`1<RawProcessResult>, FSharpAsync`1<b>>> onResult);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IProcessHookImpl`2<CombinedState`1<a>, b> hookAppendFuncs(FSharpFunc`2<Unit, a> prepareState, FSharpFunc`2<a, FSharpFunc`2<StreamSpecs, StreamSpecs>> prepareStreams, FSharpFunc`2<a, FSharpFunc`2<Process, Unit>> onStart, FSharpFunc`2<FSharpAsync`1<TRes>, FSharpFunc`2<a, FSharpFunc`2<Task`1<RawProcessResult>, FSharpAsync`1<b>>>> onResult, IProcessHook`1<TRes> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CreateProcess`1<c> appendFuncs(FSharpFunc`2<Unit, a> prepareState, FSharpFunc`2<a, FSharpFunc`2<StreamSpecs, StreamSpecs>> prepareStreams, FSharpFunc`2<a, FSharpFunc`2<Process, Unit>> onStart, FSharpFunc`2<FSharpAsync`1<b>, FSharpFunc`2<a, FSharpFunc`2<Task`1<RawProcessResult>, FSharpAsync`1<c>>>> onResult, CreateProcess`1<b> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CreateProcess`1<c> appendFuncsDispose(FSharpFunc`2<Unit, a> prepareState, FSharpFunc`2<a, FSharpFunc`2<StreamSpecs, StreamSpecs>> prepareStreams, FSharpFunc`2<a, FSharpFunc`2<Process, Unit>> onStart, FSharpFunc`2<FSharpAsync`1<b>, FSharpFunc`2<a, FSharpFunc`2<Task`1<RawProcessResult>, FSharpAsync`1<c>>>> onResult, FSharpFunc`2<a, Unit> onDispose, CreateProcess`1<b> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<c> appendSimpleFuncs(FSharpFunc`2<Unit, a> prepareState, FSharpFunc`2<a, FSharpFunc`2<Process, Unit>> onStart, FSharpFunc`2<FSharpAsync`1<b>, FSharpFunc`2<a, FSharpFunc`2<Task`1<RawProcessResult>, FSharpAsync`1<c>>>> onResult, FSharpFunc`2<a, Unit> onDispose, CreateProcess`1<b> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<b> addOnSetup(FSharpFunc`2<Unit, a> f, CreateProcess`1<b> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> addOnFinally(FSharpFunc`2<Unit, Unit> f, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> addOnStarted(FSharpFunc`2<Unit, Unit> f, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withEnvironment(FSharpList`1<Tuple`2<string, string>> env, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withEnvironmentMap(IImmutableDictionary`2<string, string> env, CreateProcess`1<a> c);
    public static IImmutableDictionary`2<string, string> getEnvironmentMap(CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> setEnvironmentVariable(string envKey, string envVar, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withStandardOutput(StreamSpecification stdOut, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withStandardError(StreamSpecification stdErr, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withStandardInput(StreamSpecification stdIn, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<b> map(FSharpFunc`2<a, b> f, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<ProcessResult`1<b>> mapResult(FSharpFunc`2<a, b> f, CreateProcess`1<ProcessResult`1<a>> c);
    public static CreateProcess`1<ProcessResult`1<ProcessOutput>> redirectOutput(CreateProcess`1<a> c);
    internal static Task`1<Unit> watchStream@434(FSharpFunc`2<string, Unit> onF, Stream stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withOutputEvents(FSharpFunc`2<string, Unit> onStdOut, FSharpFunc`2<string, Unit> onStdErr, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withOutputEventsNotNull(FSharpFunc`2<string, Unit> onStdOut, FSharpFunc`2<string, Unit> onStdErr, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<b> addOnExited(FSharpFunc`2<a, FSharpFunc`2<int, b>> f, CreateProcess`1<a> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> ensureExitCodeWithMessage(string msg, CreateProcess`1<a> r);
    internal static FSharpOption`1<ProcessOutput> tryGetOutput(object data);
    public static CreateProcess`1<a> ensureExitCode(CreateProcess`1<a> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<Unit> warnOnExitCode(string msg, CreateProcess`1<Unit> r);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1-2(Process proc, Exception _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CreateProcess`1<a> withTimeout(TimeSpan timeout, CreateProcess`1<a> c);
    internal static CreateProcess`1<Tuple`3<Process, FSharpAsync`1<a>, Task`1<RawProcessResult>>> getProcess(CreateProcess`1<a> c);
}
[CompilationMappingAttribute("34")]
public class Fake.Core.CreateProcess`1 : object {
    [DebuggerBrowsableAttribute("0")]
internal Command Command@;
    [DebuggerBrowsableAttribute("0")]
internal bool TraceCommand@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> WorkingDirectory@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<IImmutableDictionary`2<string, string>> Environment@;
    [DebuggerBrowsableAttribute("0")]
internal StreamSpecs Streams@;
    [DebuggerBrowsableAttribute("0")]
internal IProcessHook`1<TRes> Hook@;
    [CompilationMappingAttribute("4", "0")]
internal Command Command { get; }
    [CompilationMappingAttribute("4", "1")]
internal bool TraceCommand { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpOption`1<string> WorkingDirectory { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpOption`1<IImmutableDictionary`2<string, string>> Environment { get; }
    [CompilationMappingAttribute("4", "4")]
internal StreamSpecs Streams { get; }
    [CompilationMappingAttribute("4", "5")]
internal IProcessHook`1<TRes> Hook { get; }
    public string CommandLine { get; }
    internal CreateProcess`1(Command command, bool traceCommand, FSharpOption`1<string> workingDirectory, FSharpOption`1<IImmutableDictionary`2<string, string>> environment, StreamSpecs streams, IProcessHook`1<TRes> hook);
    internal Command get_Command();
    internal bool get_TraceCommand();
    internal FSharpOption`1<string> get_WorkingDirectory();
    internal FSharpOption`1<IImmutableDictionary`2<string, string>> get_Environment();
    internal StreamSpecs get_Streams();
    internal IProcessHook`1<TRes> get_Hook();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public string get_CommandLine();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.CreateProcessExt : object {
}
[CompilationMappingAttribute("34")]
public class Fake.Core.DataRef`1 : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpRef`1<FSharpFunc`2<Unit, T>> retrieveRaw@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpRef`1<FSharpFunc`2<Unit, T>> retrieveRaw { get; }
    public static DataRef`1<T> Empty { get; }
    public T Value { get; }
    internal DataRef`1(FSharpRef`1<FSharpFunc`2<Unit, T>> retrieveRaw);
    internal FSharpRef`1<FSharpFunc`2<Unit, T>> get_retrieveRaw();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static DataRef`1<T> get_Empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DataRef`1<a> Map(FSharpFunc`2<T, a> f, DataRef`1<T> inner);
    public T get_Value();
}
[CompilationMappingAttribute("34")]
internal class Fake.Core.DeclarationInfo : object {
    [DebuggerBrowsableAttribute("0")]
internal string File@;
    [DebuggerBrowsableAttribute("0")]
internal int Line@;
    [DebuggerBrowsableAttribute("0")]
internal int Column@;
    [DebuggerBrowsableAttribute("0")]
internal string ErrorDetail@;
    [CompilationMappingAttribute("4", "0")]
internal string File { get; }
    [CompilationMappingAttribute("4", "1")]
internal int Line { get; }
    [CompilationMappingAttribute("4", "2")]
internal int Column { get; }
    [CompilationMappingAttribute("4", "3")]
internal string ErrorDetail { get; }
    internal DeclarationInfo(string file, int line, int column, string errorDetail);
    internal string get_File();
    internal int get_Line();
    internal int get_Column();
    internal string get_ErrorDetail();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DeclarationInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DeclarationInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("34")]
internal class Fake.Core.Dependency : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal DeclarationInfo Declaration@;
    [CompilationMappingAttribute("4", "0")]
internal string Name { get; }
    [CompilationMappingAttribute("4", "1")]
internal DeclarationInfo Declaration { get; }
    internal Dependency(string name, DeclarationInfo declaration);
    internal string get_Name();
    internal DeclarationInfo get_Declaration();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Dependency obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Dependency obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.DocHelper : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static StringComparison OrdinalIgnoreCase;
    [CompilerGeneratedAttribute]
internal static FSharpChoice`4<string, Tuple`2<string, string>, string, Unit> |Usage|Options|Other|Newline|$cont@21(string line', Unit unitVar);
    internal static FSharpChoice`4<string, Tuple`2<string, string>, string, Unit> |Usage|Options|Other|Newline|(string line');
    internal static OptionSection mapping@1(string tupledArg0, OptionSection[] tupledArg1);
    public static Tuple`2<String[], OptionSection[]> cut(string doc');
}
[CompilationMappingAttribute("3")]
public class Fake.Core.Docopt : object {
    internal String[] uStrs;
    internal FSharpList`1<Tuple`2<string, SafeOptions>> sectionsParsers;
    internal UsageParser pusage;
    public string Usage { get; }
    public UsageParser UsageParser { get; }
    public Docopt(string doc', FSharpOption`1<string> soptChars');
    public FSharpMap`2<string, DocoptResult> Parse(String[] argv');
    public string get_Usage();
    public UsageParser get_UsageParser();
}
[CompilationMappingAttribute("5")]
public class Fake.Core.DocoptException : Exception {
    internal string Data0@;
    [CompilationMappingAttribute("4", "0")]
public string Data0 { get; }
    public string Message { get; }
    public DocoptException(string data0);
    protected DocoptException(SerializationInfo info, StreamingContext context);
    public string get_Data0();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.Core.DocoptResult : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DocoptResult _unique_NoResult;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DocoptResult _unique_Flag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DocoptResult NoResult { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoResult { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DocoptResult Flag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFlag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFlags { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArgument { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArguments { get; }
    private static DocoptResult();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DocoptResult(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static DocoptResult get_NoResult();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoResult();
    [CompilationMappingAttribute("8", "1")]
public static DocoptResult get_Flag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFlag();
    [CompilationMappingAttribute("8", "2")]
public static DocoptResult NewFlags(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFlags();
    [CompilationMappingAttribute("8", "3")]
public static DocoptResult NewArgument(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArgument();
    [CompilationMappingAttribute("8", "4")]
public static DocoptResult NewArguments(FSharpList`1<string> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArguments();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DocoptResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocoptResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.DocoptResultModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int getFlagCount(string flag, FSharpMap`2<string, DocoptResult> map);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool hasFlag(string flag, FSharpMap`2<string, DocoptResult> map);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryGetArgument(string flag, FSharpMap`2<string, DocoptResult> map);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<FSharpList`1<string>> tryGetArguments(string flag, FSharpMap`2<string, DocoptResult> map);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.Core.DotNetCoverageTool : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoverageTool _unique_DotCover;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoverageTool _unique_PartCover;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoverageTool _unique_NCover;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoverageTool _unique_NCover3;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoverageTool DotCover { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotCover { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoverageTool PartCover { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPartCover { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoverageTool NCover { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNCover { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoverageTool NCover3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNCover3 { get; }
    private static DotNetCoverageTool();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DotNetCoverageTool(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static DotNetCoverageTool get_DotCover();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotCover();
    [CompilationMappingAttribute("8", "1")]
public static DotNetCoverageTool get_PartCover();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPartCover();
    [CompilationMappingAttribute("8", "2")]
public static DotNetCoverageTool get_NCover();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNCover();
    [CompilationMappingAttribute("8", "3")]
public static DotNetCoverageTool get_NCover3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNCover3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DotNetCoverageTool obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DotNetCoverageTool obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.Environment : object {
    [CompilationMappingAttribute("9")]
public static string ProgramFiles { get; }
    [CompilationMappingAttribute("9")]
public static string ProgramFilesX86 { get; }
    [CompilationMappingAttribute("9")]
internal static string wow64@139 { get; }
    [CompilationMappingAttribute("9")]
internal static string globalArch@140 { get; }
    [CompilationMappingAttribute("9")]
internal static string arg@1 { get; }
    [CompilationMappingAttribute("9")]
internal static string detected@146 { get; }
    [CompilationMappingAttribute("9")]
public static string SystemRoot { get; }
    [CompilationMappingAttribute("9")]
public static bool isUnix { get; }
    [CompilationMappingAttribute("9")]
internal static int arg@1-1 { get; }
    [CompilationMappingAttribute("9")]
internal static int p@160 { get; }
    [CompilationMappingAttribute("9")]
public static bool isMacOS { get; }
    [CompilationMappingAttribute("9")]
public static bool isLinux { get; }
    [CompilationMappingAttribute("9")]
public static bool isWindows { get; }
    [CompilationMappingAttribute("9")]
public static bool isMono { get; }
    public static bool isDotNetCore { get; }
    [ObsoleteAttribute("Use isDotNetCore instead (different casing of 'N')")]
public static bool isDotnetCore { get; }
    [CompilationMappingAttribute("9")]
public static FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>> monoVersion { get; }
    [CompilationMappingAttribute("9")]
internal static Type t@238 { get; }
    [CompilationMappingAttribute("9")]
public static IEnumerable`1<string> pathDirectories { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> arg@1-2 { get; }
    [CompilationMappingAttribute("9")]
public static string monoPath { get; }
    [CompilationMappingAttribute("9")]
internal static string TargetPlatformPrefix { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> a@263 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> a@263-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> b@263 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> b@263-1 { get; }
    [CompilationMappingAttribute("9")]
public static string sdkBasePath { get; }
    public static string environVar(string name);
    public static FSharpList`1<Tuple`2<string, string>> environVars();
    [ObsoleteAttribute("Will be removed in dotnetcore. Use environVars instead.")]
public static FSharpList`1<Tuple`2<object, object>> environVarsWithMode(EnvironmentVariableTarget mode);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setEnvironVar(string name, string value);
    public static void clearEnvironVar(string name);
    [ObsoleteAttribute("Use setEnvironVar instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setBuildParam(string name, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string environVarOrDefault(string name, string defaultValue);
    public static string environVarOrFail(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool environVarAsBoolOrDefault(string varName, bool defaultValue);
    public static bool environVarAsBool(string varName);
    public static FSharpOption`1<string> environVarOrNone(string name);
    public static FSharpList`1<string> splitEnvironVar(string name);
    public static bool hasEnvironVar(string name);
    [ObsoleteAttribute("Use hasEnvironVar instead")]
public static bool hasBuildParam(string name);
    [ObsoleteAttribute("Use environVarOrDefault instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getBuildParamOrDefault(string name, string defaultParam);
    [ObsoleteAttribute("Use 'environVarOrDefault name String.Empty' instead")]
public static string getBuildParam(string name);
    public static string get_ProgramFiles();
    public static string get_ProgramFilesX86();
    internal static string get_wow64@139();
    internal static string get_globalArch@140();
    internal static string get_arg@1();
    internal static string get_detected@146();
    public static string get_SystemRoot();
    public static bool get_isUnix();
    internal static int get_arg@1-1();
    internal static int get_p@160();
    public static bool get_isMacOS();
    public static bool get_isLinux();
    public static bool get_isWindows();
    public static bool get_isMono();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static bool get_isDotNetCore();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static bool get_isDotnetCore();
    public static FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>> get_monoVersion();
    internal static Type get_t@238();
    public static IEnumerable`1<string> get_pathDirectories();
    internal static FSharpList`1<string> get_arg@1-2();
    public static string get_monoPath();
    internal static string get_TargetPlatformPrefix();
    internal static FSharpOption`1<string> get_a@263();
    internal static FSharpOption`1<string> get_a@263-1();
    internal static FSharpOption`1<string> get_b@263();
    internal static FSharpOption`1<string> get_b@263-1();
    public static string get_sdkBasePath();
    public static a getNewestTool(IEnumerable`1<a> possibleToolPaths);
    public static string getTargetPlatformDir(string platformVersion);
    public static Encoding getDefaultEncoding();
    [ObsoleteAttribute("Will no longer be available in dotnetcore, target package is currently unknown")]
public static IEnumerable`1<string> getInstalledDotNetFrameworks();
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@329-3(IEqualityComparer comp, MachineDetails this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@329-8(MachineDetails this, object obj, IEqualityComparer comp, Unit unitVar);
    [ObsoleteAttribute("Will no longer be available in dotnetcore, target package is currently unknown")]
public static IEnumerable`1<string> getDrivesInfo();
    [ObsoleteAttribute("Will no longer be available in dotnetcore, target package is currently unknown")]
public static MachineDetails getMachineEnvironment();
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.EnvMapModule : object {
    [CompilationMappingAttribute("9")]
public static IImmutableDictionary`2<string, string> empty { get; }
    public static IImmutableDictionary`2<string, string> get_empty();
    public static IImmutableDictionary`2<string, string> ofSeq(IEnumerable`1<Tuple`2<string, string>> l);
    public static IImmutableDictionary`2<string, string> create();
}
[CompilationMappingAttribute("2")]
public class Fake.Core.ExecParams : object {
    [DebuggerBrowsableAttribute("0")]
internal string Program@;
    [DebuggerBrowsableAttribute("0")]
internal string WorkingDir@;
    [DebuggerBrowsableAttribute("0")]
internal string CommandLine@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2<string, string>> Args@;
    [CompilationMappingAttribute("4", "0")]
public string Program { get; }
    [CompilationMappingAttribute("4", "1")]
public string WorkingDir { get; }
    [CompilationMappingAttribute("4", "2")]
public string CommandLine { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpList`1<Tuple`2<string, string>> Args { get; }
    public static ExecParams Empty { get; }
    public ExecParams(string program, string workingDir, string commandLine, FSharpList`1<Tuple`2<string, string>> args);
    public string get_Program();
    public string get_WorkingDir();
    public string get_CommandLine();
    public FSharpList`1<Tuple`2<string, string>> get_Args();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ExecParams obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static ExecParams get_Empty();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ExecParams obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.FakeVar : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> getFrom(string name, FakeExecutionContext context);
    public static FSharpOption`1<a> get(string name);
    public static a getOrFail(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a getOrDefault(string name, a defaultValue);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void removeFrom(string name, FakeExecutionContext context);
    public static void remove(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void setFrom(string name, a v, FakeExecutionContext context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void set(string name, a v);
    public static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<a>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<a, Unit>> define(string name);
    public static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<a>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<a, Unit>> defineAllowNoContext(string name);
    public static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<a>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<a, Unit>> defineOrNone(string name);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.GuardedAwaitObservable : object {
    internal static a synchronize(FSharpFunc`2<FSharpFunc`2<FSharpFunc`2<Unit, Unit>, Unit>, a> f);
    internal static void setRemover@23(FSharpRef`1<FSharpOption`1<IDisposable>> removeObj, object removeLock, IDisposable r);
    [CompilerGeneratedAttribute]
internal static void action@1-4(FSharpRef`1<FSharpOption`1<IDisposable>> removeObj, Unit unitVar0);
    internal static void remove@25(FSharpRef`1<FSharpOption`1<IDisposable>> removeObj, object removeLock, Unit unitVar0);
    internal static void finish@35(FSharpRef`1<FSharpOption`1<IDisposable>> removeObj, object removeLock, FSharpFunc`2<FSharpFunc`2<Unit, Unit>, Unit> f, FSharpFunc`2<a, Unit> cont, a value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<T1> Async.GuardedAwaitObservable.Static(IObservable`1<T1> ev1, FSharpFunc`2<Unit, Unit> guardFunction);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.IMap : object {
    public static IImmutableDictionary`2<key, value> empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<b> tryFind(a k, IImmutableDictionary`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IImmutableDictionary`2<a, b> remove(a k, IImmutableDictionary`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void iter(FSharpFunc`2<a, FSharpFunc`2<b, Unit>> f, IImmutableDictionary`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IImmutableDictionary`2<a, b> add(a k, b v, IImmutableDictionary`2<a, b> m);
    public static IEnumerable`1<Tuple`2<a, b>> toSeq(IImmutableDictionary`2<a, b> m);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.Core.ImportData : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_BuildArtifact;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_DotNetDupFinder;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_PmdCpd;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_Pmd;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_FxCop;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_ReSharperInspectCode;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_Jslint;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_FindBugs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_Checkstyle;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_Gtest;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_Mstest;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_Surefire;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_Junit;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ImportData _unique_Xunit;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData BuildArtifact { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBuildArtifact { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBuildArtifactWithName { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNetCoverage { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData DotNetDupFinder { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNetDupFinder { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData PmdCpd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPmdCpd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData Pmd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPmd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData FxCop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFxCop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData ReSharperInspectCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsReSharperInspectCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData Jslint { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsJslint { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData FindBugs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFindBugs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData Checkstyle { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCheckstyle { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData Gtest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGtest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData Mstest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMstest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData Surefire { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSurefire { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData Junit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsJunit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ImportData Xunit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXunit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNunit { get; }
    public string Name { get; }
    private static ImportData();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ImportData(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static ImportData get_BuildArtifact();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBuildArtifact();
    [CompilationMappingAttribute("8", "1")]
public static ImportData NewBuildArtifactWithName(string _artifactName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBuildArtifactWithName();
    [CompilationMappingAttribute("8", "2")]
public static ImportData NewDotNetCoverage(DotNetCoverageTool item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNetCoverage();
    [CompilationMappingAttribute("8", "3")]
public static ImportData get_DotNetDupFinder();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNetDupFinder();
    [CompilationMappingAttribute("8", "4")]
public static ImportData get_PmdCpd();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPmdCpd();
    [CompilationMappingAttribute("8", "5")]
public static ImportData get_Pmd();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPmd();
    [CompilationMappingAttribute("8", "6")]
public static ImportData get_FxCop();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFxCop();
    [CompilationMappingAttribute("8", "7")]
public static ImportData get_ReSharperInspectCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsReSharperInspectCode();
    [CompilationMappingAttribute("8", "8")]
public static ImportData get_Jslint();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsJslint();
    [CompilationMappingAttribute("8", "9")]
public static ImportData get_FindBugs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFindBugs();
    [CompilationMappingAttribute("8", "10")]
public static ImportData get_Checkstyle();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCheckstyle();
    [CompilationMappingAttribute("8", "11")]
public static ImportData get_Gtest();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGtest();
    [CompilationMappingAttribute("8", "12")]
public static ImportData get_Mstest();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMstest();
    [CompilationMappingAttribute("8", "13")]
public static ImportData get_Surefire();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSurefire();
    [CompilationMappingAttribute("8", "14")]
public static ImportData get_Junit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsJunit();
    [CompilationMappingAttribute("8", "15")]
public static ImportData get_Xunit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXunit();
    [CompilationMappingAttribute("8", "16")]
public static ImportData NewNunit(NunitDataVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNunit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ImportData obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_Name();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ImportData obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.InternalStreams : object {
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FSharpAsync`1<Unit>> catchFunction@1(FSharpAsyncReplyChannel`1<FSharpOption`1<Exception>> reply, Exception exn);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FSharpAsync`1<Unit>> catchFunction@1-1(FSharpAsyncReplyChannel`1<FSharpChoice`2<a, Exception>> reply, Exception exn);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FSharpAsync`1<Unit>> catchFunction@1-2(FSharpAsyncReplyChannel`1<FSharpChoice`2<FSharpOption`1<a>, Exception>> reply, Exception exn);
    internal static FSharpAsync`1<b> loop@122-2(Queue`1<a> queue, Queue`1<FSharpAsyncReplyChannel`1<FSharpChoice`2<a, Exception>>> waitingQueue, FSharpMailboxProcessor`1<ConcurrentQueueMessage`1<a>> inbox, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void action@1-5(MyIAsyncReadResult`1<a> x, FSharpOption`1<a> resultData, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void action@1-6(MyIAsyncReadResult`1<a> x, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1-1(Exception _arg4);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("34")]
internal class Fake.Core.InternalTarget : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Dependency> Dependencies@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Dependency> SoftDependencies@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Description@;
    [DebuggerBrowsableAttribute("0")]
internal int DefinitionOrder@;
    [DebuggerBrowsableAttribute("0")]
internal DeclarationInfo Declaration@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<TargetParameter, Unit> Function@;
    [CompilationMappingAttribute("4", "0")]
internal string Name { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpList`1<Dependency> Dependencies { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpList`1<Dependency> SoftDependencies { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpOption`1<string> Description { get; }
    [CompilationMappingAttribute("4", "4")]
internal int DefinitionOrder { get; }
    [CompilationMappingAttribute("4", "5")]
internal DeclarationInfo Declaration { get; }
    [CompilationMappingAttribute("4", "6")]
internal FSharpFunc`2<TargetParameter, Unit> Function { get; }
    internal string DescriptionAsString { get; }
    internal Target AsTarget { get; }
    internal InternalTarget(string name, FSharpList`1<Dependency> dependencies, FSharpList`1<Dependency> softDependencies, FSharpOption`1<string> description, int definitionOrder, DeclarationInfo declaration, FSharpFunc`2<TargetParameter, Unit> function);
    internal string get_Name();
    internal FSharpList`1<Dependency> get_Dependencies();
    internal FSharpList`1<Dependency> get_SoftDependencies();
    internal FSharpOption`1<string> get_Description();
    internal int get_DefinitionOrder();
    internal DeclarationInfo get_Declaration();
    internal FSharpFunc`2<TargetParameter, Unit> get_Function();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal string get_DescriptionAsString();
    internal Target get_AsTarget();
}
[CompilationMappingAttribute("3")]
internal interface Fake.Core.IProcessHook`1 {
    public abstract virtual IDisposable PrepareState();
    public abstract virtual StreamSpecs PrepareStreams(IDisposable , StreamSpecs );
    public abstract virtual void ProcessStarted(IDisposable , Process );
    public abstract virtual FSharpAsync`1<TRes> RetrieveResult(IDisposable , Task`1<RawProcessResult> );
}
[CompilationMappingAttribute("3")]
internal interface Fake.Core.IProcessHookImpl`2 {
    public abstract virtual TState PrepareState();
    public abstract virtual StreamSpecs PrepareStreams(TState , StreamSpecs );
    public abstract virtual void ProcessStarted(TState , Process );
    public abstract virtual FSharpAsync`1<TRes> RetrieveResult(TState , Task`1<RawProcessResult> );
}
[CompilationMappingAttribute("3")]
internal interface Fake.Core.IProcessStarter {
    public abstract virtual FSharpAsync`1<Task`1<RawProcessResult>> Start(RawCreateProcess );
}
[CompilationMappingAttribute("3")]
internal interface Fake.Core.IRawProcessHook {
    public abstract virtual StreamSpecs Prepare(StreamSpecs );
    public abstract virtual void OnStart(Process );
}
[CompilationMappingAttribute("3")]
public interface Fake.Core.ITraceListener {
    public abstract virtual void Write(TraceData );
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.Kernel32 : object {
    internal static UInt32 QueryFullProcessImageName(IntPtr hProcess, UInt32 flags, StringBuilder text, UInt32& size);
    internal static string getPathToApp(Process proc);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Fake.Core.KnownTags : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTask { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTarget { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFinalTarget { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFailureTarget { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCompilation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTestSuite { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOther { get; }
    public string Name { get; }
    public string Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal KnownTags(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static KnownTags NewTask(string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTask();
    [CompilationMappingAttribute("8", "1")]
public static KnownTags NewTarget(string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTarget();
    [CompilationMappingAttribute("8", "2")]
public static KnownTags NewFinalTarget(string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFinalTarget();
    [CompilationMappingAttribute("8", "3")]
public static KnownTags NewFailureTarget(string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFailureTarget();
    [CompilationMappingAttribute("8", "4")]
public static KnownTags NewCompilation(string _compiler);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCompilation();
    [CompilationMappingAttribute("8", "5")]
public static KnownTags NewTestSuite(string _suiteName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTestSuite();
    [CompilationMappingAttribute("8", "6")]
public static KnownTags NewTest(string _testName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTest();
    [CompilationMappingAttribute("8", "7")]
public static KnownTags NewOther(string _typeDef, string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOther();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(KnownTags obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_Name();
    public string get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(KnownTags obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.Mono : object {
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpOption`1<string>, FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>>> patternInput@6-7 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>> monoVersion { get; }
    [CompilationMappingAttribute("9")]
public static FSharpOption`1<string> monoPath { get; }
    internal static Tuple`2<FSharpOption`1<string>, FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>>> get_patternInput@6-7();
    public static FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>> get_monoVersion();
    public static FSharpOption`1<string> get_monoPath();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.Core.NunitDataVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NunitDataVersion _unique_Nunit;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NunitDataVersion _unique_Nunit3;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NunitDataVersion Nunit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNunit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NunitDataVersion Nunit3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNunit3 { get; }
    private static NunitDataVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NunitDataVersion(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static NunitDataVersion get_Nunit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNunit();
    [CompilationMappingAttribute("8", "1")]
public static NunitDataVersion get_Nunit3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNunit3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NunitDataVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NunitDataVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CustomEqualityAttribute]
[CustomComparisonAttribute]
[CompilationMappingAttribute("2")]
public class Fake.Core.PreRelease : object {
    [DebuggerBrowsableAttribute("0")]
internal string Origin@;
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<PreReleaseSegment> Values@;
    [CompilationMappingAttribute("4", "0")]
public string Origin { get; }
    [CompilationMappingAttribute("4", "1")]
public string Name { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpList`1<PreReleaseSegment> Values { get; }
    public PreRelease(string origin, string name, FSharpList`1<PreReleaseSegment> values);
    public string get_Origin();
    public string get_Name();
    public FSharpList`1<PreReleaseSegment> get_Values();
    public static FSharpOption`1<PreRelease> TryParse(string str);
    public bool Equals(PreRelease y);
    public virtual bool Equals(object yobj);
    public virtual string ToString();
    public virtual int GetHashCode();
    public int CompareTo(PreRelease yobj);
    private virtual override int System-IComparable-CompareTo(object yobj);
}
[CustomEqualityAttribute]
[CustomComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Fake.Core.PreReleaseSegment : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAlphaNumeric { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNumeric { get; }
    [CompilationMappingAttribute("8", "0")]
public static PreReleaseSegment NewAlphaNumeric(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAlphaNumeric();
    [CompilationMappingAttribute("8", "1")]
public static PreReleaseSegment NewNumeric(BigInteger item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNumeric();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public int CompareTo(PreReleaseSegment y);
    public virtual int GetHashCode();
    public bool Equals(PreReleaseSegment y);
    public virtual bool Equals(object yobj);
    private virtual override int System-IComparable-CompareTo(object yobj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.Proc : object {
    public static Task`1<AsyncProcessResult`1<a>> startRaw(CreateProcess`1<a> c);
    public static AsyncProcessResult`1<a> startRawSync(CreateProcess`1<a> c);
    public static Task`1<a> start(CreateProcess`1<a> c);
    public static FSharpAsync`1<a> startAndAwait(CreateProcess`1<a> c);
    public static a run(CreateProcess`1<a> c);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.Process : object {
    internal static string startedProcessesVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<ProcessList>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<ProcessList, Unit>> patternInput@307-3 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ProcessList, Unit> setStartedProcesses { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, FSharpOption`1<ProcessList>> getStartedProcesses { get; }
    internal static string redirectOutputToTraceVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<bool>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<bool, Unit>> patternInput@349-4 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, FSharpOption`1<bool>> tryGetRedirectOutputToTrace { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<bool, Unit> setRedirectOutputToTrace { get; }
    internal static string enableProcessTracingVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<bool>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<bool, Unit>> patternInput@362-5 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<bool, Unit> setEnableProcessTracing { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> removeEnableProcessTracing { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, FSharpOption`1<bool>> getEnableProcessTracing { get; }
    [CompilationMappingAttribute("9")]
public static bool AlwaysSetProcessEncoding { get; public set; }
    [CompilationMappingAttribute("9")]
public static Encoding ProcessEncoding { get; public set; }
    [CompilationMappingAttribute("9")]
internal static IProcessStarter processStarter { get; }
    public static string defaultEnvVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpOption`1<string>, FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>>> patternInput@908-6 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> matchValue@909-1 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>> monoVersion { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> monoPath { get; }
    public static void kill(Process proc);
    [CompilerGeneratedAttribute]
internal static void action@1-7(ProcessList this, FSharpRef`1<bool> traced, Process[] processList, Unit _arg1);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_startedProcessesVar();
    internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<ProcessList>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<ProcessList, Unit>> get_patternInput@307-3();
    internal static FSharpFunc`2<ProcessList, Unit> get_setStartedProcesses();
    internal static FSharpFunc`2<Unit, FSharpOption`1<ProcessList>> get_getStartedProcesses();
    internal static FSharpOption`1<a> doWithProcessList(FSharpFunc`2<ProcessList, a> f);
    internal static void addStartedProcess(int id, DateTime startTime);
    public static void setKillCreatedProcesses(bool enable);
    public static bool shouldKillCreatedProcesses();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_redirectOutputToTraceVar();
    internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<bool>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<bool, Unit>> get_patternInput@349-4();
    internal static FSharpFunc`2<Unit, FSharpOption`1<bool>> get_tryGetRedirectOutputToTrace();
    public static FSharpFunc`2<bool, Unit> get_setRedirectOutputToTrace();
    public static bool getRedirectOutputToTrace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_enableProcessTracingVar();
    internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<bool>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<bool, Unit>> get_patternInput@362-5();
    public static FSharpFunc`2<bool, Unit> get_setEnableProcessTracing();
    internal static FSharpFunc`2<Unit, Unit> get_removeEnableProcessTracing();
    internal static FSharpFunc`2<Unit, FSharpOption`1<bool>> get_getEnableProcessTracing();
    public static bool shouldEnableProcessTracing();
    public static bool get_AlwaysSetProcessEncoding();
    public static void set_AlwaysSetProcessEncoding(bool value);
    public static Encoding get_ProcessEncoding();
    public static void set_ProcessEncoding(Encoding value);
    internal static void recordProcess(Process proc);
    internal static void rawStartProcessNoRecord(Process proc);
    internal static void rawStartProcess(Process proc);
    internal static IProcessStarter get_processStarter();
    [ObsoleteAttribute("Do not use. If you have to use this, open an issue and explain why.")]
public static bool startProcess(Process proc);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_defaultEnvVar();
    public static FSharpMap`2<string, string> createEnvironmentMap();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a setRedirectOutput(bool shouldRedirect, a startInfo);
    public static a redirectOutput(a startInfo);
    public static a disableRedirectOutput(a startInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a setEnvironment(FSharpMap`2<string, string> map, a startInfo);
    public static ProcStartInfo disableShellExecute(ProcStartInfo startInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a setEnvironmentVariable(string envKey, string envVar, a startInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> getEnvironmentVariable(string envKey, a startInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a removeEnvironmentVariable(string envKey, a startInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a setEnvironmentVariables(IEnumerable`1<Tuple`2<string, string>> vars, a startInfo);
    public static a setCurrentEnvironmentVariables(a startInfo);
    internal static CreateProcess`1<ProcessResult`1<Unit>> getProcI(FSharpFunc`2<ProcStartInfo, ProcStartInfo> config);
    [ObsoleteAttribute("use the CreateProcess APIs instead.")]
public static Process getProc(FSharpFunc`2<ProcStartInfo, ProcStartInfo> config);
    [ObsoleteAttribute("use the CreateProcess APIs instead.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int execRaw(FSharpFunc`2<ProcStartInfo, ProcStartInfo> configProcessStartInfoF, TimeSpan timeOut, bool silent, FSharpFunc`2<string, Unit> errorF, FSharpFunc`2<string, Unit> messageF);
    internal static FSharpFunc`2<string, Unit> appendMessage@614(FSharpRef`1<FSharpList`1<ConsoleMessage>> messages, bool isError);
    [ObsoleteAttribute("use the CreateProcess APIs instead.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcessResult execWithResult(FSharpFunc`2<ProcStartInfo, ProcStartInfo> configProcessStartInfoF, TimeSpan timeOut);
    [ObsoleteAttribute("use the CreateProcess APIs instead.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int execSimple(FSharpFunc`2<ProcStartInfo, ProcStartInfo> configProcessStartInfoF, TimeSpan timeOut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int myExecElevated(string cmd, string args, TimeSpan timeout);
    [ObsoleteAttribute("This is currently not possible in dotnetcore")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int execElevated(string cmd, string args, TimeSpan timeOut);
    [ObsoleteAttribute("use the CreateProcess APIs instead.")]
public static void fireAndForget(FSharpFunc`2<ProcStartInfo, ProcStartInfo> configProcessStartInfoF);
    [ObsoleteAttribute("use the CreateProcess APIs instead.")]
public static bool directExec(FSharpFunc`2<ProcStartInfo, ProcStartInfo> configProcessStartInfoF);
    [ObsoleteAttribute("use the CreateProcess APIs instead.")]
public static void start(FSharpFunc`2<ProcStartInfo, ProcStartInfo> configProcessStartInfoF);
    [ObsoleteAttribute("Use the Arguments and Args modules/types instead")]
public static string quote(string str);
    [ObsoleteAttribute("Use the Arguments and Args modules/types instead")]
public static string quoteIfNeeded(string str);
    [ObsoleteAttribute("Use the Arguments and Args modules/types instead")]
public static string toParam(string x);
    [ObsoleteAttribute("Use 'id' instead")]
public static FSharpFunc`2<a, a> UseDefaults();
    [ObsoleteAttribute("Use the Arguments.appendNotEmpty and the Args modules/types instead.")]
public static FSharpOption`1<Tuple`2<a, string>> stringParam(a paramName, string paramValue);
    [ObsoleteAttribute("Use the Arguments and Args modules/types instead")]
public static FSharpFunc`2<IEnumerable`1<string>, FSharpList`1<FSharpOption`1<Tuple`2<a, string>>>> multipleStringParams(a paramName);
    [ObsoleteAttribute("Use the Arguments.appendOption and Args modules/types instead")]
public static FSharpOption`1<Tuple`2<a, string>> optionParam(a paramName, FSharpOption`1<b> paramValue);
    [ObsoleteAttribute("Use the Arguments.appendIf and Args modules/types instead")]
public static FSharpOption`1<Tuple`2<a, b>> boolParam(a paramName, bool paramValue);
    [ObsoleteAttribute("Use the Arguments and Args modules/types instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string parametersToString(string flagPrefix, string delimiter, IEnumerable`1<FSharpOption`1<Tuple`2<string, string>>> parameters);
    [ObsoleteAttribute("Use ProcessUtils.findFiles instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> findFiles(IEnumerable`1<string> dirs, string file);
    [ObsoleteAttribute("Use ProcessUtils.tryFindFile instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindFile(IEnumerable`1<string> dirs, string file);
    [ObsoleteAttribute("Use ProcessUtils.findFile instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findFile(IEnumerable`1<string> dirs, string file);
    [ObsoleteAttribute("Use ProcessUtils.findFilesOnPath instead")]
public static IEnumerable`1<string> findFilesOnPath(string file);
    [ObsoleteAttribute("Use ProcessUtils.tryFindFileOnPath instead")]
public static FSharpOption`1<string> tryFindFileOnPath(string file);
    [ObsoleteAttribute("This is no longer supported on dotnetcore.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] appSettings(string key, string fallbackValue);
    [ObsoleteAttribute("Use ProcessUtils.tryFindTool instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindTool(string envVar, string tool);
    [ObsoleteAttribute("Use ProcessUtils.tryFindPath instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindPath(string settingsName, string fallbackValue, string tool);
    [ObsoleteAttribute("Use ProcessUtils.findPath instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findPath(string settingsName, string fallbackValue, string tool);
    internal static string delimit@799(string str);
    internal static string formatArgs(IEnumerable`1<Tuple`2<string, string>> args);
    [ObsoleteAttribute("use the CreateProcess APIs instead.")]
public static FSharpAsync`1<int> asyncShellExec(ExecParams args);
    public static void killById(int id);
    [ObsoleteAttribute("use Process.killById instead.")]
public static void killProcessById(int id);
    public static string getFileName(Process p);
    public static IEnumerable`1<Process> getAllByName(string name);
    [ObsoleteAttribute("use Process.getAllByName instead.")]
public static IEnumerable`1<Process> getProcessesByName(string name);
    public static void killAllByName(string name);
    [ObsoleteAttribute("use Process.killAllByName instead.")]
public static void killProcess(string name);
    public static void killFSI();
    public static void killMSBuild();
    public static void killAllCreatedProcesses();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureProcessesHaveStopped(string name, TimeSpan timeout);
    public static int shellExec(ExecParams args);
    internal static Tuple`2<FSharpOption`1<string>, FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>>> get_patternInput@908-6();
    internal static FSharpOption`1<string> get_matchValue@909-1();
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpOption`1<string>, FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>>> patternInput$cont@911(Unit unitVar);
    public static FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>> get_monoVersion();
    internal static FSharpOption`1<string> get_monoPath();
    public static ProcStartInfo withFramework(ProcStartInfo proc);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.ProcessHelpers.Async : object {
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<b> func2@1-3(b arg00);
    internal static FSharpFunc`2<a, FSharpAsync`1<b>> lift(FSharpFunc`2<a, b> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<b> bind(FSharpFunc`2<a, FSharpAsync`1<b>> f, FSharpAsync`1<a> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<b> map(FSharpFunc`2<a, b> f, FSharpAsync`1<a> a);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Fake.Core.ProcessHelpers.AsyncExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationCanceledException getCancelledException(Task completedTask, FSharpFunc`2<Unit, Unit> waitWithAwaiter);
    internal static FSharpAsync`1<a> startCatchCancellation(FSharpAsync`1<a> work, FSharpOption`1<CancellationToken> cancellationToken);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Task`1<a> startAsTaskHelper(FSharpFunc`2<FSharpAsync`1<Unit>, Unit> start, FSharpAsync`1<a> computation, FSharpOption`1<CancellationToken> cancellationToken, FSharpOption`1<TaskCreationOptions> taskCreationOptions);
    internal static FSharpAsync`1<a> Async.StartCatchCancellation.Static(FSharpAsync`1<a> work, FSharpOption`1<CancellationToken> cancellationToken);
    internal static Task`1<a> Async.StartAsTaskProperCancel.Static(FSharpAsync`1<a> computation, FSharpOption`1<TaskCreationOptions> taskCreationOptions, FSharpOption`1<CancellationToken> cancellationToken);
    internal static Task`1<a> Async.StartImmediateAsTask.Static(FSharpAsync`1<a> computation, FSharpOption`1<TaskCreationOptions> taskCreationOptions, FSharpOption`1<CancellationToken> cancellationToken);
    internal static void continuation@74(FSharpFunc`2<T, Unit> cont, FSharpFunc`2<Exception, Unit> econt, Task`1<T> completedTask);
    internal static FSharpAsync`1<T> Async.AwaitTaskWithoutAggregate.Static(Task`1<T> task);
    internal static void continuation@89-1(FSharpFunc`2<Unit, Unit> cont, FSharpFunc`2<Exception, Unit> econt, Task completedTask);
    internal static FSharpAsync`1<Unit> Async.AwaitTaskWithoutAggregate.Static(Task task);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<R> AsyncBuilder.Bind(FSharpAsyncBuilder x, Task`1<T> t, FSharpFunc`2<T, FSharpAsync`1<R>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<R> AsyncBuilder.Bind(FSharpAsyncBuilder x, Task t, FSharpFunc`2<Unit, FSharpAsync`1<R>> f);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.ProcessHelpers.Event : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEvent`2<FSharpHandler`1<Args>, Args> guard(FSharpFunc`2<Unit, Unit> f, IEvent`2<Del, Args> e);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.ProcessHook : object {
    internal static IProcessHook`1<TRes> toRawHook(IProcessHookImpl`2<TState, TRes> h);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.ProcessOutput : object {
    [DebuggerBrowsableAttribute("0")]
internal string Output@;
    [DebuggerBrowsableAttribute("0")]
internal string Error@;
    [CompilationMappingAttribute("4", "0")]
public string Output { get; }
    [CompilationMappingAttribute("4", "1")]
public string Error { get; }
    public ProcessOutput(string output, string error);
    public string get_Output();
    public string get_Error();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ProcessOutput obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProcessOutput obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.ProcessResult : object {
    [DebuggerBrowsableAttribute("0")]
internal int ExitCode@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<ConsoleMessage> Results@;
    [CompilationMappingAttribute("4", "0")]
public int ExitCode { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<ConsoleMessage> Results { get; }
    public bool OK { get; }
    internal string ReportString { get; }
    public FSharpList`1<string> Messages { get; }
    public FSharpList`1<string> Errors { get; }
    public ProcessResult(int exitCode, FSharpList`1<ConsoleMessage> results);
    public int get_ExitCode();
    public FSharpList`1<ConsoleMessage> get_Results();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ProcessResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool get_OK();
    internal string get_ReportString();
    public FSharpList`1<string> get_Messages();
    public FSharpList`1<string> get_Errors();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcessResult New(int exitCode, FSharpList`1<ConsoleMessage> results);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProcessResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.ProcessResult`1 : object {
    [DebuggerBrowsableAttribute("0")]
internal a Result@;
    [DebuggerBrowsableAttribute("0")]
internal int ExitCode@;
    [CompilationMappingAttribute("4", "0")]
public a Result { get; }
    [CompilationMappingAttribute("4", "1")]
public int ExitCode { get; }
    public ProcessResult`1(a result, int exitCode);
    public a get_Result();
    public int get_ExitCode();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ProcessResult`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProcessResult`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.ProcessUtils : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<string> findFilesInternal(IEnumerable`1<string> dirs, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> findFiles(IEnumerable`1<string> dirs, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindFile(IEnumerable`1<string> dirs, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findFile(IEnumerable`1<string> dirs, string file);
    public static IEnumerable`1<string> findFilesOnPath(string file);
    public static FSharpOption`1<string> tryFindFileOnPath(string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindTool(string envVar, string tool);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindPath(IEnumerable`1<string> fallbackValue, string tool);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findPath(IEnumerable`1<string> fallbackValue, string tool);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.ProcStartInfo : object {
    [DebuggerBrowsableAttribute("0")]
internal string Arguments@;
    [DebuggerBrowsableAttribute("0")]
internal bool CreateNoWindow@;
    [DebuggerBrowsableAttribute("0")]
internal string Domain@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<string, string> Environment@;
    [DebuggerBrowsableAttribute("0")]
internal bool ErrorDialog@;
    [DebuggerBrowsableAttribute("0")]
internal IntPtr ErrorDialogParentHandle@;
    [DebuggerBrowsableAttribute("0")]
internal string FileName@;
    [DebuggerBrowsableAttribute("0")]
internal bool LoadUserProfile@;
    [DebuggerBrowsableAttribute("0")]
internal string Password@;
    [DebuggerBrowsableAttribute("0")]
internal ProcessWindowStyle WindowStyle@;
    [DebuggerBrowsableAttribute("0")]
internal bool RedirectStandardError@;
    [DebuggerBrowsableAttribute("0")]
internal bool RedirectStandardInput@;
    [DebuggerBrowsableAttribute("0")]
internal bool RedirectStandardOutput@;
    [DebuggerBrowsableAttribute("0")]
internal Encoding StandardErrorEncoding@;
    [DebuggerBrowsableAttribute("0")]
internal Encoding StandardOutputEncoding@;
    [DebuggerBrowsableAttribute("0")]
internal string UserName@;
    [DebuggerBrowsableAttribute("0")]
internal bool UseShellExecute@;
    [DebuggerBrowsableAttribute("0")]
internal string Verb@;
    [DebuggerBrowsableAttribute("0")]
internal string WorkingDirectory@;
    [CompilationMappingAttribute("4", "0")]
public string Arguments { get; }
    [CompilationMappingAttribute("4", "1")]
public bool CreateNoWindow { get; }
    [CompilationMappingAttribute("4", "2")]
public string Domain { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpMap`2<string, string> Environment { get; }
    [CompilationMappingAttribute("4", "4")]
public bool ErrorDialog { get; }
    [CompilationMappingAttribute("4", "5")]
public IntPtr ErrorDialogParentHandle { get; }
    [CompilationMappingAttribute("4", "6")]
public string FileName { get; }
    [CompilationMappingAttribute("4", "7")]
public bool LoadUserProfile { get; }
    [CompilationMappingAttribute("4", "8")]
public string Password { get; }
    [CompilationMappingAttribute("4", "9")]
public ProcessWindowStyle WindowStyle { get; }
    [CompilationMappingAttribute("4", "10")]
public bool RedirectStandardError { get; }
    [CompilationMappingAttribute("4", "11")]
public bool RedirectStandardInput { get; }
    [CompilationMappingAttribute("4", "12")]
public bool RedirectStandardOutput { get; }
    [CompilationMappingAttribute("4", "13")]
public Encoding StandardErrorEncoding { get; }
    [CompilationMappingAttribute("4", "14")]
public Encoding StandardOutputEncoding { get; }
    [CompilationMappingAttribute("4", "15")]
public string UserName { get; }
    [CompilationMappingAttribute("4", "16")]
public bool UseShellExecute { get; }
    [CompilationMappingAttribute("4", "17")]
public string Verb { get; }
    [CompilationMappingAttribute("4", "18")]
public string WorkingDirectory { get; }
    [ObsoleteAttribute("Please use 'Create()' instead and make sure to properly set Environment via Process-module funtions!")]
public static ProcStartInfo Empty { get; }
    public ProcessStartInfo AsStartInfo { get; }
    public ProcStartInfo(string arguments, bool createNoWindow, string domain, FSharpMap`2<string, string> environment, bool errorDialog, IntPtr errorDialogParentHandle, string fileName, bool loadUserProfile, string password, ProcessWindowStyle windowStyle, bool redirectStandardError, bool redirectStandardInput, bool redirectStandardOutput, Encoding standardErrorEncoding, Encoding standardOutputEncoding, string userName, bool useShellExecute, string verb, string workingDirectory);
    public string get_Arguments();
    public bool get_CreateNoWindow();
    public string get_Domain();
    public FSharpMap`2<string, string> get_Environment();
    public bool get_ErrorDialog();
    public IntPtr get_ErrorDialogParentHandle();
    public string get_FileName();
    public bool get_LoadUserProfile();
    public string get_Password();
    public ProcessWindowStyle get_WindowStyle();
    public bool get_RedirectStandardError();
    public bool get_RedirectStandardInput();
    public bool get_RedirectStandardOutput();
    public Encoding get_StandardErrorEncoding();
    public Encoding get_StandardOutputEncoding();
    public string get_UserName();
    public bool get_UseShellExecute();
    public string get_Verb();
    public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static ProcStartInfo Create();
    public static ProcStartInfo get_Empty();
    public ProcStartInfo WithEnvironment(FSharpMap`2<string, string> map);
    public ProcessStartInfo get_AsStartInfo();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProcStartInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.ProcStartInfoData : object {
    internal static string defaultEnvVar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_defaultEnvVar();
    internal static FSharpMap`2<string, string> createEnvironmentMap();
    internal static void checkMap(FSharpMap`2<string, string> map);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.ProcStartInfoExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithArguments(ProcStartInfo x, string args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithCreateNoWindow(ProcStartInfo x, bool noWindow);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithDomain(ProcStartInfo x, string domain);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithoutEnvironment(ProcStartInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithEnvironmentVariable(ProcStartInfo x, string envKey, string envVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithRemovedEnvironmentVariable(ProcStartInfo x, string envKey);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithEnvironmentVariables(ProcStartInfo x, IEnumerable`1<Tuple`2<string, string>> vars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithCurrentEnvironmentVariables(ProcStartInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithErrorDialog(ProcStartInfo x, bool errorDialog);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithErrorDialogParentHandle(ProcStartInfo x, IntPtr handle);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithFileName(ProcStartInfo x, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithLoadUserProfile(ProcStartInfo x, bool userProfile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithPassword(ProcStartInfo x, string password);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithWindowStyle(ProcStartInfo x, ProcessWindowStyle style);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithRedirectStandardError(ProcStartInfo x, bool redirectStdErr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithRedirectStandardInput(ProcStartInfo x, bool redirectStdInput);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithRedirectStandardOutput(ProcStartInfo x, bool redirectStdOutput);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithStandardErrorEncoding(ProcStartInfo x, Encoding encoding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithStandardOutputEncoding(ProcStartInfo x, Encoding encoding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithUserName(ProcStartInfo x, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithUseShellExecute(ProcStartInfo x, bool shellExec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithVerb(ProcStartInfo x, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcStartInfo ProcStartInfo.WithWorkingDirectory(ProcStartInfo x, string dir);
}
[CompilationMappingAttribute("34")]
internal class Fake.Core.RawCreateProcess : object {
    [DebuggerBrowsableAttribute("0")]
internal Command Command@;
    [DebuggerBrowsableAttribute("0")]
internal bool TraceCommand@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> WorkingDirectory@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<IImmutableDictionary`2<string, string>> Environment@;
    [DebuggerBrowsableAttribute("0")]
internal StreamSpecs Streams@;
    [DebuggerBrowsableAttribute("0")]
internal IRawProcessHook OutputHook@;
    [CompilationMappingAttribute("4", "0")]
internal Command Command { get; }
    [CompilationMappingAttribute("4", "1")]
internal bool TraceCommand { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpOption`1<string> WorkingDirectory { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpOption`1<IImmutableDictionary`2<string, string>> Environment { get; }
    [CompilationMappingAttribute("4", "4")]
internal StreamSpecs Streams { get; }
    [CompilationMappingAttribute("4", "5")]
internal IRawProcessHook OutputHook { get; }
    internal ProcessStartInfo ToStartInfo { get; }
    internal string CommandLine { get; }
    internal RawCreateProcess(Command command, bool traceCommand, FSharpOption`1<string> workingDirectory, FSharpOption`1<IImmutableDictionary`2<string, string>> environment, StreamSpecs streams, IRawProcessHook outputHook);
    internal Command get_Command();
    internal bool get_TraceCommand();
    internal FSharpOption`1<string> get_WorkingDirectory();
    internal FSharpOption`1<IImmutableDictionary`2<string, string>> get_Environment();
    internal StreamSpecs get_Streams();
    internal IRawProcessHook get_OutputHook();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal ProcessStartInfo get_ToStartInfo();
    internal string get_CommandLine();
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.RawProc : object {
    internal static bool setEcho(bool b);
    internal static FSharpAsync`1<Stream> handleStream@198(CancellationTokenSource tok, StreamSpecification parameter, Stream processStream, bool isInputStream);
    internal static void start@188-4(FSharpFunc`2<RawCreateProcess, FSharpFunc`2<Process, Unit>> startProcessRaw, RawCreateProcess c, ProcessStartInfo p, StreamSpecs streamSpec, Process toolProcess, CancellationTokenSource tok, FSharpRef`1<bool> isStarted, FSharpRef`1<Task`1<Stream>> readOutputTask, FSharpRef`1<Task`1<Stream>> readErrorTask, FSharpRef`1<Task`1<Stream>> redirectStdInTask, Unit unitVar0);
    internal static FSharpAsync`1<bool> tryWait@260(Task`1<Stream[]> all, Unit unitVar0);
    internal static IProcessStarter createProcessStarter(FSharpFunc`2<RawCreateProcess, FSharpFunc`2<Process, Unit>> startProcessRaw);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.RawProcessResult : object {
    [DebuggerBrowsableAttribute("0")]
internal int RawExitCode@;
    [CompilationMappingAttribute("4", "0")]
public int RawExitCode { get; }
    public RawProcessResult(int rawExitCode);
    public int get_RawExitCode();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(RawProcessResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RawProcessResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.ReleaseNotes : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Tuple`2<Match, Match>> parseVersions { get; }
    [CompilationMappingAttribute("9")]
internal static Regex nugetRegex@68 { get; }
    [CompilationMappingAttribute("9")]
internal static Regex assemblyVersionRegex@69 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, FSharpOption`1<DateTime>> parseDate { get; }
    [CompilationMappingAttribute("9")]
internal static Regex dateRegex@81 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-24(ReleaseNotes this, ReleaseNotes obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-25(IComparer comp, ReleaseNotes this, ReleaseNotes objTemp, Unit unitVar);
    internal static FSharpFunc`2<string, Tuple`2<Match, Match>> get_parseVersions();
    internal static Regex get_nugetRegex@68();
    internal static Regex get_assemblyVersionRegex@69();
    internal static FSharpFunc`2<string, FSharpOption`1<DateTime>> get_parseDate();
    internal static Regex get_dateRegex@81();
    [CompilerGeneratedAttribute]
internal static string func2@1-1(string x);
    internal static ReleaseNotes parseSimple(string line);
    internal static Tuple`2<FSharpList`1<string>, FSharpList`1<string>> findEnd@111(FSharpList`1<string> notes, FSharpList`1<string> text);
    internal static FSharpOption`1<Tuple`2<string, Tuple`2<FSharpList`1<string>, FSharpList`1<string>>>> findNextNotesBlock@109(FSharpList`1<string> text);
    internal static FSharpList`1<ReleaseNotes> loop@120(FSharpList`1<ReleaseNotes> releaseNotes, FSharpList`1<string> text);
    internal static FSharpList`1<ReleaseNotes> parseAllComplex(IEnumerable`1<string> text);
    [CompilerGeneratedAttribute]
internal static bool func1@1-2(string value);
    internal static FSharpChoice`3<Unit, Unit, Unit> |Simple|Complex|Invalid|@144(char _arg1);
    public static FSharpList`1<ReleaseNotes> parseAll(IEnumerable`1<string> data);
    public static ReleaseNotes parse(IEnumerable`1<string> data);
    public static ReleaseNotes load(string fileName);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.SemVer : object {
    [CompilationMappingAttribute("9")]
internal static Regex validContent { get; }
    public static bool isValid(string version);
    internal static FSharpOption`1<int> |Int|_|(string str);
    internal static FSharpOption`1<BigInteger> |Big|_|(string str);
    [CompilerGeneratedAttribute]
internal static bool contains@1(a e, FSharpList`1<a> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> expand(FSharpList`1<char> delimiter, string text);
    internal static Regex get_validContent();
    [CompilerGeneratedAttribute]
internal static Tuple`5<int, int, int, BigInteger, FSharpList`1<string>> parse$cont@321-1(FSharpList`1<string> fragments, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`5<int, int, int, BigInteger, FSharpList`1<string>> parse$cont@321(FSharpList`1<string> fragments, Unit unitVar);
    public static SemVerInfo parse(string version);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.SemVerActivePattern : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<FSharpList`1<string>> |ParseRegex|_|(string pattern, string input);
    public static FSharpOption`1<FSharpList`1<string>> |SemVer|_|(string version);
    public static FSharpOption`1<Unit> |ValidVersion|_|(string _arg1);
}
[CustomEqualityAttribute]
[CustomComparisonAttribute]
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute("2")]
public class Fake.Core.SemVerInfo : object {
    [DebuggerBrowsableAttribute("0")]
internal UInt32 Major@;
    [DebuggerBrowsableAttribute("0")]
internal UInt32 Minor@;
    [DebuggerBrowsableAttribute("0")]
internal UInt32 Patch@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<PreRelease> PreRelease@;
    [DebuggerBrowsableAttribute("0")]
internal BigInteger Build@;
    [DebuggerBrowsableAttribute("0")]
internal string BuildMetaData@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Original@;
    [CompilationMappingAttribute("4", "0")]
public UInt32 Major { get; }
    [CompilationMappingAttribute("4", "1")]
public UInt32 Minor { get; }
    [CompilationMappingAttribute("4", "2")]
public UInt32 Patch { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<PreRelease> PreRelease { get; }
    [CompilationMappingAttribute("4", "4")]
public BigInteger Build { get; }
    [CompilationMappingAttribute("4", "5")]
public string BuildMetaData { get; }
    [CompilationMappingAttribute("4", "6")]
public FSharpOption`1<string> Original { get; }
    public string AsString { get; }
    public SemVerInfo(UInt32 major, UInt32 minor, UInt32 patch, FSharpOption`1<PreRelease> preRelease, BigInteger build, string buildMetaData, FSharpOption`1<string> original);
    public UInt32 get_Major();
    public UInt32 get_Minor();
    public UInt32 get_Patch();
    public FSharpOption`1<PreRelease> get_PreRelease();
    public BigInteger get_Build();
    public string get_BuildMetaData();
    public FSharpOption`1<string> get_Original();
    public string Normalize();
    public string NormalizeToShorter();
    public virtual string ToString();
    public string get_AsString();
    public bool Equals(SemVerInfo y);
    public virtual bool Equals(object yobj);
    public virtual int GetHashCode();
    public int CompareTo(SemVerInfo y);
    private virtual override int System-IComparable-CompareTo(object yobj);
}
[CompilationMappingAttribute("3")]
public class Fake.Core.Shell : object {
    internal static ExecParams GetParams(string cmd, FSharpOption`1<string> args, FSharpOption`1<string> dir);
    public static int Exec(string cmd, FSharpOption`1<string> args, FSharpOption`1<string> dir);
    public static FSharpAsync`1<int> AsyncExec(string cmd, FSharpOption`1<string> args, FSharpOption`1<string> dir);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.StreamExtensions : object {
    public static Stream Stream.CombineWrite.Static(Stream target1, Stream target2);
    public static Stream Stream.InterceptStream.Static(Stream readStream, Stream track);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Fake.Core.StreamSpecification : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static StreamSpecification _unique_Inherit;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static StreamSpecification Inherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUseStream { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCreatePipe { get; }
    private static StreamSpecification();
    [CompilationMappingAttribute("8", "0")]
public static StreamSpecification get_Inherit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInherit();
    [CompilationMappingAttribute("8", "1")]
public static StreamSpecification NewUseStream(bool _closeOnExit, Stream _stream);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUseStream();
    [CompilationMappingAttribute("8", "2")]
public static StreamSpecification NewCreatePipe(DataRef`1<Stream> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCreatePipe();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("34")]
internal class Fake.Core.StreamSpecs : object {
    [DebuggerBrowsableAttribute("0")]
internal StreamSpecification StandardInput@;
    [DebuggerBrowsableAttribute("0")]
internal StreamSpecification StandardOutput@;
    [DebuggerBrowsableAttribute("0")]
internal StreamSpecification StandardError@;
    [CompilationMappingAttribute("4", "0")]
internal StreamSpecification StandardInput { get; }
    [CompilationMappingAttribute("4", "1")]
internal StreamSpecification StandardOutput { get; }
    [CompilationMappingAttribute("4", "2")]
internal StreamSpecification StandardError { get; }
    internal StreamSpecs(StreamSpecification standardInput, StreamSpecification standardOutput, StreamSpecification standardError);
    internal StreamSpecification get_StandardInput();
    internal StreamSpecification get_StandardOutput();
    internal StreamSpecification get_StandardError();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal void SetStartInfo(ProcessStartInfo p);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.String : object {
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, bool> endsWithSlash { get; }
    [CompilationMappingAttribute("9")]
internal static char copyOfStruct@50 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, Regex> regexes { get; }
    [CompilationMappingAttribute("9")]
public static FSharpList`1<char> charsAndDigits { get; }
    public static char Colon { get; }
    public static string LinuxLineBreaks { get; }
    public static string WindowsLineBreaks { get; }
    public static string MacLineBreaks { get; }
    public static string productName();
    public static bool isNullOrEmpty(string value);
    public static bool isNotNullOrEmpty(string value);
    public static bool isNullOrWhiteSpace(string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replace(string pattern, string replacement, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string separated(string delimiter, IEnumerable`1<string> items);
    public static string trimSlash(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> split(char delimiter, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> splitStr(string delimiterStr, string text);
    public static string toLines(IEnumerable`1<string> text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool startsWith(string prefix, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool endsWith(string suffix, string text);
    public static FSharpFunc`2<string, bool> get_endsWithSlash();
    internal static char get_copyOfStruct@50();
    internal static void set_copyOfStruct@50(char value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replaceFirst(string pattern, string replacement, string text);
    internal static Dictionary`2<string, Regex> get_regexes();
    public static Regex getRegEx(string pattern);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string regex_replace(string pattern, string replacement, string text);
    public static bool isUmlaut(char c);
    public static string toLower(string s);
    public static FSharpList`1<char> get_charsAndDigits();
    public static bool isLetterOrDigit(char c);
    public static string trimSeparator(string s);
    public static string trimSpecialChars(string text);
    public static string trim(string x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string trimChars(Char[] chars, string x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string trimStartChars(Char[] chars, string x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string trimEndChars(Char[] chars, string x);
    public static FSharpOption`1<string> liftString(string x);
    public static string NormalizeVersion(string version);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static char get_Colon();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_LinuxLineBreaks();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_WindowsLineBreaks();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_MacLineBreaks();
    public static string convertTextToWindowsLineBreaks(string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void convertFileToWindowsLineBreaksWithEncoding(Encoding encoding, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void convertFileToWindowsLineBreak(Encoding encoding, string fileName);
    public static string removeLineBreaks(string text);
    public static string encapsulateApostrophe(string text);
    public static string decodeBase64Utf8String(string text);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.StringBuilder : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder append(string text, StringBuilder builder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendWithoutQuotes(string text, StringBuilder builder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendIfSome(FSharpOption`1<a> o, FSharpFunc`2<a, string> f, StringBuilder builder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendIfTrue(bool p, string s, StringBuilder builder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendIfTrueWithoutQuotes(bool p, string s, StringBuilder builder);
    public static FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>> appendIfFalse(bool p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<StringBuilder, StringBuilder> appendWithoutQuotesIfNotNull(object value, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<StringBuilder, StringBuilder> appendIfNotNull(object value, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendQuotedIfNotNull(object value, string s, StringBuilder builder);
    public static FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>> appendStringIfValueIsNotNull(a value);
    public static FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>> appendStringIfValueIsNotNullOrEmpty(string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<StringBuilder, StringBuilder> appendIfNotNullOrEmpty(string value, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendFileNamesIfNotNull(IEnumerable`1<string> fileNames, StringBuilder builder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder forEach(FSharpList`1<a> items, FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<StringBuilder, c>>> action, b text, StringBuilder builder);
    public static string toText(StringBuilder builder);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.Core.TagStatus : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TagStatus _unique_Success;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TagStatus _unique_Warning;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TagStatus _unique_Failed;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TagStatus Success { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSuccess { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TagStatus Warning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWarning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TagStatus Failed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFailed { get; }
    private static TagStatus();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TagStatus(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static TagStatus get_Success();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSuccess();
    [CompilationMappingAttribute("8", "1")]
public static TagStatus get_Warning();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWarning();
    [CompilationMappingAttribute("8", "2")]
public static TagStatus get_Failed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFailed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TagStatus obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TagStatus obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("2")]
public class Fake.Core.Target : object {
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Dependencies@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> SoftDependencies@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Description@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<TargetParameter, Unit> Function@;
    [CompilationMappingAttribute("4", "0")]
public string Name { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<string> Dependencies { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpList`1<string> SoftDependencies { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<string> Description { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpFunc`2<TargetParameter, Unit> Function { get; }
    public string DescriptionAsString { get; }
    public Target(string name, FSharpList`1<string> dependencies, FSharpList`1<string> softDependencies, FSharpOption`1<string> description, FSharpFunc`2<TargetParameter, Unit> function);
    public string get_Name();
    public FSharpList`1<string> get_Dependencies();
    public FSharpList`1<string> get_SoftDependencies();
    public FSharpOption`1<string> get_Description();
    public FSharpFunc`2<TargetParameter, Unit> get_Function();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public string get_DescriptionAsString();
}
[CompilationMappingAttribute("7")]
internal static class Fake.Core.TargetCli : object {
    internal static string targetCli { get; }
    [CompilationMappingAttribute("9")]
internal static Docopt doc { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_targetCli();
    internal static Docopt get_doc();
    internal static FSharpMap`2<string, DocoptResult> parseArgs(String[] args);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("2")]
public class Fake.Core.TargetContext : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<TargetResult> PreviousTargets@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Target> AllExecutingTargets@;
    [DebuggerBrowsableAttribute("0")]
internal string FinalTarget@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Arguments@;
    [DebuggerBrowsableAttribute("0")]
internal bool IsRunningFinalTargets@;
    [DebuggerBrowsableAttribute("0")]
internal CancellationToken CancellationToken@;
    [CompilationMappingAttribute("4", "0")]
public FSharpList`1<TargetResult> PreviousTargets { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<Target> AllExecutingTargets { get; }
    [CompilationMappingAttribute("4", "2")]
public string FinalTarget { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpList`1<string> Arguments { get; }
    [CompilationMappingAttribute("4", "4")]
public bool IsRunningFinalTargets { get; }
    [CompilationMappingAttribute("4", "5")]
public CancellationToken CancellationToken { get; }
    public bool HasError { get; }
    public FSharpList`1<Tuple`2<Exception, Target>> ErrorTargets { get; }
    public TargetContext(FSharpList`1<TargetResult> previousTargets, FSharpList`1<Target> allExecutingTargets, string finalTarget, FSharpList`1<string> arguments, bool isRunningFinalTargets, CancellationToken cancellationToken);
    public FSharpList`1<TargetResult> get_PreviousTargets();
    public FSharpList`1<Target> get_AllExecutingTargets();
    public string get_FinalTarget();
    public FSharpList`1<string> get_Arguments();
    public bool get_IsRunningFinalTargets();
    public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TargetContext Create(string ft, FSharpList`1<Target> all, FSharpList`1<string> args, CancellationToken token);
    public bool get_HasError();
    public FSharpOption`1<TargetResult> TryFindPrevious(string name);
    public FSharpOption`1<Target> TryFindTarget(string name);
    public FSharpList`1<Tuple`2<Exception, Target>> get_ErrorTargets();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.TargetModule : object {
    internal static string printStackTraceOnErrorVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<bool>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<bool, Unit>> patternInput@140-8 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<bool, Unit> setPrintStackTraceOnError { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, FSharpOption`1<bool>> getPrintStackTraceOnError { get; }
    internal static string lastDescriptionVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<string>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<string, Unit>> patternInput@146-9 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Unit> setLastDescription { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<Unit, Unit> removeLastDescription { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, FSharpOption`1<string>> getLastDescription { get; }
    internal static string collectStackVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<bool>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<bool, Unit>> patternInput@152-10 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<bool, Unit> setCollectStack { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<Unit, Unit> removeCollectStack { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, FSharpOption`1<bool>> getCollectStack { get; }
    [CompilationMappingAttribute("9")]
internal static bool isWindows { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Dictionary`2<string, InternalTarget>> getTargetDict { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Dictionary`2<string, bool>> getFinalTargets { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Dictionary`2<string, bool>> getBuildFailureTargets { get; }
    internal static string argResultsVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<ArgResults>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<ArgResults, Unit>> patternInput@985-11 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ArgResults, Unit> setArgResults { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> removeArgResults { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, FSharpOption`1<ArgResults>> privGetArgResults { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_printStackTraceOnErrorVar();
    internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<bool>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<bool, Unit>> get_patternInput@140-8();
    public static FSharpFunc`2<bool, Unit> get_setPrintStackTraceOnError();
    internal static FSharpFunc`2<Unit, FSharpOption`1<bool>> get_getPrintStackTraceOnError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_lastDescriptionVar();
    internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<string>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<string, Unit>> get_patternInput@146-9();
    public static FSharpFunc`2<string, Unit> get_setLastDescription();
    public static FSharpFunc`2<Unit, Unit> get_removeLastDescription();
    internal static FSharpFunc`2<Unit, FSharpOption`1<string>> get_getLastDescription();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_collectStackVar();
    internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<bool>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<bool, Unit>> get_patternInput@152-10();
    public static FSharpFunc`2<bool, Unit> get_setCollectStack();
    public static FSharpFunc`2<Unit, Unit> get_removeCollectStack();
    internal static FSharpFunc`2<Unit, FSharpOption`1<bool>> get_getCollectStack();
    internal static bool shouldCollectStack();
    internal static bool get_isWindows();
    internal static string getNormalizedFileName(string fileName);
    internal static DeclarationInfo getDeclaration();
    public static void description(string text);
    [ObsoleteAttribute("Use Target.description instead")]
public static void Description(string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Unit, a> getVarWithInit(string name, FSharpFunc`2<Unit, a> f);
    internal static FSharpFunc`2<Unit, Dictionary`2<string, InternalTarget>> get_getTargetDict();
    internal static FSharpFunc`2<Unit, Dictionary`2<string, bool>> get_getFinalTargets();
    internal static FSharpFunc`2<Unit, Dictionary`2<string, bool>> get_getBuildFailureTargets();
    internal static void reset();
    internal static FSharpList`1<string> getAllTargetsNames();
    internal static InternalTarget getInternal(string name);
    public static Target get(string name);
    internal static string dependencyString(Target target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TargetResult runSimpleInternal(TargetContext context, Target target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TargetContext runSimpleContextInternal(FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<string, ISafeDisposable>>> traceStart, TargetContext context, Target target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TargetResult runSimple(string name, FSharpList`1<string> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TargetResult runSimpleWithContext(string name, TargetContext ctx);
    internal static string softDependencyString(InternalTarget target);
    [ObsoleteAttribute("Use ignore instead")]
public static void DoNothing(TargetParameter _arg1);
    internal static void checkDependencies@346(FSharpFunc`2<InternalTarget, FSharpList`1<Dependency>> fGetDependencies, string targetName, HashSet`1<string> visited, InternalTarget dependentTarget);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<InternalTarget, InternalTarget> checkIfDependencyCanBeAddedCore(FSharpFunc`2<InternalTarget, FSharpList`1<Dependency>> fGetDependencies, string targetName, string dependentTargetName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<InternalTarget, InternalTarget> checkIfDependencyCanBeAdded(string targetName, string dependentTargetName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<InternalTarget, InternalTarget> checkIfSoftDependencyCanBeAdded(string targetName, string dependentTargetName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void dependencyAtFront(string targetName, string dependentTargetName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void softDependencyAtFront(string targetName, string dependentTargetName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void dependency(string targetName, string dependentTargetName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void softDependency(string targetName, string dependentTargetName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void Dependencies(string targetName, FSharpList`1<string> dependentTargetNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SoftDependencies(string targetName, FSharpList`1<string> dependentTargetNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void op_LessEqualsEquals(string x, FSharpList`1<string> ys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addTarget(InternalTarget target, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addTargetWithDependencies(FSharpList`1<Dependency> dependencies, FSharpFunc`2<TargetParameter, Unit> body, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void create(string name, FSharpFunc`2<TargetParameter, Unit> body);
    internal static TargetContext runFinalTargets(TargetContext context);
    internal static TargetContext runBuildFailureTargets(TargetContext context);
    public static void listAvailable();
    internal static string escapeJson@469(string s);
    internal static string createJsonString@484(string s);
    internal static string createDeclJson@488(DeclarationInfo decl);
    internal static FSharpFunc`2<IEnumerable`1<a>, string> joinJsonObjects@497(FSharpFunc`2<a, string> createObj);
    internal static void writeInfoFile(string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<DependencyType, a>> withDependencyType(DependencyType depType, FSharpList`1<a> targets);
    internal static FSharpList`1<string> visitDependenciesAux@527(bool repeatVisit, FSharpFunc`2<Target, a> fGetDependencies, FSharpFunc`2<Tuple`3<Target, DependencyType, int>, Unit> fVisit, HashSet`1<string> visited, FSharpList`1<string> orderedTargets, FSharpList`1<Tuple`3<int, DependencyType, string>> _arg1);
    internal static Tuple`2<HashSet`1<string>, FSharpList`1<string>> visit@525(bool repeatVisit, FSharpFunc`2<Target, a> fGetDependencies, FSharpFunc`2<Tuple`3<Target, DependencyType, int>, Unit> fVisit, string targetName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<HashSet`1<string>, FSharpList`1<string>> visitDependencies(bool repeatVisit, FSharpFunc`2<Tuple`3<Target, DependencyType, int>, Unit> fVisit, string targetName);
    internal static a appendfn@563(StringBuilder sb, PrintfFormat`4<a, Unit, string, Unit> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void printDependencyGraph(bool verbose, string target);
    internal static a appendfn@580-3(StringBuilder sb, PrintfFormat`4<a, Unit, string, Unit> fmt);
    internal static void printRunningOrder(FSharpList`1<Target[]> targetOrder);
    internal static string alignedString@603(int width, string name, b duration, string extra);
    internal static void aligned@608(int width, string name, b duration, string extra);
    internal static void alignedWarn@609(int width, string name, b duration, string extra);
    internal static void alignedError@610(int width, string name, b duration, string extra);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeTaskTimeSummary(a total, TargetContext context);
    internal static FSharpList`1<Target> visitDependenciesAux@637-1(HashSet`1<string> visited, List`1<Target> visitedTargets, FSharpList`1<string> _arg1);
    internal static FSharpList`1<Target[]> findOrder@657(HashSet`1<string> targetLeftSet, FSharpList`1<Target[]> progress, FSharpList`1<Target> targetLeft);
    internal static FSharpList`1<Target[]> determineBuildOrder(string target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TargetContext runSingleTarget(Target target, TargetContext context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void handleUserCancelEvent(CancellationTokenSource cts, ConsoleCancelEventArgs e);
    internal static FSharpFunc`2<a, Unit> captureContext@873(FSharpFunc`2<a, Unit> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TargetContext runInternal(bool singleTarget, int parallelJobs, string targetName, FSharpList`1<string> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createBuildFailure(string name, FSharpFunc`2<TargetParameter, Unit> body);
    public static void activateBuildFailure(string name);
    public static void deactivateBuildFailure(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createFinal(string name, FSharpFunc`2<TargetParameter, Unit> body);
    public static void activateFinal(string name);
    public static void deactivateFinal(string name);
    internal static BuildFailedException getBuildFailedException(TargetContext context);
    public static void updateBuildStatus(OptionalTargetContext context);
    public static void raiseIfError(OptionalTargetContext context);
    [ObsoleteAttribute("Use Target.WithContext.run instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TargetContext runAndGetContext(int parallelJobs, string targetName, FSharpList`1<string> args);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@980-30(ArgResults this, ArgResults obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@980-31(IComparer comp, ArgResults this, ArgResults objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_argResultsVar();
    internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<ArgResults>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<ArgResults, Unit>> get_patternInput@985-11();
    internal static FSharpFunc`2<ArgResults, Unit> get_setArgResults();
    internal static FSharpFunc`2<Unit, Unit> get_removeArgResults();
    internal static FSharpFunc`2<Unit, FSharpOption`1<ArgResults>> get_privGetArgResults();
    [CompilerGeneratedAttribute]
internal static ArgResults parseArgsAndSetEnvironment$cont@1028-1(FSharpMap`2<string, DocoptResult> results, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ArgResults parseArgsAndSetEnvironment$cont@1005(FSharpFunc`2<string, FSharpOption`1<Tuple`2<string, string>>> trySplitEnvArg, FSharpChoice`2<FSharpMap`2<string, DocoptResult>, DocoptException> results, Unit unitVar);
    internal static ArgResults parseArgsAndSetEnvironment();
    internal static ArgResults getArgs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpFunc`2<Unit, FSharpOption`1<TargetContext>>> getRunFunction(bool allowAdditionalArgs, FSharpOption`1<string> defaultTarget);
    internal static OptionalTargetContext runFunction(FSharpOption`1<FSharpFunc`2<Unit, FSharpOption`1<TargetContext>>> targetFunction);
    internal static a initAndProcess(FSharpFunc`2<ArgResults, a> proc);
    public static void initEnvironment();
    public static FSharpOption`1<String[]> getArguments();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void run(int parallelJobs, string targetName, FSharpList`1<string> args);
    public static void runOrDefault(string defaultTarget);
    public static void runOrDefaultWithArguments(string defaultTarget);
    public static void runOrList();
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.TargetOperators : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Dictionary`2<string, string>> sameLevels { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b op_Dynamic(FSharpFunc`2<a, b> f, a s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c op_DynamicAssignment(FSharpFunc`2<a, FSharpFunc`2<b, c>> f, a str, b action);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void op_LessEqualsEquals(string x, FSharpList`1<string> y);
    internal static FSharpFunc`2<Unit, Dictionary`2<string, string>> get_sameLevels();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void targetsAreOnSameLevel(string x, string y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addDependenciesOnSameLevel(string target, string dependency);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addSoftDependenciesOnSameLevel(string target, string dependency);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_EqualsEqualsGreater(string x, string y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_QmarkEqualsGreater(string x, string y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_LessEqualsQmark(string y, string x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_LessEqualsGreater(string x, string y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_EqualsQmarkGreater(string x, string y, bool condition);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("2")]
public class Fake.Core.TargetParameter : object {
    [DebuggerBrowsableAttribute("0")]
internal Target TargetInfo@;
    [DebuggerBrowsableAttribute("0")]
internal TargetContext Context@;
    [CompilationMappingAttribute("4", "0")]
public Target TargetInfo { get; }
    [CompilationMappingAttribute("4", "1")]
public TargetContext Context { get; }
    public TargetParameter(Target targetInfo, TargetContext context);
    public Target get_TargetInfo();
    public TargetContext get_Context();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("2")]
public class Fake.Core.TargetResult : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Exception> Error@;
    [DebuggerBrowsableAttribute("0")]
internal TimeSpan Time@;
    [DebuggerBrowsableAttribute("0")]
internal Target Target@;
    [DebuggerBrowsableAttribute("0")]
internal bool WasSkipped@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Exception> Error { get; }
    [CompilationMappingAttribute("4", "1")]
public TimeSpan Time { get; }
    [CompilationMappingAttribute("4", "2")]
public Target Target { get; }
    [CompilationMappingAttribute("4", "3")]
public bool WasSkipped { get; }
    public TargetResult(FSharpOption`1<Exception> error, TimeSpan time, Target target, bool wasSkipped);
    public FSharpOption`1<Exception> get_Error();
    public TimeSpan get_Time();
    public Target get_Target();
    public bool get_WasSkipped();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.TaskRunner : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TimeSpan waitFor(FSharpFunc`2<Unit, bool> f, TimeSpan timeout, int testMS, FSharpFunc`2<Unit, Unit> timeoutF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a runWithRetries(FSharpFunc`2<Unit, a> f, int retries);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Fake.Core.TestStatus : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIgnored { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFailed { get; }
    [CompilationMappingAttribute("8", "0")]
public static TestStatus NewIgnored(string _message);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIgnored();
    [CompilationMappingAttribute("8", "1")]
public static TestStatus NewFailed(string _message, string _details, FSharpOption`1<Tuple`2<string, string>> _expectedActual);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFailed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TestStatus obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TestStatus obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.TestStatusModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TestStatus mapMessage(FSharpFunc`2<string, string> f, TestStatus t);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.Trace : object {
    [CompilationMappingAttribute("9")]
internal static ThreadLocal`1<FSharpList`1<Tuple`2<Stopwatch, KnownTags>>> openTags { get; }
    internal static ThreadLocal`1<FSharpList`1<Tuple`2<Stopwatch, KnownTags>>> get_openTags();
    public static void log(string message);
    public static a logfn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static a logf(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static a logVerbosefn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static void trace(string message);
    public static a tracefn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static a tracef(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static void traceVerbose(string s);
    public static void traceImportant(string text);
    public static a traceImportantfn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static a traceFAKE(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static void traceError(string error);
    public static a traceErrorfn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    [CompilerGeneratedAttribute]
internal static void action@1-1(StringBuilder sb, string nl, Exception e, PropertyInfo p);
    internal static void printException@66(StringBuilder sb, string delimeter, string nl, Exception e, int count);
    public static string exceptionAndInnersToString(Exception ex);
    public static void traceException(Exception ex);
    public static void traceEnvironmentVariables();
    public static void traceLine();
    public static void traceHeader(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void openTagUnsafe(KnownTags tag, string description);
    internal static ISafeDisposable asSafeDisposable(FSharpFunc`2<TagStatus, Unit> f);
    [ObsoleteAttribute("Consider using traceTag instead and 'use' to properly call closeTag in case of exceptions. To remove this warning use 'openTagUnsafe'.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void openTag(KnownTags tag, string description);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void closeTagUnsafeEx(TagStatus status, KnownTags tag);
    public static void closeTagUnsafe(KnownTags tag);
    [ObsoleteAttribute("Consider using traceTag instead and 'use' to properly call closeTag in case of exceptions. To remove this warning use 'closeTagUnsafe'.")]
public static void closeTag(KnownTags tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ISafeDisposable traceTag(KnownTags tag, string description);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setBuildStateWithMessage(TagStatus tag, string message);
    public static void setBuildState(TagStatus tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void testStatus(string testName, TestStatus testStatus);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void testOutput(string testName, string out, string err);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void publish(ImportData typ, string path);
    public static void setBuildNumber(string number);
    public static void closeAllOpenTags();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceStartTargetUnsafe(string name, string description, string dependencyString);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceStartFinalTargetUnsafe(string name, string description, string dependencyString);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceStartFailureTargetUnsafe(string name, string description, string dependencyString);
    [ObsoleteAttribute("Consider using traceTarget instead and 'use' to properly call traceEndTask in case of exceptions. To remove this warning use 'traceStartTargetUnsafe'.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceStartTarget(string name, string description, string dependencyString);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceEndTargetUnsafeEx(TagStatus state, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceEndFinalTargetUnsafeEx(TagStatus state, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceEndFailureTargetUnsafeEx(TagStatus state, string name);
    public static void traceEndTargetUnsafe(string name);
    [ObsoleteAttribute("Consider using traceTarget instead and 'use' to properly call traceEndTask in case of exceptions. To remove this warning use 'traceEndTargetUnsafe'.")]
public static void traceEndTarget(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ISafeDisposable traceTarget(string name, string description, string dependencyString);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ISafeDisposable traceFinalTarget(string name, string description, string dependencyString);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ISafeDisposable traceFailureTarget(string name, string description, string dependencyString);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceStartTaskUnsafe(string task, string description);
    [ObsoleteAttribute("Consider using traceTask instead and 'use' to properly call traceEndTask in case of exceptions. To remove this warning use 'traceStartTaskUnsafe'.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceStartTask(string task, string description);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceEndTaskUnsafeEx(TagStatus state, string task);
    public static void traceEndTaskUnsafe(string task);
    [ObsoleteAttribute("Consider using traceTask instead and 'use' to properly call traceEndTask in case of exceptions. To remove this warning use 'traceEndTask'.")]
public static void traceEndTask(string task);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ISafeDisposable traceTask(string name, string description);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a useWith(bool automaticSuccess, FSharpFunc`2<ISafeDisposable, a> func, ISafeDisposable trace);
    public static void logToConsole(string msg, EventLogEntryType eventLogEntry);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void logItems(string message, IEnumerable`1<string> items);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class Fake.Core.TraceData : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsImportData { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBuildNumber { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsImportantMessage { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsErrorMessage { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLogMessage { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTraceMessage { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpenTag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTestStatus { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTestOutput { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCloseTag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBuildState { get; }
    public FSharpOption`1<bool> NewLine { get; }
    public FSharpOption`1<string> Message { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TraceData(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static TraceData NewImportData(ImportData _typ, string _path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsImportData();
    [CompilationMappingAttribute("8", "1")]
public static TraceData NewBuildNumber(string _text);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBuildNumber();
    [CompilationMappingAttribute("8", "2")]
public static TraceData NewImportantMessage(string _text);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsImportantMessage();
    [CompilationMappingAttribute("8", "3")]
public static TraceData NewErrorMessage(string _text);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsErrorMessage();
    [CompilationMappingAttribute("8", "4")]
public static TraceData NewLogMessage(string _text, bool _newLine);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLogMessage();
    [CompilationMappingAttribute("8", "5")]
public static TraceData NewTraceMessage(string _text, bool _newLine);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTraceMessage();
    [CompilationMappingAttribute("8", "6")]
public static TraceData NewOpenTag(KnownTags item1, FSharpOption`1<string> _description);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpenTag();
    [CompilationMappingAttribute("8", "7")]
public static TraceData NewTestStatus(string _testName, TestStatus _status);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTestStatus();
    [CompilationMappingAttribute("8", "8")]
public static TraceData NewTestOutput(string _testName, string _out, string _err);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTestOutput();
    [CompilationMappingAttribute("8", "9")]
public static TraceData NewCloseTag(KnownTags item1, TimeSpan _time, TagStatus item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCloseTag();
    [CompilationMappingAttribute("8", "10")]
public static TraceData NewBuildState(TagStatus item1, FSharpOption`1<string> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBuildState();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TraceData obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public FSharpOption`1<bool> get_NewLine();
    public FSharpOption`1<string> get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TraceData obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.TraceDataModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static KnownTags mapKnownTags(FSharpFunc`2<string, string> f, KnownTags t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TraceData mapMessage(FSharpFunc`2<string, string> f, TraceData t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string repl(string oldStr, string repl, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TraceData replace(string oldString, string replacement, TraceData t);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.Core.TraceMode : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TraceMode _unique_Console;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TraceMode _unique_Xml;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TraceMode Console { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConsole { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TraceMode Xml { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXml { get; }
    private static TraceMode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TraceMode(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static TraceMode get_Console();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConsole();
    [CompilationMappingAttribute("8", "1")]
public static TraceMode get_Xml();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXml();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TraceMode obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TraceMode obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class Fake.Core.TraceSecret : object {
    [DebuggerBrowsableAttribute("0")]
internal string Value@;
    [DebuggerBrowsableAttribute("0")]
internal string Replacement@;
    [CompilationMappingAttribute("4", "0")]
public string Value { get; }
    [CompilationMappingAttribute("4", "1")]
public string Replacement { get; }
    public TraceSecret(string value, string replacement);
    public string get_Value();
    public string get_Replacement();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TraceSecret obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TraceSecret obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.TraceSecrets : object {
    internal static string traceSecretsVar { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<FSharpList`1<TraceSecret>>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<FSharpList`1<TraceSecret>, Unit>> patternInput@316 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<FSharpList`1<TraceSecret>, Unit> setTraceSecrets { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, FSharpOption`1<FSharpList`1<TraceSecret>>> getTraceSecrets { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_traceSecretsVar();
    internal static Tuple`3<FSharpFunc`2<Unit, FSharpOption`1<FSharpList`1<TraceSecret>>>, FSharpFunc`2<Unit, Unit>, FSharpFunc`2<FSharpList`1<TraceSecret>, Unit>> get_patternInput@316();
    public static FSharpFunc`2<FSharpList`1<TraceSecret>, Unit> get_setTraceSecrets();
    internal static FSharpFunc`2<Unit, FSharpOption`1<FSharpList`1<TraceSecret>>> get_getTraceSecrets();
    public static FSharpList`1<TraceSecret> getAll();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void register(string replacement, string secret);
    public static string guardMessage(string s);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.UserInput : object {
    internal static void erasePreviousChar();
    internal static FSharpList`1<char> loop@26-21(bool echo, FSharpList`1<char> cs);
    internal static string readString(bool echo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a color(ConsoleColor color, FSharpFunc`2<Unit, a> code);
    public static string getUserInput(string prompt);
    public static string getUserPassword(string prompt);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.Vault : object {
    [CompilationMappingAttribute("9")]
public static Vault empty { get; }
    internal static void increaseCounter@28(Byte[] counter, Unit unitVar0);
    internal static void aesCtrTransform(Byte[] key, Byte[] salt, Stream inputStream, Stream outputStream);
    internal static Byte[] aesCtrTransformBytes(Byte[] key, Byte[] iv, Byte[] inputBytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string decryptVariable(KeyInfo key, string base64Val);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string encryptVariable(KeyInfo key, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vault fromEncryptedVariables(KeyInfo key, IEnumerable`1<Variable> vars);
    public static KeyInfo createKey(FSharpOption`1<string> file);
    public static Vault get_empty();
    public static Vault fromJson(string s);
    public static Vault fromEnvironmentVariable(string envVar);
    public static FSharpOption`1<Vault> fromEnvironmentVariableOrNone(string envVar);
    public static FSharpOption`1<Vault> fromFakeEnvironmentOrNone();
    public static Vault fromFakeEnvironmentVariable();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string fromVariable(KeyInfo key, Variable v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryGet(string name, Vault v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string get(string name, Vault v);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Core.VaultExt : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> Vault.TryGet(Vault x, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string Vault.Get(Vault x, string name);
}
[CompilationMappingAttribute("7")]
public static class Fake.Core.Xml : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> read(bool failOnError, string xmlFileName, string nameSpace, string prefix, string xPath);
    internal static a headOrDefault@40(a def, IEnumerable`1<a> seq);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, int> read_Int(bool failOnError, string xmlFileName, string nameSpace, string prefix, string xPath);
    public static XmlWriter getWriter(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlWriter writeComment(string comment, XmlWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlWriter startElement(string name, XmlWriter writer);
    public static XmlWriter endElement(XmlWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlWriter writeAttribute(string name, a value, XmlWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlWriter writeCDataElement(string elementName, string data, XmlWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getAttribute(string name, a node);
    public static IEnumerable`1<XmlNode> getChilds(a node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlNode getSubNode(string name, XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b parse(string name, FSharpFunc`2<a, b> f, a node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<XmlNode, a> parseSubNode(string name, FSharpFunc`2<XmlNode, a> f);
    public static XmlDocument createDoc(string text);
    public static XmlElement getDocElement(XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument replaceXPath(string xpath, string value, XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument replaceXPathInnerText(string xpath, string innerTextValue, XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument replaceXPathAttribute(string xpath, string attribute, string value, XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string selectXPathValue(string xpath, a namespaces, XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string selectXPathAttributeValue(string xpath, string attribute, a namespaces, XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlNode selectXPathNode(string xpath, a namespaces, XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void load(string fileName, XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void saveDoc(string fileName, XmlDocument doc);
    public static XmlDocument loadDoc(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void poke(string fileName, string xpath, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pokeInnerText(string fileName, string xpath, string innerTextValue);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument replaceXPathNS(string xpath, string value, a namespaces, XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument replaceXPathInnerTextNS(string xpath, string innerTextValue, a namespaces, XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pokeNS(string fileName, IEnumerable`1<Tuple`2<string, string>> namespaces, string xpath, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pokeInnerTextNS(string fileName, IEnumerable`1<Tuple`2<string, string>> namespaces, string xpath, string innerTextValue);
    [ObsoleteAttribute("This API is not yet available on netcore. If you have an alternative please switch. If the API becomes available this warning is removed.")]
public static XslCompiledTransform XslTransformer(string text);
    [ObsoleteAttribute("This API is not yet available on netcore. If you have an alternative please switch. If the API becomes available this warning is removed.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument XslTransform(XslCompiledTransform xsl, XmlDocument doc);
    [ObsoleteAttribute("This API is not yet available on netcore. If you have an alternative please switch. If the API becomes available this warning is removed.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void XmlTransform(string stylesheetUri, string fileName);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.CscHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int cscExe(string toolPath, FSharpList`1<string> srcFiles, FSharpList`1<string> opts);
    internal static string ensureTrimQuotedPath@95(string path);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int csc(FSharpFunc`2<CscParams, CscParams> setParams, FSharpList`1<string> inputFiles);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Csc(FSharpFunc`2<CscParams, CscParams> setParams, FSharpList`1<string> inputFiles);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.Documentation.DocFx module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.DocFxHelper : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.Documentation.DocFx module instead")]
[CompilationMappingAttribute("9")]
public static DocFxParams DocFxDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string toolPath@26-2 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-52 { get; }
    [CompilationMappingAttribute("9")]
internal static string docsPath@27 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-509(DocFxParams this, DocFxParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-510(IComparer comp, DocFxParams this, DocFxParams objTemp, Unit unitVar);
    public static DocFxParams get_DocFxDefaults();
    internal static string get_toolPath@26-2();
    internal static string get_path2@32-52();
    internal static string get_docsPath@27();
    [ObsoleteAttribute("FAKE0001 Use the Fake.Documentation.DocFx module instead")]
public static void DocFx(FSharpFunc`2<DocFxParams, DocFxParams> setParams);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.DocuHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static DocuParams DocuDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string toolPath@24-1 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-33 { get; }
    [CompilationMappingAttribute("9")]
internal static FileInfo fi@25 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-34 { get; }
    public static DocuParams get_DocuDefaults();
    internal static string get_toolPath@24-1();
    internal static string get_path2@32-33();
    internal static FileInfo get_fi@25();
    internal static string get_path2@32-34();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Docu(FSharpFunc`2<DocuParams, DocuParams> setParams, IEnumerable`1<string> assemblies);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Documentation.DocFx : object {
    [CompilationMappingAttribute("9")]
internal static string docFxPath { get; }
    [CompilationMappingAttribute("9")]
internal static string toolPath@16 { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-11 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-13 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-14 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<FSharpOption`1<Tuple`2<string, string>>>, string> paramsToString { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpOption`1<LogLevel>, FSharpOption`1<string>> parseLogLevel { get; }
    internal static string get_docFxPath();
    internal static string get_toolPath@16();
    internal static string get_path1@7-11();
    internal static string get_path2@7-13();
    internal static string get_path2@7-14();
    internal static FSharpFunc`2<Tuple`2<a, bool>, FSharpOption`1<Tuple`2<a, b>>> boolParam();
    internal static FSharpOption`1<Tuple`2<a, string>> stringParam(a paramName, string paramValue);
    internal static FSharpFunc`2<Tuple`2<a, FSharpOption`1<b>>, FSharpOption`1<Tuple`2<a, string>>> optionParam();
    internal static string seperated(IEnumerable`1<string> xs);
    internal static FSharpOption`1<Tuple`2<a, string>> stringListParam(a paramName, FSharpList`1<string> paramValue);
    internal static FSharpFunc`2<FSharpList`1<FSharpOption`1<Tuple`2<string, string>>>, string> get_paramsToString();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void exec(FSharpFunc`2<CommonParams, CommonParams> setParams, string command, string args);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@67-210(InitParams this, InitParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@67-211(InitParams this, InitParams objTemp, Unit unitVar);
    internal static string serializeInitParams(InitParams p);
    public static void init(FSharpFunc`2<InitParams, InitParams> setParams);
    internal static FSharpFunc`2<FSharpOption`1<LogLevel>, FSharpOption`1<string>> get_parseLogLevel();
    internal static FSharpList`1<FSharpOption`1<Tuple`2<string, string>>> parseLogParams(LogParams p);
    internal static FSharpList`1<FSharpOption`1<Tuple`2<string, string>>> parseBuildParams(BuildParams p);
    internal static string serializeBuildParams(BuildParams p);
    public static void build(FSharpFunc`2<BuildParams, BuildParams> setParams);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@406-213(PdfParams this, PdfParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@406-212(PdfParams this, PdfParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@406-215(IComparer comp, PdfParams this, PdfParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@406-214(IComparer comp, PdfParams this, PdfParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@406-87(PdfParams this, PdfParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@406-88(PdfParams this, PdfParams obj, Unit unitVar);
    internal static FSharpList`1<FSharpOption`1<Tuple`2<string, string>>> parsePdfParams(PdfParams p);
    internal static string serializePdfParams(PdfParams p);
    public static void pdf(FSharpFunc`2<PdfParams, PdfParams> setParams);
    internal static string serializeExportTemplateParams(ExportTemplateParams p);
    public static void exportTemplate(FSharpFunc`2<ExportTemplateParams, ExportTemplateParams> setParams);
    internal static string serializeDownloadParams(DownloadParams p);
    public static void download(FSharpFunc`2<DownloadParams, DownloadParams> setParams);
    internal static string serializeServeParams(ServeParams p);
    public static void serve(FSharpFunc`2<ServeParams, ServeParams> setParams);
    internal static string serializeMetadataParams(MetadataParams p);
    public static void metadata(FSharpFunc`2<MetadataParams, MetadataParams> setParams);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.DotCover : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationMappingAttribute("9")]
public static DotCoverParams DotCoverDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-44 { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationMappingAttribute("9")]
public static DotCoverMergeParams DotCoverMergeDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-45 { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationMappingAttribute("9")]
public static DotCoverReportParams DotCoverReportDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-46 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-391(DotCoverParams this, DotCoverParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-390(DotCoverParams this, DotCoverParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-393(IComparer comp, DotCoverParams this, DotCoverParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-392(IComparer comp, DotCoverParams this, DotCoverParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@23-83(IEqualityComparer comp, DotCoverParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@23-165(DotCoverParams this, DotCoverParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@23-166(DotCoverParams this, DotCoverParams obj, Unit unitVar);
    public static DotCoverParams get_DotCoverDefaults();
    internal static string get_path2@32-44();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-394(DotCoverMergeParams this, DotCoverMergeParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-395(IComparer comp, DotCoverMergeParams this, DotCoverMergeParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@51-84(IEqualityComparer comp, DotCoverMergeParams this, Unit unitVar);
    public static DotCoverMergeParams get_DotCoverMergeDefaults();
    internal static string get_path2@32-45();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@70-396(DotCoverReportParams this, DotCoverReportParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@70-397(DotCoverReportParams this, DotCoverReportParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@70-85(DotCoverReportParams this, Unit unitVar);
    public static DotCoverReportParams get_DotCoverReportDefaults();
    internal static string get_path2@32-46();
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
public static string buildDotCoverArgs(DotCoverParams parameters);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
public static string buildDotCoverMergeArgs(DotCoverMergeParams parameters);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
public static string buildDotCoverReportArgs(DotCoverReportParams parameters);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
public static string getWorkingDir(string workingDir);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void buildParamsAndExecute(a parameters, FSharpFunc`2<a, string> buildArguments, string toolPath, string workingDir, bool failBuild);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
public static void DotCover(FSharpFunc`2<DotCoverParams, DotCoverParams> setParams);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
public static void DotCoverMerge(FSharpFunc`2<DotCoverMergeParams, DotCoverMergeParams> setParams);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
public static FSharpFunc`2<bool, Unit> DotCoverReport(FSharpFunc`2<DotCoverReportParams, DotCoverReportParams> setParams);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void DotCoverNUnit(FSharpFunc`2<DotCoverParams, DotCoverParams> setDotCoverParams, FSharpFunc`2<NUnitParams, NUnitParams> setNUnitParams, IEnumerable`1<string> assemblies);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void DotCoverNUnit3(FSharpFunc`2<DotCoverParams, DotCoverParams> setDotCoverParams, FSharpFunc`2<NUnit3Params, NUnit3Params> setNUnitParams, IEnumerable`1<string> assemblies);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void DotCoverXUnit2(FSharpFunc`2<DotCoverParams, DotCoverParams> setDotCoverParams, FSharpFunc`2<XUnit2Params, XUnit2Params> setXUnit2Params, IEnumerable`1<string> assemblies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string buildMSTestArgsForDotCover(MSTestParams parameters, String[] assemblies);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void DotCoverMSTest(FSharpFunc`2<DotCoverParams, DotCoverParams> setDotCoverParams, FSharpFunc`2<MSTestParams, MSTestParams> setMSTestParams, IEnumerable`1<string> assemblies);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Testing.DotCover module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void DotCoverMSpec(FSharpFunc`2<DotCoverParams, DotCoverParams> setDotCoverParams, FSharpFunc`2<MSpecParams, MSpecParams> setMSpecParams, IEnumerable`1<string> assemblies);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.AssemblyInfo : object {
    internal static string quote(string value);
    public static Attribute StringAttributeWithStatic(string name, string value, string inNamespace, string staticName, string staticValue);
    [ObsoleteAttribute("Please use 'StringAttributeWithStatic' instead")]
public static Attribute StringAttributeEx(string name, string value, string inNamespace, string staticName, string staticValue);
    public static Attribute StringAttribute(string name, string value, string inNamespace);
    public static Attribute BoolAttribute(string name, bool value, string inNamespace);
    public static Attribute Company(string value);
    public static Attribute Product(string value);
    public static Attribute Copyright(string value);
    public static Attribute Title(string value);
    public static Attribute Description(string value);
    public static Attribute Culture(string value);
    public static Attribute Configuration(string value);
    public static Attribute Trademark(string value);
    public static Attribute Version(string value);
    public static Attribute KeyFile(string value);
    public static Attribute KeyName(string value);
    public static Attribute InternalsVisibleTo(string value);
    public static Attribute FileVersion(string value);
    public static Attribute InformationalVersion(string value);
    public static Attribute Guid(string value);
    public static Attribute ComVisible(bool value);
    public static Attribute CLSCompliant(bool value);
    public static Attribute DelaySign(bool value);
    public static Attribute Metadata(string name, string value);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.AssemblyInfoFile : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeToFile(string outputFileName, IEnumerable`1<string> lines);
    internal static FSharpList`1<string> getDependencies(IEnumerable`1<Attribute> attributes);
    internal static string getAssemblyVersionInfo(IEnumerable`1<Attribute> attributes);
    internal static string getAssemblyInformationalVersion(IEnumerable`1<Attribute> attributes);
    internal static IEnumerable`1<Tuple`3<string, string, string>> getSortedAndNumberedAttributes(IEnumerable`1<Attribute> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createCSharpWithConfig(string outputFileName, IEnumerable`1<Attribute> attributes, AssemblyInfoFileConfig config);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createFSharpWithConfig(string outputFileName, IEnumerable`1<Attribute> attributes, AssemblyInfoFileConfig config);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createVisualBasicWithConfig(string outputFileName, IEnumerable`1<Attribute> attributes, AssemblyInfoFileConfig config);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createCppCliWithConfig(string outputFileName, IEnumerable`1<Attribute> attributes, AssemblyInfoFileConfig config);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createCSharp(string outputFileName, IEnumerable`1<Attribute> attributes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createFSharp(string outputFileName, IEnumerable`1<Attribute> attributes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createVisualBasic(string outputFileName, IEnumerable`1<Attribute> attributes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createCppCli(string outputFileName, IEnumerable`1<Attribute> attributes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> |Suffix|_|(string p, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string removeAtEnd(string textToRemove, string text);
    [CompilerGeneratedAttribute]
internal static void create$cont@364(string outputFileName, IEnumerable`1<Attribute> attributes, FSharpOption`1<AssemblyInfoFileConfig> config, string matchValue_0, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void create(string outputFileName, IEnumerable`1<Attribute> attributes, FSharpOption`1<AssemblyInfoFileConfig> config);
    public static IEnumerable`1<Attribute> getAttributes(string assemblyInfoFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Attribute> getAttribute(string attrName, string assemblyInfoFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> getAttributeValue(string attrName, string assemblyInfoFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string updateAttr(FSharpFunc`2<string, string> regexFactory, RegexOptions regexOptions, string text, Attribute attribute);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void updateAttributes(string assemblyInfoFile, IEnumerable`1<Attribute> attributes);
}
[CompilationMappingAttribute("3")]
public class Fake.DotNet.AssemblyInfoFileConfig : object {
    internal FSharpOption`1<string> useNamespace;
    internal bool generateClass;
    internal FSharpOption`1<bool> emitResharperSupressions;
    public bool GenerateClass { get; }
    public string UseNamespace { get; }
    public bool EmitResharperSuppressions { get; }
    public static AssemblyInfoFileConfig Default { get; }
    public AssemblyInfoFileConfig(bool generateClass, FSharpOption`1<bool> emitResharperSupressions, FSharpOption`1<string> useNamespace);
    public bool get_GenerateClass();
    public string get_UseNamespace();
    public bool get_EmitResharperSuppressions();
    public static AssemblyInfoFileConfig get_Default();
}
[CompilationMappingAttribute("5")]
public class Fake.DotNet.BuildException : Exception {
    internal string Data0@;
    internal FSharpList`1<string> Data1@;
    [CompilationMappingAttribute("4", "0")]
public string Data0 { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<string> Data1 { get; }
    public BuildException(string data0, FSharpList`1<string> data1);
    protected BuildException(SerializationInfo info, StreamingContext context);
    public string get_Data0();
    public FSharpList`1<string> get_Data1();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.DotNet : object {
    [CompilationMappingAttribute("9")]
internal static string defaultUserInstallDir { get; }
    [CompilationMappingAttribute("9")]
internal static string defaultSystemInstallDir { get; }
    internal static string get_defaultUserInstallDir();
    internal static string get_defaultSystemInstallDir();
    internal static IEnumerable`1<FileInfo> loop@36-22(DirectoryInfo dir);
    internal static IEnumerable`1<FileInfo> globalJsonPaths@35(string rootDir);
    internal static FSharpOption`1<string> tryGetSDKVersionFromGlobalJsonDir(string startDir);
    internal static string getSDKVersionFromGlobalJsonDir(string startDir);
    public static FSharpOption`1<string> tryGetSDKVersionFromGlobalJson();
    public static string getSDKVersionFromGlobalJson();
    internal static IEnumerable`1<string> findPossibleDotnetCliPaths(FSharpOption`1<string> dotnetCliDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getGenericDotNetCliInstallerUrl(string branch, string installerName);
    internal static string getPowershellDotNetCliInstallerUrl(string branch);
    internal static string getBashDotNetCliInstallerUrl(string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void downloadDotNetInstallerFromUrl(string url, string fileName);
    internal static string md5(Byte[] data);
    public static string downloadInstaller(FSharpFunc`2<InstallerOptions, InstallerOptions> setParams);
    [ObsoleteAttribute("Please use a stable release at this point")]
public static CliInstallOptions Preview2ToolingOptions(CliInstallOptions options);
    [ObsoleteAttribute("Please use a stable release at this point")]
public static CliInstallOptions LatestPreview4ToolingOptions(CliInstallOptions options);
    [ObsoleteAttribute("Please use a stable release at this point")]
public static CliInstallOptions RC4_004771ToolingOptions(CliInstallOptions options);
    [ObsoleteAttribute("Please use a stable release at this point")]
public static CliInstallOptions RC4_004973ToolingOptions(CliInstallOptions options);
    [ObsoleteAttribute("Please use DotNet.Versions.Release_1_0_4 instead")]
public static CliInstallOptions Release_1_0_4(CliInstallOptions options);
    [ObsoleteAttribute("Please use DotNet.Versions.Release_2_0_0 instead")]
public static CliInstallOptions Release_2_0_0(CliInstallOptions options);
    [ObsoleteAttribute("Please use DotNet.Versions.Release_2_0_3 instead")]
public static CliInstallOptions Release_2_0_3(CliInstallOptions options);
    [ObsoleteAttribute("Please use DotNet.Versions.Release_2_1_4 instead")]
public static CliInstallOptions Release_2_1_4(CliInstallOptions options);
    [ObsoleteAttribute("Please use DotNet.Versions.Release_2_1_300_RC1 instead")]
public static CliInstallOptions Release_2_1_300_RC1(CliInstallOptions option);
    [ObsoleteAttribute("Please use DotNet.Versions.Release_2_1_300 instead")]
public static CliInstallOptions Release_2_1_300(CliInstallOptions option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string optionToParam(FSharpOption`1<a> option, PrintfFormat`4<FSharpFunc`2<a, string>, Unit, string, string> paramFormat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string boolToFlag(bool value, string flagParam);
    internal static Arguments buildDotNetCliInstallArgs(CliInstallOptions param);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@508-82(Options this, Options obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@508-81(Options this, Options obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@508-84(IComparer comp, Options this, Options objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@508-83(IComparer comp, Options this, Options objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@508-13(IEqualityComparer comp, Options this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@508-36(Options this, Options that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@508-37(Options this, Options obj, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> argList2(string name, FSharpList`1<string> values);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> argOption(string name, bool value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> argOptionExplicit(string name, a value);
    internal static FSharpList`1<string> buildCommonArgs(Options param);
    internal static FSharpList`1<string> buildSdkOptionsArgs(Options param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a withGlobalJson(string workDir, FSharpOption`1<string> version, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcessResult exec(FSharpFunc`2<Options, Options> buildOptions, string command, string args);
    public static InfoResult info(FSharpFunc`2<InfoOptions, InfoOptions> setParams);
    [CompilerGeneratedAttribute]
internal static Options f@796-9(FSharpMap`2<string, string> map, Options c);
    public static string getVersion(FSharpFunc`2<VersionOptions, VersionOptions> setParams);
    [CompilerGeneratedAttribute]
internal static Options f@796-10(string dotnet, Options c);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Options, Options> install$cont@874(CliInstallOptions param, string dir, bool fromGlobalJson, FSharpOption`1<string> checkVersion, Unit unitVar);
    public static FSharpFunc`2<Options, Options> install(FSharpFunc`2<CliInstallOptions, CliInstallOptions> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<a>, string> addBinaryLogger(bool disableFakeBinLog, string args, Options common);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void execWithBinLog(string project, Options common, string command, string args, CliArguments msBuildArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpChoice`2<ProcessResult, Tuple`2<Exception, ProcessResult>> tryExecWithBinLog(string project, Options common, string command, string args, CliArguments msBuildArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void msbuild(FSharpFunc`2<MSBuildOptions, MSBuildOptions> setParams, string project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpChoice`2<ProcessResult, Tuple`2<Exception, ProcessResult>> msbuildWithResult(FSharpFunc`2<MSBuildOptions, MSBuildOptions> setParams, string project);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1043-86(RestoreOptions this, RestoreOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1043-85(RestoreOptions this, RestoreOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1043-88(IComparer comp, RestoreOptions this, RestoreOptions objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1043-87(IComparer comp, RestoreOptions this, RestoreOptions objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1043-38(RestoreOptions this, RestoreOptions that, IEqualityComparer comp, Unit unitVar);
    internal static FSharpList`1<string> buildRestoreArgs(RestoreOptions param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void restore(FSharpFunc`2<RestoreOptions, RestoreOptions> setParams, string project);
    internal static FSharpList`1<string> buildConfigurationArg(BuildConfiguration param);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1153-89(PackOptions this, PackOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1153-90(IComparer comp, PackOptions this, PackOptions objTemp, Unit unitVar);
    internal static FSharpList`1<string> buildPackArgs(PackOptions param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pack(FSharpFunc`2<PackOptions, PackOptions> setParams, string project);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1226-92(PublishOptions this, PublishOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1226-91(PublishOptions this, PublishOptions obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1226-94(IComparer comp, PublishOptions this, PublishOptions objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1226-93(IComparer comp, PublishOptions this, PublishOptions objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1226-39(PublishOptions this, PublishOptions that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1226-40(PublishOptions this, PublishOptions obj, Unit unitVar);
    internal static FSharpList`1<string> buildPublishArgs(PublishOptions param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void publish(FSharpFunc`2<PublishOptions, PublishOptions> setParams, string project);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1323-95(BuildOptions this, BuildOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1323-96(IComparer comp, BuildOptions this, BuildOptions objTemp, Unit unitVar);
    internal static FSharpList`1<string> buildBuildArgs(BuildOptions param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void build(FSharpFunc`2<BuildOptions, BuildOptions> setParams, string project);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1401-98(TestOptions this, TestOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1401-97(TestOptions this, TestOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1401-100(IComparer comp, TestOptions this, TestOptions objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1401-99(IComparer comp, TestOptions this, TestOptions objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1401-41(TestOptions this, TestOptions that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1401-42(TestOptions this, TestOptions obj, Unit unitVar);
    internal static FSharpList`1<string> buildTestArgs(TestOptions param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void test(FSharpFunc`2<TestOptions, TestOptions> setParams, string project);
    internal static FSharpList`1<string> buildNugetPushArgs(NuGetPushParams param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void nugetPush(FSharpFunc`2<NuGetPushOptions, NuGetPushOptions> setParams, string nupkg);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Fsc : object {
    public static string resourceStr(string _arg1_0, FSharpOption`1<string> _arg1_1, FSharpOption`1<Access> _arg1_2);
    internal static string argp@220(string s, string p);
    internal static string sargp@222(string s, string p);
    internal static string togl@226(string s, bool b);
    internal static string stogl@228(string s, bool b);
    internal static string argls@230(string s, FSharpList`1<string> ls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] makeArgsList(FSharpList`1<string> opts, FSharpList`1<string> srcFiles);
    internal static void reportErrors(FscResultMessage[] errors);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int compileFiles(FSharpFunc`2<String[], Tuple`2<FscResultMessage[], int>> compiler, FSharpList`1<string> srcFiles, FSharpList`1<string> opts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int doCompile(FSharpFunc`2<String[], Tuple`2<FscResultMessage[], int>> compiler, FSharpList`1<FscParam> fscParams, FSharpList`1<string> inputFiles);
    [CompilerGeneratedAttribute]
internal static FscResultMessage mapping@1-6(FSharpErrorInfo e);
    internal static Tuple`2<FscResultMessage[], int> scsCompile(String[] optsArr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int compileWithResult(FSharpList`1<FscParam> fscParams, FSharpList`1<string> inputFiles);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void compile(FSharpList`1<FscParam> fscParams, FSharpList`1<string> inputFiles);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FscResultMessage[], int> extFscCompile(string fscTool, String[] optsArr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int compileExternalWithResult(string fscTool, FSharpList`1<FscParam> fscParams, FSharpList`1<string> inputFiles);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void compileExternal(string fscTool, FSharpList`1<FscParam> fscParams, FSharpList`1<string> inputFiles);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.FSFormatting : object {
    [CompilationMappingAttribute("9")]
public static string toolPath { get; public set; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-9 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-10 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-11 { get; }
    [CompilationMappingAttribute("9")]
public static LiterateArguments defaultLiterateArguments { get; }
    [CompilationMappingAttribute("9")]
public static MetadataFormatArguments defaultMetadataFormatArguments { get; }
    public static string get_toolPath();
    public static void set_toolPath(string value);
    internal static string get_path1@7-9();
    internal static string get_path2@7-10();
    internal static string get_path2@7-11();
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-16(string toolPath, string command, ProcStartInfo info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void run(string toolPath, string command);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@24-152(LiterateArguments this, LiterateArguments obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@24-153(IComparer comp, LiterateArguments this, LiterateArguments objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@24-25(IEqualityComparer comp, LiterateArguments this, Unit unitVar);
    public static LiterateArguments get_defaultLiterateArguments();
    public static void createDocs(FSharpFunc`2<LiterateArguments, LiterateArguments> p);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@63-154(MetadataFormatArguments this, MetadataFormatArguments obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@63-155(IComparer comp, MetadataFormatArguments this, MetadataFormatArguments objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@63-26(IEqualityComparer comp, MetadataFormatArguments this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@63-65(MetadataFormatArguments this, MetadataFormatArguments that, IEqualityComparer comp, Unit unitVar);
    public static MetadataFormatArguments get_defaultMetadataFormatArguments();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createDocsForDlls(FSharpFunc`2<MetadataFormatArguments, MetadataFormatArguments> p, IEnumerable`1<string> dllFiles);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Fsi : object {
    internal static string stringEmptyMap@134(FSharpFunc`2<string, string> f, string s);
    internal static string arg@138-12(string s, bool b);
    internal static string argp@140-4(string s, string p);
    internal static string sargp@142-4(string s, string p);
    internal static string togl@146-3(string s, FSharpOption`1<bool> b);
    internal static string argls@148-3(string s, FSharpList`1<string> ls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, FSharpList`1<string>> execRaw(FSharpFunc`2<FsiParams, FsiParams> fsiParams, string script, FSharpList`1<string> scriptArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<int, FSharpList`1<string>> exec(FSharpFunc`2<FsiParams, FsiParams> fsiParams, string script, FSharpList`1<string> scriptArgs);
}
[CompilationMappingAttribute("7")]
internal static class Fake.DotNet.Helper : object {
    [CompilationMappingAttribute("9")]
internal static Regex assemblyVersionRegex { get; }
    internal static string regexAttrNameValueCs { get; }
    internal static string regexAttrNameValueFs { get; }
    internal static string regexAttrNameValueCpp { get; }
    internal static string regexAttrNameValueVb { get; }
    internal static Regex get_assemblyVersionRegex();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_regexAttrNameValueCs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_regexAttrNameValueFs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_regexAttrNameValueCpp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_regexAttrNameValueVb();
    internal static string regexAttrValueCs(string name);
    internal static string regexAttrValueFs(string name);
    internal static string regexAttrValueCpp(string name);
    internal static string regexAttrValueVb(string name);
    internal static string NormalizeVersion(string version);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.MSBuild : object {
    [ObsoleteAttribute("Implementation detail.")]
[CompilationMappingAttribute("9")]
public static string msBuildExe { get; }
    public static string msbuildNamespace { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, FSharpFunc`2<FSharpFunc`2<string, string>, Version>> getVersion { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, Version> cache@688-2 { get; }
    [CompilationMappingAttribute("9")]
internal static Version versionToUseBinLog { get; }
    [CompilationMappingAttribute("9")]
internal static Version versionToUseStructuredLogger { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@333-45(CliArguments this, CliArguments obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@333-44(CliArguments this, CliArguments obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@333-43(CliArguments this, CliArguments obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@333-42(CliArguments this, CliArguments obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@333-49(IComparer comp, CliArguments this, CliArguments objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@333-48(IComparer comp, CliArguments this, CliArguments objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@333-47(IComparer comp, CliArguments this, CliArguments objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@333-46(IComparer comp, CliArguments this, CliArguments objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@333-8(IEqualityComparer comp, CliArguments this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@333-20(CliArguments this, CliArguments that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@333-19(CliArguments this, CliArguments that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@333-21(CliArguments this, CliArguments obj, Unit unitVar);
    internal static CliArguments asCliArguments(MSBuildParams x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MSBuildParams withCliArguments(MSBuildParams oldObj, CliArguments x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CliArguments MSBuildParams.get_CliArguments(MSBuildParams );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MSBuildParams MSBuildParams.WithCliArguments(MSBuildParams oldObj, CliArguments x);
    public static string get_msBuildExe();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_msbuildNamespace();
    public static XName xname(string name);
    public static XDocument loadProject(string projectFileName);
    internal static string unescapeMSBuildSpecialChars(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Tuple`2<XAttribute, string>> getReferenceElements(string elementName, string projectFileName, XDocument doc);
    [ObsoleteAttribute("Will be removed.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XDocument processReferences(string elementName, FSharpFunc`2<string, string> f, string projectFileName, XDocument doc);
    [ObsoleteAttribute("Will be removed.")]
public static FSharpSet`1<string> getProjectReferences(string projectFileName);
    internal static string verbosityName@491(MSBuildVerbosity v);
    internal static string escapePropertyValue@505(string v);
    internal static string logParams@568(MSBuildLogParameter param);
    internal static string loggerParams@567(FSharpList`1<MSBuildLogParameter> paramList);
    internal static string serializeLogger@597(MSBuildFileLoggerConfig fl);
    internal static string serializeLogger@622-4(MSBuildDistributedLoggerConfig dlogger);
    internal static string createLoggerString@641(MSBuildDistributedLoggerConfig cl, FSharpOption`1<MSBuildDistributedLoggerConfig> fl);
    internal static string fromCliArguments(CliArguments p);
    public static Tuple`2<MSBuildParams, string> buildArgs(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams);
    [ObsoleteAttribute("use buildArgs instead.")]
public static string serializeMSBuildParams(MSBuildParams p);
    internal static FSharpFunc`2<string, FSharpFunc`2<FSharpFunc`2<string, string>, Version>> get_getVersion();
    internal static ConcurrentDictionary`2<string, Version> get_cache@688-2();
    internal static Version getFromCall@690(string exePath, FSharpFunc`2<string, string> callMsbuildExe, Unit unitVar0);
    internal static Version get_versionToUseBinLog();
    internal static Version get_versionToUseStructuredLogger();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<a>, string> addBinaryLogger(string exePath, FSharpFunc`2<string, string> callMsbuildExe, string args, bool disableFakeBinLoger);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void handleAfterRun(string command, a binLogPath, int exitCode, string project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpChoice`2<ProcessResult, Tuple`2<Exception, ProcessResult>> buildWithRedirect(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void build(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string project);
    internal static FSharpFunc`2<MSBuildParams, MSBuildParams> setBuildParam@880(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string targets, FSharpFunc`2<string, FSharpList`1<Tuple`2<string, string>>> properties, string project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> runWithProperties(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string outputPath, string targets, FSharpFunc`2<string, FSharpList`1<Tuple`2<string, string>>> properties, IEnumerable`1<string> projects);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> run(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string outputPath, string targets, FSharpList`1<Tuple`2<string, string>> properties, IEnumerable`1<string> projects);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> runDebug(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string outputPath, string targets, IEnumerable`1<string> projects);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> runRelease(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string outputPath, string targets, IEnumerable`1<string> projects);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> runWithDefaults(string targets, IEnumerable`1<string> projects);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> runReleaseExt(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string outputPath, FSharpList`1<Tuple`2<string, string>> properties, string targets, IEnumerable`1<string> projects);
    internal static int slashes@948(string dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void buildWebsiteConfig(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string outputPath, string configuration, string projectFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void buildWebsite(string outputPath, string projectFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void buildWebsitesConfig(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string outputPath, string configuration, IEnumerable`1<string> projectFiles);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<IEnumerable`1<string>, Unit> buildWebsites(FSharpFunc`2<MSBuildParams, MSBuildParams> outputPath, string projectFiles);
}
[CompilationMappingAttribute("2")]
public class Fake.DotNet.MSBuildDistributedLoggerConfig : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ClassName@;
    [DebuggerBrowsableAttribute("0")]
internal string AssemblyPath@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<Tuple`2<string, string>>> Parameters@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<string> ClassName { get; }
    [CompilationMappingAttribute("4", "1")]
public string AssemblyPath { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<FSharpList`1<Tuple`2<string, string>>> Parameters { get; }
    public MSBuildDistributedLoggerConfig(FSharpOption`1<string> className, string assemblyPath, FSharpOption`1<FSharpList`1<Tuple`2<string, string>>> parameters);
    public FSharpOption`1<string> get_ClassName();
    public string get_AssemblyPath();
    public FSharpOption`1<FSharpList`1<Tuple`2<string, string>>> get_Parameters();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MSBuildDistributedLoggerConfig obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MSBuildDistributedLoggerConfig obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class Fake.DotNet.MSBuildEntry : object {
    [DebuggerBrowsableAttribute("0")]
internal string Version@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Paths@;
    [CompilationMappingAttribute("4", "0")]
public string Version { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<string> Paths { get; }
    public MSBuildEntry(string version, FSharpList`1<string> paths);
    public string get_Version();
    public FSharpList`1<string> get_Paths();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MSBuildEntry obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MSBuildEntry obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("5")]
public class Fake.DotNet.MSBuildException : Exception {
    internal string Data0@;
    internal FSharpList`1<string> Data1@;
    [CompilationMappingAttribute("4", "0")]
public string Data0 { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<string> Data1 { get; }
    public MSBuildException(string data0, FSharpList`1<string> data1);
    protected MSBuildException(SerializationInfo info, StreamingContext context);
    public string get_Data0();
    public FSharpList`1<string> get_Data1();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Fake.DotNet.MSBuildExe : object {
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<MSBuildEntry> knownMSBuildEntries { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> oldMSBuildLocations { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> getAllKnownPaths { get; }
    [CompilationMappingAttribute("9")]
internal static Version monoVersionToUseMSBuildOn { get; }
    [CompilationMappingAttribute("9")]
internal static string msBuildExe { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, FSharpOption`1<string>> which@184 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> msbuildEnvironVar@185 { get; }
    [CompilationMappingAttribute("9")]
internal static bool preferMSBuildOnNetCore@187 { get; }
    [CompilationMappingAttribute("9")]
internal static bool preferMSBuildOnMono@194 { get; }
    [CompilationMappingAttribute("9")]
internal static string foundExe@199 { get; }
    [CompilationMappingAttribute("9")]
internal static bool matchValue_1@200 { get; }
    internal static FSharpList`1<MSBuildEntry> get_knownMSBuildEntries();
    internal static FSharpList`1<string> get_oldMSBuildLocations();
    internal static FSharpMap`2<string, FSharpList`1<string>> toDict(IEnumerable`1<MSBuildEntry> items);
    internal static FSharpList`1<string> get_getAllKnownPaths();
    internal static Version get_monoVersionToUseMSBuildOn();
    internal static string get_msBuildExe();
    internal static FSharpFunc`2<string, string> exactPathOrBinaryOnPath@179(string tool);
    internal static FSharpFunc`2<string, FSharpOption`1<string>> get_which@184();
    internal static FSharpOption`1<string> get_msbuildEnvironVar@185();
    internal static bool get_preferMSBuildOnNetCore@187();
    internal static bool get_preferMSBuildOnMono@194();
    internal static string get_foundExe@199();
    internal static bool get_matchValue_1@200();
}
[CompilationMappingAttribute("7")]
internal static class Fake.DotNet.MSBuildExeFromVsWhere : object {
    internal static FSharpList`1<MSBuildEntry> getOrdered();
}
[CompilationMappingAttribute("2")]
public class Fake.DotNet.MSBuildFileLoggerConfig : object {
    [DebuggerBrowsableAttribute("0")]
internal int Number@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Filename@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<MSBuildVerbosity> Verbosity@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<MSBuildLogParameter>> Parameters@;
    [CompilationMappingAttribute("4", "0")]
public int Number { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<string> Filename { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<MSBuildVerbosity> Verbosity { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<FSharpList`1<MSBuildLogParameter>> Parameters { get; }
    public MSBuildFileLoggerConfig(int number, FSharpOption`1<string> filename, FSharpOption`1<MSBuildVerbosity> verbosity, FSharpOption`1<FSharpList`1<MSBuildLogParameter>> parameters);
    public int get_Number();
    public FSharpOption`1<string> get_Filename();
    public FSharpOption`1<MSBuildVerbosity> get_Verbosity();
    public FSharpOption`1<FSharpList`1<MSBuildLogParameter>> get_Parameters();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MSBuildFileLoggerConfig obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MSBuildFileLoggerConfig obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.DotNet.MSBuildLogParameter : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_Append;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_PerformanceSummary;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_Summary;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_NoSummary;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_ErrorsOnly;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_WarningsOnly;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_NoItemAndPropertyList;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_ShowCommandLine;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_ShowTimestamp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_ShowEventId;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_ForceNoAlign;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_DisableConsoleColor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_ForceConsoleColor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_DisableMPLogging;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildLogParameter _unique_EnableMPLogging;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter Append { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAppend { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter PerformanceSummary { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPerformanceSummary { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter Summary { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSummary { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter NoSummary { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoSummary { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter ErrorsOnly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsErrorsOnly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter WarningsOnly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWarningsOnly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter NoItemAndPropertyList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoItemAndPropertyList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter ShowCommandLine { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsShowCommandLine { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter ShowTimestamp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsShowTimestamp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter ShowEventId { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsShowEventId { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter ForceNoAlign { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsForceNoAlign { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter DisableConsoleColor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDisableConsoleColor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter ForceConsoleColor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsForceConsoleColor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter DisableMPLogging { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDisableMPLogging { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildLogParameter EnableMPLogging { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnableMPLogging { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLogParameter { get; }
    private static MSBuildLogParameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MSBuildLogParameter(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static MSBuildLogParameter get_Append();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAppend();
    [CompilationMappingAttribute("8", "1")]
public static MSBuildLogParameter get_PerformanceSummary();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPerformanceSummary();
    [CompilationMappingAttribute("8", "2")]
public static MSBuildLogParameter get_Summary();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSummary();
    [CompilationMappingAttribute("8", "3")]
public static MSBuildLogParameter get_NoSummary();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoSummary();
    [CompilationMappingAttribute("8", "4")]
public static MSBuildLogParameter get_ErrorsOnly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsErrorsOnly();
    [CompilationMappingAttribute("8", "5")]
public static MSBuildLogParameter get_WarningsOnly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWarningsOnly();
    [CompilationMappingAttribute("8", "6")]
public static MSBuildLogParameter get_NoItemAndPropertyList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoItemAndPropertyList();
    [CompilationMappingAttribute("8", "7")]
public static MSBuildLogParameter get_ShowCommandLine();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsShowCommandLine();
    [CompilationMappingAttribute("8", "8")]
public static MSBuildLogParameter get_ShowTimestamp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsShowTimestamp();
    [CompilationMappingAttribute("8", "9")]
public static MSBuildLogParameter get_ShowEventId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsShowEventId();
    [CompilationMappingAttribute("8", "10")]
public static MSBuildLogParameter get_ForceNoAlign();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsForceNoAlign();
    [CompilationMappingAttribute("8", "11")]
public static MSBuildLogParameter get_DisableConsoleColor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDisableConsoleColor();
    [CompilationMappingAttribute("8", "12")]
public static MSBuildLogParameter get_ForceConsoleColor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsForceConsoleColor();
    [CompilationMappingAttribute("8", "13")]
public static MSBuildLogParameter get_DisableMPLogging();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDisableMPLogging();
    [CompilationMappingAttribute("8", "14")]
public static MSBuildLogParameter get_EnableMPLogging();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnableMPLogging();
    [CompilationMappingAttribute("8", "15")]
public static MSBuildLogParameter NewLogParameter(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLogParameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MSBuildLogParameter obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MSBuildLogParameter obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Fake.DotNet.MSBuildParamExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CliArguments MSBuildParams.get_CliArguments(MSBuildParams );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MSBuildParams MSBuildParams.WithCliArguments(MSBuildParams oldObj, CliArguments x);
}
[CompilationMappingAttribute("2")]
public class Fake.DotNet.MSBuildParams : object {
    [DebuggerBrowsableAttribute("0")]
internal string ToolPath@;
    [DebuggerBrowsableAttribute("0")]
internal string WorkingDirectory@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Targets@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2<string, string>> Properties@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpOption`1<int>> MaxCpuCount@;
    [DebuggerBrowsableAttribute("0")]
internal bool DoRestore@;
    [DebuggerBrowsableAttribute("0")]
internal bool NoLogo@;
    [DebuggerBrowsableAttribute("0")]
internal bool NodeReuse@;
    [DebuggerBrowsableAttribute("0")]
internal bool RestorePackagesFlag@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ToolsVersion@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<MSBuildVerbosity> Verbosity@;
    [DebuggerBrowsableAttribute("0")]
internal bool NoConsoleLogger@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<string>> WarnAsError@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<string>> NoWarn@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<MSBuildLogParameter> ConsoleLogParameters@;
    [DebuggerBrowsableAttribute("0")]
internal bool DisableInternalBinLog@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<MSBuildFileLoggerConfig>> FileLoggers@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<string>> BinaryLoggers@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<MSBuildDistributedLoggerConfig>> Loggers@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<Tuple`2<MSBuildDistributedLoggerConfig, FSharpOption`1<MSBuildDistributedLoggerConfig>>>> DistributedLoggers@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<string, string> Environment@;
    [CompilationMappingAttribute("4", "0")]
public string ToolPath { get; }
    [CompilationMappingAttribute("4", "1")]
public string WorkingDirectory { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpList`1<string> Targets { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpList`1<Tuple`2<string, string>> Properties { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpOption`1<FSharpOption`1<int>> MaxCpuCount { get; }
    [CompilationMappingAttribute("4", "5")]
public bool DoRestore { get; }
    [CompilationMappingAttribute("4", "6")]
public bool NoLogo { get; }
    [CompilationMappingAttribute("4", "7")]
public bool NodeReuse { get; }
    [CompilationMappingAttribute("4", "8")]
public bool RestorePackagesFlag { get; }
    [CompilationMappingAttribute("4", "9")]
public FSharpOption`1<string> ToolsVersion { get; }
    [CompilationMappingAttribute("4", "10")]
public FSharpOption`1<MSBuildVerbosity> Verbosity { get; }
    [CompilationMappingAttribute("4", "11")]
public bool NoConsoleLogger { get; }
    [CompilationMappingAttribute("4", "12")]
public FSharpOption`1<FSharpList`1<string>> WarnAsError { get; }
    [CompilationMappingAttribute("4", "13")]
public FSharpOption`1<FSharpList`1<string>> NoWarn { get; }
    [CompilationMappingAttribute("4", "14")]
public FSharpList`1<MSBuildLogParameter> ConsoleLogParameters { get; }
    [CompilationMappingAttribute("4", "15")]
public bool DisableInternalBinLog { get; }
    [CompilationMappingAttribute("4", "16")]
public FSharpOption`1<FSharpList`1<MSBuildFileLoggerConfig>> FileLoggers { get; }
    [CompilationMappingAttribute("4", "17")]
public FSharpOption`1<FSharpList`1<string>> BinaryLoggers { get; }
    [CompilationMappingAttribute("4", "18")]
public FSharpOption`1<FSharpList`1<MSBuildDistributedLoggerConfig>> Loggers { get; }
    [CompilationMappingAttribute("4", "19")]
public FSharpOption`1<FSharpList`1<Tuple`2<MSBuildDistributedLoggerConfig, FSharpOption`1<MSBuildDistributedLoggerConfig>>>> DistributedLoggers { get; }
    [CompilationMappingAttribute("4", "20")]
public FSharpMap`2<string, string> Environment { get; }
    [ObsoleteAttribute("Please use 'Create()' instead and make sure to properly set Environment via Process-module funtions!")]
public static MSBuildParams Empty { get; }
    public MSBuildParams(string toolPath, string workingDirectory, FSharpList`1<string> targets, FSharpList`1<Tuple`2<string, string>> properties, FSharpOption`1<FSharpOption`1<int>> maxCpuCount, bool doRestore, bool noLogo, bool nodeReuse, bool restorePackagesFlag, FSharpOption`1<string> toolsVersion, FSharpOption`1<MSBuildVerbosity> verbosity, bool noConsoleLogger, FSharpOption`1<FSharpList`1<string>> warnAsError, FSharpOption`1<FSharpList`1<string>> noWarn, FSharpList`1<MSBuildLogParameter> consoleLogParameters, bool disableInternalBinLog, FSharpOption`1<FSharpList`1<MSBuildFileLoggerConfig>> fileLoggers, FSharpOption`1<FSharpList`1<string>> binaryLoggers, FSharpOption`1<FSharpList`1<MSBuildDistributedLoggerConfig>> loggers, FSharpOption`1<FSharpList`1<Tuple`2<MSBuildDistributedLoggerConfig, FSharpOption`1<MSBuildDistributedLoggerConfig>>>> distributedLoggers, FSharpMap`2<string, string> environment);
    public string get_ToolPath();
    public string get_WorkingDirectory();
    public FSharpList`1<string> get_Targets();
    public FSharpList`1<Tuple`2<string, string>> get_Properties();
    public FSharpOption`1<FSharpOption`1<int>> get_MaxCpuCount();
    public bool get_DoRestore();
    public bool get_NoLogo();
    public bool get_NodeReuse();
    public bool get_RestorePackagesFlag();
    public FSharpOption`1<string> get_ToolsVersion();
    public FSharpOption`1<MSBuildVerbosity> get_Verbosity();
    public bool get_NoConsoleLogger();
    public FSharpOption`1<FSharpList`1<string>> get_WarnAsError();
    public FSharpOption`1<FSharpList`1<string>> get_NoWarn();
    public FSharpList`1<MSBuildLogParameter> get_ConsoleLogParameters();
    public bool get_DisableInternalBinLog();
    public FSharpOption`1<FSharpList`1<MSBuildFileLoggerConfig>> get_FileLoggers();
    public FSharpOption`1<FSharpList`1<string>> get_BinaryLoggers();
    public FSharpOption`1<FSharpList`1<MSBuildDistributedLoggerConfig>> get_Loggers();
    public FSharpOption`1<FSharpList`1<Tuple`2<MSBuildDistributedLoggerConfig, FSharpOption`1<MSBuildDistributedLoggerConfig>>>> get_DistributedLoggers();
    public FSharpMap`2<string, string> get_Environment();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MSBuildParams obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static MSBuildParams Create();
    public static MSBuildParams get_Empty();
    public MSBuildParams WithEnvironment(FSharpMap`2<string, string> map);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MSBuildParams obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.DotNet.MSBuildVerbosity : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildVerbosity _unique_Quiet;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildVerbosity _unique_Minimal;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildVerbosity _unique_Normal;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildVerbosity _unique_Detailed;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MSBuildVerbosity _unique_Diagnostic;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildVerbosity Quiet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsQuiet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildVerbosity Minimal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMinimal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildVerbosity Normal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNormal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildVerbosity Detailed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDetailed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MSBuildVerbosity Diagnostic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDiagnostic { get; }
    private static MSBuildVerbosity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MSBuildVerbosity(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static MSBuildVerbosity get_Quiet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsQuiet();
    [CompilationMappingAttribute("8", "1")]
public static MSBuildVerbosity get_Minimal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMinimal();
    [CompilationMappingAttribute("8", "2")]
public static MSBuildVerbosity get_Normal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNormal();
    [CompilationMappingAttribute("8", "3")]
public static MSBuildVerbosity get_Detailed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDetailed();
    [CompilationMappingAttribute("8", "4")]
public static MSBuildVerbosity get_Diagnostic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDiagnostic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MSBuildVerbosity obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MSBuildVerbosity obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.NuGet.Install : object {
    [CompilationMappingAttribute("9")]
public static NugetInstallParams NugetInstallDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-2 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-2 { get; }
    public static NugetInstallParams get_NugetInstallDefaults();
    internal static string get_path1@7-2();
    internal static string get_path2@7-2();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string argList(string name, IEnumerable`1<string> values);
    public static string buildArgs(NugetInstallParams param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NugetInstall(FSharpFunc`2<NugetInstallParams, NugetInstallParams> setParams, string packageName);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.NuGet.NuGet : object {
    [ObsoleteAttribute("This V1 NuGet feed url most likely doesn't work. Please consider using v3 nuget feed via `NuGet.galleryV3`.")]
public static string galleryV1 { get; }
    public static string galleryV2 { get; }
    public static string galleryV3 { get; }
    [CompilationMappingAttribute("9")]
internal static WebClient webClient { get; }
    [CompilationMappingAttribute("9")]
public static Lazy`1<string> discoverRepoUrl { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-57(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-56(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-55(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-54(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-53(NuGetParams this, NuGetParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-52(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-51(NuGetParams this, NuGetParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-50(NuGetParams this, NuGetParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-64(IComparer comp, NuGetParams this, NuGetParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-63(IComparer comp, NuGetParams this, NuGetParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-62(IComparer comp, NuGetParams this, NuGetParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-61(IComparer comp, NuGetParams this, NuGetParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-60(IComparer comp, NuGetParams this, NuGetParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-59(IComparer comp, NuGetParams this, NuGetParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@55-58(IComparer comp, NuGetParams this, NuGetParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@55-9(IEqualityComparer comp, NuGetParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@55-25(NuGetParams this, NuGetParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@55-24(NuGetParams this, NuGetParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@55-23(NuGetParams this, NuGetParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@55-22(NuGetParams this, NuGetParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@55-28(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@55-27(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@55-26(NuGetParams this, NuGetParams obj, Unit unitVar);
    public static NuGetParams NuGetDefaults();
    public static string RequireExactly(string version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string RequireRange(BreakingPoint breakingPoint, string version);
    internal static string packageFileName(NuGetParams parameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string GetPackageVersion(string deploymentsDir, string package);
    internal static string getFrameworkGroup@179(IEnumerable`1<Tuple`2<string, string>> frameworkTags);
    internal static string getGroup@186(FSharpList`1<a> items, FSharpFunc`2<FSharpList`1<a>, string> toTags);
    internal static string getReferencesTags@190(IEnumerable`1<string> references);
    internal static string getFrameworkAssemblyTags@204(IEnumerable`1<NugetFrameworkAssemblyReferences> references);
    internal static string getDependenciesTags@215(IEnumerable`1<Tuple`2<string, string>> dependencies);
    internal static string xmlEncode@244(string notEncodedText);
    internal static string toSingleLine@248(string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string createNuSpecFromTemplate(NuGetParams parameters, FileInfo templateNuSpec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> createNuSpecFromTemplateIfNotProjFile(NuGetParams parameters, string nuSpecOrProjFile);
    internal static string propertiesParam(FSharpList`1<Tuple`2<string, string>> _arg1);
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-7(NuGetParams parameters, string args, ProcStartInfo info);
    internal static void execute@303(NuGetParams parameters, string args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pack(NuGetParams parameters, string nuspecFile);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@331-66(NuGetPushParams this, NuGetPushParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@331-65(NuGetPushParams this, NuGetPushParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@331-68(IComparer comp, NuGetPushParams this, NuGetPushParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@331-67(IComparer comp, NuGetPushParams this, NuGetPushParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@331-10(IEqualityComparer comp, NuGetPushParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@331-29(NuGetPushParams this, NuGetPushParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@331-30(NuGetPushParams this, NuGetPushParams obj, Unit unitVar);
    internal static FSharpOption`1<string> normalize@364(string str);
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> stringToArg@385(string name);
    internal static FSharpFunc`2<bool, FSharpList`1<string>> boolToArg@389(string name);
    internal static FSharpList`1<string> toPushCliArgs(NuGetPushParams param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void push(ToolOptions options, NuGetPushParams parameters, string nupkg);
    internal static void publish(NuGetParams parameters);
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-8(NuGetParams parameters, string args, ProcStartInfo info);
    internal static void publishSymbols(NuGetParams parameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NuGetPackDirectly(FSharpFunc`2<NuGetParams, NuGetParams> setParams, string nuspecOrProjectFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NuGetPack(FSharpFunc`2<NuGetParams, NuGetParams> setParams, string nuspecOrProjectFile);
    public static void NuGetPublish(FSharpFunc`2<NuGetParams, NuGetParams> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NuGet(FSharpFunc`2<NuGetParams, NuGetParams> setParams, string nuspecOrProjectFile);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@548-71(NuSpecPackage this, NuSpecPackage obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@548-70(NuSpecPackage this, NuSpecPackage obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@548-69(NuSpecPackage this, NuSpecPackage obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@548-74(NuSpecPackage this, NuSpecPackage objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@548-73(NuSpecPackage this, NuSpecPackage objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@548-72(IComparer comp, NuSpecPackage this, NuSpecPackage objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@548-11(IEqualityComparer comp, NuSpecPackage this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@548-32(NuSpecPackage this, NuSpecPackage that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@548-31(NuSpecPackage this, NuSpecPackage that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@548-33(NuSpecPackage this, NuSpecPackage obj, Unit unitVar);
    internal static FSharpOption`1<string> getWith@586(XmlDocument doc, FSharpList`1<Tuple`2<string, string>> namespaces, string name, string ns);
    internal static string getValue@585(XmlDocument doc, FSharpList`1<Tuple`2<string, string>> namespaces, string name);
    public static NuSpecPackage getNuspecProperties(string nuspec);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_galleryV1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_galleryV2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_galleryV3();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void WebClient.UploadFileAsMultipart(WebClient x, Uri url, string filename);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addAcceptHeader(WebClient client, string contentType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addHeader(WebClient client, string headerKey, string headerVal);
    internal static WebClient get_webClient();
    public static Lazy`1<string> get_discoverRepoUrl();
    public static string getRepoUrl();
    internal static string property@751(XmlElement properties, string name);
    public static NuSpecPackage extractFeedPackageFromXml(XmlNode entry);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NuSpecPackage getPackage(string repoUrl, string packageName, string version);
    public static FSharpList`1<NuSpecPackage> getFeedPackagesFromUrl(string url);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NuSpecPackage getLatestPackage(string repoUrl, string packageName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string downloadPackage(string targetDir, NuSpecPackage package);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string argList(string name, IEnumerable`1<string> values);
    internal static string attribute@815(string name, XElement e);
    public static FSharpList`1<NuGetDependency> getDependencies(string packagesFile);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.NuGet.Restore : object {
    [CompilationMappingAttribute("9")]
public static RestorePackageParams RestorePackageDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7 { get; }
    [CompilationMappingAttribute("9")]
public static RestoreSinglePackageParams RestoreSinglePackageDefaults { get; }
    internal static IEnumerable`1<string> findInFolders@29(FSharpList`1<string> exeNames, IEnumerable`1<string> folders);
    public static string findNuget(string defaultPath);
    public static RestorePackageParams get_RestorePackageDefaults();
    internal static string get_path1@7();
    internal static string get_path2@7();
    public static RestoreSinglePackageParams get_RestoreSinglePackageDefaults();
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-6(string toolPath, string args, ProcStartInfo info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runNuGet(string toolPath, TimeSpan timeOut, string args, FSharpFunc`2<Unit, Unit> failWith);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runNuGetTrial(int retries, string toolPath, TimeSpan timeOut, string args, FSharpFunc`2<Unit, Unit> failWith);
    public static FSharpList`1<string> buildSources(FSharpList`1<string> sources);
    internal static string verbosityToString(NugetRestoreVerbosity v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildNuGetArgs(FSharpFunc`2<RestoreSinglePackageParams, RestoreSinglePackageParams> setParams, string packageId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RestorePackageId(FSharpFunc`2<RestoreSinglePackageParams, RestoreSinglePackageParams> setParams, string packageId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RestorePackage(FSharpFunc`2<RestorePackageParams, RestorePackageParams> setParams, string packageFile);
    public static void RestorePackages();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RestoreMSSolutionPackages(FSharpFunc`2<RestorePackageParams, RestorePackageParams> setParams, string solutionFile);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.NuGet.Update : object {
    [CompilationMappingAttribute("9")]
public static NugetUpdateParams NugetUpdateDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-1 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-1 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@20-77(NugetUpdateParams this, NugetUpdateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@20-76(NugetUpdateParams this, NugetUpdateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@20-75(NugetUpdateParams this, NugetUpdateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@20-80(IComparer comp, NugetUpdateParams this, NugetUpdateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@20-79(IComparer comp, NugetUpdateParams this, NugetUpdateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@20-78(IComparer comp, NugetUpdateParams this, NugetUpdateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@20-12(IEqualityComparer comp, NugetUpdateParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@20-34(NugetUpdateParams this, NugetUpdateParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@20-35(NugetUpdateParams this, NugetUpdateParams obj, Unit unitVar);
    public static NugetUpdateParams get_NugetUpdateDefaults();
    internal static string get_path1@7-1();
    internal static string get_path2@7-1();
    public static string buildArgs(NugetUpdateParams param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NugetUpdate(FSharpFunc`2<NugetUpdateParams, NugetUpdateParams> setParams, string packagesFile);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.NuGet.Version : object {
    public static SemVerInfo IncPatch(SemVerInfo v);
    public static SemVerInfo IncMinor(SemVerInfo v);
    public static SemVerInfo IncMajor(SemVerInfo v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<SemVerInfo> getLastNuGetVersion(string server, string packageName);
    public static string nextVersion(FSharpFunc`2<NuGetVersionArg, NuGetVersionArg> f);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Paket : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@16-159(PaketPackParams this, PaketPackParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@16-158(PaketPackParams this, PaketPackParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@16-157(PaketPackParams this, PaketPackParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@16-156(PaketPackParams this, PaketPackParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@16-163(PaketPackParams this, PaketPackParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@16-162(IComparer comp, PaketPackParams this, PaketPackParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@16-161(IComparer comp, PaketPackParams this, PaketPackParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@16-160(IComparer comp, PaketPackParams this, object obj, PaketPackParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@16-27(IEqualityComparer comp, PaketPackParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@16-67(PaketPackParams this, PaketPackParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@16-66(PaketPackParams this, PaketPackParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@16-68(PaketPackParams this, PaketPackParams obj, Unit unitVar);
    internal static string findPaketExecutable();
    public static PaketPackParams PaketPackDefaults();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@63-164(PaketPushParams this, PaketPushParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@63-165(PaketPushParams this, PaketPushParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@63-28(IEqualityComparer comp, PaketPushParams this, Unit unitVar);
    public static PaketPushParams PaketPushDefaults();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@83-166(PaketRestoreParams this, PaketRestoreParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@83-167(IComparer comp, PaketRestoreParams this, PaketRestoreParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@83-29(IEqualityComparer comp, PaketRestoreParams this, Unit unitVar);
    public static PaketRestoreParams PaketRestoreDefaults();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ProcStartInfo startPaket(string toolPath, string workDir, ProcStartInfo info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ProcStartInfo withArgs(string args, ProcStartInfo info);
    internal static string xmlEncode@118-2(string notEncodedText);
    public static void pack(FSharpFunc`2<PaketPackParams, PaketPackParams> setParams);
    internal static FSharpList`1<FSharpList`1<a>> loop@177-24(int length, IEnumerable`1<a> xs);
    internal static FSharpFunc`2<IEnumerable`1<T>, FSharpList`1<FSharpList`1<T>>> split@176-1(int length);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> mapping@1-2(PaketPushParams parameters, string url, string endpoint, string key, string package);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pushFiles(FSharpFunc`2<PaketPushParams, PaketPushParams> setParams, IEnumerable`1<string> files);
    public static void push(FSharpFunc`2<PaketPushParams, PaketPushParams> setParams);
    [CompilerGeneratedAttribute]
internal static String[] func2@1-4(String[] array);
    [CompilerGeneratedAttribute]
internal static String[] func2@1-5(String[] array);
    internal static string find@242(string dir);
    internal static string getPaketLockFile@241(string referencesFile);
    public static Tuple`2[] getDependenciesForReferencesFile(string referencesFile);
    public static void restore(FSharpFunc`2<PaketRestoreParams, PaketRestoreParams> setParams);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.PaketTemplate : object {
    [CompilationMappingAttribute("9")]
public static PaketTemplateParams DefaultPaketTemplateParams { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-172(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-171(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-170(PaketTemplateParams this, PaketTemplateParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-169(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-168(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-177(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-176(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-175(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-174(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@41-173(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@41-71(PaketTemplateParams this, PaketTemplateParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@41-70(PaketTemplateParams this, PaketTemplateParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@41-69(PaketTemplateParams this, PaketTemplateParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@41-73(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@41-72(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    public static PaketTemplateParams get_DefaultPaketTemplateParams();
    public static void create(FSharpFunc`2<PaketTemplateParams, PaketTemplateParams> setParams);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.DotCover : object {
    [CompilationMappingAttribute("9")]
internal static Params Defaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-14 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-17 { get; }
    [CompilationMappingAttribute("9")]
internal static MergeParams MergeDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-15 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-18 { get; }
    [CompilationMappingAttribute("9")]
internal static ReportParams ReportDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-16 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-19 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@25-227(Params this, Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@25-226(Params this, Params obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@25-229(IComparer comp, Params this, Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@25-228(IComparer comp, Params this, Params objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@25-42(IEqualityComparer comp, Params this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@25-92(Params this, Params that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@25-93(Params this, Params obj, Unit unitVar);
    internal static Params get_Defaults();
    internal static string get_path1@7-14();
    internal static string get_path2@7-17();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-230(MergeParams this, MergeParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-231(IComparer comp, MergeParams this, MergeParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@50-43(IEqualityComparer comp, MergeParams this, Unit unitVar);
    internal static MergeParams get_MergeDefaults();
    internal static string get_path1@7-15();
    internal static string get_path2@7-18();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@66-232(ReportParams this, ReportParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@66-233(ReportParams this, ReportParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@66-44(ReportParams this, Unit unitVar);
    internal static ReportParams get_ReportDefaults();
    internal static string get_path1@7-16();
    internal static string get_path2@7-19();
    internal static string buildArgs(Params parameters);
    internal static string buildMergeArgs(MergeParams parameters);
    internal static string buildReportArgs(ReportParams parameters);
    internal static string getWorkingDir(string workingDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildParamsAndExecute(a parameters, FSharpFunc`2<a, string> buildArguments, string toolPath, string workingDir, bool failBuild);
    public static void run(FSharpFunc`2<Params, Params> setParams);
    public static void merge(FSharpFunc`2<MergeParams, MergeParams> setParams);
    public static FSharpFunc`2<bool, Unit> report(FSharpFunc`2<ReportParams, ReportParams> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runNUnit(FSharpFunc`2<Params, Params> setDotCoverParams, FSharpFunc`2<NUnitParams, NUnitParams> setNUnitParams, IEnumerable`1<string> assemblies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runNUnit3(FSharpFunc`2<Params, Params> setDotCoverParams, FSharpFunc`2<NUnit3Params, NUnit3Params> setNUnitParams, IEnumerable`1<string> assemblies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runXUnit2(FSharpFunc`2<Params, Params> setDotCoverParams, FSharpFunc`2<XUnit2Params, XUnit2Params> setXUnit2Params, IEnumerable`1<string> assemblies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string buildMSTestArgsForDotCover(MSTestParams parameters, String[] assemblies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runMSTest(FSharpFunc`2<Params, Params> setDotCoverParams, FSharpFunc`2<MSTestParams, MSTestParams> setMSTestParams, IEnumerable`1<string> assemblies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runMSpec(FSharpFunc`2<Params, Params> setDotCoverParams, FSharpFunc`2<MSpecParams, MSpecParams> setMSpecParams, IEnumerable`1<string> assemblies);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.Expecto : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-126(Params this, Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-125(Params this, Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-124(Params this, Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-123(Params this, Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-129(IComparer comp, Params this, Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-128(IComparer comp, Params this, Params objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-127(IComparer comp, Params this, Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@10-18(IEqualityComparer comp, Params this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@10-53(Params this, Params that, IEqualityComparer comp, Unit unitVar);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendIfTrue@44(bool value, string s);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendIfNotNullOrWhiteSpace@46(string value, string s);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendIfNotEqual@50(a other, a value, string s);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendList@54(FSharpList`1<string> list, string s);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@10-54(Params this, Params obj, Unit unitVar);
    internal static RunMode getRunMode(string assembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> runAssembly(Params expectoParams, string testAssembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void run(FSharpFunc`2<Params, Params> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.MSpec : object {
    [CompilationMappingAttribute("9")]
public static MSpecParams MSpecDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-3 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-3 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-102(MSpecParams this, MSpecParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-101(MSpecParams this, MSpecParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-104(IComparer comp, MSpecParams this, MSpecParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-103(IComparer comp, MSpecParams this, MSpecParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@13-14(IEqualityComparer comp, MSpecParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@13-43(MSpecParams this, MSpecParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@13-44(MSpecParams this, MSpecParams obj, Unit unitVar);
    public static MSpecParams get_MSpecDefaults();
    internal static string get_path1@7-3();
    internal static string get_path2@7-3();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildArgs(MSpecParams parameters, IEnumerable`1<string> assemblies);
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-9(MSpecParams parameters, string args, ProcStartInfo info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void exec(FSharpFunc`2<MSpecParams, MSpecParams> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.MSTest : object {
    [CompilationMappingAttribute("9")]
public static String[] mstestPaths { get; }
    [CompilationMappingAttribute("9")]
public static string mstestexe { get; }
    [CompilationMappingAttribute("9")]
public static MSTestParams MSTestDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> matchValue@64-2 { get; }
    public static String[] get_mstestPaths();
    public static string get_mstestexe();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-120(MSTestParams this, MSTestParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-119(MSTestParams this, MSTestParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-122(IComparer comp, MSTestParams this, MSTestParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@30-121(IComparer comp, MSTestParams this, MSTestParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@30-17(IEqualityComparer comp, MSTestParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@30-51(MSTestParams this, MSTestParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@30-52(MSTestParams this, MSTestParams obj, Unit unitVar);
    public static MSTestParams get_MSTestDefaults();
    internal static FSharpOption`1<string> get_matchValue@64-2();
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<StringBuilder, StringBuilder> action@75-8(string value, string s);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<StringBuilder, StringBuilder> action@75-9(string value, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildArgs(MSTestParams parameters, string assembly);
    internal static FSharpFunc`2<int, Unit> failIfError@107(MSTestParams parameters, string assembly);
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-14(MSTestParams parameters, string args, ProcStartInfo info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void exec(FSharpFunc`2<MSTestParams, MSTestParams> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.NUnit.Common : object {
    [CompilationMappingAttribute("9")]
public static NUnitParams NUnitDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-5 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-5 { get; }
    public static NUnitParams get_NUnitDefaults();
    internal static string get_path1@7-5();
    internal static string get_path2@7-5();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildArgs(NUnitParams parameters, IEnumerable`1<string> assemblies);
    public static string getWorkingDir(NUnitParams parameters);
    public static FSharpChoice`3<Unit, Unit, string> |OK|TestsFailed|FatalError|(int errorCode);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.NUnit.Parallel : object {
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-13(string tool, NUnitParams parameters, string args, ProcStartInfo info);
    internal static NUnitParallelResult runSingleAssembly@50(string tool, NUnitParams parameters, string name, string outputFile);
    internal static FSharpList`1<string> formatErrorMessages@95(NUnitParams parameters, NUnitParallelResult r);
    internal static a fail@111(FSharpList`1<NUnitParallelResult> testRunResults, AggFailedResult aggResult, FSharpList`1<NUnitParallelResult> matchValue, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void run(FSharpFunc`2<NUnitParams, NUnitParams> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.NUnit.Sequential : object {
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-12(NUnitParams parameters, string tool, string args, ProcStartInfo info);
    internal static string errorDescription@45(int error);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void run(FSharpFunc`2<NUnitParams, NUnitParams> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.NUnit.Xml : object {
    internal static a imp(b arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string op_Dynamic(XElement elem, string attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XElement attr(string attr, a value, XElement elem);
    internal static XElement elem(string name);
    public static FSharpList`1<XElement> GetTestAssemblies(XDocument xDoc);
    public static bool AllSucceeded(IEnumerable`1<a> xDocs);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.NUnit3 : object {
    [CompilationMappingAttribute("9")]
public static NUnit3Params NUnit3Defaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-6 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-6 { get; }
    public static NUnit3Params get_NUnit3Defaults();
    internal static string get_path1@7-6();
    internal static string get_path2@7-6();
    public static string getWorkingDir(NUnit3Params parameters);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendResultString@288(FSharpList`1<string> results);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildArgs(NUnit3Params parameters, IEnumerable`1<string> assemblies);
    internal static string errorDescription@343-3(int error);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CreateProcess`1<Unit> createProcess(FSharpFunc`2<Unit, string> createTempFile, FSharpFunc`2<NUnit3Params, NUnit3Params> setParams, String[] assemblies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void run(FSharpFunc`2<NUnit3Params, NUnit3Params> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.OpenCover : object {
    [CompilationMappingAttribute("9")]
public static OpenCoverParams OpenCoverDefaults { get; }
    public static OpenCoverParams get_OpenCoverDefaults();
    internal static string printParamWithValue@91(string paramName, string paramValue);
    internal static string mergeListAsValues@92(FSharpList`1<a> paramList, FSharpFunc`2<a, string> valueModification);
    internal static string printParamListAsValuesWithQuote@94(string paramName, FSharpList`1<string> paramList);
    internal static string printParamListAsValues@95(string paramName, FSharpList`1<HideSkippedType> paramList);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string buildOpenCoverArgs(OpenCoverParams param, string targetArgs);
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-17(OpenCoverParams param, string processArgs, ProcStartInfo info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void run(FSharpFunc`2<OpenCoverParams, OpenCoverParams> setParams, string targetArgs);
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-18(OpenCoverParams param, ProcStartInfo info);
    public static void getVersion(FSharpOption`1<FSharpFunc`2<OpenCoverParams, OpenCoverParams>> setParams);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Testing.XUnit2 : object {
    [CompilationMappingAttribute("9")]
public static XUnit2Params XUnit2Defaults { get; }
    [CompilationMappingAttribute("9")]
internal static ParallelMode Parallel@172 { get; }
    [CompilationMappingAttribute("9")]
internal static CollectionConcurrencyMode MaxThreads@173 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> HtmlOutputPath@174 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> XmlOutputPath@175 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> XmlV1OutputPath@176 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> NUnitXmlOutputPath@177 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<string, string>> IncludeTraits@178 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<string, string>> ExcludeTraits@179 { get; }
    [CompilationMappingAttribute("9")]
internal static TestRunnerErrorLevel ErrorLevel@181 { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-4 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-4 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-108(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-107(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-106(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-105(XUnit2Params this, XUnit2Params obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-112(IComparer comp, XUnit2Params this, XUnit2Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-111(IComparer comp, XUnit2Params this, XUnit2Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-110(IComparer comp, XUnit2Params this, XUnit2Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-109(IComparer comp, XUnit2Params this, XUnit2Params objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@101-46(XUnit2Params this, XUnit2Params that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@101-45(XUnit2Params this, XUnit2Params that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@101-47(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    public static XUnit2Params get_XUnit2Defaults();
    internal static ParallelMode get_Parallel@172();
    internal static CollectionConcurrencyMode get_MaxThreads@173();
    internal static FSharpOption`1<string> get_HtmlOutputPath@174();
    internal static FSharpOption`1<string> get_XmlOutputPath@175();
    internal static FSharpOption`1<string> get_XmlV1OutputPath@176();
    internal static FSharpOption`1<string> get_NUnitXmlOutputPath@177();
    internal static FSharpList`1<Tuple`2<string, string>> get_IncludeTraits@178();
    internal static FSharpList`1<Tuple`2<string, string>> get_ExcludeTraits@179();
    internal static TestRunnerErrorLevel get_ErrorLevel@181();
    internal static string get_path1@7-4();
    internal static string get_path2@7-4();
    internal static string formatTrait@195(string traitFlag, string tupledArg0, string tupledArg1);
    internal static FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>> appendTraits@197(IEnumerable`1<Tuple`2<string, string>> traitsList);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildArgs(XUnit2Params parameters, IEnumerable`1<string> assemblies);
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-10(XUnit2Params parameters, ProcStartInfo info);
    internal static XUnit2Params discoverNoAppDomainExists(XUnit2Params parameters);
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-11(IEnumerable`1<string> assemblies, XUnit2Params parameters, ProcStartInfo info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void run(FSharpFunc`2<XUnit2Params, XUnit2Params> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.DotNet.Xamarin : object {
    [CompilationMappingAttribute("9")]
public static XamarinComponentRestoreParams XamarinComponentRestoreDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-10 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-12 { get; }
    [CompilationMappingAttribute("9")]
public static iOSBuildParams iOSBuildDefaults { get; }
    [CompilationMappingAttribute("9")]
public static AndroidPackageAbiParam AllAndroidAbiTargets { get; }
    [CompilationMappingAttribute("9")]
public static AndroidPackageParams AndroidPackageDefaults { get; }
    [CompilationMappingAttribute("9")]
public static AndroidSignAndAlignParams AndroidSignAndAlignDefaults { get; }
    [CompilationMappingAttribute("9")]
public static iOSArchiveParams iOSArchiveDefaults { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void executeCommand(string command, string args);
    public static XamarinComponentRestoreParams get_XamarinComponentRestoreDefaults();
    internal static string get_path1@7-10();
    internal static string get_path2@7-12();
    internal static FSharpFunc`2<XamarinComponentRestoreParams, Unit> restoreComponents@42(string project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RestoreComponents(FSharpFunc`2<XamarinComponentRestoreParams, XamarinComponentRestoreParams> setParams, string projectFile);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-181(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-180(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-179(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-178(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-185(IComparer comp, iOSBuildParams this, iOSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-184(IComparer comp, iOSBuildParams this, iOSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-183(IComparer comp, iOSBuildParams this, iOSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-182(IComparer comp, iOSBuildParams this, object obj, iOSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@50-30(IEqualityComparer comp, iOSBuildParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@50-75(iOSBuildParams this, iOSBuildParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@50-74(iOSBuildParams this, iOSBuildParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@50-76(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    public static iOSBuildParams get_iOSBuildDefaults();
    public static AndroidPackageAbiParam get_AllAndroidAbiTargets();
    internal static bool exists@132(iOSBuildParams param, string parameter);
    internal static iOSBuildParams validateParams@130(iOSBuildParams param);
    internal static MSBuildParams applyiOSBuildParamsToMSBuildParams@140(iOSBuildParams iOSBuildParams, MSBuildParams buildParams);
    public static void iOSBuild(FSharpFunc`2<iOSBuildParams, iOSBuildParams> setParams);
    public static AndroidPackageParams get_AndroidPackageDefaults();
    internal static AndroidPackageParams validateParams@224-1(AndroidPackageParams param);
    internal static MSBuildParams applyAndroidBuildParamsToMSBuildParams@232(AndroidPackageParams androidBuildParams, MSBuildParams buildParams);
    internal static MSBuildParams applyBuildParams@259(AndroidPackageParams param, FSharpOption`1<string> abi, FSharpOption`1<string> manifestFile, MSBuildParams msbuildParam);
    internal static void buildPackages@258(AndroidPackageParams param, FSharpOption`1<string> abi, FSharpOption`1<string> manifestFile);
    internal static void rewriteManifestFile@277(string manifestFile, string outfile, FSharpFunc`2<int, FSharpFunc`2<AndroidAbiTarget, int>> transformVersion, AndroidAbiTarget target);
    internal static FileInfo mostRecentFileInDirMatching@287(string path);
    internal static FSharpList`1<FileInfo> createPackage@293(AndroidPackageParams param);
    internal static void buildSpecificApk@298(AndroidPackageParams param, string manifestFile, string name, FSharpFunc`2<int, FSharpFunc`2<AndroidAbiTarget, int>> transformVersion, AndroidAbiTarget target);
    internal static string translateAbi@311(AndroidAbiTarget _arg1);
    internal static void createTargetPackage@319(AndroidPackageParams param, string manifestFile, AndroidAbiTarget target, FSharpFunc`2<int, FSharpFunc`2<AndroidAbiTarget, int>> transformVersion);
    internal static FSharpList`1<FileInfo> createPackageAbiSpecificApk@329(AndroidPackageParams param, FSharpList`1<AndroidAbiTarget> targets, FSharpFunc`2<int, FSharpFunc`2<AndroidAbiTarget, int>> transformVersion);
    public static FSharpList`1<FileInfo> AndroidBuildPackages(FSharpFunc`2<AndroidPackageParams, AndroidPackageParams> setParams);
    public static FileInfo AndroidPackage(FSharpFunc`2<AndroidPackageParams, AndroidPackageParams> setParams);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@366-186(AndroidSignAndAlignParams this, AndroidSignAndAlignParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@366-187(AndroidSignAndAlignParams this, AndroidSignAndAlignParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@366-31(AndroidSignAndAlignParams this, Unit unitVar);
    public static AndroidSignAndAlignParams get_AndroidSignAndAlignDefaults();
    internal static AndroidSignAndAlignParams validateParams@399-3(AndroidSignAndAlignParams param);
    internal static string quotesSurround@406(string s);
    internal static FSharpFunc`2<AndroidSignAndAlignParams, FileInfo> signAndAlign@408(FileInfo file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileInfo AndroidSignAndAlign(FSharpFunc`2<AndroidSignAndAlignParams, AndroidSignAndAlignParams> setParams, FileInfo apkFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<FileInfo> AndroidSignAndAlignPackages(FSharpFunc`2<AndroidSignAndAlignParams, AndroidSignAndAlignParams> setParams, IEnumerable`1<FileInfo> apkFiles);
    public static iOSArchiveParams get_iOSArchiveDefaults();
    public static void iOSArchive(FSharpFunc`2<iOSArchiveParams, iOSArchiveParams> setParams);
}
[ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
[CompilationMappingAttribute("7")]
public static class Fake.DotNetCli : object {
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static string commandName { get; }
    [CompilationMappingAttribute("9")]
internal static CommandParams DefaultCommandParams { get; }
    [CompilationMappingAttribute("9")]
internal static RestoreParams DefaultRestoreParams { get; }
    [CompilationMappingAttribute("9")]
internal static BuildParams DefaultBuildParams { get; }
    [CompilationMappingAttribute("9")]
internal static TestParams DefaultTestParams { get; }
    [CompilationMappingAttribute("9")]
internal static PackParams DefaultPackParams { get; }
    [CompilationMappingAttribute("9")]
internal static PublishParams DefaultPublishParams { get; }
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
[CompilationMappingAttribute("9")]
public static string DotnetSDKPath { get; public set; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_commandName();
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static string getVersion();
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static bool isInstalled();
    internal static CommandParams get_DefaultCommandParams();
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RunCommand(FSharpFunc`2<CommandParams, CommandParams> setCommandParams, string args);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@89-376(RestoreParams this, RestoreParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@89-377(IComparer comp, RestoreParams this, RestoreParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@89-78(IEqualityComparer comp, RestoreParams this, Unit unitVar);
    internal static RestoreParams get_DefaultRestoreParams();
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static void Restore(FSharpFunc`2<RestoreParams, RestoreParams> setRestoreParams);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@159-379(BuildParams this, BuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@159-378(BuildParams this, BuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@159-381(IComparer comp, BuildParams this, BuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@159-380(IComparer comp, BuildParams this, object obj, BuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@159-79(IEqualityComparer comp, BuildParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@159-159(BuildParams this, BuildParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@159-160(BuildParams this, BuildParams obj, Unit unitVar);
    internal static BuildParams get_DefaultBuildParams();
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static void Build(FSharpFunc`2<BuildParams, BuildParams> setBuildParams);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@240-382(TestParams this, TestParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@240-383(IComparer comp, TestParams this, TestParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@240-80(IEqualityComparer comp, TestParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@240-161(TestParams this, object obj, IEqualityComparer comp, Unit unitVar);
    internal static TestParams get_DefaultTestParams();
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static void Test(FSharpFunc`2<TestParams, TestParams> setTestParams);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@316-384(PackParams this, PackParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@316-385(IComparer comp, PackParams this, PackParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@316-81(IEqualityComparer comp, PackParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@316-162(PackParams this, object obj, IEqualityComparer comp, Unit unitVar);
    internal static PackParams get_DefaultPackParams();
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static void Pack(FSharpFunc`2<PackParams, PackParams> setPackParams);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@391-387(PublishParams this, PublishParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@391-386(PublishParams this, PublishParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@391-389(IComparer comp, PublishParams this, PublishParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@391-388(IComparer comp, PublishParams this, PublishParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@391-82(IEqualityComparer comp, PublishParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@391-163(PublishParams this, PublishParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@391-164(PublishParams this, PublishParams obj, Unit unitVar);
    internal static PublishParams get_DefaultPublishParams();
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static void Publish(FSharpFunc`2<PublishParams, PublishParams> setPublishParams);
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SetVersionInProjectJson(string version, string fileName);
    public static string get_DotnetSDKPath();
    public static void set_DotnetSDKPath(string value);
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static string GetDotNetSDKVersionFromGlobalJson();
    internal static bool correctVersionInstalled@510(string sdkVersion, string exe);
    internal static string downloadSDK@541(string tempDir, string downloadPath, string archiveFileName);
    [ObsoleteAttribute("Please add 'open Fake.DotNet' and use 'DotNet.*' instead, see https://fake.build/dotnet-dotnet.html for an example (the fake 5 module is called Fake.DotNet.Cli)")]
public static string InstallDotNetSDK(string sdkVersion);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.DynamicsCRMHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static DynamicsCrmHelperParams DynamicsCrmHelperDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-49 { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static SolutionPackagerParams SolutionPackagerDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-50 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@34-482(DynamicsCrmHelperParams this, DynamicsCrmHelperParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@34-481(DynamicsCrmHelperParams this, DynamicsCrmHelperParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@34-484(DynamicsCrmHelperParams this, DynamicsCrmHelperParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@34-483(IComparer comp, DynamicsCrmHelperParams this, DynamicsCrmHelperParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@34-101(IEqualityComparer comp, DynamicsCrmHelperParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@34-196(DynamicsCrmHelperParams this, DynamicsCrmHelperParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@34-197(DynamicsCrmHelperParams this, DynamicsCrmHelperParams obj, Unit unitVar);
    public static DynamicsCrmHelperParams get_DynamicsCrmHelperDefaults();
    internal static string get_path2@32-49();
    public static SolutionPackagerParams get_SolutionPackagerDefaults();
    internal static string get_path2@32-50();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void PublishAll(FSharpFunc`2<DynamicsCrmHelperParams, DynamicsCrmHelperParams> setParams);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void ExportSolution(FSharpFunc`2<DynamicsCrmHelperParams, DynamicsCrmHelperParams> setParams);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void ImportSolution(FSharpFunc`2<DynamicsCrmHelperParams, DynamicsCrmHelperParams> setParams);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void SolutionPackager(FSharpFunc`2<SolutionPackagerParams, SolutionPackagerParams> setParams);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.DynamicsNav : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string getNAVClassicPath(string navClientVersion);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string getNAVPath(string navClientVersion);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string getNAVServicePath(string navClientVersion);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DynamicsNavParams createConnectionInfo(string navClientVersion, NavisionServerType serverMode, string serverName, string targetDatabase);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a reportError(string text, string logFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void import(DynamicsNavParams connectionInfo, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void export(DynamicsNavParams connectionInfo, string filter, string fileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ExportObjects(DynamicsNavParams connectionInfo, string filter, string fileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ExportAllObjects(DynamicsNavParams connectionInfo, string fileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ImportFile(DynamicsNavParams connectionInfo, string fileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateImportFile(string importFileName, IEnumerable`1<string> files);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ImportFiles(DynamicsNavParams connectionInfo, string importFileName, IEnumerable`1<string> files);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CompileWithFilter(string filter, DynamicsNavParams connectionInfo);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void CompileAll(DynamicsNavParams connectionInfo);
    public static void FullCompile(DynamicsNavParams connectionInfo);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@342-319(RTCParams this, RTCParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@342-320(IComparer comp, RTCParams this, RTCParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@342-65(IEqualityComparer comp, RTCParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@342-133(RTCParams this, object obj, IEqualityComparer comp, Unit unitVar);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RTCParams createRTCConnectionInfo(string navClientVersion, string serverName, string serviceTierName, int port, string company);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RunCodeunit(RTCParams connectionInfo, int codeunitID);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RunCodeunitWithSettings(RTCParams connectionInfo, string settingsFile, int codeunitID);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool OpenPage(RTCParams connectionInfo, int pageNo);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static IEnumerable`1<Process> getNAVProcesses();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void CloseAllNavProcesses(bool raiseExceptionIfNotFound);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void ensureAllNAVProcessesHaveStopped(TimeSpan timeout);
    internal static string findNext@459(string pattern, IEnumerable`1<string> messages);
    internal static FSharpOption`1<string> tryFindNext@465(string pattern, IEnumerable`1<string> messages);
    internal static FSharpList`1<Test> getTests@475(IEnumerable`1<string> messages);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpOption`1<TestResults> analyzeTestResults(string fileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<TestResults> analyzeXmlTestResults(string fileName, string testSuite);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void StartNavServiceTier(NavisionServerType serverMode, string navClientVersion);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void StopNavServiceTier(NavisionServerType serverMode, a navClientVersion);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.DynamicsNavFile : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex ModifiedRegex { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex VersionRegex { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex DateRegex { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex TimeRegex { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex ObjectRegex { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex ObjectSplitRegex { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string NavObjectDateFormat { get; }
    public static Regex get_ModifiedRegex();
    public static Regex get_VersionRegex();
    public static Regex get_DateRegex();
    public static Regex get_TimeRegex();
    public static Regex get_ObjectRegex();
    public static Regex get_ObjectSplitRegex();
    public static string get_NavObjectDateFormat();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replaceDateTimeInStringWithFormat(DateTime dateTime, string dateFormat, string text);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replaceDateTimeInString(DateTime dateTime, string text);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string removeModifiedFlag(string text);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string getVersionTagList(string text);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static String[] splitVersionTags(string tagList);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replaceInVersionTag(string versionTag, string newVersion, string tagList);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replaceVersionTagList(string text, string newTags);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replaceVersionTag(string versionTag, string newVersion, string sourceCode);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> getMissingRequiredTags(IEnumerable`1<string> requiredTags, IEnumerable`1<string> versionTags);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> getInvalidTags(IEnumerable`1<string> invalidTags, IEnumerable`1<string> versionTags);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<string, string> checkTagsInObjectString(IEnumerable`1<string> requiredTags, bool acceptPreTagged, IEnumerable`1<string> invalidTags, string objectString, string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<string, string> checkTagsInFile(IEnumerable`1<string> requiredTags, bool acceptPreTagged, IEnumerable`1<string> invalidTags, string fileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void modifyNavisionFiles(IEnumerable`1<string> requiredTags, bool acceptPreTagged, IEnumerable`1<string> invalidTags, string versionTag, string newVersion, bool removeModified, DateTime newDateTime, IEnumerable`1<string> fileNames);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setVersionTags(IEnumerable`1<string> requiredTags, bool acceptPreTagged, IEnumerable`1<string> invalidTags, string versionTag, string newVersion, bool removeModifiedFlag, DateTime newDateTime, IEnumerable`1<string> fileNames);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpList`1<NavObject> objectsInObjectString(string text);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string fileNameFromObject(NavObject navObject, string fileEnding);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void splitNavisionFiles(IEnumerable`1<string> fileNames, string destDir);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getTagVersionInVersionTagList(string versionTag, string tagList);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getTagVersionInObject(string versionTag, string sourceCode);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getHighestTagVersionInObjects(string versionTag, string sourceCode);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getHighestTagVersionInFiles(string versionTag, IEnumerable`1<string> fileNames);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("7")]
public static class Fake.EnvironmentHelper : object {
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string ProgramFiles { get; }
    [CompilationMappingAttribute("9")]
internal static string wow64@136-1 { get; }
    [CompilationMappingAttribute("9")]
internal static string globalArch@137-1 { get; }
    [CompilationMappingAttribute("9")]
internal static string arg@1-13 { get; }
    [CompilationMappingAttribute("9")]
internal static string detected@148-1 { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string ProgramFilesX86 { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string SystemRoot { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool isWindows { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool isUnix { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool isMacOS { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool isLinux { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static bool isMono { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>> monoVersion { get; }
    [CompilationMappingAttribute("9")]
internal static Type t@191-1 { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string monoPath { get; }
    [ObsoleteAttribute("Use Fake.Core.Process instead (FAKE0001 - package: Fake.Core.Process)")]
[CompilationMappingAttribute("9")]
public static string monoArguments { get; public set; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string TargetPlatformPrefix { get; public set; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> a@231-13 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> a@231-14 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> b@231-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> b@231-3 { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string msSdkBasePath { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string sdkBasePath { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string documentsFolder { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static string directorySeparator { get; }
    [CompilationMappingAttribute("9")]
internal static char copyOfStruct@272-1 { get; internal set; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationMappingAttribute("9")]
public static Encoding encoding { get; }
    [CompilationMappingAttribute("9")]
internal static string matchValue@283-3 { get; }
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static string environVar(string name);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string combinePaths(string path1, string path2);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string combinePathsNoTrim(string path1, string path2);
    [ObsoleteAttribute("Use Fake.IO.FileSystemOperators instead (FAKE0001 - package: Fake.IO.FileSystem)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_AtAt(string path1, string path2);
    [ObsoleteAttribute("Use Fake.IO.FileSystemOperators instead (FAKE0001 - package: Fake.IO.FileSystem)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_LessDivideGreater(string path1, string path2);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem)")]
public static string normalizePath(string path);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static FSharpList`1<Tuple`2<object, object>> environVars(EnvironmentVariableTarget target);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setEnvironVar(string name, string value);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setUserEnvironVar(string name, string value);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setMachineEnvironVar(string name, string value);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setProcessEnvironVar(string name, string value);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static void clearProcessEnvironVar(string name);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setBuildParam(string name, string value);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string environVarOrDefault(string name, string defaultValue);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static string environVarOrFail(string name);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool getEnvironmentVarAsBoolOrDefault(string varName, bool defaultValue);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static bool getEnvironmentVarAsBool(string varName);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static FSharpOption`1<string> environVarOrNone(string name);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static FSharpList`1<string> splitEnvironVar(string name);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static string appSetting(string name);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static bool hasBuildParam(string name);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getBuildParamOrDefault(string name, string defaultParam);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static string getBuildParam(string name);
    public static string get_ProgramFiles();
    internal static string get_wow64@136-1();
    internal static string get_globalArch@137-1();
    internal static string get_arg@1-13();
    internal static string get_detected@148-1();
    public static string get_ProgramFilesX86();
    public static string get_SystemRoot();
    public static bool get_isWindows();
    public static bool get_isUnix();
    public static bool get_isMacOS();
    public static bool get_isLinux();
    public static bool get_isMono();
    public static FSharpOption`1<Tuple`2<string, FSharpOption`1<Version>>> get_monoVersion();
    internal static Type get_t@191-1();
    internal static Version minimizeVersion@198-1(Version v);
    public static string get_monoPath();
    public static string get_monoArguments();
    public static void set_monoArguments(string value);
    [ObsoleteAttribute("Use Fake.Core.Process instead (FAKE0001 - package: Fake.Core.Process)")]
public static void platformInfoAction(ProcessStartInfo psi);
    public static string get_TargetPlatformPrefix();
    public static void set_TargetPlatformPrefix(string value);
    internal static FSharpOption`1<string> get_a@231-13();
    internal static FSharpOption`1<string> get_a@231-14();
    internal static FSharpOption`1<string> get_b@231-2();
    internal static FSharpOption`1<string> get_b@231-3();
    public static string get_msSdkBasePath();
    public static string get_sdkBasePath();
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static a getNewestTool(IEnumerable`1<a> possibleToolPaths);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static string getTargetPlatformDir(string platformVersion);
    public static string get_documentsFolder();
    public static string get_directorySeparator();
    internal static char get_copyOfStruct@272-1();
    internal static void set_copyOfStruct@272-1(char value);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static string convertWindowsToCurrentPath(string windowsPath);
    public static Encoding get_encoding();
    internal static string get_matchValue@283-3();
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static IEnumerable`1<string> getInstalledDotNetFrameworks();
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@314-45(IEqualityComparer comp, MachineDetails this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@314-94(MachineDetails this, object obj, IEqualityComparer comp, Unit unitVar);
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static IEnumerable`1<string> getDrivesInfo();
    [ObsoleteAttribute("Use Fake.Core.Environment instead (FAKE0001 - package: Fake.Core.Environment)")]
public static MachineDetails getMachineEnvironment();
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem)")]
[CompilationMappingAttribute("7")]
public static class Fake.FileHelper : object {
    [ObsoleteAttribute("Function is no more accessible (FAKE0003 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.recursively). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void recursively(FSharpFunc`2<DirectoryInfo, Unit> dirF, FSharpFunc`2<FileInfo, Unit> fileF, DirectoryInfo dir);
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - no longer supported)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setDirectoryReadOnly(bool readOnly, DirectoryInfo dir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.setReadOnlyRecursive)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SetDirReadOnly(bool readOnly, DirectoryInfo dir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.SilentCopy)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SetReadOnly(bool readOnly, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Directory.delete)")]
public static void DeleteDir(string path);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Directory.create)")]
public static void CreateDir(string path);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.File.create)")]
public static void CreateFile(string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.File.delete)")]
public static void DeleteFile(string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.File.deleteAll)")]
public static void DeleteFiles(IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.FileSystemInfo.(|File|Directory|))")]
public static FSharpChoice`2<FileInfo, Tuple`2<DirectoryInfo, IEnumerable`1<FileSystemInfo>>> |File|Directory|(FileSystemInfo fileSysInfo);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.File.(|EndsWith|_|))")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Unit> |EndsWith|_|(string extension, string file);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.FileInfo.(|FullName|))")]
public static string |FileInfoFullName|(FileInfo f);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.FileInfo.(|NameSections|))")]
public static Tuple`3<string, string, string> |FileInfoNameSections|(FileInfo f);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CopyFile)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyFile(string target, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void DoCopyFile(string targetName, string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CopyFileIntoSubFolder)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyFileIntoSubFolder(string target, string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CopyFileWithSubfolder)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyFileWithSubfolder(string baseDir, string target, string fileName);
    internal static FSharpFunc`2<IEnumerable`1<string>, Unit> copyFiles@171(string target, string dir);
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - no longer supported)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyWithSubfoldersTo(string target, IEnumerable`1<FileIncludes> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.Copy)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Copy(string target, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CopyTo)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyTo(string target, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CopyCached)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> CopyCached(string target, string cacheDir, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.Rename)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Rename(string target, string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.SilentCopy)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SilentCopy(string target, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CopyFiles)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyFiles(string target, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - no longer supported)")]
public static bool excludeSVNFiles(string path);
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - no longer supported)")]
public static bool allFiles(string path);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CopyDir)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyDir(string target, string source, FSharpFunc`2<string, bool> filterFile);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CleanDir)")]
public static void CleanDir(string path);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CleanDirs)")]
public static void CleanDirs(IEnumerable`1<string> dirs);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.DeleteDirs)")]
public static void DeleteDirs(IEnumerable`1<string> dirs);
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - no longer supported)")]
public static IEnumerable`1<String[]> ReadCSVFile(string file);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.AppendTextFiles)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void AppendTextFiles(string newFileName, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.FileInfo.contentIsEqualTo)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool FilesAreEqual(FileInfo first, FileInfo second);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CompareFiles)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool CompareFiles(bool delete, string originalFileName, string compareFileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.TestDir)")]
public static bool TestDir(string path);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.TestFile)")]
public static bool TestFile(string path);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.GeneratePatchWithFindOldFileFunction)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void GeneratePatchWithFindOldFileFunction(string lastReleaseDir, string patchDir, IEnumerable`1<string> srcFiles, FSharpFunc`2<string, FSharpFunc`2<string, string>> findOldFileF);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.GeneratePatch)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void GeneratePatch(string lastReleaseDir, string patchDir, IEnumerable`1<string> srcFiles);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.copyRecursiveTo. NB: parameters order changed)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> copyRecursive(DirectoryInfo dir, DirectoryInfo outputDir, bool overwrite);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.CopyRecursive)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<bool, FSharpList`1<string>> CopyRecursive(string dir, string outputDir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.MoveFile)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void MoveFile(string target, string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.WriteConfigFile)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void WriteConfigFile(string configFileName, IEnumerable`1<Tuple`2<a, b>> parameters);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.ReplaceInFiles)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ReplaceInFiles(IEnumerable`1<Tuple`2<string, string>> replacements, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.RegexReplaceInFileWithEncoding)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RegexReplaceInFileWithEncoding(string pattern, string replacement, Encoding encoding, string file);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Shell.RegexReplaceInFileWithEncoding)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RegexReplaceInFilesWithEncoding(string pattern, string replacement, Encoding encoding, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.File.getVersion)")]
public static string FileVersion(string fileName);
    [ObsoleteAttribute("Open System.IO and use Path.GetExtension")]
public static string ext(string fileName);
    [ObsoleteAttribute("Open System.IO and use Path.ChangeExtension")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string changeExt(string extension, string fileName);
    [ObsoleteAttribute("Open System.IO and use System.String.Equals(Path.GetExtension fileName, extension, System.StringComparison.InvariantCultureIgnoreCase)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool hasExt(string extension, string fileName);
    [ObsoleteAttribute("Open System.IO and use Path.GetFileName")]
public static string filename(string path);
    [ObsoleteAttribute("Open System.IO and use Path.GetFileNameWithoutExtension")]
public static string fileNameWithoutExt(string path);
    [ObsoleteAttribute("This was a typo - please use fileNameWithoutExt")]
public static string filenameWithouExt(string path);
    [ObsoleteAttribute("Open System.IO and use Path.GetDirectoryName")]
public static string directory(string path);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Please use nuget 'Fake.IO.FileSystem' and Fake.IO.Globbing.Operators instead")]
[CompilationMappingAttribute("7")]
public static class Fake.FileSystem : object {
    [CompilationMappingAttribute("9")]
internal static string defaultBaseDir { get; }
    internal static string fullDir@30-1(FileIncludes this, string pattern);
    internal static string get_defaultBaseDir();
    [ObsoleteAttribute("Please use nuget 'Fake.IO.FileSystem' and Fake.IO.Globbing.Operators instead")]
public static FileIncludes Include(string x);
    [ObsoleteAttribute("Please use nuget 'Fake.IO.FileSystem' and Fake.IO.Globbing.Operators instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileIncludes SetBaseDir(string dir, FileIncludes fileIncludes);
    [ObsoleteAttribute("Please use nuget 'Fake.IO.FileSystem' and Fake.IO.Globbing.Operators instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileIncludes op_PlusPlus(FileIncludes x, string pattern);
    [ObsoleteAttribute("Please use nuget 'Fake.IO.FileSystem' and Fake.IO.Globbing.Operators instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileIncludes op_MinusMinus(FileIncludes x, string pattern);
    [ObsoleteAttribute("Please use nuget 'Fake.IO.FileSystem' and Fake.IO.Globbing.Operators instead")]
public static FileIncludes op_BangBang(string x);
    [ObsoleteAttribute("Please use nuget 'Fake.IO.FileSystem' and Fake.IO.Globbing.Tools instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findToolInSubPath(string toolname, string defaultPath);
    [ObsoleteAttribute("Please use nuget 'Fake.IO.FileSystem' and Fake.IO.Globbing.Tools instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findToolFolderInSubPath(string toolname, string defaultPath);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem)")]
[CompilationMappingAttribute("7")]
public static class Fake.FileSystemHelper : object {
    [CompilationMappingAttribute("9")]
public static string currentDirectory { get; }
    [CompilationMappingAttribute("9")]
public static string fullAssemblyPath { get; }
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.ofPath)")]
public static DirectoryInfo directoryInfo(string path);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.FileInfo.ofPath)")]
public static FileInfo fileInfo(string path);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.FileSystemInfo.ofPath)")]
public static FileSystemInfo fileSystemInfo(string path);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Path.getFullName)")]
public static string FullName(string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Path.getDirectory)")]
public static string DirectoryName(string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.getSubDirectories)")]
public static DirectoryInfo[] subDirectories(DirectoryInfo dir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.getFiles)")]
public static FileInfo[] filesInDir(DirectoryInfo dir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.getMatchingFiles)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileInfo[] filesInDirMatching(string pattern, DirectoryInfo dir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.getMatchingFilesRecursive)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileInfo[] filesInDirMatchingRecursive(string pattern, DirectoryInfo dir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.tryFindFirstMatchingFile)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> TryFindFirstMatchingFile(string pattern, string dir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.findFirstMatchingFile)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string FindFirstMatchingFile(string pattern, string dir);
    public static string get_currentDirectory();
    public static string get_fullAssemblyPath();
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.File.exists)")]
public static bool fileExists(string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.File.checkExists)")]
public static void checkFileExists(string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.File.allExist)")]
public static bool allFilesExist(IEnumerable`1<string> files);
    public static string normalizeFileName(string fileName);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.isSubfolderOf)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isSubfolderOf(DirectoryInfo dir2, DirectoryInfo dir1);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.containsFile. NB: reverse parameters)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isInFolder(DirectoryInfo dir, FileInfo fileInfo);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.exists)")]
public static bool directoryExists(string dir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.DirectoryInfo.ensure)")]
public static void ensureDirExists(DirectoryInfo dir);
    [ObsoleteAttribute("Use Fake.IO instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Directory.ensure)")]
public static void ensureDirectory(string dir);
    public static bool isDirectory(string path);
    public static bool isFile(string path);
    public static bool isValidPath(string path);
}
[ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `FileSystem.Shell`")]
[CompilationMappingAttribute("7")]
public static class Fake.FileUtils : object {
    [ObsoleteAttribute("FAKE0003 Please open an issue if you used this API")]
[CompilationMappingAttribute("9")]
public static Stack`1<string> dirStack { get; }
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.rm`")]
public static void rm(string fileName);
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.rm_rf`")]
public static void rm_rf(string f);
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.mkdir`")]
public static void mkdir(string path);
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.cp_r`")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void cp_r(string src, string dest);
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.cp`")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void cp(string src, string dest);
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.chdir`")]
public static void chdir(string path);
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.cd`")]
public static void cd(string path);
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.pwd`")]
public static string pwd();
    public static Stack`1<string> get_dirStack();
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.pushd`")]
public static void pushd(string path);
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.popd`")]
public static void popd();
    [ObsoleteAttribute("FAKE0001 Use `open Fake.IO` and `Shell.mv`")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void mv(string src, string dest);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.FixieHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static FixieParams FixieDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-41 { get; }
    public static FixieParams get_FixieDefaults();
    internal static string get_path2@32-41();
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendCustomOptions@48(FSharpFunc`2<string, string> option, IEnumerable`1<Tuple`2<string, a>> options);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Fixie(FSharpFunc`2<FixieParams, FixieParams> setParams, IEnumerable`1<string> assemblies);
}
[ObsoleteAttribute("Use Fake.DotNet.Fsc instead (FAKE0001 - package: Fake.DotNet.Fsc - module: Fake.DotNet.Fsc)")]
[CompilationMappingAttribute("7")]
public static class Fake.FscHelper : object {
    [ObsoleteAttribute("Use FscHelper.compileFiles instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int fscList(FSharpList`1<string> srcFiles, FSharpList`1<string> opts);
    [ObsoleteAttribute("Use FscHelper.compile instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int fsc(FSharpFunc`2<FscParams, FscParams> setParams, FSharpList`1<string> inputFiles);
    [ObsoleteAttribute("Use FscHelper.Compile instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Fsc(FSharpFunc`2<FscParams, FscParams> setParams, FSharpList`1<string> inputFiles);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Fsc module instead")]
public static string resourceStr(string _arg1_0, FSharpOption`1<string> _arg1_1, FSharpOption`1<Access> _arg1_2);
    internal static string argp@374-7(string s, string p);
    internal static string sargp@376-7(string s, string p);
    internal static string togl@380-6(string s, bool b);
    internal static string stogl@382-1(string s, bool b);
    internal static string argls@384-5(string s, FSharpList`1<string> ls);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Fsc module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int compileFiles(FSharpList`1<string> srcFiles, FSharpList`1<string> opts);
    [ObsoleteAttribute("FAKE0001 Use the function CompileWithResult in the Fake.DotNet.Fsc module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int compile(FSharpList`1<FscParam> fscParams, FSharpList`1<string> inputFiles);
    [ObsoleteAttribute("FAKE0001 Use the Fake.DotNet.Fsc module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Compile(FSharpList`1<FscParam> fscParams, FSharpList`1<string> inputFiles);
}
[ObsoleteAttribute("use Fake.DotNet.FSFormatting instead")]
[CompilationMappingAttribute("7")]
public static class Fake.FSharpFormatting : object {
    [ObsoleteAttribute("use Fake.DotNet.FSFormatting instead")]
[CompilationMappingAttribute("9")]
public static string toolPath { get; public set; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-27 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-28 { get; }
    public static string get_toolPath();
    public static void set_toolPath(string value);
    internal static string get_path2@32-27();
    internal static string get_path2@32-28();
    [ObsoleteAttribute("use Fake.DotNet.FSFormatting instead")]
public static void run(string command);
    [ObsoleteAttribute("use Fake.DotNet.FSFormatting instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateDocs(string source, string outputDir, string template, IEnumerable`1<Tuple`2<string, string>> projectParameters);
    [ObsoleteAttribute("use Fake.DotNet.FSFormatting instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateDocsForDlls(string outputDir, string templatesDir, IEnumerable`1<Tuple`2<string, string>> projectParameters, string sourceRepo, IEnumerable`1<string> dllFiles);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.FSIHelper : object {
    internal static string FSIPath { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex loadRegex { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex rAssemblyRegex { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex searchPathRegex { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string fsiPath { get; }
    [CompilationMappingAttribute("9")]
internal static string ev@141-1 { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Regex hashRegex { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSIPath();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static Regex createDirectiveRegex(string id);
    public static Regex get_loadRegex();
    public static Regex get_rAssemblyRegex();
    public static Regex get_searchPathRegex();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<string> extractDirectives(Regex regex, string scriptContents);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static IEnumerable`1<string> getAllScriptContents(IEnumerable`1<Script> pathsAndContents);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static IEnumerable`1<string> getIncludedAssembly(string scriptContents);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static IEnumerable`1<string> getSearchPaths(string scriptContents);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static IEnumerable`1<Script> getAllScripts(string scriptPath);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getScriptHash(IEnumerable`1<Script> pathsAndContents, IEnumerable`1<string> fsiOptions);
    public static string get_fsiPath();
    internal static string get_ev@141-1();
    [CompilerGeneratedAttribute]
internal static FSharpChoice`2<FsiArgs, string> parse$cont@168-2(String[] args, int i, string fsxPath, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<ProcessStartInfo, Unit> FsiStartInfo(string workingDirectory, FsiArgs _arg1, IEnumerable`1<Tuple`2<string, string>> environmentVars);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void fsiStartInfo(string script, string workingDirectory, IEnumerable`1<Tuple`2<string, string>> env, ProcessStartInfo info);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, IEnumerable`1<ConsoleMessage>> executeFSI(string workingDirectory, string script, IEnumerable`1<Tuple`2<string, string>> env);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool executeFSIWithArgs(string workingDirectory, string script, FSharpList`1<string> extraFsiArgs, IEnumerable`1<Tuple`2<string, string>> env);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, IEnumerable`1<ConsoleMessage>> executeFSIWithArgsAndReturnMessages(string workingDirectory, string script, FSharpList`1<string> extraFsiArgs, IEnumerable`1<Tuple`2<string, string>> env);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, IEnumerable`1<ConsoleMessage>> executeFSIWithScriptArgsAndReturnMessages(string script, String[] scriptArgs);
    public static Regex get_hashRegex();
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@234-69(IEqualityComparer comp, CacheInfo this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@234-137(CacheInfo this, object obj, IEqualityComparer comp, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CacheInfo getCacheInfoFromScript(bool printDetails, IEnumerable`1<string> fsiOptions, string scriptPath);
    internal static string fullName@341-6(string endString, string i);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static Tuple`3<string, FSharpFunc`2<string, string>, FSharpFunc`2<string, FSharpOption`1<string>>> nameParser(string scriptFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool runScriptCached(bool printDetails, CacheInfo cacheInfo, TextWriter out, TextWriter err);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void handleCaching(bool printDetails, IFsiSession session, a fsiErrorOutput, DirectoryInfo cacheDir, CacheInfo cacheInfo);
    internal static Tuple`2<string, string> getScriptAndHash@472(string fileName);
    internal static FSharpFunc`2<SourceLevels, FSharpFunc`2<TraceListener, Unit>> setupListener@522(TraceOptions traceOptions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool runScriptUncached(bool useCache, IEnumerable`1<string> fsiOptions, bool printDetails, CacheInfo cacheInfo, TextWriter out, TextWriter err);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool runFAKEScriptWithFsiArgsAndRedirectMessages(bool printDetails, FsiArgs _arg1, IEnumerable`1<Tuple`2<string, string>> env, FSharpFunc`2<string, Unit> onErrMsg, FSharpFunc`2<string, Unit> onOutMsg, bool useCache);
    internal static FSharpFunc`2<string, Unit> onMessage(bool isError);
    internal static FSharpFunc`2<string, Unit> appendMessage@649-4(FSharpRef`1<FSharpList`1<ConsoleMessage>> messages, bool isError);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, FSharpList`1<ConsoleMessage>> executeBuildScriptWithArgsAndFsiArgsAndReturnMessages(string script, String[] scriptArgs, String[] fsiArgs, bool useCache);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, FSharpList`1<ConsoleMessage>> executeBuildScriptWithArgsAndReturnMessages(string script, String[] scriptArgs, bool useCache);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool runBuildScriptWithFsiArgsAt(bool printDetails, FsiArgs _arg1, IEnumerable`1<Tuple`2<string, string>> env, bool useCache);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool runBuildScriptAt(bool printDetails, string script, FSharpList`1<string> extraFsiArgs, IEnumerable`1<Tuple`2<string, string>> env, bool useCache);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool runBuildScript(bool printDetails, string script, FSharpList`1<string> extraFsiArgs, IEnumerable`1<Tuple`2<string, string>> env, bool useCache);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.FtpHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FtpServerInfo getServerInfo(string serverNameIp, string user, string password, string ftpMethod);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeChunkToReqStream(Byte[] chunk, Stream reqStrm, BinaryReader br);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getSubstring(int fromPos, string str, int toPos);
    internal static int lastSlashPos(string str);
    internal static bool dirNameIsValid(string dirName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool regexCheck(string fname, string ftpContents);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getFtpDirContents(string server, string user, string pwd, string dirPath);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void uploadAFile(string server, string user, string pwd, string destPath, string srcPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkInExistingDirList(string server, string user, string pwd, string destPath, string fname);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isFolderPresent(string server, string user, string pwd, string destPath);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createAFolder(string server, string user, string pwd, string destPath);
    [CompilerGeneratedAttribute]
internal static bool uploadAFolder$cont@142(string rootDir, Unit unitVar);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void uploadAFolder(string server, string user, string pwd, string srcPath, string rootDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void upload(string server, string user, string pwd, FileSystemInfo fsi, string rootDir);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteAFile(string server, string user, string pwd, string destPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> getFolderContents(string server, string user, string pwd, string destPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void deleteEmptyFolder(string server, string user, string pwd, string destPath);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteAFolder(string server, string user, string pwd, string destPath);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.FuchuHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void Fuchu(IEnumerable`1<string> testExes);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Please use nuget 'Fake.DotNet.FxCop', open 'Fake.DotNet' and use module FxCop instead.")]
[CompilationMappingAttribute("7")]
public static class Fake.FxCopHelper : object {
    [ObsoleteAttribute("Please use nuget 'Fake.DotNet.FxCop', open 'Fake.DotNet' and use FxCop.Params.Create() instead")]
[CompilationMappingAttribute("9")]
public static FxCopParams FxCopDefaults { get; }
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@26-60(IEqualityComparer comp, FxCopParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@26-125(FxCopParams this, FxCopParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@26-124(FxCopParams this, FxCopParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@26-127(FxCopParams this, FxCopParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@26-126(FxCopParams this, FxCopParams obj, Unit unitVar);
    internal static int getErrorValue@59(string resultFile, string s);
    [ObsoleteAttribute("Please use nuget 'Fake.DotNet.FxCop', open 'Fake.DotNet' and use FxCop.checkForErrors instead.")]
public static Tuple`4<int, int, int, int> checkForErrors(string resultFile);
    public static FxCopParams get_FxCopDefaults();
    internal static void append@106(FSharpRef`1<StringBuilder> args, bool predicate, string s);
    internal static void appendFormat@109(FSharpRef`1<StringBuilder> args, string format, string value);
    [CompilerGeneratedAttribute]
internal static void FxCop$cont@147(FxCopParams param, Unit unitVar);
    [ObsoleteAttribute("Please use nuget 'Fake.DotNet.FxCop', open 'Fake.DotNet' and use FxCop.Run instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FxCop(FSharpFunc`2<FxCopParams, FxCopParams> setParams, IEnumerable`1<string> assemblies);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.GACHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string gacutilToolPath { get; }
    [CompilationMappingAttribute("9")]
internal static FileIncludes arg@1-15 { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string GACUtil { get; public set; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static GACParams GACDefaults { get; }
    public static string get_gacutilToolPath();
    internal static FileIncludes get_arg@1-15();
    public static string get_GACUtil();
    public static void set_GACUtil(string value);
    public static GACParams get_GACDefaults();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void GAC(FSharpFunc`2<GACParams, GACParams> setParams, string command);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Branches : object {
    internal static FSharpList`1<string> cleanBranches(IEnumerable`1<string> text);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
public static FSharpList`1<string> getLocalBranches(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
public static FSharpList`1<string> getRemoteBranches(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
public static FSharpList`1<string> getAllBranches(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getSHA1(string repositoryDir, string commit);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findMergeBase(string repositoryDir, string commit1, string commit2);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int revisionsBetween(string repositoryDir, string commit1, string commit2);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkoutBranch(string repositoryDir, string branch);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkoutTracked(string repositoryDir, string trackBranch, string branch);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkoutNewBranch(string repositoryDir, string baseBranch, string branch);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkout(string repositoryDir, bool create, string branch);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createBranch(string repositoryDir, string newBranchName, string commit);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteBranch(string repositoryDir, bool force, string branch);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void tag(string repositoryDir, string tag);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteTag(string repositoryDir, string tag);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
public static void push(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pushTag(string repositoryDir, string remote, string tag);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pushBranch(string repositoryDir, string remote, string branch);
    [ObsoleteAttribute("Use Fake.Tools.Git.Branches instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pull(string repositoryDir, string remote, string branch);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.CommandHelper : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationMappingAttribute("9")]
public static TimeSpan gitTimeOut { get; public set; }
    internal static string GitPath { get; }
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationMappingAttribute("9")]
public static string gitPath { get; }
    public static TimeSpan get_gitTimeOut();
    public static void set_gitTimeOut(TimeSpan value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_GitPath();
    public static string get_gitPath();
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`3<bool, List`1<string>, string> runGitCommand(string repositoryDir, string command);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
public static a runGitCommandf(PrintfFormat`4<a, Unit, string, FSharpFunc`2<string, Tuple`3<bool, List`1<string>, string>>> fmt);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static List`1<string> getGitResult(string repositoryDir, string command);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void fireAndForgetGitCommand(string repositoryDir, string command);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool directRunGitCommand(string repositoryDir, string command);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void directRunGitCommandAndFail(string repositoryDir, string command);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void gitCommand(string repositoryDir, string command);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a gitCommandf(string repositoryDir, PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void showGitCommand(string repositoryDir, string command);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string runSimpleGitCommand(string repositoryDir, string command);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
public static string fixPath(string path);
    internal static DirectoryInfo findGitDir@118-1(DirectoryInfo dirInfo);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommandHelper instead")]
public static DirectoryInfo findGitDir(string repositoryDir);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Commit instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Commit : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.Commit instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Commit(string repositoryDir, string message);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.CommitMessage instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.CommitMessage : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.CommitMessage instead")]
public static FSharpList`1<FileInfo> getCommitMessageFileInfos(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommitMessage instead")]
public static string getCommitMessage(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.CommitMessage instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setMessage(string repositoryDir, string text);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.FileStatus : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<FileStatus, string>> getChangedFiles(string repositoryDir, string revision1, string revision2);
    [ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
public static IEnumerable`1<Tuple`2<FileStatus, string>> getAllFiles(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<FileStatus, string>> getChangedFilesInWorkingCopy(string repositoryDir, string revision);
    [ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
public static FSharpList`1<string> getConflictedFiles(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
public static bool isInTheMiddleOfConflictedMerge(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
public static string getRebaseDir(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
public static bool isInTheMiddleOfRebase(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
public static bool isInTheMiddleOfPatch(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.FileStatus instead")]
public static void cleanWorkingCopy(string repositoryDir);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Information : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
[CompilationMappingAttribute("9")]
public static Regex versionRegex { get; }
    public static Regex get_versionRegex();
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static string getVersion(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isVersionHigherOrEqual(string currentVersion, string referenceVersion);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static string extractGitVersion(string version);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static bool isGitVersionHigherOrEqual(string referenceVersion);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static string getBranchName(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static string getCurrentSHA1(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static void showStatus(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static bool isCleanWorkingCopy(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string showName(string repositoryDir, string sha1);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isAheadOf(string repositoryDir, string rev1, string rev2);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static string describe(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static string shortlog(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static string getLastTag();
    [ObsoleteAttribute("Use Fake.Tools.Git.Information instead")]
public static string getCurrentHash();
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Merge instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Merge : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.Merge instead")]
public static string FastForwardFlag { get; }
    [ObsoleteAttribute("Use Fake.Tools.Git.Merge instead")]
public static string NoFastForwardFlag { get; }
    [ObsoleteAttribute("Use Fake.Tools.Git.Merge instead")]
public static string getMergeMessage(string repositoryDir);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_FastForwardFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_NoFastForwardFlag();
    [ObsoleteAttribute("Use Fake.Tools.Git.Merge instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static MergeType compareBranches(string repositoryDir, string local, string remote);
    [ObsoleteAttribute("Use Fake.Tools.Git.Merge instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void merge(string repositoryDir, string flags, string branch);
}
[ObsoleteAttribute("Use Fake.Tools.Git.Rebase instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Rebase : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.Rebase instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void start(string repositoryDir, string onTopOfBranch);
    [ObsoleteAttribute("Use Fake.Tools.Git.Rebase instead")]
public static void abort(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Rebase instead")]
public static void continueRebase(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Rebase instead")]
public static void skip(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Rebase instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rollBackAndUseMerge(string repositoryDir, string onTopOfBranch);
    [ObsoleteAttribute("Use Fake.Tools.Git.Rebase instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rebaseOrFallbackOnMerge(string repositoryDir, string onTopOfBranch);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Repository instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Repository : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.Repository instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void clone(string workingDir, string repoUrl, string toPath);
    [ObsoleteAttribute("Use Fake.Tools.Git.Repository instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void cloneSingleBranch(string workingDir, string repoUrl, string branchName, string toPath);
    [ObsoleteAttribute("Use Fake.Tools.Git.Repository instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void init(string repositoryDir, bool bare, bool shared);
    [ObsoleteAttribute("Use Fake.Tools.Git.Repository instead")]
public static void fullclean(string repositoryDir);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Reset instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Reset : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string addArgs(string commit, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string resetOrCheckout(string file, string mode);
    [ObsoleteAttribute("Use Fake.Tools.Git.Reset instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void soft(string repositoryDir, string commit, string file);
    [ObsoleteAttribute("Use Fake.Tools.Git.Reset instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void mixed(string repositoryDir, string commit, string file);
    [ObsoleteAttribute("Use Fake.Tools.Git.Reset instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void hard(string repositoryDir, string commit, string file);
    [ObsoleteAttribute("Use Fake.Tools.Git.Reset instead")]
public static void ResetSoft(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Reset instead")]
public static void ResetMixed(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Reset instead")]
public static void ResetHard(string repositoryDir);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.SanityChecks instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.SanityChecks : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.SanityChecks instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkRevisionExists(string repositoryDir, string revision1);
    [ObsoleteAttribute("Use Fake.Tools.Git.SanityChecks instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkIfBranchExists(string repositoryDir, string branch);
    [ObsoleteAttribute("Use Fake.Tools.Git.SanityChecks instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkIfBranchIsAbsent(string repositoryDir, string branch);
    [ObsoleteAttribute("Use Fake.Tools.Git.SanityChecks instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkIsLocalBranch(string repositoryDir, string branch);
    [ObsoleteAttribute("Use Fake.Tools.Git.SanityChecks instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkIsRemoteBranch(string repositoryDir, string branch);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Sha1 instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.SHA1 : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.Sha1 instead")]
public static string calcSHA1(string text);
    [ObsoleteAttribute("Use Fake.Tools.Git.Sha1 instead")]
public static string calcGitSHA1(string text);
    [ObsoleteAttribute("Use Fake.Tools.Git.Sha1 instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string showObjectHash(string repositoryDir, string fileName);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Staging instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Staging : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.Staging instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`3<bool, List`1<string>, string> StageFile(string repositoryDir, string file);
    [ObsoleteAttribute("Use Fake.Tools.Git.Staging instead")]
public static void StageAll(string repositoryDir);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Stash instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Stash : object {
    [ObsoleteAttribute("Use Fake.Tools.Git.Stash instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void push(string repositoryDir, string message);
    [ObsoleteAttribute("Use Fake.Tools.Git.Stash instead")]
public static void pop(string repositoryDir);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Tools.Git.Submodule instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Git.Submodule : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@11-329(Submodule this, Submodule obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@11-330(Submodule this, Submodule objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@11-68(Submodule this, Unit unitVar);
    internal static string trimChars(string s);
    [ObsoleteAttribute("Use Fake.Tools.Git.Submodule instead")]
public static IEnumerable`1<Submodule> getSubModules(string repositoryDir);
    [ObsoleteAttribute("Use Fake.Tools.Git.Submodule instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void init(string superRepositoryDir, string name);
    [ObsoleteAttribute("Use Fake.Tools.Git.Submodule instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void add(string superRepositoryDir, string remotePath, string localPath, string branch);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.Tools.GitVersion module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.GitVersionHelper : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.GitVersion module instead")]
[CompilationMappingAttribute("9")]
public static GitversionParams GitversionDefaults { get; }
    public static GitversionParams get_GitversionDefaults();
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@25-108(IEqualityComparer comp, GitVersionProperties this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@25-206(GitVersionProperties this, GitVersionProperties that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@25-205(GitVersionProperties this, GitVersionProperties that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@25-208(GitVersionProperties this, GitVersionProperties obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@25-207(GitVersionProperties this, GitVersionProperties obj, Unit unitVar);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.GitVersion module instead. Function GitVersion.generateProperties")]
public static GitVersionProperties GitVersion(FSharpFunc`2<GitversionParams, GitversionParams> setParams);
}
[ObsoleteAttribute("Please use Fake.IO.Globbing.Glob instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Globbing : object {
    [CompilationMappingAttribute("9")]
internal static Regex driveRegex { get; }
    [ObsoleteAttribute("This is no longer supported, please open an issue if you had a need for it.")]
[CompilationMappingAttribute("9")]
public static ConcurrentDictionary`2<string, Regex> globRegexCache { get; }
    [ObsoleteAttribute("Please use Fake.IO.Globbing.Glob instead")]
public static string normalizePath(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> checkSubDirs(bool absolute, string dir, string root);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> buildPaths(FSharpList`1<string> acc, FSharpList`1<SearchOption> input);
    internal static Regex get_driveRegex();
    internal static string normalizeOutputPath(string p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getRoot(string baseDirectory, string pattern);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> search(string baseDir, string input);
    internal static Regex compileGlobToRegex(string pattern);
    public static ConcurrentDictionary`2<string, Regex> get_globRegexCache();
    [ObsoleteAttribute("Please use Fake.IO.Globbing.Glob instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isMatch(string pattern, string path);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.HipChatNotificationHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static HipChatNotificationParams HipChatNotificationDefaults { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-444(HipChatNotificationParams this, HipChatNotificationParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-445(HipChatNotificationParams this, HipChatNotificationParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@12-91(HipChatNotificationParams this, Unit unitVar);
    public static HipChatNotificationParams get_HipChatNotificationDefaults();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static HipChatNotificationParams validateParams(HipChatNotificationParams param);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static int HipChatNotification(FSharpFunc`2<HipChatNotificationParams, HipChatNotificationParams> setParams);
}
[ObsoleteAttribute("Use Fake.Api.HockeyApp instead (open Fake.Api and use 'HockeyApp.')")]
[CompilationMappingAttribute("7")]
public static class Fake.HockeyAppHelper : object {
    [CompilationMappingAttribute("9")]
public static HockeyAppUploadParams HockeyAppUploadDefaults { get; }
    [CompilationMappingAttribute("9")]
public static HockeyAppVersionParams HockeyAppVersionDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string nl { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-447(HockeyResponse this, HockeyResponse obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-446(HockeyResponse this, HockeyResponse obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-449(HockeyResponse this, HockeyResponse objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-448(HockeyResponse this, HockeyResponse objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@50-92(HockeyResponse this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@50-184(HockeyResponse this, HockeyResponse that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@50-185(HockeyResponse this, HockeyResponse obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@84-450(HockeyVersionResponse this, HockeyVersionResponse obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@84-451(HockeyVersionResponse this, HockeyVersionResponse objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@84-93(HockeyVersionResponse this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@84-186(HockeyVersionResponse this, object obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@142-455(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@142-454(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@142-453(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@142-452(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@142-459(IComparer comp, HockeyAppUploadParams this, HockeyAppUploadParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@142-458(IComparer comp, HockeyAppUploadParams this, HockeyAppUploadParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@142-457(IComparer comp, HockeyAppUploadParams this, HockeyAppUploadParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@142-456(IComparer comp, HockeyAppUploadParams this, HockeyAppUploadParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@142-94(IEqualityComparer comp, HockeyAppUploadParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@142-188(HockeyAppUploadParams this, HockeyAppUploadParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@142-187(HockeyAppUploadParams this, HockeyAppUploadParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@142-189(HockeyAppUploadParams this, HockeyAppUploadParams obj, Unit unitVar);
    public static HockeyAppUploadParams get_HockeyAppUploadDefaults();
    public static HockeyAppVersionParams get_HockeyAppVersionDefaults();
    internal static string get_nl();
    internal static HockeyAppUploadParams validateParams(HockeyAppUploadParams param);
    internal static HockeyAppVersionParams validateVersionParams(HockeyAppVersionParams param);
    internal static IEnumerable`1<string> toCurlArgs(HockeyAppUploadParams param);
    internal static IEnumerable`1<string> toVersionCurlArgs(HockeyAppVersionParams param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TResponse processHockeyAppCmd(TParam defaults, FSharpFunc`2<TParam, TParam> setParams, FSharpFunc`2<TParam, TParam> validateParam, FSharpFunc`2<TParam, IEnumerable`1<string>> toCurlArgs);
    [ObsoleteAttribute("Use Fake.Api.HockeyApp instead (open Fake.Api and use 'HockeyApp.')")]
public static HockeyResponse HockeyApp(FSharpFunc`2<HockeyAppUploadParams, HockeyAppUploadParams> setParams);
    [ObsoleteAttribute("Use Fake.Api.HockeyApp instead (open Fake.Api and use 'HockeyApp.')")]
public static HockeyVersionResponse HockeyAppVersion(FSharpFunc`2<HockeyAppVersionParams, HockeyAppVersionParams> setParams);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.HTMLHelpWorkShopHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> CompileHTMLHelpProject(string helpCompiler, string projectFile);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.ILMergeHelper : object {
    [ObsoleteAttribute("Please use nuget 'Fake.DotNet.ILMerge', open 'Fake.DotNet' and use ILMerge.Params.Create() instead")]
[CompilationMappingAttribute("9")]
public static ILMergeParams ILMergeDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-35 { get; }
    public static ILMergeParams get_ILMergeDefaults();
    internal static string get_path2@32-35();
    [ObsoleteAttribute("Please use nuget 'Fake.DotNet.ILMerge', open 'Fake.DotNet' and use ILMerge.getArguments instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getArguments(string outputFile, string primaryAssembly, ILMergeParams parameters);
    [ObsoleteAttribute("Please use nuget 'Fake.DotNet.ILMerge', open 'Fake.DotNet' and use ILMerge.run instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ILMerge(FSharpFunc`2<ILMergeParams, ILMergeParams> setParams, string outputFile, string primaryAssembly);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Installer.Wix : object {
    [CompilationMappingAttribute("9")]
internal static int fileCount { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, int> dirs { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, int> compRefs { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, int> comps { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static File FileDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static ServiceControl ServiceControlDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static ServiceConfig ServiceConfigDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static ServiceDependency ServiceDependencyDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static ServiceInstall ServiceInstallDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static RegistryValue RegistryValueDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static RegistryKey RegistryKeyDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static ComponentRef ComponentRefDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static DirectoryRef DirectoryRefDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static Component ComponentDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static YesOrNo Win64@708 { get; }
    [CompilationMappingAttribute("9")]
internal static Dir DirDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static Params Defaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-12 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-15 { get; }
    [CompilationMappingAttribute("9")]
internal static Feature FeatureDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static CustomAction CustomActionDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static CustomActionExecution CustomActionExecutionDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static UIRef UIRefDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static Upgrade UpgradeDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static UpgradeVersion UpgradeVersionDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static MajorUpgrade MajorUpgradeDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static Variable VariableDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static Script ScriptDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static HeatParams HeatDefaulParams { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-13 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-16 { get; }
    internal static int get_fileCount();
    internal static void set_fileCount(int value);
    internal static Dictionary`2<string, int> get_dirs();
    internal static void set_dirs(Dictionary`2<string, int> value);
    internal static string getDirName(string dir);
    internal static Dictionary`2<string, int> get_compRefs();
    internal static void set_compRefs(Dictionary`2<string, int> value);
    internal static string getCompRefName(string compRef);
    internal static Dictionary`2<string, int> get_comps();
    internal static void set_comps(Dictionary`2<string, int> value);
    internal static string getCompName(string comp);
    internal static string getWixFileTag(FileInfo fileInfo);
    public static string getFilesAsWiXString(IEnumerable`1<string> files);
    internal static File get_FileDefaults();
    internal static ServiceControl get_ServiceControlDefaults();
    public static ServiceControl generateServiceControl(FSharpFunc`2<ServiceControl, ServiceControl> setParams);
    internal static ServiceConfig get_ServiceConfigDefaults();
    internal static ServiceConfig generateServiceConfig(FSharpFunc`2<ServiceConfig, ServiceConfig> setParams);
    internal static ServiceDependency get_ServiceDependencyDefaults();
    internal static ServiceDependency generateServiceDependency(FSharpFunc`2<ServiceDependency, ServiceDependency> setParams);
    internal static ServiceInstall get_ServiceInstallDefaults();
    public static ServiceInstall generateServiceInstall(FSharpFunc`2<ServiceInstall, ServiceInstall> setParams);
    internal static RegistryValue get_RegistryValueDefaults();
    public static RegistryValue generateRegistryValue(FSharpFunc`2<RegistryValue, RegistryValue> setParams);
    internal static RegistryKey get_RegistryKeyDefaults();
    public static RegistryKey generateRegistryKey(FSharpFunc`2<RegistryKey, RegistryKey> setParams);
    internal static ComponentRef get_ComponentRefDefaults();
    public static FSharpOption`1<ComponentRef> generateComponentRef(FSharpFunc`2<ComponentRef, ComponentRef> setParams);
    internal static DirectoryRef get_DirectoryRefDefaults();
    internal static DirectoryRef generateDirectoryRef(FSharpFunc`2<DirectoryRef, DirectoryRef> setParams);
    public static IEnumerable`1<FSharpOption`1<ComponentRef>> getComponentRefs(IEnumerable`1<DirectoryComponent> elements);
    internal static Component get_ComponentDefaults();
    internal static YesOrNo get_Win64@708();
    internal static Component generateComponent(FSharpFunc`2<Component, Component> setParams);
    internal static Dir get_DirDefaults();
    internal static Dir generateDirectory(FSharpFunc`2<Dir, Dir> setParams);
    internal static string calcSHA1(string text);
    internal static string getDirectoryId(string directoryName);
    internal static string getFileId(string fileName);
    internal static YesOrNo IsWin64(Architecture architecture);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<DirectoryComponent> createComponents(FSharpFunc`2<FileInfo, bool> fileFilter, DirectoryInfo directoryInfo, string directoryName, Architecture architecture);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<DirectoryComponent> bulkComponentTreeCreation(FSharpFunc`2<FileInfo, bool> fileFilter, FSharpFunc`2<DirectoryInfo, bool> directoryFilter, DirectoryInfo directoryInfo, Architecture architecture);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DirectoryComponent bulkComponentTreeSubCreation(FSharpFunc`2<FileInfo, bool> fileFilter, FSharpFunc`2<DirectoryInfo, bool> directoryFilter, DirectoryInfo directoryInfo, string directoryName, Architecture architecture);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<DirectoryComponent> bulkComponentCreation(FSharpFunc`2<FileInfo, bool> fileFilter, DirectoryInfo directoryInfo, Architecture architecture);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Dir bulkComponentCreationAsSubDir(FSharpFunc`2<FileInfo, bool> fileFilter, DirectoryInfo directoryInfo, Architecture architecture);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectoryComponent attachServiceControlToComponent(DirectoryComponent comp, FSharpFunc`2<Component, bool> fileFilter, IEnumerable`1<ServiceControl> serviceControls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<DirectoryComponent> attachServiceControlToComponents(IEnumerable`1<DirectoryComponent> components, FSharpFunc`2<Component, bool> fileFilter, IEnumerable`1<ServiceControl> serviceControls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectoryComponent attachServiceInstallToComponent(DirectoryComponent comp, FSharpFunc`2<Component, bool> fileFilter, IEnumerable`1<ServiceInstall> serviceInstalls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<DirectoryComponent> attachServiceInstallToComponents(IEnumerable`1<DirectoryComponent> components, FSharpFunc`2<Component, bool> fileFilter, IEnumerable`1<ServiceInstall> serviceInstalls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getWixDirTag(FSharpFunc`2<FileInfo, bool> fileFilter, bool asSubDir, DirectoryInfo directoryInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getFileIdFromWiXString(string wiXString, string fileRegex);
    public static string getComponentIdsFromWiXString(string wiXString);
    internal static string getComponentRefsTags(DirectoryInfo directoryInfo);
    public static string setComponentsNeverOverwrite(string components);
    internal static Params get_Defaults();
    internal static string get_path1@7-12();
    internal static string get_path2@7-15();
    internal static FSharpChoice`2<Unit, a> |Empty|NotEmpty|@1026(a seq);
    internal static string ConcatAll@1028(Feature feature, string node);
    internal static Feature get_FeatureDefaults();
    internal static CustomAction get_CustomActionDefaults();
    internal static CustomActionExecution get_CustomActionExecutionDefaults();
    internal static UIRef get_UIRefDefaults();
    internal static Upgrade get_UpgradeDefaults();
    internal static UpgradeVersion get_UpgradeVersionDefaults();
    internal static MajorUpgrade get_MajorUpgradeDefaults();
    internal static Variable get_VariableDefaults();
    internal static Script get_ScriptDefaults();
    public static void generateWiXScript(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void fillInWiXTemplate(string wiXPath, FSharpFunc`2<Script, Script> setParams);
    public static Feature generateFeatureElement(FSharpFunc`2<Feature, Feature> setParams);
    public static CustomAction generateCustomAction(FSharpFunc`2<CustomAction, CustomAction> setParams);
    public static CustomActionExecution generateCustomActionExecution(FSharpFunc`2<CustomActionExecution, CustomActionExecution> setParams);
    public static UIRef generateUIRef(FSharpFunc`2<UIRef, UIRef> setParams);
    public static Upgrade generateUpgrade(FSharpFunc`2<Upgrade, Upgrade> setParams);
    public static UpgradeVersion generateUpgradeVersion(FSharpFunc`2<UpgradeVersion, UpgradeVersion> setParams);
    public static MajorUpgrade generateMajorUpgradeVersion(FSharpFunc`2<MajorUpgrade, MajorUpgrade> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string Candle(Params parameters, string wixScript);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Light(Params parameters, string outputFile, string wixObj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void WiX(FSharpFunc`2<Params, Params> setParams, string outputFile, string wixScript);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1721-222(HeatParams this, HeatParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1721-221(HeatParams this, HeatParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1721-220(HeatParams this, HeatParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1721-225(IComparer comp, HeatParams this, HeatParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1721-224(IComparer comp, HeatParams this, HeatParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1721-223(IComparer comp, HeatParams this, HeatParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@1721-41(IEqualityComparer comp, HeatParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1721-90(HeatParams this, HeatParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1721-91(HeatParams this, HeatParams obj, Unit unitVar);
    internal static HeatParams get_HeatDefaulParams();
    internal static string get_path1@7-13();
    internal static string get_path2@7-16();
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpList`1<a>> conditionalArgument@1776(bool condition, a arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void HarvestDirectory(FSharpFunc`2<HeatParams, HeatParams> setParams, string directory, string outputFile);
}
[CompilationMappingAttribute("7")]
public static class Fake.IO.ChangeWatcher : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void handleWatcherEvents(FileStatus status, FSharpFunc`2<FileChange, Unit> onChange, FileSystemEventArgs e);
    [CompilerGeneratedAttribute]
internal static void action@1-2(FSharpFunc`2<IEnumerable`1<FileChange>, Unit> onChange, FSharpRef`1<FSharpList`1<FileChange>> unNotifiedChanges, FSharpRef`1<bool> runningHandlers, Unit unitVar0);
    internal static void timerCallback@61(FSharpFunc`2<IEnumerable`1<FileChange>, Unit> onChange, FSharpRef`1<FSharpList`1<FileChange>> unNotifiedChanges, FSharpRef`1<bool> runningHandlers, a _arg1);
    [CompilerGeneratedAttribute]
internal static void action@1-3(FSharpRef`1<FSharpList`1<FileChange>> unNotifiedChanges, Lazy`1<IDisposable> timer, FileChange fileChange, Unit unitVar0);
    internal static void acumChanges@86(IGlobbingPattern fileIncludes, FSharpRef`1<FSharpList`1<FileChange>> unNotifiedChanges, FSharpRef`1<bool> runningHandlers, Lazy`1<IDisposable> timer, FileChange fileChange);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IDisposable runWithOptions(FSharpFunc`2<Options, Options> foptions, FSharpFunc`2<IEnumerable`1<FileChange>, Unit> onChange, IGlobbingPattern fileIncludes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IDisposable run(FSharpFunc`2<IEnumerable`1<FileChange>, Unit> onChange, IGlobbingPattern fileIncludes);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.Directory : object {
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Unit> create { get; }
    public static void ensure(string dir);
    public static FSharpFunc`2<string, Unit> get_create();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindFirstMatchingFile(string pattern, string dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findFirstMatchingFile(string pattern, string dir);
    public static void delete(string path);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.DirectoryInfo : object {
    public static DirectoryInfo ofPath(string path);
    public static DirectoryInfo[] getSubDirectories(DirectoryInfo dir);
    public static FileInfo[] getFiles(DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileInfo[] getMatchingFiles(string pattern, DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileInfo[] getMatchingFilesRecursive(string pattern, DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isSubfolderOf(DirectoryInfo dir2, DirectoryInfo dir1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool containsFile(FileInfo fileInfo, DirectoryInfo dir);
    public static bool exists(DirectoryInfo dir);
    public static void ensure(DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void recursively(FSharpFunc`2<DirectoryInfo, Unit> dirF, FSharpFunc`2<FileInfo, Unit> fileF, DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setReadOnly(bool readOnly, DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setReadOnlyRecursive(bool readOnly, DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> copyRecursiveToWithFilter(bool overwrite, FSharpFunc`2<DirectoryInfo, FSharpFunc`2<FileInfo, bool>> filter, DirectoryInfo outputDir, DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> copyRecursiveTo(bool overwrite, DirectoryInfo outputDir, DirectoryInfo dir);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.File : object {
    [CompilationMappingAttribute("9")]
internal static UTF8Encoding utf8WithoutBom { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Encoding> getEncodingOrUtf8WithoutBom { get; }
    internal static UTF8Encoding get_utf8WithoutBom();
    [CompilerGeneratedAttribute]
internal static Encoding getEncoding$cont@26(Encoding def, int read, FSharpList`1<byte> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Encoding getEncoding(Encoding def, string filename);
    public static bool exists(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Encoding getEncodingOrDefault(Encoding def, string filename);
    public static FSharpFunc`2<string, Encoding> get_getEncodingOrUtf8WithoutBom();
    public static void checkExists(string fileName);
    public static bool allExist(IEnumerable`1<string> files);
    public static string getVersion(string fileName);
    public static void create(string fileName);
    public static void delete(string fileName);
    public static void deleteAll(IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Unit> |EndsWith|_|(string extension, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> readWithEncoding(Encoding encoding, string file);
    public static IEnumerable`1<string> read(string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string readLineWithEncoding(Encoding encoding, string file);
    public static string readLine(string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeWithEncoding(Encoding encoding, bool append, string fileName, IEnumerable`1<string> lines);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void write(bool append, string fileName, IEnumerable`1<string> lines);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeBytes(string file, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeStringWithEncoding(Encoding encoding, bool append, string fileName, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeString(bool append, string fileName, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void replaceContent(string fileName, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeNew(string file, IEnumerable`1<string> lines);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void append(string file, IEnumerable`1<string> lines);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string readAsStringWithEncoding(Encoding encoding, string file);
    public static string readAsString(string file);
    public static Byte[] readAsBytes(string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void applyReplace(FSharpFunc`2<string, string> replaceF, string fileName);
}
[CompilationMappingAttribute("2")]
public class Fake.IO.FileChange : object {
    [DebuggerBrowsableAttribute("0")]
internal string FullPath@;
    [DebuggerBrowsableAttribute("0")]
internal string Name@;
    [DebuggerBrowsableAttribute("0")]
internal FileStatus Status@;
    [CompilationMappingAttribute("4", "0")]
public string FullPath { get; }
    [CompilationMappingAttribute("4", "1")]
public string Name { get; }
    [CompilationMappingAttribute("4", "2")]
public FileStatus Status { get; }
    public FileChange(string fullPath, string name, FileStatus status);
    public string get_FullPath();
    public string get_Name();
    public FileStatus get_Status();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FileChange obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FileChange obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.FileFilter : object {
    public static bool allFiles(a _arg1);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.FileInfo : object {
    public static FileInfo ofPath(string path);
    public static string |FullName|(FileInfo f);
    public static Tuple`3<string, string, string> |NameSections|(FileInfo f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool contentIsEqualTo(FileInfo first, FileInfo second);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class Fake.IO.FileStatus : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FileStatus _unique_Deleted;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FileStatus _unique_Created;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FileStatus _unique_Changed;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FileStatus Deleted { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDeleted { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FileStatus Created { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCreated { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FileStatus Changed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChanged { get; }
    private static FileStatus();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FileStatus(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FileStatus get_Deleted();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDeleted();
    [CompilationMappingAttribute("8", "1")]
public static FileStatus get_Created();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCreated();
    [CompilationMappingAttribute("8", "2")]
public static FileStatus get_Changed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChanged();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FileStatus obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FileStatus obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.FileSystemInfo : object {
    public static FileSystemInfo ofPath(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setReadOnly(bool readOnly, IEnumerable`1<string> items);
    public static FSharpChoice`2<FileInfo, Tuple`2<DirectoryInfo, IEnumerable`1<FileSystemInfo>>> |File|Directory|(FileSystemInfo fileSysInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void moveTo(FileSystemInfo fileSysInfo, string dest);
}
[CompilationMappingAttribute("7")]
public static class Fake.IO.FileSystemOperators : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_AtAt(string path1, string path2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_LessDivideGreater(string path1, string path2);
}
[CompilationRepresentationAttribute("4")]
[ObsoleteAttribute("Please use GlobbingPattern instead")]
[CompilationMappingAttribute("7")]
public static class Fake.IO.Globbing.FileIncludesModule : object {
    [ObsoleteAttribute("Please use GlobbingPattern.create instead")]
public static IGlobbingPattern Include(string x);
    [ObsoleteAttribute("Please use GlobbingPattern instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IGlobbingPattern SetBaseDir(string dir, IGlobbingPattern fileIncludes);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.Globbing.Glob : object {
    [CompilationMappingAttribute("9")]
internal static Regex driveRegex { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, Regex> globRegexCache { get; }
    public static string normalizePath(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> checkSubDirs(bool absolute, string dir, string root);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> buildPaths(FSharpList`1<string> acc, FSharpList`1<SearchOption> input);
    internal static Regex get_driveRegex();
    internal static string normalizeOutputPath(string p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getRoot(string baseDirectory, string pattern);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<SearchOption>, IEnumerable`1<string>> baseItems$cont@120(string originalInput, string input, String[] splits, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> search(string baseDir, string originalInput);
    internal static Regex compileGlobToRegex(string pattern);
    internal static ConcurrentDictionary`2<string, Regex> get_globRegexCache();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isMatch(string pattern, string path);
}
[CompilationMappingAttribute("2")]
public class Fake.IO.Globbing.LazyGlobbingPattern : object {
    [DebuggerBrowsableAttribute("0")]
internal string BaseDirectory@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Includes@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Excludes@;
    [CompilationMappingAttribute("4", "0")]
public string BaseDirectory { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<string> Includes { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpList`1<string> Excludes { get; }
    public LazyGlobbingPattern(string baseDirectory, FSharpList`1<string> includes, FSharpList`1<string> excludes);
    public string get_BaseDirectory();
    public FSharpList`1<string> get_Includes();
    public FSharpList`1<string> get_Excludes();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(LazyGlobbingPattern obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    private virtual override string Fake-IO-IGlobbingPattern-get_BaseDirectory();
    private virtual override FSharpList`1<string> Fake-IO-IGlobbingPattern-get_Includes();
    private virtual override FSharpList`1<string> Fake-IO-IGlobbingPattern-get_Excludes();
    private virtual override IEnumerator`1<string> System-Collections-Generic-IEnumerable`1-GetEnumerator();
    private virtual override IEnumerator System-Collections-IEnumerable-GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LazyGlobbingPattern obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class Fake.IO.Globbing.Operators : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IGlobbingPattern op_PlusPlus(IGlobbingPattern x, string pattern);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IGlobbingPattern op_MinusMinus(IGlobbingPattern x, string pattern);
    public static IGlobbingPattern op_BangBang(string x);
}
[CompilationMappingAttribute("2")]
public class Fake.IO.Globbing.ResolvedGlobbingPattern : object {
    [DebuggerBrowsableAttribute("0")]
internal string BaseDirectory@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Includes@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Excludes@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Results@;
    [CompilationMappingAttribute("4", "0")]
public string BaseDirectory { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<string> Includes { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpList`1<string> Excludes { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpList`1<string> Results { get; }
    public ResolvedGlobbingPattern(string baseDirectory, FSharpList`1<string> includes, FSharpList`1<string> excludes, FSharpList`1<string> results);
    public string get_BaseDirectory();
    public FSharpList`1<string> get_Includes();
    public FSharpList`1<string> get_Excludes();
    public FSharpList`1<string> get_Results();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ResolvedGlobbingPattern obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    private virtual override string Fake-IO-IGlobbingPattern-get_BaseDirectory();
    private virtual override FSharpList`1<string> Fake-IO-IGlobbingPattern-get_Includes();
    private virtual override FSharpList`1<string> Fake-IO-IGlobbingPattern-get_Excludes();
    private virtual override IEnumerator`1<string> System-Collections-Generic-IEnumerable`1-GetEnumerator();
    private virtual override IEnumerator System-Collections-IEnumerable-GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ResolvedGlobbingPattern obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.Globbing.Tools : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string op_AtAt(string path1, string path2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findToolInSubPath(string toolname, string defaultPath);
    public static FSharpOption`1<string> tryFindToolFolderInSubPath(string toolname);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findToolFolderInSubPath(string toolname, string defaultPath);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.GlobbingPatternExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LazyGlobbingPattern IGlobbingPattern.get_Pattern(IGlobbingPattern );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IGlobbingPattern IGlobbingPattern.Resolve(IGlobbingPattern );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IGlobbingPattern IGlobbingPattern.And(IGlobbingPattern this, string pattern);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IGlobbingPattern IGlobbingPattern.ButNot(IGlobbingPattern this, string pattern);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IGlobbingPattern IGlobbingPattern.SetBaseDirectory(IGlobbingPattern this, string dir);
    internal static string fullDir@100(IGlobbingPattern this, string pattern);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool IGlobbingPattern.IsMatch(IGlobbingPattern this, string path);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
public static class Fake.IO.GlobbingPatternModule : object {
    [CompilationMappingAttribute("9")]
internal static string defaultBaseDir { get; }
    internal static string get_defaultBaseDir();
    public static IGlobbingPattern create(string x);
    public static IGlobbingPattern createFrom(string dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IGlobbingPattern setBaseDir(string dir, IGlobbingPattern fileIncludes);
    public static FSharpList`1<string> getBaseDirectoryIncludes(IGlobbingPattern fileIncludes);
}
[CompilationMappingAttribute("3")]
public interface Fake.IO.IGlobbingPattern {
    public string BaseDirectory { get; }
    public FSharpList`1<string> Includes { get; }
    public FSharpList`1<string> Excludes { get; }
    public abstract virtual string get_BaseDirectory();
    public abstract virtual FSharpList`1<string> get_Includes();
    public abstract virtual FSharpList`1<string> get_Excludes();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.Path : object {
    [CompilationMappingAttribute("9")]
public static string directorySeparator { get; }
    [CompilationMappingAttribute("9")]
internal static char dirsepChar@64 { get; }
    [CompilationMappingAttribute("9")]
internal static char dirsepChar@64-1 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, FSharpFunc`2<string, string>> toRelativeFrom { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<Tuple`2<string, string>, string> relativePaths@112 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string combineTrimEnd(string path1, string path2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string combine(string path1, string path2);
    public static bool isDirectory(string path);
    public static bool isFile(string path);
    public static string normalizeFileName(string fileName);
    public static bool isValidPath(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string changeExtension(string extension, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool hasExtension(string extension, string fileName);
    public static string getDirectory(string path);
    public static string get_directorySeparator();
    internal static char get_dirsepChar@64();
    internal static char get_dirsepChar@64-1();
    public static string getFullName(string p);
    public static string shortenCurrentDirectory(string path);
    [CompilerGeneratedAttribute]
internal static string ProduceRelativePath$cont@86(string baseLocation, string targetLocation, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ProduceRelativePath(string baseLocation, string targetLocation);
    public static FSharpFunc`2<string, FSharpFunc`2<string, string>> get_toRelativeFrom();
    internal static ConcurrentDictionary`2<Tuple`2<string, string>, string> get_relativePaths@112();
    public static string toRelativeFromCurrent(string path);
    public static string convertWindowsToCurrentPath(string windowsPath);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.Shell : object {
    [CompilationMappingAttribute("9")]
internal static Stack`1<string> dirStack { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void copyFile(string target, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void doCopyFile(string targetName, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void copyFileIntoSubFolder(string target, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void copyFileWithSubfolder(string baseDir, string target, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void copy(string target, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void copyTo(string target, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> copyCached(string target, string cacheDir, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void rename(string target, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void silentCopy(string target, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void copyFiles(string target, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void copyFilesWithSubFolder(string targetDir, IGlobbingPattern files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void copyDir(string target, string source, FSharpFunc`2<string, bool> filterFile);
    public static void cleanDir(string path);
    public static void cleanDirs(IEnumerable`1<string> dirs);
    public static void deleteDir(string dir);
    public static void deleteDirs(IEnumerable`1<string> dirs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void appendTextFilesWithEncoding(Encoding encoding, string newFileName, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void appendTextFiles(string newFileName, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool compareFiles(bool delete, string originalFileName, string compareFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void generatePatchWithFindOldFileFunction(string lastReleaseDir, string patchDir, IEnumerable`1<string> srcFiles, FSharpFunc`2<string, FSharpFunc`2<string, string>> findOldFileF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void generatePatch(string lastReleaseDir, string patchDir, IEnumerable`1<string> srcFiles);
    public static bool testDir(string path);
    public static bool testFile(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> copyRecursive(string dir, string outputDir, bool overWrite);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> copyRecursiveTo(bool overWrite, string outputDir, string dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> copyRecursive2(CopyRecursiveMethod method, string dir, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void moveFile(string target, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void moveDir(string target, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void writeConfigFile(string configFileName, IEnumerable`1<Tuple`2<a, b>> parameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void replaceInFiles(IEnumerable`1<Tuple`2<string, string>> replacements, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void regexReplaceInFileWithEncoding(string pattern, string replacement, Encoding encoding, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void regexReplaceInFilesWithEncoding(string pattern, string replacement, Encoding encoding, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please use copyFile instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyFile(string target, string fileName);
    [ObsoleteAttribute("Please use copyFileIntoSubFolder instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyFileIntoSubFolder(string target, string fileName);
    [ObsoleteAttribute("Please use copyFileWithSubfolder instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyFileWithSubfolder(string baseDir, string target, string fileName);
    [ObsoleteAttribute("Please use copy instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Copy(string target, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please use copyTo instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyTo(string target, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please use copyCached instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> CopyCached(string target, string cacheDir, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please use rename instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Rename(string target, string fileName);
    [ObsoleteAttribute("Please use silentCopy instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SilentCopy(string target, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please use copyFiles instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyFiles(string target, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please use copyDir instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyDir(string target, string source, FSharpFunc`2<string, bool> filterFile);
    [ObsoleteAttribute("Please use cleanDir instead")]
public static void CleanDir(string path);
    [ObsoleteAttribute("Please use cleanDirs instead")]
public static void CleanDirs(IEnumerable`1<string> dirs);
    [ObsoleteAttribute("Please use deleteDir instead")]
public static void DeleteDir(string dir);
    [ObsoleteAttribute("Please use deleteDirs instead")]
public static void DeleteDirs(IEnumerable`1<string> dirs);
    [ObsoleteAttribute("Please use appendTextFilesWithEncoding instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void AppendTextFilesWithEncoding(Encoding encoding, string newFileName, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please use appendTextFiles instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void AppendTextFiles(string newFileName, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please use compareFiles instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool CompareFiles(bool delete, string originalFileName, string compareFileName);
    [ObsoleteAttribute("Please use generatePatchWithFindOldFileFunction instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void GeneratePatchWithFindOldFileFunction(string lastReleaseDir, string patchDir, IEnumerable`1<string> srcFiles, FSharpFunc`2<string, FSharpFunc`2<string, string>> findOldFileF);
    [ObsoleteAttribute("Please use generatePatch instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void GeneratePatch(string lastReleaseDir, string patchDir, IEnumerable`1<string> srcFiles);
    [ObsoleteAttribute("Please use testDir instead")]
public static bool TestDir(string path);
    [ObsoleteAttribute("Please use testFile instead")]
public static bool TestFile(string path);
    [ObsoleteAttribute("Please use copyRecursive instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> CopyRecursive(string dir, string outputDir, bool overWrite);
    [ObsoleteAttribute("Please use copyRecursiveTo instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> CopyRecursiveTo(bool overWrite, string outputDir, string dir);
    [ObsoleteAttribute("Please use copyRecursive2 instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> CopyRecursive2(CopyRecursiveMethod method, string dir, string outputDir);
    [ObsoleteAttribute("Please use moveFile instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void MoveFile(string target, string fileName);
    [ObsoleteAttribute("Please use writeConfigFile instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void WriteConfigFile(string configFileName, IEnumerable`1<Tuple`2<a, b>> parameters);
    [ObsoleteAttribute("Please use replaceInFiles instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ReplaceInFiles(IEnumerable`1<Tuple`2<string, string>> replacements, IEnumerable`1<string> files);
    [ObsoleteAttribute("Please use regexReplaceInFileWithEncoding instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RegexReplaceInFileWithEncoding(string pattern, string replacement, Encoding encoding, string file);
    [ObsoleteAttribute("Please use regexReplaceInFilesWithEncoding instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RegexReplaceInFilesWithEncoding(string pattern, string replacement, Encoding encoding, IEnumerable`1<string> files);
    public static void rm(string fileName);
    public static void rm_rf(string f);
    public static void mkdir(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void cp_r(string src, string dest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void cp(string src, string dest);
    public static void chdir(string path);
    public static void cd(string path);
    public static string pwd();
    internal static Stack`1<string> get_dirStack();
    public static void pushd(string path);
    public static void popd();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void mv(string src, string dest);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.Templates : object {
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<IEnumerable`1<Tuple`2<string, IEnumerable`1<string>>>, Unit> saveFiles { get; }
    public static IEnumerable`1<Tuple`2<string, IEnumerable`1<string>>> load(IEnumerable`1<string> seq);
    public static FSharpFunc`2<IEnumerable`1<Tuple`2<a, b>>, IEnumerable`1<Tuple`2<a, IEnumerable`1<string>>>> replaceKeywords(IEnumerable`1<Tuple`2<string, string>> replacements);
    public static FSharpFunc`2<IEnumerable`1<Tuple`2<string, IEnumerable`1<string>>>, Unit> get_saveFiles();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void replaceInFiles(IEnumerable`1<Tuple`2<string, string>> replacements, IEnumerable`1<string> files);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.IO.Zip : object {
    public static int DefaultZipLevel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_DefaultZipLevel();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addZipEntry(ZipOutputStream stream, Byte[] buffer, string item, string itemSpec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createZipInternal(string fileName, string comment, int level, IEnumerable`1<Tuple`2<string, string>> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createZip(string workingDir, string fileName, string comment, int level, bool flatten, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void zip(string workingDir, string fileName, IEnumerable`1<string> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createZipSpec(string fileName, string comment, int level, IEnumerable`1<Tuple`2<string, string>> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void zipSpec(string fileName, IEnumerable`1<Tuple`2<string, string>> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void zipFile(string fileName, string targetFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void unzip(string target, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string unzipSingleFileInMemory(string fileToUnzip, string zipFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string unzipFirstMatchingFileInMemory(FSharpFunc`2<ZipEntry, bool> predicate, string zipFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Tuple`2<string, string>> filesAsSpecsExt(bool flatten, string workingDir, IGlobbingPattern files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<string, string>> filesAsSpecs(string workingDir, IGlobbingPattern files);
    public static IEnumerable`1<Tuple`2<string, string>> filesAsSpecsFlatten(IGlobbingPattern files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<string, string>> moveToFolder(string path, IEnumerable`1<Tuple`2<string, string>> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createZipOfIncludes(string fileName, string comment, int level, IEnumerable`1<Tuple`2<string, IGlobbingPattern>> files);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void zipOfIncludes(string fileName, IEnumerable`1<Tuple`2<string, IGlobbingPattern>> files);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.JavaScript.Npm : object {
    [CompilationMappingAttribute("9")]
internal static string npmFileName { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> arg@1-4 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> _arg1@23 { get; }
    [CompilationMappingAttribute("9")]
public static NpmParams defaultNpmParams { get; }
    internal static string get_npmFileName();
    internal static FSharpOption`1<string> get_arg@1-4();
    internal static FSharpOption`1<string> get__arg1@23();
    public static NpmParams get_defaultNpmParams();
    internal static string parseInstallArgs(InstallArgs _arg1);
    internal static string parse(NpmCommand _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void execute(NpmParams npmParams, NpmCommand command);
    internal static FSharpFunc`2<NpmCommand, Unit> npm(FSharpFunc`2<NpmParams, NpmParams> setParams);
    public static void installForced(FSharpFunc`2<NpmParams, NpmParams> setParams);
    public static void install(FSharpFunc`2<NpmParams, NpmParams> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void run(string command, FSharpFunc`2<NpmParams, NpmParams> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runSilent(string command, FSharpFunc`2<NpmParams, NpmParams> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runTest(string command, FSharpFunc`2<NpmParams, NpmParams> setParams);
    public static void test(FSharpFunc`2<NpmParams, NpmParams> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void exec(string command, FSharpFunc`2<NpmParams, NpmParams> setParams);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.JavaScript.Yarn : object {
    [CompilationMappingAttribute("9")]
internal static string yarnFileName { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> arg@1-5 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> _arg1@22-1 { get; }
    [CompilationMappingAttribute("9")]
public static YarnParams defaultYarnParams { get; }
    internal static string get_yarnFileName();
    internal static FSharpOption`1<string> get_arg@1-5();
    internal static FSharpOption`1<string> get__arg1@22-1();
    public static YarnParams get_defaultYarnParams();
    internal static string parseInstallArgs(InstallArgs _arg1);
    internal static string parse(YarnCommand _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void run(YarnParams yarnParams, YarnCommand command);
    internal static FSharpFunc`2<YarnCommand, Unit> yarn(FSharpFunc`2<YarnParams, YarnParams> setParams);
    public static void install(FSharpFunc`2<YarnParams, YarnParams> setParams);
    public static void installProduction(FSharpFunc`2<YarnParams, YarnParams> setParams);
    public static void installForced(FSharpFunc`2<YarnParams, YarnParams> setParams);
    public static void installFlat(FSharpFunc`2<YarnParams, YarnParams> setParams);
    public static void installHar(FSharpFunc`2<YarnParams, YarnParams> setParams);
    public static void installNoLock(FSharpFunc`2<YarnParams, YarnParams> setParams);
    public static void installPureLock(FSharpFunc`2<YarnParams, YarnParams> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void exec(string command, FSharpFunc`2<YarnParams, YarnParams> setParams);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, module: Mage)")]
[CompilationMappingAttribute("7")]
public static class Fake.MageHelper : object {
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@30-144(MageParams this, MageParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@30-145(MageParams this, MageParams obj, Unit unitVar);
    [ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, function: serializeParams (private))")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string MageSerializeParams(MageCall action, MageParams mp);
    [ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, function: call")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void mageCall(MageCall action, MageParams mp);
    [ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, function: createApp")]
public static void MageCreateApp(MageParams mp);
    [ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, function: updateApp")]
public static void MageUpdateApp(MageParams mp);
    [ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, function: signManifest")]
public static void MageSignManifest(MageParams mp);
    [ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, function: deployApp")]
public static void MageDeployApp(MageParams mp);
    [ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, function: updateDeploy")]
public static void MageUpdateDeploy(MageParams mp);
    [ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, function: signDeploy")]
public static void MageSignDeploy(MageParams mp);
    [ObsoleteAttribute("Open Fake.DotNet instead (FAKE0001 - package: Fake.DotNet.Mage, function: run")]
public static void MageRun(MageParams mp);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.MessageHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TimeSpan WaitForMessageFiles(IEnumerable`1<string> files, TimeSpan timeOut);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TimeSpan WaitForMessageFile(string file, TimeSpan timeOut);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.MSBuild.ProjectSystem : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<ProjectComparison> findMissingFiles(string templateProject, IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<ProjectComparison> findMissingContentFiles(string templateProject, IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FixMissingFiles(string templateProject, IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FixMissingContentFiles(string templateProject, IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void RemoveDuplicateFiles(IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void RemoveDuplicateContentFiles(IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FixProjectFiles(string templateProject, IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FixProjectContentFiles(string templateProject, IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CompareProjectsTo(string templateProject, IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProjectFile removeCompileNodesWithMissingFiles(FSharpFunc`2<string, bool> includeExistsF, ProjectFile project);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProjectFile removeContentNodesWithMissingFiles(FSharpFunc`2<string, bool> includeExistsF, ProjectFile project);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void RemoveCompileNodesWithMissingFiles(string project);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void RemoveContentNodesWithMissingFiles(string project);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.MSBuild.SpecsRemovement : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string normalize(XDocument project);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XDocument removeFilteredElement(string elementName, FSharpFunc`2<string, FSharpFunc`2<string, bool>> filterF, XDocument doc);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XDocument removeAssemblyReference(FSharpFunc`2<string, FSharpFunc`2<string, bool>> filterF, XDocument doc);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XDocument removeFiles(FSharpFunc`2<string, FSharpFunc`2<string, bool>> filterF, XDocument doc);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string createFileName(string projectFileName);
    internal static string removeTestsFromProject@58(HashSet`1<string> processedProjects, FSharpFunc`2<string, FSharpFunc`2<string, bool>> assemblyFilterF, FSharpFunc`2<string, FSharpFunc`2<string, bool>> fileFilterF, string projectFileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string RemoveTestsFromProject(FSharpFunc`2<string, FSharpFunc`2<string, bool>> assemblyFilterF, FSharpFunc`2<string, FSharpFunc`2<string, bool>> fileFilterF, string projectFileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool AllNUnitReferences(a elementName, string s);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool AllSpecFiles(a elementName, string s);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool AllSpecAndTestDataFiles(string elementName, string s);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool Nothing(a _arg2, b _arg1);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string RemoveAllNUnitReferences(string projectFileName);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string RemoveAllSpecAndTestDataFiles(string projectFileName);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("7")]
public static class Fake.MSBuildHelper : object {
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static FSharpList`1<MsBuildEntry> knownMsBuildEntries { get; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static FSharpList`1<string> oldMsBuildLocations { get; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static FSharpList`1<string> getAllKnownPaths { get; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static Version monoVersionToUseMSBuildOn { get; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static string msBuildExe { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, FSharpOption`1<string>> which@86-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> msbuildEnvironVar@87-1 { get; }
    [CompilationMappingAttribute("9")]
internal static string foundExe@89-4 { get; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
public static string msbuildNamespace { get; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static MSBuildParams MSBuildDefaults { get; public set; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static string TeamCityLoggerName { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@1-1 { get; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static string ErrorLoggerName { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@1-2 { get; }
    [CompilationMappingAttribute("9")]
internal static string pathToLogger { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@1-3 { get; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static FSharpList`1<string> MSBuildLoggers { get; public set; }
    public static FSharpList`1<MsBuildEntry> get_knownMsBuildEntries();
    public static FSharpList`1<string> get_oldMsBuildLocations();
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
public static FSharpMap`2<string, FSharpList`1<string>> toDict(IEnumerable`1<MsBuildEntry> items);
    public static FSharpList`1<string> get_getAllKnownPaths();
    public static Version get_monoVersionToUseMSBuildOn();
    public static string get_msBuildExe();
    internal static FSharpFunc`2<string, string> exactPathOrBinaryOnPath@81-2(string tool);
    internal static FSharpFunc`2<string, FSharpOption`1<string>> get_which@86-2();
    internal static FSharpOption`1<string> get_msbuildEnvironVar@87-1();
    internal static string get_foundExe@89-4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_msbuildNamespace();
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
public static XName xname(string name);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
public static XDocument loadProject(string projectFileName);
    internal static string unescapeMSBuildSpecialChars(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Tuple`2<XAttribute, string>> getReferenceElements(string elementName, string projectFileName, XDocument doc);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XDocument processReferences(string elementName, FSharpFunc`2<string, string> f, string projectFileName, XDocument doc);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
public static FSharpSet`1<string> getProjectReferences(string projectFileName);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@239-301(MSBuildParams this, MSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@239-300(MSBuildParams this, MSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@239-299(MSBuildParams this, MSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@239-304(IComparer comp, MSBuildParams this, MSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@239-303(IComparer comp, MSBuildParams this, MSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@239-302(IComparer comp, MSBuildParams this, MSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@239-61(IEqualityComparer comp, MSBuildParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@239-128(MSBuildParams this, MSBuildParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@239-129(MSBuildParams this, MSBuildParams obj, Unit unitVar);
    public static MSBuildParams get_MSBuildDefaults();
    public static void set_MSBuildDefaults(MSBuildParams value);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<a> getAllParameters(a targets, a maxcpu, a noLogo, a nodeReuse, a tools, a verbosity, a noconsolelogger, a warnAsError, a nowarn, FSharpList`1<a> fileLoggers, FSharpList`1<a> binaryLoggers, FSharpList`1<a> distributedFileLoggers, FSharpList`1<a> properties);
    internal static string serializeArgs(IEnumerable`1<FSharpOption`1<Tuple`2<string, string>>> args);
    internal static string verbosityName@302-1(MSBuildVerbosity v);
    internal static string logParams@360-1(MSBuildLogParameter param);
    internal static string serializeLogger@359-12(MSBuildFileLoggerConfig fl);
    internal static string serializeDLogger@405(MSBuildDistributedLoggerConfig dlogger);
    internal static string createLoggerString@416-3(MSBuildDistributedLoggerConfig cl, FSharpOption`1<MSBuildDistributedLoggerConfig> fl);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
public static string serializeMSBuildParams(MSBuildParams p);
    public static string get_TeamCityLoggerName();
    internal static Type get_ty@1-1();
    public static string get_ErrorLoggerName();
    internal static Type get_ty@1-2();
    internal static string get_pathToLogger();
    internal static Type get_ty@1-3();
    public static FSharpList`1<string> get_MSBuildLoggers();
    public static void set_MSBuildLoggers(FSharpList`1<string> value);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void build(FSharpFunc`2<MSBuildParams, MSBuildParams> setParams, string project);
    internal static FSharpFunc`2<MSBuildParams, MSBuildParams> setBuildParam@533-2(string targets, FSharpFunc`2<string, FSharpList`1<Tuple`2<string, string>>> properties, string project);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild.RunWithProjectProperties instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> MSBuildWithProjectProperties(string outputPath, string targets, FSharpFunc`2<string, FSharpList`1<Tuple`2<string, string>>> properties, IEnumerable`1<string> projects);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild.Run instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> MSBuild(string outputPath, string targets, FSharpList`1<Tuple`2<string, string>> properties, IEnumerable`1<string> projects);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild.RunDebug instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> MSBuildDebug(string outputPath, string targets, IEnumerable`1<string> projects);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild.RunRelease instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> MSBuildRelease(string outputPath, string targets, IEnumerable`1<string> projects);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild.RunWithDefaults instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> MSBuildWithDefaults(string targets, IEnumerable`1<string> projects);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild.RunReleaseExt instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> MSBuildReleaseExt(string outputPath, FSharpList`1<Tuple`2<string, string>> properties, string targets, IEnumerable`1<string> projects);
    internal static int slashes@598-2(string dir);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void BuildWebsiteConfig(string outputPath, string configuration, string projectFile);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void BuildWebsite(string outputPath, string projectFile);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void BuildWebsitesConfig(string outputPath, string configuration, IEnumerable`1<string> projectFiles);
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void BuildWebsites(string outputPath, IEnumerable`1<string> projectFiles);
}
[CompilationMappingAttribute("7")]
public static class Fake.MsBuildLogger : object {
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
[CompilationMappingAttribute("9")]
public static string ErrorLoggerFile { get; }
    [ObsoleteAttribute("Use Fake.DotNet.MSBuild instead")]
public static string errToStr(BuildErrorEventArgs a);
    public static string get_ErrorLoggerFile();
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.MSIHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static MSIParams MSIDefaults { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@11-311(MSIParams this, MSIParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@11-312(IComparer comp, MSIParams this, MSIParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@11-63(IEqualityComparer comp, MSIParams this, Unit unitVar);
    public static MSIParams get_MSIDefaults();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Install(FSharpFunc`2<MSIParams, MSIParams> setParams, string setup);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Uninstall(FSharpFunc`2<MSIParams, MSIParams> setParams, string setup);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use Fake.DotNet.Testing.MSpec instead")]
[CompilationMappingAttribute("7")]
public static class Fake.MSpecHelper : object {
    [ObsoleteAttribute("use Fake.DotNet.Testing.MSpec instead")]
[CompilationMappingAttribute("9")]
public static MSpecParams MSpecDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-26 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-282(MSpecParams this, MSpecParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-281(MSpecParams this, MSpecParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-284(IComparer comp, MSpecParams this, MSpecParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-283(IComparer comp, MSpecParams this, MSpecParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@14-56(IEqualityComparer comp, MSpecParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@14-113(MSpecParams this, MSpecParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@14-114(MSpecParams this, MSpecParams obj, Unit unitVar);
    public static MSpecParams get_MSpecDefaults();
    internal static string get_path2@32-26();
    [ObsoleteAttribute("use Fake.DotNet.Testing.MSpec instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildMSpecArgs(MSpecParams parameters, IEnumerable`1<string> assemblies);
    [ObsoleteAttribute("use Fake.DotNet.Testing.MSpec instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void MSpec(FSharpFunc`2<MSpecParams, MSpecParams> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.MSTest : object {
    [ObsoleteAttribute("use Fake.DotNet.Testing.MSTest instead")]
[CompilationMappingAttribute("9")]
public static String[] mstestPaths { get; }
    [ObsoleteAttribute("use Fake.DotNet.Testing.MSTest instead")]
[CompilationMappingAttribute("9")]
public static string mstestexe { get; }
    [ObsoleteAttribute("use Fake.DotNet.Testing.MSTest instead")]
[CompilationMappingAttribute("9")]
public static MSTestParams MSTestDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> matchValue@67-4 { get; }
    public static String[] get_mstestPaths();
    public static string get_mstestexe();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@32-286(MSTestParams this, MSTestParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@32-285(MSTestParams this, MSTestParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@32-288(IComparer comp, MSTestParams this, MSTestParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@32-287(IComparer comp, MSTestParams this, MSTestParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@32-57(IEqualityComparer comp, MSTestParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@32-115(MSTestParams this, MSTestParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@32-116(MSTestParams this, MSTestParams obj, Unit unitVar);
    public static MSTestParams get_MSTestDefaults();
    internal static FSharpOption`1<string> get_matchValue@67-4();
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<StringBuilder, StringBuilder> action@153-12(string value, string s);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<StringBuilder, StringBuilder> action@153-13(string value, string s);
    [ObsoleteAttribute("use Fake.DotNet.Testing.MSTest instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildMSTestArgs(MSTestParams parameters, a assembly);
    internal static FSharpFunc`2<int, Unit> failIfError@113-2(MSTestParams parameters, string assembly);
    [ObsoleteAttribute("use Fake.DotNet.Testing.MSTest instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void MSTest(FSharpFunc`2<MSTestParams, MSTestParams> setParams, IEnumerable`1<string> assemblies);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.NCoverHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static NCoverParams NCoverDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-29 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-30 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-31 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-297(NCoverParams this, NCoverParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-298(IComparer comp, NCoverParams this, NCoverParams objTemp, Unit unitVar);
    public static NCoverParams get_NCoverDefaults();
    internal static string get_path2@32-29();
    internal static string get_path2@32-30();
    internal static string get_path2@32-31();
    internal static void appendQuoted@42(FSharpRef`1<StringBuilder> args, string s);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NCover(FSharpFunc`2<NCoverParams, NCoverParams> setParams, IEnumerable`1<string> assemblies, IEnumerable`1<string> excludeAssemblies);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.NDepend : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static NDependParams NDependDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-32 { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string getWorkingDir(string workingDir);
    public static NDependParams get_NDependDefaults();
    internal static string get_path2@32-32();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static string buildNDependArgs(NDependParams parameters);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void NDepend(FSharpFunc`2<NDependParams, NDependParams> setParams);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Net.Async.Async : object {
    internal static FSharpFunc`2<a, FSharpAsync`1<a>> result();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<b> map(FSharpFunc`2<a, b> f, FSharpAsync`1<a> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<b> bind(FSharpFunc`2<a, FSharpAsync`1<b>> f, FSharpAsync`1<a> xAsync);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<b> apply(FSharpAsync`1<FSharpFunc`2<a, b>> fAsync, FSharpAsync`1<a> xAsync);
}
[CompilationMappingAttribute("7")]
public static class Fake.Net.Http : object {
    internal static FSharpResult`2<string, FSharpList`1<string>> createFilePath(string filePathStr);
    internal static FSharpResult`2<Uri, FSharpList`1<string>> createUri(string uriStr);
    internal static FSharpFunc`2<FSharpFunc`2<a, b>, FSharpFunc`2<FSharpResult`2<a, c>, FSharpResult`2<b, c>>> op_LessBangGreater@56();
    internal static FSharpFunc`2<FSharpResult`2<FSharpFunc`2<a, b>, FSharpList`1<c>>, FSharpFunc`2<FSharpResult`2<a, FSharpList`1<c>>, FSharpResult`2<b, FSharpList`1<c>>>> op_LessMultiplyGreater@57-4();
    internal static FSharpResult`2<DownloadInfo, FSharpList`1<string>> createDownloadInfo(DownloadParameters input);
    internal static a processResults(FSharpResult`2<a, b> result);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpResult`2<string, FSharpList`1<string>>> catchHandler@1-5(string filePath, Exception _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<FSharpResult`2<string, FSharpList`1<string>>> saveStreamToFileAsync(string filePath, Stream stream);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpResult`2<string, FSharpList`1<string>>> catchHandler@1-6(DownloadInfo info, Exception _arg5);
    internal static FSharpAsync`1<FSharpResult`2<string, FSharpList`1<string>>> downloadStreamToFileAsync(DownloadInfo info);
    internal static FSharpAsync`1<FSharpResult`2<string, FSharpList`1<string>>> downloadFileAsync(DownloadParameters input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string downloadFile(string localFilePath, string uri);
    public static FSharpList`1<string> downloadFiles(FSharpList`1<DownloadParameters> input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<Tuple`2<FSharpMap`2<string, FSharpList`1<string>>, string>> getAsync(FSharpFunc`2<HttpRequestHeaders, Unit> headerF, string userName, string password, string url);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string get(string userName, string password, string url);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<Tuple`2<FSharpMap`2<string, FSharpList`1<string>>, string>> postCommandAsync(FSharpFunc`2<HttpRequestHeaders, Unit> headerF, string url, string userName, string password, string data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string postCommand(FSharpFunc`2<HttpRequestHeaders, Unit> headerF, string url, string userName, string password, string data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string post(string url, string userName, string password, string data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<Unit> uploadAsync(string url, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void upload(string url, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FSharpMap`2<string, FSharpList`1<string>>, string> getWithHeaders(string userName, string password, FSharpFunc`2<HttpRequestHeaders, Unit> headerF, string url);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Net.List.List : object {
    internal static FSharpFunc`2<FSharpAsync`1<FSharpFunc`2<c, d>>, FSharpFunc`2<FSharpAsync`1<c>, FSharpAsync`1<d>>> op_LessMultiplyGreater@19();
    internal static FSharpFunc`2<c, FSharpAsync`1<c>> retn@20();
    internal static FSharpFunc`2<c, FSharpFunc`2<FSharpList`1<c>, FSharpList`1<c>>> cons@23();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<FSharpList`1<b>> traverseAsyncA(FSharpFunc`2<a, FSharpAsync`1<b>> f, FSharpList`1<a> list);
    internal static FSharpAsync`1<FSharpList`1<a>> sequenceAsyncA(FSharpList`1<FSharpAsync`1<a>> x);
    internal static FSharpFunc`2<FSharpResult`2<FSharpFunc`2<d, e>, FSharpList`1<f>>, FSharpFunc`2<FSharpResult`2<d, FSharpList`1<f>>, FSharpResult`2<e, FSharpList`1<f>>>> op_LessMultiplyGreater@44-2();
    internal static FSharpFunc`2<d, FSharpFunc`2<FSharpList`1<d>, FSharpList`1<d>>> cons@48-2();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpResult`2<FSharpList`1<b>, FSharpList`1<c>> traverseResultA(FSharpFunc`2<a, FSharpResult`2<b, FSharpList`1<c>>> f, FSharpList`1<a> list);
    internal static FSharpResult`2<FSharpList`1<a>, FSharpList`1<b>> sequenceResultA(FSharpList`1<FSharpResult`2<a, FSharpList`1<b>>> x);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Net.Result.Result : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpResult`2<b, FSharpList`1<c>> apply(FSharpResult`2<FSharpFunc`2<a, b>, FSharpList`1<c>> fResult, FSharpResult`2<a, FSharpList`1<c>> xResult);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.NGenHelper : object {
    [CompilationMappingAttribute("9")]
internal static string winDir { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string NGen32 { get; public set; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string NGen64 { get; public set; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static NGenParams NGenDefaults { get; }
    internal static string get_winDir();
    public static string get_NGen32();
    public static void set_NGen32(string value);
    public static string get_NGen64();
    public static void set_NGen64(string value);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static NGenParams UseNGen64(NGenParams p);
    public static NGenParams get_NGenDefaults();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ngen(NGenParams param, string command);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NGen(FSharpFunc`2<NGenParams, NGenParams> setParams, string command);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Install(FSharpFunc`2<NGenParams, NGenParams> setParams, IEnumerable`1<string> assemblies);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.JavaScript.Npm module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.NpmHelper : object {
    [CompilationMappingAttribute("9")]
internal static string npmFileName { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.JavaScript.Npm module instead")]
[CompilationMappingAttribute("9")]
public static NpmParams defaultNpmParams { get; }
    internal static string get_npmFileName();
    public static NpmParams get_defaultNpmParams();
    internal static string parseInstallArgs(InstallArgs _arg1);
    internal static string parse(NpmCommand _arg1);
    [ObsoleteAttribute("FAKE0001 Use the Fake.JavaScript.Npm module instead")]
public static void run(NpmParams npmParams);
    [ObsoleteAttribute("FAKE0001 Use the Fake.JavaScript.Npm module instead")]
public static void Npm(FSharpFunc`2<NpmParams, NpmParams> setParams);
}
[ObsoleteAttribute("Use Fake.DotNet.NuGet.Install instead")]
[CompilationMappingAttribute("7")]
public static class Fake.NuGet.Install : object {
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Install instead")]
[CompilationMappingAttribute("9")]
public static NugetInstallParams NugetInstallDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-43 { get; }
    public static NugetInstallParams get_NugetInstallDefaults();
    internal static string get_path2@32-43();
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Install instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string argList(string name, IEnumerable`1<string> values);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Install instead")]
public static string buildArgs(NugetInstallParams param);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Install instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NugetInstall(FSharpFunc`2<NugetInstallParams, NugetInstallParams> setParams, string packageName);
}
[ObsoleteAttribute("Use Fake.DotNet.NuGet.Update instead")]
[CompilationMappingAttribute("7")]
public static class Fake.NuGet.Update : object {
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Update instead")]
[CompilationMappingAttribute("9")]
public static NugetUpdateParams NugetUpdateDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-42 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-368(NugetUpdateParams this, NugetUpdateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-367(NugetUpdateParams this, NugetUpdateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-366(NugetUpdateParams this, NugetUpdateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-371(IComparer comp, NugetUpdateParams this, NugetUpdateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-370(IComparer comp, NugetUpdateParams this, NugetUpdateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-369(IComparer comp, NugetUpdateParams this, NugetUpdateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@12-76(IEqualityComparer comp, NugetUpdateParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-156(NugetUpdateParams this, NugetUpdateParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-157(NugetUpdateParams this, NugetUpdateParams obj, Unit unitVar);
    public static NugetUpdateParams get_NugetUpdateDefaults();
    internal static string get_path2@32-42();
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Update instead")]
public static string buildArgs(NugetUpdateParams param);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Update instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NugetUpdate(FSharpFunc`2<NugetUpdateParams, NugetUpdateParams> setParams, string packagesFile);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationMappingAttribute("7")]
public static class Fake.NuGetHelper : object {
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static string feedUrl { get; }
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationMappingAttribute("9")]
internal static WebClient webClient { get; }
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationMappingAttribute("9")]
public static Lazy`1<string> discoverRepoUrl { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-352(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-351(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-350(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-349(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-348(NuGetParams this, NuGetParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-347(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-346(NuGetParams this, NuGetParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-345(NuGetParams this, NuGetParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-359(IComparer comp, NuGetParams this, NuGetParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-358(IComparer comp, NuGetParams this, NuGetParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-357(IComparer comp, NuGetParams this, NuGetParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-356(IComparer comp, NuGetParams this, NuGetParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-355(IComparer comp, NuGetParams this, NuGetParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-354(IComparer comp, NuGetParams this, NuGetParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@45-353(IComparer comp, NuGetParams this, NuGetParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@45-74(IEqualityComparer comp, NuGetParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@45-149(NuGetParams this, NuGetParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@45-148(NuGetParams this, NuGetParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@45-147(NuGetParams this, NuGetParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@45-146(NuGetParams this, NuGetParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@45-152(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@45-151(NuGetParams this, NuGetParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@45-150(NuGetParams this, NuGetParams obj, Unit unitVar);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static NuGetParams NuGetDefaults();
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static string RequireExactly(string version);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
internal static string packageFileName(NuGetParams parameters);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string GetPackageVersion(string deploymentsDir, string package);
    internal static FSharpFunc`2<string, string> replaceKey@153(string key);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string replaceAccessKeys(NuGetParams parameters, string text);
    internal static string getFrameworkGroup@167-8(IEnumerable`1<Tuple`2<string, string>> frameworkTags);
    internal static string getGroup@174-2(FSharpList`1<a> items, FSharpFunc`2<FSharpList`1<a>, string> toTags);
    internal static string getReferencesTags@178-4(IEnumerable`1<string> references);
    internal static string getFrameworkAssemblyTags@192-8(IEnumerable`1<NugetFrameworkAssemblyReferences> references);
    internal static string getDependenciesTags@203-8(IEnumerable`1<Tuple`2<string, string>> dependencies);
    internal static string xmlEncode@232-3(string notEncodedText);
    internal static string toSingleLine@236-2(string text);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string createNuSpecFromTemplate(NuGetParams parameters, FileInfo templateNuSpec);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> createNuSpecFromTemplateIfNotProjFile(NuGetParams parameters, string nuSpecOrProjFile);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
internal static string propertiesParam(FSharpList`1<Tuple`2<string, string>> _arg1);
    internal static void execute@292-9(NuGetParams parameters, string args);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void pack(NuGetParams parameters, string nuspecFile);
    internal static FSharpOption`1<string> normalize@327-1(string str);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
internal static void publish(NuGetParams parameters);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
internal static void publishSymbols(NuGetParams parameters);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NuGetPackDirectly(FSharpFunc`2<NuGetParams, NuGetParams> setParams, string nuspecOrProjectFile);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NuGetPack(FSharpFunc`2<NuGetParams, NuGetParams> setParams, string nuspecOrProjectFile);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static void NuGetPublish(FSharpFunc`2<NuGetParams, NuGetParams> setParams);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NuGet(FSharpFunc`2<NuGetParams, NuGetParams> setParams, string nuspecOrProjectFile);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@455-362(NuSpecPackage this, NuSpecPackage obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@455-361(NuSpecPackage this, NuSpecPackage obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@455-360(NuSpecPackage this, NuSpecPackage obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@455-365(NuSpecPackage this, NuSpecPackage objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@455-364(NuSpecPackage this, NuSpecPackage objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@455-363(IComparer comp, NuSpecPackage this, NuSpecPackage objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@455-75(IEqualityComparer comp, NuSpecPackage this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@455-154(NuSpecPackage this, NuSpecPackage that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@455-153(NuSpecPackage this, NuSpecPackage that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@455-155(NuSpecPackage this, NuSpecPackage obj, Unit unitVar);
    internal static FSharpOption`1<string> getWith@494-4(XmlDocument doc, FSharpList`1<Tuple`2<string, string>> namespaces, string name, string ns);
    internal static string getValue@493-3(XmlDocument doc, FSharpList`1<Tuple`2<string, string>> namespaces, string name);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static NuSpecPackage getNuspecProperties(string nuspec);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static NuSpecPackage GetMetaDataFromPackageFile(string packageFileName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_feedUrl();
    internal static WebClient get_webClient();
    public static Lazy`1<string> get_discoverRepoUrl();
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static string getRepoUrl();
    internal static string property@558-1(XmlElement properties, string name);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static NuSpecPackage extractFeedPackageFromXml(XmlNode entry);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NuSpecPackage getPackage(string repoUrl, string packageName, string version);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static FSharpList`1<NuSpecPackage> getFeedPackagesFromUrl(string url);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NuSpecPackage getLatestPackage(string repoUrl, string packageName);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string downloadPackage(string targetDir, NuSpecPackage package);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string argList(string name, IEnumerable`1<string> values);
    internal static string attribute@626-1(string name, XElement e);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.NuGet instead")]
public static FSharpList`1<Tuple`2<string, string>> getDependencies(string packagesFile);
}
[ObsoleteAttribute("Use Fake.DotNet.NuGet.Version instead")]
[CompilationMappingAttribute("7")]
public static class Fake.NuGetVersion : object {
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Version instead")]
public static SemVerInfo IncPatch(SemVerInfo v);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Version instead")]
public static SemVerInfo IncMinor(SemVerInfo v);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Version instead")]
public static SemVerInfo IncMajor(SemVerInfo v);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Version instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<SemVerInfo> getLastNuGetVersion(string server, string packageName);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Version instead")]
public static string nextVersion(FSharpFunc`2<NuGetVersionArg, NuGetVersionArg> f);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationMappingAttribute("7")]
public static class Fake.NUnitCommon : object {
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationMappingAttribute("9")]
public static NUnitParams NUnitDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-20 { get; }
    public static NUnitParams get_NUnitDefaults();
    internal static string get_path2@32-20();
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildNUnitdArgs(NUnitParams parameters, IEnumerable`1<string> assemblies);
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
public static string getWorkingDir(NUnitParams parameters);
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
public static FSharpChoice`3<Unit, Unit, string> |OK|TestsFailed|FatalError|(int errorCode);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationMappingAttribute("7")]
public static class Fake.NUnitParallel : object {
    internal static NUnitParallelResult runSingleAssembly@48-6(string tool, NUnitParams parameters, string name, string outputFile);
    internal static FSharpList`1<string> formatErrorMessages@89-6(NUnitParams parameters, NUnitParallelResult r);
    internal static a fail@105-4(FSharpList`1<NUnitParallelResult> testRunResults, AggFailedResult aggResult, FSharpList`1<NUnitParallelResult> matchValue, Unit unitVar0);
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NUnitParallel(FSharpFunc`2<NUnitParams, NUnitParams> setParams, IEnumerable`1<string> assemblies);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationMappingAttribute("7")]
public static class Fake.NUnitSequential : object {
    internal static string errorDescription@35-6(int error);
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NUnit(FSharpFunc`2<NUnitParams, NUnitParams> setParams, IEnumerable`1<string> assemblies);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationMappingAttribute("7")]
public static class Fake.NUnitXml : object {
    internal static a imp(b arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string op_Dynamic(XElement elem, string attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XElement attr(string attr, a value, XElement elem);
    internal static XElement elem(string name);
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
public static FSharpList`1<XElement> GetTestAssemblies(XDocument xDoc);
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
public static bool AllSucceeded(IEnumerable`1<a> xDocs);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.OctoTools : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationMappingAttribute("9")]
public static OctoServerOptions serverOptions { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationMappingAttribute("9")]
public static CreateReleaseOptions releaseOptions { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationMappingAttribute("9")]
public static DeployReleaseOptions deployOptions { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationMappingAttribute("9")]
public static DeleteReleaseOptions deleteOptions { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationMappingAttribute("9")]
public static OctoParams octoParams { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-40 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@19-336(CreateReleaseOptions this, CreateReleaseOptions obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@19-335(CreateReleaseOptions this, CreateReleaseOptions obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@19-338(IComparer comp, CreateReleaseOptions this, CreateReleaseOptions objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@19-337(IComparer comp, CreateReleaseOptions this, CreateReleaseOptions objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@19-72(IEqualityComparer comp, CreateReleaseOptions this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@19-140(CreateReleaseOptions this, CreateReleaseOptions that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@19-141(CreateReleaseOptions this, CreateReleaseOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@52-340(DeployReleaseOptions this, DeployReleaseOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@52-339(DeployReleaseOptions this, DeployReleaseOptions obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@52-342(IComparer comp, DeployReleaseOptions this, DeployReleaseOptions objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@52-341(IComparer comp, DeployReleaseOptions this, DeployReleaseOptions objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@52-73(IEqualityComparer comp, DeployReleaseOptions this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@52-142(DeployReleaseOptions this, DeployReleaseOptions that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@52-143(DeployReleaseOptions this, DeployReleaseOptions obj, Unit unitVar);
    public static OctoServerOptions get_serverOptions();
    public static CreateReleaseOptions get_releaseOptions();
    public static DeployReleaseOptions get_deployOptions();
    public static DeleteReleaseOptions get_deleteOptions();
    public static OctoParams get_octoParams();
    internal static string get_path2@32-40();
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string optionalStringParam(string p, FSharpOption`1<string> o);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string optionalObjParam(string p, FSharpOption`1<a> o);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string stringListParam(string p, IEnumerable`1<a> os);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string flag(string p, bool b);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
public static string releaseCommandLine(CreateReleaseOptions opts);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
public static string deployCommandLine(DeployReleaseOptions opts);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
public static string deleteCommandLine(DeleteReleaseOptions opts);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
public static string serverCommandLine(OctoServerOptions opts);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
public static string pushCommandLine(PushOptions opts);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
public static string commandLine(OctoCommand command);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
public static string serverCommandLineForTracing(OctoServerOptions opts);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Tools.Octo module instead")]
public static void Octo(FSharpFunc`2<OctoParams, OctoParams> setParams);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.Office365ConnectorHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Section SectionDefaults { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static ConnectorCard ConnectorCardDefaults { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static JsonWriter writeJson(JsonWriter w, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static JsonWriter writePropertyName(string title, JsonWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static JsonWriter writeString(string value, JsonWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static JsonWriter writeNamedString(string title, string value, JsonWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static JsonWriter writeNonEmptyValue(string title, FSharpOption`1<string> value, JsonWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static JsonWriter asList(string title, FSharpFunc`2<JsonWriter, JsonWriter> writeValues, JsonWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static JsonWriter asObject(FSharpFunc`2<JsonWriter, JsonWriter> writeValues, JsonWriter writer);
    [CompilerGeneratedAttribute]
internal static bool contains@1-2(a e, FSharpList`1<a> xs1);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@209-111(IEqualityComparer comp, Section this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@209-211(Section this, Section that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@209-212(Section this, Section obj, Unit unitVar);
    public static Section get_SectionDefaults();
    public static ConnectorCard get_ConnectorCardDefaults();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConnectorCard validateParams(string webhookURL, ConnectorCard card);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string Office365Notification(string webhookURL, FSharpFunc`2<ConnectorCard, ConnectorCard> setParams);
}
[ObsoleteAttribute("Use Fake.DotNet.Testing.OpenCover instead (open Fake.Testing and use 'OpenCover.')")]
[CompilationMappingAttribute("7")]
public static class Fake.OpenCoverHelper : object {
    [ObsoleteAttribute("Use Fake.DotNet.Testing.OpenCover instead (open Fake.Testing and use 'OpenCover.')")]
[CompilationMappingAttribute("9")]
public static OpenCoverParams OpenCoverDefaults { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@17-422(OpenCoverParams this, OpenCoverParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@17-423(IComparer comp, OpenCoverParams this, OpenCoverParams objTemp, Unit unitVar);
    public static OpenCoverParams get_OpenCoverDefaults();
    [ObsoleteAttribute("Use Fake.DotNet.Testing.OpenCover instead (open Fake.Testing and use 'OpenCover.')")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildOpenCoverArgs(OpenCoverParams param, string targetArgs);
    [ObsoleteAttribute("Use Fake.DotNet.Testing.OpenCover instead (open Fake.Testing and use 'OpenCover.')")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void OpenCover(FSharpFunc`2<OpenCoverParams, OpenCoverParams> setParams, string targetArgs);
}
[ObsoleteAttribute("use Fake.DotNet.Paket instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Paket : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-401(PaketPackParams this, PaketPackParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-400(PaketPackParams this, PaketPackParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-399(PaketPackParams this, PaketPackParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-398(PaketPackParams this, PaketPackParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-405(PaketPackParams this, PaketPackParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-404(IComparer comp, PaketPackParams this, PaketPackParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-403(IComparer comp, PaketPackParams this, PaketPackParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-402(IComparer comp, PaketPackParams this, object obj, PaketPackParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@14-86(IEqualityComparer comp, PaketPackParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@14-168(PaketPackParams this, PaketPackParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@14-167(PaketPackParams this, PaketPackParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@14-169(PaketPackParams this, PaketPackParams obj, Unit unitVar);
    [ObsoleteAttribute("use Fake.DotNet.Paket instead")]
public static PaketPackParams PaketPackDefaults();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@57-406(PaketPushParams this, PaketPushParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@57-407(PaketPushParams this, PaketPushParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@57-87(IEqualityComparer comp, PaketPushParams this, Unit unitVar);
    [ObsoleteAttribute("use Fake.DotNet.Paket instead")]
public static PaketPushParams PaketPushDefaults();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@80-408(PaketRestoreParams this, PaketRestoreParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@80-409(IComparer comp, PaketRestoreParams this, PaketRestoreParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@80-88(IEqualityComparer comp, PaketRestoreParams this, Unit unitVar);
    [ObsoleteAttribute("use Fake.DotNet.Paket instead")]
public static PaketRestoreParams PaketRestoreDefaults();
    internal static string xmlEncode@109-4(string notEncodedText);
    [ObsoleteAttribute("use Fake.DotNet.Paket instead")]
public static void Pack(FSharpFunc`2<PaketPackParams, PaketPackParams> setParams);
    internal static FSharpList`1<FSharpList`1<a>> loop@159-28(int length, IEnumerable`1<a> xs);
    internal static FSharpFunc`2<IEnumerable`1<T>, FSharpList`1<FSharpList`1<T>>> split@158-4(int length);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> mapping@1-7(PaketPushParams parameters, string url, string endpoint, string key, string package);
    [ObsoleteAttribute("use Fake.DotNet.Paket instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void PushFiles(FSharpFunc`2<PaketPushParams, PaketPushParams> setParams, IEnumerable`1<string> files);
    [ObsoleteAttribute("use Fake.DotNet.Paket instead")]
public static void Push(FSharpFunc`2<PaketPushParams, PaketPushParams> setParams);
    [CompilerGeneratedAttribute]
internal static String[] func2@1-18(String[] array);
    [CompilerGeneratedAttribute]
internal static String[] func2@1-19(String[] array);
    internal static string find@223-1(string dir);
    internal static string getPaketLockFile@222-1(string referencesFile);
    [ObsoleteAttribute("use Fake.DotNet.Paket instead")]
public static Tuple`2[] GetDependenciesForReferencesFile(string referencesFile);
    [ObsoleteAttribute("use Fake.DotNet.Paket instead")]
public static void Restore(FSharpFunc`2<PaketRestoreParams, PaketRestoreParams> setParams);
}
[ObsoleteAttribute("use Fake.DotNet.PaketTemplate instead")]
[CompilationMappingAttribute("7")]
public static class Fake.PaketTemplate : object {
    [ObsoleteAttribute("use Fake.DotNet.PaketTemplate instead")]
[CompilationMappingAttribute("9")]
public static PaketTemplateParams DefaultPaketTemplateParams { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-414(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-413(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-412(PaketTemplateParams this, PaketTemplateParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-411(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-410(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-419(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-418(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-417(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-416(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@48-415(IComparer comp, PaketTemplateParams this, PaketTemplateParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@48-172(PaketTemplateParams this, PaketTemplateParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@48-171(PaketTemplateParams this, PaketTemplateParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@48-170(PaketTemplateParams this, PaketTemplateParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@48-174(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@48-173(PaketTemplateParams this, PaketTemplateParams obj, Unit unitVar);
    public static PaketTemplateParams get_DefaultPaketTemplateParams();
    [ObsoleteAttribute("use Fake.DotNet.PaketTemplate instead")]
public static void PaketTemplate(FSharpFunc`2<PaketTemplateParams, PaketTemplateParams> setParams);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.PermissionsHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static bool isAdmin(WindowsIdentity identity);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static a requiresAdmin(FSharpFunc`2<Unit, a> f);
}
[ObsoleteAttribute("Open Fake.Tools instead (FAKE0001 - package: Fake.Tools.Pickles, module: Pickles)")]
[CompilationMappingAttribute("7")]
public static class Fake.PicklesHelper : object {
    [ObsoleteAttribute("Open Fake.Tools instead (FAKE0001 - package: Fake.Tools.Pickles, module: Pickles, function: PicklesDefaults)")]
[CompilationMappingAttribute("9")]
public static PicklesParams PicklesDefaults { get; }
    public static PicklesParams get_PicklesDefaults();
    public static string buildPicklesArgs(PicklesParams parameters);
    [ObsoleteAttribute("Open Fake.Tools instead (FAKE0001 - package: Fake.Tools.Pickles, module: Pickles, function: convert)")]
public static void Pickles(FSharpFunc`2<PicklesParams, PicklesParams> setParams);
}
[AutoOpenAttribute]
[ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.ProcessHelper : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationMappingAttribute("9")]
public static bool AlwaysSetProcessEncoding { get; public set; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationMappingAttribute("9")]
public static Encoding ProcessEncoding { get; public set; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationMappingAttribute("9")]
public static ConcurrentBag`1<Tuple`2<int, DateTime>> startedProcesses { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationMappingAttribute("9")]
public static bool redirectOutputToTrace { get; public set; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationMappingAttribute("9")]
public static bool enableProcessTracing { get; public set; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationMappingAttribute("9")]
public static IEnumerable`1<string> pathDirectories { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> arg@1-14 { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationMappingAttribute("9")]
public static ExecParams defaultParams { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationMappingAttribute("9")]
public static bool killCreatedProcesses { get; public set; }
    public static bool get_AlwaysSetProcessEncoding();
    public static void set_AlwaysSetProcessEncoding(bool value);
    public static Encoding get_ProcessEncoding();
    public static void set_ProcessEncoding(Encoding value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ConcurrentBag`1.Clear(ConcurrentBag`1<T> );
    public static ConcurrentBag`1<Tuple`2<int, DateTime>> get_startedProcesses();
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void start(Process proc);
    public static bool get_redirectOutputToTrace();
    public static void set_redirectOutputToTrace(bool value);
    public static bool get_enableProcessTracing();
    public static void set_enableProcessTracing(bool value);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int ExecProcessWithLambdas(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut, bool silent, FSharpFunc`2<string, Unit> errorF, FSharpFunc`2<string, Unit> messageF);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcessResult ExecProcessAndReturnMessages(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut);
    internal static FSharpFunc`2<string, Unit> appendMessage@153-2(FSharpRef`1<FSharpList`1<ConsoleMessage>> messages, bool isError);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, IEnumerable`1<ConsoleMessage>> ExecProcessRedirected(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int execProcess2(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut, bool silent);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int execProcessAndReturnExitCode(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool execProcess3(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int ExecProcess(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int ExecProcessElevated(string cmd, string args, TimeSpan timeOut);
    public static IEnumerable`1<string> get_pathDirectories();
    internal static FSharpList`1<string> get_arg@1-14();
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setEnvironmentVariables(ProcessStartInfo startInfo, IEnumerable`1<Tuple`2<string, string>> environmentSettings);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool execProcess(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void fireAndForget(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static bool directExec(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void StartProcess(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RunRemoteService(string command, string host, string serviceName);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RunService(string command, string serviceName);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void StopService(string serviceName);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void StopRemoteService(string host, string serviceName);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void StartService(string serviceName);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void StartRemoteService(string host, string serviceName);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static string quote(string str);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static string quoteIfNeeded(string str);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static string toParam(string x);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static FSharpFunc`2<a, a> UseDefaults();
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static FSharpOption`1<Tuple`2<a, string>> stringParam(a paramName, string paramValue);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static FSharpFunc`2<IEnumerable`1<string>, FSharpList`1<FSharpOption`1<Tuple`2<a, string>>>> multipleStringParams(a paramName);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static FSharpOption`1<Tuple`2<a, string>> optionParam(a paramName, FSharpOption`1<b> paramValue);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static FSharpOption`1<Tuple`2<a, b>> boolParam(a paramName, bool paramValue);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string parametersToString(string flagPrefix, string delimiter, IEnumerable`1<FSharpOption`1<Tuple`2<string, string>>> parameters);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindFile(IEnumerable`1<string> dirs, string file);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findFile(IEnumerable`1<string> dirs, string file);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static FSharpOption`1<string> tryFindFileOnPath(string file);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] appSettings(string key, string fallbackValue);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindFileInDirsThenPath(IEnumerable`1<string> paths, string tool);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindPath(string settingsName, string fallbackValue, string tool);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findPath(string settingsName, string fallbackValue, string tool);
    public static ExecParams get_defaultParams();
    internal static string delimit@482-1(string str);
    internal static string formatArgs(IEnumerable`1<Tuple`2<string, string>> args);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static FSharpAsync`1<int> asyncShellExec(ExecParams args);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void kill(Process proc);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void killProcessById(int id);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static IEnumerable`1<Process> getProcessesByName(string name);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void killProcess(string name);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void killFSI();
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void killMSBuild();
    public static bool get_killCreatedProcesses();
    public static void set_killCreatedProcesses(bool value);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static void killAllCreatedProcesses();
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureProcessesHaveStopped(string name, TimeSpan timeout);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.Process module instead")]
public static int shellExec(ExecParams args);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.ProcessTestRunner : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static ProcessTestRunnerParams ProcessTestRunnerDefaults { get; }
    public static ProcessTestRunnerParams get_ProcessTestRunnerDefaults();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> RunConsoleTest(ProcessTestRunnerParams parameters, string fileName, string args);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`3<string, string, string>> runConsoleTests(ProcessTestRunnerParams parameters, IEnumerable`1<Tuple`2<string, string>> processes);
    internal static string execute@74-4(IEnumerable`1<Tuple`2<string, string>> processes, ProcessTestRunnerParams parameters, Unit unitVar0);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RunConsoleTests(FSharpFunc`2<ProcessTestRunnerParams, ProcessTestRunnerParams> setParams, IEnumerable`1<Tuple`2<string, string>> processes);
}
[CompilationMappingAttribute("7")]
public static class Fake.Profile : object {
    [CompilationMappingAttribute("9")]
public static ConcurrentBag`1<Event> events { get; }
    internal static FSharpOption`1<Tuple`2<TimeSpan, Tuple`2<int, EventBoundary[]>>> getNextSpan(int startIndex, EventBoundary[] boundaries);
    public static TimeSpan[] getCoalescedEventTimeSpans(EventBoundary[] boundaries);
    public static ConcurrentBag`1<Event> get_events();
    public static void trackEvent(Category cat);
    public static IDisposable startCategory(Category cat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a startCategoryF(Category cat, FSharpFunc`2<Unit, a> f);
    internal static string reason@168(BlockReason b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void print(bool includePaket, TimeSpan realTime);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.PsExecHelper : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string formatArgs(string host, string username, string password, string exe, string inputs);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void execRemote(string host, string username, string password, string exe, string inputs, TimeSpan timeout);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.RaygunHelper : object {
    [CompilationMappingAttribute("9")]
internal static string gitHash { get; }
    internal static string endPoint { get; }
    [CompilationMappingAttribute("9")]
internal static RaygunDeploymentData defaultData { get; }
    [CompilationMappingAttribute("9")]
internal static RaygunConnectionSettings defaultSettings { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-475(RaygunDeploymentData this, RaygunDeploymentData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-476(IComparer comp, RaygunDeploymentData this, RaygunDeploymentData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@14-99(IEqualityComparer comp, RaygunDeploymentData this, Unit unitVar);
    internal static string get_gitHash();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_endPoint();
    internal static RaygunDeploymentData get_defaultData();
    internal static RaygunConnectionSettings get_defaultSettings();
    internal static NameValueCollection createQueryStringCollection(string token);
    internal static string serialize(a data);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ReportDeployment(FSharpFunc`2<RaygunConnectionSettings, RaygunConnectionSettings> settings, FSharpFunc`2<RaygunDeploymentData, RaygunDeploymentData> data);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.RegAsmHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string regAsmToolPath { get; }
    [CompilationMappingAttribute("9")]
internal static FileIncludes arg@1-16 { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static RegAsmParams RegAsmDefaults { get; }
    public static string get_regAsmToolPath();
    internal static FileIncludes get_arg@1-16();
    public static RegAsmParams get_RegAsmDefaults();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RegAsm(FSharpFunc`2<RegAsmParams, RegAsmParams> setParams, string lib);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RegisterAssembliesWithCodebase(string workingDir, IEnumerable`1<string> assemblies);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void UnregisterAssemblies(string workingDir, IEnumerable`1<string> assemblies);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Windows.Registry instead (FAKE0001 - package: Fake.Windows.Registry - module: Fake.Windows.Registry)")]
[CompilationMappingAttribute("7")]
public static class Fake.RegistryHelper : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
public static RegistryKey getKey(RegistryBaseKey name);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
public static RegistryKey get64BitKey(RegistryBaseKey name);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
public static RegistryKey get32BitKey(RegistryBaseKey name);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RegistryKey getRegistryKey64(RegistryBaseKey baseKey, string subKey, bool writePermission);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RegistryKey getRegistryKey(RegistryBaseKey baseKey, string subKey, bool writePermission);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getRegistryValue(RegistryBaseKey baseKey, string subKey, string name);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getRegistryValue64(RegistryBaseKey baseKey, string subKey, string name);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setRegistryValue(RegistryBaseKey baseKey, string subKey, string name, T value);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteRegistryValue(RegistryBaseKey baseKey, string subKey, string name);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] getRegistryValueNames(RegistryBaseKey baseKey, string subKey);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool valueExistsForKey(RegistryBaseKey baseKey, string subKey, string name);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createRegistrySubKey(RegistryBaseKey baseKey, string subKey);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteRegistrySubKey(RegistryBaseKey baseKey, string subKey);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Windows.Registry module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] getRegistrySubKeyNames(RegistryBaseKey baseKey, string subKey);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.Core.ReleaseNotes module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.ReleaseNotesHelper : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.ReleaseNotes module instead")]
[CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Tuple`2<Match, Match>> parseVersions { get; }
    [CompilationMappingAttribute("9")]
internal static Regex nugetRegex@73-1 { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.ReleaseNotes module instead")]
[CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, FSharpOption`1<DateTime>> parseDate { get; }
    [CompilationMappingAttribute("9")]
internal static Regex dateRegex@86-1 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@47-343(ReleaseNotes this, ReleaseNotes obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@47-344(IComparer comp, ReleaseNotes this, ReleaseNotes objTemp, Unit unitVar);
    public static FSharpFunc`2<string, Tuple`2<Match, Match>> get_parseVersions();
    internal static Regex get_nugetRegex@73-1();
    public static FSharpFunc`2<string, FSharpOption`1<DateTime>> get_parseDate();
    internal static Regex get_dateRegex@86-1();
    [CompilerGeneratedAttribute]
internal static string func2@1-17(string x);
    internal static ReleaseNotes parseSimpleReleaseNotes(string line);
    internal static Tuple`2<FSharpList`1<string>, FSharpList`1<string>> findEnd@114-3(FSharpList`1<string> notes, FSharpList`1<string> text);
    internal static FSharpOption`1<Tuple`2<string, Tuple`2<FSharpList`1<string>, FSharpList`1<string>>>> findNextNotesBlock@112-1(FSharpList`1<string> text);
    internal static FSharpList`1<ReleaseNotes> loop@123-27(FSharpList`1<ReleaseNotes> releaseNotes, FSharpList`1<string> text);
    internal static FSharpList`1<ReleaseNotes> parseAllComplexReleaseNotes(IEnumerable`1<string> text);
    [CompilerGeneratedAttribute]
internal static bool func1@1-31(string value);
    internal static FSharpChoice`3<Unit, Unit, Unit> |Simple|Complex|Invalid|@145-1(char _arg1);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.ReleaseNotes module instead")]
public static FSharpList`1<ReleaseNotes> parseAllReleaseNotes(IEnumerable`1<string> data);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.ReleaseNotes module instead")]
public static ReleaseNotes parseReleaseNotes(IEnumerable`1<string> data);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.ReleaseNotes module instead")]
public static ReleaseNotes LoadReleaseNotes(string fileName);
}
[ObsoleteAttribute("Open Fake.Testing instead (FAKE0001 - package: Fake.Testing.ReportGenerator, module: ReportGenerator)")]
[CompilationMappingAttribute("7")]
public static class Fake.ReportGeneratorHelper : object {
    [ObsoleteAttribute("Open Fake.Testing instead (FAKE0001 - package: Fake.Testing.ReportGenerator, module: ReportGenerator, function: ReportGeneratorDefaultParams)")]
[CompilationMappingAttribute("9")]
public static ReportGeneratorParams ReportGeneratorDefaultParams { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@28-425(ReportGeneratorParams this, ReportGeneratorParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@28-424(ReportGeneratorParams this, ReportGeneratorParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@28-427(IComparer comp, ReportGeneratorParams this, ReportGeneratorParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@28-426(IComparer comp, ReportGeneratorParams this, ReportGeneratorParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@28-89(IEqualityComparer comp, ReportGeneratorParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@28-175(ReportGeneratorParams this, ReportGeneratorParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@28-176(ReportGeneratorParams this, ReportGeneratorParams obj, Unit unitVar);
    public static ReportGeneratorParams get_ReportGeneratorDefaultParams();
    [ObsoleteAttribute("Open Fake.Testing instead (FAKE0001 - package: Fake.Testing.ReportGenerator, module: ReportGenerator, function: buildReportGeneratorArgs (now private))")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildReportGeneratorArgs(ReportGeneratorParams parameters, IEnumerable`1<string> reports);
    [ObsoleteAttribute("Open Fake.Testing instead (FAKE0001 - package: Fake.Testing.ReportGenerator, module: ReportGenerator, function: generateReports)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ReportGenerator(FSharpFunc`2<ReportGeneratorParams, ReportGeneratorParams> setParams, FSharpList`1<string> reports);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.Net.Http module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.REST : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.Net.Http module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string ExecuteGetCommand(string userName, string password, string url);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Net.Http module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string ExecutePostCommand(FSharpFunc`2<WebHeaderCollection, Unit> headerF, string url, string userName, string password, string data);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Net.Http module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string ExecutePost(string url, string userName, string password, string data);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
[CompilationMappingAttribute("7")]
public static class Fake.RestorePackageHelper : object {
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
[CompilationMappingAttribute("9")]
public static RestorePackageParams RestorePackageDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-38 { get; }
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
[CompilationMappingAttribute("9")]
public static RestoreSinglePackageParams RestoreSinglePackageDefaults { get; }
    internal static IEnumerable`1<string> findInFolders@23-2(FSharpList`1<string> exeNames, IEnumerable`1<string> folders);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
public static string findNuget(string defaultPath);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-313(RestorePackageParams this, RestorePackageParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@50-314(IComparer comp, RestorePackageParams this, RestorePackageParams objTemp, Unit unitVar);
    public static RestorePackageParams get_RestorePackageDefaults();
    internal static string get_path2@32-38();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@70-316(RestoreSinglePackageParams this, RestoreSinglePackageParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@70-315(RestoreSinglePackageParams this, RestoreSinglePackageParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@70-318(IComparer comp, RestoreSinglePackageParams this, RestoreSinglePackageParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@70-317(IComparer comp, RestoreSinglePackageParams this, object obj, RestoreSinglePackageParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@70-64(IEqualityComparer comp, RestoreSinglePackageParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@70-132(RestoreSinglePackageParams this, RestoreSinglePackageParams that, IEqualityComparer comp, Unit unitVar);
    public static RestoreSinglePackageParams get_RestoreSinglePackageDefaults();
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runNuGet(string toolPath, TimeSpan timeOut, string args, FSharpFunc`2<Unit, Unit> failWith);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runNuGetTrial(int retries, string toolPath, TimeSpan timeOut, string args, FSharpFunc`2<Unit, Unit> failWith);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
public static string buildSources(FSharpList`1<string> sources);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildNuGetArgs(FSharpFunc`2<RestoreSinglePackageParams, RestoreSinglePackageParams> setParams, string packageId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RestorePackageId(FSharpFunc`2<RestoreSinglePackageParams, RestoreSinglePackageParams> setParams, string packageId);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RestorePackage(FSharpFunc`2<RestorePackageParams, RestorePackageParams> setParams, string packageFile);
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
public static void RestorePackages();
    [ObsoleteAttribute("Use Fake.DotNet.NuGet.Restore instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RestoreMSSolutionPackages(FSharpFunc`2<RestorePackageParams, RestorePackageParams> setParams, string solutionFile);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.RoboCopyHelper : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void roboCopyWithOptions(string source, string destination, RoboCopyOptions options);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RoboCopy(string source, string destination);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RoboCopyMirror(string source, string destination);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.RoundhouseHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static RoundhouseParams RoundhouseDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-47 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-435(RoundhouseParams this, RoundhouseParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-434(RoundhouseParams this, RoundhouseParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-433(RoundhouseParams this, RoundhouseParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-432(RoundhouseParams this, RoundhouseParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-431(RoundhouseParams this, RoundhouseParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-430(RoundhouseParams this, RoundhouseParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-429(RoundhouseParams this, RoundhouseParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-428(RoundhouseParams this, RoundhouseParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-443(IComparer comp, RoundhouseParams this, RoundhouseParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-442(IComparer comp, RoundhouseParams this, RoundhouseParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-441(IComparer comp, RoundhouseParams this, RoundhouseParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-440(IComparer comp, RoundhouseParams this, RoundhouseParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-439(IComparer comp, RoundhouseParams this, RoundhouseParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-438(IComparer comp, RoundhouseParams this, RoundhouseParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-437(IComparer comp, RoundhouseParams this, RoundhouseParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-436(IComparer comp, RoundhouseParams this, RoundhouseParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@12-90(IEqualityComparer comp, RoundhouseParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-180(RoundhouseParams this, RoundhouseParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-179(RoundhouseParams this, RoundhouseParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-178(RoundhouseParams this, RoundhouseParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-177(RoundhouseParams this, RoundhouseParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-183(RoundhouseParams this, RoundhouseParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-182(RoundhouseParams this, RoundhouseParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-181(RoundhouseParams this, RoundhouseParams obj, Unit unitVar);
    public static RoundhouseParams get_RoundhouseDefaults();
    internal static string get_path2@32-47();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<a, string>> getStringParam(a k, string v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<a, string>> getBoolParam(a k, bool v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<a, string>> getIntParam(a k, int v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string formatArgs(IEnumerable`1<FSharpOption`1<Tuple`2<string, string>>> args, string pre, string split, string delim);
    internal static string serializeArgs(IEnumerable`1<FSharpOption`1<Tuple`2<string, string>>> args);
    internal static FSharpList`1<FSharpOption`1<Tuple`2<string, string>>> getParamPairs(RoundhouseParams rh);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void Roundhouse(FSharpFunc`2<RoundhouseParams, RoundhouseParams> setParams);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.CompileRunner : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultCoreCacheInfo handleCoreCaching(FakeContext context, string compiledAssembly, string errors);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<string, FSharpFunc`2<string, FSharpOption`1<Unit>>> nameParser(string cachedAssemblyFileName, string scriptFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RunResult tryRunCached(CoreCacheInfo c, FakeContext context);
    internal static FSharpList`1<string> fixReferences@115(FSharpList`1<string> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<CompilationErrors, int> compile(FakeContext context, string outDll);
    public static Tuple`2<ResultCoreCacheInfo, RunResult> runUncached(FakeContext context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<ResultCoreCacheInfo, RunResult> runFakeScript(FSharpOption`1<CoreCacheInfo> cache, FakeContext context);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.CoreCache : object {
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<AssemblyLoadContext, FSharpFunc`2<AssemblyName, FSharpFunc`2<VerboseLevel, FSharpFunc`2<FSharpList`1<AssemblyInfo>, Assembly>>>> findAndLoadInRuntimeDepsCached { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, Assembly> assemblyCache@299 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<FSharpFunc`2<string, IntPtr>, FSharpFunc`2<string, FSharpFunc`2<VerboseLevel, FSharpFunc`2<FSharpList`1<NativeLibrary>, IntPtr>>>> resolveUnmanagedDependencyCached { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, string> libCache@350 { get; }
    public static string fakeDirectoryName { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a getCached(FSharpFunc`2<Unit, a> getUncached, FSharpFunc`2<Unit, a> readFromCache, FSharpFunc`2<a, Unit> writeToCache, FSharpFunc`2<Unit, bool> checkCacheUpToDate);
    internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, Assembly>> realLoadAssembly@193(VerboseLevel logLevel, AssemblyInfo assemInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Tuple`2<FSharpOption`1<string>, Assembly>> loadAssembly(AssemblyLoadContext loadContext, VerboseLevel logLevel, AssemblyInfo assemInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Assembly findAndLoadInRuntimeDeps(AssemblyLoadContext loadContext, AssemblyName name, VerboseLevel logLevel, FSharpList`1<AssemblyInfo> runtimeDependencies);
    public static FSharpFunc`2<AssemblyLoadContext, FSharpFunc`2<AssemblyName, FSharpFunc`2<VerboseLevel, FSharpFunc`2<FSharpList`1<AssemblyInfo>, Assembly>>>> get_findAndLoadInRuntimeDepsCached();
    internal static ConcurrentDictionary`2<string, Assembly> get_assemblyCache@299();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findUnmanagedInRuntimeDeps(string unmanagedDllName, VerboseLevel logLevel, FSharpList`1<NativeLibrary> nativeLibraries);
    public static FSharpFunc`2<FSharpFunc`2<string, IntPtr>, FSharpFunc`2<string, FSharpFunc`2<VerboseLevel, FSharpFunc`2<FSharpList`1<NativeLibrary>, IntPtr>>>> get_resolveUnmanagedDependencyCached();
    internal static ConcurrentDictionary`2<string, string> get_libCache@350();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_fakeDirectoryName();
    internal static Tuple`3<FSharpList`1<Script>, string, string> getHashUncached@412(FakeConfig config, Unit unitVar0);
    internal static void writeToCache@418(FakeConfig config, string fakeCacheFile, string fakeCacheDepsFile, string fakeCacheContentsFile, FSharpList`1<Script> tupledArg0, string tupledArg1, string tupledArg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FakeContext, FSharpOption`1<CoreCacheInfo>> prepareContext(FakeConfig config, ICachingProvider cache);
    public static void setupAssemblyResolverLogger(FakeContext context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`3<RunResult, ResultCoreCacheInfo, FakeContext> runScriptWithCacheProviderExt(FakeConfig config, ICachingProvider cache);
    [ObsoleteAttribute("Use runScriptWithCacheProviderExt instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RunResult runScriptWithCacheProvider(FakeConfig config, ICachingProvider cache);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.Environment : object {
    public static string fakeVersion { get; }
    [CompilationMappingAttribute("9")]
public static string fakeVersionStr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_fakeVersion();
    public static string get_fakeVersionStr();
    public static string environVar(string name);
    public static FSharpList`1<Tuple`2<object, object>> environVars();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setEnvironVar(string name, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string environVarOrDefault(string name, string defaultValue);
    public static string environVarOrFail(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool getEnvironmentVarAsBoolOrDefault(string varName, bool defaultValue);
    public static bool getEnvironmentVarAsBool(string varName);
    public static FSharpOption`1<string> environVarOrNone(string name);
    public static bool hasEnvironVar(string name);
    internal static Assembly getAssemblyFromType(Type t);
    internal static Assembly fsCoreAssembly();
    internal static Assembly fakeContextAssembly();
}
[CompilationMappingAttribute("7")]
internal static class Fake.Runtime.FakeHeader : object {
    internal static string dependenciesFileName { get; }
    internal static IEnumerable`1<string> readAllLines(TextReader r);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_dependenciesFileName();
    internal static FSharpFunc`2<string, string> replacePaketCommand@38(string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FakeSection writeFixedPaketDependencies(Lazy`1<string> scriptCacheDir, InlinePaketDependenciesSection f);
    internal static string fixDefaults@109(string paketCode);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FakeSection> tryReadPaketDependenciesFromScript(TokenizedScript tokenized, Lazy`1<string> cacheDir, string scriptPath);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.FakeRuntime : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<AssemblyData> filterValidAssembly(VerboseLevel logLevel, a isSdk, bool isReferenceAssembly, FileInfo fi);
    internal static void writeIntellisenseFile@97(VerboseLevel logLevel, string cacheDir);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1(Exception _arg2);
    internal static FSharpAsync`1<Unit> writeIntellisenseLazyFile@110(GroupName groupName, string cacheDir, PaketContext context);
    [CompilerGeneratedAttribute]
internal static Version projection@1-1(DependencyFile _arg7);
    internal static FSharpList`1<DependencyFile> retrieveInfosUncached@141(string cacheDir, VerboseLevel logLevel, GroupName groupName, FrameworkIdentifier framework, Lazy`1<LockFile> lockFile, Lazy`1<DependencyCache> cache, Unit unitVar0);
    internal static void restoreOrUpdate@242(FakeConfig config, string cacheDir, Dependencies paketApi, FSharpOption`1<string> group, VerboseLevel logLevel, string script, string groupStr, FileInfo lockFilePath, Unit unitVar0);
    internal static FSharpChoice`2<Unit, bool> |Library|Assembly|@294(string input);
    internal static FSharpList`1<DependencyFile> getKnownDependencies@335(string cacheDir, VerboseLevel logLevel, GroupName groupName, FrameworkIdentifier framework, FileInfo lockFilePath, string dependencyCacheHashFile, string dependencyCacheFile, Lazy`1<LockFile> lockFile, Lazy`1<DependencyCache> cache, Lazy`1<Task`1<Unit>> writeIntellisenseTask, FSharpFunc`2<Unit, FSharpList`1<DependencyFile>> readFromCache, FSharpFunc`2<FSharpList`1<DependencyFile>, Unit> writeToCache, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ICachingProvider paketCachingProvider(FakeConfig config, string cacheDir, Dependencies paketApi, Lazy`1<DependenciesFile> paketDependenciesFile, FSharpOption`1<string> group);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ICachingProvider restoreDependencies(FakeConfig config, string cacheDir, FakeSection section);
    internal static FSharpOption`1<FakeSection> tryFindGroupFromDepsFile(string scriptDir);
    public static TryPrepareInfo tryPrepareFakeScript(FakeConfig config);
    public static PrepareInfo prepareFakeScript(FakeConfig config);
    public static ICachingProvider restoreAndCreateCachingProvider(PrepareInfo p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FakeConfig createConfig(VerboseLevel logLevel, FSharpList`1<string> fsiOptions, string scriptPath, FSharpList`1<string> scriptArgs, FSharpFunc`2<string, Unit> onErrMsg, FSharpFunc`2<string, Unit> onOutMsg, bool useCache, bool restoreOnlyGroup);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FakeConfig createConfigSimple(VerboseLevel logLevel, FSharpList`1<string> fsiOptions, string scriptPath, FSharpList`1<string> scriptArgs, bool useCache, bool restoreOnlyGroup);
    public static Tuple`3<RunResult, ResultCoreCacheInfo, FakeContext> runScript(PrepareInfo preparedScript);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.FSharpParser : object {
    internal static Tuple`2<FSharpList`1<FSharpTokenInfo>, FSharpOption`1<FSharpTokenizerLexState>> tokenizeLine@10(FSharpLineTokenizer tokenizer, FSharpTokenizerLexState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TokenizedScript getTokenized(string filePath, FSharpList`1<string> defines, IEnumerable`1<string> lines);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getHashableString(bool ignoreWhitespace, TokenizedScript _arg1);
    internal static string handleRawString(string s);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<FSharpList`1<StringLike>> strings$cont@82(FSharpList`1<FSharpList`1<StringLike>> state, FSharpTokenInfo tokenInfo, string data, Unit unitVar);
    internal static PreprocessorDirective handlePreprocessorTokens(FSharpList`1<Token> tokens);
    internal static FSharpList`1<PreprocessorDirective> findProcessorDirectives(TokenizedScript _arg1);
    internal static FSharpFunc`2<Tuple`2<a, AnalyseState>, FSharpFunc`2<Token, Tuple`2<FSharpOption`1<InterestingItem>, AnalyseState>>> analyseNextToken@134();
    internal static FSharpList`1<InterestingItem> findInterestingItems(TokenizedScript _arg1);
}
[CompilationMappingAttribute("7")]
internal static class Fake.Runtime.HashGeneration : object {
    internal static IEnumerable`1<string> getAllScriptContents(IEnumerable`1<Script> pathsAndContents);
    internal static FSharpOption`1<string> tryResolvePath@21(FSharpList`1<string> currentIncludes, string currentDir, string relativeOrAbsolute, bool isDir);
    internal static string resolvePath@30(FSharpList`1<string> currentIncludes, string currentDir, string relativeOrAbsolute, bool isDir);
    internal static FSharpOption`1<string> |MatchFirstString|_|@39(string scriptName, PreprocessorDirective preprocessorDirective, FSharpList`1<StringLike> l);
    [CompilerGeneratedAttribute]
internal static Tuple`3<FSharpList`1<string>, string, FSharpList`1<Script>> loadedContents$cont@52(string scriptPath, string workDir, string scriptName, Tuple`3<FSharpList`1<string>, string, FSharpList`1<Script>> _arg1, PreprocessorDirective preprocessorDirective, FSharpList`1<string> currentIncludes, string currentDir, FSharpList`1<Script> childScripts, Unit unitVar);
    internal static FSharpList`1<Script> getAllScriptsRec@20(bool ignoreWhitespace, FSharpList`1<string> defines, string scriptPath, TokenizedScript tokens, string workDir, string scriptName, FSharpList`1<string> parentIncludes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Script> getAllScripts(bool ignoreWhitespace, FSharpList`1<string> defines, TokenizedScript tokens, string scriptPath);
    internal static string getStringHash(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getCombinedString(IEnumerable`1<Script> pathsAndContents, IEnumerable`1<string> compileOptions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getScriptHash(IEnumerable`1<Script> pathsAndContents, IEnumerable`1<string> compileOptions);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.LegacyApiHelper : object {
    public static NewApiMutableHelper`1<a> ofRef(FSharpRef`1<a> r);
    public static Tuple`2<FSharpFunc`2<Unit, a>, FSharpFunc`2<a, Unit>> toGetSet(FSharpFunc`2<Unit, NewApiMutableHelper`1<a>> f);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.Path : object {
    [CompilationMappingAttribute("9")]
internal static bool isCaseInSensitive { get; }
    [CompilationMappingAttribute("9")]
internal static string nugetDir { get; }
    [CompilationMappingAttribute("9")]
internal static char value@1 { get; }
    [CompilationMappingAttribute("9")]
internal static object matchValue@1 { get; }
    internal static bool get_isCaseInSensitive();
    internal static string normalizeFileName(string fileName);
    public static string normalizePath(string path);
    public static string getCurrentDirectory();
    internal static string get_nugetDir();
    internal static char get_value@1();
    internal static object get_matchValue@1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string fixPathForCache(string scriptPath, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string readPathFromCache(string scriptPath, string s);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.Runners : object {
    public static string fsiAssemblyName { get; }
    public static string cachedAssemblyPrefix { get; }
    public static string loadScriptName { get; }
    public static string loadScriptLazyName { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_fsiAssemblyName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_cachedAssemblyPrefix();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_loadScriptName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_loadScriptLazyName();
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.ScriptRunner : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultCoreCacheInfo handleCoreCaching(FakeContext context, IFsiSession session, string fsiErrorOutput);
    internal static string fullName@123(string endString, string i);
    public static Tuple`3<string, FSharpFunc`2<string, string>, FSharpFunc`2<string, FSharpOption`1<string>>> nameParser(string scriptFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RunResult tryRunCached(CoreCacheInfo c, FakeContext context);
    public static Tuple`2<ResultCoreCacheInfo, RunResult> runUncached(FakeContext context);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<ResultCoreCacheInfo, RunResult> runFakeScript(FSharpOption`1<CoreCacheInfo> cache, FakeContext context);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.String : object {
    public static bool isNullOrEmpty(string value);
    public static bool isNotNullOrEmpty(string value);
}
[CompilationMappingAttribute("7")]
public static class Fake.Runtime.Trace : object {
    [CompilationMappingAttribute("9")]
public static ITraceListener defaultConsoleTraceListener { get; }
    [CompilationMappingAttribute("9")]
public static List`1<ITraceListener> listeners { get; }
    [CompilationMappingAttribute("9")]
public static string fakePath { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@32-18(TraceData this, TraceData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@32-19(TraceData this, TraceData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@32-2(TraceData this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@32-7(TraceData this, object obj, Unit unitVar);
    public static ConsoleColor colorMap(TraceData traceData);
    public static ITraceListener get_defaultConsoleTraceListener();
    public static List`1<ITraceListener> get_listeners();
    public static void postMessage(TraceData x);
    public static string get_fakePath();
    public static void log(string message);
    public static void trace(string message);
    public static a tracefn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static a tracef(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static a traceFAKE(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static void traceError(string error);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.SCPHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static SCPParams SCPDefaults { get; }
    public static SCPParams get_SCPDefaults();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SCP(FSharpFunc`2<SCPParams, SCPParams> setParams, string source, string target);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.Core.SemVer module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.SemVerHelper : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.SemVer module instead")]
[CompilationMappingAttribute("9")]
public static Regex identRE { get; }
    internal static string SemVerPattern { get; }
    public static Regex get_identRE();
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.SemVer module instead")]
public static Ident parseIdent(string s);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<PreRelease> TryParse$cont@55-1(string str, FSharpList`1<string> idents, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_SemVerPattern();
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.SemVer module instead")]
public static bool isValidSemVer(string input);
    internal static FSharpOption`1<int> startPos@153(char c, string s);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, FSharpOption`1<string>, FSharpOption`1<string>> parse$cont@161-3(string version, int n, int m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, FSharpOption`1<string>, FSharpOption`1<string>> parse$cont@159-4(string version, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, FSharpOption`1<string>, FSharpOption`1<string>> parse$cont@160-5(string version, int n, Unit unitVar);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.SemVer module instead")]
public static SemVerInfo parse(string version);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.ServiceControllerHelpers : object {
    internal static string localhost { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_localhost();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string friendlyName(string host, string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isService(string name, ServiceController service);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<ServiceController> getRemoteServices(string host, string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static IEnumerable`1<ServiceController> getServices(string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<ServiceController> getRemoteService(string host, string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpOption`1<ServiceController> getService(string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool checkRemoteServiceExists(string host, string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static bool checkServiceExists(string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ServiceControllerStatus getRemoteServiceStatus(string host, string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static ServiceControllerStatus getServiceStatus(string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void startRemoteService(string host, string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void startService(string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void stopRemoteService(string host, string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void stopService(string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureRemoteServiceHasStarted(string host, string name, TimeSpan timeout);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureServiceHasStarted(string name, TimeSpan timeout);
    internal static ServiceControllerStatus getRemoteServiceStatus@148-4(string host, string name);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureRemoteServiceHasStopped(string host, string name, TimeSpan timeout);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureServiceHasStopped(string name, TimeSpan timeout);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.SignToolHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Sign(string toolsPath, SignParams parameters, IEnumerable`1<string> filesToSign);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void AppendSignature(string toolsPath, SignParams parameters, IEnumerable`1<string> filesToSign);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SignTool(string toolsPath, string certFile, FSharpOption`1<string> passFile, IEnumerable`1<string> filesToSign);
}
[ObsoleteAttribute("Use Fake.Api.Slack instead")]
[CompilationMappingAttribute("7")]
public static class Fake.SlackNotificationHelper : object {
    [ObsoleteAttribute("Use Fake.Api.Slack.NotificationDefaults instead")]
[CompilationMappingAttribute("9")]
public static SlackNotificationParams SlackNotificationDefaults { get; }
    [ObsoleteAttribute("Use Fake.Api.Slack.NotificationAttachmentDefaults instead")]
[CompilationMappingAttribute("9")]
public static SlackNotificationAttachmentParams SlackNotificationAttachmentDefaults { get; }
    [ObsoleteAttribute("Use Fake.Api.Slack.NotificationAttachmentFieldDefaults instead")]
[CompilationMappingAttribute("9")]
public static SlackNotificationAttachmentFieldParams SlackNotificationAttachmentFieldDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static DefaultContractResolver lowerCaseContractResolver { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-503(SlackNotificationAttachmentParams this, SlackNotificationAttachmentParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-504(IComparer comp, SlackNotificationAttachmentParams this, SlackNotificationAttachmentParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@23-105(IEqualityComparer comp, SlackNotificationAttachmentParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@43-505(SlackNotificationParams this, SlackNotificationParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@43-506(IComparer comp, SlackNotificationParams this, SlackNotificationParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@43-106(IEqualityComparer comp, SlackNotificationParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@43-204(SlackNotificationParams this, object obj, IEqualityComparer comp, Unit unitVar);
    public static SlackNotificationParams get_SlackNotificationDefaults();
    public static SlackNotificationAttachmentParams get_SlackNotificationAttachmentDefaults();
    public static SlackNotificationAttachmentFieldParams get_SlackNotificationAttachmentFieldDefaults();
    internal static DefaultContractResolver get_lowerCaseContractResolver();
    internal static void validateField@105-1(SlackNotificationAttachmentFieldParams field);
    internal static void validateAttachment@108-1(SlackNotificationAttachmentParams attachment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlackNotificationParams ValidateParams(string webhookURL, SlackNotificationParams param);
    internal static string SerializeData(a data);
    internal static string sendNotification@125-2(string webhookURL, a param);
    [ObsoleteAttribute("Use Fake.Api.Slack.sendNotification instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string SlackNotification(string webhookURL, FSharpFunc`2<SlackNotificationParams, SlackNotificationParams> setParams);
}
[ObsoleteAttribute("Use Fake.Testing.SonarQube instead (open Fake.Testing and use 'SonarQube.')")]
[CompilationMappingAttribute("7")]
public static class Fake.SonarQubeHelper : object {
    [ObsoleteAttribute("Use Fake.Testing.SonarQube instead (open Fake.Testing and use 'SonarQube.')")]
[CompilationMappingAttribute("9")]
public static SonarQubeParams SonarQubeDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-51 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-507(SonarQubeParams this, SonarQubeParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-508(IComparer comp, SonarQubeParams this, SonarQubeParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@13-107(IEqualityComparer comp, SonarQubeParams this, Unit unitVar);
    public static SonarQubeParams get_SonarQubeDefaults();
    internal static string get_path2@32-51();
    [ObsoleteAttribute("Use Fake.Testing.SonarQube instead (open Fake.Testing and use 'SonarQube.')")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SonarQubeCall(SonarQubeCall call, SonarQubeParams parameters);
    [ObsoleteAttribute("Use Fake.Testing.SonarQube instead (open Fake.Testing and use 'SonarQube.')")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SonarQube(SonarQubeCall call, FSharpFunc`2<SonarQubeParams, SonarQubeParams> setParams);
    [ObsoleteAttribute("Use Fake.Testing.SonarQube instead (open Fake.Testing and use 'SonarQube.')")]
public static void SonarQubeEnd();
}
[AutoOpenAttribute]
[ObsoleteAttribute("Open Fake.DotNet.Testing instead (FAKE0001 - package: Fake.DotNet.Testing.SpecFlow, module: SpecFlow)")]
[CompilationMappingAttribute("7")]
public static class Fake.SpecFlowHelper : object {
    [ObsoleteAttribute("Open Fake.DotNet.Testing instead (FAKE0001 - package: Fake.DotNet.Testing.SpecFlow, module: SpecFlow, function: toolname (now private))")]
public static string toolname { get; }
    [ObsoleteAttribute("Open Fake.DotNet.Testing instead (FAKE0001 - package: Fake.DotNet.Testing.SpecFlow, module: SpecFlow, function: SpecFlowDefaults)")]
[CompilationMappingAttribute("9")]
public static SpecFlowParams SpecFlowDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-39 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-332(SpecFlowParams this, SpecFlowParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-331(SpecFlowParams this, SpecFlowParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-334(SpecFlowParams this, SpecFlowParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-333(SpecFlowParams this, SpecFlowParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@13-71(SpecFlowParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@13-138(SpecFlowParams this, SpecFlowParams that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@13-139(SpecFlowParams this, SpecFlowParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_toolname();
    public static SpecFlowParams get_SpecFlowDefaults();
    internal static string get_path2@32-39();
    [ObsoleteAttribute("Open Fake.DotNet.Testing instead (FAKE0001 - package: Fake.DotNet.Testing.SpecFlow, module: SpecFlow, function: generate)")]
public static void SpecFlow(FSharpFunc`2<SpecFlowParams, SpecFlowParams> setParams);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Sql.DacPac : object {
    [CompilationMappingAttribute("9")]
public static FSharpList`1<string> validPaths { get; }
    [CompilationMappingAttribute("9")]
internal static IEnumerable`1<Tuple`2<string, int>> sql@48 { get; }
    [CompilationMappingAttribute("9")]
internal static IGlobbingPattern arg@1-9 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Tuple`2<string, int>> mapping@48-3 { get; }
    [CompilationMappingAttribute("9")]
internal static IGlobbingPattern source@48 { get; }
    [CompilationMappingAttribute("9")]
internal static IEnumerable`1<Tuple`2<string, int>> vs@49 { get; }
    [CompilationMappingAttribute("9")]
internal static IGlobbingPattern arg@1-10 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Tuple`2<string, int>> mapping@49-4 { get; }
    [CompilationMappingAttribute("9")]
internal static IGlobbingPattern source@49-1 { get; }
    [CompilationMappingAttribute("9")]
internal static IEnumerable`1<Tuple`2<string, int>> vs2017@50 { get; }
    [CompilationMappingAttribute("9")]
internal static IGlobbingPattern arg@1-11 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Tuple`2<string, int>> mapping@50-5 { get; }
    [CompilationMappingAttribute("9")]
internal static IGlobbingPattern source@50-2 { get; }
    [CompilationMappingAttribute("9")]
public static DeployDbArgs DefaultDeploymentArgs { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-217(DeployDbArgs this, DeployDbArgs obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-216(DeployDbArgs this, DeployDbArgs obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-219(IComparer comp, DeployDbArgs this, DeployDbArgs objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-218(IComparer comp, DeployDbArgs this, DeployDbArgs objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@23-89(DeployDbArgs this, DeployDbArgs that, IEqualityComparer comp, Unit unitVar);
    public static FSharpList`1<string> get_validPaths();
    internal static IEnumerable`1<Tuple`2<string, int>> get_sql@48();
    internal static IGlobbingPattern get_arg@1-9();
    internal static FSharpFunc`2<string, Tuple`2<string, int>> get_mapping@48-3();
    internal static IGlobbingPattern get_source@48();
    internal static IEnumerable`1<Tuple`2<string, int>> get_vs@49();
    internal static IGlobbingPattern get_arg@1-10();
    internal static FSharpFunc`2<string, Tuple`2<string, int>> get_mapping@49-4();
    internal static IGlobbingPattern get_source@49-1();
    internal static IEnumerable`1<Tuple`2<string, int>> get_vs2017@50();
    internal static IGlobbingPattern get_arg@1-11();
    internal static FSharpFunc`2<string, Tuple`2<string, int>> get_mapping@50-5();
    internal static IGlobbingPattern get_source@50-2();
    public static DeployDbArgs get_DefaultDeploymentArgs();
    internal static Tuple`2<string, string> generateCommandLine(DeployAction args);
    internal static FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, string> concat@91(string parameter);
    [CompilerGeneratedAttribute]
internal static bool contains@1-1(a e, FSharpList`1<a> xs1);
    public static void deployDb(FSharpFunc`2<DeployDbArgs, DeployDbArgs> setParams);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.Installer.Squirrel module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Squirrel : object {
    [ObsoleteAttribute("FAKE0001 Use the Fake.Installer.Squirrel module instead")]
[CompilationMappingAttribute("9")]
public static SquirrelParams SquirrelDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-48 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-478(SquirrelParams this, SquirrelParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-477(SquirrelParams this, SquirrelParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-480(IComparer comp, SquirrelParams this, SquirrelParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-479(IComparer comp, SquirrelParams this, SquirrelParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@15-100(IEqualityComparer comp, SquirrelParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@15-194(SquirrelParams this, SquirrelParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@15-195(SquirrelParams this, SquirrelParams obj, Unit unitVar);
    public static SquirrelParams get_SquirrelDefaults();
    internal static string get_path2@32-48();
    internal static string createSigningArgs(SquirrelParams parameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string buildSquirrelArgs(SquirrelParams parameters, string nugetPackage);
    [ObsoleteAttribute("FAKE0001 Use Fake.Installer.Squirrel.releasify instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SquirrelPack(FSharpFunc`2<SquirrelParams, SquirrelParams> setParams, string nugetPackage);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.SSHHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static SSHParams SSHDefaults { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@9-321(SSHParams this, SSHParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@9-322(SSHParams this, SSHParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@9-66(SSHParams this, Unit unitVar);
    public static SSHParams get_SSHDefaults();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SSH(FSharpFunc`2<SSHParams, SSHParams> setParams, string command);
}
[AutoOpenAttribute]
[ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationMappingAttribute("7")]
public static class Fake.StringHelper : object {
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, bool> endsWithSlash { get; }
    [CompilationMappingAttribute("9")]
internal static char copyOfStruct@68-2 { get; internal set; }
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationMappingAttribute("9")]
internal static Dictionary`2<string, Regex> regexes { get; }
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationMappingAttribute("9")]
public static FSharpList`1<char> charsAndDigits { get; }
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static char Colon { get; }
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string LinuxLineBreaks { get; }
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string WindowsLineBreaks { get; }
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string MacLineBreaks { get; }
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationMappingAttribute("9")]
public static Dictionary`2<string, string> relativePaths { get; }
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string productName();
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static bool isNullOrEmpty(string value);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static bool isNotNullOrEmpty(string value);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static bool isNullOrWhiteSpace(string value);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replace(string pattern, string replacement, string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string separated(string delimiter, IEnumerable`1<string> items);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string trimSlash(string s);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> split(char delimiter, string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> splitRemove(char delimiter, string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> splitStr(string delimiterStr, string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string toLines(IEnumerable`1<string> text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool startsWith(string prefix, string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool endsWith(string suffix, string text);
    public static FSharpFunc`2<string, bool> get_endsWithSlash();
    internal static char get_copyOfStruct@68-2();
    internal static void set_copyOfStruct@68-2(char value);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string replaceFirst(string pattern, string replacement, string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder append(string text, StringBuilder builder);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendWithoutQuotes(string text, StringBuilder builder);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendIfSome(FSharpOption`1<a> o, FSharpFunc`2<a, string> f, StringBuilder builder);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendIfTrue(bool p, string s, StringBuilder builder);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendIfTrueWithoutQuotes(bool p, string s, StringBuilder builder);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>> appendIfFalse(bool p);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<StringBuilder, StringBuilder> appendWithoutQuotesIfNotNull(object value, string s);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<StringBuilder, StringBuilder> appendIfNotNull(object value, string s);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendQuotedIfNotNull(object value, string s, StringBuilder builder);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>> appendStringIfValueIsNotNull(a value);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>> appendStringIfValueIsNotNullOrEmpty(string value);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<StringBuilder, StringBuilder> appendIfNotNullOrEmpty(string value, string s);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder appendFileNamesIfNotNull(IEnumerable`1<string> fileNames, StringBuilder builder);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StringBuilder forEach(FSharpList`1<a> items, FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<StringBuilder, c>>> action, b text, StringBuilder builder);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string toText(StringBuilder builder);
    internal static Dictionary`2<string, Regex> get_regexes();
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static Regex getRegEx(string pattern);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string regex_replace(string pattern, string replacement, string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static bool isUmlaut(char c);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string toLower(string s);
    public static FSharpList`1<char> get_charsAndDigits();
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static bool isLetterOrDigit(char c);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string trimSeparator(string s);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string trimSpecialChars(string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string trim(string x);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string trimChars(Char[] chars, string x);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string trimStartChars(Char[] chars, string x);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string trimEndChars(Char[] chars, string x);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static FSharpOption`1<string> liftString(string x);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.read`/`File.readWithEncoding` instead (encoding parameter added, default to UTF8)")]
public static IEnumerable`1<string> ReadFile(string file);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.readLine`/`File.readLineWithEncoding` instead (encoding parameter added, default to UTF8)")]
public static string ReadLine(string file);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.write`/`File.writeWithEncoding` instead (encoding parameter added, default to UTF8)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void WriteToFile(bool append, string fileName, IEnumerable`1<string> lines);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string NormalizeVersion(string version);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.writeBytes` instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void WriteBytesToFile(string file, Byte[] bytes);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.writeString`/`File.writeStringWithEncoding` instead (encoding parameter added, default to UTF8)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void WriteStringToFile(bool append, string fileName, string text);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.replaceContent` instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ReplaceFile(string fileName, string text);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static char get_Colon();
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.writeNew` instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void WriteFile(string file, IEnumerable`1<string> lines);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.append` instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void AppendToFile(string file, IEnumerable`1<string> lines);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.readAsString`/`File.readAsStringWithEncoding` instead")]
public static string ReadFileAsString(string file);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.readAsBytes` instead")]
public static Byte[] ReadFileAsBytes(string file);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string shortenCurrentDirectory(string value);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_LessMultiply(string prefix, string text);
    [ObsoleteAttribute("FAKE0001 use `open Fake.IO` and `File.applyReplace` instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ReplaceInFile(FSharpFunc`2<string, string> replaceF, string fileName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_LinuxLineBreaks();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_WindowsLineBreaks();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_MacLineBreaks();
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string ConvertTextToWindowsLineBreaks(string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static void ConvertFileToWindowsLineBreaks(string fileName);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string RemoveLineBreaks(string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string EncapsulateApostrophe(string text);
    public static Dictionary`2<string, string> get_relativePaths();
    [CompilerGeneratedAttribute]
internal static string ProduceRelativePath$cont@393-1(string baseLocation, string targetLocation, Unit unitVar);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string ProduceRelativePath(string baseLocation, string targetLocation);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string toRelativePath(string value);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string op_GreaterEqualsGreater(string pattern, string replacement, string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool op_GreaterMultiplyMultiply(string pattern, string text);
    [ObsoleteAttribute("FAKE0001 use Fake.Core.String instead")]
public static string DecodeBase64Utf8String(string text);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.StrongNamingHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string SN32 { get; public set; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static string SN64 { get; public set; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static StrongNameParams StrongNameDefaults { get; }
    public static string get_SN32();
    public static void set_SN32(string value);
    public static string get_SN64();
    public static void set_SN64(string value);
    public static StrongNameParams get_StrongNameDefaults();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void StrongName(FSharpFunc`2<StrongNameParams, StrongNameParams> setParams, string command);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void DisableVerification(string assembly, string key);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.StyleCopHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static StyleCopParams StyleCopDefaults { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@22-515(StyleCopParams this, StyleCopParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@22-516(IComparer comp, StyleCopParams this, StyleCopParams objTemp, Unit unitVar);
    public static StyleCopParams get_StyleCopDefaults();
    internal static void addSourceFile@72(StyleCopConsole analyser, CodeProject codeProject, CSharpSourceFile sourceFile);
    internal static FSharpList`1<b> combineCodeProjectFromFiles@76(int id, FSharpList`1<a> files, FSharpFunc`2<int, FSharpFunc`2<a, b>> func);
    internal static FSharpList`1<CodeProject> addSourceFiles@85(StyleCopConsole analyser, Configuration config, int id, FSharpList`1<CSharpSourceFile> files);
    internal static FSharpList`1<CodeProject> addProjectFiles@93(Configuration config, FSharpFunc`2<CodeProject, FSharpFunc`2<CSharpSourceFile, Unit>> addSourceFile, int id, FSharpList`1<CSharpProjectFile> files);
    internal static FSharpList`1<CodeProject> addSolutionFiles@102(Configuration config, FSharpFunc`2<CodeProject, FSharpFunc`2<CSharpSourceFile, Unit>> addSourceFile, int id, FSharpList`1<SolutionFile> files);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void StyleCop(FSharpFunc`2<StyleCopParams, StyleCopParams> setParams);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.SxsHelper : object {
    [CompilationMappingAttribute("9")]
internal static string mtToolPath { get; }
    [CompilationMappingAttribute("9")]
internal static FileIncludes arg@1-18 { get; }
    [CompilationMappingAttribute("9")]
internal static string ildasmPath { get; }
    [CompilationMappingAttribute("9")]
internal static FileIncludes arg@1-19 { get; }
    internal static string manifestNamespace { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<XDocument, FSharpFunc`2<XDocument, Unit>> copyAssemblyIdName { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<XDocument, FSharpFunc`2<XDocument, Unit>> copyAssemblyIdVersion { get; }
    internal static string get_mtToolPath();
    internal static FileIncludes get_arg@1-18();
    internal static string get_ildasmPath();
    internal static FileIncludes get_arg@1-19();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_manifestNamespace();
    internal static XName nsXn(string s);
    internal static XName xn(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void setAssemblyIdAttributeValue(string attributeName, a attributeValue, XContainer manifest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getAssemblyIdAttributeValue(string attributeName, XContainer manifest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void setAssemblyName(XContainer manifest, a name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void setAssemblyVersion(XContainer manifest, a version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void copyAssemblyIdAttributeValue(string attributeName, XContainer toManifest, XContainer fromManifest);
    internal static FSharpFunc`2<XDocument, FSharpFunc`2<XDocument, Unit>> get_copyAssemblyIdName();
    internal static FSharpFunc`2<XDocument, FSharpFunc`2<XDocument, Unit>> get_copyAssemblyIdVersion();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void copyElements(XContainer toManifest, string toElement, XContainer fromManifest, string elementName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void copyClrClasses(XContainer toManifest, XContainer fromManifest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<Unit> embedManiFestAsync(string workingDir, FSharpAsync`1<Tuple`2<string, string>> asyncData);
    internal static string createManifestPath@136(string workingDir, string assembly);
    internal static FSharpAsync`1<Tuple`2<string, string>> createManiFestBaseAsync@147(string workingDir, string assembly);
    internal static FSharpAsync`1<Tuple`2<string, string>> createManifestAsync@159(string assemblyManifestBase, FSharpAsync`1<Tuple`2<string, string>> asyncData);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void AddEmbeddedAssemblyManifest(string workingDir, IEnumerable`1<string> assemblies);
    internal static FSharpFunc`2<string, string> getValueBetween@202(char startChar, char endChar);
    internal static FSharpOption`1<Guid> getGuid@210(a assembly, String[] customDataLines);
    internal static ILparsingResult tryGetInteropInfo@220(string tupledArg0, IEnumerable`1<string> tupledArg1);
    internal static FSharpAsync`1<ILparsingResult> tryGetInteropInfoAsync@248(FSharpAsync`1<Tuple`2<string, String[]>> asyncData);
    internal static FSharpAsync`1<Tuple`2<string, String[]>> getRawAssemblyDataAsync@254(string workingDir, string assembly);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<InteropAssemblyData> GetInteropAssemblyData(string workingDir, IEnumerable`1<string> assemblies);
    internal static IEnumerable`1<XElement> createDependencyElements@314(XElement dependencyBase, IEnumerable`1<InteropAssemblyData> dependencies);
    internal static Tuple`2<string, string> createManifest@323(string workingDir, string applicationManifestBase, XElement dependencyBase, InteropApplicationData application);
    internal static FSharpAsync`1<Tuple`2<string, string>> createManifestAsync@332-5(string workingDir, string applicationManifestBase, XElement dependencyBase, InteropApplicationData application);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void AddEmbeddedApplicationManifest(string workingDir, IEnumerable`1<InteropApplicationData> applications);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - module: Fake.Core.Target)")]
[CompilationMappingAttribute("7")]
public static class Fake.TargetHelper : object {
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationMappingAttribute("9")]
public static bool PrintStackTraceOnError { get; public set; }
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationMappingAttribute("9")]
public static string LastDescription { get; public set; }
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationMappingAttribute("9")]
public static Dictionary`2<string, TargetTemplate`1<Unit>> TargetDict { get; }
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationMappingAttribute("9")]
public static Dictionary`2<string, bool> FinalTargets { get; }
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationMappingAttribute("9")]
public static Dictionary`2<string, bool> BuildFailureTargets { get; }
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationMappingAttribute("9")]
public static HashSet`1<string> ExecutedTargets { get; }
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationMappingAttribute("9")]
public static List`1<Tuple`2<string, TimeSpan>> ExecutedTargetTimes { get; }
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationMappingAttribute("9")]
public static FSharpList`1<FSharpList`1<string>> CurrentTargetOrder { get; public set; }
    [ObsoleteAttribute("Please open an issue and tell us why you need it! (FAKE0002 - package: Fake.Core.Target - no longer supported)")]
[CompilationMappingAttribute("9")]
public static string CurrentTarget { get; public set; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<BuildError> errors { get; internal set; }
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationMappingAttribute("9")]
public static bool isListMode { get; }
    public static bool get_PrintStackTraceOnError();
    public static void set_PrintStackTraceOnError(bool value);
    public static string get_LastDescription();
    public static void set_LastDescription(string value);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static void Description(string text);
    public static Dictionary`2<string, TargetTemplate`1<Unit>> get_TargetDict();
    public static Dictionary`2<string, bool> get_FinalTargets();
    public static Dictionary`2<string, bool> get_BuildFailureTargets();
    public static HashSet`1<string> get_ExecutedTargets();
    public static List`1<Tuple`2<string, TimeSpan>> get_ExecutedTargetTimes();
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static void reset();
    public static FSharpList`1<FSharpList`1<string>> get_CurrentTargetOrder();
    public static void set_CurrentTargetOrder(FSharpList`1<FSharpList`1<string>> value);
    public static string get_CurrentTarget();
    public static void set_CurrentTarget(string value);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static FSharpList`1<string> getAllTargetsNames();
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.Get)")]
public static TargetTemplate`1<Unit> getTarget(string name);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static string dependencyString(TargetTemplate`1<a> target);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static string softDependencyString(TargetTemplate`1<a> target);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.DoNothing)")]
public static void DoNothing();
    internal static void checkDependencies@136-4(FSharpFunc`2<TargetTemplate`1<Unit>, FSharpList`1<string>> fGetDependencies, string targetName, TargetTemplate`1<Unit> dependentTarget);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<TargetTemplate`1<Unit>, TargetTemplate`1<Unit>> checkIfDependencyCanBeAddedCore(FSharpFunc`2<TargetTemplate`1<Unit>, FSharpList`1<string>> fGetDependencies, string targetName, string dependentTargetName);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<TargetTemplate`1<Unit>, TargetTemplate`1<Unit>> checkIfDependencyCanBeAdded(string targetName, string dependentTargetName);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<TargetTemplate`1<Unit>, TargetTemplate`1<Unit>> checkIfSoftDependencyCanBeAdded(string targetName, string dependentTargetName);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void dependencyAtFront(string targetName, string dependentTargetName);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void dependencyAtEnd(string targetName, string dependentTargetName);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void softDependencyAtEnd(string targetName, string dependentTargetName);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void dependency(string targetName, string dependentTargetName);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void softDependency(string targetName, string dependentTargetName);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Dependencies(string targetName, FSharpList`1<string> dependentTargetNames);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SoftDependencies(string targetName, FSharpList`1<string> dependentTargetNames);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - open Fake.Core.TargetOperators)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void op_LessEqualsEquals(string x, FSharpList`1<string> ys);
    [ObsoleteAttribute("Please use the ==> operator")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void TargetsDependOn(string target, IEnumerable`1<string> targets);
    [ObsoleteAttribute("Please use the ==> operator")]
public static void AllTargetsDependOn(string target);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case. Note you can create Template with functions that Target.Create using a closure on function parameters + defines dependencies with TargetOperators.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void targetFromTemplate(TargetTemplate`1<a> template, string name, a parameters);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case. Note you can create Template with functions that Target.Create using a closure on function parameters + defines dependencies with TargetOperators.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void TargetTemplateWithDependencies(FSharpList`1<string> dependencies, FSharpFunc`2<a, Unit> body, string name, a parameters);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case. Note you can create Template with functions that Target.Create using a closure on function parameters + defines dependencies with TargetOperators.")]
public static FSharpFunc`2<FSharpFunc`2<a, Unit>, FSharpFunc`2<string, FSharpFunc`2<a, Unit>>> TargetTemplateWithDependecies(FSharpList`1<string> dependencies);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case. Note you can create Template with functions that Target.Create using a closure on function parameters + defines dependencies with TargetOperators.")]
public static FSharpFunc`2<string, FSharpFunc`2<a, Unit>> TargetTemplate(FSharpFunc`2<a, Unit> body);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.Create)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Target(string name, FSharpFunc`2<Unit, Unit> body);
    internal static FSharpList`1<BuildError> get_errors();
    internal static void set_errors(FSharpList`1<BuildError> value);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static FSharpList`1<BuildError> GetErrors();
    internal static string error@331-5(Exception exn, Exception e);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void targetError(string targetName, Exception exn);
    [CompilerGeneratedAttribute]
internal static void action@1-14(string target, TimeSpan time, Unit unitVar0);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void addExecutedTarget(string target, TimeSpan time);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static void runFinalTargets();
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static void runBuildFailureTargets();
    internal static a appendfn@394-6(StringBuilder sb, PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.ListAvailable)")]
public static void PrintTargets();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<DependencyType, a>> withDependencyType(DependencyType depType, FSharpList`1<a> targets);
    internal static void visitDependenciesAux@415-2(FSharpFunc`2<TargetTemplate`1<Unit>, a> fGetDependencies, FSharpFunc`2<Tuple`5<FSharpOption`1<TargetTemplate`1<Unit>>, TargetTemplate`1<Unit>, DependencyType, int, bool>, Unit> fVisit, HashSet`1<string> visited, List`1<string> ordered, int level, FSharpOption`1<TargetTemplate`1<Unit>> dependentTarget, Tuple`2<DependencyType, string> tupledArg);
    internal static Tuple`2<HashSet`1<string>, List`1<string>> visit@412-2(FSharpFunc`2<TargetTemplate`1<Unit>, a> fGetDependencies, FSharpFunc`2<Tuple`5<FSharpOption`1<TargetTemplate`1<Unit>>, TargetTemplate`1<Unit>, DependencyType, int, bool>, Unit> fVisit, string targetName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<HashSet`1<string>, List`1<string>> visitDependencies(FSharpFunc`2<Tuple`5<FSharpOption`1<TargetTemplate`1<Unit>>, TargetTemplate`1<Unit>, DependencyType, int, bool>, Unit> fVisit, string targetName);
    internal static a appendfn@448-9(StringBuilder sb, PrintfFormat`4<a, Unit, string, Unit> fmt);
    internal static FSharpFunc`2<Tuple`5<a, TargetTemplate`1<Unit>, DependencyType, int, bool>, Unit> logDependency@452-7(bool verbose, StringBuilder sb, FSharpTypeFunc appendfn);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.PrintDependencyGraph)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void PrintDependencyGraph(bool verbose, string target);
    internal static a appendfn@468-12(StringBuilder sb, PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("Not yet migrated, waiting for your contribution ;) (FAKE0004 - package: Fake.Core.Target - member: Fake.Core.Target.PrintRunningOrder to be created)")]
public static void PrintRunningOrder();
    internal static a appendfn@483-15(StringBuilder sb, PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("Not yet migrated, waiting for your contribution ;) (FAKE0004 - package: Fake.Core.Target - member: Fake.Core.Target.PrintDotDependencyGraph to be created)")]
public static void PrintDotDependencyGraph();
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static void WriteErrors();
    internal static void aligned@519-1(int width, string name, b duration);
    internal static void alignedError@520-1(int width, string name, b duration);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.WriteTaskTimeSummary)")]
public static void WriteTaskTimeSummary(a total);
    internal static void changeExitCodeIfErrorOccured();
    public static bool get_isListMode();
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.ListAvailable)")]
public static void listTargets();
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static bool doesTargetMeanListTargets(string target);
    internal static bool doesTargetMeanPrintDotGraph(string target);
    internal static FSharpList`1<string> appendDepentantOption@589(FSharpList`1<string> currentList, FSharpOption`1<TargetTemplate`1<Unit>> dependantTarget);
    internal static void SetDependency@594(Dictionary`2<string, DependencyLevel> targetLevels, FSharpOption`1<TargetTemplate`1<Unit>> dependantTarget, string target);
    internal static void SetTargetLevel@600(Dictionary`2<string, DependencyLevel> targetLevels, int newLevel, string target);
    internal static void AddNewTargetLevel@617(Dictionary`2<string, DependencyLevel> targetLevels, FSharpOption`1<TargetTemplate`1<Unit>> dependantTarget, int level, string target);
    internal static FSharpOption`1<Tuple`2<DependencyLevel, c>> |LevelIncreaseWithDependantTarget|_|@621(int level, bool _arg30, DependencyLevel _arg31, FSharpOption`1<c> _arg32);
    internal static FSharpOption`1<DependencyLevel> |LevelIncreaseWithNoDependantTarget|_|@625(int level, bool _arg40, DependencyLevel _arg41, FSharpOption`1<c> _arg42);
    internal static FSharpOption`1<DependencyLevel> |LevelDecrease|_|@629(int level, bool _arg50, DependencyLevel _arg51, c _arg52);
    internal static FSharpOption`1<Tuple`2<DependencyLevel, TargetTemplate`1<c>>> |AddDependency|_|@633(bool _arg60, DependencyLevel _arg61, FSharpOption`1<TargetTemplate`1<c>> _arg62);
    internal static FSharpOption`1<Unit> |NewTarget|_|@637(bool _arg70, c _arg71, d _arg72);
    internal static FSharpFunc`2<Tuple`5<FSharpOption`1<TargetTemplate`1<Unit>>, TargetTemplate`1<Unit>, a, int, b>, Unit> addTargetLevel@620(Dictionary`2<string, DependencyLevel> targetLevels);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.determineBuildOrder)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<TargetTemplate`1[]> determineBuildOrder(string target, int parallelJobs);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static void runSingleTarget(TargetTemplate`1<Unit> target);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runTargetsParallel(int count, TargetTemplate`1[] targets);
    [ObsoleteAttribute("Internal state is no more accessible now (FAKE0003 - package: Fake.Core.Target). If you consider, it is still useful, please open an issue and explain your use case")]
public static void runTargets(TargetTemplate`1[] targets);
    [CompilerGeneratedAttribute]
internal static void run$cont@715(string targetName, Unit unitVar);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.Run)")]
public static void run(string targetName);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.CreateBuildFailure)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void BuildFailureTarget(string name, FSharpFunc`2<Unit, Unit> body);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.ActivateBuildFailure)")]
public static void ActivateBuildFailureTarget(string name);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.CreateFinal)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FinalTarget(string name, FSharpFunc`2<Unit, Unit> body);
    [ObsoleteAttribute("Use Fake.Core.Target instead (FAKE0001 - package: Fake.Core.Target - member: Fake.Core.Target.ActivateFinal)")]
public static void ActivateFinalTarget(string name);
}
[ObsoleteAttribute("Use Fake.Core.TaskRunner instead (open Fake.Core and use 'TaskRunner')")]
[CompilationMappingAttribute("7")]
public static class Fake.TaskRunnerHelper : object {
    [ObsoleteAttribute("Use Fake.Core.TaskRunner instead (open Fake.Core and use 'TaskRunner')")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TimeSpan waitFor(FSharpFunc`2<Unit, bool> f, TimeSpan timeout, int testMS, FSharpFunc`2<Unit, Unit> timeoutF);
    [ObsoleteAttribute("Use Fake.Core.TaskRunner instead (open Fake.Core and use 'TaskRunner')")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a runWithRetries(FSharpFunc`2<Unit, a> f, int retries);
}
[AutoOpenAttribute]
[ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity instead")]
[CompilationMappingAttribute("7")]
public static class Fake.TeamCityHelper : object {
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use the Trace module instead")]
[CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, string> scrub { get; }
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use the TeamCity.block instead")]
[CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Unit> sendOpenBlock { get; }
    [CompilationMappingAttribute("9")]
internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> format@36 { get; }
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use the TeamCity.block instead")]
[CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Unit> sendCloseBlock { get; }
    [CompilationMappingAttribute("9")]
internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> format@40-1 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Unit> sendTeamCityDotCoverHome { get; }
    [CompilationMappingAttribute("9")]
internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> format@123-2 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Unit> sendTeamCityNCover3Home { get; }
    [CompilationMappingAttribute("9")]
internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> format@126-3 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Unit> sendTeamCityNCover3ReporterArgs { get; }
    [CompilationMappingAttribute("9")]
internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> format@129-4 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Unit> sendTeamCityNCoverExplorerTool { get; }
    [CompilationMappingAttribute("9")]
internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> format@132-5 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, Unit> sendTeamCityNCoverExplorerToolArgs { get; }
    [CompilationMappingAttribute("9")]
internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> format@135-6 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<int, Unit> sendTeamCityNCoverReportType { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> func2@1-11 { get; }
    [CompilationMappingAttribute("9")]
internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> format@138-7 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<int, Unit> sendTeamCityNCoverReportOrder { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> func2@1-12 { get; }
    [CompilationMappingAttribute("9")]
internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> format@141-8 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, Unit> sendTeamCityPartCoverReportXslts { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, string> func1@1-25 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, string> func1@1-26 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, IEnumerable`1<string>> func1@1-27 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, IEnumerable`1<string>> func1@1-28 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<string>, IEnumerable`1<string>> func2@1-13 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<IEnumerable`1<string>, string> func2@1-14 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> func2@1-15 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> clo1@148-1 { get; }
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.Environment.Version instead")]
[CompilationMappingAttribute("9")]
public static FSharpOption`1<string> TeamCityVersion { get; }
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.Environment.ProjectName instead")]
[CompilationMappingAttribute("9")]
public static FSharpOption`1<string> TeamCityProjectName { get; }
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.Environment.BuildConfigurationName instead")]
[CompilationMappingAttribute("9")]
public static FSharpOption`1<string> TeamCityBuildConfigurationName { get; }
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.Environment.BuildIsPersonal instead")]
[CompilationMappingAttribute("9")]
public static bool TeamCityBuildIsPersonal { get; }
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.Environment.BuildNumber instead")]
[CompilationMappingAttribute("9")]
public static FSharpOption`1<string> TeamCityBuildNumber { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpOption`1<IEnumerable`1<string>>> recentlyFailedTests { get; }
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use the Trace module instead")]
public static string EncapsulateSpecialChars(string text);
    public static FSharpFunc`2<string, string> get_scrub();
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use the Trace module instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void sendToTeamCity(PrintfFormat`4<FSharpFunc`2<string, string>, Unit, string, string> format, string message);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use the Trace module instead")]
public static void sendStrToTeamCity(string s);
    public static FSharpFunc`2<string, Unit> get_sendOpenBlock();
    internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> get_format@36();
    public static FSharpFunc`2<string, Unit> get_sendCloseBlock();
    internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> get_format@40-1();
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use the TeamCity.block instead")]
public static IDisposable teamCityBlock(string name);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use the TeamCity.<> instead")]
public static void sendTeamCityError(string error);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityNUnitImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityFXCopImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityJUnitImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCitySurefireImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityMSTestImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityGTestImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityCheckstyleImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityFindBugsImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityJSLintImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityReSharperInspectCodeImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityFxCopImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityPmdImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityPmdCpdImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void sendTeamCityDotNetDupFinderImport(string path);
    [ObsoleteAttribute("This function does not specify the type of coverage tool used to generate the report.  Use 'sendTeamCityDotNetCoverageImportForTool' instead")]
public static void sendTeamCityDotNetCoverageImport(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void sendTeamCityDotNetCoverageImportForTool(string path, TeamCityDotNetCoverageTool tool);
    public static FSharpFunc`2<string, Unit> get_sendTeamCityDotCoverHome();
    internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> get_format@123-2();
    public static FSharpFunc`2<string, Unit> get_sendTeamCityNCover3Home();
    internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> get_format@126-3();
    public static FSharpFunc`2<string, Unit> get_sendTeamCityNCover3ReporterArgs();
    internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> get_format@129-4();
    public static FSharpFunc`2<string, Unit> get_sendTeamCityNCoverExplorerTool();
    internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> get_format@132-5();
    public static FSharpFunc`2<string, Unit> get_sendTeamCityNCoverExplorerToolArgs();
    internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> get_format@135-6();
    public static FSharpFunc`2<int, Unit> get_sendTeamCityNCoverReportType();
    [CompilerGeneratedAttribute]
internal static string func1@1-23(int value);
    internal static FSharpFunc`2<string, Unit> get_func2@1-11();
    internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> get_format@138-7();
    public static FSharpFunc`2<int, Unit> get_sendTeamCityNCoverReportOrder();
    [CompilerGeneratedAttribute]
internal static string func1@1-24(int value);
    internal static FSharpFunc`2<string, Unit> get_func2@1-12();
    internal static PrintfFormat`5<FSharpFunc`2<string, string>, Unit, string, string, string> get_format@141-8();
    public static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, Unit> get_sendTeamCityPartCoverReportXslts();
    internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, string> get_func1@1-25();
    internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, string> get_func1@1-26();
    internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, IEnumerable`1<string>> get_func1@1-27();
    internal static FSharpFunc`2<IEnumerable`1<Tuple`2<string, string>>, IEnumerable`1<string>> get_func1@1-28();
    internal static FSharpFunc`2<IEnumerable`1<string>, IEnumerable`1<string>> get_func2@1-13();
    internal static FSharpFunc`2<IEnumerable`1<string>, string> get_func2@1-14();
    internal static FSharpFunc`2<string, string> get_func2@1-15();
    internal static FSharpFunc`2<string, string> get_clo1@148-1();
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.<> instead")]
public static void StartTestCase(string testCaseName);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.<> instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FinishTestCase(string testCaseName, TimeSpan duration);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.<> instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void IgnoreTestCase(string name, string message);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.<> instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void IgnoreTestCaseWithDetails(string name, string message, string details);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.<> instead")]
public static void FinishTestSuite(string testSuiteName);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.<> instead")]
public static void StartTestSuite(string testSuiteName);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.<> instead")]
public static void ReportProgress(string message);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.<> instead")]
public static void ReportProgressStart(string message);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.<> instead")]
public static void ReportProgressFinish(string message);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.<> instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildStatus(string status, string message);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.<> instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ReportBuildStatus(string status, string message);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void PublishArtifact(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.publish instead")]
public static void PublishArticfact(string path);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.setBuildNumber instead")]
public static void SetBuildNumber(string buildNumber);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.<> instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SetBuildStatistic(string key, string value);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.<> instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void SetTeamCityParameter(string name, string value);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.<> instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void TestFailed(string name, string message, string details);
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use Trace.<> instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ComparisonFailure(string name, string message, string details, string expected, string actual);
    public static FSharpOption`1<string> get_TeamCityVersion();
    public static FSharpOption`1<string> get_TeamCityProjectName();
    public static FSharpOption`1<string> get_TeamCityBuildConfigurationName();
    public static bool get_TeamCityBuildIsPersonal();
    public static FSharpOption`1<string> get_TeamCityBuildNumber();
    internal static FSharpOption`1<IEnumerable`1<string>> getRecentlyFailedTests'();
    internal static Lazy`1<FSharpOption`1<IEnumerable`1<string>>> get_recentlyFailedTests();
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.Environment.RecentlyFailedTests instead")]
public static FSharpOption`1<IEnumerable`1<string>> getTeamCityRecentlyFailedTests();
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.Environment.Branch instead")]
public static FSharpOption`1<string> getTeamCityBranch();
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.Environment.BranchDisplayName instead")]
public static FSharpOption`1<string> getTeamCityBranchName();
    [ObsoleteAttribute("please use nuget 'Fake.BuildServer.TeamCity', open Fake.BuildServer and use TeamCity.Environment.IsDefaultBranch instead")]
public static bool getTeamCityBranchIsDefault();
}
[AutoOpenAttribute]
[ObsoleteAttribute("please check the Fake.BuildServer.TeamCity module for a replacement and send a PR to include this into FAKE 5 if needed.")]
[CompilationMappingAttribute("7")]
public static class Fake.TeamCityRESTHelper : object {
    [ObsoleteAttribute("please check the Fake.BuildServer.TeamCity module for a replacement and send a PR to include this into FAKE 5 if needed.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string prepareURL(string restURL, string serverURL);
    [ObsoleteAttribute("please check the Fake.BuildServer.TeamCity module for a replacement and send a PR to include this into FAKE 5 if needed.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getRESTVersion(string serverURL, string username, string password);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@35-47(IEqualityComparer comp, BuildConfiguration this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@46-48(IEqualityComparer comp, Project this, Unit unitVar);
    [ObsoleteAttribute("please check the Fake.BuildServer.TeamCity module for a replacement and send a PR to include this into FAKE 5 if needed.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlElement getFirstNode(string serverURL, string username, string password, string url);
    internal static bool parseBooleanOrFalse(string s);
    [ObsoleteAttribute("please check the Fake.BuildServer.TeamCity module for a replacement and send a PR to include this into FAKE 5 if needed.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static BuildConfiguration getBuildConfig(string serverURL, string username, string password, string id);
    [ObsoleteAttribute("please check the Fake.BuildServer.TeamCity module for a replacement and send a PR to include this into FAKE 5 if needed.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Project getProject(string serverURL, string username, string password, string id);
    [ObsoleteAttribute("please check the Fake.BuildServer.TeamCity module for a replacement and send a PR to include this into FAKE 5 if needed.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> getProjects(string serverURL, string username, string password);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.IO.Templates instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Templates)")]
[CompilationMappingAttribute("7")]
public static class Fake.TemplateHelper : object {
    [ObsoleteAttribute("Use Fake.IO.Templates instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Templates.saveFiles)")]
[CompilationMappingAttribute("9")]
public static FSharpFunc`2<IEnumerable`1<Tuple`2<string, IEnumerable`1<string>>>, Unit> saveFiles { get; }
    [ObsoleteAttribute("Use Fake.IO.Templates instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Templates.loadTemplates)")]
public static IEnumerable`1<Tuple`2<string, IEnumerable`1<string>>> loadTemplates(IEnumerable`1<string> seq);
    [ObsoleteAttribute("Use Fake.IO.Templates instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Templates.replaceKeywords)")]
public static FSharpFunc`2<IEnumerable`1<Tuple`2<a, b>>, IEnumerable`1<Tuple`2<a, IEnumerable`1<string>>>> replaceKeywords(IEnumerable`1<Tuple`2<string, string>> replacements);
    public static FSharpFunc`2<IEnumerable`1<Tuple`2<string, IEnumerable`1<string>>>, Unit> get_saveFiles();
    [ObsoleteAttribute("Use Fake.IO.Templates instead (FAKE0001 - package: Fake.IO.FileSystem - member: Fake.IO.Templates.replaceInFiles)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void processTemplates(IEnumerable`1<Tuple`2<string, string>> replacements, IEnumerable`1<string> files);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.TestFlightHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static TestFlightParams TestFlightDefaults { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@11-373(TestFlightParams this, TestFlightParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@11-372(TestFlightParams this, TestFlightParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@11-375(IComparer comp, TestFlightParams this, TestFlightParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@11-374(IComparer comp, TestFlightParams this, object obj, TestFlightParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@11-77(IEqualityComparer comp, TestFlightParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@11-158(TestFlightParams this, TestFlightParams that, IEqualityComparer comp, Unit unitVar);
    public static TestFlightParams get_TestFlightDefaults();
    internal static TestFlightParams validateParams(TestFlightParams ps);
    internal static IEnumerable`1<string> toCurlArgs(TestFlightParams ps);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void TestFlight(FSharpFunc`2<TestFlightParams, TestFlightParams> setParams);
}
[CompilationMappingAttribute("7")]
public static class Fake.Testing.Common : object {
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.Testing.Expecto : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-243(ExpectoParams this, ExpectoParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-242(ExpectoParams this, ExpectoParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-241(ExpectoParams this, ExpectoParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-240(ExpectoParams this, ExpectoParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-246(IComparer comp, ExpectoParams this, ExpectoParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-245(IComparer comp, ExpectoParams this, ExpectoParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@13-244(IComparer comp, ExpectoParams this, ExpectoParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@13-50(IEqualityComparer comp, ExpectoParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@13-98(ExpectoParams this, ExpectoParams that, IEqualityComparer comp, Unit unitVar);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendIfTrue@47-2(bool value, string s);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendIfNotNullOrWhiteSpace@49-4(string value, string s);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendIfNotEqual@53-4(a other, a value, string s);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendList@57-2(FSharpList`1<string> list, string s);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@13-99(ExpectoParams this, ExpectoParams obj, Unit unitVar);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Expecto(FSharpFunc`2<ExpectoParams, ExpectoParams> setParams, IEnumerable`1<string> assemblies);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Testing.NUnit3 : object {
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationMappingAttribute("9")]
public static NUnit3Params NUnit3Defaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-21 { get; }
    public static NUnit3Params get_NUnit3Defaults();
    internal static string get_path2@32-21();
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
public static string getWorkingDir(NUnit3Params parameters);
    internal static FSharpFunc`2<StringBuilder, StringBuilder> appendResultString@285-3(FSharpList`1<string> results);
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildNUnit3Args(NUnit3Params parameters, IEnumerable`1<string> assemblies);
    internal static string errorDescription@335-9(int error);
    [ObsoleteAttribute("use Fake.DotNet.Testing.NUnit instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void NUnit3(FSharpFunc`2<NUnit3Params, NUnit3Params> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.Testing.SonarQube : object {
    [CompilationMappingAttribute("9")]
public static SonarQubeParams SonarQubeDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-8 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-9 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-150(SonarQubeParams this, SonarQubeParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@14-151(IComparer comp, SonarQubeParams this, SonarQubeParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@14-24(IEqualityComparer comp, SonarQubeParams this, Unit unitVar);
    public static SonarQubeParams get_SonarQubeDefaults();
    internal static string get_path1@7-8();
    internal static string get_path2@7-9();
    [CompilerGeneratedAttribute]
internal static ProcStartInfo func1@1-15(string sonarPath, string args, ProcStartInfo info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SonarQubeCall(SonarQubeCall call, SonarQubeParams parameters);
    public static void start(FSharpFunc`2<SonarQubeParams, SonarQubeParams> setParams);
    public static void finish(FSharpOption`1<FSharpFunc`2<SonarQubeParams, SonarQubeParams>> setParams);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationMappingAttribute("7")]
public static class Fake.Testing.XUnit : object {
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationMappingAttribute("9")]
public static XUnitParams XUnitDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> HtmlOutputPath@59-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> NUnitXmlOutputPath@60-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> XmlOutputPath@61-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<string, string>> IncludeTraits@62-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<string, string>> ExcludeTraits@63-1 { get; }
    [CompilationMappingAttribute("9")]
internal static TestRunnerErrorLevel ErrorLevel@65-1 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-22 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-255(XUnitParams this, XUnitParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-254(XUnitParams this, XUnitParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-253(XUnitParams this, XUnitParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-258(IComparer comp, XUnitParams this, XUnitParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-257(IComparer comp, XUnitParams this, XUnitParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@15-256(IComparer comp, XUnitParams this, object obj, XUnitParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@15-53(IEqualityComparer comp, XUnitParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@15-103(XUnitParams this, XUnitParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@15-104(XUnitParams this, XUnitParams obj, Unit unitVar);
    public static XUnitParams get_XUnitDefaults();
    internal static FSharpOption`1<string> get_HtmlOutputPath@59-1();
    internal static FSharpOption`1<string> get_NUnitXmlOutputPath@60-1();
    internal static FSharpOption`1<string> get_XmlOutputPath@61-1();
    internal static FSharpList`1<Tuple`2<string, string>> get_IncludeTraits@62-1();
    internal static FSharpList`1<Tuple`2<string, string>> get_ExcludeTraits@63-1();
    internal static TestRunnerErrorLevel get_ErrorLevel@65-1();
    internal static string get_path2@32-22();
    internal static string formatTrait@74-4(string traitFlag, string tupledArg0, string tupledArg1);
    internal static FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>> appendTraits@76-3(IEnumerable`1<Tuple`2<string, string>> traitsList);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string buildXUnitArgs(string assembly, XUnitParams parameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int runXUnitForOneAssembly(XUnitParams parameters, string assembly);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void xUnitSingle(FSharpFunc`2<XUnitParams, XUnitParams> setParams, string assembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XUnitParams overrideAssemblyReportParams(string assembly, XUnitParams p);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void xUnit(FSharpFunc`2<XUnitParams, XUnitParams> setParams, IEnumerable`1<string> assemblies);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead")]
[CompilationMappingAttribute("7")]
public static class Fake.Testing.XUnit2 : object {
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead")]
[CompilationMappingAttribute("9")]
public static XUnit2Params XUnit2Defaults { get; }
    [CompilationMappingAttribute("9")]
internal static ParallelMode Parallel@173-1 { get; }
    [CompilationMappingAttribute("9")]
internal static CollectionConcurrencyMode MaxThreads@174-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> HtmlOutputPath@175-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> XmlOutputPath@176-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> XmlV1OutputPath@177-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> NUnitXmlOutputPath@178-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<string, string>> IncludeTraits@179-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<string, string>> ExcludeTraits@180-2 { get; }
    [CompilationMappingAttribute("9")]
internal static TestRunnerErrorLevel ErrorLevel@182-2 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-24 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-268(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-267(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-266(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-265(XUnit2Params this, XUnit2Params obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-272(IComparer comp, XUnit2Params this, XUnit2Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-271(IComparer comp, XUnit2Params this, XUnit2Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-270(IComparer comp, XUnit2Params this, XUnit2Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@101-269(IComparer comp, XUnit2Params this, XUnit2Params objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@101-108(XUnit2Params this, XUnit2Params that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@101-107(XUnit2Params this, XUnit2Params that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@101-109(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    public static XUnit2Params get_XUnit2Defaults();
    internal static ParallelMode get_Parallel@173-1();
    internal static CollectionConcurrencyMode get_MaxThreads@174-1();
    internal static FSharpOption`1<string> get_HtmlOutputPath@175-2();
    internal static FSharpOption`1<string> get_XmlOutputPath@176-2();
    internal static FSharpOption`1<string> get_XmlV1OutputPath@177-1();
    internal static FSharpOption`1<string> get_NUnitXmlOutputPath@178-2();
    internal static FSharpList`1<Tuple`2<string, string>> get_IncludeTraits@179-2();
    internal static FSharpList`1<Tuple`2<string, string>> get_ExcludeTraits@180-2();
    internal static TestRunnerErrorLevel get_ErrorLevel@182-2();
    internal static string get_path2@32-24();
    internal static string formatTrait@196-8(string traitFlag, string tupledArg0, string tupledArg1);
    internal static FSharpFunc`2<string, FSharpFunc`2<StringBuilder, StringBuilder>> appendTraits@198-6(IEnumerable`1<Tuple`2<string, string>> traitsList);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildXUnit2Args(IEnumerable`1<string> assemblies, XUnit2Params parameters);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead")]
internal static XUnit2Params discoverNoAppDomainExists(XUnit2Params parameters);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void xUnit2(FSharpFunc`2<XUnit2Params, XUnit2Params> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Branches : object {
    internal static FSharpList`1<string> cleanBranches(IEnumerable`1<string> text);
    public static FSharpList`1<string> getLocalBranches(string repositoryDir);
    public static FSharpList`1<string> getRemoteBranches(string repositoryDir);
    public static FSharpList`1<string> getAllBranches(string repositoryDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getSHA1(string repositoryDir, string commit);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findMergeBase(string repositoryDir, string commit1, string commit2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int revisionsBetween(string repositoryDir, string commit1, string commit2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkoutBranch(string repositoryDir, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkoutTracked(string repositoryDir, string trackBranch, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkoutNewBranch(string repositoryDir, string baseBranch, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkout(string repositoryDir, bool create, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createBranch(string repositoryDir, string newBranchName, string commit);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteBranch(string repositoryDir, bool force, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void tag(string repositoryDir, string tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteTag(string repositoryDir, string tag);
    public static void push(string repositoryDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pushTag(string repositoryDir, string remote, string tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pushBranch(string repositoryDir, string remote, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void pull(string repositoryDir, string remote, string branch);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.CommandHelper : object {
    [CompilationMappingAttribute("9")]
public static TimeSpan gitTimeOut { get; public set; }
    internal static string GitPath { get; }
    [CompilationMappingAttribute("9")]
public static string gitPath { get; }
    public static TimeSpan get_gitTimeOut();
    public static void set_gitTimeOut(TimeSpan value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_GitPath();
    public static string get_gitPath();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ProcStartInfo setInfo(string gitPath, string repositoryDir, string command, ProcStartInfo info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`3<bool, FSharpList`1<string>, string> runGitCommand(string repositoryDir, string command);
    public static a runGitCommandf(PrintfFormat`4<a, Unit, string, FSharpFunc`2<string, Tuple`3<bool, FSharpList`1<string>, string>>> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> getGitResult(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void fireAndForgetGitCommand(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool directRunGitCommand(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void directRunGitCommandAndFail(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void gitCommand(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a gitCommandf(string repositoryDir, PrintfFormat`4<a, Unit, string, Unit> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void showGitCommand(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string runSimpleGitCommand(string repositoryDir, string command);
    public static string fixPath(string path);
    internal static DirectoryInfo findGitDir@99(DirectoryInfo dirInfo);
    public static DirectoryInfo findGitDir(string repositoryDir);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Commit : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void exec(string repositoryDir, string message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void execExtended(string repositoryDir, string shortMessage, string extendedMessage);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.CommitMessage : object {
    public static FSharpList`1<FileInfo> getCommitMessageFileInfos(string repositoryDir);
    public static string getCommitMessage(string repositoryDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setMessage(string repositoryDir, string text);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.FileStatus : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<FileStatus, string>> getChangedFiles(string repositoryDir, string revision1, string revision2);
    public static IEnumerable`1<Tuple`2<FileStatus, string>> getAllFiles(string repositoryDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<FileStatus, string>> getChangedFilesInWorkingCopy(string repositoryDir, string revision);
    public static FSharpList`1<string> getConflictedFiles(string repositoryDir);
    public static bool isInTheMiddleOfConflictedMerge(string repositoryDir);
    public static string getRebaseDir(string repositoryDir);
    public static bool isInTheMiddleOfRebase(string repositoryDir);
    public static bool isInTheMiddleOfPatch(string repositoryDir);
    public static void cleanWorkingCopy(string repositoryDir);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Information : object {
    [CompilationMappingAttribute("9")]
internal static Regex versionRegex { get; }
    internal static Regex get_versionRegex();
    public static string getVersion(string repositoryDir);
    public static SemVerInfo extractGitVersion(string version);
    public static bool isGitVersionHigherOrEqual(string referenceVersion);
    public static string getBranchName(string repositoryDir);
    public static string getCurrentSHA1(string repositoryDir);
    public static void showStatus(string repositoryDir);
    public static bool isCleanWorkingCopy(string repositoryDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string showName(string repositoryDir, string sha1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isAheadOf(string repositoryDir, string rev1, string rev2);
    public static string describe(string repositoryDir);
    public static string shortlog(string repositoryDir);
    public static string getLastTag();
    public static string getCurrentHash();
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Merge : object {
    public static string FastForwardFlag { get; }
    public static string NoFastForwardFlag { get; }
    public static string getMergeMessage(string repositoryDir);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_FastForwardFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_NoFastForwardFlag();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static MergeType compareBranches(string repositoryDir, string local, string remote);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void merge(string repositoryDir, string flags, string branch);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Rebase : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void start(string repositoryDir, string onTopOfBranch);
    public static void abort(string repositoryDir);
    public static void continueRebase(string repositoryDir);
    public static void skip(string repositoryDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rollBackAndUseMerge(string repositoryDir, string onTopOfBranch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rebaseOrFallbackOnMerge(string repositoryDir, string onTopOfBranch);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Repository : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void clone(string workingDir, string repoUrl, string toPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void cloneSingleBranch(string workingDir, string repoUrl, string branchName, string toPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void init(string repositoryDir, bool bare, bool shared);
    public static void fullclean(string repositoryDir);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Reset : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string addArgs(string commit, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string resetOrCheckout(string file, string mode);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void soft(string repositoryDir, string commit, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void mixed(string repositoryDir, string commit, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void hard(string repositoryDir, string commit, string file);
    public static void ResetSoft(string repositoryDir);
    public static void ResetMixed(string repositoryDir);
    public static void ResetHard(string repositoryDir);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.SanityChecks : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkRevisionExists(string repositoryDir, string revision1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkIfBranchExists(string repositoryDir, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkIfBranchIsAbsent(string repositoryDir, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkIsLocalBranch(string repositoryDir, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkIsRemoteBranch(string repositoryDir, string branch);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.SHA1 : object {
    public static string calcSHA1(string text);
    public static string calcGitSHA1(string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string showObjectHash(string repositoryDir, string fileName);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Staging : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`3<bool, FSharpList`1<string>, string> stageFile(string repositoryDir, string file);
    public static void stageAll(string repositoryDir);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Stash : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void push(string repositoryDir, string message);
    public static void pop(string repositoryDir);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Git.Submodule : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@8-148(Submodule this, Submodule obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@8-149(Submodule this, Submodule objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@8-22(Submodule this, Unit unitVar);
    internal static string trimChars(string s);
    public static IEnumerable`1<Submodule> getSubModules(string repositoryDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void init(string superRepositoryDir, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void add(string superRepositoryDir, string remotePath, string localPath, string branch);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Tools.GitVersion : object {
    [CompilationMappingAttribute("9")]
internal static GitversionParams gitversionDefaults { get; }
    internal static GitversionParams get_gitversionDefaults();
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@18-23(IEqualityComparer comp, GitVersionProperties this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@18-62(GitVersionProperties this, GitVersionProperties that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@18-61(GitVersionProperties this, GitVersionProperties that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@18-64(GitVersionProperties this, GitVersionProperties obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@18-63(GitVersionProperties this, GitVersionProperties obj, Unit unitVar);
    public static GitVersionProperties generateProperties(FSharpFunc`2<GitversionParams, GitversionParams> setParams);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Tools.Octo : object {
    [CompilationMappingAttribute("9")]
internal static ServerOptions serverOptions { get; }
    [CompilationMappingAttribute("9")]
internal static Options commonOptions { get; }
    [CompilationMappingAttribute("9")]
internal static string path1@7-7 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-8 { get; }
    [CompilationMappingAttribute("9")]
internal static CreateReleaseOptions releaseOptions { get; }
    [CompilationMappingAttribute("9")]
internal static DeployReleaseOptions deployOptions { get; }
    [CompilationMappingAttribute("9")]
internal static DeleteReleasesOptions deleteOptions { get; }
    [CompilationMappingAttribute("9")]
internal static PushOptions pushOptions { get; }
    internal static ServerOptions get_serverOptions();
    internal static Options get_commonOptions();
    internal static string get_path1@7-7();
    internal static string get_path2@7-8();
    internal static CreateReleaseOptions get_releaseOptions();
    internal static DeployReleaseOptions get_deployOptions();
    internal static DeleteReleasesOptions get_deleteOptions();
    internal static PushOptions get_pushOptions();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string optionalStringParam(string p, FSharpOption`1<string> o);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string optionalObjParam(string p, FSharpOption`1<a> o);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringListParam(string p, IEnumerable`1<a> os);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string flag(string p, bool b);
    internal static string releaseCommandLine(CreateReleaseOptions opts);
    internal static string deployCommandLine(DeployReleaseOptions opts);
    internal static string deleteCommandLine(DeleteReleasesOptions opts);
    internal static string serverCommandLine(ServerOptions opts);
    internal static string pushCommandLine(PushOptions opts);
    internal static string commandLine(Command command);
    internal static string serverCommandLineForTracing@255(ServerOptions opts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void exec(Command command, Options options);
    public static void createRelease(FSharpFunc`2<CreateReleaseOptions, CreateReleaseOptions> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createReleaseAndDeploy(FSharpFunc`2<CreateReleaseOptions, CreateReleaseOptions> setReleaseParams, FSharpFunc`2<DeployReleaseOptions, FSharpOption`1<DeployReleaseOptions>> setDeployParams);
    public static void deployRelease(FSharpFunc`2<DeployReleaseOptions, DeployReleaseOptions> setParams);
    public static void deleteReleases(FSharpFunc`2<DeleteReleasesOptions, DeleteReleasesOptions> setParams);
    public static void listEnvironments(FSharpFunc`2<Options, Options> setParams);
    public static void push(FSharpFunc`2<PushOptions, PushOptions> setParams);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
[CompilationMappingAttribute("7")]
public static class Fake.TraceHelper : object {
    [ObsoleteAttribute("Don't use anymore, there is no equivalent, please open an issue in FAKE if you need help.")]
[CompilationMappingAttribute("9")]
public static string fakePath { get; }
    [ObsoleteAttribute("use Fake.Runtime.Environment.fakeVersion instead (open Fake.Runtime and use 'Environment.')")]
public static string fakeVersion { get; }
    [CompilationMappingAttribute("9")]
internal static ThreadLocal`1<FSharpList`1<string>> openTags { get; }
    [ObsoleteAttribute("use Fake.Runtime.Environment.fakeVersionStr instead (open Fake.Runtime and use 'Environment.')")]
[CompilationMappingAttribute("9")]
public static string fakeVersionStr { get; }
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
[CompilationMappingAttribute("9")]
public static ITraceListener console { get; }
    public static string get_fakePath();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_fakeVersion();
    internal static ThreadLocal`1<FSharpList`1<string>> get_openTags();
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void log(string message);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static a logfn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static a logf(PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static a logVerbosefn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void trace(string message);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static a tracefn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static a tracef(PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void traceVerbose(string s);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void traceImportant(string text);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static a traceFAKE(PrintfFormat`4<a, Unit, string, Unit> fmt);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void traceError(string error);
    [CompilerGeneratedAttribute]
internal static void action@1-11(StringBuilder sb, string nl, Exception e, PropertyInfo p);
    internal static void printException@81-25(StringBuilder sb, string delimeter, string nl, Exception e, int count);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static string exceptionAndInnersToString(Exception ex);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void traceException(Exception ex);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void TraceEnvironmentVariables();
    public static string get_fakeVersionStr();
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void traceLine();
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void traceHeader(string name);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void traceStartBuild();
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void traceEndBuild();
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void openTag(string tag);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void closeTag(string tag);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void closeAllOpenTags();
    [ObsoleteAttribute("This method is unsafe, please use nuget 'Fake.Core.Trace', open Fake.Core and use 'use _ = Trace.traceTarget' to properly finish the target on errors or use traceStartTargetUnsafe if you know what you do")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceStartTarget(string name, string description, string dependencyString);
    [ObsoleteAttribute("This method is unsafe, please use nuget 'Fake.Core.Trace', open Fake.Core and use 'use _ = Trace.traceTarget' to properly finish the target on errors or use traceStartTargetUnsafe if you know what you do")]
public static void traceEndTarget(string name);
    [ObsoleteAttribute("This method is unsafe, please use nuget 'Fake.Core.Trace', open Fake.Core and use 'use _ = Trace.traceTask' to properly finish the task on errors or use traceStartTaskUnsafe if you know what you do")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceStartTask(string task, string description);
    [ObsoleteAttribute("This method is unsafe, please use nuget 'Fake.Core.Trace', open Fake.Core and use 'use _ = Trace.traceTask' to properly finish the task on errors or use traceStartTaskUnsafe if you know what you do")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void traceEndTask(string task, string description);
    [ObsoleteAttribute("Please use nuget 'Fake.Core.Trace', open Fake.Core and use 'use _ = Trace.traceTask' to properly finish the task on errors or use traceStartTaskUnsafe if you know what you do")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IDisposable traceStartTaskUsing(string task, string description);
    public static ITraceListener get_console();
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.')")]
public static void logToConsole(string msg, EventLogEntryType eventLogEntry);
    [ObsoleteAttribute("use nuget 'Fake.Core.Trace' instead (open Fake.Core and use 'Trace.logItems')")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Log(string message, IEnumerable`1<string> files);
}
[AutoOpenAttribute]
[ObsoleteAttribute("please use nuget 'Fake.Core.Trace' and open Fake.Core instead")]
[CompilationMappingAttribute("7")]
public static class Fake.TraceListener : object {
    [ObsoleteAttribute("please use nuget 'Fake.Core.Trace' and open Fake.Core instead")]
[CompilationMappingAttribute("9")]
public static bool importantMessagesToStdErr { get; }
    [CompilationMappingAttribute("9")]
internal static BuildServer y@1-1 { get; }
    [ObsoleteAttribute("please use nuget 'Fake.Core.Trace' and open Fake.Core instead")]
[CompilationMappingAttribute("9")]
public static bool useAnsiColors { get; }
    [CompilationMappingAttribute("9")]
internal static BuildServer y@1-2 { get; }
    [ObsoleteAttribute("please use nuget 'Fake.Core.Trace' and open Fake.Core instead")]
[CompilationMappingAttribute("9")]
public static ConsoleTraceListener defaultConsoleTraceListener { get; }
    [ObsoleteAttribute("please use nuget 'Fake.Core.Trace' and open Fake.Core instead")]
[CompilationMappingAttribute("9")]
public static bool AutoCloseXmlWriter { get; public set; }
    [ObsoleteAttribute("please use nuget 'Fake.Core.Trace' and open Fake.Core instead")]
[CompilationMappingAttribute("9")]
public static List`1<ITraceListener> listeners { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-234(TraceData this, TraceData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-235(TraceData this, TraceData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@10-46(TraceData this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@10-95(TraceData this, TraceData that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@10-96(TraceData this, TraceData obj, Unit unitVar);
    [ObsoleteAttribute("please use nuget 'Fake.Core.Trace' and open Fake.Core instead")]
public static ConsoleColor colorMap(TraceData traceData);
    internal static FSharpFunc`2<FSharpFunc`2<string, a>, a> writeText@114(ConsoleTraceListener this, ConsoleColor color, string text);
    internal static FSharpList`1<int> colorCode@77-1(ConsoleColor _arg1);
    public static bool get_importantMessagesToStdErr();
    internal static BuildServer get_y@1-1();
    public static bool get_useAnsiColors();
    internal static BuildServer get_y@1-2();
    public static ConsoleTraceListener get_defaultConsoleTraceListener();
    public static bool get_AutoCloseXmlWriter();
    public static void set_AutoCloseXmlWriter(bool value);
    public static List`1<ITraceListener> get_listeners();
    [ObsoleteAttribute("please use nuget 'Fake.Core.Trace' and open Fake.Core instead")]
public static void addXmlListener(string xmlOutputFile);
    [ObsoleteAttribute("please use nuget 'Fake.Core.Trace' and open Fake.Core instead")]
public static void postMessage(TraceData x);
}
[CompilationMappingAttribute("7")]
public static class Fake.Tracing.NAntXml : object {
    [CompilationMappingAttribute("9")]
public static bool AutoCloseXmlWriter { get; public set; }
    public static bool get_AutoCloseXmlWriter();
    public static void set_AutoCloseXmlWriter(bool value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void addXmlListener(Encoding encoding, string xmlOutputFile);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.TypeScript : object {
    [CompilationMappingAttribute("9")]
internal static string TypeScriptCompilerPrefix { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static TypeScriptParams TypeScriptDefaultParams { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@24-420(TypeScriptParams this, TypeScriptParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@24-421(IComparer comp, TypeScriptParams this, TypeScriptParams objTemp, Unit unitVar);
    internal static string get_TypeScriptCompilerPrefix();
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static double extractVersionNumber(DirectoryInfo di);
    public static TypeScriptParams get_TypeScriptDefaultParams();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string buildArguments(TypeScriptParams parameters, string file);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void TypeScriptCompiler(FSharpFunc`2<TypeScriptParams, TypeScriptParams> setParams, IEnumerable`1<string> files);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use Fake.Testing.Common instead")]
[CompilationMappingAttribute("7")]
public static class Fake.UnitTestCommon : object {
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.UnitTestHelper : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-238(TestStatus this, TestStatus obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@10-239(TestStatus this, object obj, TestStatus objTemp, Unit unitVar);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void reportToTeamCity(TestResults testResults);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void reportToAppVeyor(TestResults testResults);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void reportTestResults(TestResults testResults);
}
[AutoOpenAttribute]
[ObsoleteAttribute("FAKE0001 Use the Fake.Core.UserInput module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.UserInputHelper : object {
    internal static void erasePreviousChar();
    internal static FSharpList`1<char> loop@23-26(bool echo, FSharpList`1<char> cs);
    internal static string readString(bool echo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a color(ConsoleColor color, FSharpFunc`2<Unit, a> code);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.UserInput module instead")]
public static string getUserInput(string prompt);
    [ObsoleteAttribute("FAKE0001 Use the Fake.Core.UserInput module instead")]
public static string getUserPassword(string prompt);
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.Utils : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static Lazy`1<FSharpMap`2<string, WebProxy>> calcEnvProxies { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static FSharpFunc`2<string, WebProxy> getDefaultProxyForUrl { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, WebProxy> cache@9 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<a, b>, FSharpFunc`2<Tuple`2<key, b>, Unit>> memoizeByExt(FSharpFunc`2<a, key> getKey, FSharpFunc`2<a, b> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<a, b> memoizeBy(FSharpFunc`2<a, key> getKey, FSharpFunc`2<a, b> f);
    internal static FSharpFunc`2<a, b> memoize(FSharpFunc`2<a, b> f);
    internal static string getEnvValue@22(string name);
    internal static FSharpOption`1<NetworkCredential> getCredentials@32(Uri uri);
    internal static FSharpOption`1<WebProxy> getProxy@38(String[] bypassList, string scheme);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpMap`2<string, WebProxy> envProxies();
    public static Lazy`1<FSharpMap`2<string, WebProxy>> get_calcEnvProxies();
    public static FSharpFunc`2<string, WebProxy> get_getDefaultProxyForUrl();
    internal static WebProxy getDefault@80(Uri uri, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static WebProxy f@18(string url);
    internal static ConcurrentDictionary`2<string, WebProxy> get_cache@9();
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.Vb6Helper : object {
    [CompilationMappingAttribute("9")]
internal static Vb6BuildParams defaultVb6BuildParams { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@31-461(Vb6BuildJob this, Vb6BuildJob obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@31-460(Vb6BuildJob this, Vb6BuildJob obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@31-463(Vb6BuildJob this, Vb6BuildJob objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@31-462(IComparer comp, Vb6BuildJob this, Vb6BuildJob objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@31-95(IEqualityComparer comp, Vb6BuildJob this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@31-190(Vb6BuildJob this, Vb6BuildJob that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@31-191(Vb6BuildJob this, Vb6BuildJob obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-464(Vb6Version this, Vb6Version obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-465(Vb6Version this, Vb6Version objTemp, Unit unitVar);
    internal static Vb6BuildParams get_defaultVb6BuildParams();
    internal static String[] readProjectFileLines(string p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeProjectFileLines(string p, IEnumerable`1<string> l);
    internal static IEnumerable`1<char> toChars(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getValueBetween(char startChar, char endChar, string line);
    internal static String[] getReferenceLineParts(string line);
    internal static string createReferenceLine(String[] lineParts);
    internal static Guid getReferenceLineGuid(String[] lineParts);
    internal static bool referenceLineFilter(string l);
    internal static FSharpAsync`1<Vb6BuildJob> startBuildAsync@146(Vb6BuildParams config, Vb6BuildJob j);
    internal static FSharpAsync`1<Vb6BuildResult> getLogfileStatusAsync@159(Vb6BuildJob j);
    internal static FSharpAsync`1<Vb6BuildJob> waitForFinishAsync@171(Vb6BuildParams config, FSharpAsync`1<Vb6BuildJob> asyncJ);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Vb6Make(FSharpFunc`2<Vb6BuildParams, Vb6BuildParams> getConfig, IEnumerable`1<string> vb6Projects);
    internal static int getVersionValue@217(string l);
    internal static FSharpFunc`2<IEnumerable`1<string>, string> getExename@225(string project);
    internal static Vb6Version getVersion@233-9(Vb6Version defaultVb6Version, IEnumerable`1<string> projectlines);
    internal static Vb6ReferenceVersion getVersion@252-11(String[] lineParts);
    internal static Vb6Reference createReference@257(String[] lineParts);
    internal static IEnumerable`1<Vb6Reference> getReferencesAndObjectGuids@251(IEnumerable`1<string> projectLines);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static IEnumerable`1<Vb6Project> GetVb6ApplicationProjDetails(IEnumerable`1<string> projects);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RegisterDependenciesForDevelopment(FSharpFunc`2<Vb6BuildParams, Vb6BuildParams> getConfig, IEnumerable`1<string> vb6Projects, IEnumerable`1<string> possibleAssemblies);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void UnRegisterDependenciesForDevelopment(FSharpFunc`2<Vb6BuildParams, Vb6BuildParams> getConfig, IEnumerable`1<string> vb6Projects, IEnumerable`1<string> possibleAssemblies);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void BuildAndEmbedInteropManifests(FSharpFunc`2<Vb6BuildParams, Vb6BuildParams> getConfig, IEnumerable`1<string> vb6Projects, IEnumerable`1<string> possibleAssemblies);
    internal static Vb6ReferenceVersion transformInteropVersion@386(InteropAssemblyData a);
    internal static string versionToString@402(Vb6ReferenceVersion v);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void UpdateDependencyVersions(FSharpFunc`2<Vb6BuildParams, Vb6BuildParams> getConfig, IEnumerable`1<string> vb6Projects, IEnumerable`1<string> possibleAssemblies);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Core.SemVer instead")]
[CompilationMappingAttribute("7")]
public static class Fake.VersionHelper : object {
    [ObsoleteAttribute("Use Fake.Core.SemVer instead")]
public static VerInfo parseVersion(string version);
    [ObsoleteAttribute("Use Fake.Core.SemVer instead")]
public static Version GetAssemblyVersion(string assemblyFile);
    [ObsoleteAttribute("Use Fake.Core.SemVer instead")]
public static string GetAssemblyVersionString(string assemblyFile);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.VSSHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void getVSSProjectWithLabel(string toolPath, string srcSafeIni, string username, string password, string project, string localSpec, string label);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void getVSSProject(string toolPath, string srcSafeIni, string username, string password, string project, string localSpec);
}
[ObsoleteAttribute("use Fake.DotNet.Testing.VSTest instead")]
[CompilationMappingAttribute("7")]
public static class Fake.VSTest : object {
    [ObsoleteAttribute("use Fake.DotNet.Testing.VSTest instead")]
[CompilationMappingAttribute("9")]
public static String[] vsTestPaths { get; }
    [ObsoleteAttribute("use Fake.DotNet.Testing.VSTest instead")]
[CompilationMappingAttribute("9")]
public static string vsTestExe { get; }
    [ObsoleteAttribute("use Fake.DotNet.Testing.VSTest instead")]
[CompilationMappingAttribute("9")]
public static VSTestParams VSTestDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> matchValue@86-5 { get; }
    public static String[] get_vsTestPaths();
    public static string get_vsTestExe();
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@28-58(IEqualityComparer comp, VSTestParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@28-118(VSTestParams this, VSTestParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@28-117(VSTestParams this, VSTestParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@28-120(VSTestParams this, VSTestParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@28-119(VSTestParams this, VSTestParams obj, Unit unitVar);
    public static VSTestParams get_VSTestDefaults();
    internal static FSharpOption`1<string> get_matchValue@86-5();
    [ObsoleteAttribute("use Fake.DotNet.Testing.VSTest instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildVSTestArgs(VSTestParams parameters, string assembly);
    internal static FSharpFunc`2<int, Unit> failIfError@141-4(VSTestParams parameters, string assembly);
    [ObsoleteAttribute("use Fake.DotNet.Testing.VSTest instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void VSTest(FSharpFunc`2<VSTestParams, VSTestParams> setParams, IEnumerable`1<string> assemblies);
}
[CompilationMappingAttribute("7")]
public static class Fake.Windows.Choco : object {
    [CompilationMappingAttribute("9")]
public static ChocoInstallParams ChocoInstallDefaults { get; }
    [CompilationMappingAttribute("9")]
public static ChocoPackParams ChocoPackDefaults { get; }
    [CompilationMappingAttribute("9")]
public static ChocoPushParams ChocoPushDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<IEnumerable`1<string>> getPaths { get; }
    [CompilationMappingAttribute("9")]
internal static string programDataPath@327 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpOption`1<string> findExe { get; }
    [CompilationMappingAttribute("9")]
internal static string getTempFolder { get; }
    [CompilationMappingAttribute("9")]
internal static DirectoryInfo tempFolder@374 { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@7-7 { get; }
    [CompilationMappingAttribute("9")]
public static bool IsAvailable { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@27-132(ChocoInstallParams this, ChocoInstallParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@27-131(ChocoInstallParams this, ChocoInstallParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@27-130(ChocoInstallParams this, ChocoInstallParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@27-135(IComparer comp, ChocoInstallParams this, ChocoInstallParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@27-134(IComparer comp, ChocoInstallParams this, ChocoInstallParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@27-133(IComparer comp, ChocoInstallParams this, ChocoInstallParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@27-19(IEqualityComparer comp, ChocoInstallParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@27-55(ChocoInstallParams this, ChocoInstallParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@27-56(ChocoInstallParams this, ChocoInstallParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@200-136(ChocoPushParams this, ChocoPushParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@200-137(ChocoPushParams this, ChocoPushParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@200-20(IEqualityComparer comp, ChocoPushParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-142(NuspecData this, NuspecData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-141(NuspecData this, NuspecData obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-140(NuspecData this, NuspecData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-139(NuspecData this, NuspecData obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-138(NuspecData this, NuspecData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-147(NuspecData this, NuspecData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-146(NuspecData this, NuspecData objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-145(NuspecData this, NuspecData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-144(NuspecData this, NuspecData objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@224-143(NuspecData this, NuspecData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@224-21(NuspecData this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@224-58(NuspecData this, NuspecData that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@224-57(NuspecData this, NuspecData that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@224-60(NuspecData this, NuspecData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@224-59(NuspecData this, NuspecData obj, Unit unitVar);
    public static ChocoInstallParams get_ChocoInstallDefaults();
    public static ChocoPackParams get_ChocoPackDefaults();
    public static ChocoPushParams get_ChocoPushDefaults();
    internal static FSharpList`1<IEnumerable`1<string>> get_getPaths();
    internal static string get_programDataPath@327();
    public static FSharpOption`1<string> get_findExe();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void callChoco(string exePath, string args, TimeSpan timeout);
    internal static string get_getTempFolder();
    internal static DirectoryInfo get_tempFolder@374();
    internal static string get_path2@7-7();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StringBuilder appendLine(string line, StringBuilder builder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StringBuilder appendFormattedLine(PrintfFormat`4<FSharpFunc`2<a, string>, Unit, string, string> format, a value, StringBuilder builder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StringBuilder appendFormattedLineIfNotNull(PrintfFormat`4<FSharpFunc`2<a, string>, Unit, string, string> format, a value, StringBuilder builder);
    internal static string getFrameworkGroup@399-4(IEnumerable`1<Tuple`2<string, string>> frameworkTags);
    internal static string getGroup@406-1(FSharpList`1<a> items, FSharpFunc`2<FSharpList`1<a>, string> toTags);
    internal static string getReferencesTags@410-2(IEnumerable`1<string> references);
    internal static string getFrameworkAssemblyTags@424-4(IEnumerable`1<NugetFrameworkAssemblyReferences> references);
    internal static string getDependenciesTags@435-4(IEnumerable`1<Tuple`2<string, string>> dependencies);
    internal static string xmlEncode@463-1(string notEncodedText);
    internal static string toSingleLine@467-1(string text);
    internal static NuspecData getNuspecData(ChocoPackParams parameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string createNuSpecFromTemplate(ChocoPackParams parameters, FileInfo templateNuSpec, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string createNuSpec(ChocoPackParams parameters, string outputDir);
    internal static string installerTypeToString(ChocolateyInstallerType x);
    internal static string checksumTypeToString(ChocolateyChecksumType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createChocolateyInstallPs1(ChocoPackParams parameters, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createChocolateyInstallPs1FromTemplate(ChocoPackParams parameters, string templatePath, string outputDir);
    [CompilerGeneratedAttribute]
internal static void createChocolateyUninstallPs1$cont@658(ChocoPackParams parameters, string outputDir, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createChocolateyUninstallPs1(ChocoPackParams parameters, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createChocolateyUninstallPs1FromTemplate(ChocoPackParams parameters, string templatePath, string outputDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void callChocoPack(string nuspecFile, ChocoPackParams parameters);
    public static bool get_IsAvailable();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void install(FSharpFunc`2<ChocoInstallParams, ChocoInstallParams> setParams, string packages);
    public static void pack(FSharpFunc`2<ChocoPackParams, ChocoPackParams> setParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void packFromTemplate(FSharpFunc`2<ChocoPackParams, ChocoPackParams> setParams, string nuspecPath);
    internal static void tries@834(ChocoPushParams parameters, string args, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void push(FSharpFunc`2<ChocoPushParams, ChocoPushParams> setParams, string nupkgPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void exec(string args, TimeSpan timeout);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class Fake.Windows.Registry : object {
    public static RegistryKey getKey(RegistryBaseKey name);
    public static RegistryKey get64BitKey(RegistryBaseKey name);
    public static RegistryKey get32BitKey(RegistryBaseKey name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RegistryKey getRegistryKey64(RegistryBaseKey baseKey, string subKey, bool writePermission);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RegistryKey getRegistryKey(RegistryBaseKey baseKey, string subKey, bool writePermission);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getRegistryValue(RegistryBaseKey baseKey, string subKey, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getRegistryValue64(RegistryBaseKey baseKey, string subKey, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void setRegistryValue(RegistryBaseKey baseKey, string subKey, string name, T value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteRegistryValue(RegistryBaseKey baseKey, string subKey, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] getRegistryValueNames(RegistryBaseKey baseKey, string subKey);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool valueExistsForKey(RegistryBaseKey baseKey, string subKey, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createRegistrySubKey(RegistryBaseKey baseKey, string subKey);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteRegistrySubKey(RegistryBaseKey baseKey, string subKey);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] getRegistrySubKeyNames(RegistryBaseKey baseKey, string subKey);
}
[CompilationMappingAttribute("7")]
public static class Fake.Windows.ServiceControl : object {
    internal static string localhost { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_localhost();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string friendlyName(string host, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isService(string name, ServiceController service);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<ServiceController> getRemoteServices(string host, string name);
    public static IEnumerable`1<ServiceController> getServices(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<ServiceController> getRemoteService(string host, string name);
    public static FSharpOption`1<ServiceController> getService(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool checkRemoteServiceExists(string host, string name);
    public static bool checkServiceExists(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ServiceControllerStatus getRemoteServiceStatus(string host, string name);
    public static ServiceControllerStatus getServiceStatus(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void startRemoteService(string host, string name);
    public static void startService(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void stopRemoteService(string host, string name);
    public static void stopService(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureRemoteServiceHasStarted(string host, string name, TimeSpan timeout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureServiceHasStarted(string name, TimeSpan timeout);
    internal static ServiceControllerStatus getRemoteServiceStatus@131-1(string host, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureRemoteServiceHasStopped(string host, string name, TimeSpan timeout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ensureServiceHasStopped(string name, TimeSpan timeout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RunRemoteService(string command, string host, string serviceName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RunService(string command, string serviceName);
    public static void StopService(string serviceName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void StopRemoteService(string host, string serviceName);
    public static void StartService(string serviceName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void StartRemoteService(string host, string serviceName);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - module: Fake.Installer.Wix)")]
[CompilationMappingAttribute("7")]
public static class Fake.WiXHelper : object {
    [CompilationMappingAttribute("9")]
internal static int fileCount { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, int> dirs { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, int> compRefs { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, int> comps { get; internal set; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.FileDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXFile WiXFileDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.ServiceControlDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXServiceControl WiXServiceControlDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.ServiceConfigDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXServiceConfig WiXServiceConfigDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.ServiceDependencyDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXServiceDependency WiXServiceDependencyDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.ServiceInstallDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXServiceInstall WiXServiceInstallDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.RegistryValueDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXRegistryValue wixRegistryValueDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.RegistryKeyDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXRegistryKey wixRegistryKeyDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.ComponentRefDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXComponentRef WiXComponentRefDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.DirectoryRefDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXDirectoryRef WiXDirectoryRefDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.ComponentDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXComponent WiXComponentDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static YesOrNo Win64@759-1 { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.DirDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXDir WiXDirDefaults { get; }
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("9")]
public static WiXParams WiXDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-36 { get; }
    [ObsoleteAttribute("Please use the new 'Feature' type which features automatic string concatenation of inner features")]
[CompilationMappingAttribute("9")]
public static WiXFeature WiXFeatureDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.FeatureDefaults)")]
[CompilationMappingAttribute("9")]
public static Feature FeatureDefaults { get; }
    [ObsoleteAttribute("Please use new 'Script' type")]
[CompilationMappingAttribute("9")]
public static WiXScript WiXScriptDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.CustomActionDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXCustomAction WiXCustomActionDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.CustomActionExecutionDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXCustomActionExecution WixCustomActionExecutionDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.UIRef)")]
[CompilationMappingAttribute("9")]
public static WiXUIRef WiXUIRefDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.UpgradeDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXUpgrade WiXUpgradeDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.UpgradeVersionDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXUpgradeVersion WiXUpgradeVersionDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.MajorUpgradeDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXMajorUpgrade WiXMajorUpgradeDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.VariableDefaults)")]
[CompilationMappingAttribute("9")]
public static WiXVariable WiXVariableDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.ScriptDefaults)")]
[CompilationMappingAttribute("9")]
public static Script ScriptDefaults { get; }
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.HeatDefaulParams)")]
[CompilationMappingAttribute("9")]
public static HeatParams HeatDefaulParams { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-37 { get; }
    internal static int get_fileCount();
    internal static void set_fileCount(int value);
    internal static Dictionary`2<string, int> get_dirs();
    internal static void set_dirs(Dictionary`2<string, int> value);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getDirName)")]
public static string dirName(string dir);
    internal static Dictionary`2<string, int> get_compRefs();
    internal static void set_compRefs(Dictionary`2<string, int> value);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getCompRefName)")]
public static string compRefName(string compRef);
    internal static Dictionary`2<string, int> get_comps();
    internal static void set_comps(Dictionary`2<string, int> value);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getCompName)")]
public static string compName(string comp);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getWixFileTag)")]
public static string wixFile(FileInfo fileInfo);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getFilesAsWiXString)")]
public static string getFilesAsWiXString(IEnumerable`1<string> files);
    public static WiXFile get_WiXFileDefaults();
    public static WiXServiceControl get_WiXServiceControlDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateServiceControl)")]
public static WiXServiceControl generateServiceControl(FSharpFunc`2<WiXServiceControl, WiXServiceControl> setParams);
    public static WiXServiceConfig get_WiXServiceConfigDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateServiceConfig)")]
public static WiXServiceConfig generateServiceConfig(FSharpFunc`2<WiXServiceConfig, WiXServiceConfig> setParams);
    public static WiXServiceDependency get_WiXServiceDependencyDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateServiceDependency)")]
public static WiXServiceDependency generateServiceDependency(FSharpFunc`2<WiXServiceDependency, WiXServiceDependency> setParams);
    public static WiXServiceInstall get_WiXServiceInstallDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateServiceInstall)")]
public static WiXServiceInstall generateServiceInstall(FSharpFunc`2<WiXServiceInstall, WiXServiceInstall> setParams);
    public static WiXRegistryValue get_wixRegistryValueDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateRegistryValue)")]
public static WiXRegistryValue generateRegistryValue(FSharpFunc`2<WiXRegistryValue, WiXRegistryValue> setParams);
    public static WiXRegistryKey get_wixRegistryKeyDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateRegistryKey)")]
public static WiXRegistryKey generateRegistryKey(FSharpFunc`2<WiXRegistryKey, WiXRegistryKey> setParams);
    public static WiXComponentRef get_WiXComponentRefDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateComponentRef)")]
public static FSharpOption`1<WiXComponentRef> generateComponentRef(FSharpFunc`2<WiXComponentRef, WiXComponentRef> setParams);
    public static WiXDirectoryRef get_WiXDirectoryRefDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateDirectoryRef)")]
public static WiXDirectoryRef generateDirectoryRef(FSharpFunc`2<WiXDirectoryRef, WiXDirectoryRef> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getComponentRefs)")]
public static IEnumerable`1<FSharpOption`1<WiXComponentRef>> getComponentRefs(IEnumerable`1<WiXDirectoryComponent> elements);
    public static WiXComponent get_WiXComponentDefaults();
    internal static YesOrNo get_Win64@759-1();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateComponent)")]
public static WiXComponent generateComponent(FSharpFunc`2<WiXComponent, WiXComponent> setParams);
    public static WiXDir get_WiXDirDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateDirectory)")]
public static WiXDir generateDirectory(FSharpFunc`2<WiXDir, WiXDir> setParams);
    internal static string calcSHA1(string text);
    internal static string getDirectoryId(string directoryName);
    internal static string getFileId(string fileName);
    internal static YesOrNo IsWin64(Architecture architecture);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<WiXDirectoryComponent> createComponents(FSharpFunc`2<FileInfo, bool> fileFilter, DirectoryInfo directoryInfo, string directoryName, Architecture architecture);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.bulkComponentTreeCreation)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<WiXDirectoryComponent> bulkComponentTreeCreation(FSharpFunc`2<FileInfo, bool> fileFilter, FSharpFunc`2<DirectoryInfo, bool> directoryFilter, DirectoryInfo directoryInfo, Architecture architecture);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static WiXDirectoryComponent bulkComponentTreeSubCreation(FSharpFunc`2<FileInfo, bool> fileFilter, FSharpFunc`2<DirectoryInfo, bool> directoryFilter, DirectoryInfo directoryInfo, string directoryName, Architecture architecture);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.bulkComponentCreation)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<WiXDirectoryComponent> bulkComponentCreation(FSharpFunc`2<FileInfo, bool> fileFilter, DirectoryInfo directoryInfo, Architecture architecture);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.bulkComponentCreationAsSubDir)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static WiXDir bulkComponentCreationAsSubDir(FSharpFunc`2<FileInfo, bool> fileFilter, DirectoryInfo directoryInfo, Architecture architecture);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.attachServiceControlToComponent)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static WiXDirectoryComponent attachServiceControlToComponent(WiXDirectoryComponent comp, FSharpFunc`2<WiXComponent, bool> fileFilter, IEnumerable`1<WiXServiceControl> serviceControls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<WiXDirectoryComponent> attachServiceControlToComponents(IEnumerable`1<WiXDirectoryComponent> components, FSharpFunc`2<WiXComponent, bool> fileFilter, IEnumerable`1<WiXServiceControl> serviceControls);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.attachServiceInstallToComponent)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static WiXDirectoryComponent attachServiceInstallToComponent(WiXDirectoryComponent comp, FSharpFunc`2<WiXComponent, bool> fileFilter, IEnumerable`1<WiXServiceInstall> serviceInstalls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<WiXDirectoryComponent> attachServiceInstallToComponents(IEnumerable`1<WiXDirectoryComponent> components, FSharpFunc`2<WiXComponent, bool> fileFilter, IEnumerable`1<WiXServiceInstall> serviceInstalls);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getWixDirTag)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string wixDir(FSharpFunc`2<FileInfo, bool> fileFilter, bool asSubDir, DirectoryInfo directoryInfo);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getFileIdFromWiXString)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getFileIdFromWiXString(string wiXString, string fileRegex);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getComponentIdsFromWiXString)")]
public static string getComponentIdsFromWiXString(string wiXString);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.getComponentRefsTags)")]
public static string wixComponentRefs(DirectoryInfo directoryInfo);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.setComponentsNeverOverwrite)")]
public static string setComponentsNeverOverwrite(string components);
    public static WiXParams get_WiXDefaults();
    internal static string get_path2@32-36();
    public static WiXFeature get_WiXFeatureDefaults();
    internal static FSharpChoice`2<Unit, a> |Empty|NotEmpty|@1141-1(a seq);
    internal static string ConcatAll@1143-6(Feature feature, string node);
    public static Feature get_FeatureDefaults();
    public static WiXScript get_WiXScriptDefaults();
    public static WiXCustomAction get_WiXCustomActionDefaults();
    public static WiXCustomActionExecution get_WixCustomActionExecutionDefaults();
    public static WiXUIRef get_WiXUIRefDefaults();
    public static WiXUpgrade get_WiXUpgradeDefaults();
    public static WiXUpgradeVersion get_WiXUpgradeVersionDefaults();
    public static WiXMajorUpgrade get_WiXMajorUpgradeDefaults();
    public static WiXVariable get_WiXVariableDefaults();
    public static Script get_ScriptDefaults();
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateWiXScript)")]
public static void generateWiXScript(string fileName);
    [ObsoleteAttribute("Please use new fillInWiXTemplate function")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FillInWixScript(string wiXPath, FSharpFunc`2<WiXScript, WiXScript> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.FillInWiXTemplate)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void FillInWiXTemplate(string wiXPath, FSharpFunc`2<Script, Script> setParams);
    [ObsoleteAttribute("Please use the new generateFeatureElement")]
public static WiXFeature generateFeature(FSharpFunc`2<WiXFeature, WiXFeature> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateFeatureElement)")]
public static Feature generateFeatureElement(FSharpFunc`2<Feature, Feature> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateCustomAction)")]
public static WiXCustomAction generateCustomAction(FSharpFunc`2<WiXCustomAction, WiXCustomAction> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateCustomActionExecution)")]
public static WiXCustomActionExecution generateCustomActionExecution(FSharpFunc`2<WiXCustomActionExecution, WiXCustomActionExecution> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateUIRef)")]
public static WiXUIRef generateUIRef(FSharpFunc`2<WiXUIRef, WiXUIRef> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateUpgrade)")]
public static WiXUpgrade generateUpgrade(FSharpFunc`2<WiXUpgrade, WiXUpgrade> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateUpgradeVersion)")]
public static WiXUpgradeVersion generateUpgradeVersion(FSharpFunc`2<WiXUpgradeVersion, WiXUpgradeVersion> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.generateMajorUpgradeVersion)")]
public static WiXMajorUpgrade generateMajorUpgradeVersion(FSharpFunc`2<WiXMajorUpgrade, WiXMajorUpgrade> setParams);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.Candle)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string Candle(WiXParams parameters, string wixScript);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.Light)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Light(WiXParams parameters, string outputFile, string wixObj);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.WiX)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void WiX(FSharpFunc`2<WiXParams, WiXParams> setParams, string outputFile, string wixScript);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2022-307(HeatParams this, HeatParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2022-306(HeatParams this, HeatParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2022-305(HeatParams this, HeatParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2022-310(IComparer comp, HeatParams this, HeatParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2022-309(IComparer comp, HeatParams this, HeatParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@2022-308(IComparer comp, HeatParams this, HeatParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@2022-62(IEqualityComparer comp, HeatParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@2022-130(HeatParams this, HeatParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@2022-131(HeatParams this, HeatParams obj, Unit unitVar);
    public static HeatParams get_HeatDefaulParams();
    internal static string get_path2@32-37();
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpList`1<a>> conditionalArgument@2079-2(bool condition, a arg);
    [ObsoleteAttribute("Use Fake.Installer.Wix instead (FAKE0001 - package: Fake.Installer.Wix - member: Fake.Installer.Wix.harvestDirectory)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void HarvestDirectory(FSharpFunc`2<HeatParams, HeatParams> setParams, string directory, string outputFile);
}
[ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
[CompilationMappingAttribute("7")]
public static class Fake.XamarinHelper : object {
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
[CompilationMappingAttribute("9")]
public static XamarinComponentRestoreParams XamarinComponentRestoreDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-53 { get; }
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
[CompilationMappingAttribute("9")]
public static iOSBuildParams iOSBuildDefaults { get; }
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
[CompilationMappingAttribute("9")]
public static AndroidPackageAbiParam AllAndroidAbiTargets { get; }
    [CompilationMappingAttribute("9")]
public static AndroidPackageParams AndroidPackageDefaults { get; }
    [CompilationMappingAttribute("9")]
public static AndroidSignAndAlignParams AndroidSignAndAlignDefaults { get; }
    [CompilationMappingAttribute("9")]
public static iOSArchiveParams iOSArchiveDefaults { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void executeCommand(string command, string args);
    public static XamarinComponentRestoreParams get_XamarinComponentRestoreDefaults();
    internal static string get_path2@32-53();
    internal static FSharpFunc`2<XamarinComponentRestoreParams, Unit> restoreComponents@41-2(string project);
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void RestoreComponents(FSharpFunc`2<XamarinComponentRestoreParams, XamarinComponentRestoreParams> setParams, string projectFile);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-520(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-519(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-518(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-517(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-524(IComparer comp, iOSBuildParams this, iOSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-523(IComparer comp, iOSBuildParams this, iOSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-522(IComparer comp, iOSBuildParams this, iOSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@51-521(IComparer comp, iOSBuildParams this, object obj, iOSBuildParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@51-112(IEqualityComparer comp, iOSBuildParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@51-214(iOSBuildParams this, iOSBuildParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@51-213(iOSBuildParams this, iOSBuildParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@51-215(iOSBuildParams this, iOSBuildParams obj, Unit unitVar);
    public static iOSBuildParams get_iOSBuildDefaults();
    public static AndroidPackageAbiParam get_AllAndroidAbiTargets();
    internal static bool exists@140-2(iOSBuildParams param, string parameter);
    internal static iOSBuildParams validateParams@138-4(iOSBuildParams param);
    internal static MSBuildParams applyiOSBuildParamsToMSBuildParams@148-1(iOSBuildParams iOSBuildParams, MSBuildParams buildParams);
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
public static void iOSBuild(FSharpFunc`2<iOSBuildParams, iOSBuildParams> setParams);
    public static AndroidPackageParams get_AndroidPackageDefaults();
    internal static AndroidPackageParams validateParams@234-5(AndroidPackageParams param);
    internal static MSBuildParams applyAndroidBuildParamsToMSBuildParams@242-1(AndroidPackageParams androidBuildParams, MSBuildParams buildParams);
    internal static MSBuildParams applyBuildParams@269-1(AndroidPackageParams param, FSharpOption`1<string> abi, FSharpOption`1<string> manifestFile, MSBuildParams msbuildParam);
    internal static void buildPackages@268-2(AndroidPackageParams param, FSharpOption`1<string> abi, FSharpOption`1<string> manifestFile);
    internal static void rewriteManifestFile@287-1(string manifestFile, string outfile, FSharpFunc`2<int, FSharpFunc`2<AndroidAbiTarget, int>> transformVersion, AndroidAbiTarget target);
    internal static FileInfo mostRecentFileInDirMatching@297-2(string path);
    internal static FSharpList`1<FileInfo> createPackage@303-2(AndroidPackageParams param);
    internal static void buildSpecificApk@308-1(AndroidPackageParams param, string manifestFile, string name, FSharpFunc`2<int, FSharpFunc`2<AndroidAbiTarget, int>> transformVersion, AndroidAbiTarget target);
    internal static string translateAbi@321-1(AndroidAbiTarget _arg1);
    internal static void createTargetPackage@329-1(AndroidPackageParams param, string manifestFile, AndroidAbiTarget target, FSharpFunc`2<int, FSharpFunc`2<AndroidAbiTarget, int>> transformVersion);
    internal static FSharpList`1<FileInfo> createPackageAbiSpecificApk@339-2(AndroidPackageParams param, FSharpList`1<AndroidAbiTarget> targets, FSharpFunc`2<int, FSharpFunc`2<AndroidAbiTarget, int>> transformVersion);
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
public static FSharpList`1<FileInfo> AndroidBuildPackages(FSharpFunc`2<AndroidPackageParams, AndroidPackageParams> setParams);
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
public static FileInfo AndroidPackage(FSharpFunc`2<AndroidPackageParams, AndroidPackageParams> setParams);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@378-525(AndroidSignAndAlignParams this, AndroidSignAndAlignParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@378-526(AndroidSignAndAlignParams this, AndroidSignAndAlignParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@378-113(AndroidSignAndAlignParams this, Unit unitVar);
    public static AndroidSignAndAlignParams get_AndroidSignAndAlignDefaults();
    internal static AndroidSignAndAlignParams validateParams@412-7(AndroidSignAndAlignParams param);
    internal static string quotesSurround@419-1(string s);
    internal static FSharpFunc`2<AndroidSignAndAlignParams, FileInfo> signAndAlign@421-2(FileInfo file);
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileInfo AndroidSignAndAlign(FSharpFunc`2<AndroidSignAndAlignParams, AndroidSignAndAlignParams> setParams, FileInfo apkFile);
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<FileInfo> AndroidSignAndAlignPackages(FSharpFunc`2<AndroidSignAndAlignParams, AndroidSignAndAlignParams> setParams, IEnumerable`1<FileInfo> apkFiles);
    public static iOSArchiveParams get_iOSArchiveDefaults();
    [ObsoleteAttribute("Use Fake.DotNet.Xamarin")]
public static void iOSArchive(FSharpFunc`2<iOSArchiveParams, iOSArchiveParams> setParams);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.XCopyHelper : object {
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void XCopy(string source, string destination);
}
[ObsoleteAttribute("Use Fake.Core.Xdt instead (open Fake.Core and use 'Xdt.<name>' instead of directly calling Xdt<name> - ie add a dot)")]
[CompilationMappingAttribute("7")]
public static class Fake.XDTHelper : object {
    [ObsoleteAttribute("Use Fake.Core.Xdt instead (open Fake.Core and use 'Xdt.<name>' instead of directly calling Xdt<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void TransformFile(string inXmlFile, string transformFile, string outXmlFile);
    [ObsoleteAttribute("Use Fake.Core.Xdt instead (open Fake.Core and use 'Xdt.<name>' instead of directly calling Xdt<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void TransformFileWithConfigName(string configName, string xmlFile);
    [ObsoleteAttribute("Use Fake.Core.Xdt instead (open Fake.Core and use 'Xdt.<name>' instead of directly calling Xdt<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void TransformFilesWithConfigName(string configName, FileIncludes files);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationMappingAttribute("7")]
public static class Fake.XMLHelper : object {
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> XMLRead(bool failOnError, string xmlFileName, string nameSpace, string prefix, string xPath);
    internal static a headOrDefault@42-1(a def, IEnumerable`1<a> seq);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, int> XMLRead_Int(bool failOnError, string xmlFileName, string nameSpace, string prefix, string xPath);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
public static XmlTextWriter XmlWriter(string fileName);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlTextWriter XmlComment(string comment, XmlTextWriter writer);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlTextWriter XmlStartElement(string name, XmlTextWriter writer);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
public static XmlTextWriter XmlEndElement(XmlTextWriter writer);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlTextWriter XmlAttribute(string name, a value, XmlTextWriter writer);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlTextWriter XmlCDataElement(string elementName, string data, XmlTextWriter writer);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getAttribute(string name, a node);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
public static IEnumerable`1<XmlNode> getChilds(a node);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlNode getSubNode(string name, XmlNode node);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b parse(string name, FSharpFunc`2<a, b> f, a node);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<XmlNode, a> parseSubNode(string name, FSharpFunc`2<XmlNode, a> f);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
public static XmlDocument XMLDoc(string text);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
public static XmlElement DocElement(XmlDocument doc);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument XPathReplace(string xpath, string value, XmlDocument doc);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument XPathReplaceInnerText(string xpath, string innerTextValue, XmlDocument doc);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string XPathValue(string xpath, a namespaces, XmlDocument doc);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void XmlPoke(string fileName, string xpath, string value);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void XmlPokeInnerText(string fileName, string xpath, string innerTextValue);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument XPathReplaceNS(string xpath, string value, a namespaces, XmlDocument doc);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument XPathReplaceInnerTextNS(string xpath, string innerTextValue, a namespaces, XmlDocument doc);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void XmlPokeNS(string fileName, IEnumerable`1<Tuple`2<string, string>> namespaces, string xpath, string value);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void XmlPokeInnerTextNS(string fileName, IEnumerable`1<Tuple`2<string, string>> namespaces, string xpath, string innerTextValue);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
public static XslCompiledTransform XslTransformer(string text);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDocument XslTransform(XslCompiledTransform xsl, XmlDocument doc);
    [ObsoleteAttribute("Use Fake.Core.Xml instead (open Fake.Core and use 'Xml.<name>' instead of directly calling Xml<name> - ie add a dot)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void XmlTransform(string stylesheetUri, string fileName);
}
[AutoOpenAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[CompilationMappingAttribute("7")]
public static class Fake.XpkgHelper : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-325(xpkgParams this, xpkgParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-324(xpkgParams this, xpkgParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-323(xpkgParams this, xpkgParams obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-328(IComparer comp, xpkgParams this, xpkgParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-327(IComparer comp, xpkgParams this, xpkgParams objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@12-326(IComparer comp, xpkgParams this, xpkgParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@12-67(IEqualityComparer comp, xpkgParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-135(xpkgParams this, xpkgParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-134(xpkgParams this, object obj, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@12-136(xpkgParams this, xpkgParams obj, Unit unitVar);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static xpkgParams XpkgDefaults();
    internal static string getPackageFileName(xpkgParams parameters);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void xpkgPack(FSharpFunc`2<xpkgParams, xpkgParams> setParams);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static void xpkgValidate(FSharpFunc`2<xpkgParams, xpkgParams> setParams);
}
[ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationMappingAttribute("7")]
public static class Fake.XUnit2Helper : object {
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
public static FSharpOption`1<Tuple`2<string, string>> empty2Trait { get; }
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationMappingAttribute("9")]
public static XUnit2Params XUnit2Defaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-25 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-276(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-275(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-274(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-273(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-280(XUnit2Params this, XUnit2Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-279(IComparer comp, XUnit2Params this, XUnit2Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-278(IComparer comp, XUnit2Params this, XUnit2Params objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-277(IComparer comp, XUnit2Params this, XUnit2Params objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@59-55(IEqualityComparer comp, XUnit2Params this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@59-111(XUnit2Params this, XUnit2Params that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@59-110(XUnit2Params this, XUnit2Params that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@59-112(XUnit2Params this, XUnit2Params obj, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static FSharpOption`1<Tuple`2<string, string>> get_empty2Trait();
    public static XUnit2Params get_XUnit2Defaults();
    internal static string get_path2@32-25();
    internal static FSharpFunc`2<Tuple`2<string, string>, string> traits@142-5(string includeExclude);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildXUnit2Args(XUnit2Params parameters, string assembly);
    internal static bool runTests@196-4(XUnit2Params parameters, string assembly);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void xUnit2(FSharpFunc`2<XUnit2Params, XUnit2Params> setParams, IEnumerable`1<string> assemblies);
}
[AutoOpenAttribute]
[ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationMappingAttribute("7")]
public static class Fake.XUnitHelper : object {
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
public static FSharpOption`1<Tuple`2<string, string>> emptyTrait { get; }
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationMappingAttribute("9")]
public static XUnitParams XUnitDefaults { get; }
    [CompilationMappingAttribute("9")]
internal static string path2@32-23 { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-261(XUnitParams this, XUnitParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-260(XUnitParams this, XUnitParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-259(XUnitParams this, XUnitParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-264(IComparer comp, XUnitParams this, XUnitParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-263(IComparer comp, XUnitParams this, XUnitParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@23-262(IComparer comp, XUnitParams this, XUnitParams objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@23-54(IEqualityComparer comp, XUnitParams this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@23-105(XUnitParams this, XUnitParams that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@23-106(XUnitParams this, XUnitParams obj, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static FSharpOption`1<Tuple`2<string, string>> get_emptyTrait();
    public static XUnitParams get_XUnitDefaults();
    internal static string get_path2@32-23();
    internal static FSharpFunc`2<Tuple`2<string, string>, string> traits@85(string includeExclude);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string buildXUnitArgs(XUnitParams parameters, string assembly);
    internal static bool runTests@129(XUnitParams parameters, string assembly);
    [ObsoleteAttribute("use Fake.DotNet.Testing.XUnit2 instead (yes please migrate to xunit2)")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void xUnit(FSharpFunc`2<XUnitParams, XUnitParams> setParams, IEnumerable`1<string> assemblies);
}
[ObsoleteAttribute("FAKE0001 Use the Fake.JavaScript.Yarn module instead")]
[CompilationMappingAttribute("7")]
public static class Fake.YarnHelper : object {
    [CompilationMappingAttribute("9")]
internal static string yarnFileName { get; }
    [ObsoleteAttribute("FAKE0001 Use the Fake.JavaScript.Yarn module instead")]
[CompilationMappingAttribute("9")]
public static YarnParams defaultYarnParams { get; }
    internal static string get_yarnFileName();
    public static YarnParams get_defaultYarnParams();
    internal static string parseInstallArgs(InstallArgs _arg1);
    internal static string parse(YarnCommand _arg1);
    [ObsoleteAttribute("FAKE0001 Use the Fake.JavaScript.Yarn module instead")]
public static void run(YarnParams yarnParams);
    [ObsoleteAttribute("FAKE0001 Use the Fake.JavaScript.Yarn module instead")]
public static void Yarn(FSharpFunc`2<YarnParams, YarnParams> setParams);
}
[AutoOpenAttribute]
[ObsoleteAttribute("Use Fake.IO.Zip instead")]
[CompilationMappingAttribute("7")]
public static class Fake.ZipHelper : object {
    [ObsoleteAttribute("Use Fake.IO.Zip instead")]
public static int DefaultZipLevel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_DefaultZipLevel();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addZipEntry(ZipOutputStream stream, Byte[] buffer, string item, string itemSpec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createZip(string fileName, string comment, int level, IEnumerable`1<Tuple`2<string, string>> items);
    [ObsoleteAttribute("Use Fake.IO.Zip instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateZip(string workingDir, string fileName, string comment, int level, bool flatten, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO.Zip instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Zip(string workingDir, string fileName, IEnumerable`1<string> files);
    [ObsoleteAttribute("Use Fake.IO.Zip instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ZipFile(string fileName, string targetFileName);
    [ObsoleteAttribute("Use Fake.IO.Zip instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Unzip(string target, string fileName);
    [ObsoleteAttribute("Use Fake.IO.Zip instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string UnzipSingleFileInMemory(string fileToUnzip, string zipFileName);
    [ObsoleteAttribute("Use Fake.IO.Zip instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string UnzipFirstMatchingFileInMemory(FSharpFunc`2<ZipEntry, bool> predicate, string zipFileName);
    [ObsoleteAttribute("Use Fake.IO.Zip instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateZipOfIncludes(string fileName, string comment, int level, IEnumerable`1<Tuple`2<string, FileIncludes>> files);
    [ObsoleteAttribute("Use Fake.IO.Zip instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void ZipOfIncludes(string fileName, IEnumerable`1<Tuple`2<string, FileIncludes>> files);
}
[CompilationMappingAttribute("7")]
internal static class System.AssemblyVersionInformation : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyTitle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string InternalsVisibleTo;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Guid;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyProduct;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyInformationalVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyFileVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string AssemblyMetadata_BuildDate;
}
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
[ExtensionAttribute]
[CompilationMappingAttribute("3")]
public class Test.FAKECore.FSharpFuncUtil : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpFunc`2<Unit, a> ToFSharpFunc(Func`1<a> func);
    [ExtensionAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpFunc`2<a, b> ToFSharpFunc(Func`2<a, b> func);
    [ExtensionAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpFunc`2<a, FSharpFunc`2<b, c>> ToFSharpFunc(Func`3<a, b, c> func);
    [ExtensionAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, d>>> ToFSharpFunc(Func`4<a, b, c, d> func);
    [ExtensionAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpFunc`2<Unit, Unit> ToFSharpFunc(Action func);
    [ExtensionAttribute]
[ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpFunc`2<a, Unit> ToFSharpFunc(Action`1<a> func);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpFunc`2<a, b> Create(Func`2<a, b> func);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpFunc`2<a, FSharpFunc`2<b, c>> Create(Func`3<a, b, c> func);
    [ObsoleteAttribute("This API is obsolete. There is no alternative in FAKE 5 yet. You can help by porting this module.")]
public static FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, d>>> Create(Func`4<a, b, c, d> func);
}
[CompilationMappingAttribute("7")]
internal static class Yaaf.FSharp.Scripting.ArgParser : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> |StartsWith|_|(string start, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> |FsiBoolArg|_|(string argName, string s);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Yaaf.FSharp.Scripting.CompilerServiceExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string Type.get_NamespaceName(Type );
    internal static IEnumerable`1<Tuple`2<string, FSharpOption`1<FSharpAssembly>>> FSharpAssembly.LoadFiles.Static(IEnumerable`1<string> dllFiles, FSharpOption`1<IEnumerable`1<string>> libDirs, FSharpOption`1<IEnumerable`1<string>> otherFlags, FSharpOption`1<bool> manualResolve);
    internal static FSharpOption`1<FSharpAssembly> FSharpAssembly.FromAssembly.Static(Assembly assembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpEntity> FSharpAssembly.FindType(FSharpAssembly x, Type t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string Type.get_FSharpName(Type );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string Type.get_FSharpFullName(Type );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string Type.get_FSharpParamList(Type );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string Type.get_FSharpFullNameWithTypeArgs(Type );
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class Yaaf.FSharp.Scripting.DebugMode : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugMode _unique_Full;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugMode _unique_PdbOnly;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugMode _unique_Portable;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugMode _unique_NoDebug;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static DebugMode Full { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFull { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static DebugMode PdbOnly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPdbOnly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static DebugMode Portable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPortable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static DebugMode NoDebug { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoDebug { get; }
    private static DebugMode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DebugMode(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static DebugMode get_Full();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFull();
    [CompilationMappingAttribute("8", "1")]
internal static DebugMode get_PdbOnly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPdbOnly();
    [CompilationMappingAttribute("8", "2")]
internal static DebugMode get_Portable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPortable();
    [CompilationMappingAttribute("8", "3")]
internal static DebugMode get_NoDebug();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoDebug();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DebugMode obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugMode obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Yaaf.FSharp.Scripting.Env : object {
    [CompilationMappingAttribute("9")]
internal static bool isMono { get; }
    internal static bool isNull(a o);
    internal static bool get_isMono();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string op_PlusPlus(string a, string b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool op_EqualsQmark(string s1, string s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool op_LessGreaterQmark(string s1, string s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type CustomAttributeData.get_AttributeType(CustomAttributeData );
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Yaaf.FSharp.Scripting.Extensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IFsiSession.EvalInteraction(IFsiSession x, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<object, Type>> IFsiSession.TryEvalExpression(IFsiSession x, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IFsiSession.EvalScript(IFsiSession x, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IFsiSession.EvalScriptAsInteractionWithOutput(IFsiSession x, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IFsiSession.EvalScriptAsInteraction(IFsiSession x, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<InteractionResult, a> IFsiSession.EvalExpressionWithOutput(IFsiSession x, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a IFsiSession.EvalExpression(IFsiSession x, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IFsiSession.Let(IFsiSession x, string varName, a obj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IFsiSession.Open(IFsiSession x, string ns);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IFsiSession.Reference(IFsiSession x, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IFsiSession.Include(IFsiSession x, string dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IFsiSession.Load(IFsiSession x, string file);
    internal static void cd@739(IFsiSession x, string dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IDisposable IFsiSession.Cd(IFsiSession x, string dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c IFsiSession.WithCd(IFsiSession x, string dir, FSharpFunc`2<Unit, c> f);
    internal static void cd@759-1(IFsiSession x, string dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IDisposable IFsiSession.ChangeCurrentDirectory(IFsiSession x, string dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b IFsiSession.WithCurrentDirectory(IFsiSession x, string dir, FSharpFunc`2<Unit, b> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static HandledResult`1<a> IFsiSession.Handle(IFsiSession __, FSharpFunc`2<string, a> f, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AssemblyBuilder IFsiSession.get_DynamicAssemblyBuilder(IFsiSession );
}
[SerializableAttribute]
[CompilationMappingAttribute("3")]
internal class Yaaf.FSharp.Scripting.FsiEvaluationException : Exception {
    internal InteractionResult result@;
    internal string input@;
    internal FSharpOption`1<FSharpList`1<string>> arguments@;
    [CompilationMappingAttribute("4", "0")]
internal InteractionResult result { get; }
    [CompilationMappingAttribute("4", "1")]
internal string input { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpOption`1<FSharpList`1<string>> arguments { get; }
    internal InteractionResult Result { get; }
    internal string Input { get; }
    public FsiEvaluationException(string msg, string input, FSharpOption`1<FSharpList`1<string>> args, InteractionResult result, Exception inner);
    public FsiEvaluationException(SerializationInfo info, StreamingContext context);
    internal InteractionResult get_result();
    internal string get_input();
    internal FSharpOption`1<FSharpList`1<string>> get_arguments();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext _arg1);
    internal InteractionResult get_Result();
    internal string get_Input();
    public virtual string ToString();
}
[SerializableAttribute]
[CompilationMappingAttribute("3")]
internal class Yaaf.FSharp.Scripting.FsiExpressionTypeException : FsiEvaluationException {
    internal FSharpOption`1<object> value@;
    internal Type expected@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpOption`1<object> value { get; }
    [CompilationMappingAttribute("4", "1")]
internal Type expected { get; }
    internal FSharpOption`1<object> Value { get; }
    internal Type ExpectedType { get; }
    public FsiExpressionTypeException(string msg, string input, InteractionResult result, Type expect, FSharpOption`1<object> value);
    public FsiExpressionTypeException(SerializationInfo info, StreamingContext context);
    internal FSharpOption`1<object> get_value();
    internal Type get_expected();
    internal FSharpOption`1<object> get_Value();
    internal Type get_ExpectedType();
}
[CompilationMappingAttribute("34")]
internal class Yaaf.FSharp.Scripting.FsiOptions : object {
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<bool> Checked@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<int> Codepage@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<bool> CrossOptimize@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<DebugMode> Debug@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Defines@;
    [DebuggerBrowsableAttribute("0")]
internal bool Exec@;
    [DebuggerBrowsableAttribute("0")]
internal bool FullPaths@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<bool> Gui@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> LibDirs@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Loads@;
    [DebuggerBrowsableAttribute("0")]
internal bool NoFramework@;
    [DebuggerBrowsableAttribute("0")]
internal bool NoLogo@;
    [DebuggerBrowsableAttribute("0")]
internal bool NonInteractive@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<int> NoWarns@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2<bool, FSharpList`1<OptimizationType>>> Optimize@;
    [DebuggerBrowsableAttribute("0")]
internal bool Quiet@;
    [DebuggerBrowsableAttribute("0")]
internal bool QuotationsDebug@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<bool> ReadLine@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> References@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<bool> TailCalls@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Uses@;
    [DebuggerBrowsableAttribute("0")]
internal bool Utf8Output@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<int> WarnLevel@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<bool> WarnAsError@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2<bool, FSharpList`1<int>>> WarnAsErrorList@;
    [DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> ScriptArgs@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpOption`1<bool> Checked { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpOption`1<int> Codepage { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpOption`1<bool> CrossOptimize { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpOption`1<DebugMode> Debug { get; }
    [CompilationMappingAttribute("4", "4")]
internal FSharpList`1<string> Defines { get; }
    [CompilationMappingAttribute("4", "5")]
internal bool Exec { get; }
    [CompilationMappingAttribute("4", "6")]
internal bool FullPaths { get; }
    [CompilationMappingAttribute("4", "7")]
internal FSharpOption`1<bool> Gui { get; }
    [CompilationMappingAttribute("4", "8")]
internal FSharpList`1<string> LibDirs { get; }
    [CompilationMappingAttribute("4", "9")]
internal FSharpList`1<string> Loads { get; }
    [CompilationMappingAttribute("4", "10")]
internal bool NoFramework { get; }
    [CompilationMappingAttribute("4", "11")]
internal bool NoLogo { get; }
    [CompilationMappingAttribute("4", "12")]
internal bool NonInteractive { get; }
    [CompilationMappingAttribute("4", "13")]
internal FSharpList`1<int> NoWarns { get; }
    [CompilationMappingAttribute("4", "14")]
internal FSharpList`1<Tuple`2<bool, FSharpList`1<OptimizationType>>> Optimize { get; }
    [CompilationMappingAttribute("4", "15")]
internal bool Quiet { get; }
    [CompilationMappingAttribute("4", "16")]
internal bool QuotationsDebug { get; }
    [CompilationMappingAttribute("4", "17")]
internal FSharpOption`1<bool> ReadLine { get; }
    [CompilationMappingAttribute("4", "18")]
internal FSharpList`1<string> References { get; }
    [CompilationMappingAttribute("4", "19")]
internal FSharpOption`1<bool> TailCalls { get; }
    [CompilationMappingAttribute("4", "20")]
internal FSharpList`1<string> Uses { get; }
    [CompilationMappingAttribute("4", "21")]
internal bool Utf8Output { get; }
    [CompilationMappingAttribute("4", "22")]
internal FSharpOption`1<int> WarnLevel { get; }
    [CompilationMappingAttribute("4", "23")]
internal FSharpOption`1<bool> WarnAsError { get; }
    [CompilationMappingAttribute("4", "24")]
internal FSharpList`1<Tuple`2<bool, FSharpList`1<int>>> WarnAsErrorList { get; }
    [CompilationMappingAttribute("4", "25")]
internal FSharpList`1<string> ScriptArgs { get; }
    internal static FsiOptions Empty { get; }
    internal static FsiOptions Default { get; }
    internal String[] AsArgs { get; }
    internal FsiOptions(FSharpOption`1<bool> checked, FSharpOption`1<int> codepage, FSharpOption`1<bool> crossOptimize, FSharpOption`1<DebugMode> debug, FSharpList`1<string> defines, bool exec, bool fullPaths, FSharpOption`1<bool> gui, FSharpList`1<string> libDirs, FSharpList`1<string> loads, bool noFramework, bool noLogo, bool nonInteractive, FSharpList`1<int> noWarns, FSharpList`1<Tuple`2<bool, FSharpList`1<OptimizationType>>> optimize, bool quiet, bool quotationsDebug, FSharpOption`1<bool> readLine, FSharpList`1<string> references, FSharpOption`1<bool> tailCalls, FSharpList`1<string> uses, bool utf8Output, FSharpOption`1<int> warnLevel, FSharpOption`1<bool> warnAsError, FSharpList`1<Tuple`2<bool, FSharpList`1<int>>> warnAsErrorList, FSharpList`1<string> scriptArgs);
    internal FSharpOption`1<bool> get_Checked();
    internal FSharpOption`1<int> get_Codepage();
    internal FSharpOption`1<bool> get_CrossOptimize();
    internal FSharpOption`1<DebugMode> get_Debug();
    internal FSharpList`1<string> get_Defines();
    internal bool get_Exec();
    internal bool get_FullPaths();
    internal FSharpOption`1<bool> get_Gui();
    internal FSharpList`1<string> get_LibDirs();
    internal FSharpList`1<string> get_Loads();
    internal bool get_NoFramework();
    internal bool get_NoLogo();
    internal bool get_NonInteractive();
    internal FSharpList`1<int> get_NoWarns();
    internal FSharpList`1<Tuple`2<bool, FSharpList`1<OptimizationType>>> get_Optimize();
    internal bool get_Quiet();
    internal bool get_QuotationsDebug();
    internal FSharpOption`1<bool> get_ReadLine();
    internal FSharpList`1<string> get_References();
    internal FSharpOption`1<bool> get_TailCalls();
    internal FSharpList`1<string> get_Uses();
    internal bool get_Utf8Output();
    internal FSharpOption`1<int> get_WarnLevel();
    internal FSharpOption`1<bool> get_WarnAsError();
    internal FSharpList`1<Tuple`2<bool, FSharpList`1<int>>> get_WarnAsErrorList();
    internal FSharpList`1<string> get_ScriptArgs();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FsiOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal static FsiOptions get_Empty();
    internal static FsiOptions get_Default();
    internal static FsiOptions ofArgs(IEnumerable`1<string> args);
    internal String[] get_AsArgs();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FsiOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class Yaaf.FSharp.Scripting.HandledResult`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInvalidExpressionType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInvalidCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsResult { get; }
    [CompilationMappingAttribute("8", "0")]
internal static HandledResult`1<a> NewInvalidExpressionType(FsiExpressionTypeException item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInvalidExpressionType();
    [CompilationMappingAttribute("8", "1")]
internal static HandledResult`1<a> NewInvalidCode(FsiEvaluationException item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInvalidCode();
    [CompilationMappingAttribute("8", "2")]
internal static HandledResult`1<a> NewResult(a item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsResult();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HandledResult`1<a> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Yaaf.FSharp.Scripting.Helper : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a consoleCapture(TextWriter out, TextWriter err, FSharpFunc`2<Unit, a> f);
    internal static Tuple`3<OutputData, OutputData, string> getMessages@1263(OutStreamHelper out, OutStreamHelper err, StringBuilder sbInput, Unit unitVar0);
    internal static a redirectOut@1268(bool preventStdOut, OutStreamHelper out, OutStreamHelper err, FSharpFunc`2<Unit, a> f);
    internal static FSharpFunc`2<string, Tuple`2<InteractionResult, a>> save_@1295(bool reportGlobal, bool preventStdOut, OutStreamHelper out, OutStreamHelper err, StringBuilder sbInput, String[] args, FSharpFunc`2<string, a> f);
    internal static FSharpFunc`2<string, Tuple`2<InteractionResult, a>> save@1310(bool reportGlobal, bool preventStdOut, OutStreamHelper out, OutStreamHelper err, StringBuilder sbInput, String[] args, FSharpFunc`2<string, a> f);
    internal static FSharpFunc`2<string, Tuple`2<InteractionResult, a>> saveScript@1315(bool reportGlobal, bool preventStdOut, OutStreamHelper out, OutStreamHelper err, StringBuilder sbInput, String[] args, FSharpFunc`2<string, a> f);
    internal static IFsiSession getSession(object fsi, FsiOptions options, bool reportGlobal, FSharpOption`1<TextWriter> liveOut, FSharpOption`1<TextWriter> liveOutFsi, FSharpOption`1<TextWriter> liveErr, FSharpOption`1<TextWriter> liveErrFsi, bool preventStdOut);
}
[CompilationMappingAttribute("3")]
internal interface Yaaf.FSharp.Scripting.IFsiSession {
    public Assembly DynamicAssembly { get; }
    public abstract virtual InteractionResult EvalInteractionWithOutput(string );
    public abstract virtual Tuple`2<InteractionResult, FSharpOption`1<Tuple`2<object, Type>>> TryEvalExpressionWithOutput(string );
    public abstract virtual InteractionResult EvalScriptWithOutput(string );
    public abstract virtual Assembly get_DynamicAssembly();
}
[CompilationMappingAttribute("34")]
internal class Yaaf.FSharp.Scripting.InteractionResult : object {
    [DebuggerBrowsableAttribute("0")]
internal OutputData Output@;
    [DebuggerBrowsableAttribute("0")]
internal OutputData Error@;
    [CompilationMappingAttribute("4", "0")]
internal OutputData Output { get; }
    [CompilationMappingAttribute("4", "1")]
internal OutputData Error { get; }
    internal InteractionResult(OutputData output, OutputData error);
    internal OutputData get_Output();
    internal OutputData get_Error();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InteractionResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InteractionResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class Yaaf.FSharp.Scripting.Log : object {
    [CompilationMappingAttribute("9")]
public static TraceSource source { get; }
    public static TraceSource get_source();
    public static void LogConsole(SourceLevels levels);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a traceEventf(TraceEventType t, PrintfFormat`4<a, Unit, string, Unit> f);
    public static a infof(PrintfFormat`4<a, Unit, string, Unit> f);
    public static a errorf(PrintfFormat`4<a, Unit, string, Unit> f);
    public static a warnf(PrintfFormat`4<a, Unit, string, Unit> f);
    public static a critf(PrintfFormat`4<a, Unit, string, Unit> f);
    public static a verbf(PrintfFormat`4<a, Unit, string, Unit> f);
    public static string formatArgs(IEnumerable`1<string> args);
    public static string formatPaths(IEnumerable`1<string> paths);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class Yaaf.FSharp.Scripting.OptimizationType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static OptimizationType _unique_NoJitOptimize;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static OptimizationType _unique_NoJitTracking;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static OptimizationType _unique_NoLocalOptimize;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static OptimizationType _unique_NoCrossOptimize;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static OptimizationType _unique_NoTailCalls;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static OptimizationType NoJitOptimize { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoJitOptimize { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static OptimizationType NoJitTracking { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoJitTracking { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static OptimizationType NoLocalOptimize { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoLocalOptimize { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static OptimizationType NoCrossOptimize { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoCrossOptimize { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static OptimizationType NoTailCalls { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoTailCalls { get; }
    private static OptimizationType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal OptimizationType(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static OptimizationType get_NoJitOptimize();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoJitOptimize();
    [CompilationMappingAttribute("8", "1")]
internal static OptimizationType get_NoJitTracking();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoJitTracking();
    [CompilationMappingAttribute("8", "2")]
internal static OptimizationType get_NoLocalOptimize();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoLocalOptimize();
    [CompilationMappingAttribute("8", "3")]
internal static OptimizationType get_NoCrossOptimize();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoCrossOptimize();
    [CompilationMappingAttribute("8", "4")]
internal static OptimizationType get_NoTailCalls();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoTailCalls();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(OptimizationType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OptimizationType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class Yaaf.FSharp.Scripting.OutputData : object {
    [DebuggerBrowsableAttribute("0")]
internal string FsiOutput@;
    [DebuggerBrowsableAttribute("0")]
internal string ScriptOutput@;
    [DebuggerBrowsableAttribute("0")]
internal string Merged@;
    [CompilationMappingAttribute("4", "0")]
public string FsiOutput { get; }
    [CompilationMappingAttribute("4", "1")]
public string ScriptOutput { get; }
    [CompilationMappingAttribute("4", "2")]
public string Merged { get; }
    public OutputData(string fsiOutput, string scriptOutput, string merged);
    public string get_FsiOutput();
    public string get_ScriptOutput();
    public string get_Merged();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(OutputData obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OutputData obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class Yaaf.FSharp.Scripting.ScriptHost : object {
    internal static TextWriter CreateForwardWriter(FSharpFunc`2<string, Unit> f, FSharpOption`1<bool> revertRedirect, FSharpOption`1<bool> removeNewLines);
    internal static IFsiSession Create(FsiOptions opts, FSharpOption`1<object> fsiObj, FSharpOption`1<bool> reportGlobal, FSharpOption`1<TextWriter> outWriter, FSharpOption`1<TextWriter> fsiOutWriter, FSharpOption`1<TextWriter> errWriter, FSharpOption`1<TextWriter> fsiErrWriter, FSharpOption`1<bool> preventStdOut);
    internal static IFsiSession CreateNew(FSharpOption`1<FSharpList`1<string>> defines, FSharpOption`1<object> fsiObj, FSharpOption`1<bool> reportGlobal, FSharpOption`1<TextWriter> outWriter, FSharpOption`1<TextWriter> fsiOutWriter, FSharpOption`1<TextWriter> errWriter, FSharpOption`1<TextWriter> fsiErrWriter, FSharpOption`1<bool> preventStdOut);
}
[CompilationMappingAttribute("7")]
internal static class Yaaf.FSharp.Scripting.Shell : object {
}
[CompilationMappingAttribute("7")]
internal static class Yaaf.FSharp.Scripting.StringHelpers : object {
}
