public class NuGet.AggregateConstraintProvider : object {
    private IEnumerable`1<IPackageConstraintProvider> _constraintProviders;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageConstraintProvider, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageConstraintProvider, string> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<IVersionSpec, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    public string Source { get; }
    public AggregateConstraintProvider(IPackageConstraintProvider[] constraintProviders);
    public sealed virtual string get_Source();
    public sealed virtual IVersionSpec GetConstraint(string packageId);
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__0(IPackageConstraintProvider cp);
    [CompilerGeneratedAttribute]
private static string <get_Source>b__2(IPackageConstraintProvider cp);
    [CompilerGeneratedAttribute]
private static bool <GetConstraint>b__5(IVersionSpec constraint);
}
internal class NuGet.AggregateQuery`1 : object {
    private static int QueryCacheSize;
    private IEnumerable`1<IQueryable`1<TVal>> _queryables;
    private Expression _expression;
    private IEqualityComparer`1<TVal> _equalityComparer;
    private IList`1<IEnumerable`1<TVal>> _subQueries;
    private bool _ignoreFailures;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<TVal>, LazyQueue`1<TVal>> CS$<>9__CachedAnonymousMethodDelegate8;
    public Type ElementType { get; }
    public Expression Expression { get; }
    public IQueryProvider Provider { get; }
    public AggregateQuery`1(IEnumerable`1<IQueryable`1<TVal>> queryables, IEqualityComparer`1<TVal> equalityComparer, ILogger logger, bool ignoreFailures);
    private AggregateQuery`1(IEnumerable`1<IQueryable`1<TVal>> queryables, IEqualityComparer`1<TVal> equalityComparer, IList`1<IEnumerable`1<TVal>> subQueries, Expression expression, ILogger logger, bool ignoreInvalidRepositories);
    public sealed virtual IEnumerator`1<TVal> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Type get_ElementType();
    public sealed virtual Expression get_Expression();
    public sealed virtual IQueryProvider get_Provider();
    public sealed virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public sealed virtual IQueryable CreateQuery(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    public sealed virtual object Execute(Expression expression);
    private IEnumerable`1<TVal> GetAggregateEnumerable();
    private IEnumerable`1<TVal> ReadOrderedQueues(IComparer`1<TVal> comparer);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
private TaskResult<TVal> ReadQueue(LazyQueue`1<TVal> queue);
    private IList`1<IEnumerable`1<TVal>> GetSubQueries(Expression expression);
    private IQueryable CreateQuery(Type elementType, Expression expression);
    private void LogWarning(Exception ex);
    private static IEnumerable`1<TVal> GetSubQuery(IQueryable queryable, Expression expression);
    private static TResult Execute(IQueryable queryable, Expression expression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
private TResult TryExecute(IQueryable queryable, Expression expression);
    private static Expression RewriteForAggregation(IQueryable queryable, Expression expression);
    private static Expression Rewrite(IQueryable queryable, Expression expression);
    [CompilerGeneratedAttribute]
private IEnumerable`1<TVal> <GetAggregateEnumerable>b__3(IEnumerable`1<TVal> query);
    [CompilerGeneratedAttribute]
private static LazyQueue`1<TVal> <ReadOrderedQueues>b__5(IEnumerable`1<TVal> query);
    [CompilerGeneratedAttribute]
private Task`1<TaskResult<TVal>> <ReadOrderedQueues>b__6(LazyQueue`1<TVal> queue);
}
public class NuGet.AggregateRepository : PackageRepositoryBase {
    private static string SourceValue;
    private ConcurrentBag`1<IPackageRepository> _failingRepositories;
    private IEnumerable`1<IPackageRepository> _repositories;
    private Lazy`1<bool> _supportsPrereleasePackages;
    [CompilerGeneratedAttribute]
private bool <ResolveDependenciesVertically>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreFailingRepositories>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageRepository, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<AggregateRepository, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<AggregateRepository, ILogger> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<ILogger, bool> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypec`2<string, IPackageRepository>, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypec`2<string, IPackageRepository>, IPackageRepository> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageRepository, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageRepository, IQueryable`1<IPackage>> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, bool> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Predicate`1<IPackage> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageRepository, IEnumerable`1<IPackageRepository>> CS$<>9__CachedAnonymousMethodDelegate38;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate43;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate44;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypec`2<PackageSource, IPackageRepository>, bool> CS$<>9__CachedAnonymousMethodDelegate53;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypec`2<PackageSource, IPackageRepository>, IPackageRepository> CS$<>9__CachedAnonymousMethodDelegate54;
    public string Source { get; }
    public bool ResolveDependenciesVertically { get; public set; }
    public bool IgnoreFailingRepositories { get; public set; }
    public IEnumerable`1<IPackageRepository> Repositories { get; }
    public bool SupportsPrereleasePackages { get; }
    public AggregateRepository(IEnumerable`1<IPackageRepository> repositories);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
public AggregateRepository(IPackageRepositoryFactory repositoryFactory, IEnumerable`1<string> packageSources, bool ignoreFailingRepositories);
    public virtual string get_Source();
    [CompilerGeneratedAttribute]
public bool get_ResolveDependenciesVertically();
    [CompilerGeneratedAttribute]
public void set_ResolveDependenciesVertically(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreFailingRepositories();
    [CompilerGeneratedAttribute]
public void set_IgnoreFailingRepositories(bool value);
    public IEnumerable`1<IPackageRepository> get_Repositories();
    public virtual bool get_SupportsPrereleasePackages();
    public virtual IQueryable`1<IPackage> GetPackages();
    public sealed virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public sealed virtual bool Exists(string packageId, SemanticVersion version);
    public sealed virtual IPackage ResolveDependency(PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
private Func`2<IPackageRepository, T> Wrap(Func`2<IPackageRepository, T> factory, T defaultValue);
    public void LogRepository(IPackageRepository repository, Exception ex);
    public sealed virtual IQueryable`1<IPackage> Search(string searchTerm, IEnumerable`1<string> targetFrameworks, bool allowPrereleaseVersions);
    public sealed virtual IPackageRepository Clone();
    private AggregateQuery`1<IPackage> CreateAggregateQuery(IEnumerable`1<IQueryable`1<IPackage>> queries);
    internal static IEnumerable`1<IPackageRepository> Flatten(IEnumerable`1<IPackageRepository> repositories);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
public sealed virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
public sealed virtual IEnumerable`1<IPackage> GetUpdates(IEnumerable`1<IPackageName> packages, bool includePrerelease, bool includeAllVersions, IEnumerable`1<FrameworkName> targetFrameworks, IEnumerable`1<IVersionSpec> versionConstraints);
    public sealed virtual IDisposable StartOperation(string operation, string mainPackageId, string mainPackageVersion);
    public static IPackageRepository Create(IPackageRepositoryFactory factory, IList`1<PackageSource> sources, bool ignoreFailingRepositories);
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__0(IPackageRepository r);
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__2(AggregateRepository r);
    [CompilerGeneratedAttribute]
private static ILogger <.ctor>b__3(AggregateRepository r);
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__4(ILogger l);
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__e(<>f__AnonymousTypec`2<string, IPackageRepository> <>h__TransparentIdentifierb);
    [CompilerGeneratedAttribute]
private static IPackageRepository <.ctor>b__f(<>f__AnonymousTypec`2<string, IPackageRepository> <>h__TransparentIdentifierb);
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__10(IPackageRepository r);
    [CompilerGeneratedAttribute]
private static IQueryable`1<IPackage> <GetPackages>b__1a(IPackageRepository r);
    [CompilerGeneratedAttribute]
private static bool <FindPackage>b__1d(IPackage p);
    [CompilerGeneratedAttribute]
private static bool <ResolveDependency>b__27(IPackage package);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<IPackageRepository> <Flatten>b__37(IPackageRepository repository);
    [CompilerGeneratedAttribute]
private static string <GetUpdates>b__41(IPackage p);
    [CompilerGeneratedAttribute]
private static SemanticVersion <GetUpdates>b__42(IPackage p);
    [CompilerGeneratedAttribute]
private static bool <Create>b__50(<>f__AnonymousTypec`2<PackageSource, IPackageRepository> <>h__TransparentIdentifier4c);
    [CompilerGeneratedAttribute]
private static IPackageRepository <Create>b__51(<>f__AnonymousTypec`2<PackageSource, IPackageRepository> <>h__TransparentIdentifier4c);
}
internal class NuGet.Analysis.Rules.InitScriptNotUnderToolsRule : object {
    public sealed virtual IEnumerable`1<PackageIssue> Validate(IPackage package);
    private static PackageIssue CreatePackageIssue(IPackageFile file);
}
internal class NuGet.Analysis.Rules.InvalidFrameworkFolderRule : object {
    public sealed virtual IEnumerable`1<PackageIssue> Validate(IPackage package);
    private static bool IsValidFrameworkName(string name);
    private static bool IsValidCultureName(IPackage package, string name);
    private PackageIssue CreatePackageIssue(string target);
}
internal class NuGet.Analysis.Rules.MisplacedAssemblyRule : object {
    public sealed virtual IEnumerable`1<PackageIssue> Validate(IPackage package);
    private static PackageIssue CreatePackageIssueForAssembliesUnderLib(string target);
    private static PackageIssue CreatePackageIssueForAssembliesOutsideLib(string target);
}
internal class NuGet.Analysis.Rules.MisplacedScriptFileRule : object {
    private static string ScriptExtension;
    public sealed virtual IEnumerable`1<PackageIssue> Validate(IPackage package);
    private static PackageIssue CreatePackageIssueForMisplacedScript(string target);
    private static PackageIssue CreatePackageIssueForUnrecognizedScripts(string target);
}
internal class NuGet.Analysis.Rules.MisplacedTransformFileRule : object {
    private static string CodeTransformExtension;
    private static string ConfigTransformExtension;
    public sealed virtual IEnumerable`1<PackageIssue> Validate(IPackage package);
    private static PackageIssue CreatePackageIssueForMisplacedContent(string path);
}
internal class NuGet.Analysis.Rules.MissingSummaryRule : object {
    private static int ThresholdDescriptionLength;
    public sealed virtual IEnumerable`1<PackageIssue> Validate(IPackage package);
}
internal class NuGet.Analysis.Rules.WinRTNameIsObsoleteRule : object {
    private static String[] Prefixes;
    private static WinRTNameIsObsoleteRule();
    public sealed virtual IEnumerable`1<PackageIssue> Validate(IPackage package);
    private static PackageIssue CreateIssue(IPackageFile file);
}
public class NuGet.AssemblyMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Company>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    public string Name { get; public set; }
    public SemanticVersion Version { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public string Company { get; public set; }
    public string Copyright { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public SemanticVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(SemanticVersion value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Company();
    [CompilerGeneratedAttribute]
public void set_Company(string value);
    [CompilerGeneratedAttribute]
public string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
}
public static class NuGet.AssemblyMetadataExtractor : object {
    public static AssemblyMetadata GetMetadata(string assemblyPath);
    public static void ExtractMetadata(PackageBuilder builder, string assemblyPath);
}
[SuppressMessageAttribute("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
public class NuGet.BufferedEnumerable`1 : object {
    private IQueryable`1<TElement> _source;
    private int _bufferSize;
    private QueryState`1<TElement, TElement> _state;
    public BufferedEnumerable`1(IQueryable`1<TElement> source, int bufferSize);
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class NuGet.CollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static int RemoveAll(ICollection`1<T> collection, Func`2<T, bool> match);
}
[CompilerGeneratedAttribute]
internal static class NuGet.CommonResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
[SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static CultureInfo Culture { get; internal set; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static string Argument_Must_Be_Between { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static string Argument_Must_Be_Enum_Member { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static string Argument_Must_Be_GreaterThan { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static string Argument_Must_Be_GreaterThanOrEqualTo { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static string Argument_Must_Be_LessThan { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static string Argument_Must_Be_LessThanOrEqualTo { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static string Argument_Must_Be_Null_Or_Non_Empty { get; }
    [SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
internal static string EnsureImportedMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_Argument_Must_Be_Between();
    internal static string get_Argument_Must_Be_Enum_Member();
    internal static string get_Argument_Must_Be_GreaterThan();
    internal static string get_Argument_Must_Be_GreaterThanOrEqualTo();
    internal static string get_Argument_Must_Be_LessThan();
    internal static string get_Argument_Must_Be_LessThanOrEqualTo();
    internal static string get_Argument_Must_Be_Null_Or_Non_Empty();
    internal static string get_EnsureImportedMessage();
    [CompilerGeneratedAttribute]
private static bool <get_ResourceManager>b__0(string s);
}
public class NuGet.ConfigurationDefaults : object {
    private static string ConfigurationDefaultsFile;
    private ISettings _settingsManager;
    private static ConfigurationDefaults _instance;
    private bool _defaultPackageSourceInitialized;
    private List`1<PackageSource> _defaultPackageSources;
    private string _defaultPushSource;
    public static ConfigurationDefaults Instance { get; }
    public IEnumerable`1<PackageSource> DefaultPackageSources { get; }
    public string DefaultPushSource { get; }
    public string DefaultPackageRestoreConsent { get; }
    internal ConfigurationDefaults(IFileSystem fileSystem, string path);
    private static ConfigurationDefaults();
    private static ConfigurationDefaults InitializeInstance();
    public static ConfigurationDefaults get_Instance();
    public IEnumerable`1<PackageSource> get_DefaultPackageSources();
    public string get_DefaultPushSource();
    public string get_DefaultPackageRestoreConsent();
}
public class NuGet.ConflictResult : object {
    [CompilerGeneratedAttribute]
private IPackage <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IDependentsResolver <DependentsResolver>k__BackingField;
    public IPackage Package { get; private set; }
    public IPackageRepository Repository { get; private set; }
    public IDependentsResolver DependentsResolver { get; private set; }
    public ConflictResult(IPackage conflictingPackage, IPackageRepository repository, IDependentsResolver resolver);
    [CompilerGeneratedAttribute]
public IPackage get_Package();
    [CompilerGeneratedAttribute]
private void set_Package(IPackage value);
    [CompilerGeneratedAttribute]
public IPackageRepository get_Repository();
    [CompilerGeneratedAttribute]
private void set_Repository(IPackageRepository value);
    [CompilerGeneratedAttribute]
public IDependentsResolver get_DependentsResolver();
    [CompilerGeneratedAttribute]
private void set_DependentsResolver(IDependentsResolver value);
}
public static class NuGet.Constants : object {
    internal static string PackageRelationshipNamespace;
    internal static string PackageEmptyFileName;
    public static string PackageExtension;
    public static string ManifestExtension;
    public static string ContentDirectory;
    public static string LibDirectory;
    public static string ToolsDirectory;
    public static string HashFileExtension;
    public static string BuildDirectory;
    public static string ContentFilesDirectory;
    public static string AnalyzersDirectory;
    public static string BinDirectory;
    public static string SettingsFileName;
    public static string PackageReferenceFile;
    public static string MirroringReferenceFile;
    public static string BeginIgnoreMarker;
    public static string EndIgnoreMarker;
    public static DateTimeOffset Unpublished;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static ICollection`1<string> AssemblyReferencesExtensions;
    public static Version NuGetVersion;
    private static Constants();
}
[ExtensionAttribute]
internal static class NuGet.CredentialProviderExtensions : object {
    private static String[] _authenticationSchemes;
    private static CredentialProviderExtensions();
    [ExtensionAttribute]
internal static ICredentials GetCredentials(ICredentialProvider provider, WebRequest request, CredentialType credentialType, bool retrying);
    [ExtensionAttribute]
internal static ICredentials AsCredentialCache(ICredentials credentials, Uri uri);
}
public class NuGet.CredentialResult : object {
    [CompilerGeneratedAttribute]
private CredentialState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    public CredentialState State { get; public set; }
    public ICredentials Credentials { get; public set; }
    [CompilerGeneratedAttribute]
public CredentialState get_State();
    [CompilerGeneratedAttribute]
public void set_State(CredentialState value);
    [CompilerGeneratedAttribute]
public ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(ICredentials value);
    public static CredentialResult Create(CredentialState state, ICredentials credentials);
}
public enum NuGet.CredentialState : Enum {
    public int value__;
    public static CredentialState HasCredentials;
    public static CredentialState Abort;
}
public class NuGet.CredentialStore : object {
    private ConcurrentDictionary`2<Uri, ICredentials> _credentialCache;
    private static CredentialStore _instance;
    public static CredentialStore Instance { get; }
    private static CredentialStore();
    public static CredentialStore get_Instance();
    public sealed virtual ICredentials GetCredentials(Uri uri);
    public sealed virtual void Add(Uri uri, ICredentials credentials);
    internal static Uri GetRootUri(Uri uri);
}
public enum NuGet.CredentialType : Enum {
    public int value__;
    public static CredentialType ProxyCredentials;
    public static CredentialType RequestCredentials;
}
public class NuGet.CryptoHashProvider : object {
    private static string SHA512HashAlgorithm;
    private static string SHA256HashAlgorithm;
    private string _hashAlgorithm;
    private static bool AllowOnlyFipsAlgorithms { get; }
    public CryptoHashProvider(string hashAlgorithm);
    private static bool get_AllowOnlyFipsAlgorithms();
    public sealed virtual Byte[] CalculateHash(Stream stream);
    public sealed virtual Byte[] CalculateHash(Byte[] data);
    public sealed virtual bool VerifyHash(Byte[] data, Byte[] hash);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
private HashAlgorithm GetHashAlgorithm();
    private static bool ReadFipsConfigValue();
}
[ExtensionAttribute]
public static class NuGet.CustomAttributeProviderExtensions : object {
    [ExtensionAttribute]
public static T GetCustomAttribute(ICustomAttributeProvider attributeProvider);
    [ExtensionAttribute]
public static object GetCustomAttribute(ICustomAttributeProvider attributeProvider, Type type);
}
[CLSCompliantAttribute("False")]
public class NuGet.DataServiceContextWrapper : object {
    private static string MetadataKey;
    private static MethodInfo _executeMethodInfo;
    private DataServiceContext _context;
    private Uri _metadataUri;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, bool> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousType12`2<XElement, XElement>> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType12`2<XElement, XElement>, <>f__AnonymousType13`2<<>f__AnonymousType12`2<XElement, XElement>, string>> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType13`2<<>f__AnonymousType12`2<XElement, XElement>, string>, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType13`2<<>f__AnonymousType12`2<XElement, XElement>, string>, <>f__AnonymousType14`2<XElement, XElement>> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, string> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, bool> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousType15`2<XElement, XAttribute>> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType15`2<XElement, XAttribute>, XElement> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, bool> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, string> CS$<>9__CachedAnonymousMethodDelegate21;
    public Uri BaseUri { get; }
    public bool IgnoreMissingProperties { get; public set; }
    private DataServiceMetadata ServiceMetadata { get; }
    public DataServiceContextWrapper(Uri serviceRoot);
    private static DataServiceContextWrapper();
    private Type ResolveTypeFunction(string wireName);
    public sealed virtual Uri get_BaseUri();
    public sealed virtual void add_SendingRequest(EventHandler`1<SendingRequestEventArgs> value);
    public sealed virtual void remove_SendingRequest(EventHandler`1<SendingRequestEventArgs> value);
    public sealed virtual void add_ReadingEntity(EventHandler`1<ReadingWritingEntityEventArgs> value);
    public sealed virtual void remove_ReadingEntity(EventHandler`1<ReadingWritingEntityEventArgs> value);
    public sealed virtual bool get_IgnoreMissingProperties();
    public sealed virtual void set_IgnoreMissingProperties(bool value);
    private DataServiceMetadata get_ServiceMetadata();
    public sealed virtual IDataServiceQuery`1<T> CreateQuery(string entitySetName, IDictionary`2<string, object> queryOptions);
    public sealed virtual IDataServiceQuery`1<T> CreateQuery(string entitySetName);
    public sealed virtual IEnumerable`1<T> Execute(Type elementType, DataServiceQueryContinuation continuation);
    public sealed virtual IEnumerable`1<T> ExecuteBatch(DataServiceRequest request);
    public sealed virtual Uri GetReadStreamUri(object entity);
    public sealed virtual bool SupportsServiceMethod(string methodName);
    public sealed virtual bool SupportsProperty(string propertyName);
    private string GetServiceMetadataKey();
    private static DataServiceMetadata GetDataServiceMetadata(Uri metadataUri);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
internal static DataServiceMetadata ExtractMetadataFromSchema(Stream schemaStream);
    private static DataServiceMetadata ExtractMetadataInternal(XDocument schemaDocument);
    private static IEnumerable`1<string> ExtractSupportedProperties(XDocument schemaDocument, string packageEntityName);
    private static string TrimNamespace(string packageEntityName);
    [CompilerGeneratedAttribute]
private DataServiceMetadata <get_ServiceMetadata>b__1();
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <ExecuteBatch>b__2(QueryOperationResponse o);
    [CompilerGeneratedAttribute]
private static bool <ExtractMetadataInternal>b__6(XElement e);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType12`2<XElement, XElement> <ExtractMetadataInternal>b__7(XElement e);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType13`2<<>f__AnonymousType12`2<XElement, XElement>, string> <ExtractMetadataInternal>b__9(<>f__AnonymousType12`2<XElement, XElement> <>h__TransparentIdentifier3);
    [CompilerGeneratedAttribute]
private static bool <ExtractMetadataInternal>b__a(<>f__AnonymousType13`2<<>f__AnonymousType12`2<XElement, XElement>, string> <>h__TransparentIdentifier4);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType14`2<XElement, XElement> <ExtractMetadataInternal>b__b(<>f__AnonymousType13`2<<>f__AnonymousType12`2<XElement, XElement>, string> <>h__TransparentIdentifier4);
    [CompilerGeneratedAttribute]
private static bool <ExtractMetadataInternal>b__c(XElement e);
    [CompilerGeneratedAttribute]
private static string <ExtractMetadataInternal>b__d(XElement e);
    [CompilerGeneratedAttribute]
private static bool <ExtractMetadataInternal>b__8(XElement el);
    [CompilerGeneratedAttribute]
private static bool <ExtractSupportedProperties>b__17(XElement e);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType15`2<XElement, XAttribute> <ExtractSupportedProperties>b__18(XElement e);
    [CompilerGeneratedAttribute]
private static XElement <ExtractSupportedProperties>b__1a(<>f__AnonymousType15`2<XElement, XAttribute> <>h__TransparentIdentifier16);
    [CompilerGeneratedAttribute]
private static bool <ExtractSupportedProperties>b__1b(XElement e);
    [CompilerGeneratedAttribute]
private static string <ExtractSupportedProperties>b__1c(XElement e);
}
[DataServiceKeyAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[EntityPropertyMappingAttribute]
[CLSCompliantAttribute("False")]
[EntityPropertyMappingAttribute]
[EntityPropertyMappingAttribute]
[EntityPropertyMappingAttribute]
public class NuGet.DataServicePackage : object {
    private IHashProvider _hashProvider;
    private bool _usingMachineCache;
    private string _licenseNames;
    internal IPackage _package;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReportAbuseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <GalleryDetailsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <LicenseNameCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseReportUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLatestVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAbsoluteLatestVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OldHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataServiceContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDownloader <Downloader>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Tuple`3<string, IVersionSpec, FrameworkName>, FrameworkName> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<FrameworkName, Tuple`3<string, IVersionSpec, FrameworkName>>, PackageDependencySet> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<Tuple`3<string, IVersionSpec, FrameworkName>, bool> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<Tuple`3<string, IVersionSpec, FrameworkName>, PackageDependency> CS$<>9__CachedAnonymousMethodDelegate9;
    public string Id { get; public set; }
    public string Version { get; public set; }
    public string Title { get; public set; }
    public string Authors { get; public set; }
    public string Owners { get; public set; }
    public Uri IconUrl { get; public set; }
    public Uri LicenseUrl { get; public set; }
    public Uri ProjectUrl { get; public set; }
    public Uri ReportAbuseUrl { get; public set; }
    public Uri GalleryDetailsUrl { get; public set; }
    public string LicenseNames { get; public set; }
    public ICollection`1<string> LicenseNameCollection { get; private set; }
    public Uri LicenseReportUrl { get; public set; }
    public Uri DownloadUrl { get; }
    public bool Listed { get; public set; }
    public Nullable`1<DateTimeOffset> Published { get; public set; }
    public DateTimeOffset LastUpdated { get; public set; }
    public int DownloadCount { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string Language { get; public set; }
    public string Tags { get; public set; }
    public string Dependencies { get; public set; }
    public string PackageHash { get; public set; }
    public string PackageHashAlgorithm { get; public set; }
    public bool IsLatestVersion { get; public set; }
    public bool IsAbsoluteLatestVersion { get; public set; }
    public string Copyright { get; public set; }
    public string MinClientVersion { get; public set; }
    private string OldHash { get; private set; }
    private IPackage Package { get; }
    internal IDataServiceContext Context { get; internal set; }
    internal PackageDownloader Downloader { get; internal set; }
    internal IHashProvider HashProvider { get; internal set; }
    private bool NuGet.IPackage.Listed { get; }
    private IEnumerable`1<string> NuGet.IPackageMetadata.Authors { get; }
    private IEnumerable`1<string> NuGet.IPackageMetadata.Owners { get; }
    public IEnumerable`1<PackageDependencySet> DependencySets { get; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; }
    private SemanticVersion NuGet.IPackageName.Version { get; }
    private Version NuGet.IPackageMetadata.MinClientVersion { get; }
    public IEnumerable`1<IPackageAssemblyReference> AssemblyReferences { get; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkAssemblies { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(string value);
    [CompilerGeneratedAttribute]
public string get_Owners();
    [CompilerGeneratedAttribute]
public void set_Owners(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReportAbuseUrl();
    [CompilerGeneratedAttribute]
public void set_ReportAbuseUrl(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_GalleryDetailsUrl();
    [CompilerGeneratedAttribute]
public void set_GalleryDetailsUrl(Uri value);
    public string get_LicenseNames();
    public void set_LicenseNames(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_LicenseNameCollection();
    [CompilerGeneratedAttribute]
private void set_LicenseNameCollection(ICollection`1<string> value);
    [CompilerGeneratedAttribute]
public Uri get_LicenseReportUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseReportUrl(Uri value);
    public Uri get_DownloadUrl();
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public void set_Listed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
public void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastUpdated();
    [CompilerGeneratedAttribute]
public void set_LastUpdated(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_DownloadCount();
    [CompilerGeneratedAttribute]
public void set_DownloadCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(string value);
    [CompilerGeneratedAttribute]
public string get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(string value);
    [CompilerGeneratedAttribute]
public string get_PackageHash();
    [CompilerGeneratedAttribute]
public void set_PackageHash(string value);
    [CompilerGeneratedAttribute]
public string get_PackageHashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_PackageHashAlgorithm(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLatestVersion();
    [CompilerGeneratedAttribute]
public void set_IsLatestVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAbsoluteLatestVersion();
    [CompilerGeneratedAttribute]
public void set_IsAbsoluteLatestVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public string get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(string value);
    [CompilerGeneratedAttribute]
private string get_OldHash();
    [CompilerGeneratedAttribute]
private void set_OldHash(string value);
    private IPackage get_Package();
    [CompilerGeneratedAttribute]
internal IDataServiceContext get_Context();
    [CompilerGeneratedAttribute]
internal void set_Context(IDataServiceContext value);
    [CompilerGeneratedAttribute]
internal PackageDownloader get_Downloader();
    [CompilerGeneratedAttribute]
internal void set_Downloader(PackageDownloader value);
    internal IHashProvider get_HashProvider();
    internal void set_HashProvider(IHashProvider value);
    private sealed virtual override bool NuGet.IPackage.get_Listed();
    private sealed virtual override IEnumerable`1<string> NuGet.IPackageMetadata.get_Authors();
    private sealed virtual override IEnumerable`1<string> NuGet.IPackageMetadata.get_Owners();
    public sealed virtual IEnumerable`1<PackageDependencySet> get_DependencySets();
    public sealed virtual ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    private sealed virtual override SemanticVersion NuGet.IPackageName.get_Version();
    private sealed virtual override Version NuGet.IPackageMetadata.get_MinClientVersion();
    public sealed virtual IEnumerable`1<IPackageAssemblyReference> get_AssemblyReferences();
    public sealed virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkAssemblies();
    public virtual IEnumerable`1<FrameworkName> GetSupportedFrameworks();
    public sealed virtual IEnumerable`1<IPackageFile> GetFiles();
    public sealed virtual Stream GetStream();
    public sealed virtual void ExtractContents(IFileSystem fileSystem, string extractPath);
    public virtual string ToString();
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2202:Do not dispose objects multiple times")]
internal void EnsurePackage(IPackageCacheRepository cacheRepository);
    private bool MatchPackageHash(IPackage package);
    private static List`1<PackageDependencySet> ParseDependencySet(string value);
    private static Tuple`3<string, IVersionSpec, FrameworkName> ParseDependency(string value);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
private static bool TryGetPackage(IPackageRepository repository, IPackageMetadata packageMetadata, IPackage& package);
    [CompilerGeneratedAttribute]
private void <EnsurePackage>b__0(Stream stream);
    [CompilerGeneratedAttribute]
private static FrameworkName <ParseDependencySet>b__2(Tuple`3<string, IVersionSpec, FrameworkName> d);
    [CompilerGeneratedAttribute]
private static PackageDependencySet <ParseDependencySet>b__3(IGrouping`2<FrameworkName, Tuple`3<string, IVersionSpec, FrameworkName>> g);
    [CompilerGeneratedAttribute]
private static bool <ParseDependencySet>b__4(Tuple`3<string, IVersionSpec, FrameworkName> pair);
    [CompilerGeneratedAttribute]
private static PackageDependency <ParseDependencySet>b__5(Tuple`3<string, IVersionSpec, FrameworkName> pair);
}
public class NuGet.DataServicePackageRepository : PackageRepositoryBase {
    private static string FindPackagesByIdSvcMethod;
    private static string PackageServiceEntitySetName;
    private static string SearchSvcMethod;
    private static string GetUpdatesSvcMethod;
    private IDataServiceContext _context;
    private IHttpClient _httpClient;
    private PackageDownloader _packageDownloader;
    private CultureInfo _culture;
    private Tuple`3<string, string, string> _currentOperation;
    private EventHandler`1<WebRequestEventArgs> _sendingRequest;
    [CompilerGeneratedAttribute]
private static Func`2<string, FrameworkName> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageName, string> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageName, string> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<IVersionSpec, string> CS$<>9__CachedAnonymousMethodDelegate12;
    public CultureInfo Culture { get; }
    public PackageDownloader PackageDownloader { get; }
    public string Source { get; }
    public bool SupportsPrereleasePackages { get; }
    private IDataServiceContext Context { get; internal set; }
    public DataServicePackageRepository(Uri serviceRoot);
    public DataServicePackageRepository(IHttpClient client);
    public DataServicePackageRepository(IHttpClient client, PackageDownloader packageDownloader);
    private void add__sendingRequest(EventHandler`1<WebRequestEventArgs> value);
    private void remove__sendingRequest(EventHandler`1<WebRequestEventArgs> value);
    private void OnPackageDownloaderSendingRequest(object sender, WebRequestEventArgs e);
    public sealed virtual void add_ProgressAvailable(EventHandler`1<ProgressEventArgs> value);
    public sealed virtual void remove_ProgressAvailable(EventHandler`1<ProgressEventArgs> value);
    public sealed virtual void add_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
    public sealed virtual void remove_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
    public sealed virtual CultureInfo get_Culture();
    public PackageDownloader get_PackageDownloader();
    public virtual string get_Source();
    public virtual bool get_SupportsPrereleasePackages();
    private IDataServiceContext get_Context();
    internal void set_Context(IDataServiceContext value);
    private void OnReadingEntity(object sender, ReadingWritingEntityEventArgs e);
    private void OnSendingRequest(object sender, SendingRequestEventArgs e);
    private void RaiseSendingRequest(WebRequestEventArgs e);
    public virtual IQueryable`1<IPackage> GetPackages();
    public sealed virtual IQueryable`1<IPackage> Search(string searchTerm, IEnumerable`1<string> targetFrameworks, bool allowPrereleaseVersions);
    public sealed virtual bool Exists(string packageId, SemanticVersion version);
    public sealed virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public sealed virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
    public sealed virtual IEnumerable`1<IPackage> GetUpdates(IEnumerable`1<IPackageName> packages, bool includePrerelease, bool includeAllVersions, IEnumerable`1<FrameworkName> targetFrameworks, IEnumerable`1<IVersionSpec> versionConstraints);
    public sealed virtual IPackageRepository Clone();
    public sealed virtual IDisposable StartOperation(string operation, string mainPackageId, string mainPackageVersion);
    public sealed virtual bool TryFindLatestPackageById(string id, SemanticVersion& latestVersion);
    public sealed virtual bool TryFindLatestPackageById(string id, bool includePrerelease, IPackage& package);
    private static string UrlEncodeOdataParameter(string value);
    [SuppressMessageAttribute("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase")]
private static string ToLowerCaseString(bool value);
    public sealed virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    [CompilerGeneratedAttribute]
private static FrameworkName <Search>b__1(string name);
    [CompilerGeneratedAttribute]
private static string <GetUpdates>b__d(IPackageName p);
    [CompilerGeneratedAttribute]
private static string <GetUpdates>b__e(IPackageName p);
    [CompilerGeneratedAttribute]
private static string <GetUpdates>b__f(IVersionSpec v);
}
[CLSCompliantAttribute("False")]
public class NuGet.DataServiceQueryWrapper`1 : object {
    private static int MaxUrlLength;
    private DataServiceQuery _query;
    private IDataServiceContext _context;
    private Type _concreteType;
    public DataServiceQueryWrapper`1(IDataServiceContext context, DataServiceQuery query);
    public DataServiceQueryWrapper`1(IDataServiceContext context, DataServiceQuery query, Type concreteType);
    public sealed virtual bool RequiresBatch(Expression expression);
    public sealed virtual DataServiceRequest GetRequest(Expression expression);
    public virtual Uri GetRequestUri(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    public sealed virtual object Execute(Expression expression);
    public sealed virtual IDataServiceQuery`1<TElement> CreateQuery(Expression expression);
    public sealed virtual IQueryable`1<T> AsQueryable();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private IEnumerable`1<T> GetAll();
    private Expression GetInnerExpression(Expression expression);
    public virtual string ToString();
    private TResult Execute(Func`1<TResult> action);
    private static string ExtractMessageFromClientException(Exception exception);
}
public class NuGet.DefaultConstraintProvider : object {
    private Dictionary`2<string, IVersionSpec> _constraints;
    public string Source { get; }
    public sealed virtual string get_Source();
    public void AddConstraint(string packageId, IVersionSpec versionSpec);
    public sealed virtual IVersionSpec GetConstraint(string packageId);
}
public class NuGet.DefaultPackagePathResolver : object {
    private IFileSystem _fileSystem;
    private bool _useSideBySidePaths;
    public DefaultPackagePathResolver(string path);
    public DefaultPackagePathResolver(IFileSystem fileSystem);
    public DefaultPackagePathResolver(string path, bool useSideBySidePaths);
    public DefaultPackagePathResolver(IFileSystem fileSystem, bool useSideBySidePaths);
    public virtual string GetInstallPath(IPackage package);
    public virtual string GetPackageDirectory(IPackage package);
    public virtual string GetPackageFileName(IPackage package);
    public virtual string GetPackageDirectory(string packageId, SemanticVersion version);
    public virtual string GetPackageFileName(string packageId, SemanticVersion version);
}
public static class NuGet.DefaultPackageRuleSet : object {
    private static ReadOnlyCollection`1<IPackageRule> _rules;
    public static IEnumerable`1<IPackageRule> Rules { get; }
    private static DefaultPackageRuleSet();
    public static IEnumerable`1<IPackageRule> get_Rules();
}
public enum NuGet.DependencyVersion : Enum {
    public int value__;
    public static DependencyVersion Lowest;
    public static DependencyVersion HighestPatch;
    public static DependencyVersion HighestMinor;
    public static DependencyVersion Highest;
}
public class NuGet.DependentsWalker : PackageWalker {
    [CompilerGeneratedAttribute]
private IPackageRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<IPackage, HashSet`1<IPackage>> <DependentsLookup>k__BackingField;
    protected bool RaiseErrorOnCycle { get; }
    protected bool IgnoreWalkInfo { get; }
    protected IPackageRepository Repository { get; private set; }
    private IDictionary`2<IPackage, HashSet`1<IPackage>> DependentsLookup { get; private set; }
    internal DependentsWalker(IPackageRepository repository);
    public DependentsWalker(IPackageRepository repository, FrameworkName targetFramework);
    protected virtual bool get_RaiseErrorOnCycle();
    protected virtual bool get_IgnoreWalkInfo();
    [CompilerGeneratedAttribute]
protected IPackageRepository get_Repository();
    [CompilerGeneratedAttribute]
private void set_Repository(IPackageRepository value);
    [CompilerGeneratedAttribute]
private IDictionary`2<IPackage, HashSet`1<IPackage>> get_DependentsLookup();
    [CompilerGeneratedAttribute]
private void set_DependentsLookup(IDictionary`2<IPackage, HashSet`1<IPackage>> value);
    protected virtual IPackage ResolveDependency(PackageDependency dependency);
    protected virtual bool OnAfterResolveDependency(IPackage package, IPackage dependency);
    public sealed virtual IEnumerable`1<IPackage> GetDependents(IPackage package);
}
public class NuGet.DisposableAction : object {
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static DisposableAction NoOp;
    private Action _action;
    [CompilerGeneratedAttribute]
private static Action CS$<>9__CachedAnonymousMethodDelegate4;
    public DisposableAction(Action action);
    private static DisposableAction();
    public static IDisposable All(IDisposable[] tokens);
    public static IDisposable All(IEnumerable`1<IDisposable> tokens);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private static void <.cctor>b__3();
}
internal class NuGet.EmptyFrameworkFolderFile : PhysicalPackageFile {
    [CompilerGeneratedAttribute]
private static Func`1<Stream> CS$<>9__CachedAnonymousMethodDelegate4;
    public EmptyFrameworkFolderFile(string directoryPathInPackage);
    [CompilerGeneratedAttribute]
private static Stream <.ctor>b__3();
}
public static class NuGet.EncryptionUtility : object {
    private static Byte[] _entropyBytes;
    private static EncryptionUtility();
    internal static string EncryptString(string value);
    internal static string DecryptString(string encryptedString);
    public static string GenerateUniqueToken(string caseInsensitiveKey);
}
[ExtensionAttribute]
public static class NuGet.EnumerableExtensions : object {
    [ExtensionAttribute]
internal static IEnumerable`1<TElement> DistinctLast(IEnumerable`1<TElement> source, IEqualityComparer`1<TElement> equalityComparer, IComparer`1<TElement> comparer);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
[ExtensionAttribute]
internal static IEnumerable`1<TElement> SafeIterate(IEnumerable`1<TElement> source);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> sequence);
}
public static class NuGet.EnvironmentUtility : object {
    private static bool _runningFromCommandLine;
    private static bool _isMonoRuntime;
    public static bool IsMonoRuntime { get; }
    public static bool RunningFromCommandLine { get; }
    public static bool IsNet45Installed { get; }
    private static EnvironmentUtility();
    public static bool get_IsMonoRuntime();
    public static bool get_RunningFromCommandLine();
    public static bool get_IsNet45Installed();
    public static void SetRunningFromCommandLine();
}
internal class NuGet.EnvironmentVariableWrapper : object {
    public sealed virtual string GetEnvironmentVariable(string variable);
}
public static class NuGet.ExceptionUtility : object {
    public static Exception Unwrap(Exception exception);
}
public class NuGet.ExpandedPackageRepository : PackageRepositoryBase {
    private IFileSystem _fileSystem;
    private IHashProvider _hashProvider;
    public string Source { get; }
    public bool SupportsPrereleasePackages { get; }
    public ExpandedPackageRepository(IFileSystem fileSystem);
    public ExpandedPackageRepository(IFileSystem fileSystem, IHashProvider hashProvider);
    public virtual string get_Source();
    public virtual bool get_SupportsPrereleasePackages();
    public virtual void AddPackage(IPackage package);
    public virtual void RemovePackage(IPackage package);
    public sealed virtual bool Exists(string packageId, SemanticVersion version);
    public sealed virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public sealed virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
    public virtual IQueryable`1<IPackage> GetPackages();
    private static string GetPackageRoot(string packageId, SemanticVersion version);
    private IPackage GetPackageInternal(string packageId, SemanticVersion version);
    private static string GetPackagePath(string packageId, SemanticVersion version);
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPackage> <GetPackages>b__c(string packageDirectory);
}
internal class NuGet.ExpressionRewriter : ExpressionVisitor {
    private IQueryable _rootQuery;
    private IEnumerable`1<string> _methodsToExclude;
    public ExpressionRewriter(IQueryable rootQuery, IEnumerable`1<string> methodsToExclude);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
}
public enum NuGet.FileConflictResolution : Enum {
    public int value__;
    public static FileConflictResolution Overwrite;
    public static FileConflictResolution Ignore;
    public static FileConflictResolution OverwriteAll;
    public static FileConflictResolution IgnoreAll;
}
[ExtensionAttribute]
public static class NuGet.FileSystemExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, string> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, IPackageFile>, IEnumerable`1<string>> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`3<IGrouping`2<string, IPackageFile>, string, <>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string>> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string>, int> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string>, string> CS$<>9__CachedAnonymousMethodDelegatea;
    [ExtensionAttribute]
public static IEnumerable`1<string> GetFiles(IFileSystem fileSystem, string path, string filter);
    public static void AddFiles(IFileSystem fileSystem, IEnumerable`1<IPackageFile> files, string rootDir);
    [ExtensionAttribute]
public static void AddFiles(IFileSystem fileSystem, IEnumerable`1<IPackageFile> files, string rootDir, bool preserveFilePath);
    internal static void DeleteFiles(IFileSystem fileSystem, IEnumerable`1<IPackageFile> files, string rootDir);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
[ExtensionAttribute]
internal static IEnumerable`1<string> GetDirectoriesSafe(IFileSystem fileSystem, string path);
    [ExtensionAttribute]
internal static IEnumerable`1<string> GetFilesSafe(IFileSystem fileSystem, string path);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
[ExtensionAttribute]
internal static IEnumerable`1<string> GetFilesSafe(IFileSystem fileSystem, string path, string filter);
    [ExtensionAttribute]
internal static void DeleteDirectorySafe(IFileSystem fileSystem, string path, bool recursive);
    [ExtensionAttribute]
internal static void DeleteFileSafe(IFileSystem fileSystem, string path);
    public static bool ContentEqual(IFileSystem fileSystem, string path, Func`1<Stream> streamFactory);
    [ExtensionAttribute]
public static void DeleteFileSafe(IFileSystem fileSystem, string path, Func`1<Stream> streamFactory);
    [ExtensionAttribute]
public static void DeleteFileAndParentDirectoriesIfEmpty(IFileSystem fileSystem, string filePath);
    [ExtensionAttribute]
internal static void AddFileWithCheck(IFileSystem fileSystem, string path, Func`1<Stream> streamFactory);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
[ExtensionAttribute]
internal static void AddFileWithCheck(IFileSystem fileSystem, string path, Action`1<Stream> write);
    internal static IEnumerable`1<string> GetDirectories(string path);
    private static IEnumerable`1<int> IndexOfAll(string value, char ch);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
private static void DoSafeAction(Action action, ILogger logger);
    private static void Attempt(Action action, int retries, int delayBeforeRetry);
    [CompilerGeneratedAttribute]
private static string <DeleteFiles>b__1(IPackageFile p);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<string> <DeleteFiles>b__2(IGrouping`2<string, IPackageFile> grouping);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string> <DeleteFiles>b__3(IGrouping`2<string, IPackageFile> grouping, string directory);
    [CompilerGeneratedAttribute]
private static int <DeleteFiles>b__4(<>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private static string <DeleteFiles>b__5(<>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string> <>h__TransparentIdentifier0);
}
public class NuGet.FileTransformExtensions : object {
    [CompilerGeneratedAttribute]
private string <InstallExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UninstallExtension>k__BackingField;
    public string InstallExtension { get; private set; }
    public string UninstallExtension { get; private set; }
    public FileTransformExtensions(string installExtension, string uninstallExtension);
    [CompilerGeneratedAttribute]
public string get_InstallExtension();
    [CompilerGeneratedAttribute]
private void set_InstallExtension(string value);
    [CompilerGeneratedAttribute]
public string get_UninstallExtension();
    [CompilerGeneratedAttribute]
private void set_UninstallExtension(string value);
    public sealed virtual bool Equals(FileTransformExtensions other);
    public virtual int GetHashCode();
}
public class NuGet.FrameworkAssemblyReference : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkName> <SupportedFrameworks>k__BackingField;
    public string AssemblyName { get; private set; }
    public IEnumerable`1<FrameworkName> SupportedFrameworks { get; private set; }
    public FrameworkAssemblyReference(string assemblyName);
    public FrameworkAssemblyReference(string assemblyName, IEnumerable`1<FrameworkName> supportedFrameworks);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkName> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
private void set_SupportedFrameworks(IEnumerable`1<FrameworkName> value);
}
internal class NuGet.FrameworkNameEqualityComparer : object {
    public static FrameworkNameEqualityComparer Default;
    private static FrameworkNameEqualityComparer();
    public sealed virtual bool Equals(FrameworkName x, FrameworkName y);
    public sealed virtual int GetHashCode(FrameworkName x);
}
internal class NuGet.Frameworks.CompatibilityCacheKey : object {
    private NuGetFramework _target;
    private NuGetFramework _candidate;
    private int _hashCode;
    public NuGetFramework Target { get; }
    public NuGetFramework Candidate { get; }
    public CompatibilityCacheKey(NuGetFramework target, NuGetFramework candidate);
    public NuGetFramework get_Target();
    public NuGetFramework get_Candidate();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(CompatibilityCacheKey other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
internal class NuGet.Frameworks.CompatibilityListProvider : object {
    private IFrameworkNameProvider _nameProvider;
    private IFrameworkCompatibilityProvider _compatibilityProvider;
    private FrameworkReducer _reducer;
    private static IFrameworkCompatibilityListProvider _default;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, string> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, NuGetFramework>, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`3<NuGetFramework, NuGetFramework, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegatec;
    public static IFrameworkCompatibilityListProvider Default { get; }
    public CompatibilityListProvider(IFrameworkNameProvider nameProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public sealed virtual IEnumerable`1<NuGetFramework> GetFrameworksSupporting(NuGetFramework target);
    private IEnumerable`1<NuGetFramework> ReduceDownwards(IEnumerable`1<NuGetFramework> frameworks);
    public static IFrameworkCompatibilityListProvider get_Default();
    [CompilerGeneratedAttribute]
private static NuGetFramework <GetFrameworksSupporting>b__1(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <ReduceDownwards>b__5(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static string <ReduceDownwards>b__6(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static NuGetFramework <ReduceDownwards>b__7(IGrouping`2<string, NuGetFramework> g);
    [CompilerGeneratedAttribute]
private static NuGetFramework <ReduceDownwards>b__8(NuGetFramework a, NuGetFramework b);
}
internal class NuGet.Frameworks.CompatibilityMappingComparer : object {
    public sealed virtual bool Equals(OneWayCompatibilityMappingEntry x, OneWayCompatibilityMappingEntry y);
    public sealed virtual int GetHashCode(OneWayCompatibilityMappingEntry obj);
}
internal class NuGet.Frameworks.CompatibilityProvider : object {
    private IFrameworkNameProvider _mappings;
    private FrameworkExpander _expander;
    private static NuGetFrameworkFullComparer _fullComparer;
    private ConcurrentDictionary`2<CompatibilityCacheKey, bool> _cache;
    public CompatibilityProvider(IFrameworkNameProvider mappings);
    private static CompatibilityProvider();
    public sealed virtual bool IsCompatible(NuGetFramework target, NuGetFramework candidate);
    private Nullable`1<bool> IsCompatibleCore(NuGetFramework target, NuGetFramework candidate);
    private Nullable`1<bool> IsSpecialFrameworkCompatible(NuGetFramework target, NuGetFramework candidate);
    private bool IsPCLCompatible(NuGetFramework target, NuGetFramework candidate);
    private bool PCLInnerCompare(IEnumerable`1<NuGetFramework> targetFrameworks, IEnumerable`1<NuGetFramework> candidateFrameworks);
    private bool IsCompatibleWithTarget(NuGetFramework target, NuGetFramework candidate);
    private static bool IsCompatibleWithTargetCore(NuGetFramework target, NuGetFramework candidate);
    private static bool IsVersionCompatible(Version target, Version candidate);
    private IEnumerable`1<NuGetFramework> GetEquivalentFrameworksClosure(NuGetFramework framework);
}
internal class NuGet.Frameworks.CompatibilityTable : object {
    private IFrameworkNameProvider _mappings;
    private IFrameworkCompatibilityProvider _compat;
    private Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> _table;
    private FrameworkReducer _reducer;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    public CompatibilityTable(IEnumerable`1<NuGetFramework> frameworks);
    public CompatibilityTable(IEnumerable`1<NuGetFramework> frameworks, IFrameworkNameProvider mappings, IFrameworkCompatibilityProvider compat);
    public bool HasFramework(NuGetFramework framework);
    public IEnumerable`1<NuGetFramework> GetNearest(NuGetFramework framework);
    public bool TryGetCompatible(NuGetFramework framework, IEnumerable`1& compatible);
    private static Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> GetTable(IEnumerable`1<NuGetFramework> frameworks, IFrameworkNameProvider mappings, IFrameworkCompatibilityProvider compat);
    [CompilerGeneratedAttribute]
private static bool <GetTable>b__3(NuGetFramework f);
}
internal class NuGet.Frameworks.DefaultCompatibilityProvider : CompatibilityProvider {
    private static IFrameworkCompatibilityProvider _instance;
    public static IFrameworkCompatibilityProvider Instance { get; }
    public static IFrameworkCompatibilityProvider get_Instance();
}
internal class NuGet.Frameworks.DefaultFrameworkMappings : object {
    private static KeyValuePair`2[] _identifierSynonyms;
    private static KeyValuePair`2[] _identifierShortNames;
    private static FrameworkSpecificMapping[] _profileShortNames;
    private static KeyValuePair`2[] _equivalentFrameworks;
    private static FrameworkSpecificMapping[] _equivalentProfiles;
    private static KeyValuePair`2[] _subSetFrameworks;
    private static OneWayCompatibilityMappingEntry[] _compatibilityMappings;
    private static String[] _nonPackageBasedFrameworkPrecedence;
    private static String[] _packageBasedFrameworkPrecedence;
    private static String[] _equivalentFrameworkPrecedence;
    private static KeyValuePair`2[] _shortNameReplacements;
    private static KeyValuePair`2[] _fullNameReplacements;
    private static IFrameworkMappings _instance;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<OneWayCompatibilityMappingEntry>, IEnumerable`1<OneWayCompatibilityMappingEntry>> CS$<>9__CachedAnonymousMethodDelegate1;
    public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierSynonyms { get; }
    public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierShortNames { get; }
    public IEnumerable`1<FrameworkSpecificMapping> ProfileShortNames { get; }
    public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> EquivalentFrameworks { get; }
    public IEnumerable`1<FrameworkSpecificMapping> EquivalentProfiles { get; }
    public IEnumerable`1<KeyValuePair`2<string, string>> SubSetFrameworks { get; }
    public IEnumerable`1<OneWayCompatibilityMappingEntry> CompatibilityMappings { get; }
    public IEnumerable`1<string> NonPackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> PackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> EquivalentFrameworkPrecedence { get; }
    public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> ShortNameReplacements { get; }
    public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> FullNameReplacements { get; }
    public static IFrameworkMappings Instance { get; }
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierSynonyms();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierShortNames();
    public sealed virtual IEnumerable`1<FrameworkSpecificMapping> get_ProfileShortNames();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_EquivalentFrameworks();
    public sealed virtual IEnumerable`1<FrameworkSpecificMapping> get_EquivalentProfiles();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_SubSetFrameworks();
    public sealed virtual IEnumerable`1<OneWayCompatibilityMappingEntry> get_CompatibilityMappings();
    private static OneWayCompatibilityMappingEntry CreateGenerationMapping(NuGetFramework framework, NuGetFramework netPlatform);
    private static OneWayCompatibilityMappingEntry CreateStandardMapping(NuGetFramework framework, NuGetFramework netPlatform);
    private static IEnumerable`1<OneWayCompatibilityMappingEntry> CreateGenerationAndStandardMapping(NuGetFramework framework, NuGetFramework netPlatform, NuGetFramework netStandard);
    private static IEnumerable`1<OneWayCompatibilityMappingEntry> CreateGenerationAndStandardMappingForAllVersions(string framework, NuGetFramework netPlatform, NuGetFramework netStandard);
    public sealed virtual IEnumerable`1<string> get_NonPackageBasedFrameworkPrecedence();
    public sealed virtual IEnumerable`1<string> get_PackageBasedFrameworkPrecedence();
    public sealed virtual IEnumerable`1<string> get_EquivalentFrameworkPrecedence();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_ShortNameReplacements();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_FullNameReplacements();
    public static IFrameworkMappings get_Instance();
    [CompilerGeneratedAttribute]
private static IEnumerable`1<OneWayCompatibilityMappingEntry> <get_CompatibilityMappings>b__0(IEnumerable`1<OneWayCompatibilityMappingEntry> mappings);
}
internal class NuGet.Frameworks.DefaultFrameworkNameProvider : FrameworkNameProvider {
    private static IFrameworkNameProvider _instance;
    public static IFrameworkNameProvider Instance { get; }
    public static IFrameworkNameProvider get_Instance();
}
internal class NuGet.Frameworks.DefaultPortableFrameworkMappings : object {
    private KeyValuePair`2[] _profileFrameworks;
    private static Int32[] _profilesWithOptionalFrameworks;
    private List`1<KeyValuePair`2<int, NuGetFramework[]>> _profileOptionalFrameworks;
    private IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> _compatibilityMappings;
    private static IPortableFrameworkMappings _instance;
    public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileFrameworks { get; }
    public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileOptionalFrameworks { get; }
    public IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> CompatibilityMappings { get; }
    public static IPortableFrameworkMappings Instance { get; }
    private static DefaultPortableFrameworkMappings();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileFrameworks();
    private KeyValuePair`2<int, NuGetFramework[]> CreateProfileFrameworks(int profile, NuGetFramework[] frameworks);
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileOptionalFrameworks();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> get_CompatibilityMappings();
    private static KeyValuePair`2<int, FrameworkRange> CreateStandardMapping(int profileNumber, NuGetFramework netStandard);
    public static IPortableFrameworkMappings get_Instance();
}
internal class NuGet.Frameworks.FallbackFramework : NuGetFramework {
    private IList`1<NuGetFramework> _fallback;
    private Nullable`1<int> _hashCode;
    public IList`1<NuGetFramework> Fallback { get; }
    public FallbackFramework(NuGetFramework framework, IList`1<NuGetFramework> fallbackFrameworks);
    public IList`1<NuGetFramework> get_Fallback();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(FallbackFramework other);
}
internal static class NuGet.Frameworks.FrameworkConstants : object {
    public static Version EmptyVersion;
    public static Version MaxVersion;
    public static Version Version5;
    public static Version Version10;
    public static FrameworkRange DotNetAll;
    private static FrameworkConstants();
}
internal class NuGet.Frameworks.FrameworkException : Exception {
    public FrameworkException(string message);
}
internal class NuGet.Frameworks.FrameworkExpander : object {
    private IFrameworkNameProvider _mappings;
    public FrameworkExpander(IFrameworkNameProvider mappings);
    public IEnumerable`1<NuGetFramework> Expand(NuGetFramework framework);
    private IEnumerable`1<NuGetFramework> ExpandInternal(NuGetFramework framework);
}
internal static class NuGet.Frameworks.FrameworkNameHelpers : object {
    public static string GetPortableProfileNumberString(int profileNumber);
    public static string GetFolderName(string identifierShortName, string versionString, string profileShortName);
    public static string GetVersionString(Version version);
    public static Version GetVersion(string versionString);
}
internal class NuGet.Frameworks.FrameworkNameProvider : object {
    private Dictionary`2<string, string> _identifierSynonyms;
    private Dictionary`2<string, string> _identifierToShortName;
    private Dictionary`2<string, string> _profilesToShortName;
    private Dictionary`2<string, string> _identifierShortToLong;
    private Dictionary`2<string, string> _profileShortToLong;
    private Dictionary`2<int, HashSet`1<NuGetFramework>> _portableFrameworks;
    private Dictionary`2<int, HashSet`1<NuGetFramework>> _portableOptionalFrameworks;
    private Dictionary`2<int, HashSet`1<FrameworkRange>> _portableCompatibilityMappings;
    private Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> _equivalentFrameworks;
    private Dictionary`2<string, Dictionary`2<string, HashSet`1<string>>> _equivalentProfiles;
    private Dictionary`2<string, HashSet`1<OneWayCompatibilityMappingEntry>> _compatibilityMappings;
    private Dictionary`2<string, HashSet`1<string>> _subSetFrameworks;
    private Dictionary`2<string, int> _nonPackageBasedFrameworkPrecedence;
    private Dictionary`2<string, int> _packageBasedFrameworkPrecedence;
    private Dictionary`2<string, int> _equivalentFrameworkPrecedence;
    private Dictionary`2<NuGetFramework, NuGetFramework> _shortNameRewrites;
    private Dictionary`2<NuGetFramework, NuGetFramework> _fullNameRewrites;
    private List`1<NuGetFramework> _netStandardVersions;
    private List`1<NuGetFramework> _compatibleCandidates;
    private static HashSet`1<string> _singleDigitVersionFrameworks;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<int, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<NuGetFramework>, HashSet`1<NuGetFramework>> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<OneWayCompatibilityMappingEntry, FrameworkRange> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<HashSet`1<NuGetFramework>, IEnumerable`1<NuGetFramework>> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, HashSet`1<OneWayCompatibilityMappingEntry>>, IEnumerable`1<OneWayCompatibilityMappingEntry>> CS$<>9__CachedAnonymousMethodDelegate2a;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, HashSet`1<string>>, IEnumerable`1<<>f__AnonymousType0`2<string, string>>> CS$<>9__CachedAnonymousMethodDelegate2b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType0`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate2c;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType0`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate2d;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate2e;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, string>, HashSet`1<string>> CS$<>9__CachedAnonymousMethodDelegate2f;
    public FrameworkNameProvider(IEnumerable`1<IFrameworkMappings> mappings, IEnumerable`1<IPortableFrameworkMappings> portableMappings);
    private static FrameworkNameProvider();
    private static bool TryConvertOrNormalize(string key, IDictionary`2<string, string> mappings, IDictionary`2<string, string> reverse, String& value);
    public sealed virtual bool TryGetIdentifier(string framework, String& identifier);
    public sealed virtual bool TryGetProfile(string frameworkIdentifier, string profileShortName, String& profile);
    public sealed virtual bool TryGetShortIdentifier(string identifier, String& identifierShortName);
    public sealed virtual bool TryGetShortProfile(string frameworkIdentifier, string profile, String& profileShortName);
    public sealed virtual bool TryGetVersion(string versionString, Version& version);
    public sealed virtual string GetVersionString(string framework, Version version);
    public sealed virtual bool TryGetPortableProfile(IEnumerable`1<NuGetFramework> supportedFrameworks, Int32& profileNumber);
    private HashSet`1<NuGetFramework> RemoveDuplicateFramework(IEnumerable`1<NuGetFramework> supportedFrameworks);
    private HashSet`1<NuGetFramework> GetAllEquivalentFrameworks(NuGetFramework framework);
    private IEnumerable`1<IEnumerable`1<NuGetFramework>> GetEquivalentPermutations(IEnumerable`1<NuGetFramework> frameworks);
    private IEnumerable`1<NuGetFramework> GetOptionalFrameworks(int profile);
    public sealed virtual bool TryGetPortableFrameworks(int profile, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableFrameworks(int profile, bool includeOptional, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableFrameworks(string shortPortableProfiles, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableCompatibilityMappings(int profile, IEnumerable`1& supportedFrameworkRanges);
    public sealed virtual bool TryGetPortableProfileNumber(string profile, Int32& profileNumber);
    public sealed virtual bool TryGetPortableFrameworks(string profile, bool includeOptional, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetEquivalentFrameworks(NuGetFramework framework, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetEquivalentFrameworks(FrameworkRange range, IEnumerable`1& frameworks);
    private void InitMappings(IEnumerable`1<IFrameworkMappings> mappings);
    private void InitPortableMappings(IEnumerable`1<IPortableFrameworkMappings> portableMappings);
    private void InitNetStandard();
    private void AddShortNameRewriteMappings(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddFullNameRewriteMappings(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddCompatibilityMappings(IEnumerable`1<OneWayCompatibilityMappingEntry> mappings);
    private void AddSubSetFrameworks(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddEquivalentProfiles(IEnumerable`1<FrameworkSpecificMapping> mappings);
    private void AddEquivalentFrameworks(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddFrameworkSynoyms(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddIdentifierShortNames(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddProfileShortNames(IEnumerable`1<FrameworkSpecificMapping> mappings);
    private void AddPortableProfileMappings(IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> mappings);
    private void AddPortableOptionalFrameworks(IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> mappings);
    private void AddPortableCompatibilityMappings(IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> mappings);
    public void AddFrameworkPrecedenceMappings(IDictionary`2<string, int> destination, IEnumerable`1<string> mappings);
    public sealed virtual bool TryGetCompatibilityMappings(NuGetFramework framework, IEnumerable`1& supportedFrameworkRanges);
    public sealed virtual bool TryGetSubSetFrameworks(string frameworkIdentifier, IEnumerable`1& subSetFrameworks);
    public sealed virtual int CompareFrameworks(NuGetFramework x, NuGetFramework y);
    public sealed virtual int CompareEquivalentFrameworks(NuGetFramework x, NuGetFramework y);
    private static int CompareUsingPrecedence(NuGetFramework x, NuGetFramework y, Dictionary`2<string, int> precedence);
    public sealed virtual NuGetFramework GetShortNameReplacement(NuGetFramework framework);
    public sealed virtual NuGetFramework GetFullNameReplacement(NuGetFramework framework);
    public sealed virtual IEnumerable`1<NuGetFramework> GetNetStandardVersions();
    public sealed virtual IEnumerable`1<NuGetFramework> GetCompatibleCandidates();
    private void AddNetStandardVersions();
    private void AddCompatibleCandidates();
    [CompilerGeneratedAttribute]
private static string <TryConvertOrNormalize>b__1(KeyValuePair`2<string, string> s);
    [CompilerGeneratedAttribute]
private static bool <GetVersionString>b__6(int x);
    [CompilerGeneratedAttribute]
private static HashSet`1<NuGetFramework> <TryGetPortableProfile>b__8(IEnumerable`1<NuGetFramework> p);
    [CompilerGeneratedAttribute]
private static FrameworkRange <TryGetCompatibilityMappings>b__1c(OneWayCompatibilityMappingEntry m);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<NuGetFramework> <AddCompatibleCandidates>b__21(HashSet`1<NuGetFramework> x);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<OneWayCompatibilityMappingEntry> <AddCompatibleCandidates>b__22(KeyValuePair`2<string, HashSet`1<OneWayCompatibilityMappingEntry>> p);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<<>f__AnonymousType0`2<string, string>> <AddCompatibleCandidates>b__23(KeyValuePair`2<string, HashSet`1<string>> p);
    [CompilerGeneratedAttribute]
private static string <AddCompatibleCandidates>b__25(<>f__AnonymousType0`2<string, string> p);
    [CompilerGeneratedAttribute]
private static string <AddCompatibleCandidates>b__26(<>f__AnonymousType0`2<string, string> p);
    [CompilerGeneratedAttribute]
private static string <AddCompatibleCandidates>b__27(IGrouping`2<string, string> g);
    [CompilerGeneratedAttribute]
private static HashSet`1<string> <AddCompatibleCandidates>b__28(IGrouping`2<string, string> g);
}
internal class NuGet.Frameworks.FrameworkPrecedenceSorter : object {
    private IFrameworkNameProvider _mappings;
    private bool _allEquivalent;
    public FrameworkPrecedenceSorter(IFrameworkNameProvider mappings, bool allEquivalent);
    public sealed virtual int Compare(NuGetFramework x, NuGetFramework y);
}
internal class NuGet.Frameworks.FrameworkRange : object {
    private NuGetFramework _minFramework;
    private NuGetFramework _maxFramework;
    private bool _includeMin;
    private bool _includeMax;
    public NuGetFramework Min { get; }
    public NuGetFramework Max { get; }
    public bool IncludeMin { get; }
    public bool IncludeMax { get; }
    public string FrameworkIdentifier { get; }
    public FrameworkRange(NuGetFramework min, NuGetFramework max);
    public FrameworkRange(NuGetFramework min, NuGetFramework max, bool includeMin, bool includeMax);
    public NuGetFramework get_Min();
    public NuGetFramework get_Max();
    public bool get_IncludeMin();
    public bool get_IncludeMax();
    public string get_FrameworkIdentifier();
    public bool Satisfies(NuGetFramework framework);
    private static bool SameExceptForVersion(NuGetFramework x, NuGetFramework y);
    public virtual string ToString();
    public sealed virtual bool Equals(FrameworkRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.Frameworks.FrameworkRangeComparer : object {
    public sealed virtual bool Equals(FrameworkRange x, FrameworkRange y);
    public sealed virtual int GetHashCode(FrameworkRange obj);
}
internal class NuGet.Frameworks.FrameworkReducer : object {
    private IFrameworkNameProvider _mappings;
    private IFrameworkCompatibilityProvider _compat;
    private NuGetFrameworkFullComparer _fullComparer;
    private NuGetFrameworkNameComparer _fwNameComparer;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate24;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate25;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegate26;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegate27;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, int> CS$<>9__CachedAnonymousMethodDelegate28;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegate2d;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegate2e;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate3c;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate3d;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate40;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, string> CS$<>9__CachedAnonymousMethodDelegate43;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, string> CS$<>9__CachedAnonymousMethodDelegate44;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<NuGetFramework>, IEnumerable`1<NuGetFramework>> CS$<>9__CachedAnonymousMethodDelegate48;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<NuGetFramework, IEnumerable`1<NuGetFramework>>, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegate49;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<NuGetFramework>, IEnumerable`1<NuGetFramework>> CS$<>9__CachedAnonymousMethodDelegate50;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<NuGetFramework, int>, int> CS$<>9__CachedAnonymousMethodDelegate51;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<int, KeyValuePair`2<NuGetFramework, int>>, int> CS$<>9__CachedAnonymousMethodDelegate52;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<NuGetFramework, int>, NuGetFramework> CS$<>9__CachedAnonymousMethodDelegate53;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, string> CS$<>9__CachedAnonymousMethodDelegate5b;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate5c;
    [CompilerGeneratedAttribute]
private static Func`2<NuGetFramework, bool> CS$<>9__CachedAnonymousMethodDelegate5d;
    public FrameworkReducer(IFrameworkNameProvider mappings, IFrameworkCompatibilityProvider compat);
    public NuGetFramework GetNearest(NuGetFramework framework, IEnumerable`1<NuGetFramework> possibleFrameworks);
    private NuGetFramework GetNearestInternal(NuGetFramework framework, IEnumerable`1<NuGetFramework> possibleFrameworks);
    public IEnumerable`1<NuGetFramework> ReduceEquivalent(IEnumerable`1<NuGetFramework> frameworks);
    public IEnumerable`1<NuGetFramework> ReduceUpwards(IEnumerable`1<NuGetFramework> frameworks);
    public IEnumerable`1<NuGetFramework> ReduceDownwards(IEnumerable`1<NuGetFramework> frameworks);
    private IEnumerable`1<NuGetFramework> ReduceCore(IEnumerable`1<NuGetFramework> frameworks, Func`3<NuGetFramework, NuGetFramework, bool> isCompat);
    private IEnumerable`1<NuGetFramework> GetNearestNonPCLtoPCL(NuGetFramework framework, IEnumerable`1<NuGetFramework> reduced);
    private IEnumerable`1<NuGetFramework> GetNearestPCLtoPCL(NuGetFramework framework, IEnumerable`1<NuGetFramework> reduced);
    private Dictionary`2<NuGetFramework, IEnumerable`1<NuGetFramework>> ExplodePortableFrameworks(IEnumerable`1<NuGetFramework> pcls, bool includeOptional);
    private IEnumerable`1<NuGetFramework> ExplodePortableFramework(NuGetFramework pcl, bool includeOptional);
    private NuGetFramework GetBestPCL(IEnumerable`1<NuGetFramework> reduced);
    private bool IsBetterPCL(NuGetFramework current, NuGetFramework considering);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__0(NuGetFramework e);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__1(NuGetFramework e);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__6(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__7(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__8(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__9(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__a(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__b(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__c(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__d(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__f(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__10(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <GetNearestInternal>b__11(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static NuGetFramework <GetNearestInternal>b__12(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static NuGetFramework <GetNearestInternal>b__13(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static int <GetNearestInternal>b__14(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static NuGetFramework <ReduceEquivalent>b__2b(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static NuGetFramework <ReduceEquivalent>b__2c(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <ReduceUpwards>b__39(NuGetFramework e);
    [CompilerGeneratedAttribute]
private static bool <ReduceUpwards>b__3a(NuGetFramework e);
    [CompilerGeneratedAttribute]
private bool <ReduceUpwards>b__3b(NuGetFramework x, NuGetFramework y);
    [CompilerGeneratedAttribute]
private static bool <ReduceDownwards>b__3e(NuGetFramework e);
    [CompilerGeneratedAttribute]
private bool <ReduceDownwards>b__3f(NuGetFramework x, NuGetFramework y);
    [CompilerGeneratedAttribute]
private static string <ReduceCore>b__41(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static string <ReduceCore>b__42(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<NuGetFramework> <GetNearestNonPCLtoPCL>b__45(IEnumerable`1<NuGetFramework> f);
    [CompilerGeneratedAttribute]
private static NuGetFramework <GetNearestNonPCLtoPCL>b__47(KeyValuePair`2<NuGetFramework, IEnumerable`1<NuGetFramework>> pair);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<NuGetFramework> <GetNearestPCLtoPCL>b__4c(IEnumerable`1<NuGetFramework> f);
    [CompilerGeneratedAttribute]
private static int <GetNearestPCLtoPCL>b__4d(KeyValuePair`2<NuGetFramework, int> pair);
    [CompilerGeneratedAttribute]
private static int <GetNearestPCLtoPCL>b__4e(IGrouping`2<int, KeyValuePair`2<NuGetFramework, int>> g);
    [CompilerGeneratedAttribute]
private static NuGetFramework <GetNearestPCLtoPCL>b__4f(KeyValuePair`2<NuGetFramework, int> e);
    [CompilerGeneratedAttribute]
private static string <IsBetterPCL>b__54(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <IsBetterPCL>b__59(NuGetFramework f);
    [CompilerGeneratedAttribute]
private static bool <IsBetterPCL>b__5a(NuGetFramework f);
}
internal class NuGet.Frameworks.FrameworkRuntimePair : object {
    private NuGetFramework _framework;
    private string _runtimeIdentifier;
    private string _name;
    public NuGetFramework Framework { get; }
    public string RuntimeIdentifier { get; }
    public string Name { get; }
    public FrameworkRuntimePair(NuGetFramework framework, string runtimeIdentifier);
    public NuGetFramework get_Framework();
    public string get_RuntimeIdentifier();
    public string get_Name();
    public sealed virtual bool Equals(FrameworkRuntimePair other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(FrameworkRuntimePair other);
    public static string GetName(NuGetFramework framework, string runtimeIdentifier);
}
internal class NuGet.Frameworks.FrameworkSpecificMapping : object {
    private string _frameworkIdentifier;
    private KeyValuePair`2<string, string> _mapping;
    public string FrameworkIdentifier { get; }
    public KeyValuePair`2<string, string> Mapping { get; }
    public FrameworkSpecificMapping(string frameworkIdentifier, string key, string value);
    public FrameworkSpecificMapping(string frameworkIdentifier, KeyValuePair`2<string, string> mapping);
    public string get_FrameworkIdentifier();
    public KeyValuePair`2<string, string> get_Mapping();
}
internal class NuGet.Frameworks.HashCodeCombiner : object {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    internal void AddInt32(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(object o);
    internal void AddStringIgnoreCase(string s);
    internal static int GetHashCode(Object[] objects);
}
internal interface NuGet.Frameworks.IFrameworkCompatibilityListProvider {
    public abstract virtual IEnumerable`1<NuGetFramework> GetFrameworksSupporting(NuGetFramework target);
}
internal interface NuGet.Frameworks.IFrameworkCompatibilityProvider {
    public abstract virtual bool IsCompatible(NuGetFramework framework, NuGetFramework other);
}
internal interface NuGet.Frameworks.IFrameworkMappings {
    public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierSynonyms { get; }
    public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierShortNames { get; }
    public IEnumerable`1<FrameworkSpecificMapping> ProfileShortNames { get; }
    public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> EquivalentFrameworks { get; }
    public IEnumerable`1<FrameworkSpecificMapping> EquivalentProfiles { get; }
    public IEnumerable`1<KeyValuePair`2<string, string>> SubSetFrameworks { get; }
    public IEnumerable`1<OneWayCompatibilityMappingEntry> CompatibilityMappings { get; }
    public IEnumerable`1<string> NonPackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> PackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> EquivalentFrameworkPrecedence { get; }
    public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> ShortNameReplacements { get; }
    public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> FullNameReplacements { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierSynonyms();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierShortNames();
    public abstract virtual IEnumerable`1<FrameworkSpecificMapping> get_ProfileShortNames();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_EquivalentFrameworks();
    public abstract virtual IEnumerable`1<FrameworkSpecificMapping> get_EquivalentProfiles();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_SubSetFrameworks();
    public abstract virtual IEnumerable`1<OneWayCompatibilityMappingEntry> get_CompatibilityMappings();
    public abstract virtual IEnumerable`1<string> get_NonPackageBasedFrameworkPrecedence();
    public abstract virtual IEnumerable`1<string> get_PackageBasedFrameworkPrecedence();
    public abstract virtual IEnumerable`1<string> get_EquivalentFrameworkPrecedence();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_ShortNameReplacements();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_FullNameReplacements();
}
internal interface NuGet.Frameworks.IFrameworkNameProvider {
    public abstract virtual bool TryGetIdentifier(string identifierShortName, String& identifier);
    public abstract virtual bool TryGetShortIdentifier(string identifier, String& identifierShortName);
    public abstract virtual bool TryGetProfile(string frameworkIdentifier, string profileShortName, String& profile);
    public abstract virtual bool TryGetShortProfile(string frameworkIdentifier, string profile, String& profileShortName);
    public abstract virtual bool TryGetVersion(string versionString, Version& version);
    public abstract virtual string GetVersionString(string framework, Version version);
    public abstract virtual bool TryGetPortableProfileNumber(string profile, Int32& profileNumber);
    public abstract virtual bool TryGetPortableProfile(IEnumerable`1<NuGetFramework> supportedFrameworks, Int32& profileNumber);
    public abstract virtual bool TryGetPortableFrameworks(int profile, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(int profile, bool includeOptional, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(string profile, bool includeOptional, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(string shortPortableProfiles, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableCompatibilityMappings(int profile, IEnumerable`1& supportedFrameworkRanges);
    public abstract virtual bool TryGetEquivalentFrameworks(NuGetFramework framework, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetEquivalentFrameworks(FrameworkRange range, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetCompatibilityMappings(NuGetFramework framework, IEnumerable`1& supportedFrameworkRanges);
    public abstract virtual bool TryGetSubSetFrameworks(string frameworkIdentifier, IEnumerable`1& subSetFrameworkIdentifiers);
    public abstract virtual int CompareFrameworks(NuGetFramework x, NuGetFramework y);
    public abstract virtual int CompareEquivalentFrameworks(NuGetFramework x, NuGetFramework y);
    public abstract virtual NuGetFramework GetShortNameReplacement(NuGetFramework framework);
    public abstract virtual NuGetFramework GetFullNameReplacement(NuGetFramework framework);
    public abstract virtual IEnumerable`1<NuGetFramework> GetNetStandardVersions();
    public abstract virtual IEnumerable`1<NuGetFramework> GetCompatibleCandidates();
}
internal interface NuGet.Frameworks.IFrameworkSpecific {
    public NuGetFramework TargetFramework { get; }
    public abstract virtual NuGetFramework get_TargetFramework();
}
internal interface NuGet.Frameworks.IFrameworkTargetable {
    public IEnumerable`1<NuGetFramework> SupportedFrameworks { get; }
    public abstract virtual IEnumerable`1<NuGetFramework> get_SupportedFrameworks();
}
internal interface NuGet.Frameworks.IPortableFrameworkMappings {
    public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileFrameworks { get; }
    public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileOptionalFrameworks { get; }
    public IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> CompatibilityMappings { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileFrameworks();
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileOptionalFrameworks();
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> get_CompatibilityMappings();
}
internal class NuGet.Frameworks.NuGetFramework : object {
    private static string _portable;
    private string _frameworkIdentifier;
    private Version _frameworkVersion;
    private string _frameworkProfile;
    private Nullable`1<int> _hashCode;
    public static IEqualityComparer`1<NuGetFramework> Comparer;
    public static IEqualityComparer`1<NuGetFramework> FrameworkNameComparer;
    private static SortedSet`1<string> _packagesBased;
    public static NuGetFramework UnsupportedFramework;
    public static NuGetFramework AgnosticFramework;
    public static NuGetFramework AnyFramework;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegatec;
    public string Framework { get; }
    public Version Version { get; }
    public bool HasProfile { get; }
    public string Profile { get; }
    public string DotNetFrameworkName { get; }
    public bool IsPCL { get; }
    public bool IsPackageBased { get; }
    public bool AllFrameworkVersions { get; }
    public bool IsUnsupported { get; }
    public bool IsAgnostic { get; }
    public bool IsAny { get; }
    public bool IsSpecificFramework { get; }
    public NuGetFramework(NuGetFramework framework);
    public NuGetFramework(string framework);
    public NuGetFramework(string framework, Version version);
    public NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string frameworkProfile);
    private static NuGetFramework();
    public string get_Framework();
    public Version get_Version();
    public bool get_HasProfile();
    public string get_Profile();
    public string get_DotNetFrameworkName();
    public string GetDotNetFrameworkName(IFrameworkNameProvider mappings);
    public string GetShortFolderName();
    public virtual string GetShortFolderName(IFrameworkNameProvider mappings);
    private static string GetDisplayVersion(Version version);
    private static string GetLettersAndDigitsOnly(string s);
    public bool get_IsPCL();
    public bool get_IsPackageBased();
    public bool get_AllFrameworkVersions();
    public bool get_IsUnsupported();
    public bool get_IsAgnostic();
    public bool get_IsAny();
    public bool get_IsSpecificFramework();
    public virtual string ToString();
    public sealed virtual bool Equals(NuGetFramework other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private static Version NormalizeVersion(Version version);
    public static NuGetFramework Parse(string folderName);
    public static NuGetFramework Parse(string folderName, IFrameworkNameProvider mappings);
    public static NuGetFramework ParseFrameworkName(string frameworkName, IFrameworkNameProvider mappings);
    public static NuGetFramework ParseFolder(string folderName);
    public static NuGetFramework ParseFolder(string folderName, IFrameworkNameProvider mappings);
    private static bool TryParseDeprecatedFramework(string s, NuGetFramework& framework);
    private static Tuple`3<string, string, string> RawParse(string s);
    private static bool IsLetterOrDot(char c);
    private static bool IsDigitOrDot(char c);
    private static bool IsValidProfileChar(char c);
    private static bool TryParseSpecialFramework(string frameworkString, NuGetFramework& framework);
    private static bool TryParseCommonFramework(string frameworkString, NuGetFramework& framework);
    private static string SingleOrDefaultSafe(IEnumerable`1<string> items);
    [CompilerGeneratedAttribute]
private static string <GetShortFolderName>b__2(string e);
    [CompilerGeneratedAttribute]
private static string <ParseFrameworkName>b__7(string s);
    [CompilerGeneratedAttribute]
private static bool <ParseFrameworkName>b__8(string s);
    [CompilerGeneratedAttribute]
private static bool <ParseFrameworkName>b__9(string s);
}
[ExtensionAttribute]
internal static class NuGet.Frameworks.NuGetFrameworkExtensions : object {
    [ExtensionAttribute]
public static bool IsDesktop(NuGetFramework framework);
    [ExtensionAttribute]
public static T GetNearest(IEnumerable`1<T> items, NuGetFramework projectFramework);
    [CompilerGeneratedAttribute]
private static NuGetFramework <GetNearest>b__0(T e);
}
internal class NuGet.Frameworks.NuGetFrameworkFullComparer : object {
    public sealed virtual bool Equals(NuGetFramework x, NuGetFramework y);
    public sealed virtual int GetHashCode(NuGetFramework obj);
}
internal class NuGet.Frameworks.NuGetFrameworkNameComparer : object {
    public sealed virtual bool Equals(NuGetFramework x, NuGetFramework y);
    public sealed virtual int GetHashCode(NuGetFramework obj);
}
internal class NuGet.Frameworks.NuGetFrameworkSorter : object {
    public sealed virtual int Compare(NuGetFramework x, NuGetFramework y);
}
internal static class NuGet.Frameworks.NuGetFrameworkUtility : object {
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, Func`2<T, NuGetFramework> selector);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, IFrameworkNameProvider frameworkMappings, IFrameworkCompatibilityProvider compatibilityProvider, Func`2<T, NuGetFramework> selector);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, IFrameworkNameProvider frameworkMappings, IFrameworkCompatibilityProvider compatibilityProvider);
    public static bool IsCompatibleWithFallbackCheck(NuGetFramework projectFramework, NuGetFramework candidate);
    public static bool IsNetCore50AndUp(NuGetFramework framework);
    [CompilerGeneratedAttribute]
private static NuGetFramework <GetNearest>b__6(T item);
}
internal class NuGet.Frameworks.OneWayCompatibilityMappingEntry : object {
    private FrameworkRange _targetFramework;
    private FrameworkRange _supportedFramework;
    public FrameworkRange TargetFrameworkRange { get; }
    public FrameworkRange SupportedFrameworkRange { get; }
    public static CompatibilityMappingComparer Comparer { get; }
    public OneWayCompatibilityMappingEntry(FrameworkRange targetFramework, FrameworkRange supportedFramework);
    public FrameworkRange get_TargetFrameworkRange();
    public FrameworkRange get_SupportedFrameworkRange();
    public static CompatibilityMappingComparer get_Comparer();
    public sealed virtual bool Equals(OneWayCompatibilityMappingEntry other);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal class NuGet.Frameworks.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FrameworkMismatch { get; }
    internal static string InvalidFrameworkIdentifier { get; }
    internal static string InvalidFrameworkVersion { get; }
    internal static string InvalidPortableFrameworks { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FrameworkMismatch();
    internal static string get_InvalidFrameworkIdentifier();
    internal static string get_InvalidFrameworkVersion();
    internal static string get_InvalidPortableFrameworks();
}
internal class NuGet.HashCodeCombiner : object {
    private long _combinedHash64;
    public int CombinedHash { get; }
    public int get_CombinedHash();
    public void AddInt32(int i);
    public void AddObject(object o);
}
public class NuGet.HttpClient : object {
    private EventHandler`1<ProgressEventArgs> ProgressAvailable;
    private EventHandler`1<WebRequestEventArgs> SendingRequest;
    private static ICredentialProvider _credentialProvider;
    private Uri _uri;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AcceptCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableBuffering>k__BackingField;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ProgressEventArgs> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static EventHandler`1<WebRequestEventArgs> CS$<>9__CachedAnonymousMethodDelegate3;
    public string UserAgent { get; public set; }
    public Uri Uri { get; public set; }
    public Uri OriginalUri { get; }
    public string Method { get; public set; }
    public string ContentType { get; public set; }
    public bool AcceptCompression { get; public set; }
    public bool DisableBuffering { get; public set; }
    public static ICredentialProvider DefaultCredentialProvider { get; public set; }
    public HttpClient(Uri uri);
    public sealed virtual void add_ProgressAvailable(EventHandler`1<ProgressEventArgs> value);
    public sealed virtual void remove_ProgressAvailable(EventHandler`1<ProgressEventArgs> value);
    public sealed virtual void add_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
    public sealed virtual void remove_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserAgent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UserAgent(string value);
    public virtual Uri get_Uri();
    public virtual void set_Uri(Uri value);
    public virtual Uri get_OriginalUri();
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AcceptCompression();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AcceptCompression(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableBuffering();
    [CompilerGeneratedAttribute]
public void set_DisableBuffering(bool value);
    public static ICredentialProvider get_DefaultCredentialProvider();
    public static void set_DefaultCredentialProvider(ICredentialProvider value);
    public virtual WebResponse GetResponse();
    public sealed virtual void InitializeRequest(WebRequest request);
    private void TrySetCredentialsAndProxy(WebRequest request);
    private void InitializeRequestProperties(WebRequest request);
    public sealed virtual void DownloadData(Stream targetStream);
    private void OnProgressAvailable(int percentage);
    private void RaiseSendingRequest(WebRequest webRequest);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(object param0, ProgressEventArgs param1);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__1(object param0, WebRequestEventArgs param1);
    [CompilerGeneratedAttribute]
private WebRequest <GetResponse>b__4();
}
public static class NuGet.HttpUtility : object {
    private static string UserAgentTemplate;
    private static string UserAgentWithHostTemplate;
    private static string ProjectGuidsHeader;
    public static string CreateUserAgentString(string client);
    public static string CreateUserAgentString(string client, string host);
    public static void SetUserAgent(WebRequest request, string userAgent, string projectGuids);
}
public interface NuGet.IBatchProcessor`1 {
    public abstract virtual void BeginProcessing(IEnumerable`1<T> batch, PackageAction action);
    public abstract virtual void EndProcessing();
}
public interface NuGet.ICloneableRepository {
    public abstract virtual IPackageRepository Clone();
}
public interface NuGet.ICredentialCache {
    public abstract virtual void Add(Uri uri, ICredentials credentials);
    public abstract virtual ICredentials GetCredentials(Uri uri);
}
public interface NuGet.ICredentialProvider {
    public abstract virtual ICredentials GetCredentials(Uri uri, IWebProxy proxy, CredentialType credentialType, bool retrying);
}
public interface NuGet.ICultureAwareRepository {
    public CultureInfo Culture { get; }
    public abstract virtual CultureInfo get_Culture();
}
[CLSCompliantAttribute("False")]
public interface NuGet.IDataServiceContext {
    public Uri BaseUri { get; }
    public bool IgnoreMissingProperties { get; public set; }
    public abstract virtual Uri get_BaseUri();
    public abstract virtual bool get_IgnoreMissingProperties();
    public abstract virtual void set_IgnoreMissingProperties(bool value);
    public abstract virtual bool SupportsServiceMethod(string methodName);
    public abstract virtual bool SupportsProperty(string propertyName);
    public abstract virtual void add_SendingRequest(EventHandler`1<SendingRequestEventArgs> value);
    public abstract virtual void remove_SendingRequest(EventHandler`1<SendingRequestEventArgs> value);
    public abstract virtual void add_ReadingEntity(EventHandler`1<ReadingWritingEntityEventArgs> value);
    public abstract virtual void remove_ReadingEntity(EventHandler`1<ReadingWritingEntityEventArgs> value);
    public abstract virtual IDataServiceQuery`1<T> CreateQuery(string entitySetName);
    public abstract virtual IDataServiceQuery`1<T> CreateQuery(string entitySetName, IDictionary`2<string, object> queryOptions);
    public abstract virtual IEnumerable`1<T> ExecuteBatch(DataServiceRequest request);
    public abstract virtual Uri GetReadStreamUri(object entity);
    public abstract virtual IEnumerable`1<T> Execute(Type elementType, DataServiceQueryContinuation continuation);
}
[CLSCompliantAttribute("False")]
public interface NuGet.IDataServiceQuery {
    public abstract virtual bool RequiresBatch(Expression expression);
    public abstract virtual DataServiceRequest GetRequest(Expression expression);
    public abstract virtual IDataServiceQuery`1<TElement> CreateQuery(Expression expression);
    public abstract virtual TResult Execute(Expression expression);
    public abstract virtual object Execute(Expression expression);
}
[CLSCompliantAttribute("False")]
public interface NuGet.IDataServiceQuery`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
    public abstract virtual IQueryable`1<T> AsQueryable();
}
public interface NuGet.IDependencyResolver {
    public abstract virtual IPackage ResolveDependency(PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion);
}
public interface NuGet.IDependentsResolver {
    public abstract virtual IEnumerable`1<IPackage> GetDependents(IPackage package);
}
public interface NuGet.IEnvironmentVariableReader {
    public abstract virtual string GetEnvironmentVariable(string variable);
}
public interface NuGet.IFileConflictResolver {
    public abstract virtual FileConflictResolution ResolveFileConflict(string message);
}
public interface NuGet.IFileSystem {
    public ILogger Logger { get; public set; }
    public string Root { get; }
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual string get_Root();
    public abstract virtual void DeleteDirectory(string path, bool recursive);
    public abstract virtual IEnumerable`1<string> GetFiles(string path, string filter, bool recursive);
    public abstract virtual IEnumerable`1<string> GetDirectories(string path);
    public abstract virtual string GetFullPath(string path);
    public abstract virtual void DeleteFile(string path);
    public abstract virtual void DeleteFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    public abstract virtual bool FileExists(string path);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual void AddFile(string path, Stream stream);
    public abstract virtual void AddFile(string path, Action`1<Stream> writeToStream);
    public abstract virtual void AddFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    public abstract virtual void MakeFileWritable(string path);
    public abstract virtual void MoveFile(string source, string destination);
    public abstract virtual Stream CreateFile(string path);
    public abstract virtual Stream OpenFile(string path);
    public abstract virtual DateTimeOffset GetLastModified(string path);
    public abstract virtual DateTimeOffset GetCreated(string path);
    public abstract virtual DateTimeOffset GetLastAccessed(string path);
}
public interface NuGet.IFrameworkTargetable {
    public IEnumerable`1<FrameworkName> SupportedFrameworks { get; }
    public abstract virtual IEnumerable`1<FrameworkName> get_SupportedFrameworks();
}
public interface NuGet.IHashProvider {
    public abstract virtual Byte[] CalculateHash(Stream stream);
    public abstract virtual Byte[] CalculateHash(Byte[] data);
    public abstract virtual bool VerifyHash(Byte[] data, Byte[] hash);
}
public interface NuGet.IHttpClient {
    public string UserAgent { get; public set; }
    public Uri Uri { get; }
    public Uri OriginalUri { get; }
    public bool AcceptCompression { get; public set; }
    public abstract virtual string get_UserAgent();
    public abstract virtual void set_UserAgent(string value);
    public abstract virtual Uri get_Uri();
    public abstract virtual Uri get_OriginalUri();
    public abstract virtual bool get_AcceptCompression();
    public abstract virtual void set_AcceptCompression(bool value);
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
public abstract virtual WebResponse GetResponse();
    public abstract virtual void InitializeRequest(WebRequest request);
    public abstract virtual void DownloadData(Stream targetStream);
}
public interface NuGet.IHttpClientEvents {
    public abstract virtual void add_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
    public abstract virtual void remove_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
}
public interface NuGet.IHttpWebResponse {
    public HttpStatusCode StatusCode { get; }
    public Uri ResponseUri { get; }
    public string AuthType { get; }
    public NameValueCollection Headers { get; }
    public abstract virtual HttpStatusCode get_StatusCode();
    public abstract virtual Uri get_ResponseUri();
    public abstract virtual string get_AuthType();
    public abstract virtual NameValueCollection get_Headers();
}
public interface NuGet.ILatestPackageLookup {
    public abstract virtual bool TryFindLatestPackageById(string id, SemanticVersion& latestVersion);
    public abstract virtual bool TryFindLatestPackageById(string id, bool includePrerelease, IPackage& package);
}
public interface NuGet.ILogger {
    public abstract virtual void Log(MessageLevel level, string message, Object[] args);
}
public interface NuGet.IMachineWideSettings {
    public IEnumerable`1<Settings> Settings { get; }
    public abstract virtual IEnumerable`1<Settings> get_Settings();
}
public class NuGet.InstallWalker : PackageWalker {
    private bool _ignoreDependencies;
    private bool _allowPrereleaseVersions;
    private OperationLookup _operations;
    private bool _isDowngrade;
    private HashSet`1<IPackage> _packagesToKeep;
    private IDictionary`2<string, IList`1<IPackage>> _packagesByDependencyOrder;
    [CompilerGeneratedAttribute]
private bool <DisableWalkInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckDowngrade>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageRepository <SourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageConstraintProvider <ConstraintProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1c`2<IPackage, PackageDependency>, IPackage> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<IPackage, IPackage>, bool> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<IPackage, IPackage>, IPackage> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, IList`1<IPackage>>, IEnumerable`1<IPackage>> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate23;
    internal bool DisableWalkInfo { get; internal set; }
    internal bool CheckDowngrade { get; internal set; }
    protected bool IgnoreWalkInfo { get; }
    protected ILogger Logger { get; private set; }
    protected IPackageRepository Repository { get; private set; }
    protected bool IgnoreDependencies { get; }
    protected bool AllowPrereleaseVersions { get; }
    protected IPackageRepository SourceRepository { get; private set; }
    private IPackageConstraintProvider ConstraintProvider { get; private set; }
    protected IList`1<PackageOperation> Operations { get; }
    internal InstallWalker(IPackageRepository localRepository, IPackageRepository sourceRepository, ILogger logger, bool ignoreDependencies, bool allowPrereleaseVersions, DependencyVersion dependencyVersion);
    public InstallWalker(IPackageRepository localRepository, IPackageRepository sourceRepository, FrameworkName targetFramework, ILogger logger, bool ignoreDependencies, bool allowPrereleaseVersions, DependencyVersion dependencyVersion);
    public InstallWalker(IPackageRepository localRepository, IPackageRepository sourceRepository, IPackageConstraintProvider constraintProvider, FrameworkName targetFramework, ILogger logger, bool ignoreDependencies, bool allowPrereleaseVersions, DependencyVersion dependencyVersion);
    [CompilerGeneratedAttribute]
internal bool get_DisableWalkInfo();
    [CompilerGeneratedAttribute]
internal void set_DisableWalkInfo(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CheckDowngrade();
    [CompilerGeneratedAttribute]
internal void set_CheckDowngrade(bool value);
    protected virtual bool get_IgnoreWalkInfo();
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
protected IPackageRepository get_Repository();
    [CompilerGeneratedAttribute]
private void set_Repository(IPackageRepository value);
    protected virtual bool get_IgnoreDependencies();
    protected virtual bool get_AllowPrereleaseVersions();
    [CompilerGeneratedAttribute]
protected IPackageRepository get_SourceRepository();
    [CompilerGeneratedAttribute]
private void set_SourceRepository(IPackageRepository value);
    [CompilerGeneratedAttribute]
private IPackageConstraintProvider get_ConstraintProvider();
    [CompilerGeneratedAttribute]
private void set_ConstraintProvider(IPackageConstraintProvider value);
    protected IList`1<PackageOperation> get_Operations();
    protected virtual ConflictResult GetConflict(IPackage package);
    protected virtual void OnBeforePackageWalk(IPackage package);
    private void Uninstall(IPackage package, IDependentsResolver dependentsResolver, IPackageRepository repository);
    private IPackage SelectDependency(IEnumerable`1<IPackage> dependencies);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
private bool TryUpdate(IEnumerable`1<IPackage> dependents, ConflictResult conflictResult, IPackage package, IEnumerable`1& incompatiblePackages);
    protected virtual void OnAfterPackageWalk(IPackage package);
    protected virtual IPackage ResolveDependency(PackageDependency dependency);
    protected virtual void OnDependencyResolveError(PackageDependency dependency);
    public sealed virtual IEnumerable`1<PackageOperation> ResolveOperations(IPackage package);
    [SuppressMessageAttribute("Microsoft.Design", "CA1021:AvoidOutParameters")]
public IList`1<PackageOperation> ResolveOperations(IEnumerable`1<IPackage> packages, IList`1& packagesByDependencyOrder, bool allowPrereleaseVersionsBasedOnPackage);
    private IEnumerable`1<IPackage> GetDependents(ConflictResult conflict);
    private static InvalidOperationException CreatePackageConflictException(IPackage resolvedPackage, IPackage package, IEnumerable`1<IPackage> dependents);
    [CompilerGeneratedAttribute]
private static IPackage <OnBeforePackageWalk>b__3(<>f__AnonymousType1c`2<IPackage, PackageDependency> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private static string <TryUpdate>b__9(IPackage d);
    [CompilerGeneratedAttribute]
private static string <TryUpdate>b__a(IPackage p);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType1e`2<IPackage, IPackage> <TryUpdate>b__c(<>f__AnonymousType1d`2<IGrouping`2<string, IPackage>, IPackage> <>h__TransparentIdentifier8);
    [CompilerGeneratedAttribute]
private static bool <TryUpdate>b__f(KeyValuePair`2<IPackage, IPackage> p);
    [CompilerGeneratedAttribute]
private static IPackage <TryUpdate>b__10(KeyValuePair`2<IPackage, IPackage> p);
    [CompilerGeneratedAttribute]
private static SemanticVersion <TryUpdate>b__e(IPackage p);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<IPackage> <ResolveOperations>b__1a(KeyValuePair`2<string, IList`1<IPackage>> p);
    [CompilerGeneratedAttribute]
private static string <CreatePackageConflictException>b__22(IPackage d);
}
public interface NuGet.IOperationAwareRepository {
    public abstract virtual IDisposable StartOperation(string operation, string mainPackageId, string mainPackageVersion);
}
public interface NuGet.IPackage {
    public bool IsAbsoluteLatestVersion { get; }
    public bool IsLatestVersion { get; }
    public bool Listed { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public IEnumerable`1<IPackageAssemblyReference> AssemblyReferences { get; }
    public abstract virtual bool get_IsAbsoluteLatestVersion();
    public abstract virtual bool get_IsLatestVersion();
    public abstract virtual bool get_Listed();
    public abstract virtual Nullable`1<DateTimeOffset> get_Published();
    public abstract virtual IEnumerable`1<IPackageAssemblyReference> get_AssemblyReferences();
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
public abstract virtual IEnumerable`1<IPackageFile> GetFiles();
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
public abstract virtual IEnumerable`1<FrameworkName> GetSupportedFrameworks();
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
public abstract virtual Stream GetStream();
    public abstract virtual void ExtractContents(IFileSystem fileSystem, string extractPath);
}
public interface NuGet.IPackageAssemblyReference {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public interface NuGet.IPackageBuilder {
    public Collection`1<IPackageFile> Files { get; }
    public abstract virtual Collection`1<IPackageFile> get_Files();
    public abstract virtual void Save(Stream stream);
}
public interface NuGet.IPackageCacheRepository {
    public abstract virtual bool InvokeOnPackage(string packageId, SemanticVersion version, Action`1<Stream> action);
}
public interface NuGet.IPackageConstraintProvider {
    public string Source { get; }
    public abstract virtual string get_Source();
    public abstract virtual IVersionSpec GetConstraint(string packageId);
}
public interface NuGet.IPackageFile {
    public string Path { get; }
    public string EffectivePath { get; }
    public FrameworkName TargetFramework { get; }
    public abstract virtual string get_Path();
    public abstract virtual string get_EffectivePath();
    public abstract virtual FrameworkName get_TargetFramework();
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
public abstract virtual Stream GetStream();
}
public interface NuGet.IPackageFileTransformer {
    public abstract virtual void TransformFile(IPackageFile file, string targetPath, IProjectSystem projectSystem);
    public abstract virtual void RevertFile(IPackageFile file, string targetPath, IEnumerable`1<IPackageFile> matchingFiles, IProjectSystem projectSystem);
}
public interface NuGet.IPackageLookup {
    public abstract virtual bool Exists(string packageId, SemanticVersion version);
    public abstract virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public abstract virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
}
public interface NuGet.IPackageManager {
    public IFileSystem FileSystem { get; public set; }
    public IPackageRepository LocalRepository { get; }
    public ILogger Logger { get; public set; }
    public DependencyVersion DependencyVersion { get; public set; }
    public bool WhatIf { get; public set; }
    public IPackageRepository SourceRepository { get; }
    public IPackagePathResolver PathResolver { get; }
    public abstract virtual IFileSystem get_FileSystem();
    public abstract virtual void set_FileSystem(IFileSystem value);
    public abstract virtual IPackageRepository get_LocalRepository();
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual DependencyVersion get_DependencyVersion();
    public abstract virtual void set_DependencyVersion(DependencyVersion value);
    public abstract virtual bool get_WhatIf();
    public abstract virtual void set_WhatIf(bool value);
    public abstract virtual IPackageRepository get_SourceRepository();
    public abstract virtual IPackagePathResolver get_PathResolver();
    public abstract virtual void add_PackageInstalled(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void remove_PackageInstalled(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void add_PackageInstalling(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void remove_PackageInstalling(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void add_PackageUninstalled(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void remove_PackageUninstalled(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void add_PackageUninstalling(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void remove_PackageUninstalling(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void InstallPackage(IPackage package, bool ignoreDependencies, bool allowPrereleaseVersions);
    public abstract virtual void InstallPackage(IPackage package, bool ignoreDependencies, bool allowPrereleaseVersions, bool ignoreWalkInfo);
    public abstract virtual void InstallPackage(string packageId, SemanticVersion version, bool ignoreDependencies, bool allowPrereleaseVersions);
    public abstract virtual void UpdatePackage(IPackage newPackage, bool updateDependencies, bool allowPrereleaseVersions);
    public abstract virtual void UpdatePackage(string packageId, SemanticVersion version, bool updateDependencies, bool allowPrereleaseVersions);
    public abstract virtual void UpdatePackage(string packageId, IVersionSpec versionSpec, bool updateDependencies, bool allowPrereleaseVersions);
    public abstract virtual void UninstallPackage(IPackage package, bool forceRemove, bool removeDependencies);
    public abstract virtual void UninstallPackage(string packageId, SemanticVersion version, bool forceRemove, bool removeDependencies);
}
public interface NuGet.IPackageMetadata {
    public string Title { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public Uri IconUrl { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public bool DevelopmentDependency { get; }
    public string Description { get; }
    public string Summary { get; }
    public string ReleaseNotes { get; }
    public string Language { get; }
    public string Tags { get; }
    public string Copyright { get; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkAssemblies { get; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; }
    public IEnumerable`1<PackageDependencySet> DependencySets { get; }
    public Version MinClientVersion { get; }
    public abstract virtual string get_Title();
    public abstract virtual IEnumerable`1<string> get_Authors();
    public abstract virtual IEnumerable`1<string> get_Owners();
    public abstract virtual Uri get_IconUrl();
    public abstract virtual Uri get_LicenseUrl();
    public abstract virtual Uri get_ProjectUrl();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual bool get_DevelopmentDependency();
    public abstract virtual string get_Description();
    public abstract virtual string get_Summary();
    public abstract virtual string get_ReleaseNotes();
    public abstract virtual string get_Language();
    public abstract virtual string get_Tags();
    public abstract virtual string get_Copyright();
    public abstract virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkAssemblies();
    public abstract virtual ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public abstract virtual IEnumerable`1<PackageDependencySet> get_DependencySets();
    public abstract virtual Version get_MinClientVersion();
}
public interface NuGet.IPackageName {
    public string Id { get; }
    public SemanticVersion Version { get; }
    public abstract virtual string get_Id();
    public abstract virtual SemanticVersion get_Version();
}
public interface NuGet.IPackageOperationResolver {
    public abstract virtual IEnumerable`1<PackageOperation> ResolveOperations(IPackage package);
}
public interface NuGet.IPackagePathResolver {
    public abstract virtual string GetInstallPath(IPackage package);
    public abstract virtual string GetPackageDirectory(IPackage package);
    public abstract virtual string GetPackageDirectory(string packageId, SemanticVersion version);
    public abstract virtual string GetPackageFileName(IPackage package);
    public abstract virtual string GetPackageFileName(string packageId, SemanticVersion version);
}
public interface NuGet.IPackageReferenceRepository {
    public abstract virtual void AddPackage(string packageId, SemanticVersion version, bool developmentDependency, FrameworkName targetFramework);
    public abstract virtual FrameworkName GetPackageTargetFramework(string packageId);
}
public interface NuGet.IPackageRepository {
    public string Source { get; }
    public PackageSaveModes PackageSaveMode { get; public set; }
    public bool SupportsPrereleasePackages { get; }
    public abstract virtual string get_Source();
    public abstract virtual PackageSaveModes get_PackageSaveMode();
    public abstract virtual void set_PackageSaveMode(PackageSaveModes value);
    public abstract virtual bool get_SupportsPrereleasePackages();
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
public abstract virtual IQueryable`1<IPackage> GetPackages();
    public abstract virtual void AddPackage(IPackage package);
    public abstract virtual void RemovePackage(IPackage package);
}
public interface NuGet.IPackageRepositoryFactory {
    public abstract virtual IPackageRepository CreateRepository(string packageSource);
}
public interface NuGet.IPackageRule {
    public abstract virtual IEnumerable`1<PackageIssue> Validate(IPackage package);
}
public interface NuGet.IPackageSourceProvider {
    public abstract virtual IEnumerable`1<PackageSource> LoadPackageSources();
    public abstract virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    public abstract virtual void DisablePackageSource(PackageSource source);
    public abstract virtual bool IsPackageSourceEnabled(PackageSource source);
}
public interface NuGet.IProgressProvider {
    public abstract virtual void add_ProgressAvailable(EventHandler`1<ProgressEventArgs> value);
    public abstract virtual void remove_ProgressAvailable(EventHandler`1<ProgressEventArgs> value);
}
public interface NuGet.IProjectManager {
    public IPackageRepository LocalRepository { get; }
    public ILogger Logger { get; public set; }
    public IProjectSystem Project { get; }
    public IPackageRepository SourceRepository { get; }
    public DependencyVersion DependencyVersion { get; public set; }
    public bool WhatIf { get; public set; }
    public abstract virtual IPackageRepository get_LocalRepository();
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual IProjectSystem get_Project();
    public abstract virtual IPackageRepository get_SourceRepository();
    public abstract virtual DependencyVersion get_DependencyVersion();
    public abstract virtual void set_DependencyVersion(DependencyVersion value);
    public abstract virtual bool get_WhatIf();
    public abstract virtual void set_WhatIf(bool value);
    public abstract virtual void add_PackageReferenceAdded(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void remove_PackageReferenceAdded(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void add_PackageReferenceAdding(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void remove_PackageReferenceAdding(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void add_PackageReferenceRemoved(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void remove_PackageReferenceRemoved(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void add_PackageReferenceRemoving(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void remove_PackageReferenceRemoving(EventHandler`1<PackageOperationEventArgs> value);
    public abstract virtual void AddPackageReference(IPackage package, bool ignoreDependencies, bool allowPrereleaseVersions);
    public abstract virtual void AddPackageReference(string packageId, SemanticVersion version, bool ignoreDependencies, bool allowPrereleaseVersions);
    public abstract virtual void RemovePackageReference(string packageId, bool forceRemove, bool removeDependencies);
    public abstract virtual void RemovePackageReference(IPackage package, bool forceRemove, bool removeDependencies);
    public abstract virtual void UpdatePackageReference(string packageId, SemanticVersion version, bool updateDependencies, bool allowPrereleaseVersions);
    public abstract virtual void UpdatePackageReference(string packageId, IVersionSpec versionSpec, bool updateDependencies, bool allowPrereleaseVersions);
    public abstract virtual void UpdatePackageReference(IPackage remotePackage, bool updateDependencies, bool allowPrereleaseVersions);
    public abstract virtual bool IsInstalled(IPackage package);
}
public interface NuGet.IProjectSystem {
    public FrameworkName TargetFramework { get; }
    public string ProjectName { get; }
    public bool IsBindingRedirectSupported { get; }
    public abstract virtual FrameworkName get_TargetFramework();
    public abstract virtual string get_ProjectName();
    public abstract virtual void AddReference(string referencePath, Stream stream);
    public abstract virtual void AddFrameworkReference(string name);
    public abstract virtual bool ReferenceExists(string name);
    public abstract virtual void RemoveReference(string name);
    public abstract virtual bool IsSupportedFile(string path);
    public abstract virtual string ResolvePath(string path);
    public abstract virtual bool get_IsBindingRedirectSupported();
    public abstract virtual void AddImport(string targetFullPath, ProjectImportLocation location);
    public abstract virtual void RemoveImport(string targetFullPath);
    public abstract virtual bool FileExistsInProject(string path);
}
public interface NuGet.IPropertyProvider {
    public abstract virtual object GetPropertyValue(string propertyName);
}
public interface NuGet.IProxyCache {
    public abstract virtual void Add(IWebProxy proxy);
    public abstract virtual IWebProxy GetProxy(Uri uri);
}
public interface NuGet.IServerPackageMetadata {
    public Uri ReportAbuseUrl { get; }
    public int DownloadCount { get; }
    public abstract virtual Uri get_ReportAbuseUrl();
    public abstract virtual int get_DownloadCount();
}
public interface NuGet.IServiceBasedRepository {
    public abstract virtual IQueryable`1<IPackage> Search(string searchTerm, IEnumerable`1<string> targetFrameworks, bool allowPrereleaseVersions);
    public abstract virtual IEnumerable`1<IPackage> GetUpdates(IEnumerable`1<IPackageName> packages, bool includePrerelease, bool includeAllVersions, IEnumerable`1<FrameworkName> targetFrameworks, IEnumerable`1<IVersionSpec> versionConstraints);
}
public interface NuGet.ISettings {
    public abstract virtual string GetValue(string section, string key, bool isPath);
    public abstract virtual IList`1<SettingValue> GetValues(string section, bool isPath);
    public abstract virtual IList`1<SettingValue> GetNestedValues(string section, string subsection);
    public abstract virtual void SetValue(string section, string key, string value);
    public abstract virtual void SetValues(string section, IList`1<SettingValue> values);
    public abstract virtual void UpdateSections(string section, IList`1<SettingValue> values);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public abstract virtual void SetNestedValues(string section, string key, IList`1<KeyValuePair`2<string, string>> values);
    public abstract virtual bool DeleteValue(string section, string key);
    public abstract virtual bool DeleteSection(string section);
}
public interface NuGet.ISharedPackageRepository {
    public abstract virtual bool IsReferenced(string packageId, SemanticVersion version);
    public abstract virtual bool IsSolutionReferenced(string packageId, SemanticVersion version);
    public abstract virtual void RegisterRepository(string path);
    public abstract virtual void UnregisterRepository(string path);
}
public interface NuGet.IVersionSpec {
    public SemanticVersion MinVersion { get; }
    public bool IsMinInclusive { get; }
    public SemanticVersion MaxVersion { get; }
    public bool IsMaxInclusive { get; }
    public abstract virtual SemanticVersion get_MinVersion();
    public abstract virtual bool get_IsMinInclusive();
    public abstract virtual SemanticVersion get_MaxVersion();
    public abstract virtual bool get_IsMaxInclusive();
}
public class NuGet.LazyLocalPackageRepository : PackageRepositoryBase {
    private Lazy`1<IPackageRepository> _repository;
    private IFileSystem _fileSystem;
    public string Source { get; }
    public bool SupportsPrereleasePackages { get; }
    internal IPackageRepository Repository { get; }
    public LazyLocalPackageRepository(string path);
    public LazyLocalPackageRepository(IFileSystem fileSystem);
    public virtual string get_Source();
    public virtual bool get_SupportsPrereleasePackages();
    internal IPackageRepository get_Repository();
    public virtual IQueryable`1<IPackage> GetPackages();
    public virtual void AddPackage(IPackage package);
    public virtual void RemovePackage(IPackage package);
    public sealed virtual bool Exists(string packageId, SemanticVersion version);
    public sealed virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public sealed virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
    private static IPackageRepository CreateRepository(IFileSystem fileSystem);
}
internal class NuGet.LazyQueue`1 : object {
    private IEnumerator`1<TVal> _enumerator;
    private TVal _peeked;
    public LazyQueue`1(IEnumerator`1<TVal> enumerator);
    public bool TryPeek(TVal& element);
    public void Dequeue();
    public sealed virtual IEnumerator`1<TVal> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class NuGet.LocalPackage : object {
    private static string ResourceAssemblyExtension;
    private IList`1<IPackageAssemblyReference> _assemblyReferences;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencySet> <DependencySets>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkAssemblyReference> <FrameworkAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageReferenceSet> <PackageAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkAssemblyReference, IEnumerable`1<FrameworkName>> CS$<>9__CachedAnonymousMethodDelegate1;
    public string Id { get; public set; }
    public SemanticVersion Version { get; public set; }
    public string Title { get; public set; }
    public IEnumerable`1<string> Authors { get; public set; }
    public IEnumerable`1<string> Owners { get; public set; }
    public Uri IconUrl { get; public set; }
    public Uri LicenseUrl { get; public set; }
    public Uri ProjectUrl { get; public set; }
    public Uri ReportAbuseUrl { get; }
    public int DownloadCount { get; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string Language { get; public set; }
    public string Tags { get; public set; }
    public Version MinClientVersion { get; private set; }
    public bool IsAbsoluteLatestVersion { get; }
    public bool IsLatestVersion { get; }
    public bool Listed { get; public set; }
    public Nullable`1<DateTimeOffset> Published { get; public set; }
    public string Copyright { get; public set; }
    public IEnumerable`1<PackageDependencySet> DependencySets { get; public set; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkAssemblies { get; public set; }
    public IEnumerable`1<IPackageAssemblyReference> AssemblyReferences { get; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual SemanticVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(SemanticVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Owners();
    [CompilerGeneratedAttribute]
public void set_Owners(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(Uri value);
    public sealed virtual Uri get_ReportAbuseUrl();
    public sealed virtual int get_DownloadCount();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
private void set_MinClientVersion(Version value);
    public sealed virtual bool get_IsAbsoluteLatestVersion();
    public sealed virtual bool get_IsLatestVersion();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Listed();
    [CompilerGeneratedAttribute]
public void set_Listed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
public void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageDependencySet> get_DependencySets();
    [CompilerGeneratedAttribute]
public void set_DependencySets(IEnumerable`1<PackageDependencySet> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkAssemblies();
    [CompilerGeneratedAttribute]
public void set_FrameworkAssemblies(IEnumerable`1<FrameworkAssemblyReference> value);
    public sealed virtual IEnumerable`1<IPackageAssemblyReference> get_AssemblyReferences();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    [CompilerGeneratedAttribute]
private void set_PackageAssemblyReferences(ICollection`1<PackageReferenceSet> value);
    public virtual IEnumerable`1<FrameworkName> GetSupportedFrameworks();
    public sealed virtual IEnumerable`1<IPackageFile> GetFiles();
    public abstract virtual Stream GetStream();
    public abstract virtual void ExtractContents(IFileSystem fileSystem, string extractPath);
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
protected abstract virtual IEnumerable`1<IPackageFile> GetFilesBase();
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
protected abstract virtual IEnumerable`1<IPackageAssemblyReference> GetAssemblyReferencesCore();
    protected void ReadManifest(Stream manifestStream);
    protected internal static bool IsAssemblyReference(string filePath);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static IEnumerable`1<FrameworkName> <GetSupportedFrameworks>b__0(FrameworkAssemblyReference f);
}
public class NuGet.LocalPackageRepository : PackageRepositoryBase {
    private ConcurrentDictionary`2<string, PackageCacheEntry> _packageCache;
    private ConcurrentDictionary`2<PackageName, string> _packagePathLookup;
    private bool _enableCaching;
    [CompilerGeneratedAttribute]
private IPackagePathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageAssemblyReference, FrameworkName> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<FrameworkName, IPackageAssemblyReference>, ManifestReferenceSet> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageAssemblyReference, ManifestReference> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTyped`2<string, IPackage>, IPackage> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, bool> CS$<>9__CachedAnonymousMethodDelegate1e;
    public string Source { get; }
    public IPackagePathResolver PathResolver { get; public set; }
    public bool SupportsPrereleasePackages { get; }
    protected IFileSystem FileSystem { get; private set; }
    public LocalPackageRepository(string physicalPath);
    public LocalPackageRepository(string physicalPath, bool enableCaching);
    public LocalPackageRepository(IPackagePathResolver pathResolver, IFileSystem fileSystem);
    public LocalPackageRepository(IPackagePathResolver pathResolver, IFileSystem fileSystem, bool enableCaching);
    public virtual string get_Source();
    [CompilerGeneratedAttribute]
public IPackagePathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public void set_PathResolver(IPackagePathResolver value);
    public virtual bool get_SupportsPrereleasePackages();
    [CompilerGeneratedAttribute]
protected IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(IFileSystem value);
    public virtual IQueryable`1<IPackage> GetPackages();
    public virtual void AddPackage(IPackage package);
    public virtual void RemovePackage(IPackage package);
    public virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
    public virtual bool Exists(string packageId, SemanticVersion version);
    public virtual IEnumerable`1<string> GetPackageLookupPaths(string packageId, SemanticVersion version);
    internal IPackage FindPackage(Func`2<string, IPackage> openPackage, string packageId, SemanticVersion version);
    internal IEnumerable`1<IPackage> FindPackagesById(Func`2<string, IPackage> openPackage, string packageId);
    internal IEnumerable`1<IPackage> GetPackages(Func`2<string, IPackage> openPackage, string packageId, IEnumerable`1<string> packagePaths);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
internal IEnumerable`1<IPackage> GetPackages(Func`2<string, IPackage> openPackage);
    private IPackage GetPackage(Func`2<string, IPackage> openPackage, string path);
    internal IEnumerable`1<string> GetPackageFiles(string filter);
    internal virtual IPackage OpenPackage(string path);
    protected virtual string GetPackageFilePath(IPackage package);
    protected virtual string GetPackageFilePath(string id, SemanticVersion version);
    private static bool FileNameMatchesPattern(string packageId, SemanticVersion version, string path);
    private string GetManifestFilePath(string packageId, SemanticVersion version);
    [CompilerGeneratedAttribute]
private static FrameworkName <AddPackage>b__2(IPackageAssemblyReference f);
    [CompilerGeneratedAttribute]
private static ManifestReferenceSet <AddPackage>b__3(IGrouping`2<FrameworkName, IPackageAssemblyReference> g);
    [CompilerGeneratedAttribute]
private static ManifestReference <AddPackage>b__4(IPackageAssemblyReference p);
    [CompilerGeneratedAttribute]
private static IPackage <FindPackage>b__11(<>f__AnonymousTyped`2<string, IPackage> <>h__TransparentIdentifiere);
    [CompilerGeneratedAttribute]
private static bool <GetPackages>b__1d(IPackage p);
}
public class NuGet.MachineCache : LocalPackageRepository {
    private static int MaxPackages;
    private static string NuGetCachePathEnvironmentVariable;
    private static Lazy`1<MachineCache> _instance;
    [CompilerGeneratedAttribute]
private static Func`1<MachineCache> CS$<>9__CachedAnonymousMethodDelegate3b;
    public static MachineCache Default { get; }
    internal MachineCache(IFileSystem fileSystem);
    private static MachineCache();
    public static MachineCache get_Default();
    internal static MachineCache CreateDefault(Func`1<string> getCachePath);
    public virtual void AddPackage(IPackage package);
    private static string GetTempFile(string filename);
    public virtual bool Exists(string packageId, SemanticVersion version);
    public sealed virtual bool InvokeOnPackage(string packageId, SemanticVersion version, Action`1<Stream> action);
    public void Clear();
    private void TryClear(IEnumerable`1<string> files);
    protected virtual string GetPackageFilePath(IPackage package);
    protected virtual string GetPackageFilePath(string id, SemanticVersion version);
    internal static string GetCachePath();
    internal static string GetCachePath(Func`2<string, string> getEnvironmentVariable, Func`2<SpecialFolder, string> getFolderPath);
    private bool TryAct(Func`1<bool> action, string path);
    [CompilerGeneratedAttribute]
private static MachineCache <.cctor>b__3a();
}
[XmlTypeAttribute("package")]
public class NuGet.Manifest : object {
    private static string SchemaVersionAttributeName;
    [CompilerGeneratedAttribute]
private ManifestMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ManifestFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<PackageReferenceSet, ManifestReferenceSet> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<string, ManifestReference> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, ManifestDependencySet> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependency, ManifestDependency> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkAssemblyReference, ManifestFrameworkAssembly> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static ValidationEventHandler CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestDependencySet, IEnumerable`1<ManifestDependency>> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<ValidationResult, string> CS$<>9__CachedAnonymousMethodDelegate18;
    [XmlElementAttribute("metadata")]
public ManifestMetadata Metadata { get; public set; }
    [SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
[XmlArrayAttribute("files")]
[SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
public List`1<ManifestFile> Files { get; public set; }
    [CompilerGeneratedAttribute]
public ManifestMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(ManifestMetadata value);
    [CompilerGeneratedAttribute]
public List`1<ManifestFile> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(List`1<ManifestFile> value);
    public void Save(Stream stream);
    public void Save(Stream stream, int minimumManifestVersion);
    public void Save(Stream stream, bool validate);
    public void Save(Stream stream, bool validate, int minimumManifestVersion);
    public static Manifest ReadFrom(Stream stream, bool validateSchema);
    public static Manifest ReadFrom(Stream stream, IPropertyProvider propertyProvider, bool validateSchema);
    private static string GetSchemaNamespace(XDocument document);
    public static Manifest Create(IPackageMetadata metadata);
    public static Manifest Create(PackageBuilder packageBuilder);
    private static string ConvertUrlToStringSafe(Uri url);
    private static List`1<ManifestReferenceSet> CreateReferenceSets(IPackageMetadata metadata);
    private static List`1<ManifestReference> CreateReferences(PackageReferenceSet referenceSet);
    private static List`1<ManifestDependencySet> CreateDependencySets(IPackageMetadata metadata);
    private static List`1<ManifestDependency> CreateDependencies(ICollection`1<PackageDependency> dependencies);
    private static List`1<ManifestFrameworkAssembly> CreateFrameworkAssemblies(IPackageMetadata metadata);
    private static string GetCommaSeparatedString(IEnumerable`1<string> values);
    private static void ValidateManifestSchema(XDocument document, string schemaNamespace);
    private static void CheckSchemaVersion(XDocument document);
    private static string GetPackageId(XElement metadataElement);
    private static XElement GetMetadataElement(XDocument document);
    internal static void Validate(Manifest manifest);
    private static void ValidateDependencySets(IPackageMetadata metadata);
    private static void ValidateDependencyVersion(PackageDependency dependency);
    private static bool TryValidate(object value, ICollection`1<ValidationResult> results);
    private static ValidationContext CreateValidationContext(object value);
    [CompilerGeneratedAttribute]
private static ManifestReferenceSet <CreateReferenceSets>b__5(PackageReferenceSet referenceSet);
    [CompilerGeneratedAttribute]
private static ManifestReference <CreateReferences>b__8(string reference);
    [CompilerGeneratedAttribute]
private static ManifestDependencySet <CreateDependencySets>b__b(PackageDependencySet dependencySet);
    [CompilerGeneratedAttribute]
private static ManifestDependency <CreateDependencies>b__e(PackageDependency dependency);
    [CompilerGeneratedAttribute]
private static ManifestFrameworkAssembly <CreateFrameworkAssemblies>b__11(FrameworkAssemblyReference reference);
    [CompilerGeneratedAttribute]
private static void <ValidateManifestSchema>b__13(object sender, ValidationEventArgs e);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ManifestDependency> <Validate>b__15(ManifestDependencySet d);
    [CompilerGeneratedAttribute]
private static string <Validate>b__16(ValidationResult r);
}
[XmlTypeAttribute("files")]
public class NuGet.ManifestContentFiles : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flatten>k__BackingField;
    [XmlAttributeAttribute("include")]
public string Include { get; public set; }
    [XmlAttributeAttribute("exclude")]
public string Exclude { get; public set; }
    [XmlAttributeAttribute("buildAction")]
public string BuildAction { get; public set; }
    [XmlAttributeAttribute("copyToOutput")]
public string CopyToOutput { get; public set; }
    [XmlAttributeAttribute("flatten")]
public string Flatten { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public void set_BuildAction(string value);
    [CompilerGeneratedAttribute]
public string get_CopyToOutput();
    [CompilerGeneratedAttribute]
public void set_CopyToOutput(string value);
    [CompilerGeneratedAttribute]
public string get_Flatten();
    [CompilerGeneratedAttribute]
public void set_Flatten(string value);
}
[XmlTypeAttribute("dependency")]
public class NuGet.ManifestDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [RequiredAttribute]
[XmlAttributeAttribute("id")]
public string Id { get; public set; }
    [XmlAttributeAttribute("version")]
public string Version { get; public set; }
    [XmlAttributeAttribute("include")]
public string Include { get; public set; }
    [XmlAttributeAttribute("exclude")]
public string Exclude { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
}
public class NuGet.ManifestDependencySet : object {
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ManifestDependency> <Dependencies>k__BackingField;
    [XmlAttributeAttribute("targetFramework")]
public string TargetFramework { get; public set; }
    [XmlElementAttribute("dependency")]
[SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
public List`1<ManifestDependency> Dependencies { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public List`1<ManifestDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(List`1<ManifestDependency> value);
}
[XmlTypeAttribute("file")]
public class NuGet.ManifestFile : object {
    private static Char[] _invalidTargetChars;
    private static Char[] _invalidSourceCharacters;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [XmlAttributeAttribute("src")]
[RequiredAttribute]
public string Source { get; public set; }
    [XmlAttributeAttribute("target")]
public string Target { get; public set; }
    [XmlAttributeAttribute("exclude")]
public string Exclude { get; public set; }
    private static ManifestFile();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    public sealed virtual IEnumerable`1<ValidationResult> Validate(ValidationContext validationContext);
}
[XmlTypeAttribute("frameworkAssembly")]
public class NuGet.ManifestFrameworkAssembly : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [RequiredAttribute]
[XmlAttributeAttribute("assemblyName")]
public string AssemblyName { get; public set; }
    [XmlAttributeAttribute("targetFramework")]
public string TargetFramework { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
}
[XmlTypeAttribute("metadata")]
public class NuGet.ManifestMetadata : object {
    private string _owners;
    private string _minClientVersionString;
    private List`1<ManifestContentFiles> _contentFiles;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ManifestDependencySet> <DependencySets>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ManifestFrameworkAssembly> <FrameworkAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ManifestReferenceSet> <ReferenceSets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestDependencySet, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestDependencySet, IEnumerable`1<ManifestDependency>> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestDependency, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestReferenceSet, bool> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestReferenceSet, IEnumerable`1<ManifestReference>> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, FrameworkName> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<FrameworkName, PackageDependencySet>, PackageDependencySet> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Predicate`1<PackageDependencySet> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, IEnumerable`1<PackageDependency>> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestReferenceSet, PackageReferenceSet> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<PackageReferenceSet, FrameworkName> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<FrameworkName, PackageReferenceSet>, PackageReferenceSet> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Predicate`1<PackageReferenceSet> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<PackageReferenceSet, IEnumerable`1<string>> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestFrameworkAssembly, FrameworkAssemblyReference> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestDependency, PackageDependency> CS$<>9__CachedAnonymousMethodDelegate22;
    [XmlAttributeAttribute("minClientVersion")]
[ManifestVersionAttribute("5")]
public string MinClientVersionString { get; public set; }
    [XmlIgnoreAttribute]
public Version MinClientVersion { get; private set; }
    [RequiredAttribute]
[XmlElementAttribute("id")]
public string Id { get; public set; }
    [RequiredAttribute]
[XmlElementAttribute("version")]
public string Version { get; public set; }
    [XmlElementAttribute("title")]
public string Title { get; public set; }
    [RequiredAttribute]
[XmlElementAttribute("authors")]
public string Authors { get; public set; }
    [XmlElementAttribute("owners")]
public string Owners { get; public set; }
    [XmlElementAttribute("licenseUrl")]
[SuppressMessageAttribute("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings")]
public string LicenseUrl { get; public set; }
    [XmlElementAttribute("projectUrl")]
[SuppressMessageAttribute("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings")]
public string ProjectUrl { get; public set; }
    [SuppressMessageAttribute("Microsoft.Design", "CA1056:UriPropertiesShouldNotBeStrings")]
[XmlElementAttribute("iconUrl")]
public string IconUrl { get; public set; }
    [XmlElementAttribute("requireLicenseAcceptance")]
public bool RequireLicenseAcceptance { get; public set; }
    [DefaultValueAttribute("False")]
[XmlElementAttribute("developmentDependency")]
public bool DevelopmentDependency { get; public set; }
    [RequiredAttribute]
[XmlElementAttribute("description")]
public string Description { get; public set; }
    [XmlElementAttribute("summary")]
public string Summary { get; public set; }
    [XmlElementAttribute("releaseNotes")]
[ManifestVersionAttribute("2")]
public string ReleaseNotes { get; public set; }
    [ManifestVersionAttribute("2")]
[XmlElementAttribute("copyright")]
public string Copyright { get; public set; }
    [XmlElementAttribute("language")]
public string Language { get; public set; }
    [XmlElementAttribute("tags")]
public string Tags { get; public set; }
    [XmlArrayItemAttribute("dependency", "NuGet.ManifestDependency")]
[XmlArrayAttribute("dependencies")]
[XmlArrayItemAttribute("group", "NuGet.ManifestDependencySet")]
[SuppressMessageAttribute("Microsoft.Usage", "CA1801:ReviewUnusedParameters")]
[SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
public List`1<object> DependencySetsSerialize { get; public set; }
    [SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
[XmlIgnoreAttribute]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
public List`1<ManifestDependencySet> DependencySets { get; public set; }
    [XmlArrayItemAttribute("frameworkAssembly")]
[SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
[XmlArrayAttribute("frameworkAssemblies")]
public List`1<ManifestFrameworkAssembly> FrameworkAssemblies { get; public set; }
    [XmlArrayItemAttribute("group", "NuGet.ManifestReferenceSet")]
[ManifestVersionAttribute("2")]
[SuppressMessageAttribute("Microsoft.Usage", "CA1801:ReviewUnusedParameters")]
[SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
[XmlArrayAttribute("references")]
[XmlArrayItemAttribute("reference", "NuGet.ManifestReference")]
public List`1<object> ReferenceSetsSerialize { get; public set; }
    [SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
[XmlIgnoreAttribute]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
public List`1<ManifestReferenceSet> ReferenceSets { get; public set; }
    [SuppressMessageAttribute("Microsoft.Usage", "CA1801:ReviewUnusedParameters")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
[XmlArrayItemAttribute("files", "NuGet.ManifestContentFiles")]
[SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
[XmlArrayAttribute("contentFiles")]
public List`1<object> ContentFilesSerialize { get; public set; }
    [SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
[XmlIgnoreAttribute]
[SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
public List`1<ManifestContentFiles> ContentFiles { get; public set; }
    private SemanticVersion NuGet.IPackageName.Version { get; }
    private Uri NuGet.IPackageMetadata.IconUrl { get; }
    private Uri NuGet.IPackageMetadata.LicenseUrl { get; }
    private Uri NuGet.IPackageMetadata.ProjectUrl { get; }
    private IEnumerable`1<string> NuGet.IPackageMetadata.Authors { get; }
    private IEnumerable`1<string> NuGet.IPackageMetadata.Owners { get; }
    private IEnumerable`1<PackageDependencySet> NuGet.IPackageMetadata.DependencySets { get; }
    private ICollection`1<PackageReferenceSet> NuGet.IPackageMetadata.PackageAssemblyReferences { get; }
    private IEnumerable`1<FrameworkAssemblyReference> NuGet.IPackageMetadata.FrameworkAssemblies { get; }
    public string get_MinClientVersionString();
    public void set_MinClientVersionString(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
private void set_MinClientVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(string value);
    public string get_Owners();
    public void set_Owners(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(string value);
    [CompilerGeneratedAttribute]
public string get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(string value);
    public List`1<object> get_DependencySetsSerialize();
    public void set_DependencySetsSerialize(List`1<object> value);
    [CompilerGeneratedAttribute]
public List`1<ManifestDependencySet> get_DependencySets();
    [CompilerGeneratedAttribute]
public void set_DependencySets(List`1<ManifestDependencySet> value);
    [CompilerGeneratedAttribute]
public List`1<ManifestFrameworkAssembly> get_FrameworkAssemblies();
    [CompilerGeneratedAttribute]
public void set_FrameworkAssemblies(List`1<ManifestFrameworkAssembly> value);
    public List`1<object> get_ReferenceSetsSerialize();
    public void set_ReferenceSetsSerialize(List`1<object> value);
    [CompilerGeneratedAttribute]
public List`1<ManifestReferenceSet> get_ReferenceSets();
    [CompilerGeneratedAttribute]
public void set_ReferenceSets(List`1<ManifestReferenceSet> value);
    public List`1<object> get_ContentFilesSerialize();
    public void set_ContentFilesSerialize(List`1<object> value);
    public List`1<ManifestContentFiles> get_ContentFiles();
    public void set_ContentFiles(List`1<ManifestContentFiles> value);
    private sealed virtual override SemanticVersion NuGet.IPackageName.get_Version();
    private sealed virtual override Uri NuGet.IPackageMetadata.get_IconUrl();
    private sealed virtual override Uri NuGet.IPackageMetadata.get_LicenseUrl();
    private sealed virtual override Uri NuGet.IPackageMetadata.get_ProjectUrl();
    private sealed virtual override IEnumerable`1<string> NuGet.IPackageMetadata.get_Authors();
    private sealed virtual override IEnumerable`1<string> NuGet.IPackageMetadata.get_Owners();
    private sealed virtual override IEnumerable`1<PackageDependencySet> NuGet.IPackageMetadata.get_DependencySets();
    private sealed virtual override ICollection`1<PackageReferenceSet> NuGet.IPackageMetadata.get_PackageAssemblyReferences();
    private sealed virtual override IEnumerable`1<FrameworkAssemblyReference> NuGet.IPackageMetadata.get_FrameworkAssemblies();
    public sealed virtual IEnumerable`1<ValidationResult> Validate(ValidationContext validationContext);
    private static IEnumerable`1<FrameworkName> ParseFrameworkNames(string frameworkNames);
    private static PackageDependencySet CreatePackageDependencySet(ManifestDependencySet manifestDependencySet);
    [CompilerGeneratedAttribute]
private static bool <get_DependencySetsSerialize>b__0(ManifestDependencySet set);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ManifestDependency> <get_DependencySetsSerialize>b__2(ManifestDependencySet set);
    [CompilerGeneratedAttribute]
private static bool <get_DependencySetsSerialize>b__1(ManifestDependency dependency);
    [CompilerGeneratedAttribute]
private static bool <get_ReferenceSetsSerialize>b__6(ManifestReferenceSet set);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<ManifestReference> <get_ReferenceSetsSerialize>b__7(ManifestReferenceSet set);
    [CompilerGeneratedAttribute]
private static FrameworkName <NuGet.IPackageMetadata.get_DependencySets>b__a(PackageDependencySet set);
    [CompilerGeneratedAttribute]
private static PackageDependencySet <NuGet.IPackageMetadata.get_DependencySets>b__b(IGrouping`2<FrameworkName, PackageDependencySet> group);
    [CompilerGeneratedAttribute]
private static bool <NuGet.IPackageMetadata.get_DependencySets>b__d(PackageDependencySet set);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PackageDependency> <NuGet.IPackageMetadata.get_DependencySets>b__c(PackageDependencySet g);
    [CompilerGeneratedAttribute]
private static PackageReferenceSet <NuGet.IPackageMetadata.get_PackageAssemblyReferences>b__12(ManifestReferenceSet r);
    [CompilerGeneratedAttribute]
private static FrameworkName <NuGet.IPackageMetadata.get_PackageAssemblyReferences>b__13(PackageReferenceSet set);
    [CompilerGeneratedAttribute]
private static PackageReferenceSet <NuGet.IPackageMetadata.get_PackageAssemblyReferences>b__14(IGrouping`2<FrameworkName, PackageReferenceSet> group);
    [CompilerGeneratedAttribute]
private static bool <NuGet.IPackageMetadata.get_PackageAssemblyReferences>b__16(PackageReferenceSet set);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<string> <NuGet.IPackageMetadata.get_PackageAssemblyReferences>b__15(PackageReferenceSet g);
    [CompilerGeneratedAttribute]
private static FrameworkAssemblyReference <NuGet.IPackageMetadata.get_FrameworkAssemblies>b__1c(ManifestFrameworkAssembly frameworkReference);
    [CompilerGeneratedAttribute]
private static PackageDependency <CreatePackageDependencySet>b__21(ManifestDependency d);
}
internal static class NuGet.ManifestReader : object {
    private static String[] RequiredElements;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousType1`2<XElement, XAttribute>> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<XElement, XAttribute>, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<XElement, XAttribute>, <>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, <>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>, <>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>, XAttribute>> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>, XAttribute>, <>f__AnonymousType5`2<<>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>, XAttribute>, XAttribute>> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType5`2<<>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>, XAttribute>, XAttribute>, ManifestContentFiles> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, ManifestReferenceSet> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousType6`2<XElement, XAttribute>> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType6`2<XElement, XAttribute>, bool> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType6`2<XElement, XAttribute>, ManifestReference> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousType7`2<XElement, XAttribute>> CS$<>9__CachedAnonymousMethodDelegate27;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType7`2<XElement, XAttribute>, bool> CS$<>9__CachedAnonymousMethodDelegate28;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType7`2<XElement, XAttribute>, ManifestFrameworkAssembly> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, ManifestDependencySet> CS$<>9__CachedAnonymousMethodDelegate2e;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousType8`2<XElement, XAttribute>> CS$<>9__CachedAnonymousMethodDelegate34;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType8`2<XElement, XAttribute>, bool> CS$<>9__CachedAnonymousMethodDelegate35;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType8`2<XElement, XAttribute>, ManifestDependency> CS$<>9__CachedAnonymousMethodDelegate36;
    private static ManifestReader();
    public static Manifest ReadManifest(XDocument document);
    private static ManifestMetadata ReadMetadata(XElement xElement);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
private static void ReadMetadataValue(ManifestMetadata manifestMetadata, XElement element, HashSet`1<string> allElements);
    private static List`1<ManifestContentFiles> ReadContentFiles(XElement contentFilesElement);
    private static List`1<ManifestReferenceSet> ReadReferenceSets(XElement referencesElement);
    public static List`1<ManifestReference> ReadReference(XElement referenceElement, bool throwIfEmpty);
    private static List`1<ManifestFrameworkAssembly> ReadFrameworkAssemblies(XElement frameworkElement);
    private static List`1<ManifestDependencySet> ReadDependencySets(XElement dependenciesElement);
    private static List`1<ManifestDependency> ReadDependencies(XElement containerElement);
    private static List`1<ManifestFile> ReadFilesList(XElement xElement);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1`2<XElement, XAttribute> <ReadContentFiles>b__7(XElement element);
    [CompilerGeneratedAttribute]
private static bool <ReadContentFiles>b__8(<>f__AnonymousType1`2<XElement, XAttribute> <>h__TransparentIdentifier1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute> <ReadContentFiles>b__9(<>f__AnonymousType1`2<XElement, XAttribute> <>h__TransparentIdentifier1);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute> <ReadContentFiles>b__a(<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute> <>h__TransparentIdentifier2);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>, XAttribute> <ReadContentFiles>b__b(<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute> <>h__TransparentIdentifier3);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType5`2<<>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>, XAttribute>, XAttribute> <ReadContentFiles>b__c(<>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>, XAttribute> <>h__TransparentIdentifier4);
    [CompilerGeneratedAttribute]
private static ManifestContentFiles <ReadContentFiles>b__d(<>f__AnonymousType5`2<<>f__AnonymousType4`2<<>f__AnonymousType3`2<<>f__AnonymousType2`2<<>f__AnonymousType1`2<XElement, XAttribute>, XAttribute>, XAttribute>, XAttribute>, XAttribute> <>h__TransparentIdentifier5);
    [CompilerGeneratedAttribute]
private static ManifestReferenceSet <ReadReferenceSets>b__18(XElement element);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType6`2<XElement, XAttribute> <ReadReference>b__1c(XElement element);
    [CompilerGeneratedAttribute]
private static bool <ReadReference>b__1d(<>f__AnonymousType6`2<XElement, XAttribute> <>h__TransparentIdentifier1a);
    [CompilerGeneratedAttribute]
private static ManifestReference <ReadReference>b__1e(<>f__AnonymousType6`2<XElement, XAttribute> <>h__TransparentIdentifier1a);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType7`2<XElement, XAttribute> <ReadFrameworkAssemblies>b__24(XElement element);
    [CompilerGeneratedAttribute]
private static bool <ReadFrameworkAssemblies>b__25(<>f__AnonymousType7`2<XElement, XAttribute> <>h__TransparentIdentifier22);
    [CompilerGeneratedAttribute]
private static ManifestFrameworkAssembly <ReadFrameworkAssemblies>b__26(<>f__AnonymousType7`2<XElement, XAttribute> <>h__TransparentIdentifier22);
    [CompilerGeneratedAttribute]
private static ManifestDependencySet <ReadDependencySets>b__2d(XElement element);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType8`2<XElement, XAttribute> <ReadDependencies>b__31(XElement element);
    [CompilerGeneratedAttribute]
private static bool <ReadDependencies>b__32(<>f__AnonymousType8`2<XElement, XAttribute> <>h__TransparentIdentifier2f);
    [CompilerGeneratedAttribute]
private static ManifestDependency <ReadDependencies>b__33(<>f__AnonymousType8`2<XElement, XAttribute> <>h__TransparentIdentifier2f);
}
[XmlTypeAttribute("reference")]
public class NuGet.ManifestReference : object {
    private static Char[] _referenceFileInvalidCharacters;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [XmlAttributeAttribute("file")]
[RequiredAttribute]
public string File { get; public set; }
    private static ManifestReference();
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    public sealed virtual IEnumerable`1<ValidationResult> Validate(ValidationContext validationContext);
    public sealed virtual bool Equals(ManifestReference other);
    public virtual int GetHashCode();
}
public class NuGet.ManifestReferenceSet : object {
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ManifestReference> <References>k__BackingField;
    [XmlAttributeAttribute("targetFramework")]
public string TargetFramework { get; public set; }
    [XmlElementAttribute("reference")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]
[SuppressMessageAttribute("Microsoft.Design", "CA1002:DoNotExposeGenericLists")]
public List`1<ManifestReference> References { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public List`1<ManifestReference> get_References();
    [CompilerGeneratedAttribute]
public void set_References(List`1<ManifestReference> value);
    public sealed virtual IEnumerable`1<ValidationResult> Validate(ValidationContext validationContext);
}
internal static class NuGet.ManifestSchemaUtility : object {
    internal static string SchemaVersionV1;
    internal static string SchemaVersionV2;
    internal static string SchemaVersionV3;
    internal static string SchemaVersionV4;
    internal static string SchemaVersionV5;
    internal static string SchemaVersionV6;
    private static String[] VersionToSchemaMappings;
    private static ConcurrentDictionary`2<string, XmlSchemaSet> _manifestSchemaSetCache;
    [CompilerGeneratedAttribute]
private static Func`2<string, XmlSchemaSet> CS$<>9__CachedAnonymousMethodDelegate2;
    private static ManifestSchemaUtility();
    public static int GetVersionFromNamespace(string namespace);
    public static string GetSchemaNamespace(int version);
    public static XmlSchemaSet GetManifestSchemaSet(string schemaNamespace);
    public static bool IsKnownSchema(string schemaNamespace);
    [CompilerGeneratedAttribute]
private static XmlSchemaSet <GetManifestSchemaSet>b__1(string schema);
}
[AttributeUsageAttribute("128")]
internal class NuGet.ManifestVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Version { get; private set; }
    public ManifestVersionAttribute(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
}
internal static class NuGet.ManifestVersionUtility : object {
    public static int DefaultVersion;
    public static int SemverVersion;
    public static int TargetFrameworkSupportForDependencyContentsAndToolsVersion;
    public static int TargetFrameworkSupportForReferencesVersion;
    public static int XdtTransformationVersion;
    private static Type[] _xmlAttributes;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestReferenceSet, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestDependencySet, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    private static ManifestVersionUtility();
    public static int GetManifestVersion(ManifestMetadata metadata);
    private static int GetMaxVersionFromMetadata(ManifestMetadata metadata);
    private static int VisitObject(object obj);
    private static int VisitProperty(object obj, PropertyInfo property);
    private static int VisitList(IList list);
    private static int GetPropertyVersion(PropertyInfo property);
    private static bool IsManifestMetadata(PropertyInfo property);
    [CompilerGeneratedAttribute]
private static bool <GetMaxVersionFromMetadata>b__0(ManifestReferenceSet r);
    [CompilerGeneratedAttribute]
private static bool <GetMaxVersionFromMetadata>b__1(ManifestDependencySet d);
}
public class NuGet.MemoryCache : object {
    private static Lazy`1<MemoryCache> _instance;
    private static TimeSpan _cleanupInterval;
    private ConcurrentDictionary`2<object, CacheItem> _cache;
    private Timer _timer;
    [CompilerGeneratedAttribute]
private static Func`1<MemoryCache> CS$<>9__CachedAnonymousMethodDelegate1;
    internal static MemoryCache Instance { get; }
    private static MemoryCache();
    internal static MemoryCache get_Instance();
    internal T GetOrAdd(object cacheKey, Func`1<T> factory, TimeSpan expiration, bool absoluteExpiration);
    internal bool TryGetValue(object cacheKey, T& value);
    internal void Remove(object cacheKey);
    private void RemoveExpiredEntries(object state);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private static MemoryCache <.cctor>b__0();
}
public enum NuGet.MessageLevel : Enum {
    public int value__;
    public static MessageLevel Info;
    public static MessageLevel Warning;
    public static MessageLevel Debug;
    public static MessageLevel Error;
}
public class NuGet.MultipartWebRequest : object {
    private static string FormDataTemplate;
    private static string FileTemplate;
    private static string CrLf;
    private Dictionary`2<string, string> _formData;
    private List`1<PostFileData> _files;
    public MultipartWebRequest(Dictionary`2<string, string> formData);
    public void AddFormData(string key, string value);
    public void AddFile(Func`1<Stream> fileFactory, string fieldName, long length, string contentType);
    public void CreateMultipartRequest(WebRequest request);
    private long CalculateContentLength(string boundary);
}
public class NuGet.NetPortableProfile : object {
    internal static string ProfilePrefix;
    private static NetPortableProfileTable EmptyTable;
    private string _customProfile;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<FrameworkName> <SupportedFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<FrameworkName> <OptionalFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkName, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkName, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public string Name { get; private set; }
    public string FrameworkVersion { get; private set; }
    public ISet`1<FrameworkName> SupportedFrameworks { get; private set; }
    public ISet`1<FrameworkName> OptionalFrameworks { get; private set; }
    public string CustomProfileString { get; }
    public NetPortableProfile(string name, IEnumerable`1<FrameworkName> supportedFrameworks, IEnumerable`1<FrameworkName> optionalFrameworks);
    public NetPortableProfile(string version, string name, IEnumerable`1<FrameworkName> supportedFrameworks, IEnumerable`1<FrameworkName> optionalFrameworks);
    private static NetPortableProfile();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_FrameworkVersion();
    [CompilerGeneratedAttribute]
private void set_FrameworkVersion(string value);
    [CompilerGeneratedAttribute]
public ISet`1<FrameworkName> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
private void set_SupportedFrameworks(ISet`1<FrameworkName> value);
    [CompilerGeneratedAttribute]
public ISet`1<FrameworkName> get_OptionalFrameworks();
    [CompilerGeneratedAttribute]
private void set_OptionalFrameworks(ISet`1<FrameworkName> value);
    public sealed virtual bool Equals(NetPortableProfile other);
    public virtual int GetHashCode();
    public string get_CustomProfileString();
    internal bool IsCompatibleWith(NetPortableProfile projectFrameworkProfile);
    internal bool IsCompatibleWith(NetPortableProfileTable table, FrameworkName projectFramework);
    public static NetPortableProfile Parse(NetPortableProfileTable table, string profileValue, bool treatOptionalFrameworksAsSupportedFrameworks);
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__0(FrameworkName f);
    [CompilerGeneratedAttribute]
private static string <get_CustomProfileString>b__2(FrameworkName f);
    [CompilerGeneratedAttribute]
private bool <IsCompatibleWith>b__4(FrameworkName projectFramework);
}
public class NuGet.NetPortableProfileCollection : KeyedCollection`2<string, NetPortableProfile> {
    protected virtual string GetKeyForItem(NetPortableProfile item);
}
public class NuGet.NetPortableProfileTable : object {
    private static string PortableReferenceAssemblyPathEnvironmentVariableName;
    private CompiledNetPortableProfileCollection _compiled;
    private static NetPortableProfileTable _instance;
    [CompilerGeneratedAttribute]
private static Func`2<NetPortableProfile, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkName, bool> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkName, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    public NetPortableProfileCollection Profiles { get; }
    public static NetPortableProfileTable Instance { get; }
    public NetPortableProfileTable(NetPortableProfileCollection profileCollection);
    public NetPortableProfileCollection get_Profiles();
    public NetPortableProfile GetProfile(string profileName);
    internal static void SetProfileCollection(NetPortableProfileCollection profileCollection);
    internal bool HasCompatibleProfileWith(NetPortableProfile packageFramework, FrameworkName projectOptionalFrameworkName);
    internal static NetPortableProfileCollection BuildPortableProfileCollection();
    private static IEnumerable`1<NetPortableProfile> LoadProfilesFromFramework(string version, string profileFilesPath);
    private static NetPortableProfile LoadPortableProfile(string version, string profileDirectory);
    internal static NetPortableProfile LoadPortableProfile(string version, string profileName, IFileSystem fileSystem, IEnumerable`1<string> frameworkFiles);
    private static bool IsOptionalFramework(FrameworkName framework);
    private static FrameworkName LoadSupportedFramework(IFileSystem fileSystem, string frameworkFile);
    internal static FrameworkName LoadSupportedFramework(Stream stream);
    public static NetPortableProfileTable get_Instance();
    [CompilerGeneratedAttribute]
private static bool <LoadProfilesFromFramework>b__1(NetPortableProfile p);
    [CompilerGeneratedAttribute]
private static bool <LoadPortableProfile>b__7(FrameworkName p);
    [CompilerGeneratedAttribute]
private static bool <LoadPortableProfile>b__8(FrameworkName p);
}
[SuppressMessageAttribute("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors")]
public class NuGet.NuGetVersionNotSatisfiedException : Exception {
    public NuGetVersionNotSatisfiedException(string message);
    public NuGetVersionNotSatisfiedException(string message, Exception innerException);
}
public class NuGet.NullConstraintProvider : object {
    private static NullConstraintProvider _instance;
    public static NullConstraintProvider Instance { get; }
    public string Source { get; }
    private static NullConstraintProvider();
    public static NullConstraintProvider get_Instance();
    public sealed virtual string get_Source();
    public sealed virtual IVersionSpec GetConstraint(string packageId);
}
public class NuGet.NullCredentialProvider : object {
    private static NullCredentialProvider _instance;
    public static ICredentialProvider Instance { get; }
    private static NullCredentialProvider();
    public static ICredentialProvider get_Instance();
    public sealed virtual ICredentials GetCredentials(Uri uri, IWebProxy proxy, CredentialType credentialType, bool retrying);
}
internal class NuGet.NullFileSystem : object {
    private static NullFileSystem _instance;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public static NullFileSystem Instance { get; }
    public ILogger Logger { get; public set; }
    public string Root { get; }
    private static NullFileSystem();
    public static NullFileSystem get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Logger(ILogger value);
    public sealed virtual string get_Root();
    public sealed virtual void DeleteDirectory(string path, bool recursive);
    public sealed virtual IEnumerable`1<string> GetFiles(string path, string filter, bool recursive);
    public sealed virtual IEnumerable`1<string> GetDirectories(string path);
    public sealed virtual string GetFullPath(string path);
    public sealed virtual void DeleteFile(string path);
    public sealed virtual void DeleteFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual void AddFile(string path, Stream stream);
    public sealed virtual void AddFile(string path, Action`1<Stream> writeToStream);
    public sealed virtual void AddFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    public sealed virtual Stream CreateFile(string path);
    public sealed virtual Stream OpenFile(string path);
    public sealed virtual DateTimeOffset GetLastModified(string path);
    public sealed virtual DateTimeOffset GetCreated(string path);
    public sealed virtual DateTimeOffset GetLastAccessed(string path);
    public sealed virtual void MakeFileWritable(string path);
    public sealed virtual void MoveFile(string source, string destination);
}
public class NuGet.NullLogger : object {
    private static ILogger _instance;
    public static ILogger Instance { get; }
    private static NullLogger();
    public static ILogger get_Instance();
    public sealed virtual void Log(MessageLevel level, string message, Object[] args);
    public sealed virtual FileConflictResolution ResolveFileConflict(string message);
}
public class NuGet.NullPropertyProvider : object {
    private static NullPropertyProvider _instance;
    public static NullPropertyProvider Instance { get; }
    private static NullPropertyProvider();
    public static NullPropertyProvider get_Instance();
    public sealed virtual object GetPropertyValue(string propertyName);
}
public class NuGet.NullSettings : object {
    private static NullSettings _settings;
    public static NullSettings Instance { get; }
    private static NullSettings();
    public static NullSettings get_Instance();
    public sealed virtual string GetValue(string section, string key, bool isPath);
    public sealed virtual IList`1<SettingValue> GetValues(string section, bool isPath);
    public sealed virtual IList`1<SettingValue> GetNestedValues(string section, string subsection);
    public sealed virtual void SetValue(string section, string key, string value);
    public sealed virtual void SetValues(string section, IList`1<SettingValue> values);
    public sealed virtual void UpdateSections(string section, IList`1<SettingValue> values);
    public sealed virtual void SetNestedValues(string section, string key, IList`1<KeyValuePair`2<string, string>> values);
    public sealed virtual bool DeleteValue(string section, string key);
    public sealed virtual bool DeleteSection(string section);
}
[ExtensionAttribute]
internal static class NuGet.ObjectExtensions : object {
    [ExtensionAttribute]
public static string ToStringSafe(object obj);
}
public class NuGet.OptimizedZipPackage : LocalPackage {
    private static ConcurrentDictionary`2<PackageName, Tuple`2<string, DateTimeOffset>> _cachedExpandedFolder;
    private static IFileSystem _tempFileSystem;
    private Dictionary`2<string, PhysicalPackageFile> _files;
    private ICollection`1<FrameworkName> _supportedFrameworks;
    private IFileSystem _fileSystem;
    private IFileSystem _expandedFileSystem;
    private string _packagePath;
    private string _expandedFolderPath;
    private bool _forceUseCache;
    [CompilerGeneratedAttribute]
private static Func`2<PhysicalPackageFile, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<PhysicalPackageFile, IPackageAssemblyReference> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<PhysicalPackageFile, FrameworkName> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkName, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    public bool IsValid { get; }
    protected IFileSystem FileSystem { get; }
    public OptimizedZipPackage(string fullPackagePath);
    public OptimizedZipPackage(IFileSystem fileSystem, string packagePath);
    public OptimizedZipPackage(IFileSystem fileSystem, string packagePath, IFileSystem expandedFileSystem);
    internal OptimizedZipPackage(IFileSystem fileSystem, string packagePath, IFileSystem expandedFileSystem, bool forceUseCache);
    private static OptimizedZipPackage();
    public bool get_IsValid();
    protected IFileSystem get_FileSystem();
    public virtual Stream GetStream();
    public virtual void ExtractContents(IFileSystem fileSystem, string extractPath);
    protected virtual IEnumerable`1<IPackageFile> GetFilesBase();
    protected virtual IEnumerable`1<IPackageAssemblyReference> GetAssemblyReferencesCore();
    public virtual IEnumerable`1<FrameworkName> GetSupportedFrameworks();
    private void EnsureManifest();
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
private void EnsurePackageFiles();
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
protected virtual string GetExpandedFolderPath();
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
public static void PurgeCache();
    [CompilerGeneratedAttribute]
private static bool <GetAssemblyReferencesCore>b__0(PhysicalPackageFile file);
    [CompilerGeneratedAttribute]
private static IPackageAssemblyReference <GetAssemblyReferencesCore>b__1(PhysicalPackageFile file);
    [CompilerGeneratedAttribute]
private static FrameworkName <GetSupportedFrameworks>b__4(PhysicalPackageFile c);
    [CompilerGeneratedAttribute]
private static bool <GetSupportedFrameworks>b__5(FrameworkName f);
}
internal class NuGet.OrderingComparer`1 : ExpressionVisitor {
    private Expression _expression;
    private Dictionary`2<ParameterExpression, ParameterExpression> _parameters;
    private bool _inOrderExpression;
    private Stack`1<Ordering`1<TElement, TElement>> _orderings;
    public bool CanCompare { get; }
    public OrderingComparer`1(Expression expression);
    public bool get_CanCompare();
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    public sealed virtual int Compare(TElement x, TElement y);
    private void EnsureOrderings();
}
public enum NuGet.PackageAction : Enum {
    public int value__;
    public static PackageAction Install;
    public static PackageAction Uninstall;
}
public class NuGet.PackageBuilder : object {
    private static string DefaultContentType;
    internal static string ManifestRelationType;
    private bool _includeEmptyDirectories;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<PackageDependencySet> <DependencySets>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<IPackageFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageReferenceSet> <PackageAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, IEnumerable`1<PackageDependency>> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, bool> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependency, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, IEnumerable`1<PackageDependency>> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, IEnumerable`1<PackageDependency>> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, bool> CS$<>9__CachedAnonymousMethodDelegate15;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, string> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<PackageReferenceSet, IEnumerable`1<string>> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestReferenceSet, PackageReferenceSet> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<PackagePart, Uri> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<Uri, PackagePart>, bool> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Predicate`1<PhysicalPackageFile> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<PhysicalPackageFile, string> CS$<>9__CachedAnonymousMethodDelegate27;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate29;
    public string Id { get; public set; }
    public SemanticVersion Version { get; public set; }
    public string Title { get; public set; }
    public ISet`1<string> Authors { get; private set; }
    public ISet`1<string> Owners { get; private set; }
    public Uri IconUrl { get; public set; }
    public Uri LicenseUrl { get; public set; }
    public Uri ProjectUrl { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string Language { get; public set; }
    public ISet`1<string> Tags { get; private set; }
    public string Copyright { get; public set; }
    public Collection`1<PackageDependencySet> DependencySets { get; private set; }
    public Collection`1<IPackageFile> Files { get; private set; }
    public Collection`1<FrameworkAssemblyReference> FrameworkReferences { get; private set; }
    public Collection`1<ManifestContentFiles> ContentFiles { get; private set; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; private set; }
    private IEnumerable`1<string> NuGet.IPackageMetadata.Authors { get; }
    private IEnumerable`1<string> NuGet.IPackageMetadata.Owners { get; }
    private string NuGet.IPackageMetadata.Tags { get; }
    private IEnumerable`1<PackageDependencySet> NuGet.IPackageMetadata.DependencySets { get; }
    private IEnumerable`1<FrameworkAssemblyReference> NuGet.IPackageMetadata.FrameworkAssemblies { get; }
    public Version MinClientVersion { get; public set; }
    private static IEnumerable`1<string> KnownFoldersForV3 { get; }
    public PackageBuilder(string path, IPropertyProvider propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, string basePath, IPropertyProvider propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(Stream stream, string basePath);
    public PackageBuilder(Stream stream, string basePath, IPropertyProvider propertyProvider);
    private PackageBuilder(bool includeEmptyDirectories);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual SemanticVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(SemanticVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public Collection`1<PackageDependencySet> get_DependencySets();
    [CompilerGeneratedAttribute]
private void set_DependencySets(Collection`1<PackageDependencySet> value);
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<IPackageFile> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(Collection`1<IPackageFile> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferences(Collection`1<FrameworkAssemblyReference> value);
    [CompilerGeneratedAttribute]
public Collection`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
private void set_ContentFiles(Collection`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    [CompilerGeneratedAttribute]
private void set_PackageAssemblyReferences(ICollection`1<PackageReferenceSet> value);
    private sealed virtual override IEnumerable`1<string> NuGet.IPackageMetadata.get_Authors();
    private sealed virtual override IEnumerable`1<string> NuGet.IPackageMetadata.get_Owners();
    private sealed virtual override string NuGet.IPackageMetadata.get_Tags();
    private sealed virtual override IEnumerable`1<PackageDependencySet> NuGet.IPackageMetadata.get_DependencySets();
    private sealed virtual override IEnumerable`1<FrameworkAssemblyReference> NuGet.IPackageMetadata.get_FrameworkAssemblies();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(Version value);
    public sealed virtual void Save(Stream stream);
    private static string CreatorInfo();
    private static int DetermineMinimumSchemaVersion(Collection`1<IPackageFile> Files, Collection`1<PackageDependencySet> package);
    private static bool RequiresV4TargetFrameworkSchema(ICollection`1<IPackageFile> files);
    private static bool HasContentFilesV2(ICollection`1<IPackageFile> contentFiles);
    private static bool HasIncludeExclude(IEnumerable`1<PackageDependencySet> dependencySets);
    private static bool HasXdtTransformFile(ICollection`1<IPackageFile> contentFiles);
    internal static void ValidateDependencySets(SemanticVersion version, IEnumerable`1<PackageDependencySet> dependencies);
    internal static void ValidateReferenceAssemblies(IEnumerable`1<IPackageFile> files, IEnumerable`1<PackageReferenceSet> packageAssemblyReferences);
    private void ReadManifest(Stream stream, string basePath, IPropertyProvider propertyProvider);
    public void Populate(ManifestMetadata manifestMetadata);
    public void PopulateFiles(string basePath, IEnumerable`1<ManifestFile> files);
    private void WriteManifest(Package package, int minimumManifestVersion);
    private void WriteFiles(Package package);
    private void AddFiles(string basePath, string source, string destination, string exclude);
    private static bool IsKnownV3Folder(string targetPath);
    private static IEnumerable`1<string> get_KnownFoldersForV3();
    private static void ExcludeFiles(List`1<PhysicalPackageFile> searchFiles, string basePath, string exclude);
    private static void CreatePart(Package package, string path, Stream sourceStream);
    private static IEnumerable`1<string> ParseTags(string tags);
    private static bool IsPrereleaseDependency(PackageDependency dependency);
    private static bool ValidateSpecialVersionLength(SemanticVersion version);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PackageDependency> <Save>b__0(PackageDependencySet d);
    [CompilerGeneratedAttribute]
private static bool <RequiresV4TargetFrameworkSchema>b__2(IPackageFile f);
    [CompilerGeneratedAttribute]
private static bool <RequiresV4TargetFrameworkSchema>b__3(IPackageFile f);
    [CompilerGeneratedAttribute]
private static bool <HasContentFilesV2>b__6(IPackageFile file);
    [CompilerGeneratedAttribute]
private static bool <HasIncludeExclude>b__8(PackageDependencySet dependencyGroup);
    [CompilerGeneratedAttribute]
private static bool <HasIncludeExclude>b__9(PackageDependency dependency);
    [CompilerGeneratedAttribute]
private static bool <HasXdtTransformFile>b__c(IPackageFile file);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PackageDependency> <ValidateDependencySets>b__e(PackageDependencySet s);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PackageDependency> <ValidateDependencySets>b__f(PackageDependencySet set);
    [CompilerGeneratedAttribute]
private static bool <ValidateReferenceAssemblies>b__12(IPackageFile file);
    [CompilerGeneratedAttribute]
private static string <ValidateReferenceAssemblies>b__13(IPackageFile file);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<string> <ValidateReferenceAssemblies>b__14(PackageReferenceSet p);
    [CompilerGeneratedAttribute]
private static PackageReferenceSet <Populate>b__18(ManifestReferenceSet r);
    [CompilerGeneratedAttribute]
private static Uri <WriteFiles>b__1a(PackagePart s);
    [CompilerGeneratedAttribute]
private static bool <WriteFiles>b__1b(IGrouping`2<Uri, PackagePart> _);
    [CompilerGeneratedAttribute]
private static bool <AddFiles>b__1e(PhysicalPackageFile file);
    [CompilerGeneratedAttribute]
private static string <ExcludeFiles>b__26(PhysicalPackageFile p);
    [CompilerGeneratedAttribute]
private static string <ParseTags>b__28(string tag);
}
public class NuGet.PackageComparer : object {
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static PackageComparer Version;
    private Func`3<IPackage, IPackage, int> _compareTo;
    [CompilerGeneratedAttribute]
private static Func`3<IPackage, IPackage, int> CS$<>9__CachedAnonymousMethodDelegate1;
    private PackageComparer(Func`3<IPackage, IPackage, int> compareTo);
    private static PackageComparer();
    public sealed virtual int Compare(IPackage x, IPackage y);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__0(IPackage x, IPackage y);
}
public class NuGet.PackageDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IVersionSpec <VersionSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    public string Id { get; private set; }
    public IVersionSpec VersionSpec { get; private set; }
    public string Include { get; private set; }
    public string Exclude { get; private set; }
    public PackageDependency(string id);
    public PackageDependency(string id, IVersionSpec versionSpec);
    public PackageDependency(string id, IVersionSpec versionSpec, string include, string exclude);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public IVersionSpec get_VersionSpec();
    [CompilerGeneratedAttribute]
private void set_VersionSpec(IVersionSpec value);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
private void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
private void set_Exclude(string value);
    public virtual string ToString();
    internal static PackageDependency CreateDependency(string id, string versionSpec);
}
public class NuGet.PackageDependencySet : object {
    private FrameworkName _targetFramework;
    private ReadOnlyCollection`1<PackageDependency> _dependencies;
    public FrameworkName TargetFramework { get; }
    public ICollection`1<PackageDependency> Dependencies { get; }
    public IEnumerable`1<FrameworkName> SupportedFrameworks { get; }
    public PackageDependencySet(FrameworkName targetFramework, IEnumerable`1<PackageDependency> dependencies);
    public FrameworkName get_TargetFramework();
    public ICollection`1<PackageDependency> get_Dependencies();
    public sealed virtual IEnumerable`1<FrameworkName> get_SupportedFrameworks();
}
public class NuGet.PackageDownloader : object {
    private static string DefaultUserAgentClient;
    private EventHandler`1<ProgressEventArgs> ProgressAvailable;
    private EventHandler`1<WebRequestEventArgs> SendingRequest;
    [CompilerGeneratedAttribute]
private string <CurrentDownloadPackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ProgressEventArgs> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static EventHandler`1<WebRequestEventArgs> CS$<>9__CachedAnonymousMethodDelegate7;
    public string CurrentDownloadPackageId { get; private set; }
    public sealed virtual void add_ProgressAvailable(EventHandler`1<ProgressEventArgs> value);
    public sealed virtual void remove_ProgressAvailable(EventHandler`1<ProgressEventArgs> value);
    public sealed virtual void add_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
    public sealed virtual void remove_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public string get_CurrentDownloadPackageId();
    [CompilerGeneratedAttribute]
private void set_CurrentDownloadPackageId(string value);
    public virtual void DownloadPackage(Uri uri, IPackageMetadata package, Stream targetStream);
    public void DownloadPackage(IHttpClient downloadClient, IPackageName package, Stream targetStream);
    private void OnPackageDownloadProgress(ProgressEventArgs e);
    private void OnSendingRequest(object sender, WebRequestEventArgs webRequestArgs);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__4(object param0, ProgressEventArgs param1);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__5(object param0, WebRequestEventArgs param1);
}
public class NuGet.PackageEqualityComparer : object {
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static PackageEqualityComparer IdAndVersion;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static PackageEqualityComparer Id;
    private Func`3<IPackageName, IPackageName, bool> _equals;
    private Func`2<IPackageName, int> _getHashCode;
    [CompilerGeneratedAttribute]
private static Func`3<IPackageName, IPackageName, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageName, int> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`3<IPackageName, IPackageName, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageName, int> CS$<>9__CachedAnonymousMethodDelegate7;
    private PackageEqualityComparer(Func`3<IPackageName, IPackageName, bool> equals, Func`2<IPackageName, int> getHashCode);
    private static PackageEqualityComparer();
    public sealed virtual bool Equals(IPackageName x, IPackageName y);
    public sealed virtual int GetHashCode(IPackageName obj);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__0(IPackageName x, IPackageName y);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__1(IPackageName x);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__2(IPackageName x, IPackageName y);
    [CompilerGeneratedAttribute]
private static int <.cctor>b__3(IPackageName x);
}
[ExtensionAttribute]
public static class NuGet.PackageExtensions : object {
    private static string TagsProperty;
    private static String[] _packagePropertiesToSearch;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, IEnumerable`1<PackageDependency>> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, bool> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageRule, bool> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, IEnumerable`1<PackageDependency>> CS$<>9__CachedAnonymousMethodDelegate16;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, IPackage>, IPackage> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, bool> CS$<>9__CachedAnonymousMethodDelegate1e;
    private static PackageExtensions();
    [ExtensionAttribute]
public static bool IsReleaseVersion(IPackageName packageMetadata);
    [ExtensionAttribute]
public static bool IsListed(IPackage package);
    [ExtensionAttribute]
public static bool IsSatellitePackage(IPackageMetadata package);
    [ExtensionAttribute]
public static bool IsEmptyFolder(IPackageFile packageFile);
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> FindByVersion(IEnumerable`1<IPackage> source, IVersionSpec versionSpec);
    [ExtensionAttribute]
public static IEnumerable`1<IPackageFile> GetFiles(IPackage package, string directory);
    [ExtensionAttribute]
public static IEnumerable`1<IPackageFile> GetContentFiles(IPackage package);
    [ExtensionAttribute]
public static IEnumerable`1<IPackageFile> GetToolFiles(IPackage package);
    [ExtensionAttribute]
public static IEnumerable`1<IPackageFile> GetBuildFiles(IPackage package);
    [ExtensionAttribute]
public static IEnumerable`1<IPackageFile> GetLibFiles(IPackage package);
    [ExtensionAttribute]
public static bool HasFileWithNullTargetFramework(IPackage package);
    [ExtensionAttribute]
public static IEnumerable`1<IPackageFile> GetSatelliteFiles(IPackage package);
    [ExtensionAttribute]
public static IEnumerable`1<PackageIssue> Validate(IPackage package, IEnumerable`1<IPackageRule> rules);
    [ExtensionAttribute]
public static string GetHash(IPackage package, string hashAlgorithm);
    [ExtensionAttribute]
public static string GetHash(IPackage package, IHashProvider hashProvider);
    [ExtensionAttribute]
public static bool HasProjectContent(IPackage package);
    [ExtensionAttribute]
public static IEnumerable`1<PackageDependency> GetCompatiblePackageDependencies(IPackageMetadata package, FrameworkName targetFramework);
    [ExtensionAttribute]
public static string GetFullName(IPackageName package);
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> AsCollapsed(IEnumerable`1<IPackage> source);
    [ExtensionAttribute]
internal static IEnumerable`1<IPackage> CollapseById(IEnumerable`1<IPackage> source);
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> FilterByPrerelease(IEnumerable`1<IPackage> packages, bool allowPrerelease);
    [ExtensionAttribute]
public static IQueryable`1<T> Find(IQueryable`1<T> packages, string searchText);
    [ExtensionAttribute]
public static IQueryable`1<T> Find(IQueryable`1<T> packages, IEnumerable`1<string> propertiesToSearch, string searchText);
    [ExtensionAttribute]
private static IQueryable`1<T> Find(IQueryable`1<T> packages, IEnumerable`1<string> propertiesToSearch, IEnumerable`1<string> searchTerms);
    [ExtensionAttribute]
public static IQueryable`1<T> FindLatestVersion(IQueryable`1<T> packages);
    private static Expression`1<Func`2<T, bool>> BuildSearchExpression(IEnumerable`1<string> propertiesToSearch, IEnumerable`1<string> searchTerms);
    [SuppressMessageAttribute("Microsoft.Globalization", "CA1304:SpecifyCultureInfo")]
private static Expression BuildExpressionForTerm(ParameterExpression packageParameterExpression, string term, string propertyName);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PackageDependency> <IsSatellitePackage>b__0(PackageDependencySet s);
    [CompilerGeneratedAttribute]
private static bool <HasFileWithNullTargetFramework>b__b(IPackageFile file);
    [CompilerGeneratedAttribute]
private static bool <Validate>b__10(IPackageRule r);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PackageDependency> <GetCompatiblePackageDependencies>b__15(PackageDependencySet d);
    [CompilerGeneratedAttribute]
private static string <CollapseById>b__17(IPackage p);
    [CompilerGeneratedAttribute]
private static IPackage <CollapseById>b__18(IGrouping`2<string, IPackage> g);
    [CompilerGeneratedAttribute]
private static SemanticVersion <CollapseById>b__19(IPackage p);
    [CompilerGeneratedAttribute]
private static bool <FilterByPrerelease>b__1d(IPackage p);
    [CompilerGeneratedAttribute]
private static bool <Find>b__1f(string s);
}
public static class NuGet.PackageHelper : object {
    public static bool IsManifest(string path);
    public static bool IsPackageManifest(string path, string packageId);
    public static bool IsUnzippedPackageManifest(string path, string packageId, SemanticVersion packageVersion);
    public static bool IsPackageFile(string path);
    public static bool IsAssembly(string path);
    [SuppressMessageAttribute("Microsoft.Design", "CA1021:AvoidOutParameters")]
public static bool IsSatellitePackage(IPackageMetadata package, IPackageRepository repository, FrameworkName targetFramework, IPackage& runtimePackage);
    public static IPackage ResolvePackage(IPackageRepository repository, string packageId, SemanticVersion version);
    internal static Stream GetManifestStream(Stream packageStream);
}
public static class NuGet.PackageIdValidator : object {
    internal static int MaxPackageIdLength;
    private static Regex _idRegex;
    private static PackageIdValidator();
    public static bool IsValidPackageId(string packageId);
    public static void ValidatePackageId(string packageId);
}
public class NuGet.PackageIssue : object {
    [CompilerGeneratedAttribute]
private PackageIssueLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Solution>k__BackingField;
    public PackageIssueLevel Level { get; private set; }
    public string Title { get; private set; }
    public string Description { get; private set; }
    public string Solution { get; private set; }
    public PackageIssue(string title, string description, string solution);
    public PackageIssue(string title, string description, string solution, PackageIssueLevel level);
    [CompilerGeneratedAttribute]
public PackageIssueLevel get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(PackageIssueLevel value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
private void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Solution();
    [CompilerGeneratedAttribute]
private void set_Solution(string value);
    public virtual string ToString();
}
public enum NuGet.PackageIssueLevel : Enum {
    public int value__;
    public static PackageIssueLevel Warning;
    public static PackageIssueLevel Error;
}
public class NuGet.PackageManager : object {
    private ILogger _logger;
    private EventHandler`1<PackageOperationEventArgs> PackageInstalling;
    private EventHandler`1<PackageOperationEventArgs> PackageInstalled;
    private EventHandler`1<PackageOperationEventArgs> PackageUninstalling;
    private EventHandler`1<PackageOperationEventArgs> PackageUninstalled;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageRepository <SourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageRepository <LocalRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackagePathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyVersion <DependencyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WhatIf>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipPackageTargetCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckDowngrade>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, string> CS$<>9__CachedAnonymousMethodDelegate2;
    public IFileSystem FileSystem { get; public set; }
    public IPackageRepository SourceRepository { get; private set; }
    public IPackageRepository LocalRepository { get; private set; }
    public IPackagePathResolver PathResolver { get; private set; }
    public ILogger Logger { get; public set; }
    public DependencyVersion DependencyVersion { get; public set; }
    public bool WhatIf { get; public set; }
    public bool SkipPackageTargetCheck { get; public set; }
    public bool CheckDowngrade { get; public set; }
    public PackageManager(IPackageRepository sourceRepository, string path);
    public PackageManager(IPackageRepository sourceRepository, IPackagePathResolver pathResolver, IFileSystem fileSystem);
    public PackageManager(IPackageRepository sourceRepository, IPackagePathResolver pathResolver, IFileSystem fileSystem, IPackageRepository localRepository);
    public sealed virtual void add_PackageInstalling(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void remove_PackageInstalling(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void add_PackageInstalled(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void remove_PackageInstalled(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void add_PackageUninstalling(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void remove_PackageUninstalling(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void add_PackageUninstalled(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void remove_PackageUninstalled(EventHandler`1<PackageOperationEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FileSystem(IFileSystem value);
    [CompilerGeneratedAttribute]
public sealed virtual IPackageRepository get_SourceRepository();
    [CompilerGeneratedAttribute]
private void set_SourceRepository(IPackageRepository value);
    [CompilerGeneratedAttribute]
public sealed virtual IPackageRepository get_LocalRepository();
    [CompilerGeneratedAttribute]
private void set_LocalRepository(IPackageRepository value);
    [CompilerGeneratedAttribute]
public sealed virtual IPackagePathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
private void set_PathResolver(IPackagePathResolver value);
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public sealed virtual DependencyVersion get_DependencyVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DependencyVersion(DependencyVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WhatIf();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WhatIf(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipPackageTargetCheck();
    [CompilerGeneratedAttribute]
public void set_SkipPackageTargetCheck(bool value);
    public void InstallPackage(string packageId);
    public void InstallPackage(string packageId, SemanticVersion version);
    public virtual void InstallPackage(string packageId, SemanticVersion version, bool ignoreDependencies, bool allowPrereleaseVersions);
    public virtual void InstallPackage(IPackage package, bool ignoreDependencies, bool allowPrereleaseVersions);
    public sealed virtual void InstallPackage(IPackage package, bool ignoreDependencies, bool allowPrereleaseVersions, bool ignoreWalkInfo);
    protected void InstallPackage(IPackage package, FrameworkName targetFramework, bool ignoreDependencies, bool allowPrereleaseVersions, bool ignoreWalkInfo);
    private void Execute(IPackage package, IPackageOperationResolver resolver);
    protected void Execute(PackageOperation operation);
    protected void ExecuteInstall(IPackage package);
    private void ExpandFiles(IPackage package);
    protected void ExpandSatellitePackageFiles(IPackage package);
    public void UninstallPackage(string packageId);
    public void UninstallPackage(string packageId, SemanticVersion version);
    public void UninstallPackage(string packageId, SemanticVersion version, bool forceRemove);
    public virtual void UninstallPackage(string packageId, SemanticVersion version, bool forceRemove, bool removeDependencies);
    public void UninstallPackage(IPackage package);
    public void UninstallPackage(IPackage package, bool forceRemove);
    public virtual void UninstallPackage(IPackage package, bool forceRemove, bool removeDependencies);
    protected virtual void ExecuteUninstall(IPackage package);
    private void RemoveFiles(IPackage package);
    protected virtual void OnInstalling(PackageOperationEventArgs e);
    protected virtual void OnExpandFiles(PackageOperationEventArgs e);
    protected virtual void OnInstalled(PackageOperationEventArgs e);
    protected virtual void OnUninstalling(PackageOperationEventArgs e);
    protected virtual void OnRemoveFiles(PackageOperationEventArgs e);
    protected virtual void OnUninstalled(PackageOperationEventArgs e);
    private PackageOperationEventArgs CreateOperation(IPackage package);
    public void UpdatePackage(string packageId, bool updateDependencies, bool allowPrereleaseVersions);
    public sealed virtual void UpdatePackage(string packageId, IVersionSpec versionSpec, bool updateDependencies, bool allowPrereleaseVersions);
    public sealed virtual void UpdatePackage(string packageId, SemanticVersion version, bool updateDependencies, bool allowPrereleaseVersions);
    internal void UpdatePackage(string packageId, Func`1<IPackage> resolvePackage, bool updateDependencies, bool allowPrereleaseVersions);
    public sealed virtual void UpdatePackage(IPackage newPackage, bool updateDependencies, bool allowPrereleaseVersions);
    [CompilerGeneratedAttribute]
public bool get_CheckDowngrade();
    [CompilerGeneratedAttribute]
public void set_CheckDowngrade(bool value);
    [CompilerGeneratedAttribute]
private static string <ExpandFiles>b__1(IPackageFile p);
}
public class NuGet.PackageMarker : object {
    private Dictionary`2<string, Dictionary`2<IPackage, VisitedState>> _visited;
    private Dictionary`2<IPackage, HashSet`1<IPackage>> _dependents;
    [CompilerGeneratedAttribute]
private static Func`2<Dictionary`2<IPackage, VisitedState>, IEnumerable`1<IPackage>> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<VisitedState, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    public string Source { get; }
    public PackageSaveModes PackageSaveMode { get; public set; }
    public bool SupportsPrereleasePackages { get; }
    public IEnumerable`1<IPackage> Packages { get; }
    public sealed virtual string get_Source();
    public sealed virtual void set_PackageSaveMode(PackageSaveModes value);
    public sealed virtual PackageSaveModes get_PackageSaveMode();
    public sealed virtual bool get_SupportsPrereleasePackages();
    public IEnumerable`1<IPackage> get_Packages();
    public bool Contains(IPackage package);
    public void MarkProcessing(IPackage package);
    public void MarkVisited(IPackage package);
    public bool IsVersionCycle(string packageId);
    public bool IsVisited(IPackage package);
    public bool IsCycle(IPackage package);
    public void Clear();
    private sealed virtual override IQueryable`1<IPackage> NuGet.IPackageRepository.GetPackages();
    private sealed virtual override void NuGet.IPackageRepository.AddPackage(IPackage package);
    private sealed virtual override void NuGet.IPackageRepository.RemovePackage(IPackage package);
    private sealed virtual override IEnumerable`1<IPackage> NuGet.IDependentsResolver.GetDependents(IPackage package);
    public void AddDependent(IPackage package, IPackage dependency);
    private Dictionary`2<IPackage, VisitedState> GetLookup(string packageId, bool createEntry);
    public sealed virtual bool Exists(string packageId, SemanticVersion version);
    public sealed virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public sealed virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<IPackage> <get_Packages>b__0(Dictionary`2<IPackage, VisitedState> p);
    [CompilerGeneratedAttribute]
private static bool <IsVersionCycle>b__2(VisitedState state);
}
public class NuGet.PackageName : object {
    private string _packageId;
    private SemanticVersion _version;
    public string Id { get; }
    public SemanticVersion Version { get; }
    public string Name { get; }
    public PackageName(string packageId, SemanticVersion version);
    public sealed virtual string get_Id();
    public sealed virtual SemanticVersion get_Version();
    public string get_Name();
    public sealed virtual bool Equals(PackageName other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NuGet.PackageOperation : object {
    [CompilerGeneratedAttribute]
private IPackage <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageAction <Action>k__BackingField;
    public IPackage Package { get; private set; }
    public PackageAction Action { get; private set; }
    public PackageOperation(IPackage package, PackageAction action);
    [CompilerGeneratedAttribute]
public IPackage get_Package();
    [CompilerGeneratedAttribute]
private void set_Package(IPackage value);
    [CompilerGeneratedAttribute]
public PackageAction get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(PackageAction value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.PackageOperationEventArgs : CancelEventArgs {
    [CompilerGeneratedAttribute]
private string <InstallPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackage <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    public string InstallPath { get; private set; }
    public IPackage Package { get; private set; }
    public IFileSystem FileSystem { get; private set; }
    public PackageOperationEventArgs(IPackage package, IFileSystem fileSystem, string installPath);
    [CompilerGeneratedAttribute]
public string get_InstallPath();
    [CompilerGeneratedAttribute]
private void set_InstallPath(string value);
    [CompilerGeneratedAttribute]
public IPackage get_Package();
    [CompilerGeneratedAttribute]
private void set_Package(IPackage value);
    [CompilerGeneratedAttribute]
public IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(IFileSystem value);
}
[ExtensionAttribute]
public static class NuGet.PackageOperationExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`3<PackageOperation, int, IndexedPackageOperation> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<IndexedPackageOperation, object> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<object, IndexedPackageOperation>, object> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<object, IndexedPackageOperation>, List`1<IndexedPackageOperation>> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<object, List`1<IndexedPackageOperation>>, IEnumerable`1<IndexedPackageOperation>> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Comparison`1<IndexedPackageOperation> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<IndexedPackageOperation, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<IndexedPackageOperation, bool> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<IndexedPackageOperation, PackageOperation> CS$<>9__CachedAnonymousMethodDelegate11;
    [ExtensionAttribute]
public static IList`1<PackageOperation> Reduce(IEnumerable`1<PackageOperation> operations);
    [ExtensionAttribute]
private static IList`1<PackageOperation> Reorder(List`1<IndexedPackageOperation> operations);
    private static object GetOperationKey(PackageOperation operation);
    private static object GetOpposingOperationKey(PackageOperation operation);
    [CompilerGeneratedAttribute]
private static IndexedPackageOperation <Reduce>b__0(PackageOperation o, int index);
    [CompilerGeneratedAttribute]
private static object <Reduce>b__1(IndexedPackageOperation o);
    [CompilerGeneratedAttribute]
private static object <Reduce>b__2(IGrouping`2<object, IndexedPackageOperation> g);
    [CompilerGeneratedAttribute]
private static List`1<IndexedPackageOperation> <Reduce>b__3(IGrouping`2<object, IndexedPackageOperation> g);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<IndexedPackageOperation> <Reduce>b__4(KeyValuePair`2<object, List`1<IndexedPackageOperation>> o);
    [CompilerGeneratedAttribute]
private static int <Reorder>b__a(IndexedPackageOperation a, IndexedPackageOperation b);
    [CompilerGeneratedAttribute]
private static bool <Reorder>b__b(IndexedPackageOperation s);
    [CompilerGeneratedAttribute]
private static bool <Reorder>b__c(IndexedPackageOperation s);
    [CompilerGeneratedAttribute]
private static PackageOperation <Reorder>b__d(IndexedPackageOperation o);
}
public class NuGet.PackageReference : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IVersionSpec <VersionConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameworkName <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireReinstallation>k__BackingField;
    public string Id { get; private set; }
    public SemanticVersion Version { get; private set; }
    public IVersionSpec VersionConstraint { get; public set; }
    public FrameworkName TargetFramework { get; private set; }
    public bool IsDevelopmentDependency { get; private set; }
    public bool RequireReinstallation { get; private set; }
    public PackageReference(string id, SemanticVersion version, IVersionSpec versionConstraint, FrameworkName targetFramework, bool isDevelopmentDependency, bool requireReinstallation);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(string value);
    [CompilerGeneratedAttribute]
public SemanticVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(SemanticVersion value);
    [CompilerGeneratedAttribute]
public IVersionSpec get_VersionConstraint();
    [CompilerGeneratedAttribute]
public void set_VersionConstraint(IVersionSpec value);
    [CompilerGeneratedAttribute]
public FrameworkName get_TargetFramework();
    [CompilerGeneratedAttribute]
private void set_TargetFramework(FrameworkName value);
    [CompilerGeneratedAttribute]
public bool get_IsDevelopmentDependency();
    [CompilerGeneratedAttribute]
private void set_IsDevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequireReinstallation();
    [CompilerGeneratedAttribute]
private void set_RequireReinstallation(bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(PackageReference other);
}
public class NuGet.PackageReferenceFile : object {
    private IFileSystem _fileSystem;
    private string _path;
    private Dictionary`2<string, string> _constraints;
    private Dictionary`2<string, string> _developmentFlags;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousTypee`2<XElement, string>> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypee`2<XElement, string>, <>f__AnonymousTypef`2<<>f__AnonymousTypee`2<XElement, string>, SemanticVersion>> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<XElement, string>, SemanticVersion>, bool> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<XElement, string>, SemanticVersion>, XElement> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousType10`2<XElement, string>> CS$<>9__CachedAnonymousMethodDelegate26;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType10`2<XElement, string>, <>f__AnonymousType11`2<<>f__AnonymousType10`2<XElement, string>, string>> CS$<>9__CachedAnonymousMethodDelegate27;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<XElement, string>, string>, bool> CS$<>9__CachedAnonymousMethodDelegate28;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<XElement, string>, string>, string> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType11`2<<>f__AnonymousType10`2<XElement, string>, string>, XElement> CS$<>9__CachedAnonymousMethodDelegate2a;
    public string FullPath { get; }
    public PackageReferenceFile(string path);
    public PackageReferenceFile(IFileSystem fileSystem, string path);
    public PackageReferenceFile(IFileSystem fileSystem, string path, string projectName);
    public static PackageReferenceFile CreateFromProject(string projectFileFullPath);
    public static bool IsValidConfigFileName(string fileName);
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
public IEnumerable`1<PackageReference> GetPackageReferences();
    public IEnumerable`1<PackageReference> GetPackageReferences(bool requireVersion);
    public bool DeleteEntry(string id, SemanticVersion version);
    public bool EntryExists(string packageId, SemanticVersion version);
    public void AddEntry(string id, SemanticVersion version);
    public void AddEntry(string id, SemanticVersion version, bool developmentDependency);
    public void AddEntry(string id, SemanticVersion version, bool developmentDependency, FrameworkName targetFramework);
    public void MarkEntryForReinstallation(string id, SemanticVersion version, FrameworkName targetFramework, bool requireReinstallation);
    public string get_FullPath();
    private void AddEntry(XDocument document, string id, SemanticVersion version, bool developmentDependency, FrameworkName targetFramework);
    private void AddEntry(XDocument document, string id, SemanticVersion version, bool developmentDependency, FrameworkName targetFramework, bool requireReinstallation);
    private static XElement FindEntry(XDocument document, string id, SemanticVersion version);
    private void SaveDocument(XDocument document);
    private bool DeleteEntry(XDocument document, string id, SemanticVersion version);
    private XDocument GetDocument(bool createIfNotExists);
    private static string ConstructPackagesConfigFromProjectName(string projectName);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTypee`2<XElement, string> <FindEntry>b__14(XElement e);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTypef`2<<>f__AnonymousTypee`2<XElement, string>, SemanticVersion> <FindEntry>b__15(<>f__AnonymousTypee`2<XElement, string> <>h__TransparentIdentifier12);
    [CompilerGeneratedAttribute]
private static bool <FindEntry>b__16(<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<XElement, string>, SemanticVersion> <>h__TransparentIdentifier13);
    [CompilerGeneratedAttribute]
private static XElement <FindEntry>b__18(<>f__AnonymousTypef`2<<>f__AnonymousTypee`2<XElement, string>, SemanticVersion> <>h__TransparentIdentifier13);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType10`2<XElement, string> <SaveDocument>b__21(XElement e);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType11`2<<>f__AnonymousType10`2<XElement, string>, string> <SaveDocument>b__22(<>f__AnonymousType10`2<XElement, string> <>h__TransparentIdentifier1f);
    [CompilerGeneratedAttribute]
private static bool <SaveDocument>b__23(<>f__AnonymousType11`2<<>f__AnonymousType10`2<XElement, string>, string> <>h__TransparentIdentifier20);
    [CompilerGeneratedAttribute]
private static string <SaveDocument>b__24(<>f__AnonymousType11`2<<>f__AnonymousType10`2<XElement, string>, string> <>h__TransparentIdentifier20);
    [CompilerGeneratedAttribute]
private static XElement <SaveDocument>b__25(<>f__AnonymousType11`2<<>f__AnonymousType10`2<XElement, string>, string> <>h__TransparentIdentifier20);
}
public class NuGet.PackageReferenceRepository : object {
    private PackageReferenceFile _packageReferenceFile;
    private string _fullPath;
    [CompilerGeneratedAttribute]
private ISharedPackageRepository <SourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<PackageReference, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<PackageReference, bool> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<PackageReference, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate9;
    public string Source { get; }
    public PackageSaveModes PackageSaveMode { get; public set; }
    public bool SupportsPrereleasePackages { get; }
    private ISharedPackageRepository SourceRepository { get; private set; }
    private string PackageReferenceFileFullPath { get; }
    public PackageReferenceFile ReferenceFile { get; }
    public PackageReferenceRepository(IFileSystem fileSystem, string projectName, ISharedPackageRepository sourceRepository);
    public PackageReferenceRepository(string configFilePath, ISharedPackageRepository sourceRepository);
    public sealed virtual string get_Source();
    public sealed virtual PackageSaveModes get_PackageSaveMode();
    public sealed virtual void set_PackageSaveMode(PackageSaveModes value);
    public sealed virtual bool get_SupportsPrereleasePackages();
    [CompilerGeneratedAttribute]
private ISharedPackageRepository get_SourceRepository();
    [CompilerGeneratedAttribute]
private void set_SourceRepository(ISharedPackageRepository value);
    private string get_PackageReferenceFileFullPath();
    public PackageReferenceFile get_ReferenceFile();
    public sealed virtual IQueryable`1<IPackage> GetPackages();
    private IEnumerable`1<IPackage> GetPackagesCore();
    public sealed virtual void AddPackage(IPackage package);
    public sealed virtual void RemovePackage(IPackage package);
    public sealed virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public sealed virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
    public sealed virtual bool Exists(string packageId, SemanticVersion version);
    public void RegisterIfNecessary();
    public sealed virtual IVersionSpec GetConstraint(string packageId);
    public sealed virtual bool TryFindLatestPackageById(string id, SemanticVersion& latestVersion);
    public sealed virtual bool TryFindLatestPackageById(string id, bool includePrerelease, IPackage& package);
    public sealed virtual void AddPackage(string packageId, SemanticVersion version, bool developmentDependency, FrameworkName targetFramework);
    public sealed virtual FrameworkName GetPackageTargetFramework(string packageId);
    private PackageReference GetPackageReference(string packageId);
    private IEnumerable`1<PackageReference> GetPackageReferences(string packageId);
    private IPackage GetPackage(PackageReference reference);
    private static bool IsValidReference(PackageReference reference);
    [CompilerGeneratedAttribute]
private static bool <GetPackagesCore>b__0(IPackage p);
    [CompilerGeneratedAttribute]
private static bool <FindPackagesById>b__2(IPackage p);
    [CompilerGeneratedAttribute]
private static SemanticVersion <TryFindLatestPackageById>b__4(PackageReference r);
    [CompilerGeneratedAttribute]
private static bool <TryFindLatestPackageById>b__6(PackageReference r);
    [CompilerGeneratedAttribute]
private static SemanticVersion <TryFindLatestPackageById>b__7(PackageReference r);
}
public class NuGet.PackageReferenceSet : object {
    private FrameworkName _targetFramework;
    private ICollection`1<string> _references;
    [CompilerGeneratedAttribute]
private static Func`2<ManifestReference, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public ICollection`1<string> References { get; }
    public FrameworkName TargetFramework { get; }
    public IEnumerable`1<FrameworkName> SupportedFrameworks { get; }
    public PackageReferenceSet(FrameworkName targetFramework, IEnumerable`1<string> references);
    public PackageReferenceSet(ManifestReferenceSet manifestReferenceSet);
    public ICollection`1<string> get_References();
    public FrameworkName get_TargetFramework();
    public sealed virtual IEnumerable`1<FrameworkName> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
private static string <.ctor>b__0(ManifestReference r);
}
public abstract class NuGet.PackageRepositoryBase : object {
    private ILogger _logger;
    private PackageSaveModes _packageSave;
    public string Source { get; }
    public ILogger Logger { get; public set; }
    public PackageSaveModes PackageSaveMode { get; public set; }
    public bool SupportsPrereleasePackages { get; }
    public abstract virtual string get_Source();
    public ILogger get_Logger();
    public void set_Logger(ILogger value);
    public sealed virtual PackageSaveModes get_PackageSaveMode();
    public sealed virtual void set_PackageSaveMode(PackageSaveModes value);
    public abstract virtual IQueryable`1<IPackage> GetPackages();
    public abstract virtual bool get_SupportsPrereleasePackages();
    public virtual void AddPackage(IPackage package);
    public virtual void RemovePackage(IPackage package);
}
[ExtensionAttribute]
public static class NuGet.PackageRepositoryExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType20`2<<>f__AnonymousType1f`2<IPackage, PackageDependency>, IVersionSpec>, IPackage> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate26;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, bool> CS$<>9__CachedAnonymousMethodDelegate2f;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageName, string> CS$<>9__CachedAnonymousMethodDelegate31;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, bool> CS$<>9__CachedAnonymousMethodDelegate36;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, <>f__AnonymousType21`2<int, int>> CS$<>9__CachedAnonymousMethodDelegate3e;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<<>f__AnonymousType21`2<int, int>, IPackage>, int> CS$<>9__CachedAnonymousMethodDelegate3f;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<<>f__AnonymousType21`2<int, int>, IPackage>, int> CS$<>9__CachedAnonymousMethodDelegate40;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate41;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, <>f__AnonymousType22`1<int>> CS$<>9__CachedAnonymousMethodDelegate42;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<<>f__AnonymousType22`1<int>, IPackage>, int> CS$<>9__CachedAnonymousMethodDelegate43;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate44;
    [ExtensionAttribute]
public static IDisposable StartOperation(IPackageRepository self, string operation, string mainPackageId, string mainPackageVersion);
    [ExtensionAttribute]
public static bool Exists(IPackageRepository repository, IPackageName package);
    [ExtensionAttribute]
public static bool Exists(IPackageRepository repository, string packageId);
    [ExtensionAttribute]
public static bool Exists(IPackageRepository repository, string packageId, SemanticVersion version);
    [ExtensionAttribute]
public static bool TryFindPackage(IPackageRepository repository, string packageId, SemanticVersion version, IPackage& package);
    [ExtensionAttribute]
public static IPackage FindPackage(IPackageRepository repository, string packageId);
    [ExtensionAttribute]
public static IPackage FindPackage(IPackageRepository repository, string packageId, SemanticVersion version);
    [ExtensionAttribute]
public static IPackage FindPackage(IPackageRepository repository, string packageId, SemanticVersion version, bool allowPrereleaseVersions, bool allowUnlisted);
    [ExtensionAttribute]
public static IPackage FindPackage(IPackageRepository repository, string packageId, SemanticVersion version, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool allowUnlisted);
    [ExtensionAttribute]
public static IPackage FindPackage(IPackageRepository repository, string packageId, IVersionSpec versionSpec, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool allowUnlisted);
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> FindPackages(IPackageRepository repository, IEnumerable`1<string> packageIds);
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> FindPackagesById(IPackageRepository repository, string packageId);
    internal static IEnumerable`1<IPackage> FindPackagesByIdCore(IPackageRepository repository, string packageId);
    [ExtensionAttribute]
private static IEnumerable`1<IPackage> FindPackages(IPackageRepository repository, IEnumerable`1<T> items, Func`2<IEnumerable`1<T>, Expression`1<Func`2<IPackage, bool>>> filterSelector);
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> FindPackages(IPackageRepository repository, string packageId, IVersionSpec versionSpec, bool allowPrereleaseVersions, bool allowUnlisted);
    [ExtensionAttribute]
public static IPackage FindPackage(IPackageRepository repository, string packageId, IVersionSpec versionSpec, bool allowPrereleaseVersions, bool allowUnlisted);
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> FindCompatiblePackages(IPackageRepository repository, IPackageConstraintProvider constraintProvider, IEnumerable`1<string> packageIds, IPackage package, FrameworkName targetFramework, bool allowPrereleaseVersions);
    [ExtensionAttribute]
public static PackageDependency FindDependency(IPackageMetadata package, string packageId, FrameworkName targetFramework);
    [ExtensionAttribute]
public static IQueryable`1<IPackage> Search(IPackageRepository repository, string searchTerm, bool allowPrereleaseVersions);
    [ExtensionAttribute]
public static IQueryable`1<IPackage> Search(IPackageRepository repository, string searchTerm, IEnumerable`1<string> targetFrameworks, bool allowPrereleaseVersions);
    [ExtensionAttribute]
public static IPackage ResolveDependency(IPackageRepository repository, PackageDependency dependency, bool allowPrereleaseVersions, bool preferListedPackages);
    [ExtensionAttribute]
public static IPackage ResolveDependency(IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages);
    [ExtensionAttribute]
public static IPackage ResolveDependency(IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion);
    [ExtensionAttribute]
internal static IPackage ResolveDependencyCore(IPackageRepository repository, PackageDependency dependency, IPackageConstraintProvider constraintProvider, bool allowPrereleaseVersions, bool preferListedPackages, DependencyVersion dependencyVersion);
    private static IPackage ResolveDependencyCore(IEnumerable`1<IPackage> packages, PackageDependency dependency, DependencyVersion dependencyVersion);
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> GetUpdates(IPackageRepository repository, IEnumerable`1<IPackageName> packages, bool includePrerelease, bool includeAllVersions, IEnumerable`1<FrameworkName> targetFrameworks, IEnumerable`1<IVersionSpec> versionConstraints);
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> GetUpdatesCore(IPackageRepository repository, IEnumerable`1<IPackageName> packages, bool includePrerelease, bool includeAllVersions, IEnumerable`1<FrameworkName> targetFramework, IEnumerable`1<IVersionSpec> versionConstraints);
    private static bool SupportsTargetFrameworks(IEnumerable`1<FrameworkName> targetFramework, IPackage package);
    [ExtensionAttribute]
public static IPackageRepository Clone(IPackageRepository repository);
    private static IEnumerable`1<IPackage> GetUpdateCandidates(IPackageRepository repository, IEnumerable`1<IPackageName> packages, bool includePrerelease);
    private static Expression`1<Func`2<IPackage, bool>> GetFilterExpression(IEnumerable`1<IPackageName> packages);
    [SuppressMessageAttribute("Microsoft.Globalization", "CA1304:SpecifyCultureInfo")]
private static Expression`1<Func`2<IPackage, bool>> GetFilterExpression(IEnumerable`1<string> ids);
    private static Expression GetCompareExpression(Expression parameterExpression, object value);
    private static IEnumerable`1<IPackage> FilterPackagesByConstraints(IPackageConstraintProvider constraintProvider, IEnumerable`1<IPackage> packages, string packageId, bool allowPrereleaseVersions);
    [ExtensionAttribute]
internal static IPackage SelectDependency(IEnumerable`1<IPackage> packages, DependencyVersion dependencyVersion);
    [CompilerGeneratedAttribute]
private static SemanticVersion <FindPackage>b__0(IPackage p);
    [CompilerGeneratedAttribute]
private static SemanticVersion <FindPackages>b__11(IPackage p);
    [CompilerGeneratedAttribute]
private static IPackage <FindCompatiblePackages>b__19(<>f__AnonymousType20`2<<>f__AnonymousType1f`2<IPackage, PackageDependency>, IVersionSpec> <>h__TransparentIdentifier14);
    [CompilerGeneratedAttribute]
private static SemanticVersion <ResolveDependencyCore>b__20(IPackage p);
    [CompilerGeneratedAttribute]
private static SemanticVersion <ResolveDependencyCore>b__21(IPackage p);
    [CompilerGeneratedAttribute]
private static string <GetUpdatesCore>b__24(IPackage package);
    [CompilerGeneratedAttribute]
private static bool <GetUpdateCandidates>b__2e(IPackage p);
    [CompilerGeneratedAttribute]
private static string <GetFilterExpression>b__30(IPackageName p);
    [CompilerGeneratedAttribute]
private static bool <FilterPackagesByConstraints>b__35(IPackage p);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType21`2<int, int> <SelectDependency>b__37(IPackage p);
    [CompilerGeneratedAttribute]
private static int <SelectDependency>b__38(IGrouping`2<<>f__AnonymousType21`2<int, int>, IPackage> g);
    [CompilerGeneratedAttribute]
private static int <SelectDependency>b__39(IGrouping`2<<>f__AnonymousType21`2<int, int>, IPackage> g);
    [CompilerGeneratedAttribute]
private static SemanticVersion <SelectDependency>b__3a(IPackage p);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType22`1<int> <SelectDependency>b__3b(IPackage p);
    [CompilerGeneratedAttribute]
private static int <SelectDependency>b__3c(IGrouping`2<<>f__AnonymousType22`1<int>, IPackage> g);
    [CompilerGeneratedAttribute]
private static SemanticVersion <SelectDependency>b__3d(IPackage p);
}
public class NuGet.PackageRepositoryFactory : object {
    private static PackageRepositoryFactory _default;
    private static Func`2<Uri, IHttpClient> _defaultHttpClientFactory;
    private Func`2<Uri, IHttpClient> _httpClientFactory;
    [CompilerGeneratedAttribute]
private static Func`2<Uri, IHttpClient> CS$<>9__CachedAnonymousMethodDelegate1;
    public static PackageRepositoryFactory Default { get; }
    public Func`2<Uri, IHttpClient> HttpClientFactory { get; public set; }
    private static PackageRepositoryFactory();
    public static PackageRepositoryFactory get_Default();
    public Func`2<Uri, IHttpClient> get_HttpClientFactory();
    public void set_HttpClientFactory(Func`2<Uri, IHttpClient> value);
    public virtual IPackageRepository CreateRepository(string packageSource);
    [CompilerGeneratedAttribute]
private static IHttpClient <.cctor>b__0(Uri u);
}
public static class NuGet.PackageRepositoryHelper : object {
    public static IPackage ResolvePackage(IPackageRepository sourceRepository, IPackageRepository localRepository, string packageId, SemanticVersion version, bool allowPrereleaseVersions);
    public static IPackage ResolvePackage(IPackageRepository sourceRepository, IPackageRepository localRepository, IPackageConstraintProvider constraintProvider, string packageId, SemanticVersion version, bool allowPrereleaseVersions);
}
public class NuGet.PackageRestoreConsent : object {
    private static string EnvironmentVariableName;
    private static string PackageRestoreSection;
    private static string PackageRestoreConsentKey;
    private static string PackageRestoreAutomaticKey;
    private ISettings _settings;
    private IEnvironmentVariableReader _environmentReader;
    private ConfigurationDefaults _configurationDefaults;
    public bool IsGranted { get; }
    public bool IsGrantedInSettings { get; public set; }
    public bool IsAutomatic { get; public set; }
    public PackageRestoreConsent(ISettings settings);
    public PackageRestoreConsent(ISettings settings, IEnvironmentVariableReader environmentReader);
    public PackageRestoreConsent(ISettings settings, IEnvironmentVariableReader environmentReader, ConfigurationDefaults configurationDefaults);
    public bool get_IsGranted();
    public bool get_IsGrantedInSettings();
    public void set_IsGrantedInSettings(bool value);
    public bool get_IsAutomatic();
    public void set_IsAutomatic(bool value);
    private static bool IsSet(string value);
}
[FlagsAttribute]
public enum NuGet.PackageSaveModes : Enum {
    public int value__;
    public static PackageSaveModes None;
    public static PackageSaveModes Nuspec;
    [SuppressMessageAttribute("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
public static PackageSaveModes Nupkg;
}
public class NuGet.PackageServer : object {
    private static string ServiceEndpoint;
    private static string ApiKeyHeader;
    private static int MaxRediretionCount;
    private Lazy`1<Uri> _baseUri;
    private string _source;
    private string _userAgent;
    private EventHandler`1<WebRequestEventArgs> SendingRequest;
    [CompilerGeneratedAttribute]
private static EventHandler`1<WebRequestEventArgs> CS$<>9__CachedAnonymousMethodDelegate1;
    public string Source { get; }
    public PackageServer(string source, string userAgent);
    public void add_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
    public void remove_SendingRequest(EventHandler`1<WebRequestEventArgs> value);
    public string get_Source();
    public void PushPackage(string apiKey, IPackage package, long packageSize, int timeout, bool disableBuffering);
    private void PushPackageToServer(string apiKey, Func`1<Stream> packageStreamFactory, long packageSize, int timeout, bool disableBuffering);
    private static void PushPackageToFileSystem(IFileSystem fileSystem, IPackage package);
    public void DeletePackage(string apiKey, string packageId, string packageVersion);
    private void DeletePackageFromServer(string apiKey, string packageId, string packageVersion);
    private static void DeletePackageFromFileSystem(IFileSystem fileSystem, string packageId, string packageVersion);
    private HttpClient GetClient(string path, string method, string contentType);
    internal static Uri GetServiceEndpointUrl(Uri baseUrl, string path);
    private bool EnsureSuccessfulResponse(HttpClient client, Nullable`1<HttpStatusCode> expectedStatusCode);
    private Uri ResolveBaseUrl();
    private static Uri EnsureTrailingSlash(Uri uri);
    [CompilerGeneratedAttribute]
private static void <.ctor>b__0(object param0, WebRequestEventArgs param1);
}
public class NuGet.PackageSorter : PackageWalker {
    private IPackageRepository _repository;
    private IList`1<IPackage> _sortedPackages;
    protected bool RaiseErrorOnCycle { get; }
    protected bool IgnoreWalkInfo { get; }
    protected bool SkipDependencyResolveError { get; }
    public PackageSorter(FrameworkName targetFramework);
    protected virtual bool get_RaiseErrorOnCycle();
    protected virtual bool get_IgnoreWalkInfo();
    protected virtual bool get_SkipDependencyResolveError();
    protected virtual void OnAfterPackageWalk(IPackage package);
    protected virtual IPackage ResolveDependency(PackageDependency dependency);
    protected virtual void OnDependencyResolveError(PackageDependency dependency);
    public IEnumerable`1<IPackage> GetPackagesByDependencyOrder(IPackageRepository repository);
}
[DataContractAttribute]
public class NuGet.PackageSource : object {
    public static int DefaultProtocolVersion;
    private int _hashCode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOfficial>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPasswordClearText>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProtocolVersion>k__BackingField;
    [DataMemberAttribute]
public string Name { get; private set; }
    [DataMemberAttribute]
public string Source { get; private set; }
    public bool IsOfficial { get; public set; }
    public bool IsMachineWide { get; public set; }
    public bool IsEnabled { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    public bool IsPasswordClearText { get; public set; }
    public int ProtocolVersion { get; public set; }
    public PackageSource(string source);
    public PackageSource(string source, string name);
    public PackageSource(string source, string name, bool isEnabled);
    public PackageSource(string source, string name, bool isEnabled, bool isOfficial);
    private static PackageSource();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    [CompilerGeneratedAttribute]
public bool get_IsOfficial();
    [CompilerGeneratedAttribute]
public void set_IsOfficial(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
public void set_IsMachineWide(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPasswordClearText();
    [CompilerGeneratedAttribute]
public void set_IsPasswordClearText(bool value);
    [CompilerGeneratedAttribute]
public int get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(int value);
    public sealed virtual bool Equals(PackageSource other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
    public PackageSource Clone();
}
public class NuGet.PackageSourceProvider : object {
    private static int MaxSupportedProtocolVersion;
    private static string PackageSourcesSectionName;
    private static string DisabledPackageSourcesSectionName;
    private static string CredentialsSectionName;
    private static string UsernameToken;
    private static string PasswordToken;
    private static string ClearTextPasswordToken;
    private static string ProtocolVersionAttribute;
    private ISettings _settingsManager;
    private IEnumerable`1<PackageSource> _providerDefaultSources;
    private IDictionary`2<PackageSource, PackageSource> _migratePackageSources;
    private IEnumerable`1<PackageSource> _configurationDefaultSources;
    [CompilerGeneratedAttribute]
private static Func`2<SettingValue, int> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<IndexedPackageSource, int> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<IndexedPackageSource, PackageSource> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<SettingValue, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<SettingValue, bool> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<SettingValue, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Predicate`1<PackageSource> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<PackageSource, bool> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<PackageSource, bool> CS$<>9__CachedAnonymousMethodDelegate25;
    [CompilerGeneratedAttribute]
private static Func`2<SettingValue, bool> CS$<>9__CachedAnonymousMethodDelegate26;
    [CompilerGeneratedAttribute]
private static Func`2<SettingValue, string> CS$<>9__CachedAnonymousMethodDelegate27;
    [CompilerGeneratedAttribute]
private static Func`2<SettingValue, string> CS$<>9__CachedAnonymousMethodDelegate28;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, SettingValue>, IEnumerable`1<SettingValue>> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`2<PackageSource, bool> CS$<>9__CachedAnonymousMethodDelegate2a;
    [CompilerGeneratedAttribute]
private static Func`2<PackageSource, bool> CS$<>9__CachedAnonymousMethodDelegate2b;
    public PackageSourceProvider(ISettings settingsManager);
    public PackageSourceProvider(ISettings settingsManager, IEnumerable`1<PackageSource> providerDefaultSources);
    public PackageSourceProvider(ISettings settingsManager, IEnumerable`1<PackageSource> providerDefaultSources, IDictionary`2<PackageSource, PackageSource> migratePackageSources);
    internal PackageSourceProvider(ISettings settingsManager, IEnumerable`1<PackageSource> providerDefaultSources, IDictionary`2<PackageSource, PackageSource> migratePackageSources, IEnumerable`1<PackageSource> configurationDefaultSources);
    public sealed virtual IEnumerable`1<PackageSource> LoadPackageSources();
    private PackageSourceCredential ReadCredential(string sourceName);
    private void MigrateSources(List`1<PackageSource> loadedPackageSources);
    private void SetDefaultPackageSources(List`1<PackageSource> loadedPackageSources);
    private void UpdateProviderDefaultSources(List`1<PackageSource> loadedSources);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1502")]
public sealed virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    private static KeyValuePair`2<string, string> ReadPasswordValues(PackageSource source);
    public sealed virtual void DisablePackageSource(PackageSource source);
    public sealed virtual bool IsPackageSourceEnabled(PackageSource source);
    private PackageSource ReadPackageSource(SettingValue setting, bool isEnabled);
    private static int ReadProtocolVersion(SettingValue setting);
    private static int AddOrUpdateIndexedSource(Dictionary`2<string, IndexedPackageSource> packageSourceLookup, int packageIndex, PackageSource packageSource);
    [CompilerGeneratedAttribute]
private static int <LoadPackageSources>b__0(SettingValue setting);
    [CompilerGeneratedAttribute]
private static int <LoadPackageSources>b__1(IndexedPackageSource source);
    [CompilerGeneratedAttribute]
private static PackageSource <LoadPackageSources>b__2(IndexedPackageSource source);
    [CompilerGeneratedAttribute]
private static bool <ReadCredential>b__6(SettingValue k);
    [CompilerGeneratedAttribute]
private static bool <ReadCredential>b__7(SettingValue k);
    [CompilerGeneratedAttribute]
private static bool <ReadCredential>b__8(SettingValue k);
    [CompilerGeneratedAttribute]
private static bool <SetDefaultPackageSources>b__12(PackageSource source);
    [CompilerGeneratedAttribute]
private static bool <UpdateProviderDefaultSources>b__18(PackageSource p);
    [CompilerGeneratedAttribute]
private static bool <SavePackageSources>b__1a(PackageSource s);
    [CompilerGeneratedAttribute]
private static bool <SavePackageSources>b__1b(SettingValue setting);
    [CompilerGeneratedAttribute]
private static string <SavePackageSources>b__1c(SettingValue setting);
    [CompilerGeneratedAttribute]
private static string <SavePackageSources>b__1d(SettingValue setting);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<SettingValue> <SavePackageSources>b__22(IGrouping`2<string, SettingValue> s);
    [CompilerGeneratedAttribute]
private static bool <SavePackageSources>b__23(PackageSource s);
    [CompilerGeneratedAttribute]
private static bool <SavePackageSources>b__24(PackageSource s);
}
[ExtensionAttribute]
public static class NuGet.PackageSourceProviderExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<PackageSource, string> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<PackageSource, string> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<PackageSource, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [ExtensionAttribute]
public static AggregateRepository CreateAggregateRepository(IPackageSourceProvider provider, IPackageRepositoryFactory factory, bool ignoreFailingRepositories);
    [ExtensionAttribute]
public static IPackageRepository CreatePriorityPackageRepository(IPackageSourceProvider provider, IPackageRepositoryFactory factory, IPackageRepository primaryRepository);
    [ExtensionAttribute]
public static string ResolveSource(IPackageSourceProvider provider, string value);
    [ExtensionAttribute]
public static IEnumerable`1<PackageSource> GetEnabledPackageSources(IPackageSourceProvider provider);
    [CompilerGeneratedAttribute]
private static string <CreateAggregateRepository>b__0(PackageSource s);
    [CompilerGeneratedAttribute]
private static string <ResolveSource>b__6(PackageSource source);
    [CompilerGeneratedAttribute]
private static bool <GetEnabledPackageSources>b__a(PackageSource p);
}
[FlagsAttribute]
public enum NuGet.PackageTargets : Enum {
    public int value__;
    public static PackageTargets None;
    public static PackageTargets Project;
    public static PackageTargets External;
    public static PackageTargets All;
}
public abstract class NuGet.PackageWalker : object {
    private Dictionary`2<IPackage, PackageWalkInfo> _packageLookup;
    private FrameworkName _targetFramework;
    [CompilerGeneratedAttribute]
private bool <SkipPackageTargetCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyVersion <DependencyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageMarker <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, IEnumerable`1<PackageDependency>> CS$<>9__CachedAnonymousMethodDelegate5;
    public bool SkipPackageTargetCheck { get; public set; }
    protected FrameworkName TargetFramework { get; }
    protected bool RaiseErrorOnCycle { get; }
    protected bool SkipDependencyResolveError { get; }
    protected bool IgnoreDependencies { get; }
    protected bool AllowPrereleaseVersions { get; }
    public DependencyVersion DependencyVersion { get; public set; }
    protected PackageMarker Marker { get; private set; }
    protected bool IgnoreWalkInfo { get; }
    protected PackageWalker(FrameworkName targetFramework);
    [CompilerGeneratedAttribute]
public virtual bool get_SkipPackageTargetCheck();
    [CompilerGeneratedAttribute]
public virtual void set_SkipPackageTargetCheck(bool value);
    protected FrameworkName get_TargetFramework();
    protected virtual bool get_RaiseErrorOnCycle();
    protected virtual bool get_SkipDependencyResolveError();
    protected virtual bool get_IgnoreDependencies();
    protected virtual bool get_AllowPrereleaseVersions();
    [CompilerGeneratedAttribute]
public DependencyVersion get_DependencyVersion();
    [CompilerGeneratedAttribute]
public void set_DependencyVersion(DependencyVersion value);
    [CompilerGeneratedAttribute]
protected PackageMarker get_Marker();
    [CompilerGeneratedAttribute]
private void set_Marker(PackageMarker value);
    protected virtual bool get_IgnoreWalkInfo();
    public void Walk(IPackage package);
    private static void CheckPackageMinClientVersion(IPackage package);
    private void ProcessPackageTarget(IPackage package);
    protected virtual bool OnAfterResolveDependency(IPackage package, IPackage dependency);
    protected virtual void OnBeforePackageWalk(IPackage package);
    protected virtual void OnAfterPackageWalk(IPackage package);
    protected virtual void OnDependencyResolveError(PackageDependency dependency);
    protected abstract virtual IPackage ResolveDependency(PackageDependency dependency);
    protected internal PackageWalkInfo GetPackageInfo(IPackage package);
    private static PackageTargets GetPackageTarget(IPackage package);
    private static bool IsDependencyOnly(IPackage package);
    [CompilerGeneratedAttribute]
private static string <Walk>b__0(IPackage p);
    [CompilerGeneratedAttribute]
private static bool <IsDependencyOnly>b__2(IPackageFile f);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PackageDependency> <IsDependencyOnly>b__3(PackageDependencySet d);
}
public class NuGet.PackageWalkInfo : object {
    [CompilerGeneratedAttribute]
private PackageTargets <InitialTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageTargets <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackage <Parent>k__BackingField;
    public PackageTargets InitialTarget { get; private set; }
    public PackageTargets Target { get; public set; }
    public IPackage Parent { get; public set; }
    public PackageWalkInfo(PackageTargets initialTarget);
    [CompilerGeneratedAttribute]
public PackageTargets get_InitialTarget();
    [CompilerGeneratedAttribute]
private void set_InitialTarget(PackageTargets value);
    [CompilerGeneratedAttribute]
public PackageTargets get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(PackageTargets value);
    [CompilerGeneratedAttribute]
public IPackage get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(IPackage value);
    public virtual string ToString();
}
public static class NuGet.PathResolver : object {
    [CompilerGeneratedAttribute]
private static Func`2<SearchPathResult, string> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<string, SearchPathResult> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<string, SearchPathResult> CS$<>9__CachedAnonymousMethodDelegate12;
    public static IEnumerable`1<T> GetMatches(IEnumerable`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static void FilterPackageFiles(ICollection`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static string NormalizeWildcardForExcludedFiles(string basePath, string wildcard);
    private static Regex WildcardToRegex(string wildcard);
    internal static IEnumerable`1<PhysicalPackageFile> ResolveSearchPattern(string basePath, string searchPath, string targetPath, bool includeEmptyDirectories);
    public static IEnumerable`1<string> PerformWildcardSearch(string basePath, string searchPath);
    private static IEnumerable`1<SearchPathResult> PerformWildcardSearchInternal(string basePath, string searchPath, bool includeEmptyDirectories, String& normalizedBasePath);
    internal static string GetPathToEnumerateFrom(string basePath, string searchPath);
    internal static string ResolvePackagePath(string searchDirectory, string searchPattern, string fullPath, string targetPath);
    internal static string NormalizeBasePath(string basePath, String& searchPath);
    internal static bool IsWildcardSearch(string filter);
    internal static bool IsDirectoryPath(string path);
    private static bool IsEmptyDirectory(string directory);
    [CompilerGeneratedAttribute]
private static string <PerformWildcardSearch>b__b(SearchPathResult s);
    [CompilerGeneratedAttribute]
private static SearchPathResult <PerformWildcardSearchInternal>b__e(string file);
    [CompilerGeneratedAttribute]
private static SearchPathResult <PerformWildcardSearchInternal>b__10(string directory);
}
public static class NuGet.PathUtility : object {
    public static bool IsSubdirectory(string basePath, string path);
    public static string EnsureTrailingSlash(string path);
    public static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
    public static void EnsureParentDirectory(string filePath);
    public static string GetRelativePath(string path1, string path2);
    public static string GetAbsolutePath(string basePath, string relativePath);
    public static string GetCanonicalPath(string path);
}
public static class NuGet.PathValidator : object {
    private static Char[] _invalidPathChars;
    private static PathValidator();
    public static bool IsValidSource(string source);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
public static bool IsValidLocalPath(string path);
    [SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
public static bool IsValidUncPath(string path);
    [SuppressMessageAttribute("Microsoft.Design", "CA1054:UriParametersShouldNotBeStrings")]
public static bool IsValidUrl(string url);
}
public class NuGet.PhysicalFileSystem : object {
    private string _root;
    private ILogger _logger;
    public string Root { get; }
    public ILogger Logger { get; public set; }
    public PhysicalFileSystem(string root);
    public sealed virtual string get_Root();
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    public virtual string GetFullPath(string path);
    public virtual void AddFile(string path, Stream stream);
    public virtual void AddFile(string path, Action`1<Stream> writeToStream);
    public virtual void AddFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    private void AddFileCore(string path, Action`1<Stream> writeToStream);
    private void WriteAddedFileAndDirectory(string path);
    public virtual void DeleteFile(string path);
    public virtual void DeleteFiles(IEnumerable`1<IPackageFile> files, string rootDir);
    public virtual void DeleteDirectory(string path);
    public virtual void DeleteDirectory(string path, bool recursive);
    public virtual IEnumerable`1<string> GetFiles(string path, bool recursive);
    public virtual IEnumerable`1<string> GetFiles(string path, string filter, bool recursive);
    public virtual IEnumerable`1<string> GetDirectories(string path);
    public virtual DateTimeOffset GetLastModified(string path);
    public sealed virtual DateTimeOffset GetCreated(string path);
    public sealed virtual DateTimeOffset GetLastAccessed(string path);
    public virtual bool FileExists(string path);
    public virtual bool DirectoryExists(string path);
    public virtual Stream OpenFile(string path);
    public virtual Stream CreateFile(string path);
    protected string MakeRelativePath(string fullPath);
    protected virtual void EnsureDirectory(string path);
    public sealed virtual void MakeFileWritable(string path);
    public virtual void MoveFile(string source, string destination);
}
public class NuGet.PhysicalPackageAssemblyReference : PhysicalPackageFile {
    public string Name { get; }
    public PhysicalPackageAssemblyReference(PhysicalPackageFile file);
    public PhysicalPackageAssemblyReference(Func`1<Stream> streamFactory);
    public sealed virtual string get_Name();
}
public class NuGet.PhysicalPackageFile : object {
    private Func`1<Stream> _streamFactory;
    private string _targetPath;
    private FrameworkName _targetFramework;
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectivePath>k__BackingField;
    public string SourcePath { get; public set; }
    public string TargetPath { get; public set; }
    public string Path { get; }
    public string EffectivePath { get; private set; }
    public FrameworkName TargetFramework { get; }
    public IEnumerable`1<FrameworkName> SupportedFrameworks { get; }
    public PhysicalPackageFile(PhysicalPackageFile file);
    internal PhysicalPackageFile(Func`1<Stream> streamFactory);
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
public void set_SourcePath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EffectivePath();
    [CompilerGeneratedAttribute]
private void set_EffectivePath(string value);
    public sealed virtual FrameworkName get_TargetFramework();
    public sealed virtual IEnumerable`1<FrameworkName> get_SupportedFrameworks();
    public sealed virtual Stream GetStream();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.Preprocessor : object {
    public sealed virtual void TransformFile(IPackageFile file, string targetPath, IProjectSystem projectSystem);
    public sealed virtual void RevertFile(IPackageFile file, string targetPath, IEnumerable`1<IPackageFile> matchingFiles, IProjectSystem projectSystem);
    internal static string Process(IPackageFile file, IPropertyProvider propertyProvider);
    public static string Process(Stream stream, IPropertyProvider propertyProvider, bool throwIfNotFound);
    private static string ReplaceToken(string propertyName, IPropertyProvider propertyProvider, bool throwIfNotFound);
}
public class NuGet.PriorityPackageRepository : PackageRepositoryBase {
    private IPackageRepository _primaryRepository;
    private IPackageRepository _secondaryRepository;
    internal IPackageRepository PrimaryRepository { get; }
    internal IPackageRepository SecondaryRepository { get; }
    public string Source { get; }
    public bool SupportsPrereleasePackages { get; }
    public PriorityPackageRepository(IPackageRepository primaryRepository, IPackageRepository secondaryRepository);
    internal IPackageRepository get_PrimaryRepository();
    internal IPackageRepository get_SecondaryRepository();
    public virtual string get_Source();
    public virtual IQueryable`1<IPackage> GetPackages();
    public virtual bool get_SupportsPrereleasePackages();
    public sealed virtual bool Exists(string packageId, SemanticVersion version);
    public sealed virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public sealed virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
    public sealed virtual IDisposable StartOperation(string operation, string mainPackageId, string mainPackageVersion);
}
public class NuGet.ProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PercentComplete>k__BackingField;
    public string Operation { get; private set; }
    public int PercentComplete { get; private set; }
    public ProgressEventArgs(int percentComplete);
    public ProgressEventArgs(string operation, int percentComplete);
    [CompilerGeneratedAttribute]
public string get_Operation();
    [CompilerGeneratedAttribute]
private void set_Operation(string value);
    [CompilerGeneratedAttribute]
public int get_PercentComplete();
    [CompilerGeneratedAttribute]
private void set_PercentComplete(int value);
}
public enum NuGet.ProjectImportLocation : Enum {
    public int value__;
    public static ProjectImportLocation Top;
    public static ProjectImportLocation Bottom;
}
[SuppressMessageAttribute("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
public class NuGet.ProjectManager : object {
    private EventHandler`1<PackageOperationEventArgs> PackageReferenceAdding;
    private EventHandler`1<PackageOperationEventArgs> PackageReferenceAdded;
    private EventHandler`1<PackageOperationEventArgs> PackageReferenceRemoving;
    private EventHandler`1<PackageOperationEventArgs> PackageReferenceRemoved;
    private ILogger _logger;
    private IPackageConstraintProvider _constraintProvider;
    private IPackageReferenceRepository _packageReferenceRepository;
    private IDictionary`2<FileTransformExtensions, IPackageFileTransformer> _fileTransformers;
    [CompilerGeneratedAttribute]
private IPackagePathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageRepository <LocalRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageRepository <SourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectSystem <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyVersion <DependencyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WhatIf>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType19`2<IPackage, IList`1<IPackageAssemblyReference>>, IEnumerable`1<IPackageAssemblyReference>> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`3<<>f__AnonymousType19`2<IPackage, IList`1<IPackageAssemblyReference>>, IPackageAssemblyReference, IPackageAssemblyReference> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`3<IPackage, IPackageFile, <>f__AnonymousType1a`2<IPackage, IPackageFile>> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1a`2<IPackage, IPackageFile>, IPackageFile> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Action`2<XElement, XElement> CS$<>9__CachedAnonymousMethodDelegate26;
    public IPackagePathResolver PathResolver { get; private set; }
    public IPackageRepository LocalRepository { get; private set; }
    public IPackageRepository SourceRepository { get; private set; }
    public IPackageConstraintProvider ConstraintProvider { get; public set; }
    public IProjectSystem Project { get; private set; }
    public ILogger Logger { get; public set; }
    public DependencyVersion DependencyVersion { get; public set; }
    public bool WhatIf { get; public set; }
    public ProjectManager(IPackageRepository sourceRepository, IPackagePathResolver pathResolver, IProjectSystem project, IPackageRepository localRepository);
    public sealed virtual void add_PackageReferenceAdding(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void remove_PackageReferenceAdding(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void add_PackageReferenceAdded(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void remove_PackageReferenceAdded(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void add_PackageReferenceRemoving(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void remove_PackageReferenceRemoving(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void add_PackageReferenceRemoved(EventHandler`1<PackageOperationEventArgs> value);
    public sealed virtual void remove_PackageReferenceRemoved(EventHandler`1<PackageOperationEventArgs> value);
    [CompilerGeneratedAttribute]
public IPackagePathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
private void set_PathResolver(IPackagePathResolver value);
    [CompilerGeneratedAttribute]
public sealed virtual IPackageRepository get_LocalRepository();
    [CompilerGeneratedAttribute]
private void set_LocalRepository(IPackageRepository value);
    [CompilerGeneratedAttribute]
public sealed virtual IPackageRepository get_SourceRepository();
    [CompilerGeneratedAttribute]
private void set_SourceRepository(IPackageRepository value);
    public IPackageConstraintProvider get_ConstraintProvider();
    public void set_ConstraintProvider(IPackageConstraintProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual IProjectSystem get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(IProjectSystem value);
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public sealed virtual DependencyVersion get_DependencyVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DependencyVersion(DependencyVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WhatIf();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WhatIf(bool value);
    public virtual void AddPackageReference(string packageId);
    public virtual void AddPackageReference(string packageId, SemanticVersion version);
    public virtual void AddPackageReference(string packageId, SemanticVersion version, bool ignoreDependencies, bool allowPrereleaseVersions);
    public virtual void AddPackageReference(IPackage package, bool ignoreDependencies, bool allowPrereleaseVersions);
    private void Execute(IPackage package, IPackageOperationResolver resolver);
    protected void Execute(PackageOperation operation);
    protected void AddPackageReferenceToProject(IPackage package);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
protected virtual void ExtractPackageFilesToProject(IPackage package);
    private void LogTargetFrameworkInfo(IPackage package, List`1<IPackageAssemblyReference> assemblyReferences, List`1<IPackageFile> contentFiles, List`1<IPackageFile> buildFiles);
    private void FilterAssemblyReferences(List`1<IPackageAssemblyReference> assemblyReferences, ICollection`1<PackageReferenceSet> packageAssemblyReferences);
    public sealed virtual bool IsInstalled(IPackage package);
    public void RemovePackageReference(string packageId);
    public void RemovePackageReference(string packageId, bool forceRemove);
    public virtual void RemovePackageReference(string packageId, bool forceRemove, bool removeDependencies);
    public virtual void RemovePackageReference(IPackage package, bool forceRemove, bool removeDependencies);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
private void RemovePackageReferenceFromProject(IPackage package);
    private bool IsTransformFile(string path);
    private IList`1<IPackageAssemblyReference> GetFilteredAssembliesToDelete(IPackage package);
    internal void UpdatePackageReference(string packageId);
    internal void UpdatePackageReference(string packageId, SemanticVersion version);
    public sealed virtual void UpdatePackageReference(string packageId, IVersionSpec versionSpec, bool updateDependencies, bool allowPrereleaseVersions);
    public virtual void UpdatePackageReference(string packageId, SemanticVersion version, bool updateDependencies, bool allowPrereleaseVersions);
    private void UpdatePackageReference(string packageId, Func`1<IPackage> resolvePackage, bool updateDependencies, bool allowPrereleaseVersions, bool targetVersionSetExplicitly);
    public virtual void UpdatePackageReference(IPackage remotePackage, bool updateDependencies, bool allowPrereleaseVersions);
    protected void UpdatePackageReference(IPackage package);
    private void UpdatePackageReferenceCore(IPackage package, bool updateDependencies, bool allowPrereleaseVersions);
    private void OnPackageReferenceAdding(PackageOperationEventArgs e);
    private void OnPackageReferenceAdded(PackageOperationEventArgs e);
    private void OnPackageReferenceRemoved(PackageOperationEventArgs e);
    private void OnPackageReferenceRemoving(PackageOperationEventArgs e);
    private FrameworkName GetPackageTargetFramework(string packageId);
    private IEnumerable`1<T> GetCompatibleInstalledItemsForPackage(string packageId, IEnumerable`1<T> items);
    private PackageOperationEventArgs CreateOperation(IPackage package);
    private static IDictionary`2<XName, Action`2<XElement, XElement>> GetConfigMappings();
    [CompilerGeneratedAttribute]
private <>f__AnonymousType19`2<IPackage, IList`1<IPackageAssemblyReference>> <RemovePackageReferenceFromProject>b__a(IPackage p);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<IPackageAssemblyReference> <RemovePackageReferenceFromProject>b__b(<>f__AnonymousType19`2<IPackage, IList`1<IPackageAssemblyReference>> <>h__TransparentIdentifier7);
    [CompilerGeneratedAttribute]
private static IPackageAssemblyReference <RemovePackageReferenceFromProject>b__c(<>f__AnonymousType19`2<IPackage, IList`1<IPackageAssemblyReference>> <>h__TransparentIdentifier7, IPackageAssemblyReference assemblyReference);
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPackageFile> <RemovePackageReferenceFromProject>b__d(IPackage p);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1a`2<IPackage, IPackageFile> <RemovePackageReferenceFromProject>b__e(IPackage p, IPackageFile file);
    [CompilerGeneratedAttribute]
private bool <RemovePackageReferenceFromProject>b__f(<>f__AnonymousType1a`2<IPackage, IPackageFile> <>h__TransparentIdentifier9);
    [CompilerGeneratedAttribute]
private static IPackageFile <RemovePackageReferenceFromProject>b__10(<>f__AnonymousType1a`2<IPackage, IPackageFile> <>h__TransparentIdentifier9);
    [CompilerGeneratedAttribute]
private static void <GetConfigMappings>b__25(XElement parent, XElement element);
}
[ExtensionAttribute]
public static class NuGet.ProjectManagerExtensions : object {
    [ExtensionAttribute]
public static FrameworkName GetTargetFrameworkForPackage(IProjectManager projectManager, string packageId);
}
[ExtensionAttribute]
public static class NuGet.ProjectSystemExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<FileTransformExtensions, string> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<FileTransformExtensions, string> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<IGrouping`2<string, IPackageFile>, IEnumerable`1<string>> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`3<IGrouping`2<string, IPackageFile>, string, <>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string>> CS$<>9__CachedAnonymousMethodDelegate1a;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string>, int> CS$<>9__CachedAnonymousMethodDelegate1b;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string>, string> CS$<>9__CachedAnonymousMethodDelegate1c;
    [CompilerGeneratedAttribute]
private static Func`2<FileTransformExtensions, string> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`3<IPackage, IPackageFile, <>f__AnonymousType24`2<IPackage, IPackageFile>> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType24`2<IPackage, IPackageFile>, IPackageFile> CS$<>9__CachedAnonymousMethodDelegate21;
    [ExtensionAttribute]
public static void AddFiles(IProjectSystem project, IEnumerable`1<IPackageFile> files, IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers);
    internal static void TryAddFile(IProjectSystem project, string path, Func`1<Stream> content);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
[SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
[SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
[ExtensionAttribute]
public static void DeleteFiles(IProjectSystem project, IEnumerable`1<IPackageFile> files, IEnumerable`1<IPackage> otherPackages, IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers);
    [ExtensionAttribute]
public static bool TryGetCompatibleItems(IProjectSystem projectSystem, IEnumerable`1<T> items, IEnumerable`1& compatibleItems);
    [ExtensionAttribute]
internal static IEnumerable`1<T> GetCompatibleItemsCore(IProjectSystem projectSystem, IEnumerable`1<T> items);
    private static string ResolvePath(IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers, Func`2<FileTransformExtensions, string> extensionSelector, string effectivePath);
    private static string ResolveTargetPath(IProjectSystem projectSystem, IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers, Func`2<FileTransformExtensions, string> extensionSelector, string effectivePath, IPackageFileTransformer& transformer);
    private static IPackageFileTransformer FindFileTransformer(IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers, Func`2<FileTransformExtensions, string> extensionSelector, string effectivePath, String& truncatedPath);
    [CompilerGeneratedAttribute]
private static string <AddFiles>b__2(FileTransformExtensions fte);
    [CompilerGeneratedAttribute]
private static string <AddFiles>b__3(FileTransformExtensions fte);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<string> <DeleteFiles>b__e(IGrouping`2<string, IPackageFile> grouping);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string> <DeleteFiles>b__f(IGrouping`2<string, IPackageFile> grouping, string directory);
    [CompilerGeneratedAttribute]
private static int <DeleteFiles>b__10(<>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string> <>h__TransparentIdentifiera);
    [CompilerGeneratedAttribute]
private static string <DeleteFiles>b__11(<>f__AnonymousType23`2<IGrouping`2<string, IPackageFile>, string> <>h__TransparentIdentifiera);
    [CompilerGeneratedAttribute]
private static string <DeleteFiles>b__14(FileTransformExtensions fte);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType24`2<IPackage, IPackageFile> <DeleteFiles>b__16(IPackage p, IPackageFile otherFile);
    [CompilerGeneratedAttribute]
private static IPackageFile <DeleteFiles>b__18(<>f__AnonymousType24`2<IPackage, IPackageFile> <>h__TransparentIdentifierb);
}
public class NuGet.ProxyCache : object {
    private static string HostKey;
    private static string UserKey;
    private static string PasswordKey;
    private static string NoProxy;
    private static IWebProxy _originalSystemProxy;
    private ConcurrentDictionary`2<Uri, WebProxy> _cache;
    private static Lazy`1<ProxyCache> _instance;
    private ISettings _settings;
    private IEnvironmentVariableReader _environment;
    [CompilerGeneratedAttribute]
private static Func`1<ProxyCache> CS$<>9__CachedAnonymousMethodDelegate1;
    public static ProxyCache Instance { get; }
    public ProxyCache(ISettings settings, IEnvironmentVariableReader environment);
    private static ProxyCache();
    public static ProxyCache get_Instance();
    public sealed virtual IWebProxy GetProxy(Uri uri);
    internal WebProxy GetUserConfiguredProxy();
    public sealed virtual void Add(IWebProxy proxy);
    private static WebProxy GetSystemProxy(Uri uri);
    private static bool IsSystemProxySet(Uri uri);
    [CompilerGeneratedAttribute]
private static ProxyCache <.cctor>b__0();
}
[ExtensionAttribute]
public static class NuGet.QueryableExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> AsBufferedEnumerable(IQueryable`1<T> source, int bufferSize);
}
internal static class NuGet.QueryableUtility : object {
    private static String[] _orderMethods;
    private static MethodInfo[] _methods;
    private static QueryableUtility();
    private static MethodInfo GetQueryableMethod(Expression expression);
    public static bool IsQueryableMethod(Expression expression, string method);
    public static bool IsOrderingMethod(Expression expression);
    public static Expression ReplaceQueryableExpression(IQueryable query, Expression expression);
    public static Type FindGenericType(Type definition, Type type);
}
[SuppressMessageAttribute("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
public class NuGet.ReadOnlyHashSet`1 : object {
    private ISet`1<T> _backingSet;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ReadOnlyHashSet`1(IEnumerable`1<T> items);
    public ReadOnlyHashSet`1(IEnumerable`1<T> items, IEqualityComparer`1<T> comparer);
    public ReadOnlyHashSet`1(ISet`1<T> backingSet);
    public sealed virtual bool Add(T item);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NuGet.RedirectedHttpClient : HttpClient {
    private static string RedirectedClientCacheKey;
    private Uri _originalUri;
    private MemoryCache _memoryCache;
    public Uri Uri { get; }
    public Uri OriginalUri { get; }
    internal IHttpClient CachedClient { get; }
    public RedirectedHttpClient(Uri uri);
    public RedirectedHttpClient(Uri uri, MemoryCache memoryCache);
    public virtual WebResponse GetResponse();
    public virtual Uri get_Uri();
    public virtual Uri get_OriginalUri();
    internal IHttpClient get_CachedClient();
    private string GetCacheKey();
    protected internal virtual IHttpClient EnsureClient();
    private Uri GetResponseUri(HttpClient client);
}
internal class NuGet.ReferenceAssemblyCompatibilityProvider : CompatibilityProvider {
    private static ReferenceAssemblyCompatibilityProvider _instance;
    public static ReferenceAssemblyCompatibilityProvider Instance { get; }
    public ReferenceAssemblyCompatibilityProvider(NetPortableProfileCollection profileCollection);
    public static ReferenceAssemblyCompatibilityProvider get_Instance();
}
internal class NuGet.ReferenceAssemblyFrameworkNameProvider : FrameworkNameProvider {
    private static ReferenceAssemblyFrameworkNameProvider _instance;
    public static ReferenceAssemblyFrameworkNameProvider Instance { get; }
    public ReferenceAssemblyFrameworkNameProvider(NetPortableProfileCollection profileCollection);
    private static IEnumerable`1<IFrameworkMappings> GetMappings();
    private static IEnumerable`1<IPortableFrameworkMappings> GetPortableMappings(NetPortableProfileCollection profileCollection);
    public static ReferenceAssemblyFrameworkNameProvider get_Instance();
}
internal class NuGet.ReferenceAssemblyPortableFrameworkMappings : object {
    private List`1<KeyValuePair`2<int, NuGetFramework[]>> _profileFrameworks;
    private List`1<KeyValuePair`2<int, NuGetFramework[]>> _profileOptionalFrameworks;
    private static ReferenceAssemblyPortableFrameworkMappings _instance;
    public IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> CompatibilityMappings { get; }
    public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileFrameworks { get; }
    public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileOptionalFrameworks { get; }
    public static ReferenceAssemblyPortableFrameworkMappings Instance { get; }
    public ReferenceAssemblyPortableFrameworkMappings(NetPortableProfileCollection profileCollection);
    private void AddPortableProfile(NetPortableProfileTable table, NetPortableProfile profile);
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> get_CompatibilityMappings();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileFrameworks();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileOptionalFrameworks();
    public static ReferenceAssemblyPortableFrameworkMappings get_Instance();
}
public static class NuGet.RepositoryOperationNames : object {
    public static string OperationHeaderName;
    public static string DependentPackageHeaderName;
    public static string DependentPackageVersionHeaderName;
    public static string Update;
    public static string Install;
    public static string Restore;
    public static string Mirror;
    public static string Reinstall;
    private static RepositoryOperationNames();
}
internal class NuGet.RequestHelper : object {
    private Func`1<WebRequest> _createRequest;
    private Action`1<WebRequest> _prepareRequest;
    private IProxyCache _proxyCache;
    private ICredentialCache _credentialCache;
    private ICredentialProvider _credentialProvider;
    private HttpWebRequest _previousRequest;
    private IHttpWebResponse _previousResponse;
    private Nullable`1<HttpStatusCode> _previousStatusCode;
    private int _credentialsRetryCount;
    private bool _usingSTSAuth;
    private bool _continueIfFailed;
    private int _proxyCredentialsRetryCount;
    private bool _basicAuthIsUsedInPreviousRequest;
    private bool _disableBuffering;
    public RequestHelper(Func`1<WebRequest> createRequest, Action`1<WebRequest> prepareRequest, IProxyCache proxyCache, ICredentialCache credentialCache, ICredentialProvider credentialProvider, bool disableBuffering);
    public WebResponse GetResponse();
    private void SetPreviousStatusCode(HttpWebRequest request, WebException ex);
    private static bool IsMonoProxyAuthenticationRequired(HttpWebRequest request, WebException ex);
    private void ConfigureRequest(HttpWebRequest request);
    private void GetProxyCredentials(HttpWebRequest request);
    private void SetCredentialsOnAuthorizationError(HttpWebRequest request);
    private static IHttpWebResponse GetResponse(WebResponse response);
    private static bool IsAuthenticationResponse(IHttpWebResponse response);
    private static void SetKeepAliveHeaders(HttpWebRequest request, IHttpWebResponse previousResponse);
    private static bool ShouldKeepAliveBeUsedInRequest(HttpWebRequest request, IHttpWebResponse response);
    private static bool IsNtlmOrKerberos(string authType);
}
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
internal class NuGet.Resources.AnalysisResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AssemblyOutsideLibDescription { get; }
    internal static string AssemblyOutsideLibSolution { get; }
    internal static string AssemblyOutsideLibTitle { get; }
    internal static string AssemblyUnderLibDescription { get; }
    internal static string AssemblyUnderLibSolution { get; }
    internal static string AssemblyUnderLibTitle { get; }
    internal static string InvalidFrameworkDescription { get; }
    internal static string InvalidFrameworkSolution { get; }
    internal static string InvalidFrameworkTitle { get; }
    internal static string MisplacedInitScriptDescription { get; }
    internal static string MisplacedInitScriptSolution { get; }
    internal static string MisplacedInitScriptTitle { get; }
    internal static string MisplacedTransformFileDescription { get; }
    internal static string MisplacedTransformFileSolution { get; }
    internal static string MisplacedTransformFileTitle { get; }
    internal static string MissingSummaryDescription { get; }
    internal static string MissingSummarySolution { get; }
    internal static string MissingSummaryTitle { get; }
    internal static string ScriptOutsideToolsDescription { get; }
    internal static string ScriptOutsideToolsSolution { get; }
    internal static string ScriptOutsideToolsTitle { get; }
    internal static string UnrecognizedScriptDescription { get; }
    internal static string UnrecognizedScriptSolution { get; }
    internal static string UnrecognizedScriptTitle { get; }
    internal static string WinRTObsoleteDescription { get; }
    internal static string WinRTObsoleteSolution { get; }
    internal static string WinRTObsoleteTitle { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AssemblyOutsideLibDescription();
    internal static string get_AssemblyOutsideLibSolution();
    internal static string get_AssemblyOutsideLibTitle();
    internal static string get_AssemblyUnderLibDescription();
    internal static string get_AssemblyUnderLibSolution();
    internal static string get_AssemblyUnderLibTitle();
    internal static string get_InvalidFrameworkDescription();
    internal static string get_InvalidFrameworkSolution();
    internal static string get_InvalidFrameworkTitle();
    internal static string get_MisplacedInitScriptDescription();
    internal static string get_MisplacedInitScriptSolution();
    internal static string get_MisplacedInitScriptTitle();
    internal static string get_MisplacedTransformFileDescription();
    internal static string get_MisplacedTransformFileSolution();
    internal static string get_MisplacedTransformFileTitle();
    internal static string get_MissingSummaryDescription();
    internal static string get_MissingSummarySolution();
    internal static string get_MissingSummaryTitle();
    internal static string get_ScriptOutsideToolsDescription();
    internal static string get_ScriptOutsideToolsSolution();
    internal static string get_ScriptOutsideToolsTitle();
    internal static string get_UnrecognizedScriptDescription();
    internal static string get_UnrecognizedScriptSolution();
    internal static string get_UnrecognizedScriptTitle();
    internal static string get_WinRTObsoleteDescription();
    internal static string get_WinRTObsoleteSolution();
    internal static string get_WinRTObsoleteTitle();
}
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
public class NuGet.Resources.NuGetResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string AdditonalConstraintsDefined { get; }
    public static string AggregateQueriesRequireOrder { get; }
    public static string CannotCreateEmptyPackage { get; }
    public static string CircularDependencyDetected { get; }
    public static string ConflictErrorWithDependent { get; }
    public static string ConflictErrorWithDependents { get; }
    public static string Debug_AddedFile { get; }
    public static string Debug_AddedFileToFolder { get; }
    public static string Debug_LookingForUpdates { get; }
    public static string Debug_RemovedFile { get; }
    public static string Debug_RemovedFileFromFolder { get; }
    public static string Debug_RemovedFolder { get; }
    public static string Debug_TargetFrameworkInfo { get; }
    public static string Debug_TargetFrameworkInfo_AssemblyReferences { get; }
    public static string Debug_TargetFrameworkInfo_BuildFiles { get; }
    public static string Debug_TargetFrameworkInfo_ContentFiles { get; }
    public static string Debug_TargetFrameworkInfo_NotFrameworkSpecific { get; }
    public static string Debug_TargetFrameworkInfo_PowershellScripts { get; }
    public static string Debug_TargetFrameworkInfoPrefix { get; }
    public static string DependencyHasInvalidVersion { get; }
    public static string DependencyOnlyCannotMixDependencies { get; }
    public static string DownloadProgressStatus { get; }
    public static string DuplicateDependenciesDefined { get; }
    public static string Error_InvalidPackage { get; }
    public static string Error_NoWritableConfig { get; }
    public static string Error_PackageAlreadyExists { get; }
    public static string Error_TooManyRedirections { get; }
    public static string ErrorLoadingPackages { get; }
    public static string ErrorReadingFile { get; }
    public static string ErrorReadingPackage { get; }
    public static string ExternalPackagesCannotDependOnProjectLevelPackages { get; }
    public static string FileConflictMessage { get; }
    public static string FileDoesNotExit { get; }
    public static string GetUpdatesParameterMismatch { get; }
    public static string IncompatibleSchema { get; }
    public static string Info_OverwriteExistingFile { get; }
    public static string InvalidFeed { get; }
    public static string InvalidFrameworkNameFormat { get; }
    public static string InvalidNullSettingsOperation { get; }
    public static string InvalidPackageId { get; }
    public static string InvalidVersionString { get; }
    public static string Log_ApplyingConstraints { get; }
    public static string Log_AttemptingToRetrievePackageFromSource { get; }
    public static string Log_BeginAddPackageReference { get; }
    public static string Log_BeginInstallPackage { get; }
    public static string Log_BeginRemovePackageReference { get; }
    public static string Log_BeginUninstallPackage { get; }
    public static string Log_InstallPackage { get; }
    public static string Log_InstallPackageIntoProject { get; }
    public static string Log_NoUpdatesAvailable { get; }
    public static string Log_NoUpdatesAvailableForProject { get; }
    public static string Log_PackageAlreadyInstalled { get; }
    public static string Log_PackageInstalledSuccessfully { get; }
    public static string Log_ProjectAlreadyReferencesPackage { get; }
    public static string Log_SuccessfullyAddedPackageReference { get; }
    public static string Log_SuccessfullyRemovedPackageReference { get; }
    public static string Log_SuccessfullyUninstalledPackage { get; }
    public static string Log_UninstallPackage { get; }
    public static string Log_UninstallPackageFromProject { get; }
    public static string Log_UpdatingPackages { get; }
    public static string Log_UpdatingPackagesWithoutOldVersion { get; }
    public static string Manifest_AssemblyNameRequired { get; }
    public static string Manifest_DependenciesHasMixedElements { get; }
    public static string Manifest_DependencyIdRequired { get; }
    public static string Manifest_ExcludeContainsInvalidCharacters { get; }
    public static string Manifest_IdMaxLengthExceeded { get; }
    public static string Manifest_InvalidMinClientVersion { get; }
    public static string Manifest_InvalidPrereleaseDependency { get; }
    public static string Manifest_InvalidReference { get; }
    public static string Manifest_InvalidReferenceFile { get; }
    public static string Manifest_InvalidSchemaNamespace { get; }
    public static string Manifest_NotAvailable { get; }
    public static string Manifest_NotFound { get; }
    public static string Manifest_ReferencesHasMixedElements { get; }
    public static string Manifest_ReferencesIsEmpty { get; }
    public static string Manifest_RequiredElementMissing { get; }
    public static string Manifest_RequiredMetadataMissing { get; }
    public static string Manifest_RequireLicenseAcceptanceRequiresLicenseUrl { get; }
    public static string Manifest_SourceContainsInvalidCharacters { get; }
    public static string Manifest_TargetContainsInvalidCharacters { get; }
    public static string Manifest_UriCannotBeEmpty { get; }
    public static string MissingFrameworkName { get; }
    public static string NewerVersionAlreadyReferenced { get; }
    public static string PackageAuthoring_FileNotFound { get; }
    public static string PackageDoesNotContainManifest { get; }
    public static string PackageHasDependent { get; }
    public static string PackageHasDependents { get; }
    public static string PackageMinVersionNotSatisfied { get; }
    public static string PackageRestoreConsentCheckBoxText { get; }
    public static string PackageServerError { get; }
    public static string PortableFrameworkProfileComponentIsEmpty { get; }
    public static string PortableFrameworkProfileComponentIsPortable { get; }
    public static string PortableFrameworkProfileEmpty { get; }
    public static string PortableFrameworkProfileHasDash { get; }
    public static string PortableFrameworkProfileHasSpace { get; }
    public static string ProjectDoesNotHaveReference { get; }
    public static string ReferenceFile_InvalidDevelopmentFlag { get; }
    public static string ReferenceFile_InvalidRequireReinstallationFlag { get; }
    public static string ReferenceFile_InvalidVersion { get; }
    public static string SemVerSpecialVersionTooLong { get; }
    public static string SettingsCredentials_UsingSavedCredentials { get; }
    public static string SupportedFrameworkIsNull { get; }
    public static string TokenHasNoValue { get; }
    public static string TypeMustBeASemanticVersion { get; }
    public static string UnableToFindCompatibleItems { get; }
    public static string UnableToLocateDependency { get; }
    public static string UnableToLocateWIF { get; }
    public static string UnableToResolveDependency { get; }
    public static string UnableToResolveUri { get; }
    public static string UnknownPackage { get; }
    public static string UnknownPackageSpecificVersion { get; }
    public static string UnknownSchemaVersion { get; }
    public static string UnsupportedHashAlgorithm { get; }
    public static string UserSettings_UnableToParseConfigFile { get; }
    public static string Warning_FileAlreadyExists { get; }
    public static string Warning_FileModified { get; }
    public static string Warning_PackageSkippedBecauseItIsInUse { get; }
    public static string Warning_UninstallingPackageWillBreakDependents { get; }
    public static string XdtError { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_AdditonalConstraintsDefined();
    public static string get_AggregateQueriesRequireOrder();
    public static string get_CannotCreateEmptyPackage();
    public static string get_CircularDependencyDetected();
    public static string get_ConflictErrorWithDependent();
    public static string get_ConflictErrorWithDependents();
    public static string get_Debug_AddedFile();
    public static string get_Debug_AddedFileToFolder();
    public static string get_Debug_LookingForUpdates();
    public static string get_Debug_RemovedFile();
    public static string get_Debug_RemovedFileFromFolder();
    public static string get_Debug_RemovedFolder();
    public static string get_Debug_TargetFrameworkInfo();
    public static string get_Debug_TargetFrameworkInfo_AssemblyReferences();
    public static string get_Debug_TargetFrameworkInfo_BuildFiles();
    public static string get_Debug_TargetFrameworkInfo_ContentFiles();
    public static string get_Debug_TargetFrameworkInfo_NotFrameworkSpecific();
    public static string get_Debug_TargetFrameworkInfo_PowershellScripts();
    public static string get_Debug_TargetFrameworkInfoPrefix();
    public static string get_DependencyHasInvalidVersion();
    public static string get_DependencyOnlyCannotMixDependencies();
    public static string get_DownloadProgressStatus();
    public static string get_DuplicateDependenciesDefined();
    public static string get_Error_InvalidPackage();
    public static string get_Error_NoWritableConfig();
    public static string get_Error_PackageAlreadyExists();
    public static string get_Error_TooManyRedirections();
    public static string get_ErrorLoadingPackages();
    public static string get_ErrorReadingFile();
    public static string get_ErrorReadingPackage();
    public static string get_ExternalPackagesCannotDependOnProjectLevelPackages();
    public static string get_FileConflictMessage();
    public static string get_FileDoesNotExit();
    public static string get_GetUpdatesParameterMismatch();
    public static string get_IncompatibleSchema();
    public static string get_Info_OverwriteExistingFile();
    public static string get_InvalidFeed();
    public static string get_InvalidFrameworkNameFormat();
    public static string get_InvalidNullSettingsOperation();
    public static string get_InvalidPackageId();
    public static string get_InvalidVersionString();
    public static string get_Log_ApplyingConstraints();
    public static string get_Log_AttemptingToRetrievePackageFromSource();
    public static string get_Log_BeginAddPackageReference();
    public static string get_Log_BeginInstallPackage();
    public static string get_Log_BeginRemovePackageReference();
    public static string get_Log_BeginUninstallPackage();
    public static string get_Log_InstallPackage();
    public static string get_Log_InstallPackageIntoProject();
    public static string get_Log_NoUpdatesAvailable();
    public static string get_Log_NoUpdatesAvailableForProject();
    public static string get_Log_PackageAlreadyInstalled();
    public static string get_Log_PackageInstalledSuccessfully();
    public static string get_Log_ProjectAlreadyReferencesPackage();
    public static string get_Log_SuccessfullyAddedPackageReference();
    public static string get_Log_SuccessfullyRemovedPackageReference();
    public static string get_Log_SuccessfullyUninstalledPackage();
    public static string get_Log_UninstallPackage();
    public static string get_Log_UninstallPackageFromProject();
    public static string get_Log_UpdatingPackages();
    public static string get_Log_UpdatingPackagesWithoutOldVersion();
    public static string get_Manifest_AssemblyNameRequired();
    public static string get_Manifest_DependenciesHasMixedElements();
    public static string get_Manifest_DependencyIdRequired();
    public static string get_Manifest_ExcludeContainsInvalidCharacters();
    public static string get_Manifest_IdMaxLengthExceeded();
    public static string get_Manifest_InvalidMinClientVersion();
    public static string get_Manifest_InvalidPrereleaseDependency();
    public static string get_Manifest_InvalidReference();
    public static string get_Manifest_InvalidReferenceFile();
    public static string get_Manifest_InvalidSchemaNamespace();
    public static string get_Manifest_NotAvailable();
    public static string get_Manifest_NotFound();
    public static string get_Manifest_ReferencesHasMixedElements();
    public static string get_Manifest_ReferencesIsEmpty();
    public static string get_Manifest_RequiredElementMissing();
    public static string get_Manifest_RequiredMetadataMissing();
    public static string get_Manifest_RequireLicenseAcceptanceRequiresLicenseUrl();
    public static string get_Manifest_SourceContainsInvalidCharacters();
    public static string get_Manifest_TargetContainsInvalidCharacters();
    public static string get_Manifest_UriCannotBeEmpty();
    public static string get_MissingFrameworkName();
    public static string get_NewerVersionAlreadyReferenced();
    public static string get_PackageAuthoring_FileNotFound();
    public static string get_PackageDoesNotContainManifest();
    public static string get_PackageHasDependent();
    public static string get_PackageHasDependents();
    public static string get_PackageMinVersionNotSatisfied();
    public static string get_PackageRestoreConsentCheckBoxText();
    public static string get_PackageServerError();
    public static string get_PortableFrameworkProfileComponentIsEmpty();
    public static string get_PortableFrameworkProfileComponentIsPortable();
    public static string get_PortableFrameworkProfileEmpty();
    public static string get_PortableFrameworkProfileHasDash();
    public static string get_PortableFrameworkProfileHasSpace();
    public static string get_ProjectDoesNotHaveReference();
    public static string get_ReferenceFile_InvalidDevelopmentFlag();
    public static string get_ReferenceFile_InvalidRequireReinstallationFlag();
    public static string get_ReferenceFile_InvalidVersion();
    public static string get_SemVerSpecialVersionTooLong();
    public static string get_SettingsCredentials_UsingSavedCredentials();
    public static string get_SupportedFrameworkIsNull();
    public static string get_TokenHasNoValue();
    public static string get_TypeMustBeASemanticVersion();
    public static string get_UnableToFindCompatibleItems();
    public static string get_UnableToLocateDependency();
    public static string get_UnableToLocateWIF();
    public static string get_UnableToResolveDependency();
    public static string get_UnableToResolveUri();
    public static string get_UnknownPackage();
    public static string get_UnknownPackageSpecificVersion();
    public static string get_UnknownSchemaVersion();
    public static string get_UnsupportedHashAlgorithm();
    public static string get_UserSettings_UnableToParseConfigFile();
    public static string get_Warning_FileAlreadyExists();
    public static string get_Warning_FileModified();
    public static string get_Warning_PackageSkippedBecauseItIsInUse();
    public static string get_Warning_UninstallingPackageWillBreakDependents();
    public static string get_XdtError();
}
[ExtensionAttribute]
public static class NuGet.Runtime.AppDomainExtensions : object {
    [ExtensionAttribute]
public static T CreateInstance(AppDomain domain);
}
public class NuGet.Runtime.AssemblyBinding : object {
    private static string Namespace;
    private string _oldVersion;
    private string _culture;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicKeyToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessorArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <AssemblyNewVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeBaseHref>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeBaseVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublisherPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<XAttribute, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public string Name { get; private set; }
    public string Culture { get; public set; }
    public string PublicKeyToken { get; private set; }
    public string ProcessorArchitecture { get; private set; }
    public string NewVersion { get; private set; }
    public string OldVersion { get; public set; }
    public Version AssemblyNewVersion { get; private set; }
    public string CodeBaseHref { get; private set; }
    public string CodeBaseVersion { get; private set; }
    public string PublisherPolicy { get; private set; }
    public AssemblyBinding(IAssembly assembly);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public string get_Culture();
    public void set_Culture(string value);
    [CompilerGeneratedAttribute]
public string get_PublicKeyToken();
    [CompilerGeneratedAttribute]
private void set_PublicKeyToken(string value);
    [CompilerGeneratedAttribute]
public string get_ProcessorArchitecture();
    [CompilerGeneratedAttribute]
private void set_ProcessorArchitecture(string value);
    [CompilerGeneratedAttribute]
public string get_NewVersion();
    [CompilerGeneratedAttribute]
private void set_NewVersion(string value);
    public string get_OldVersion();
    public void set_OldVersion(string value);
    [CompilerGeneratedAttribute]
public Version get_AssemblyNewVersion();
    [CompilerGeneratedAttribute]
private void set_AssemblyNewVersion(Version value);
    [CompilerGeneratedAttribute]
public string get_CodeBaseHref();
    [CompilerGeneratedAttribute]
private void set_CodeBaseHref(string value);
    [CompilerGeneratedAttribute]
public string get_CodeBaseVersion();
    [CompilerGeneratedAttribute]
private void set_CodeBaseVersion(string value);
    [CompilerGeneratedAttribute]
public string get_PublisherPolicy();
    [CompilerGeneratedAttribute]
private void set_PublisherPolicy(string value);
    public XElement ToXElement();
    public virtual string ToString();
    public static AssemblyBinding Parse(XContainer dependentAssembly);
    public static XName GetQualifiedName(string name);
    public sealed virtual bool Equals(AssemblyBinding other);
    private static bool SafeEquals(object a, object b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private static bool <ToXElement>b__0(XAttribute a);
}
[ExtensionAttribute]
public static class NuGet.Runtime.AssemblyNameExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<byte, string> CS$<>9__CachedAnonymousMethodDelegate1;
    [ExtensionAttribute]
public static string GetPublicKeyTokenString(AssemblyName assemblyName);
    [CompilerGeneratedAttribute]
private static string <GetPublicKeyTokenString>b__0(byte b);
}
public class NuGet.Runtime.BindingRedirectManager : object {
    private static XName AssemblyBindingName;
    private static XName DependentAssemblyName;
    private IFileSystem _fileSystem;
    private string _configurationPath;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousType18`2<AssemblyBinding, XElement>> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType18`2<AssemblyBinding, XElement>, AssemblyBinding> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType18`2<AssemblyBinding, XElement>, XElement> CS$<>9__CachedAnonymousMethodDelegate5;
    public BindingRedirectManager(IFileSystem fileSystem, string configurationPath);
    private static BindingRedirectManager();
    public void AddBindingRedirects(IEnumerable`1<AssemblyBinding> bindingRedirects);
    public void RemoveBindingRedirects(IEnumerable`1<AssemblyBinding> bindingRedirects);
    private static void RemoveElement(XElement element);
    private static XElement GetAssemblyBindingElement(XElement runtime);
    private void Save(XDocument document);
    private static ILookup`2<AssemblyBinding, XElement> GetAssemblyBindings(XDocument document);
    private static IEnumerable`1<XElement> GetAssemblyBindingElements(XElement runtime);
    private XDocument GetConfiguration();
    private static void UpdateBindingRedirectElement(XElement element, AssemblyBinding bindingRedirect);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType18`2<AssemblyBinding, XElement> <GetAssemblyBindings>b__0(XElement dependentAssemblyElement);
    [CompilerGeneratedAttribute]
private static AssemblyBinding <GetAssemblyBindings>b__1(<>f__AnonymousType18`2<AssemblyBinding, XElement> p);
    [CompilerGeneratedAttribute]
private static XElement <GetAssemblyBindings>b__2(<>f__AnonymousType18`2<AssemblyBinding, XElement> p);
}
public static class NuGet.Runtime.BindingRedirectResolver : object {
    [CompilerGeneratedAttribute]
private static Func`2<IAssembly, AssemblyBinding> CS$<>9__CachedAnonymousMethodDelegate1;
    public static IEnumerable`1<AssemblyBinding> GetBindingRedirects(string path);
    public static IEnumerable`1<AssemblyBinding> GetBindingRedirects(string path, AppDomain domain);
    public static IEnumerable`1<AssemblyBinding> GetBindingRedirects(IEnumerable`1<string> assemblyPaths, AppDomain domain);
    public static IEnumerable`1<AssemblyBinding> GetBindingRedirects(IEnumerable`1<IAssembly> assemblies);
    private static Tuple`2<string, string> GetUniqueKey(IAssembly assembly);
    private static IEnumerable`1<IAssembly> GetAssemblies(string path, AppDomain domain);
    private static IEnumerable`1<IAssembly> GetAssemblies(IEnumerable`1<string> paths, AppDomain domain);
    [CompilerGeneratedAttribute]
private static AssemblyBinding <GetBindingRedirects>b__0(IAssembly a);
}
public interface NuGet.Runtime.IAssembly {
    public string Name { get; }
    public Version Version { get; }
    public string PublicKeyToken { get; }
    public string Culture { get; }
    public IEnumerable`1<IAssembly> ReferencedAssemblies { get; }
    public abstract virtual string get_Name();
    public abstract virtual Version get_Version();
    public abstract virtual string get_PublicKeyToken();
    public abstract virtual string get_Culture();
    public abstract virtual IEnumerable`1<IAssembly> get_ReferencedAssemblies();
}
internal class NuGet.Runtime.RemoteAssembly : MarshalByRefObject {
    private static Dictionary`2<Tuple`2<string, string>, Assembly> _assemblyCache;
    private List`1<IAssembly> _referencedAssemblies;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicKeyToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    public string Name { get; private set; }
    public Version Version { get; private set; }
    public string PublicKeyToken { get; private set; }
    public string Culture { get; private set; }
    public IEnumerable`1<IAssembly> ReferencedAssemblies { get; }
    private static RemoteAssembly();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PublicKeyToken();
    [CompilerGeneratedAttribute]
private void set_PublicKeyToken(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Culture();
    [CompilerGeneratedAttribute]
private void set_Culture(string value);
    public sealed virtual IEnumerable`1<IAssembly> get_ReferencedAssemblies();
    public void Load(string path);
    private static RemoteAssembly CopyAssemblyProperties(AssemblyName assemblyName, RemoteAssembly assembly);
    internal static IAssembly LoadAssembly(string path, AppDomain domain);
}
[TypeConverterAttribute("NuGet.SemanticVersionTypeConverter")]
public class NuGet.SemanticVersion : object {
    private static RegexOptions _flags;
    private static Regex _semanticVersionRegex;
    private static Regex _strictSemanticVersionRegex;
    private string _originalString;
    private string _normalizedVersionString;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpecialVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Metadata>k__BackingField;
    public Version Version { get; private set; }
    public string SpecialVersion { get; private set; }
    public string Metadata { get; private set; }
    public SemanticVersion(string version);
    public SemanticVersion(int major, int minor, int build, int revision);
    public SemanticVersion(int major, int minor, int build, string specialVersion);
    public SemanticVersion(int major, int minor, int build, string specialVersion, string metadata);
    public SemanticVersion(Version version);
    public SemanticVersion(Version version, string specialVersion);
    public SemanticVersion(Version version, string specialVersion, string metadata);
    private SemanticVersion(Version version, string specialVersion, string metadata, string originalString);
    internal SemanticVersion(SemanticVersion semVer);
    private static SemanticVersion();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    [CompilerGeneratedAttribute]
public string get_SpecialVersion();
    [CompilerGeneratedAttribute]
private void set_SpecialVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(string value);
    public String[] GetOriginalVersionComponents();
    private static String[] SplitAndPadVersionString(string version);
    public static SemanticVersion Parse(string version);
    public static bool TryParse(string version, SemanticVersion& value);
    public static bool TryParseStrict(string version, SemanticVersion& value);
    private static bool TryParseInternal(string version, Regex regex, SemanticVersion& semVer);
    private static string RemoveLeadingChar(string s);
    public static SemanticVersion ParseOptionalVersion(string version);
    private static Version NormalizeVersionValue(Version version);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(SemanticVersion other);
    public static bool op_Equality(SemanticVersion version1, SemanticVersion version2);
    public static bool op_Inequality(SemanticVersion version1, SemanticVersion version2);
    public static bool op_LessThan(SemanticVersion version1, SemanticVersion version2);
    public static bool op_LessThanOrEqual(SemanticVersion version1, SemanticVersion version2);
    public static bool op_GreaterThan(SemanticVersion version1, SemanticVersion version2);
    public static bool op_GreaterThanOrEqual(SemanticVersion version1, SemanticVersion version2);
    public virtual string ToString();
    public string ToNormalizedString();
    public string ToFullString();
    public string ToOriginalString();
    public bool IsSemVer2();
    public sealed virtual bool Equals(SemanticVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static int CompareReleaseLabels(IEnumerable`1<string> version1, IEnumerable`1<string> version2);
    private static int CompareRelease(string version1, string version2);
}
public class NuGet.SemanticVersionTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public class NuGet.SendingRequestEventManager : WeakEventManager {
    private static object _managerLock;
    private static SendingRequestEventManager CurrentManager { get; }
    private static SendingRequestEventManager();
    public static void AddListener(IHttpClientEvents source, IWeakEventListener listener);
    public static void RemoveListener(IHttpClientEvents source, IWeakEventListener listener);
    private static SendingRequestEventManager get_CurrentManager();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private void OnSendingRequest(object sender, WebRequestEventArgs e);
}
public class NuGet.Settings : object {
    private XDocument _config;
    private IFileSystem _fileSystem;
    private string _fileName;
    private Settings _next;
    private int _priority;
    private bool _isMachineWideSettings;
    [CompilerGeneratedAttribute]
private static Func`2<Settings, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<Settings, Settings> CS$<>9__CachedAnonymousMethodDelegate8;
    public bool IsMachineWideSettings { get; }
    public string ConfigFilePath { get; }
    public Settings(IFileSystem fileSystem);
    public Settings(IFileSystem fileSystem, string fileName);
    public Settings(IFileSystem fileSystem, string fileName, bool isMachineWideSettings);
    public bool get_IsMachineWideSettings();
    public string get_ConfigFilePath();
    public static ISettings LoadDefaultSettings(IFileSystem fileSystem, string configFileName, IMachineWideSettings machineWideSettings);
    private static void LoadUserSpecificSettings(List`1<Settings> validSettingFiles, IFileSystem fileSystem, string configFileName);
    public static IEnumerable`1<Settings> LoadMachineWideSettings(IFileSystem fileSystem, String[] paths);
    public sealed virtual string GetValue(string section, string key, bool isPath);
    private static string ResolvePath(string configDirectory, string value);
    private string ElementToValue(XElement element, bool isPath);
    private XElement GetValueInternal(string section, string key, XElement curr);
    public sealed virtual IList`1<SettingValue> GetValues(string section, bool isPath);
    private void PopulateValues(string section, List`1<SettingValue> current, bool isPath);
    public sealed virtual IList`1<SettingValue> GetNestedValues(string section, string subsection);
    private void PopulateNestedValues(string section, string subsection, List`1<SettingValue> current);
    public sealed virtual void SetValue(string section, string key, string value);
    public sealed virtual void SetValues(string section, IList`1<SettingValue> values);
    public sealed virtual void UpdateSections(string section, IList`1<SettingValue> values);
    private static void SetElementValues(XElement element, string key, string value, IDictionary`2<string, string> attributes);
    public sealed virtual void SetNestedValues(string section, string key, IList`1<KeyValuePair`2<string, string>> values);
    private void SetValueInternal(XElement sectionElement, string key, string value, IDictionary`2<string, string> attributes);
    public sealed virtual bool DeleteValue(string section, string key);
    public sealed virtual bool DeleteSection(string section);
    private void ReadSection(XContainer sectionElement, ICollection`1<SettingValue> values, bool isPath);
    private void Save();
    private SettingValue ReadSettingsValue(XElement element, bool isPath);
    private static XElement GetSection(XElement parentElement, string section);
    private static XElement GetOrCreateSection(XElement parentElement, string sectionName);
    private static XElement FindElementByKey(XElement sectionElement, string key, XElement curr);
    private static IEnumerable`1<string> GetSettingsFileNames(IFileSystem fileSystem);
    private static IEnumerable`1<string> GetSettingsFilePaths(IFileSystem fileSystem);
    private static Settings ReadSettings(IFileSystem fileSystem, string settingsPath);
    private static Settings ReadSettings(IFileSystem fileSystem, string settingsPath, bool isMachineWideSettings);
    private void ExecuteSynchronized(Action ioOperation);
    [CompilerGeneratedAttribute]
private static bool <LoadDefaultSettings>b__4(Settings f);
    [CompilerGeneratedAttribute]
private static Settings <LoadDefaultSettings>b__5(Settings s);
    [CompilerGeneratedAttribute]
private bool <UpdateSections>b__b(SettingValue v);
    [CompilerGeneratedAttribute]
private bool <UpdateSections>b__c(SettingValue v);
    [CompilerGeneratedAttribute]
private void <Save>b__e();
}
public class NuGet.SettingsCredentialProvider : object {
    private ICredentialProvider _credentialProvider;
    private IPackageSourceProvider _packageSourceProvider;
    private ILogger _logger;
    public SettingsCredentialProvider(ICredentialProvider credentialProvider, IPackageSourceProvider packageSourceProvider);
    public SettingsCredentialProvider(ICredentialProvider credentialProvider, IPackageSourceProvider packageSourceProvider, ILogger logger);
    public sealed virtual ICredentials GetCredentials(Uri uri, IWebProxy proxy, CredentialType credentialType, bool retrying);
    private bool TryGetCredentials(Uri uri, NetworkCredential& configurationCredentials);
}
[ExtensionAttribute]
public static class NuGet.SettingsExtensions : object {
    private static string ConfigSection;
    [ExtensionAttribute]
public static string GetRepositoryPath(ISettings settings);
    [ExtensionAttribute]
public static string GetDecryptedValue(ISettings settings, string section, string key, bool isPath);
    [ExtensionAttribute]
public static void SetEncryptedValue(ISettings settings, string section, string key, string value);
    [ExtensionAttribute]
public static string GetConfigValue(ISettings settings, string key, bool decrypt, bool isPath);
    [ExtensionAttribute]
public static void SetConfigValue(ISettings settings, string key, string value, bool encrypt);
    [ExtensionAttribute]
public static bool DeleteConfigValue(ISettings settings, string key);
}
public class NuGet.SettingValue : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <AdditionalData>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public string Key { get; private set; }
    public string Value { get; public set; }
    public bool IsMachineWide { get; public set; }
    public int Priority { get; public set; }
    public IDictionary`2<string, string> AdditionalData { get; private set; }
    public SettingValue(string key, string value, bool isMachineWide, int priority);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
public void set_IsMachineWide(bool value);
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_AdditionalData();
    [CompilerGeneratedAttribute]
private void set_AdditionalData(IDictionary`2<string, string> value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private static string <Equals>b__0(KeyValuePair`2<string, string> data);
    [CompilerGeneratedAttribute]
private static string <Equals>b__1(KeyValuePair`2<string, string> data);
}
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
}
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private bool _initialized;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    internal void AddInt32(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(TValue o, IEqualityComparer`1<TValue> comparer);
    internal void AddObject(object o);
    internal static int GetHashCode(Object[] objects);
    private void CheckInitialized();
}
internal class NuGet.Shared.TypeInfo : object {
    private Type _type;
    public Assembly Assembly { get; }
    public TypeInfo(Type type);
    public Assembly get_Assembly();
}
public class NuGet.SharedPackageRepository : LocalPackageRepository {
    private static string StoreFilePath;
    private PackageReferenceFile _packageReferenceFile;
    private IFileSystem _storeFileSystem;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, XElement> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType16`2<XElement, string>, XElement> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<XElement, <>f__AnonymousType17`2<XElement, string>> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType17`2<XElement, string>, bool> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType17`2<XElement, string>, string> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType17`2<XElement, string>, XElement> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<PackageDependencySet, IEnumerable`1<PackageDependency>> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`2<PackageReference, string> CS$<>9__CachedAnonymousMethodDelegate2a;
    public PackageReferenceFile PackageReferenceFile { get; }
    public bool SupportsPrereleasePackages { get; }
    public SharedPackageRepository(string path);
    public SharedPackageRepository(IPackagePathResolver resolver, IFileSystem fileSystem, IFileSystem configSettingsFileSystem);
    public SharedPackageRepository(IPackagePathResolver resolver, IFileSystem fileSystem, IFileSystem storeFileSystem, IFileSystem configSettingsFileSystem);
    public PackageReferenceFile get_PackageReferenceFile();
    public virtual bool get_SupportsPrereleasePackages();
    public sealed virtual void RegisterRepository(string path);
    public sealed virtual void UnregisterRepository(string path);
    public sealed virtual bool IsReferenced(string packageId, SemanticVersion version);
    public virtual bool Exists(string packageId, SemanticVersion version);
    public virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public void AddPackageReferenceEntry(string packageId, SemanticVersion version);
    public virtual IQueryable`1<IPackage> GetPackages();
    protected IEnumerable`1<IPackage> SearchPackages();
    public virtual void AddPackage(IPackage package);
    public virtual void RemovePackage(IPackage package);
    public sealed virtual bool IsSolutionReferenced(string packageId, SemanticVersion version);
    protected virtual IPackageRepository CreateRepository(string path);
    internal virtual IPackage OpenPackage(string path);
    private IEnumerable`1<IPackageRepository> GetRepositories();
    internal IEnumerable`1<string> GetRepositoryPaths();
    private void AddEntry(string path);
    private void DeleteEntry(string path);
    private static IEnumerable`1<XElement> GetRepositoryElements(XDocument document);
    private XElement FindEntry(XDocument document, string path);
    private void SaveDocument(XDocument document);
    private XDocument GetStoreDocument(bool createIfNotExists);
    private string NormalizePath(string path);
    private bool IsSolutionLevel(IPackage package);
    private bool HasProjectLevelPackageDependency(IPackage package);
    private string GetManifestFilePath(string packageId, SemanticVersion version);
    [CompilerGeneratedAttribute]
private bool <Exists>b__4(string path);
    [CompilerGeneratedAttribute]
private static XElement <GetRepositoryElements>b__11(XElement e);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType16`2<XElement, string> <FindEntry>b__14(XElement e);
    [CompilerGeneratedAttribute]
private static XElement <FindEntry>b__16(<>f__AnonymousType16`2<XElement, string> <>h__TransparentIdentifier13);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType17`2<XElement, string> <SaveDocument>b__1b(XElement e);
    [CompilerGeneratedAttribute]
private static bool <SaveDocument>b__1c(<>f__AnonymousType17`2<XElement, string> <>h__TransparentIdentifier1a);
    [CompilerGeneratedAttribute]
private static string <SaveDocument>b__1d(<>f__AnonymousType17`2<XElement, string> <>h__TransparentIdentifier1a);
    [CompilerGeneratedAttribute]
private static XElement <SaveDocument>b__1e(<>f__AnonymousType17`2<XElement, string> <>h__TransparentIdentifier1a);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<PackageDependency> <HasProjectLevelPackageDependency>b__26(PackageDependencySet p);
    [CompilerGeneratedAttribute]
private static string <HasProjectLevelPackageDependency>b__27(PackageReference packageReference);
}
[CLSCompliantAttribute("False")]
[SuppressMessageAttribute("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
public class NuGet.SmartDataServiceQuery`1 : object {
    private IDataServiceContext _context;
    private IDataServiceQuery _query;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Type ElementType { get; }
    public Expression Expression { get; private set; }
    public IQueryProvider Provider { get; }
    public SmartDataServiceQuery`1(IDataServiceContext context, string entitySetName);
    public SmartDataServiceQuery`1(IDataServiceContext context, IDataServiceQuery query);
    private SmartDataServiceQuery`1(IDataServiceContext context, IDataServiceQuery query, Expression expression);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(Expression value);
    public sealed virtual IQueryProvider get_Provider();
    public sealed virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public sealed virtual IQueryable CreateQuery(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    public sealed virtual object Execute(Expression expression);
    private IQueryable CreateQuery(Type elementType, Expression expression);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class NuGet.StreamExtensions : object {
    [CompilerGeneratedAttribute]
private static Predicate`1<byte> CS$<>9__CachedAnonymousMethodDelegate4;
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream stream);
    [ExtensionAttribute]
public static Func`1<Stream> ToStreamFactory(Stream stream);
    [ExtensionAttribute]
public static string ReadToEnd(Stream stream);
    [ExtensionAttribute]
public static Stream AsStream(string value);
    [ExtensionAttribute]
public static Stream AsStream(string value, Encoding encoding);
    [ExtensionAttribute]
public static bool ContentEquals(Stream stream, Stream otherStream);
    public static bool IsBinary(Stream stream);
    private static bool CompareText(Stream stream, Stream otherStream);
    private static IEnumerable`1<string> ReadStreamLines(Stream stream);
    private static bool CompareBinary(Stream stream, Stream otherStream);
    [CompilerGeneratedAttribute]
private static bool <IsBinary>b__3(byte d);
}
[ExtensionAttribute]
internal static class NuGet.StringExtensions : object {
    [ExtensionAttribute]
public static string SafeTrim(string value);
}
public static class NuGet.STSAuthHelper : object {
    private static string STSEndPointHeader;
    private static string STSRealmHeader;
    private static string STSTokenHeader;
    public static void PrepareSTSRequest(WebRequest request);
    public static bool TryRetrieveSTSToken(Uri requestUri, IHttpWebResponse response);
    private static string GetSTSToken(Uri requestUri, string endPoint, string appliesTo);
    private static void SetProperty(object instance, string propertyName, object value);
    private static TVal GetFieldValue(Type type, string fieldName);
    private static string GetSTSEndPoint(IHttpWebResponse response);
    private static string GetCacheKey(Uri requestUri);
    private static string EncodeHeader(string token);
}
[ExtensionAttribute]
public static class NuGet.TaskExtensions : object {
    [ExtensionAttribute]
public static TResult WhenAny(Task`1[] tasks, Predicate`1<TResult> predicate);
}
public class NuGet.Token : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCategory <Category>k__BackingField;
    public string Value { get; private set; }
    public TokenCategory Category { get; private set; }
    public Token(TokenCategory category, string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public TokenCategory get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(TokenCategory value);
}
public enum NuGet.TokenCategory : Enum {
    public int value__;
    public static TokenCategory Text;
    public static TokenCategory Variable;
}
public class NuGet.Tokenizer : object {
    private string _text;
    private int _index;
    public Tokenizer(string text);
    public Token Read();
    private static bool IsWordChar(char ch);
    private Token ParseTokenAfterDollarSign();
    private Token ParseText();
}
public class NuGet.UninstallWalker : PackageWalker {
    private IDictionary`2<IPackage, IEnumerable`1<IPackage>> _forcedRemoved;
    private IDictionary`2<IPackage, IEnumerable`1<IPackage>> _skippedPackages;
    private bool _removeDependencies;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableWalkInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<PackageOperation> <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Force>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDependentsResolver <DependentsResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, string> CS$<>9__CachedAnonymousMethodDelegate7;
    protected ILogger Logger { get; private set; }
    protected IPackageRepository Repository { get; private set; }
    protected bool IgnoreDependencies { get; }
    protected bool SkipDependencyResolveError { get; }
    internal bool DisableWalkInfo { get; internal set; }
    protected bool IgnoreWalkInfo { get; }
    private Stack`1<PackageOperation> Operations { get; private set; }
    public bool Force { get; private set; }
    public bool ThrowOnConflicts { get; public set; }
    protected IDependentsResolver DependentsResolver { get; private set; }
    internal UninstallWalker(IPackageRepository repository, IDependentsResolver dependentsResolver, ILogger logger, bool removeDependencies, bool forceRemove);
    public UninstallWalker(IPackageRepository repository, IDependentsResolver dependentsResolver, FrameworkName targetFramework, ILogger logger, bool removeDependencies, bool forceRemove);
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
protected IPackageRepository get_Repository();
    [CompilerGeneratedAttribute]
private void set_Repository(IPackageRepository value);
    protected virtual bool get_IgnoreDependencies();
    protected virtual bool get_SkipDependencyResolveError();
    [CompilerGeneratedAttribute]
internal bool get_DisableWalkInfo();
    [CompilerGeneratedAttribute]
internal void set_DisableWalkInfo(bool value);
    protected virtual bool get_IgnoreWalkInfo();
    [CompilerGeneratedAttribute]
private Stack`1<PackageOperation> get_Operations();
    [CompilerGeneratedAttribute]
private void set_Operations(Stack`1<PackageOperation> value);
    [CompilerGeneratedAttribute]
public bool get_Force();
    [CompilerGeneratedAttribute]
private void set_Force(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnConflicts();
    [CompilerGeneratedAttribute]
public void set_ThrowOnConflicts(bool value);
    [CompilerGeneratedAttribute]
protected IDependentsResolver get_DependentsResolver();
    [CompilerGeneratedAttribute]
private void set_DependentsResolver(IDependentsResolver value);
    protected virtual void OnBeforePackageWalk(IPackage package);
    protected virtual bool OnAfterResolveDependency(IPackage package, IPackage dependency);
    protected virtual void OnAfterPackageWalk(IPackage package);
    protected virtual IPackage ResolveDependency(PackageDependency dependency);
    protected virtual void WarnRemovingPackageBreaksDependents(IPackage package, IEnumerable`1<IPackage> dependents);
    protected virtual InvalidOperationException CreatePackageHasDependentsException(IPackage package, IEnumerable`1<IPackage> dependents);
    protected virtual void OnDependencyResolveError(PackageDependency dependency);
    public sealed virtual IEnumerable`1<PackageOperation> ResolveOperations(IPackage package);
    private IEnumerable`1<IPackage> GetDependents(IPackage package);
    private bool IsConnected(IPackage package);
    [CompilerGeneratedAttribute]
private static string <WarnRemovingPackageBreaksDependents>b__0(IPackage d);
    [CompilerGeneratedAttribute]
private static string <CreatePackageHasDependentsException>b__2(IPackage d);
    [CompilerGeneratedAttribute]
private static string <ResolveOperations>b__4(IPackage p);
    [CompilerGeneratedAttribute]
private static string <ResolveOperations>b__5(IPackage p);
    [CompilerGeneratedAttribute]
private bool <GetDependents>b__8(IPackage p);
}
internal class NuGet.UnzippedPackage : LocalPackage {
    private IFileSystem _repositoryFileSystem;
    private string _packageFileName;
    private string _packagePath;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType9`2<string, FrameworkName>, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType9`2<string, FrameworkName>, FrameworkName> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousTypea`2<string, string>, bool> CS$<>9__CachedAnonymousMethodDelegatef;
    public UnzippedPackage(string repositoryDirectory, string packageName);
    public UnzippedPackage(IFileSystem repositoryFileSystem, string packageName);
    public UnzippedPackage(IFileSystem repositoryFileSystem, string packageId, SemanticVersion version);
    public virtual Stream GetStream();
    public virtual void ExtractContents(IFileSystem fileSystem, string extractPath);
    public virtual IEnumerable`1<FrameworkName> GetSupportedFrameworks();
    protected virtual IEnumerable`1<IPackageFile> GetFilesBase();
    protected virtual IEnumerable`1<IPackageAssemblyReference> GetAssemblyReferencesCore();
    private IEnumerable`1<string> GetPackageFilePaths();
    private string GetPackageRelativePath(string path);
    private void EnsureManifest(string manifestFilePath);
    [CompilerGeneratedAttribute]
private static bool <GetSupportedFrameworks>b__2(<>f__AnonymousType9`2<string, FrameworkName> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private static FrameworkName <GetSupportedFrameworks>b__3(<>f__AnonymousType9`2<string, FrameworkName> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private PhysicalPackageFile <GetFilesBase>b__9(string p);
    [CompilerGeneratedAttribute]
private <>f__AnonymousTypea`2<string, string> <GetAssemblyReferencesCore>b__c(string p);
    [CompilerGeneratedAttribute]
private static bool <GetAssemblyReferencesCore>b__d(<>f__AnonymousTypea`2<string, string> <>h__TransparentIdentifiera);
    [CompilerGeneratedAttribute]
private PhysicalPackageAssemblyReference <GetAssemblyReferencesCore>b__e(<>f__AnonymousTypea`2<string, string> <>h__TransparentIdentifiera);
    [CompilerGeneratedAttribute]
private bool <GetPackageFilePaths>b__10(string p);
}
public class NuGet.UnzippedPackageRepository : PackageRepositoryBase {
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackagePathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<string, <>f__AnonymousTypeb`2<string, string>> CS$<>9__CachedAnonymousMethodDelegate4;
    protected IFileSystem FileSystem { get; private set; }
    internal IPackagePathResolver PathResolver { get; internal set; }
    public string Source { get; }
    public bool SupportsPrereleasePackages { get; }
    public UnzippedPackageRepository(string physicalPath);
    public UnzippedPackageRepository(IPackagePathResolver pathResolver, IFileSystem fileSystem);
    [CompilerGeneratedAttribute]
protected IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(IFileSystem value);
    [CompilerGeneratedAttribute]
internal IPackagePathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
internal void set_PathResolver(IPackagePathResolver value);
    public virtual string get_Source();
    public virtual bool get_SupportsPrereleasePackages();
    public virtual IQueryable`1<IPackage> GetPackages();
    public sealed virtual IPackage FindPackage(string packageId, SemanticVersion version);
    public sealed virtual IEnumerable`1<IPackage> FindPackagesById(string packageId);
    public sealed virtual bool Exists(string packageId, SemanticVersion version);
    private static string GetPackageFileName(string packageId, SemanticVersion version);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousTypeb`2<string, string> <GetPackages>b__1(string file);
    [CompilerGeneratedAttribute]
private bool <GetPackages>b__2(<>f__AnonymousTypeb`2<string, string> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private UnzippedPackage <GetPackages>b__3(<>f__AnonymousTypeb`2<string, string> <>h__TransparentIdentifier0);
}
public class NuGet.UpdateWalker : InstallWalker {
    private IDependentsResolver _dependentsResolver;
    [CompilerGeneratedAttribute]
private PackageTargets <AcceptedTargets>k__BackingField;
    public PackageTargets AcceptedTargets { get; public set; }
    internal UpdateWalker(IPackageRepository localRepository, IPackageRepository sourceRepository, IDependentsResolver dependentsResolver, IPackageConstraintProvider constraintProvider, ILogger logger, bool updateDependencies, bool allowPrereleaseVersions);
    public UpdateWalker(IPackageRepository localRepository, IPackageRepository sourceRepository, IDependentsResolver dependentsResolver, IPackageConstraintProvider constraintProvider, FrameworkName targetFramework, ILogger logger, bool updateDependencies, bool allowPrereleaseVersions);
    [CompilerGeneratedAttribute]
public PackageTargets get_AcceptedTargets();
    [CompilerGeneratedAttribute]
public void set_AcceptedTargets(PackageTargets value);
    protected virtual ConflictResult GetConflict(IPackage package);
    protected virtual void OnAfterPackageWalk(IPackage package);
}
internal static class NuGet.UriUtility : object {
    internal static string GetPath(Uri uri);
    internal static Uri CreatePartUri(string path);
    private static Uri CreateODataAgnosticUri(string uri);
    public static bool UriEquals(Uri uri1, Uri uri2);
}
[ExtensionAttribute]
public static class NuGet.VersionExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<IPackage, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<SemanticVersion, SemanticVersion> CS$<>9__CachedAnonymousMethodDelegate6;
    [ExtensionAttribute]
public static Func`2<IPackage, bool> ToDelegate(IVersionSpec versionInfo);
    [ExtensionAttribute]
public static Func`2<T, bool> ToDelegate(IVersionSpec versionInfo, Func`2<T, SemanticVersion> extractor);
    [ExtensionAttribute]
public static bool Satisfies(IVersionSpec versionSpec, SemanticVersion version);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetComparableVersionStrings(SemanticVersion version);
    private static void AddVersionToList(string originalVersion, LinkedList`1<string> paths, string nextVersion);
    [CompilerGeneratedAttribute]
private static SemanticVersion <ToDelegate>b__0(IPackage p);
    [CompilerGeneratedAttribute]
private static SemanticVersion <Satisfies>b__5(SemanticVersion v);
}
public class NuGet.VersionSpec : object {
    [CompilerGeneratedAttribute]
private SemanticVersion <MinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMinInclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <MaxVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMaxInclusive>k__BackingField;
    public SemanticVersion MinVersion { get; public set; }
    public bool IsMinInclusive { get; public set; }
    public SemanticVersion MaxVersion { get; public set; }
    public bool IsMaxInclusive { get; public set; }
    public VersionSpec(SemanticVersion version);
    [CompilerGeneratedAttribute]
public sealed virtual SemanticVersion get_MinVersion();
    [CompilerGeneratedAttribute]
public void set_MinVersion(SemanticVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMinInclusive();
    [CompilerGeneratedAttribute]
public void set_IsMinInclusive(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual SemanticVersion get_MaxVersion();
    [CompilerGeneratedAttribute]
public void set_MaxVersion(SemanticVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMaxInclusive();
    [CompilerGeneratedAttribute]
public void set_IsMaxInclusive(bool value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class NuGet.VersionUtility : object {
    private static string NetFrameworkIdentifier;
    private static string NetCoreAppFrameworkShortName;
    private static string NetCoreAppFrameworkIdentifier;
    private static string NetCoreFrameworkIdentifier;
    private static string PortableFrameworkIdentifier;
    private static string NetPlatformFrameworkIdentifier;
    private static string NetPlatformFrameworkShortName;
    private static string NetStandardFrameworkShortName;
    private static string NetStandardFrameworkIdentifier;
    private static string NetStandardAppFrameworkShortName;
    private static string NetStandardAppFrameworkIdentifier;
    private static string AspNetFrameworkIdentifier;
    private static string AspNetCoreFrameworkIdentifier;
    private static string DnxFrameworkIdentifier;
    private static string DnxFrameworkShortName;
    private static string DnxCoreFrameworkIdentifier;
    private static string DnxCoreFrameworkShortName;
    private static string UAPFrameworkIdentifier;
    private static string UAPFrameworkShortName;
    private static string LessThanOrEqualTo;
    private static string GreaterThanOrEqualTo;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static FrameworkName EmptyFramework;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static FrameworkName NativeProjectFramework;
    [SuppressMessageAttribute("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes")]
public static FrameworkName UnsupportedFrameworkName;
    private static Version _emptyVersion;
    private static Dictionary`2<string, string> _knownIdentifiers;
    private static Dictionary`2<string, string> _knownProfiles;
    private static Dictionary`2<string, string> _identifierToFrameworkFolder;
    private static Dictionary`2<string, string> _identifierToProfileFolder;
    private static Dictionary`2<FrameworkName, FrameworkName> _frameworkNameAlias;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    public static Version DefaultTargetFrameworkVersion { get; }
    public static FrameworkName DefaultTargetFramework { get; }
    private static VersionUtility();
    public static Version get_DefaultTargetFrameworkVersion();
    public static FrameworkName get_DefaultTargetFramework();
    public static FrameworkName ParseFrameworkName(string frameworkName);
    internal static void ValidatePortableFrameworkProfilePart(string profilePart);
    public static Version TrimVersion(Version version);
    public static IVersionSpec ParseVersionSpec(string value);
    public static bool TryParseVersionSpec(string value, IVersionSpec& result);
    public static IVersionSpec GetSafeRange(SemanticVersion version);
    public static string PrettyPrint(IVersionSpec versionSpec);
    public static string GetFrameworkString(FrameworkName frameworkName);
    public static string GetShortFrameworkName(FrameworkName frameworkName);
    internal static string GetShortFrameworkName(NetPortableProfileTable table, FrameworkName frameworkName);
    private static bool RequiresDecimalVersioning(Version version);
    private static string GetDecimalVersionString(Version version);
    public static string GetTargetFrameworkLogString(FrameworkName targetFramework);
    [SuppressMessageAttribute("Microsoft.Design", "CA1021:AvoidOutParameters")]
public static FrameworkName ParseFrameworkNameFromFilePath(string filePath, String& effectivePath);
    public static FrameworkName ParseFrameworkFolderName(string path);
    [SuppressMessageAttribute("Microsoft.Design", "CA1021:AvoidOutParameters")]
public static FrameworkName ParseFrameworkFolderName(string path, bool strictParsing, String& effectivePath);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
public static bool TryGetCompatibleItems(FrameworkName projectFramework, IEnumerable`1<T> items, IEnumerable`1& compatibleItems);
    internal static IEnumerable`1<SemanticVersion> GetPossibleVersions(SemanticVersion semVer);
    public static bool IsCompatible(FrameworkName projectFrameworkName, IEnumerable`1<FrameworkName> packageSupportedFrameworks);
    internal static bool IsCompatible(FrameworkName projectFrameworkName, FrameworkName packageTargetFrameworkName);
    internal static bool IsCompatible(NetPortableProfileTable table, IFrameworkCompatibilityProvider compatibilityProvider, IFrameworkNameProvider nameProvider, FrameworkName projectFrameworkName, FrameworkName packageTargetFrameworkName);
    private static bool IsPortableLibraryCompatible(NetPortableProfileTable table, FrameworkName projectFrameworkName, FrameworkName packageTargetFrameworkName);
    private static bool TryParseVersion(string versionString, SemanticVersion& version);
    [ExtensionAttribute]
public static bool IsPortableFramework(FrameworkName framework);
    internal static NuGetFramework GetNuGetFramework(NetPortableProfileTable table, IFrameworkNameProvider provider, FrameworkName framework);
    [CompilerGeneratedAttribute]
private static bool <ValidatePortableFrameworkProfilePart>b__0(string p);
    [CompilerGeneratedAttribute]
private static bool <ValidatePortableFrameworkProfilePart>b__1(string p);
    [CompilerGeneratedAttribute]
private static bool <ValidatePortableFrameworkProfilePart>b__2(string p);
    [CompilerGeneratedAttribute]
private static bool <ValidatePortableFrameworkProfilePart>b__3(string p);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType25`2<T, IEnumerable`1<FrameworkName>> <TryGetCompatibleItems>b__c(T item);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<FrameworkName> <TryGetCompatibleItems>b__d(<>f__AnonymousType25`2<T, IEnumerable`1<FrameworkName>> <>h__TransparentIdentifiera);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType26`2<T, FrameworkName> <TryGetCompatibleItems>b__e(<>f__AnonymousType25`2<T, IEnumerable`1<FrameworkName>> <>h__TransparentIdentifiera, FrameworkName framework);
    [CompilerGeneratedAttribute]
private static FrameworkName <TryGetCompatibleItems>b__f(<>f__AnonymousType26`2<T, FrameworkName> g);
    [CompilerGeneratedAttribute]
private static T <TryGetCompatibleItems>b__10(<>f__AnonymousType26`2<T, FrameworkName> g);
    [CompilerGeneratedAttribute]
private static bool <TryGetCompatibleItems>b__11(IGrouping`2<FrameworkName, T> g);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType27`2<NuGetFramework, IGrouping`2<FrameworkName, T>> <TryGetCompatibleItems>b__12(IGrouping`2<FrameworkName, T> g);
    [CompilerGeneratedAttribute]
private static NuGetFramework <TryGetCompatibleItems>b__13(<>f__AnonymousType27`2<NuGetFramework, IGrouping`2<FrameworkName, T>> g);
    [CompilerGeneratedAttribute]
private static bool <TryGetCompatibleItems>b__15(IGrouping`2<FrameworkName, T> g);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<T> <TryGetCompatibleItems>b__16(IGrouping`2<FrameworkName, T> g);
}
public class NuGet.WebRequestEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WebRequest <Request>k__BackingField;
    public WebRequest Request { get; private set; }
    public WebRequestEventArgs(WebRequest request);
    [CompilerGeneratedAttribute]
public WebRequest get_Request();
    [CompilerGeneratedAttribute]
private void set_Request(WebRequest value);
}
internal abstract class NuGet.WIFTypeProvider : object {
    public Type ChannelFactory { get; }
    public Type RequestSecurityToken { get; }
    public Type EndPoint { get; }
    public Type RequestTypes { get; }
    public Type KeyTypes { get; }
    protected string AssemblyName { get; }
    public abstract virtual Type get_ChannelFactory();
    public abstract virtual Type get_RequestSecurityToken();
    public abstract virtual Type get_EndPoint();
    public abstract virtual Type get_RequestTypes();
    public abstract virtual Type get_KeyTypes();
    protected abstract virtual string get_AssemblyName();
    public static WIFTypeProvider GetWIFTypes();
    protected string QualifyTypeName(string typeName);
}
internal class NuGet.XdtTransformer : object {
    public sealed virtual void TransformFile(IPackageFile file, string targetPath, IProjectSystem projectSystem);
    public sealed virtual void RevertFile(IPackageFile file, string targetPath, IEnumerable`1<IPackageFile> matchingFiles, IProjectSystem projectSystem);
    private static void PerformXdtTransform(IPackageFile file, string targetPath, IProjectSystem projectSystem);
}
[ExtensionAttribute]
public static class NuGet.XElementExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`3<XAttribute, XAttribute, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`3<XAttribute, XAttribute, bool> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`3<XAttribute, XAttribute, <>f__AnonymousType28`2<XAttribute, XAttribute>> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType28`2<XAttribute, XAttribute>, XAttribute> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<XAttribute, XName> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<XAttribute, string> CS$<>9__CachedAnonymousMethodDelegate1f;
    [ExtensionAttribute]
public static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    [ExtensionAttribute]
public static string GetOptionalElementValue(XContainer element, string localName, string namespaceName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> ElementsNoNamespace(XContainer container, string localName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> ElementsNoNamespace(IEnumerable`1<XContainer> source, string localName);
    [ExtensionAttribute]
public static XElement Except(XElement source, XElement target);
    [ExtensionAttribute]
public static XElement MergeWith(XElement source, XElement target);
    [ExtensionAttribute]
[SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static XElement MergeWith(XElement source, XElement target, IDictionary`2<XName, Action`2<XElement, XElement>> nodeActions);
    private static XElement FindElement(XElement source, XElement targetChild);
    private static bool HasComment(XElement element, XComment comment);
    private static int Compare(XElement target, XElement left, XElement right);
    private static int CountMatches(XElement left, XElement right, Func`3<XAttribute, XAttribute, bool> matcher);
    private static bool HasConflict(XElement source, XElement target);
    [ExtensionAttribute]
public static void RemoveAttributes(XElement element, Func`2<XAttribute, bool> condition);
    [ExtensionAttribute]
public static void AddIndented(XContainer container, XContainer content);
    private static void AddTrailingIndentation(XContainer container, string containerIndent);
    private static void AddLeadingIndentation(XContainer container, string containerIndent, string oneIndentLevel);
    [ExtensionAttribute]
private static void IndentChildrenElements(XContainer container, string containerIndent, string oneIndentLevel);
    [ExtensionAttribute]
public static void RemoveIndented(XNode element);
    [ExtensionAttribute]
private static bool IsWhiteSpace(XText textNode);
    [ExtensionAttribute]
private static string ComputeOneLevelOfIndentation(XNode node);
    private static bool AttributeEquals(XAttribute source, XAttribute target);
    private static void AddContents(Queue`1<T> pendingComments, Action`1<T> action);
    [CompilerGeneratedAttribute]
private static bool <Compare>b__f(XAttribute a, XAttribute b);
    [CompilerGeneratedAttribute]
private static bool <Compare>b__10(XAttribute a, XAttribute b);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType28`2<XAttribute, XAttribute> <CountMatches>b__15(XAttribute la, XAttribute ta);
    [CompilerGeneratedAttribute]
private static XAttribute <CountMatches>b__17(<>f__AnonymousType28`2<XAttribute, XAttribute> <>h__TransparentIdentifier13);
    [CompilerGeneratedAttribute]
private static XName <HasConflict>b__1c(XAttribute a);
    [CompilerGeneratedAttribute]
private static string <HasConflict>b__1d(XAttribute a);
}
internal class NuGet.XmlTransformer : object {
    private IDictionary`2<XName, Action`2<XElement, XElement>> _nodeActions;
    public XmlTransformer(IDictionary`2<XName, Action`2<XElement, XElement>> nodeActions);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
public virtual void TransformFile(IPackageFile file, string targetPath, IProjectSystem projectSystem);
    [SuppressMessageAttribute("Microsoft.Reliability", "CA2000:Dispose objects before losing scope")]
public virtual void RevertFile(IPackageFile file, string targetPath, IEnumerable`1<IPackageFile> matchingFiles, IProjectSystem projectSystem);
    private static XElement GetXml(IPackageFile file, IProjectSystem projectSystem);
    [CompilerGeneratedAttribute]
private XElement <RevertFile>b__1(XElement left, XElement right);
}
public static class NuGet.XmlUtility : object {
    public static XDocument LoadSafe(string filePath);
    public static XDocument LoadSafe(Stream input);
    public static XDocument LoadSafe(Stream input, bool ignoreWhiteSpace);
    public static XDocument LoadSafe(Stream input, LoadOptions options);
    private static XmlReaderSettings CreateSafeSettings(bool ignoreWhiteSpace);
    internal static XDocument GetOrCreateDocument(XName rootName, IFileSystem fileSystem, string path);
    private static XDocument CreateDocument(XName rootName, IFileSystem fileSystem, string path);
    internal static XDocument GetDocument(IFileSystem fileSystem, string path);
    internal static bool TryParseDocument(string content, XDocument& document);
}
public class NuGet.ZipPackage : LocalPackage {
    private static string CacheKeyFormat;
    private static string AssembliesCacheKey;
    private static string FilesCacheKey;
    private bool _enableCaching;
    private static TimeSpan CacheTimeout;
    private static String[] ExcludePaths;
    private Func`1<Stream> _streamFactory;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, FrameworkName> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<FrameworkName, bool> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, bool> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<IPackageFile, IPackageAssemblyReference> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<PackagePart, IPackageFile> CS$<>9__CachedAnonymousMethodDelegate22;
    public ZipPackage(string filePath);
    public ZipPackage(Func`1<Stream> packageStreamFactory, Func`1<Stream> manifestStreamFactory);
    public ZipPackage(Stream stream);
    private ZipPackage(string filePath, bool enableCaching);
    internal ZipPackage(Func`1<Stream> streamFactory, bool enableCaching);
    private static ZipPackage();
    public virtual Stream GetStream();
    public virtual void ExtractContents(IFileSystem fileSystem, string extractPath);
    public static string GetPackageIdentifier(Package package);
    public virtual IEnumerable`1<FrameworkName> GetSupportedFrameworks();
    protected virtual IEnumerable`1<IPackageAssemblyReference> GetAssemblyReferencesCore();
    protected virtual IEnumerable`1<IPackageFile> GetFilesBase();
    private List`1<IPackageAssemblyReference> GetAssembliesNoCache();
    private List`1<IPackageFile> GetFilesNoCache();
    private void EnsureManifest(Func`1<Stream> manifestStreamFactory);
    private static Stream GetManifestStreamFromPackage(Stream packageStream);
    private string GetFilesCacheKey();
    private string GetAssembliesCacheKey();
    internal static bool IsPackageFile(PackagePart part, string packageId);
    internal static void ClearCache(IPackage package);
    [CompilerGeneratedAttribute]
private static FrameworkName <GetSupportedFrameworks>b__13(IPackageFile c);
    [CompilerGeneratedAttribute]
private bool <GetSupportedFrameworks>b__14(PackagePart part);
    [CompilerGeneratedAttribute]
private static bool <GetSupportedFrameworks>b__16(FrameworkName f);
    [CompilerGeneratedAttribute]
private static bool <GetAssembliesNoCache>b__1c(IPackageFile file);
    [CompilerGeneratedAttribute]
private static IPackageAssemblyReference <GetAssembliesNoCache>b__1d(IPackageFile file);
    [CompilerGeneratedAttribute]
private static IPackageFile <GetFilesNoCache>b__21(PackagePart part);
}
internal class NuGet.ZipPackageAssemblyReference : ZipPackageFile {
    public string Name { get; }
    public ZipPackageAssemblyReference(IPackageFile file);
    public sealed virtual string get_Name();
    public virtual string ToString();
}
internal class NuGet.ZipPackageFile : object {
    private Func`1<Stream> _streamFactory;
    private FrameworkName _targetFramework;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectivePath>k__BackingField;
    public string Path { get; private set; }
    public string EffectivePath { get; private set; }
    public FrameworkName TargetFramework { get; }
    private IEnumerable`1<FrameworkName> NuGet.IFrameworkTargetable.SupportedFrameworks { get; }
    public ZipPackageFile(PackagePart part);
    public ZipPackageFile(IPackageFile file);
    protected ZipPackageFile(string path, Func`1<Stream> streamFactory);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EffectivePath();
    [CompilerGeneratedAttribute]
private void set_EffectivePath(string value);
    public sealed virtual FrameworkName get_TargetFramework();
    private sealed virtual override IEnumerable`1<FrameworkName> NuGet.IFrameworkTargetable.get_SupportedFrameworks();
    public sealed virtual Stream GetStream();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class System.Reflection.TypeExtensions : object {
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(Type type);
}
