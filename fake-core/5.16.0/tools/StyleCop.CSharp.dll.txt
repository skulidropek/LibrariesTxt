public enum StyleCop.CSharp.AccessModifierType : Enum {
    public int value__;
    public static AccessModifierType Public;
    public static AccessModifierType Internal;
    public static AccessModifierType ProtectedInternal;
    public static AccessModifierType Protected;
    public static AccessModifierType Private;
    public static AccessModifierType ProtectedAndInternal;
}
public class StyleCop.CSharp.Accessor : CsElement {
    private AccessorType accessorType;
    private IList`1<Parameter> parameters;
    private TypeToken returnType;
    public AccessorType AccessorType { get; }
    public IList`1<Parameter> Parameters { get; }
    public TypeToken ReturnType { get; }
    internal Accessor(CsDocument document, CsElement parent, AccessorType accessorType, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, bool unsafeCode, bool generated);
    public AccessorType get_AccessorType();
    public sealed virtual IList`1<Parameter> get_Parameters();
    public TypeToken get_ReturnType();
    internal virtual void Initialize();
    private static TypeToken CreateVoidTypeToken(Reference`1<ICodePart> parentReference);
    private void FillDetails(CsElement parent);
    private void FillGetAccessorDetails(CsElement parent);
    private void FillSetAccessorDetails(CsElement parent);
}
public enum StyleCop.CSharp.AccessorType : Enum {
    public int value__;
    public static AccessorType Get;
    public static AccessorType Set;
    public static AccessorType Add;
    public static AccessorType Remove;
}
public class StyleCop.CSharp.AnonymousMethodExpression : ExpressionWithParameters {
    private bool asyncExpression;
    public bool Async { get; internal set; }
    public bool get_Async();
    internal void set_Async(bool value);
}
[DebuggerDisplayAttribute("{Expression.Text}")]
public class StyleCop.CSharp.Argument : object {
    private Expression argumentExpression;
    private bool generated;
    private CodeLocation location;
    private ParameterModifiers modifiers;
    private CsToken name;
    private Reference`1<ICodePart> parent;
    private CsTokenList tokens;
    public CodePartType CodePartType { get; }
    public Expression Expression { get; }
    public bool Generated { get; }
    public int LineNumber { get; }
    public CodeLocation Location { get; }
    public ParameterModifiers Modifiers { get; }
    public CsToken Name { get; }
    public ICodePart Parent { get; }
    public CsTokenList Tokens { get; }
    internal Argument(CsToken name, ParameterModifiers modifiers, Expression argumentExpression, CodeLocation location, Reference`1<ICodePart> parent, CsTokenList tokens, bool generated);
    public sealed virtual CodePartType get_CodePartType();
    public Expression get_Expression();
    public bool get_Generated();
    public sealed virtual int get_LineNumber();
    public sealed virtual CodeLocation get_Location();
    public ParameterModifiers get_Modifiers();
    public CsToken get_Name();
    public sealed virtual ICodePart get_Parent();
    public CsTokenList get_Tokens();
}
public class StyleCop.CSharp.ArithmeticExpression : Expression {
    private Expression leftHandSide;
    private Operator operatorType;
    private Expression rightHandSide;
    public Expression LeftHandSide { get; }
    public Operator OperatorType { get; }
    public Expression RightHandSide { get; }
    internal ArithmeticExpression(CsTokenList tokens, Operator operatorType, Expression leftHandSide, Expression rightHandSide);
    public Expression get_LeftHandSide();
    public Operator get_OperatorType();
    public Expression get_RightHandSide();
}
public class StyleCop.CSharp.ArrayAccessExpression : Expression {
    private IList`1<Argument> arguments;
    private Expression array;
    public IList`1<Argument> Arguments { get; }
    public Expression Array { get; }
    internal ArrayAccessExpression(CsTokenList tokens, Expression array, IList`1<Argument> arguments);
    public IList`1<Argument> get_Arguments();
    public Expression get_Array();
}
public class StyleCop.CSharp.ArrayInitializerExpression : Expression {
    private ICollection`1<Expression> initializers;
    public ICollection`1<Expression> Initializers { get; }
    internal ArrayInitializerExpression(CsTokenList tokens, ICollection`1<Expression> initializers);
    public ICollection`1<Expression> get_Initializers();
}
public class StyleCop.CSharp.AsExpression : Expression {
    private TypeToken type;
    private Expression value;
    public TypeToken Type { get; }
    public Expression Value { get; }
    internal AsExpression(CsTokenList tokens, Expression value, LiteralExpression type);
    public TypeToken get_Type();
    public Expression get_Value();
}
public class StyleCop.CSharp.AssemblyOrModuleAttribute : CsElement {
    internal AssemblyOrModuleAttribute(CsDocument document, CsElement parent, Declaration declaration, bool generated, ICollection`1<Attribute> attributes);
}
public class StyleCop.CSharp.AssignmentExpression : Expression {
    private Expression leftHandSide;
    private Operator operatorType;
    private Expression rightHandSide;
    public Expression LeftHandSide { get; }
    public Operator OperatorType { get; }
    public Expression RightHandSide { get; }
    internal AssignmentExpression(CsTokenList tokens, Operator operatorType, Expression leftHandSide, Expression rightHandSide);
    public Expression get_LeftHandSide();
    public Operator get_OperatorType();
    public Expression get_RightHandSide();
}
public class StyleCop.CSharp.Attribute : CsToken {
    private CodeUnitCollection`1<AttributeExpression> attributeExpressions;
    private MasterList`1<CsToken> childTokens;
    [CompilerGeneratedAttribute]
private CsElement <Element>k__BackingField;
    public ICollection`1<AttributeExpression> AttributeExpressions { get; }
    public MasterList`1<CsToken> ChildTokens { get; }
    public CsElement Element { get; internal set; }
    private ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.Tokens { get; }
    internal Attribute(MasterList`1<CsToken> childTokens, CodeLocation location, Reference`1<ICodePart> parent, IEnumerable`1<AttributeExpression> attributeExpressions, bool generated);
    public ICollection`1<AttributeExpression> get_AttributeExpressions();
    public MasterList`1<CsToken> get_ChildTokens();
    [CompilerGeneratedAttribute]
public CsElement get_Element();
    [CompilerGeneratedAttribute]
internal void set_Element(CsElement value);
    private sealed virtual override ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.get_Tokens();
    protected virtual void CreateTextString();
}
public class StyleCop.CSharp.AttributeExpression : Expression {
    private Expression initialization;
    private LiteralExpression target;
    public Expression Initialization { get; }
    public bool IsAssemblyAttribute { get; }
    public LiteralExpression Target { get; }
    internal AttributeExpression(CsTokenList tokens, LiteralExpression target, Expression initialization);
    public Expression get_Initialization();
    public bool get_IsAssemblyAttribute();
    public LiteralExpression get_Target();
}
public class StyleCop.CSharp.AwaitExpression : Expression {
    private Expression internalExpression;
    public Expression InternalExpression { get; }
    internal AwaitExpression(CsTokenList tokens, Expression internalExpression);
    public Expression get_InternalExpression();
}
public class StyleCop.CSharp.AwaitStatement : Statement {
    private Expression awaitValue;
    public Expression AwaitValue { get; }
    internal AwaitStatement(CsTokenList tokens, Expression awaitValue);
    public Expression get_AwaitValue();
}
public class StyleCop.CSharp.BlockStatement : Statement {
}
public class StyleCop.CSharp.BodiedExpression : ExpressionWithParameters {
    private CodeUnit anonymousFunctionBody;
    public CodeUnit AnonymousFunctionBody { get; internal set; }
    public CodeUnit get_AnonymousFunctionBody();
    internal void set_AnonymousFunctionBody(CodeUnit value);
}
public class StyleCop.CSharp.Bracket : CsToken {
    private Node`1<CsToken> matchingBracketNode;
    public Bracket MatchingBracket { get; }
    public Node`1<CsToken> MatchingBracketNode { get; internal set; }
    internal Bracket(string text, CsTokenType tokenType, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public Bracket get_MatchingBracket();
    public Node`1<CsToken> get_MatchingBracketNode();
    internal void set_MatchingBracketNode(Node`1<CsToken> value);
}
public class StyleCop.CSharp.BreakStatement : Statement {
    internal BreakStatement(CsTokenList tokens);
}
public class StyleCop.CSharp.CastExpression : Expression {
    private Expression castedExpression;
    private TypeToken type;
    public Expression CastedExpression { get; }
    public TypeToken Type { get; }
    internal CastExpression(CsTokenList tokens, LiteralExpression type, Expression castedExpression);
    public Expression get_CastedExpression();
    public TypeToken get_Type();
}
public class StyleCop.CSharp.CatchStatement : Statement {
    private Expression catchExpression;
    private TypeToken classType;
    private BlockStatement embeddedStatement;
    private WhenStatement whenStatement;
    private LiteralExpression identifier;
    private TryStatement tryStatement;
    public Expression CatchExpression { get; }
    public TypeToken ClassType { get; }
    public BlockStatement EmbeddedStatement { get; }
    public CsToken Identifier { get; }
    public TryStatement TryStatement { get; }
    public WhenStatement WhenStatement { get; }
    internal CatchStatement(CsTokenList tokens, TryStatement tryStatement, Expression classExpression, BlockStatement embeddedStatement, WhenStatement whenStatement);
    public Expression get_CatchExpression();
    public TypeToken get_ClassType();
    public BlockStatement get_EmbeddedStatement();
    public CsToken get_Identifier();
    public TryStatement get_TryStatement();
    public WhenStatement get_WhenStatement();
}
public class StyleCop.CSharp.CheckedExpression : Expression {
    private Expression internalExpression;
    public Expression InternalExpression { get; }
    internal CheckedExpression(CsTokenList tokens, Expression internalExpression);
    public Expression get_InternalExpression();
}
public class StyleCop.CSharp.CheckedStatement : Statement {
    private BlockStatement embeddedStatement;
    public BlockStatement EmbeddedStatement { get; }
    internal CheckedStatement(CsTokenList tokens, BlockStatement embeddedStatement);
    public BlockStatement get_EmbeddedStatement();
}
public class StyleCop.CSharp.Class : ClassBase {
    internal Class(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, ICollection`1<TypeParameterConstraintClause> typeConstraints, bool unsafeCode, bool generated);
    internal virtual void Initialize();
}
public abstract class StyleCop.CSharp.ClassBase : CsElement {
    private ICollection`1<TypeParameterConstraintClause> typeConstraints;
    private string baseClass;
    private String[] implementedInterfaces;
    public string BaseClass { get; }
    public ICollection`1<string> ImplementedInterfaces { get; }
    public ICollection`1<CsElement> PartialElementList { get; }
    public ICollection`1<TypeParameterConstraintClause> TypeConstraints { get; }
    internal ClassBase(CsDocument document, CsElement parent, ElementType type, string name, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, ICollection`1<TypeParameterConstraintClause> typeConstraints, bool unsafeCode, bool generated);
    public string get_BaseClass();
    public ICollection`1<string> get_ImplementedInterfaces();
    public ICollection`1<CsElement> get_PartialElementList();
    public sealed virtual ICollection`1<TypeParameterConstraintClause> get_TypeConstraints();
    protected void SetInheritedItems(Declaration declaration);
}
internal class StyleCop.CSharp.CodeLexer : object {
    private CodeReader codeReader;
    private Stack`1<bool> conditionalDirectives;
    private Stack`1<bool> evaluatingSymbolsStatus;
    private MarkerData marker;
    private CsParser parser;
    private SourceCode source;
    private Dictionary`2<string, string> defines;
    private bool evaluatingSymbols;
    private Dictionary`2<string, string> undefines;
    internal SourceCode SourceCode { get; }
    internal CodeLexer(CsParser parser, SourceCode source, CodeReader codeReader);
    internal SourceCode get_SourceCode();
    internal static string DecodeEscapedText(string text, bool allowRemoveAt);
    internal Symbol GetSymbol(List`1<Symbol> symbols, SourceCode sourceCode, Configuration configuration);
    internal List`1<Symbol> GetSymbols(SourceCode sourceCode, Configuration configuration);
    private static CodeLocation CodeLocationFromMarker(MarkerData marker);
    private static SymbolType GetOtherSymbolType(string text);
    private static bool IsHexadecimalChar(char character);
    private static bool IsLetterEncoded(Char[] sequence, Char& character);
    private static bool IsLetterExtended(char character);
    private void AdvanceToEndOfLine(StringBuilder text);
    private void CheckForConditionalCompilationDirective(List`1<Symbol> symbols, SourceCode sourceCode, Symbol preprocessorSymbol, Configuration configuration);
    private Symbol CreateAndMovePastSymbol(string text, SymbolType type);
    private bool EvaluateConditionalDirectiveExpression(SourceCode sourceCode, Expression expression, Configuration configuration);
    private int FindNextEndOfLine();
    private Symbol GetComment();
    private int GetDecimalFraction(int index);
    private int GetDecimalLiteral(int index);
    private void GetDefinePreprocessorDirective(SourceCode sourceCode, Symbol preprocessorSymbol, int startIndex);
    private int GetHexadecimalIntegerLiteral(int index);
    private int GetIntegerTypeSuffix(int index);
    private Symbol GetLiteral();
    private Symbol GetLiteralKeyword(StringBuilder text);
    private Symbol GetLiteralString(StringBuilder text);
    private Symbol GetMultiLineComment(StringBuilder text);
    private Symbol GetNewLine();
    private Symbol GetNumber();
    private Symbol GetOperatorSymbol(char character);
    private Symbol GetOtherSymbol(SourceCode sourceCode);
    private int GetPositiveNumber(int index);
    private Symbol GetPreprocessorDirectiveSymbol(List`1<Symbol> symbols, SourceCode sourceCode, Configuration configuration);
    private int GetRealLiteralExponent(int index);
    private int GetRealLiteralTrailingCharacters(int index, bool requiresDecimalPoint);
    private Symbol GetSingleLineComment(StringBuilder text);
    private Symbol GetString();
    private void ReadStringText(StringBuilder text);
    private Symbol GetInterpolatedString();
    private void ReadInterpolatedStringText(StringBuilder text);
    private bool IsClosingCharacter(char character, char openingCharacter);
    private void GetUndefinePreprocessorDirective(SourceCode sourceCode, Symbol preprocessorSymbol, int startIndex);
    private Symbol GetWhitespace();
    private Symbol GetXmlHeaderLine(StringBuilder text);
    private bool IsLetterEncoded(Char[]& sequence, Char& character);
    private void ReadToEndOfOtherSymbol(StringBuilder text);
    private void SetEvaluatingSymbolsForIfElifElse(SourceCode sourceCode, Symbol preprocessorSymbol, Configuration configuration, int startIndex, string type);
}
internal class StyleCop.CSharp.CodeParser : object {
    private CodeLexer lexer;
    private CsParser parser;
    private MasterList`1<CsToken> tokens;
    private CsDocument document;
    private SymbolManager symbols;
    private static String[] ClassModifiers;
    private static String[] ConstructorModifiers;
    private static String[] DelegateModifiers;
    private static String[] DestructorModifiers;
    private static String[] EnumModifiers;
    private static String[] EventModifiers;
    private static String[] FieldModifiers;
    private static String[] IndexerModifiers;
    private static String[] MethodModifiers;
    private static String[] PropertyModifiers;
    public CsDocument Document { get; }
    public CodeParser(CsParser parser, CodeLexer lexer);
    public CodeParser(CsParser parser, SymbolManager symbols);
    private static CodeParser();
    public CsDocument get_Document();
    internal static string AddQualifications(ICollection`1<Parameter> parameters, string fullyQualifiedName);
    internal static TypeToken ExtractTypeTokenFromLiteralExpression(LiteralExpression literal);
    internal static Node`1<CsToken> FindEndOfName(CsDocument document, CsTokenList tokens, Node`1<CsToken> startTokenNode);
    internal static string GetFullName(CsDocument document, CsTokenList tokens, Node`1<CsToken> startTokenNode, Node`1& endTokenNode);
    internal static bool MoveToNextCodeToken(CsTokenList tokens, Node`1& start);
    internal static string TrimType(string type);
    internal Attribute ParseAttribute(Reference`1<ICodePart> parentReference, bool unsafeCode, CsDocument masterDocument);
    internal void ParseDocument();
    private static bool MovePastTokens(CsTokenList tokens, Node`1& start, CsTokenType[] movePastTypes);
    private int AdvanceToEndOfName(int startIndex);
    private int AdvanceToEndOfName(int startIndex, Boolean& generic);
    private void AdvanceToNextCodeSymbol(Reference`1<ICodePart> parentReference);
    private void AdvanceToNextCodeSymbol(SkipSymbols skip, Reference`1<ICodePart> parentReference);
    private SyntaxException CreateSyntaxException();
    [ConditionalAttribute("DEBUG")]
private void DebugValidateParentReferences();
    private Attribute GetAttribute(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private int GetBestLineNumber();
    private ConditionalCompilationDirective GetConditionalCompilationDirective(Symbol preprocessorSymbol, ConditionalCompilationDirectiveType type, int startIndex, Reference`1<ICodePart> parent, bool generated);
    private FileHeader GetFileHeader(Reference`1<ICodePart> parentReference);
    private MasterList`1<CsToken> GetGenericArgumentList(Reference`1<ICodePart> genericTypeReference, bool unsafeCode, CsToken name, int startIndex, Int32& endIndex);
    private GenericType GetGenericToken(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private GenericType GetGenericTokenAux(Reference`1<ICodePart> genericTokenReference, bool unsafeCode, int startIndex, Int32& lastIndex);
    private int GetNextCodeSymbolIndex(int startIndex);
    private Symbol GetNextSymbol(SymbolType symbolType, Reference`1<ICodePart> parentReference);
    private Symbol GetNextSymbol(SymbolType symbolType, SkipSymbols skip, Reference`1<ICodePart> parentReference);
    private Symbol GetNextSymbol(Reference`1<ICodePart> parentReference);
    private Symbol GetNextSymbol(SkipSymbols skip, Reference`1<ICodePart> parentReference);
    private Symbol GetNextSymbol(SkipSymbols skip, Reference`1<ICodePart> parentReference, bool allowNull);
    private Symbol PeekNextSymbol(SkipSymbols skip, Reference`1<ICodePart> parentReference, bool allowNull);
    private Preprocessor GetPreprocessorDirectiveToken(Symbol preprocessorSymbol, Reference`1<ICodePart> parent, bool generated);
    private Variable GetVariable(Reference`1<ICodePart> parentReference, bool unsafeCode, bool allowTypelessVariable, bool onlyTypelessVariable);
    private static void AddElementToPartialElementsList(CsElement element, Dictionary`2<string, List`1<CsElement>> partialElements);
    private static string ExtractStringFromAttributeExpression(Expression expression);
    private static bool IsCodeAnalysisSuppression(Expression name);
    private static bool SanityCheckElementTypeAgainstParent(ElementType elementType, CsElement parent);
    private static bool TryCrackCodeAnalysisSuppression(MethodInvocationExpression codeAnalysisAttributeExpression, String& ruleId, String& ruleName, String& ruleNamespace);
    private void AddRuleSuppressionsForElement(CsElement element);
    private Dictionary`2<CsTokenType, CsToken> GetElementModifiers(Reference`1<ICodePart> elementReference, AccessModifierType& accessModifier, String[] allowedModifiers);
    private CsToken GetElementNameToken(Reference`1<ICodePart> elementReference, bool unsafeCode);
    private CsToken GetElementNameToken(Reference`1<ICodePart> elementReference, bool unsafeCode, bool allowArrayBrackets);
    private Nullable`1<ElementType> GetElementType(CsElement parent, bool unsafeCode);
    private bool GetOtherElementModifier(Reference`1<ICodePart> elementReference, String[] allowedModifiers, Dictionary`2<CsTokenType, CsToken> modifiers, Symbol symbol);
    private XmlHeader GetXmlHeader(Reference`1<ICodePart> elementReference);
    private void InitializeElement(CsElement element);
    private void MoveToElementDeclaration(CsElement element, Reference`1<ICodePart> parentElementReference, Reference`1<ICodePart> childElementReference, bool unsafeCode, XmlHeader& xmlHeader, ICollection`1& attributes);
    private Accessor ParseAccessor(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private ICollection`1<Parameter> ParseAnonymousMethodParameterList(Reference`1<ICodePart> elementReference, bool unsafeCode);
    private AssemblyOrModuleAttribute ParseAssemblyOrModuleAttribute(CsElement parent, Reference`1<ICodePart> elementReference, bool generated);
    private ClassBase ParseClass(ElementType elementType, CsElement parent, Reference`1<ICodePart> elementReference, Dictionary`2<string, List`1<CsElement>> partialElements, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private Constructor ParseConstructor(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private Delegate ParseDelegate(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private Destructor ParseDestructor(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private CsElement ParseElement(ElementType elementType, CsElement parent, Reference`1<ICodePart> elementReference, Dictionary`2<string, List`1<CsElement>> partialElements, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private void ParseElementContainer(CsElement element, Reference`1<ICodePart> elementReference, Dictionary`2<string, List`1<CsElement>> partialElements, bool unsafeCode);
    private Node`1<CsToken> ParseElementContainerBody(CsElement element, Reference`1<ICodePart> elementReference, Dictionary`2<string, List`1<CsElement>> partialElements, bool unsafeCode);
    private EmptyElement ParseEmptyElement(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated);
    private Enum ParseEnum(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private ICollection`1<EnumItem> ParseEnumItems(Enum parent, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Event ParseEvent(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private ExternAliasDirective ParseExternAliasDirective(CsElement parent, Reference`1<ICodePart> elementReference, bool generated);
    private Field ParseField(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private IList`1<VariableDeclaratorExpression> ParseFieldDeclarators(Reference`1<ICodePart> fieldReference, bool unsafeCode, TypeToken fieldType);
    private Indexer ParseIndexer(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private Method ParseMethod(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private Namespace ParseNamespace(CsElement parent, Reference`1<ICodePart> elementReference, Dictionary`2<string, List`1<CsElement>> partialElements, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private IList`1<Parameter> ParseParameterList(Reference`1<ICodePart> elementReference, bool unsafeCode, SymbolType openingBracketType);
    private IList`1<Parameter> ParseParameterList(Reference`1<ICodePart> elementReference, bool unsafeCode, SymbolType openingBracketType, bool staticMethod);
    private Property ParseProperty(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated, XmlHeader xmlHeader, ICollection`1<Attribute> attributes);
    private IList`1<VariableDeclaratorExpression> ParsePropertyDeclarators(Reference`1<ICodePart> propertyReference, bool unsafeCode, TypeToken propertyType, Node`1<CsToken> identifierTokenNode);
    private ICollection`1<TypeParameterConstraintClause> ParseTypeConstraintClauses(Reference`1<ICodePart> elementReference, bool unsafeCode);
    private UsingDirective ParseUsingDirective(CsElement parent, Reference`1<ICodePart> elementReference, bool unsafeCode, bool generated);
    private static bool CheckPrecedence(ExpressionPrecedence previousPrecedence, ExpressionPrecedence nextPrecedence);
    private static ExpressionPrecedence GetOperatorPrecedence(OperatorType type);
    private int AdvanceToClosingGenericSymbol(int startIndex);
    private LiteralExpression ConvertTypeExpression(Expression expression);
    private AnonymousMethodExpression GetAnonymousMethodExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private CollectionInitializerExpression GetAnonymousTypeInitializerExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private IList`1<Argument> GetArgumentList(SymbolType closingSymbol, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private ArithmeticExpression GetArithmeticExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private ArrayAccessExpression GetArrayAccessExpression(Expression array, ExpressionPrecedence previousPrecedence, bool unsafeCode);
    private ArrayInitializerExpression GetArrayInitializerExpression(bool unsafeCode);
    private AsExpression GetAsExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private AssignmentExpression GetAssignmentExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Expression GetAwaitExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Expression GetNullConditionExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private CastExpression GetCastExpression(bool unsafeCode);
    private CheckedExpression GetCheckedExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private CollectionInitializerExpression GetCollectionInitializerExpression(bool unsafeCode);
    private DictionaryItemInitializationExpression GetDictionaryInitializerExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private ConditionalExpression GetConditionalExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, bool unsafeCode);
    private ConditionalLogicalExpression GetConditionalLogicalExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private DefaultValueExpression GetDefaultValueExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Expression GetExpressionExtension(Expression leftSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode, bool typeExpression, bool allowVariableDeclaration);
    private IsExpression GetIsExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private LambdaExpression GetLambdaExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private BodiedExpression GetBodiedExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private LiteralExpression GetLiteralExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private LogicalExpression GetLogicalExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private MemberAccessExpression GetMemberAccessExpression(Expression leftSide, ExpressionPrecedence previousPrecedence, bool unsafeCode);
    private MethodInvocationExpression GetMethodInvocationExpression(Expression methodName, ExpressionPrecedence previousPrecedence, bool unsafeCode);
    private Expression GetNewAllocationExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private NewExpression GetNewAnonymousTypeExpression(bool unsafeCode, Node`1<CsToken> firstTokenNode, Reference`1<ICodePart> expressionReference);
    private NewArrayExpression GetNewArrayTypeExpression(bool unsafeCode, Node`1<CsToken> firstTokenNode, Expression type, Reference`1<ICodePart> expressionReference);
    private NewExpression GetNewNonArrayTypeExpression(bool unsafeCode, Node`1<CsToken> firstTokenNode, Expression type, Reference`1<ICodePart> expressionReference);
    private Expression GetNextExpression(ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Expression GetNextExpression(ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode, bool allowVariableDeclaration, bool typeExpression);
    private NullCoalescingExpression GetNullCoalescingExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private ObjectInitializerExpression GetObjectInitializerExpression(bool unsafeCode);
    private Expression GetObjectOrCollectionInitializerExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Expression GetOpenParenthesisExpression(ExpressionPrecedence previousPrecedence, bool unsafeCode);
    private Expression GetOperatorRightHandExpression(ExpressionPrecedence precedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Expression GetOtherExpression(Reference`1<ICodePart> parentReference, bool allowVariableDeclaration, bool unsafeCode);
    private ParenthesizedExpression GetParenthesizedExpression(bool unsafeCode);
    private DecrementExpression GetPrimaryDecrementExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence);
    private IncrementExpression GetPrimaryIncrementExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence);
    private QueryContinuationClause GetQueryContinuationClause(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private QueryExpression GetQueryExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private CsTokenList GetQueryExpressionClauses(Reference`1<ICodePart> parentReference, bool unsafeCode, List`1<QueryClause> clauses, List`1<Variable> variables);
    private QueryFromClause GetQueryFromClause(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private QueryGroupClause GetQueryGroupClause(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private QueryJoinClause GetQueryJoinClause(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private QueryLetClause GetQueryLetClause(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private QueryOrderByClause GetQueryOrderByClause(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private QuerySelectClause GetQuerySelectClause(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private QueryWhereClause GetQueryWhereClause(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private RelationalExpression GetRelationalExpression(Expression leftHandSide, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private SizeofExpression GetSizeofExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private StackallocExpression GetStackallocExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private TypeofExpression GetTypeofExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private NameofExpression GetNameofExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private DecrementExpression GetUnaryDecrementExpression(bool unsafeCode);
    private UnaryExpression GetUnaryExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private IncrementExpression GetUnaryIncrementExpression(bool unsafeCode);
    private UncheckedExpression GetUncheckedExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private UnsafeAccessExpression GetUnsafeAccessExpression(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private UnsafeAccessExpression GetUnsafeTypeExpression(Expression type, ExpressionPrecedence previousPrecedence, Reference`1<ICodePart> parentReference);
    private VariableDeclarationExpression GetVariableDeclarationExpression(Expression type, ExpressionPrecedence previousPrecedence, bool unsafeCode);
    private bool HasTypeSignature(int startIndex, bool unsafeCode, Int32& endIndex);
    private bool HasTypeSignature(int startIndex, bool unsafeCode, Int32& endIndex, Boolean& generic);
    private bool IsAwaitExpression();
    private bool IsCastExpression(ExpressionPrecedence previousPrecedence, bool unsafeCode);
    private bool IsDelegateExpression();
    private bool IsDereferenceExpression(Expression leftSide);
    private bool IsLambdaExpression();
    private bool IsBodiedExpression();
    private bool IsQueryExpression(bool unsafeCode);
    private bool IsUnaryExpression();
    private void MovePastArrayBrackets(Reference`1<ICodePart> parentReference);
    private OperatorSymbol PeekOperatorToken(Reference`1<ICodePart> parentReference, Reference`1<ICodePart> tokenParent);
    internal static Expression GetConditionalPreprocessorBodyExpression(CsParser parser, SourceCode sourceCode, Symbol preprocessorSymbol, int startIndex);
    internal Expression GetNextConditionalPreprocessorExpression(SourceCode sourceCode);
    private void AdvanceToNextConditionalDirectiveCodeSymbol(Reference`1<ICodePart> parentReference);
    private ConditionalLogicalExpression GetConditionalPreprocessorAndOrExpression(SourceCode sourceCode, Reference`1<ICodePart> parentReference, Expression leftHandSide, ExpressionPrecedence previousPrecedence);
    private LiteralExpression GetConditionalPreprocessorConstantExpression();
    private RelationalExpression GetConditionalPreprocessorEqualityExpression(SourceCode sourceCode, Reference`1<ICodePart> parentReference, Expression leftHandSide, ExpressionPrecedence previousPrecedence);
    private Expression GetConditionalPreprocessorExpressionExtension(SourceCode sourceCode, Reference`1<ICodePart> parentReference, Expression leftSide, ExpressionPrecedence previousPrecedence);
    private UnaryExpression GetConditionalPreprocessorNotExpression(SourceCode sourceCode, Reference`1<ICodePart> parentReference);
    private ParenthesizedExpression GetConditionalPreprocessorParenthesizedExpression(SourceCode sourceCode, Reference`1<ICodePart> parentReference);
    private Expression GetNextConditionalPreprocessorExpression(SourceCode sourceCode, ExpressionPrecedence previousPrecedence);
    private CatchStatement GetAttachedCatchStatement(TryStatement tryStatement, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private ElseStatement GetAttachedElseStatement(Reference`1<ICodePart> parentReference, Statement parentStatement, bool unsafeCode);
    private FinallyStatement GetAttachedFinallyStatement(TryStatement tryStatement, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Statement GetNextStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Statement GetNextStatement(Reference`1<ICodePart> parentReference, bool unsafeCode, VariableCollection variables);
    private bool IsWhenExpression();
    private Statement ParseWhenStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private bool MoveToStatement(Reference`1<ICodePart> parentReference);
    private AwaitStatement ParseAwaitStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private BlockStatement ParseBlockStatement(bool unsafeCode);
    private BreakStatement ParseBreakStatement(Reference`1<ICodePart> parentReference);
    private CheckedStatement ParseCheckedStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private ContinueStatement ParseContinueStatement(Reference`1<ICodePart> parentReference);
    private DoWhileStatement ParseDoWhileStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private ExpressionStatement ParseExpressionStatement(bool unsafeCode);
    private FixedStatement ParseFixedStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private ForStatement ParseForStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Expression ParseForStatementCondition(Reference`1<ICodePart> statementReference, bool unsafeCode);
    private List`1<Expression> ParseForStatementInitializers(Reference`1<ICodePart> statementReference, bool unsafeCode);
    private List`1<Expression> ParseForStatementIterators(Reference`1<ICodePart> statementReference, bool unsafeCode, Bracket openParenthesis, Node`1<CsToken> openParenthesisNode);
    private ForeachStatement ParseForeachStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private GotoStatement ParseGotoStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private IfStatement ParseIfStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private LabelStatement ParseLabelStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private LockStatement ParseLockStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private Statement ParseOtherStatement(Reference`1<ICodePart> parentReference, bool unsafeCode, VariableCollection variables);
    private ReturnStatement ParseReturnStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private void ParseStatementContainer(CsElement element, bool interfaceType, bool unsafeCode);
    private Node`1<CsToken> ParseStatementScope(IWriteableCodeUnit parent, Reference`1<ICodePart> parentReference, bool unsafeCode);
    private SwitchCaseStatement ParseSwitchCaseStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private SwitchDefaultStatement ParseSwitchDefaultStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private SwitchStatement ParseSwitchStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private List`1<SwitchCaseStatement> ParseSwitchStatementCaseStatements(Reference`1<ICodePart> statementReference, bool unsafeCode, SwitchDefaultStatement& defaultStatement);
    private ThrowStatement ParseThrowStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private TryStatement ParseTryStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private UncheckedStatement ParseUncheckedStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private UnsafeStatement ParseUnsafeStatement(Reference`1<ICodePart> parentReference);
    private UsingStatement ParseUsingStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private VariableDeclarationStatement ParseVariableDeclarationStatement(Reference`1<ICodePart> parentReference, bool unsafeCode, VariableCollection variables);
    private WhileStatement ParseWhileStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private YieldStatement ParseYieldStatement(Reference`1<ICodePart> parentReference, bool unsafeCode);
    private static OperatorSymbol CreateOperatorToken(Symbol symbol, Reference`1<ICodePart> parentReference, bool generated);
    private static bool GetOperatorType(Symbol symbol, OperatorType& type, OperatorCategory& category);
    private static SymbolType SymbolTypeFromOperatorType(OperatorType operatorType);
    private static CsTokenType TokenTypeFromSymbolType(SymbolType symbolType);
    private CsToken ConvertOperatorOverloadSymbol(Reference`1<ICodePart> parentReference);
    private CsToken ConvertSymbol(Symbol symbol, CsTokenType tokenType, Reference`1<ICodePart> parentReference);
    private Bracket GetBracketToken(CsTokenType tokenType, SymbolType symbolType, Reference`1<ICodePart> parentReference);
    private OperatorSymbol GetOperatorToken(OperatorType operatorType, Reference`1<ICodePart> parentReference);
    private CsToken GetToken(CsTokenType tokenType, SymbolType symbolType, Reference`1<ICodePart> parentReference);
    private CsToken GetToken(CsTokenType tokenType, SymbolType symbolType, Reference`1<ICodePart> parentReference, Reference`1<ICodePart> tokenParentReference);
    private TypeToken GetTypeToken(Reference`1<ICodePart> parentReference, bool unsafeCode, bool includeArrayBrackets);
    private TypeToken GetTypeToken(Reference`1<ICodePart> parentReference, bool unsafeCode, bool includeArrayBrackets, bool isExpression);
    private void GetTypeTokenArrayBrackets(Reference`1<ICodePart> typeTokenReference, MasterList`1<CsToken> typeTokens, Int32& startIndex);
    private TypeToken GetTypeTokenAux(Reference`1<ICodePart> typeTokenReference, Reference`1<ICodePart> parentReference, bool unsafeCode, bool includeArrayBrackets, bool isExpression, int startIndex, Int32& endIndex);
    private void GetTypeTokenBaseName(Reference`1<ICodePart> typeTokenReference, MasterList`1& typeTokens, Int32& startIndex, GenericType& generic, bool unsafeCode);
    private bool GetTypeTokenDereferenceSymbols(Reference`1<ICodePart> typeTokenReference, MasterList`1<CsToken> typeTokens, Int32& startIndex);
    private LiteralExpression GetNameTokenExpression(Reference`1<ICodePart> parentReference, bool unsafeCode, bool includeArrayBrackets);
    private LiteralExpression GetTypeTokenExpression(Reference`1<ICodePart> parentReference, bool unsafeCode, bool includeArrayBrackets);
    private LiteralExpression GetTypeTokenExpression(Reference`1<ICodePart> parentReference, bool unsafeCode, bool includeArrayBrackets, bool isExpression);
    private void GetTypeTokenNullableTypeSymbol(Reference`1<ICodePart> typeTokenReference, MasterList`1<CsToken> typeTokens, bool isExpression, Int32& startIndex);
    private bool IsNullableTypeSymbolFromIsExpression(int index);
}
public enum StyleCop.CSharp.CodePartType : Enum {
    public int value__;
    public static CodePartType Token;
    public static CodePartType Element;
    public static CodePartType Statement;
    public static CodePartType Expression;
    public static CodePartType QueryClause;
    public static CodePartType ConstraintClause;
    public static CodePartType Argument;
    public static CodePartType Parameter;
    public static CodePartType Variable;
    public static CodePartType FileHeader;
    public static CodePartType Document;
}
public class StyleCop.CSharp.CodeUnit : object {
    private static Expression[] EmptyExpressionArray;
    private static Statement[] EmptyStatementArray;
    private static CsTokenList emptyTokenList;
    private CodePartType codeUnitType;
    private VariableCollection variables;
    private CodeUnitCollection`1<Expression> expressions;
    private string friendlyPluralTypeName;
    private string friendlyTypeName;
    private Nullable`1<CodeLocation> location;
    private ICodePart parent;
    private CodeUnitCollection`1<Statement> statements;
    private CsTokenList tokens;
    private bool trimTokens;
    public ICollection`1<Expression> ChildExpressions { get; }
    public ICollection`1<Statement> ChildStatements { get; }
    public CodePartType CodePartType { get; }
    public string FriendlyPluralTypeText { get; }
    public string FriendlyTypeText { get; }
    public int LineNumber { get; }
    public CodeLocation Location { get; internal set; }
    public ICodePart Parent { get; }
    public bool HasBody { get; }
    public CsTokenList Tokens { get; internal set; }
    public VariableCollection Variables { get; }
    internal bool TrimTokens { get; internal set; }
    internal CodeUnit(CodePartType codeUnitType);
    internal CodeUnit(CodePartType codeUnitType, CsTokenList tokens);
    private static CodeUnit();
    public sealed virtual ICollection`1<Expression> get_ChildExpressions();
    public sealed virtual ICollection`1<Statement> get_ChildStatements();
    public sealed virtual CodePartType get_CodePartType();
    public sealed virtual string get_FriendlyPluralTypeText();
    public sealed virtual string get_FriendlyTypeText();
    public virtual int get_LineNumber();
    public virtual CodeLocation get_Location();
    internal virtual void set_Location(CodeLocation value);
    public sealed virtual ICodePart get_Parent();
    public bool get_HasBody();
    public virtual CsTokenList get_Tokens();
    internal virtual void set_Tokens(CsTokenList value);
    public sealed virtual VariableCollection get_Variables();
    internal bool get_TrimTokens();
    internal void set_TrimTokens(bool value);
    private sealed virtual override void StyleCop.CSharp.IWriteableCodeUnit.AddExpression(Expression expression);
    private sealed virtual override void StyleCop.CSharp.IWriteableCodeUnit.AddExpressions(IEnumerable`1<Expression> items);
    private sealed virtual override void StyleCop.CSharp.IWriteableCodeUnit.AddStatement(Statement statement);
    private sealed virtual override void StyleCop.CSharp.IWriteableCodeUnit.AddStatements(IEnumerable`1<Statement> items);
    private sealed virtual override void StyleCop.CSharp.IWriteableCodeUnit.SetParent(ICodePart parentCodeUnit);
    internal void AddExpression(Expression expression);
    internal void AddExpressions(IEnumerable`1<Expression> items);
    internal void AddStatement(Statement statement);
    internal void AddStatements(IEnumerable`1<Statement> items);
    internal string GetFriendlyPluralTypeText(string typeName);
    internal string GetFriendlyTypeText(string typeName);
}
internal class StyleCop.CSharp.CodeUnitCollection`1 : object {
    private ICodePart parent;
    private List`1<T> items;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICodePart Parent { get; }
    public CodeUnitCollection`1(ICodePart parent);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public ICodePart get_Parent();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    internal void Add(T item);
    internal void AddRange(IEnumerable`1<T> codeUnits);
    internal void Clear();
    internal bool Remove(T item);
    protected virtual void InitializeItem(T item);
    protected virtual void UninitializeItem(T item);
}
internal class StyleCop.CSharp.CodeWalker`1 : object {
    private CodeWalkerElementVisitor`1<T> elementCallback;
    private CodeWalkerExpressionVisitor`1<T> expressionCallback;
    private CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback;
    private CodeWalkerStatementVisitor`1<T> statementCallback;
    private CodeWalker`1(CsDocument document, CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    private CodeWalker`1(CsElement element, CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    private CodeWalker`1(Statement statement, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    private CodeWalker`1(Expression expression, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    private CodeWalker`1(QueryClause queryClause, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public static void Start(CsDocument document, CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public static void Start(CsElement element, CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public static void Start(Statement statement, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public static void Start(Expression expression, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public static void Start(QueryClause queryClause, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    private bool VisitElement(CsElement element, CsElement parentElement, T& context);
    private bool VisitExpression(Expression expression, Expression parentExpression, Statement parentStatement, CsElement parentElement, T& context);
    private bool VisitQueryClause(QueryClause clause, QueryClause parentClause, Expression parentExpression, Statement parentStatement, CsElement parentElement, T& context);
    private bool VisitStatement(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, T& context);
    private bool WalkElement(CsElement element, CsElement parentElement, T context);
    private bool WalkExpression(Expression expression, Expression parentExpression, Statement parentStatement, CsElement parentElement, T context);
    private bool WalkQueryClause(QueryClause clause, QueryClause parentClause, Expression parentExpression, Statement parentStatement, CsElement parentElement, T context);
    private bool WalkStatement(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, T context);
}
public class StyleCop.CSharp.CodeWalkerElementVisitor`1 : MulticastDelegate {
    public CodeWalkerElementVisitor`1(object object, IntPtr method);
    public virtual bool Invoke(CsElement element, CsElement parentElement, T context);
    public virtual IAsyncResult BeginInvoke(CsElement element, CsElement parentElement, T context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class StyleCop.CSharp.CodeWalkerExpressionVisitor`1 : MulticastDelegate {
    public CodeWalkerExpressionVisitor`1(object object, IntPtr method);
    public virtual bool Invoke(Expression expression, Expression parentExpression, Statement parentStatement, CsElement parentElement, T context);
    public virtual IAsyncResult BeginInvoke(Expression expression, Expression parentExpression, Statement parentStatement, CsElement parentElement, T context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class StyleCop.CSharp.CodeWalkerQueryClauseVisitor`1 : MulticastDelegate {
    public CodeWalkerQueryClauseVisitor`1(object object, IntPtr method);
    public virtual bool Invoke(QueryClause clause, QueryClause parentClause, Expression parentExpression, Statement parentStatement, CsElement parentElement, T context);
    public virtual IAsyncResult BeginInvoke(QueryClause clause, QueryClause parentClause, Expression parentExpression, Statement parentStatement, CsElement parentElement, T context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class StyleCop.CSharp.CodeWalkerStatementVisitor`1 : MulticastDelegate {
    public CodeWalkerStatementVisitor`1(object object, IntPtr method);
    public virtual bool Invoke(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, T context);
    public virtual IAsyncResult BeginInvoke(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, T context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class StyleCop.CSharp.CollectionInitializerExpression : Expression {
    public ICollection`1<Expression> Initializers { get; }
    internal CollectionInitializerExpression(CsTokenList tokens, IEnumerable`1<Expression> initializers);
    public ICollection`1<Expression> get_Initializers();
}
public class StyleCop.CSharp.ConditionalCompilationDirective : Preprocessor {
    private Expression body;
    private ConditionalCompilationDirectiveType type;
    public Expression Body { get; }
    public ConditionalCompilationDirectiveType ConditionalCompilationDirectiveType { get; }
    internal ConditionalCompilationDirective(string text, ConditionalCompilationDirectiveType type, Expression body, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public Expression get_Body();
    public ConditionalCompilationDirectiveType get_ConditionalCompilationDirectiveType();
}
public enum StyleCop.CSharp.ConditionalCompilationDirectiveType : Enum {
    public int value__;
    public static ConditionalCompilationDirectiveType If;
    public static ConditionalCompilationDirectiveType Elif;
    public static ConditionalCompilationDirectiveType Else;
    public static ConditionalCompilationDirectiveType Endif;
}
public class StyleCop.CSharp.ConditionalExpression : Expression {
    private Expression condition;
    private Expression falseValue;
    private Expression trueValue;
    public Expression Condition { get; }
    public Expression FalseExpression { get; }
    public Expression TrueExpression { get; }
    internal ConditionalExpression(CsTokenList tokens, Expression condition, Expression trueValue, Expression falseValue);
    public Expression get_Condition();
    public Expression get_FalseExpression();
    public Expression get_TrueExpression();
}
public class StyleCop.CSharp.ConditionalLogicalExpression : Expression {
    private Expression leftHandSide;
    private Operator operatorType;
    private Expression rightHandSide;
    public Expression LeftHandSide { get; }
    public Operator OperatorType { get; }
    public Expression RightHandSide { get; }
    internal ConditionalLogicalExpression(CsTokenList tokens, Operator operatorType, Expression leftHandSide, Expression rightHandSide);
    public Expression get_LeftHandSide();
    public Operator get_OperatorType();
    public Expression get_RightHandSide();
}
public class StyleCop.CSharp.Constructor : CsElement {
    private MethodInvocationExpression initializer;
    private IList`1<Parameter> parameters;
    public MethodInvocationExpression Initializer { get; }
    public IList`1<Parameter> Parameters { get; }
    internal Constructor(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, IList`1<Parameter> parameters, MethodInvocationExpression initializerExpression, bool unsafeCode, bool generated);
    public MethodInvocationExpression get_Initializer();
    public sealed virtual IList`1<Parameter> get_Parameters();
    internal virtual void Initialize();
}
public class StyleCop.CSharp.ConstructorConstraint : CsToken {
    private MasterList`1<CsToken> childTokens;
    public MasterList`1<CsToken> ChildTokens { get; }
    private ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.Tokens { get; }
    internal ConstructorConstraint(MasterList`1<CsToken> childTokens, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public MasterList`1<CsToken> get_ChildTokens();
    private sealed virtual override ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.get_Tokens();
    protected virtual void CreateTextString();
}
public class StyleCop.CSharp.ConstructorInitializerStatement : Statement {
    private MethodInvocationExpression expression;
    public MethodInvocationExpression Expression { get; }
    internal ConstructorInitializerStatement(CsTokenList tokens, MethodInvocationExpression expression);
    public MethodInvocationExpression get_Expression();
}
public class StyleCop.CSharp.ContinueStatement : Statement {
    internal ContinueStatement(CsTokenList tokens);
}
public class StyleCop.CSharp.CsDocument : CodeDocument {
    private DocumentRoot contents;
    private FileHeader fileHeader;
    private CsParser parser;
    private MasterList`1<CsToken> tokens;
    public CodePartType CodePartType { get; }
    public ICodeElement DocumentContents { get; }
    public FileHeader FileHeader { get; internal set; }
    public int LineNumber { get; }
    public CodeLocation Location { get; }
    public ICodePart Parent { get; }
    public CsParser Parser { get; }
    public DocumentRoot RootElement { get; internal set; }
    public MasterList`1<CsToken> Tokens { get; }
    private ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.Tokens { get; }
    internal MasterList`1<CsToken> MasterTokenList { get; }
    internal CsDocument(SourceCode sourceCode, CsParser parser, MasterList`1<CsToken> tokens);
    internal CsDocument(SourceCode sourceCode, CsParser parser);
    public sealed virtual CodePartType get_CodePartType();
    public virtual ICodeElement get_DocumentContents();
    public FileHeader get_FileHeader();
    internal void set_FileHeader(FileHeader value);
    public sealed virtual int get_LineNumber();
    public sealed virtual CodeLocation get_Location();
    public sealed virtual ICodePart get_Parent();
    public CsParser get_Parser();
    public DocumentRoot get_RootElement();
    internal void set_RootElement(DocumentRoot value);
    public MasterList`1<CsToken> get_Tokens();
    private sealed virtual override ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.get_Tokens();
    internal MasterList`1<CsToken> get_MasterTokenList();
    public void WalkDocument(CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public void WalkDocument(CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, T context);
    public void WalkDocument(CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, T context);
    public void WalkDocument(CodeWalkerElementVisitor`1<T> elementCallback, T context);
    public void WalkDocument(CodeWalkerElementVisitor`1<object> elementCallback, CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback, CodeWalkerQueryClauseVisitor`1<object> queryClauseCallback);
    public void WalkDocument(CodeWalkerElementVisitor`1<object> elementCallback, CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback);
    public void WalkDocument(CodeWalkerElementVisitor`1<object> elementCallback, CodeWalkerStatementVisitor`1<object> statementCallback);
    public void WalkDocument(CodeWalkerElementVisitor`1<object> elementCallback);
    protected virtual void Dispose(bool disposing);
}
public abstract class StyleCop.CSharp.CsElement : CodeUnit {
    private static CsElement[] EmptyElementArray;
    private ICollection`1<Attribute> attributes;
    private Declaration declaration;
    private CsDocument document;
    private string fullNamespaceName;
    private string fullyQualifiedBase;
    private bool generated;
    private XmlHeader header;
    private string name;
    private ElementType type;
    private bool unsafeCode;
    private Dictionary`2<int, Violation> violations;
    private AccessModifierType actualAccess;
    private object analyzerTag;
    private CodeUnitCollection`1<CsElement> elements;
    private string fullyQualifiedName;
    public AccessModifierType AccessModifier { get; }
    public AccessModifierType ActualAccess { get; }
    public object AnalyzerTag { get; public set; }
    public ICollection`1<Attribute> Attributes { get; }
    public IEnumerable`1<ICodeElement> ChildCodeElements { get; }
    public ICollection`1<CsElement> ChildElements { get; }
    public Declaration Declaration { get; }
    public CodeDocument Document { get; }
    public IEnumerable`1<CsToken> ElementTokens { get; }
    public ElementType ElementType { get; }
    public string FullNamespaceName { get; }
    public string FullyQualifiedName { get; }
    public bool Generated { get; }
    public XmlHeader Header { get; }
    public string Name { get; }
    public bool Unsafe { get; }
    public ICollection`1<Violation> Violations { get; }
    protected string QualifiedName { get; protected set; }
    internal CsElement(CsDocument document, CsElement parent, ElementType type, string name, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, bool unsafeCode, bool generated);
    private static CsElement();
    public AccessModifierType get_AccessModifier();
    public AccessModifierType get_ActualAccess();
    public object get_AnalyzerTag();
    public void set_AnalyzerTag(object value);
    public ICollection`1<Attribute> get_Attributes();
    public sealed virtual IEnumerable`1<ICodeElement> get_ChildCodeElements();
    public ICollection`1<CsElement> get_ChildElements();
    public Declaration get_Declaration();
    public sealed virtual CodeDocument get_Document();
    public IEnumerable`1<CsToken> get_ElementTokens();
    public ElementType get_ElementType();
    public string get_FullNamespaceName();
    public sealed virtual string get_FullyQualifiedName();
    public bool get_Generated();
    public XmlHeader get_Header();
    public string get_Name();
    public bool get_Unsafe();
    public sealed virtual ICollection`1<Violation> get_Violations();
    protected string get_QualifiedName();
    protected void set_QualifiedName(string value);
    public sealed virtual bool AddViolation(Violation violation);
    public virtual void ClearAnalyzerTags();
    public void WalkElement(CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public void WalkElement(CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, T context);
    public void WalkElement(CodeWalkerElementVisitor`1<T> elementCallback, CodeWalkerStatementVisitor`1<T> statementCallback, T context);
    public void WalkElement(CodeWalkerElementVisitor`1<T> elementCallback, T context);
    public void WalkElement(CodeWalkerElementVisitor`1<object> elementCallback, CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback, CodeWalkerQueryClauseVisitor`1<object> queryClauseCallback);
    public void WalkElement(CodeWalkerElementVisitor`1<object> elementCallback, CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback);
    public void WalkElement(CodeWalkerElementVisitor`1<object> elementCallback, CodeWalkerStatementVisitor`1<object> statementCallback);
    public void WalkElement(CodeWalkerElementVisitor`1<object> elementCallback);
    internal virtual void AddElement(CsElement element);
    internal virtual void Initialize();
    private void MergeAccess(AccessModifierType parentAccess);
}
[SourceParserAttribute]
public class StyleCop.CSharp.CsParser : SourceParser {
    internal static string AnalyzeDesignerFilesProperty;
    internal static string AnalyzeGeneratedFilesProperty;
    internal static string GeneratedFileFiltersProperty;
    private static String[] DefaultGeneratedFileFilters;
    private ReaderWriterLock suppressionsLock;
    private Dictionary`2<string, List`1<CsElement>> partialElements;
    private Dictionary`2<SuppressedRule, List`1<CsElement>> suppressions;
    internal Dictionary`2<string, List`1<CsElement>> PartialElements { get; }
    private static CsParser();
    internal Dictionary`2<string, List`1<CsElement>> get_PartialElements();
    public virtual bool IsRuleSuppressed(ICodeElement element, string ruleCheckId, string ruleName, string ruleNamespace);
    public virtual bool ParseFile(SourceCode sourceCode, int passNumber, CodeDocument& document);
    public virtual void PostParse();
    public virtual void PreParse();
    public virtual bool SkipAnalysisForDocument(SourceCode sourceCode);
    internal static string GetPreprocessorDirectiveType(Symbol preprocessor, Int32& bodyIndex);
    internal void AddRuleSuppression(CsElement element, string ruleId, string ruleName, string ruleNamespace);
    private static bool MatchElementWithPossibleElementsTraversingParents(CsElement element, IList`1<CsElement> possibleElements);
}
public class StyleCop.CSharp.CsToken : object {
    private bool generated;
    private CodeLocation location;
    private CsTokenClass tokenClass;
    private CsTokenType tokenType;
    private Reference`1<ICodePart> parent;
    private string text;
    public CodePartType CodePartType { get; }
    public CsTokenClass CsTokenClass { get; }
    public CsTokenType CsTokenType { get; }
    public bool Generated { get; }
    public int LineNumber { get; }
    public CodeLocation Location { get; }
    public ICodePart Parent { get; }
    public string Text { get; protected set; }
    internal Reference`1<ICodePart> ParentRef { get; internal set; }
    internal CsToken(string text, CsTokenType tokenType, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    internal CsToken(CsTokenType tokenType, CsTokenClass tokenClass, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    internal CsToken(string text, CsTokenType tokenType, CsTokenClass tokenClass, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public sealed virtual CodePartType get_CodePartType();
    public CsTokenClass get_CsTokenClass();
    public CsTokenType get_CsTokenType();
    public bool get_Generated();
    public virtual int get_LineNumber();
    public virtual CodeLocation get_Location();
    public sealed virtual ICodePart get_Parent();
    public virtual string get_Text();
    protected virtual void set_Text(string value);
    internal Reference`1<ICodePart> get_ParentRef();
    internal void set_ParentRef(Reference`1<ICodePart> value);
    public virtual string ToString();
    internal static CodeLocation JoinLocations(CodeLocation location1, CsToken token2);
    internal static CodeLocation JoinLocations(CodeLocation location1, Node`1<CsToken> token2);
    internal static CodeLocation JoinLocations(CsToken token1, CsToken token2);
    internal static CodeLocation JoinLocations(Node`1<CsToken> token1, Node`1<CsToken> token2);
    protected virtual void CreateTextString();
}
public enum StyleCop.CSharp.CsTokenClass : Enum {
    public int value__;
    public static CsTokenClass Attribute;
    public static CsTokenClass GenericType;
    public static CsTokenClass Number;
    public static CsTokenClass PreprocessorDirective;
    public static CsTokenClass RegionDirective;
    public static CsTokenClass ConditionalCompilationDirective;
    public static CsTokenClass Type;
    public static CsTokenClass Whitespace;
    public static CsTokenClass XmlHeader;
    public static CsTokenClass OperatorSymbol;
    public static CsTokenClass Bracket;
    public static CsTokenClass ConstructorConstraint;
    public static CsTokenClass Token;
}
public class StyleCop.CSharp.CsTokenList : ItemList`1<CsToken> {
    public CsTokenList(MasterList`1<CsToken> masterList);
    public CsTokenList(MasterList`1<CsToken> masterList, Node`1<CsToken> firstItemNode, Node`1<CsToken> lastItemNode);
    public static Node`1<CsToken> GetNextCodeToken(Node`1<CsToken> start);
    public static bool MatchTokens(Node`1<CsToken> start, String[] values);
    public static bool MatchTokens(StringComparison comparisonType, Node`1<CsToken> start, String[] values);
    public bool MatchTokens(String[] values);
    public bool MatchTokens(StringComparison comparisonType, String[] values);
    internal int Trim();
    internal int Trim(CsTokenType[] types);
}
public enum StyleCop.CSharp.CsTokenType : Enum {
    public int value__;
    public static CsTokenType OpenParenthesis;
    public static CsTokenType CloseParenthesis;
    public static CsTokenType OpenCurlyBracket;
    public static CsTokenType CloseCurlyBracket;
    public static CsTokenType OpenSquareBracket;
    public static CsTokenType CloseSquareBracket;
    public static CsTokenType OpenGenericBracket;
    public static CsTokenType CloseGenericBracket;
    public static CsTokenType OperatorSymbol;
    public static CsTokenType BaseColon;
    public static CsTokenType WhereColon;
    public static CsTokenType AttributeColon;
    public static CsTokenType LabelColon;
    public static CsTokenType Comma;
    public static CsTokenType Semicolon;
    public static CsTokenType NullableTypeSymbol;
    public static CsTokenType Abstract;
    public static CsTokenType Add;
    public static CsTokenType Alias;
    public static CsTokenType As;
    public static CsTokenType Ascending;
    public static CsTokenType Base;
    public static CsTokenType Break;
    public static CsTokenType By;
    public static CsTokenType Case;
    public static CsTokenType Catch;
    public static CsTokenType Checked;
    public static CsTokenType Class;
    public static CsTokenType Const;
    public static CsTokenType Continue;
    public static CsTokenType Default;
    public static CsTokenType DefaultValue;
    public static CsTokenType Delegate;
    public static CsTokenType Descending;
    public static CsTokenType Do;
    public static CsTokenType Else;
    public static CsTokenType Enum;
    public static CsTokenType Equals;
    public static CsTokenType Event;
    public static CsTokenType Explicit;
    public static CsTokenType Extern;
    public static CsTokenType ExternDirective;
    public static CsTokenType False;
    public static CsTokenType Finally;
    public static CsTokenType Fixed;
    public static CsTokenType For;
    public static CsTokenType Foreach;
    public static CsTokenType From;
    public static CsTokenType Get;
    public static CsTokenType Goto;
    public static CsTokenType Group;
    public static CsTokenType If;
    public static CsTokenType Implicit;
    public static CsTokenType In;
    public static CsTokenType Interface;
    public static CsTokenType Internal;
    public static CsTokenType Into;
    public static CsTokenType Is;
    public static CsTokenType Join;
    public static CsTokenType Let;
    public static CsTokenType Lock;
    public static CsTokenType Nameof;
    public static CsTokenType Namespace;
    public static CsTokenType New;
    public static CsTokenType Null;
    public static CsTokenType On;
    public static CsTokenType Operator;
    public static CsTokenType OrderBy;
    public static CsTokenType Out;
    public static CsTokenType Override;
    public static CsTokenType Params;
    public static CsTokenType Partial;
    public static CsTokenType Private;
    public static CsTokenType Protected;
    public static CsTokenType Public;
    public static CsTokenType Readonly;
    public static CsTokenType Ref;
    public static CsTokenType Remove;
    public static CsTokenType Return;
    public static CsTokenType Sealed;
    public static CsTokenType Select;
    public static CsTokenType Set;
    public static CsTokenType Sizeof;
    public static CsTokenType Stackalloc;
    public static CsTokenType Static;
    public static CsTokenType Struct;
    public static CsTokenType Switch;
    public static CsTokenType This;
    public static CsTokenType Throw;
    public static CsTokenType True;
    public static CsTokenType Try;
    public static CsTokenType Typeof;
    public static CsTokenType Unchecked;
    public static CsTokenType Unsafe;
    public static CsTokenType Using;
    public static CsTokenType UsingDirective;
    public static CsTokenType Virtual;
    public static CsTokenType Volatile;
    public static CsTokenType Where;
    public static CsTokenType While;
    public static CsTokenType WhileDo;
    public static CsTokenType Yield;
    public static CsTokenType Other;
    public static CsTokenType WhiteSpace;
    public static CsTokenType EndOfLine;
    public static CsTokenType String;
    public static CsTokenType Number;
    public static CsTokenType SingleLineComment;
    public static CsTokenType MultiLineComment;
    public static CsTokenType PreprocessorDirective;
    public static CsTokenType Attribute;
    public static CsTokenType OpenAttributeBracket;
    public static CsTokenType CloseAttributeBracket;
    public static CsTokenType XmlHeader;
    public static CsTokenType XmlHeaderLine;
    public static CsTokenType DestructorTilde;
    public static CsTokenType Async;
    public static CsTokenType Await;
    public static CsTokenType When;
}
public class StyleCop.CSharp.Declaration : object {
    private ElementType elementType;
    private Dictionary`2<CsTokenType, CsToken> modifiers;
    private string name;
    private CsTokenList tokens;
    private AccessModifierType accessModifierType;
    public bool AccessModifier { get; }
    public AccessModifierType AccessModifierType { get; internal set; }
    public ElementType ElementType { get; }
    public string Name { get; }
    public CsTokenList Tokens { get; }
    internal Declaration(CsTokenList tokens, string name, ElementType elementType, AccessModifierType accessModifierType);
    internal Declaration(CsTokenList tokens, string name, ElementType elementType, AccessModifierType accessModifierType, Dictionary`2<CsTokenType, CsToken> modifiers);
    public bool get_AccessModifier();
    public AccessModifierType get_AccessModifierType();
    internal void set_AccessModifierType(AccessModifierType value);
    public ElementType get_ElementType();
    public string get_Name();
    public CsTokenList get_Tokens();
    public bool ContainsModifier(CsTokenType[] types);
}
public class StyleCop.CSharp.DecrementExpression : Expression {
    private DecrementType decrementType;
    private Expression value;
    public DecrementType Type { get; }
    public Expression Value { get; }
    internal DecrementExpression(CsTokenList tokens, Expression value, DecrementType decrementType);
    public DecrementType get_Type();
    public Expression get_Value();
}
public class StyleCop.CSharp.DefaultValueExpression : Expression {
    private Reference`1<ICodePart> parent;
    private TypeToken type;
    public TypeToken Type { get; }
    private ICodePart StyleCop.CSharp.ICodePart.Parent { get; }
    internal DefaultValueExpression(CsTokenList tokens, LiteralExpression type, Reference`1<ICodePart> parent);
    public TypeToken get_Type();
    private sealed virtual override ICodePart StyleCop.CSharp.ICodePart.get_Parent();
}
public class StyleCop.CSharp.Delegate : CsElement {
    private IList`1<Parameter> parameters;
    private TypeToken returnType;
    private ICollection`1<TypeParameterConstraintClause> typeConstraints;
    public IList`1<Parameter> Parameters { get; }
    public TypeToken ReturnType { get; }
    public ICollection`1<TypeParameterConstraintClause> TypeConstraints { get; }
    internal Delegate(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, TypeToken returnType, IList`1<Parameter> parameters, ICollection`1<TypeParameterConstraintClause> typeConstraints, bool unsafeCode, bool generated);
    public sealed virtual IList`1<Parameter> get_Parameters();
    public TypeToken get_ReturnType();
    public sealed virtual ICollection`1<TypeParameterConstraintClause> get_TypeConstraints();
}
public class StyleCop.CSharp.Destructor : CsElement {
    internal Destructor(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, bool unsafeCode, bool generated);
}
public class StyleCop.CSharp.DictionaryInitializerExpression : Expression {
    public ICollection`1<Expression> Initializers { get; }
    internal DictionaryInitializerExpression(CsTokenList tokens, IEnumerable`1<Expression> initializers);
    public ICollection`1<Expression> get_Initializers();
}
public class StyleCop.CSharp.DictionaryItemInitializationExpression : Expression {
    public ICollection`1<Expression> Initializers { get; }
    internal DictionaryItemInitializationExpression(CsTokenList tokens);
    public ICollection`1<Expression> get_Initializers();
}
public class StyleCop.CSharp.DocumentRoot : Namespace {
    internal DocumentRoot(CsDocument document, Declaration declaration, bool generated);
}
public class StyleCop.CSharp.DoWhileStatement : Statement {
    private Expression conditionExpression;
    private Statement embeddedStatement;
    public Expression ConditionalExpression { get; }
    public Statement EmbeddedStatement { get; }
    internal DoWhileStatement(CsTokenList tokens, Expression conditionExpression, Statement embeddedStatement);
    public Expression get_ConditionalExpression();
    public Statement get_EmbeddedStatement();
}
public enum StyleCop.CSharp.ElementType : Enum {
    public int value__;
    public static ElementType File;
    public static ElementType Root;
    public static ElementType ExternAliasDirective;
    public static ElementType UsingDirective;
    public static ElementType AssemblyOrModuleAttribute;
    public static ElementType Namespace;
    public static ElementType Field;
    public static ElementType Constructor;
    public static ElementType Destructor;
    public static ElementType Delegate;
    public static ElementType Event;
    public static ElementType Enum;
    public static ElementType Interface;
    public static ElementType Property;
    public static ElementType Accessor;
    public static ElementType Indexer;
    public static ElementType Method;
    public static ElementType Struct;
    public static ElementType Class;
    public static ElementType EnumItem;
    public static ElementType ConstructorInitializer;
    public static ElementType EmptyElement;
}
public class StyleCop.CSharp.ElseStatement : Statement {
    private Expression conditionExpression;
    private ElseStatement elseStatement;
    private Statement embeddedStatement;
    public ElseStatement AttachedElseStatement { get; internal set; }
    public IEnumerable`1<Statement> AttachedStatements { get; }
    public Expression ConditionExpression { get; }
    public Statement EmbeddedStatement { get; internal set; }
    internal ElseStatement(CsTokenList tokens, Expression conditionExpression);
    public ElseStatement get_AttachedElseStatement();
    internal void set_AttachedElseStatement(ElseStatement value);
    public virtual IEnumerable`1<Statement> get_AttachedStatements();
    public Expression get_ConditionExpression();
    public Statement get_EmbeddedStatement();
    internal void set_EmbeddedStatement(Statement value);
}
public class StyleCop.CSharp.EmptyElement : CsElement {
    internal EmptyElement(CsDocument document, CsElement parent, Declaration declaration, bool unsafeCode, bool generated);
}
public class StyleCop.CSharp.EmptyStatement : Statement {
    internal EmptyStatement(CsTokenList tokens);
}
public class StyleCop.CSharp.Enum : CsElement {
    private string baseType;
    private ICollection`1<EnumItem> items;
    public string BaseType { get; }
    public ICollection`1<EnumItem> Items { get; internal set; }
    internal Enum(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, bool unsafeCode, bool generated);
    public string get_BaseType();
    public ICollection`1<EnumItem> get_Items();
    internal void set_Items(ICollection`1<EnumItem> value);
    internal virtual void Initialize();
    private string GetBaseType();
}
public class StyleCop.CSharp.EnumItem : CsElement {
    private Expression initialization;
    public Expression Initialization { get; }
    internal EnumItem(CsDocument document, Enum parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, Expression initialization, bool unsafeCode, bool generated);
    public Expression get_Initialization();
}
public class StyleCop.CSharp.Event : CsElement {
    private ICollection`1<EventDeclaratorExpression> eventDeclarators;
    private TypeToken eventHandlerType;
    private Accessor add;
    private Accessor remove;
    public Accessor AddAccessor { get; }
    public ICollection`1<EventDeclaratorExpression> Declarators { get; }
    public TypeToken EventHandlerType { get; }
    public Accessor RemoveAccessor { get; }
    internal Event(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, TypeToken eventHandlerType, ICollection`1<EventDeclaratorExpression> eventDeclarators, bool unsafeCode, bool generated);
    public Accessor get_AddAccessor();
    public ICollection`1<EventDeclaratorExpression> get_Declarators();
    public TypeToken get_EventHandlerType();
    public Accessor get_RemoveAccessor();
    internal virtual void Initialize();
}
public class StyleCop.CSharp.EventDeclaratorExpression : Expression {
    private LiteralExpression identifier;
    private Expression initializer;
    [CompilerGeneratedAttribute]
private Event <ParentEvent>k__BackingField;
    public LiteralExpression Identifier { get; }
    public Expression Initializer { get; }
    public Event ParentEvent { get; internal set; }
    internal EventDeclaratorExpression(CsTokenList tokens, LiteralExpression identifier, Expression initializer);
    public LiteralExpression get_Identifier();
    public Expression get_Initializer();
    [CompilerGeneratedAttribute]
public Event get_ParentEvent();
    [CompilerGeneratedAttribute]
internal void set_ParentEvent(Event value);
}
[DebuggerDisplayAttribute("{Text}")]
public class StyleCop.CSharp.Expression : CodeUnit {
    private ExpressionType type;
    private string text;
    public ExpressionType ExpressionType { get; }
    public string Text { get; }
    internal Expression(ExpressionType type);
    internal Expression(ExpressionType type, CsTokenList tokens);
    public ExpressionType get_ExpressionType();
    public string get_Text();
    public void WalkExpression(CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public void WalkExpression(CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, T context);
    public void WalkExpression(CodeWalkerStatementVisitor`1<T> statementCallback, T context);
    public void WalkExpression(CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback, CodeWalkerQueryClauseVisitor`1<object> queryClauseCallback);
    public void WalkExpression(CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback);
    public void WalkExpression(CodeWalkerStatementVisitor`1<object> statementCallback);
    private void CreateTextString();
}
public class StyleCop.CSharp.ExpressionStatement : Statement {
    private Expression expression;
    public Expression Expression { get; }
    internal ExpressionStatement(CsTokenList tokens, Expression expression);
    public Expression get_Expression();
}
public enum StyleCop.CSharp.ExpressionType : Enum {
    public int value__;
    public static ExpressionType AnonymousMethod;
    public static ExpressionType Arithmetic;
    public static ExpressionType ArrayAccess;
    public static ExpressionType ArrayInitializer;
    public static ExpressionType As;
    public static ExpressionType Assignment;
    public static ExpressionType Attribute;
    public static ExpressionType Await;
    public static ExpressionType Bodied;
    public static ExpressionType Cast;
    public static ExpressionType Checked;
    public static ExpressionType CollectionInitializer;
    public static ExpressionType Conditional;
    public static ExpressionType ConditionalLogical;
    public static ExpressionType Decrement;
    public static ExpressionType DefaultValue;
    public static ExpressionType ExpressionList;
    public static ExpressionType Increment;
    public static ExpressionType Is;
    public static ExpressionType Lambda;
    public static ExpressionType Literal;
    public static ExpressionType Logical;
    public static ExpressionType MemberAccess;
    public static ExpressionType MethodInvocation;
    public static ExpressionType NameOf;
    public static ExpressionType NewArray;
    public static ExpressionType New;
    public static ExpressionType NullCoalescing;
    public static ExpressionType ObjectInitializer;
    public static ExpressionType Parenthesized;
    public static ExpressionType Query;
    public static ExpressionType Relational;
    public static ExpressionType Sizeof;
    public static ExpressionType Stackalloc;
    public static ExpressionType Typeof;
    public static ExpressionType Unary;
    public static ExpressionType Unchecked;
    public static ExpressionType UnsafeAccess;
    public static ExpressionType VariableDeclaration;
    public static ExpressionType VariableDeclarator;
    public static ExpressionType EventDeclarator;
}
public class StyleCop.CSharp.ExpressionWithParameters : Expression {
    private List`1<Parameter> parameters;
    private IList`1<Parameter> readOnlyParameters;
    public IList`1<Parameter> Parameters { get; }
    internal ExpressionWithParameters(ExpressionType type);
    public sealed virtual IList`1<Parameter> get_Parameters();
    internal void AddParameter(Parameter parameter);
    internal void AddParameters(IEnumerable`1<Parameter> items);
}
public class StyleCop.CSharp.ExternAliasDirective : CsElement {
    private string identifier;
    public string Identifier { get; }
    internal ExternAliasDirective(CsDocument document, CsElement parent, Declaration declaration, bool generated);
    public string get_Identifier();
    internal virtual void Initialize();
}
public class StyleCop.CSharp.Field : CsElement {
    private bool isConst;
    private bool isReadOnly;
    private bool isStatic;
    private TypeToken type;
    private VariableDeclarationStatement declaration;
    public bool Const { get; }
    public TypeToken FieldType { get; }
    public bool Readonly { get; }
    public bool Static { get; }
    public VariableDeclarationStatement VariableDeclarationStatement { get; internal set; }
    internal Field(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, TypeToken fieldType, bool unsafeCode, bool generated);
    public bool get_Const();
    public TypeToken get_FieldType();
    public bool get_Readonly();
    public bool get_Static();
    public VariableDeclarationStatement get_VariableDeclarationStatement();
    internal void set_VariableDeclarationStatement(VariableDeclarationStatement value);
}
public class StyleCop.CSharp.FileHeader : object {
    private bool generated;
    private string headerText;
    private string headerXml;
    private CodeLocation location;
    private Reference`1<ICodePart> parent;
    private CsTokenList tokens;
    [CompilerGeneratedAttribute]
private bool <UnStyled>k__BackingField;
    public CodePartType CodePartType { get; }
    public bool Generated { get; }
    public string HeaderText { get; }
    public string HeaderXml { get; }
    public int LineNumber { get; }
    public CodeLocation Location { get; }
    public ICodePart Parent { get; }
    public CsTokenList Tokens { get; }
    public bool UnStyled { get; private set; }
    internal FileHeader(string headerText, CsTokenList tokens, Reference`1<ICodePart> parent);
    public sealed virtual CodePartType get_CodePartType();
    public bool get_Generated();
    public string get_HeaderText();
    public string get_HeaderXml();
    public sealed virtual int get_LineNumber();
    public sealed virtual CodeLocation get_Location();
    public sealed virtual ICodePart get_Parent();
    public CsTokenList get_Tokens();
    [CompilerGeneratedAttribute]
public bool get_UnStyled();
    [CompilerGeneratedAttribute]
private void set_UnStyled(bool value);
    public static string HtmlEncode(string value);
}
public class StyleCop.CSharp.FinallyStatement : Statement {
    private BlockStatement embeddedStatement;
    private TryStatement tryStatement;
    public BlockStatement EmbeddedStatement { get; }
    public TryStatement TryStatement { get; }
    internal FinallyStatement(CsTokenList tokens, TryStatement tryStatement, BlockStatement embeddedStatement);
    public BlockStatement get_EmbeddedStatement();
    public TryStatement get_TryStatement();
}
public class StyleCop.CSharp.FixedStatement : Statement {
    private VariableDeclarationExpression fixedVariable;
    private Statement embeddedStatement;
    public Statement EmbeddedStatement { get; internal set; }
    public VariableDeclarationExpression FixedVariable { get; }
    internal FixedStatement(CsTokenList tokens, VariableDeclarationExpression fixedVariable);
    public Statement get_EmbeddedStatement();
    internal void set_EmbeddedStatement(Statement value);
    public VariableDeclarationExpression get_FixedVariable();
}
public class StyleCop.CSharp.ForeachStatement : Statement {
    private Expression item;
    private VariableDeclarationExpression variable;
    private Statement embeddedStatement;
    public Statement EmbeddedStatement { get; internal set; }
    public Expression Item { get; }
    public VariableDeclarationExpression Variable { get; }
    internal ForeachStatement(CsTokenList tokens, VariableDeclarationExpression variable, Expression item);
    public Statement get_EmbeddedStatement();
    internal void set_EmbeddedStatement(Statement value);
    public Expression get_Item();
    public VariableDeclarationExpression get_Variable();
}
public class StyleCop.CSharp.ForStatement : Statement {
    private Expression condition;
    private ICollection`1<Expression> initializers;
    private ICollection`1<Expression> iterators;
    private Statement embeddedStatement;
    public Expression Condition { get; }
    public Statement EmbeddedStatement { get; internal set; }
    public ICollection`1<Expression> Initializers { get; }
    public ICollection`1<Expression> Iterators { get; }
    internal ForStatement(CsTokenList tokens, ICollection`1<Expression> initializers, Expression condition, ICollection`1<Expression> iterators);
    public Expression get_Condition();
    public Statement get_EmbeddedStatement();
    internal void set_EmbeddedStatement(Statement value);
    public ICollection`1<Expression> get_Initializers();
    public ICollection`1<Expression> get_Iterators();
}
public class StyleCop.CSharp.GenericType : TypeToken {
    private ICollection`1<GenericTypeParameter> typeParameters;
    public ICollection`1<GenericTypeParameter> GenericTypesParameters { get; }
    internal GenericType(MasterList`1<CsToken> childTokens, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public ICollection`1<GenericTypeParameter> get_GenericTypesParameters();
    protected virtual void CreateTextString();
    private void ExtractGenericTypes();
}
public class StyleCop.CSharp.GenericTypeParameter : object {
    private ParameterModifiers modifiers;
    private TypeToken type;
    public ParameterModifiers Modifiers { get; }
    public TypeToken Type { get; }
    internal GenericTypeParameter(TypeToken type, ParameterModifiers modifiers);
    public ParameterModifiers get_Modifiers();
    public TypeToken get_Type();
}
public class StyleCop.CSharp.GotoStatement : Statement {
    private Expression identifier;
    public Expression Identifier { get; }
    internal GotoStatement(CsTokenList tokens, Expression identifier);
    public Expression get_Identifier();
}
public interface StyleCop.CSharp.ICodePart {
    public CodePartType CodePartType { get; }
    public int LineNumber { get; }
    public CodeLocation Location { get; }
    public ICodePart Parent { get; }
    public abstract virtual CodePartType get_CodePartType();
    public abstract virtual int get_LineNumber();
    public abstract virtual CodeLocation get_Location();
    public abstract virtual ICodePart get_Parent();
}
[ExtensionAttribute]
public static class StyleCop.CSharp.ICodePartExtensions : object {
    [ExtensionAttribute]
public static CsElement FindParentElement(ICodePart part);
    [ExtensionAttribute]
public static Expression FindParentExpression(ICodePart part);
    [ExtensionAttribute]
public static Statement FindParentStatement(ICodePart part);
}
public interface StyleCop.CSharp.ICodeUnit {
    public ICollection`1<Expression> ChildExpressions { get; }
    public ICollection`1<Statement> ChildStatements { get; }
    public string FriendlyPluralTypeText { get; }
    public string FriendlyTypeText { get; }
    public CsTokenList Tokens { get; }
    public VariableCollection Variables { get; }
    public abstract virtual ICollection`1<Expression> get_ChildExpressions();
    public abstract virtual ICollection`1<Statement> get_ChildStatements();
    public abstract virtual string get_FriendlyPluralTypeText();
    public abstract virtual string get_FriendlyTypeText();
    public abstract virtual CsTokenList get_Tokens();
    public abstract virtual VariableCollection get_Variables();
}
public class StyleCop.CSharp.IfStatement : Statement {
    private Expression conditionExpression;
    private ElseStatement elseStatement;
    private Statement embeddedStatement;
    public ElseStatement AttachedElseStatement { get; internal set; }
    public IEnumerable`1<Statement> AttachedStatements { get; }
    public Expression ConditionExpression { get; }
    public Statement EmbeddedStatement { get; internal set; }
    internal IfStatement(CsTokenList tokens, Expression conditionExpression);
    public ElseStatement get_AttachedElseStatement();
    internal void set_AttachedElseStatement(ElseStatement value);
    public virtual IEnumerable`1<Statement> get_AttachedStatements();
    public Expression get_ConditionExpression();
    public Statement get_EmbeddedStatement();
    internal void set_EmbeddedStatement(Statement value);
}
public class StyleCop.CSharp.IncrementExpression : Expression {
    private IncrementType incrementType;
    private Expression value;
    public IncrementType Type { get; }
    public Expression Value { get; }
    internal IncrementExpression(CsTokenList tokens, Expression value, IncrementType incrementType);
    public IncrementType get_Type();
    public Expression get_Value();
}
public class StyleCop.CSharp.Indexer : CsElement {
    private IList`1<Parameter> parameters;
    private TypeToken returnType;
    private Accessor get;
    private Accessor set;
    public Accessor GetAccessor { get; }
    public IList`1<Parameter> Parameters { get; }
    public TypeToken ReturnType { get; }
    public Accessor SetAccessor { get; }
    internal Indexer(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, TypeToken returnType, IList`1<Parameter> parameters, bool unsafeCode, bool generated);
    public Accessor get_GetAccessor();
    public sealed virtual IList`1<Parameter> get_Parameters();
    public TypeToken get_ReturnType();
    public Accessor get_SetAccessor();
    internal virtual void Initialize();
}
public class StyleCop.CSharp.Interface : ClassBase {
    internal Interface(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, ICollection`1<TypeParameterConstraintClause> typeConstraints, bool unsafeCode, bool generated);
    internal virtual void Initialize();
}
public interface StyleCop.CSharp.IParameterContainer {
    public IList`1<Parameter> Parameters { get; }
    public abstract virtual IList`1<Parameter> get_Parameters();
}
public class StyleCop.CSharp.IsExpression : Expression {
    private TypeToken type;
    private Expression value;
    public TypeToken Type { get; }
    public Expression Value { get; }
    internal IsExpression(CsTokenList tokens, Expression value, LiteralExpression type);
    public TypeToken get_Type();
    public Expression get_Value();
}
public interface StyleCop.CSharp.ITokenContainer {
    public ICollection`1<CsToken> Tokens { get; }
    public abstract virtual ICollection`1<CsToken> get_Tokens();
}
public interface StyleCop.CSharp.ITypeConstraintContainer {
    public ICollection`1<TypeParameterConstraintClause> TypeConstraints { get; }
    public abstract virtual ICollection`1<TypeParameterConstraintClause> get_TypeConstraints();
}
internal interface StyleCop.CSharp.IWriteableCodeUnit {
    public abstract virtual void AddExpression(Expression expression);
    public abstract virtual void AddExpressions(IEnumerable`1<Expression> expressions);
    public abstract virtual void AddStatement(Statement statement);
    public abstract virtual void AddStatements(IEnumerable`1<Statement> statements);
    public abstract virtual void SetParent(ICodePart parent);
}
public class StyleCop.CSharp.LabelStatement : Statement {
    private LiteralExpression identifier;
    public LiteralExpression Identifier { get; }
    internal LabelStatement(CsTokenList tokens, LiteralExpression identifier);
    public LiteralExpression get_Identifier();
}
public class StyleCop.CSharp.LambdaExpression : ExpressionWithParameters {
    private CodeUnit anonymousFunctionBody;
    private bool asyncExpression;
    public CodeUnit AnonymousFunctionBody { get; internal set; }
    public bool Async { get; internal set; }
    public CodeUnit get_AnonymousFunctionBody();
    internal void set_AnonymousFunctionBody(CodeUnit value);
    public bool get_Async();
    internal void set_Async(bool value);
}
public class StyleCop.CSharp.LiteralExpression : Expression {
    private Node`1<CsToken> tokenNode;
    public CsToken Token { get; }
    public Node`1<CsToken> TokenNode { get; }
    internal LiteralExpression(CsTokenList tokens, Node`1<CsToken> tokenNode);
    internal LiteralExpression(MasterList`1<CsToken> masterList, Node`1<CsToken> tokenNode);
    public CsToken get_Token();
    public Node`1<CsToken> get_TokenNode();
    public virtual string ToString();
}
public class StyleCop.CSharp.LockStatement : Statement {
    private Expression lockedExpression;
    private Statement embeddedStatement;
    public Statement EmbeddedStatement { get; internal set; }
    public Expression LockedExpression { get; }
    internal LockStatement(CsTokenList tokens, Expression lockedExpression);
    public Statement get_EmbeddedStatement();
    internal void set_EmbeddedStatement(Statement value);
    public Expression get_LockedExpression();
}
public class StyleCop.CSharp.LogicalExpression : Expression {
    private Expression leftHandSide;
    private Operator operatorType;
    private Expression rightHandSide;
    public Expression LeftHandSide { get; }
    public Operator OperatorType { get; }
    public Expression RightHandSide { get; }
    internal LogicalExpression(CsTokenList tokens, Operator operatorType, Expression leftHandSide, Expression rightHandSide);
    public Expression get_LeftHandSide();
    public Operator get_OperatorType();
    public Expression get_RightHandSide();
}
public class StyleCop.CSharp.MemberAccessExpression : Expression {
    private Expression leftHandSide;
    private Operator operatorType;
    private LiteralExpression rightHandSide;
    public Expression LeftHandSide { get; }
    public Operator OperatorType { get; }
    public LiteralExpression RightHandSide { get; }
    internal MemberAccessExpression(CsTokenList tokens, Operator operatorType, Expression leftHandSide, LiteralExpression rightHandSide);
    public Expression get_LeftHandSide();
    public Operator get_OperatorType();
    public LiteralExpression get_RightHandSide();
}
public class StyleCop.CSharp.Method : CsElement {
    private bool extensionMethod;
    private IList`1<Parameter> parameters;
    private TypeToken returnType;
    private ICollection`1<TypeParameterConstraintClause> typeConstraints;
    public bool IsExtensionMethod { get; }
    public IList`1<Parameter> Parameters { get; }
    public TypeToken ReturnType { get; }
    public ICollection`1<TypeParameterConstraintClause> TypeConstraints { get; }
    internal Method(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, TypeToken returnType, IList`1<Parameter> parameters, ICollection`1<TypeParameterConstraintClause> typeConstraints, bool unsafeCode, bool generated);
    public bool get_IsExtensionMethod();
    public sealed virtual IList`1<Parameter> get_Parameters();
    public TypeToken get_ReturnType();
    public sealed virtual ICollection`1<TypeParameterConstraintClause> get_TypeConstraints();
    internal virtual void Initialize();
}
public class StyleCop.CSharp.MethodInvocationExpression : Expression {
    private IList`1<Argument> arguments;
    private Expression name;
    public IList`1<Argument> Arguments { get; }
    public Expression Name { get; }
    internal MethodInvocationExpression(CsTokenList tokens, Expression name, IList`1<Argument> arguments);
    public IList`1<Argument> get_Arguments();
    public Expression get_Name();
}
public class StyleCop.CSharp.NameofExpression : Expression {
    internal NameofExpression(CsTokenList tokens, Expression name);
}
public class StyleCop.CSharp.Namespace : CsElement {
    internal Namespace(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, bool unsafeCode, bool generated);
    internal Namespace(CsDocument document, CsElement parent, ElementType type, string name, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, bool unsafeCode, bool generated);
}
public class StyleCop.CSharp.NewArrayExpression : Expression {
    private ArrayInitializerExpression initializer;
    private ArrayAccessExpression type;
    public ArrayInitializerExpression Initializer { get; }
    public ArrayAccessExpression Type { get; }
    internal NewArrayExpression(CsTokenList tokens, ArrayAccessExpression type, ArrayInitializerExpression initializer);
    public ArrayInitializerExpression get_Initializer();
    public ArrayAccessExpression get_Type();
}
public class StyleCop.CSharp.NewExpression : Expression {
    private Expression initializerExpression;
    private Expression typeCreationExpression;
    public Expression InitializerExpression { get; }
    public Expression TypeCreationExpression { get; }
    internal NewExpression(CsTokenList tokens, Expression typeCreationExpression, Expression initializerExpression);
    public Expression get_InitializerExpression();
    public Expression get_TypeCreationExpression();
}
public class StyleCop.CSharp.NullCoalescingExpression : Expression {
    private Expression leftHandSide;
    private Expression rightHandSide;
    public Expression LeftHandSide { get; }
    public Expression RightHandSide { get; }
    internal NullCoalescingExpression(CsTokenList tokens, Expression leftHandSide, Expression rightHandSide);
    public Expression get_LeftHandSide();
    public Expression get_RightHandSide();
}
public class StyleCop.CSharp.NullConditionExpression : Expression {
    private Expression leftHandSide;
    private Expression rightHandSide;
    public Expression LeftHandSide { get; }
    public Expression RightHandSide { get; }
    internal NullConditionExpression(CsTokenList tokens, Expression leftHandSide, Expression rightHandSide);
    public Expression get_LeftHandSide();
    public Expression get_RightHandSide();
}
public class StyleCop.CSharp.Number : CsToken {
    internal Number(string token, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
}
public class StyleCop.CSharp.ObjectInitializerExpression : Expression {
    private ICollection`1<AssignmentExpression> initializers;
    public ICollection`1<AssignmentExpression> Initializers { get; }
    internal ObjectInitializerExpression(CsTokenList tokens, ICollection`1<AssignmentExpression> initializers);
    public ICollection`1<AssignmentExpression> get_Initializers();
}
public enum StyleCop.CSharp.OperatorCategory : Enum {
    public int value__;
    public static OperatorCategory Relational;
    public static OperatorCategory Logical;
    public static OperatorCategory Assignment;
    public static OperatorCategory Arithmetic;
    public static OperatorCategory Shift;
    public static OperatorCategory Conditional;
    public static OperatorCategory IncrementDecrement;
    public static OperatorCategory Unary;
    public static OperatorCategory Reference;
    public static OperatorCategory Lambda;
}
public class StyleCop.CSharp.OperatorSymbol : CsToken {
    private OperatorCategory category;
    private OperatorType symbolType;
    public OperatorCategory Category { get; }
    public OperatorType SymbolType { get; }
    internal OperatorSymbol(string text, OperatorCategory category, OperatorType symbolType, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public OperatorCategory get_Category();
    public OperatorType get_SymbolType();
}
public enum StyleCop.CSharp.OperatorType : Enum {
    public int value__;
    public static OperatorType ConditionalEquals;
    public static OperatorType NotEquals;
    public static OperatorType LessThan;
    public static OperatorType GreaterThan;
    public static OperatorType LessThanOrEquals;
    public static OperatorType GreaterThanOrEquals;
    public static OperatorType LogicalAnd;
    public static OperatorType LogicalOr;
    public static OperatorType LogicalXor;
    public static OperatorType ConditionalAnd;
    public static OperatorType ConditionalOr;
    public static OperatorType NullCoalescingSymbol;
    public static OperatorType Equals;
    public static OperatorType PlusEquals;
    public static OperatorType MinusEquals;
    public static OperatorType MultiplicationEquals;
    public static OperatorType DivisionEquals;
    public static OperatorType LeftShiftEquals;
    public static OperatorType RightShiftEquals;
    public static OperatorType AndEquals;
    public static OperatorType OrEquals;
    public static OperatorType XorEquals;
    public static OperatorType Plus;
    public static OperatorType Minus;
    public static OperatorType Multiplication;
    public static OperatorType Division;
    public static OperatorType Mod;
    public static OperatorType ModEquals;
    public static OperatorType LeftShift;
    public static OperatorType RightShift;
    public static OperatorType ConditionalColon;
    public static OperatorType ConditionalQuestionMark;
    public static OperatorType NullConditional;
    public static OperatorType Increment;
    public static OperatorType Decrement;
    public static OperatorType Not;
    public static OperatorType BitwiseCompliment;
    public static OperatorType Positive;
    public static OperatorType Negative;
    public static OperatorType Dereference;
    public static OperatorType AddressOf;
    public static OperatorType Pointer;
    public static OperatorType MemberAccess;
    public static OperatorType QualifiedAlias;
    public static OperatorType Lambda;
}
public class StyleCop.CSharp.Parameter : object {
    internal static Parameter[] EmptyParameterArray;
    private Expression defaultArgument;
    private bool generated;
    private CodeLocation location;
    private ParameterModifiers modifiers;
    private string name;
    private Reference`1<ICodePart> parent;
    private CsTokenList tokens;
    private TypeToken type;
    public CodePartType CodePartType { get; }
    public Expression DefaultArgument { get; }
    public bool Generated { get; }
    public int LineNumber { get; }
    public CodeLocation Location { get; }
    public ParameterModifiers Modifiers { get; }
    public string Name { get; }
    public ICodePart Parent { get; }
    public CsTokenList Tokens { get; }
    public TypeToken Type { get; }
    internal Parameter(TypeToken type, string name, Reference`1<ICodePart> parent, ParameterModifiers modifiers, Expression defaultArgument, CodeLocation location, CsTokenList tokens, bool generated);
    private static Parameter();
    public sealed virtual CodePartType get_CodePartType();
    public Expression get_DefaultArgument();
    public bool get_Generated();
    public sealed virtual int get_LineNumber();
    public sealed virtual CodeLocation get_Location();
    public ParameterModifiers get_Modifiers();
    public string get_Name();
    public sealed virtual ICodePart get_Parent();
    public CsTokenList get_Tokens();
    public TypeToken get_Type();
}
[FlagsAttribute]
public enum StyleCop.CSharp.ParameterModifiers : Enum {
    public int value__;
    public static ParameterModifiers None;
    public static ParameterModifiers Out;
    public static ParameterModifiers Ref;
    public static ParameterModifiers Params;
    public static ParameterModifiers This;
    public static ParameterModifiers In;
}
public class StyleCop.CSharp.ParenthesizedExpression : Expression {
    private Expression innerExpression;
    public Expression InnerExpression { get; }
    internal ParenthesizedExpression(CsTokenList tokens, Expression innerExpression);
    public Expression get_InnerExpression();
}
public class StyleCop.CSharp.Preprocessor : CsToken {
    private string preprocessorType;
    public string PreprocessorType { get; }
    internal Preprocessor(string text, CsTokenClass tokenClass, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    internal Preprocessor(string text, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public string get_PreprocessorType();
}
public class StyleCop.CSharp.Property : CsElement {
    private TypeToken returnType;
    private Accessor get;
    private Accessor set;
    private VariableDeclarationStatement declaration;
    public Accessor GetAccessor { get; }
    public TypeToken ReturnType { get; }
    public Accessor SetAccessor { get; }
    public VariableDeclarationStatement VariableDeclarationStatement { get; internal set; }
    internal Property(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, TypeToken returnType, bool unsafeCode, bool generated);
    public Accessor get_GetAccessor();
    public TypeToken get_ReturnType();
    public Accessor get_SetAccessor();
    public VariableDeclarationStatement get_VariableDeclarationStatement();
    internal void set_VariableDeclarationStatement(VariableDeclarationStatement value);
    internal virtual void Initialize();
}
public abstract class StyleCop.CSharp.QueryClause : CodeUnit {
    private QueryClauseType type;
    public QueryClause ParentQueryClause { get; }
    public QueryClauseType QueryClauseType { get; }
    internal QueryClause(QueryClauseType type, CsTokenList tokens);
    public QueryClause get_ParentQueryClause();
    public QueryClauseType get_QueryClauseType();
    public void WalkQueryClause(CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public void WalkQueryClause(CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, T context);
    public void WalkQueryClause(CodeWalkerStatementVisitor`1<T> statementCallback, T context);
    public void WalkQueryClause(CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback, CodeWalkerQueryClauseVisitor`1<object> queryClauseCallback);
    public void WalkQueryClause(CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback);
    public void WalkQueryClause(CodeWalkerStatementVisitor`1<object> statementCallback);
}
public enum StyleCop.CSharp.QueryClauseType : Enum {
    public int value__;
    public static QueryClauseType Continuation;
    public static QueryClauseType From;
    public static QueryClauseType Group;
    public static QueryClauseType Join;
    public static QueryClauseType Let;
    public static QueryClauseType OrderBy;
    public static QueryClauseType Select;
    public static QueryClauseType Where;
}
public abstract class StyleCop.CSharp.QueryClauseWithExpression : QueryClause {
    private Expression expression;
    public Expression Expression { get; }
    internal QueryClauseWithExpression(QueryClauseType type, CsTokenList tokens, Expression expression);
    public Expression get_Expression();
}
public class StyleCop.CSharp.QueryContinuationClause : QueryClause {
    private CodeUnitCollection`1<QueryClause> clauses;
    private Variable variable;
    public ICollection`1<QueryClause> ChildClauses { get; }
    public Variable Variable { get; }
    internal QueryContinuationClause(CsTokenList tokens, Variable variable, ICollection`1<QueryClause> clauses);
    public ICollection`1<QueryClause> get_ChildClauses();
    public Variable get_Variable();
}
public class StyleCop.CSharp.QueryExpression : Expression {
    private CodeUnitCollection`1<QueryClause> clauses;
    public ICollection`1<QueryClause> ChildClauses { get; }
    internal QueryExpression(CsTokenList tokens, ICollection`1<QueryClause> clauses);
    public ICollection`1<QueryClause> get_ChildClauses();
    private void InitializeFromClauses(IEnumerable`1<QueryClause> items);
}
public class StyleCop.CSharp.QueryFromClause : QueryClauseWithExpression {
    private Variable rangeVariable;
    public Variable RangeVariable { get; }
    internal QueryFromClause(CsTokenList tokens, Variable rangeVariable, Expression expression);
    public Variable get_RangeVariable();
}
public class StyleCop.CSharp.QueryGroupClause : QueryClauseWithExpression {
    private Expression groupByExpression;
    public Expression GroupByExpression { get; }
    internal QueryGroupClause(CsTokenList tokens, Expression expression, Expression groupByExpression);
    public Expression get_GroupByExpression();
}
public class StyleCop.CSharp.QueryJoinClause : QueryClause {
    private Expression equalsKeyExpression;
    private Expression inExpression;
    private Variable intoVariable;
    private Expression onKeyExpression;
    private Variable rangeVariable;
    public Expression EqualsKeyExpression { get; }
    public Expression InExpression { get; }
    public Variable IntoVariable { get; }
    public Expression OnKeyExpression { get; }
    public Variable RangeVariable { get; }
    internal QueryJoinClause(CsTokenList tokens, Variable rangeVariable, Expression inExpression, Expression onKeyExpression, Expression equalsKeyExpression, Variable intoVariable);
    public Expression get_EqualsKeyExpression();
    public Expression get_InExpression();
    public Variable get_IntoVariable();
    public Expression get_OnKeyExpression();
    public Variable get_RangeVariable();
}
public class StyleCop.CSharp.QueryLetClause : QueryClauseWithExpression {
    private Variable rangeVariable;
    public Variable RangeVariable { get; }
    internal QueryLetClause(CsTokenList tokens, Variable rangeVariable, Expression expression);
    public Variable get_RangeVariable();
}
public class StyleCop.CSharp.QueryOrderByClause : QueryClause {
    private QueryOrderByOrdering[] orderings;
    public ICollection`1<QueryOrderByOrdering> Orderings { get; }
    internal QueryOrderByClause(CsTokenList tokens, ICollection`1<QueryOrderByOrdering> orderings);
    public ICollection`1<QueryOrderByOrdering> get_Orderings();
}
public enum StyleCop.CSharp.QueryOrderByDirection : Enum {
    public int value__;
    public static QueryOrderByDirection Undefined;
    public static QueryOrderByDirection Ascending;
    public static QueryOrderByDirection Descending;
}
public class StyleCop.CSharp.QueryOrderByOrdering : ValueType {
    private QueryOrderByDirection direction;
    private Expression expression;
    public QueryOrderByDirection Direction { get; public set; }
    public Expression Expression { get; public set; }
    public QueryOrderByDirection get_Direction();
    public void set_Direction(QueryOrderByDirection value);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public static bool op_Equality(QueryOrderByOrdering item1, QueryOrderByOrdering item2);
    public static bool op_Inequality(QueryOrderByOrdering item1, QueryOrderByOrdering item2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class StyleCop.CSharp.QuerySelectClause : QueryClauseWithExpression {
    internal QuerySelectClause(CsTokenList tokens, Expression expression);
}
public class StyleCop.CSharp.QueryWhereClause : QueryClauseWithExpression {
    internal QueryWhereClause(CsTokenList tokens, Expression expression);
}
internal class StyleCop.CSharp.Reference`1 : object {
    [CompilerGeneratedAttribute]
private T <Target>k__BackingField;
    public T Target { get; public set; }
    public Reference`1(T target);
    [CompilerGeneratedAttribute]
public T get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(T value);
}
public class StyleCop.CSharp.Region : Preprocessor {
    private bool beginning;
    [CompilerGeneratedAttribute]
private Region <Partner>k__BackingField;
    public bool Beginning { get; }
    public bool IsGeneratedCodeRegion { get; }
    public Region Partner { get; internal set; }
    internal Region(string text, CodeLocation location, Reference`1<ICodePart> parent, bool beginning, bool generated);
    public bool get_Beginning();
    public bool get_IsGeneratedCodeRegion();
    [CompilerGeneratedAttribute]
public Region get_Partner();
    [CompilerGeneratedAttribute]
internal void set_Partner(Region value);
}
public class StyleCop.CSharp.RelationalExpression : Expression {
    private Expression leftHandSide;
    private Operator operatorType;
    private Expression rightHandSide;
    public Expression LeftHandSide { get; }
    public Operator OperatorType { get; }
    public Expression RightHandSide { get; }
    internal RelationalExpression(CsTokenList tokens, Operator operatorType, Expression leftHandSide, Expression rightHandSide);
    public Expression get_LeftHandSide();
    public Operator get_OperatorType();
    public Expression get_RightHandSide();
}
public class StyleCop.CSharp.ReturnStatement : Statement {
    private Expression returnValue;
    public Expression ReturnValue { get; }
    internal ReturnStatement(CsTokenList tokens, Expression returnValue);
    public Expression get_ReturnValue();
}
internal enum StyleCop.CSharp.Rules : Enum {
    public int value__;
    public static Rules FileMustBeReadable;
    public static Rules ExceptionOccurred;
    public static Rules SyntaxException;
}
public class StyleCop.CSharp.SizeofExpression : Expression {
    private Expression type;
    public Expression Type { get; }
    internal SizeofExpression(CsTokenList tokens, Expression type);
    public Expression get_Type();
}
public class StyleCop.CSharp.StackallocExpression : Expression {
    private ArrayAccessExpression type;
    public ArrayAccessExpression Type { get; }
    internal StackallocExpression(CsTokenList tokens, ArrayAccessExpression type);
    public ArrayAccessExpression get_Type();
}
public abstract class StyleCop.CSharp.Statement : CodeUnit {
    private static Statement[] EmptyStatementArray;
    private StatementType type;
    public IEnumerable`1<Statement> AttachedStatements { get; }
    public StatementType StatementType { get; }
    internal Statement(StatementType type);
    internal Statement(StatementType type, CsTokenList tokens);
    private static Statement();
    public virtual IEnumerable`1<Statement> get_AttachedStatements();
    public StatementType get_StatementType();
    public void WalkStatement(CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, CodeWalkerQueryClauseVisitor`1<T> queryClauseCallback, T context);
    public void WalkStatement(CodeWalkerStatementVisitor`1<T> statementCallback, CodeWalkerExpressionVisitor`1<T> expressionCallback, T context);
    public void WalkStatement(CodeWalkerStatementVisitor`1<T> statementCallback, T context);
    public void WalkStatement(CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback, CodeWalkerQueryClauseVisitor`1<object> queryClauseCallback);
    public void WalkStatement(CodeWalkerStatementVisitor`1<object> statementCallback, CodeWalkerExpressionVisitor`1<object> expressionCallback);
    public void WalkStatement(CodeWalkerStatementVisitor`1<object> statementCallback);
}
public enum StyleCop.CSharp.StatementType : Enum {
    public int value__;
    public static StatementType Await;
    public static StatementType Block;
    public static StatementType Break;
    public static StatementType Catch;
    public static StatementType Checked;
    public static StatementType ConstructorInitializer;
    public static StatementType Continue;
    public static StatementType DoWhile;
    public static StatementType Else;
    public static StatementType Empty;
    public static StatementType Expression;
    public static StatementType Finally;
    public static StatementType Fixed;
    public static StatementType Foreach;
    public static StatementType For;
    public static StatementType Goto;
    public static StatementType If;
    public static StatementType Label;
    public static StatementType Lock;
    public static StatementType Return;
    public static StatementType SwitchCase;
    public static StatementType SwitchDefault;
    public static StatementType Switch;
    public static StatementType Throw;
    public static StatementType Try;
    public static StatementType Unchecked;
    public static StatementType Unsafe;
    public static StatementType Using;
    public static StatementType VariableDeclaration;
    public static StatementType While;
    public static StatementType Yield;
    public static StatementType Bodied;
    public static StatementType NameOf;
    public static StatementType When;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.CSharp.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DocumentMustBeCsDocument { get; }
    internal static string DocumentRoot { get; }
    internal static string ElementMustBeInParentsDocument { get; }
    internal static string EmptyElement { get; }
    internal static string InvalidNumberOfPasses { get; }
    internal static string Root { get; }
    internal static string UnexpectedEndOfFile { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DocumentMustBeCsDocument();
    internal static string get_DocumentRoot();
    internal static string get_ElementMustBeInParentsDocument();
    internal static string get_EmptyElement();
    internal static string get_InvalidNumberOfPasses();
    internal static string get_Root();
    internal static string get_UnexpectedEndOfFile();
}
public class StyleCop.CSharp.Struct : ClassBase {
    internal Struct(CsDocument document, CsElement parent, XmlHeader header, ICollection`1<Attribute> attributes, Declaration declaration, ICollection`1<TypeParameterConstraintClause> typeConstraints, bool unsafeCode, bool generated);
    internal virtual void Initialize();
}
public class StyleCop.CSharp.SwitchCaseStatement : Statement {
    private Expression identifier;
    public Expression Identifier { get; }
    internal SwitchCaseStatement(Expression identifier);
    public Expression get_Identifier();
}
public class StyleCop.CSharp.SwitchDefaultStatement : Statement {
}
public class StyleCop.CSharp.SwitchStatement : Statement {
    private ICollection`1<SwitchCaseStatement> caseStatements;
    private SwitchDefaultStatement defaultStatement;
    private Expression switchItem;
    public ICollection`1<SwitchCaseStatement> CaseStatements { get; }
    public SwitchDefaultStatement DefaultStatement { get; }
    public Expression SwitchItem { get; }
    internal SwitchStatement(CsTokenList tokens, Expression switchItem, ICollection`1<SwitchCaseStatement> caseStatements, SwitchDefaultStatement defaultStatement);
    public ICollection`1<SwitchCaseStatement> get_CaseStatements();
    public SwitchDefaultStatement get_DefaultStatement();
    public Expression get_SwitchItem();
}
internal class StyleCop.CSharp.Symbol : object {
    private CodeLocation location;
    private string text;
    private SymbolType symbolType;
    public int LineNumber { get; }
    public CodeLocation Location { get; }
    public SymbolType SymbolType { get; public set; }
    public string Text { get; }
    internal Symbol(string text, SymbolType symbolType, CodeLocation location);
    public int get_LineNumber();
    public CodeLocation get_Location();
    public SymbolType get_SymbolType();
    public void set_SymbolType(SymbolType value);
    public string get_Text();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal class StyleCop.CSharp.SymbolManager : object {
    private Stack`1<Region> regions;
    private List`1<Symbol> symbols;
    private int generatedCodeCount;
    private int index;
    public Symbol Current { get; }
    public int CurrentIndex { get; public set; }
    public bool Generated { get; }
    public Symbol Item { get; }
    public SymbolManager(List`1<Symbol> symbols);
    public Symbol get_Current();
    public int get_CurrentIndex();
    public void set_CurrentIndex(int value);
    public bool get_Generated();
    public Symbol get_Item(int symbolIndex);
    public void Advance();
    public void Combine(int startIndex, int endIndex, string text, SymbolType type);
    public void DecrementGeneratedCodeBlocks();
    public void IncrementGeneratedCodeBlocks();
    public Symbol Peek(int count);
    public Region PopRegion();
    public void PushRegion(Region region);
}
internal enum StyleCop.CSharp.SymbolType : Enum {
    public int value__;
    public static SymbolType OpenParenthesis;
    public static SymbolType CloseParenthesis;
    public static SymbolType OpenCurlyBracket;
    public static SymbolType CloseCurlyBracket;
    public static SymbolType OpenSquareBracket;
    public static SymbolType CloseSquareBracket;
    public static SymbolType Equals;
    public static SymbolType ConditionalEquals;
    public static SymbolType Plus;
    public static SymbolType PlusEquals;
    public static SymbolType Minus;
    public static SymbolType MinusEquals;
    public static SymbolType Multiplication;
    public static SymbolType MultiplicationEquals;
    public static SymbolType Division;
    public static SymbolType DivisionEquals;
    public static SymbolType LessThan;
    public static SymbolType LessThanOrEquals;
    public static SymbolType LeftShift;
    public static SymbolType LeftShiftEquals;
    public static SymbolType GreaterThan;
    public static SymbolType GreaterThanOrEquals;
    public static SymbolType RightShift;
    public static SymbolType RightShiftEquals;
    public static SymbolType Increment;
    public static SymbolType Decrement;
    public static SymbolType LogicalAnd;
    public static SymbolType AndEquals;
    public static SymbolType ConditionalAnd;
    public static SymbolType LogicalOr;
    public static SymbolType OrEquals;
    public static SymbolType ConditionalOr;
    public static SymbolType LogicalXor;
    public static SymbolType XorEquals;
    public static SymbolType Not;
    public static SymbolType NotEquals;
    public static SymbolType Mod;
    public static SymbolType ModEquals;
    public static SymbolType Dot;
    public static SymbolType Pointer;
    public static SymbolType Colon;
    public static SymbolType QualifiedAlias;
    public static SymbolType QuestionMark;
    public static SymbolType NullCoalescingSymbol;
    public static SymbolType Comma;
    public static SymbolType Semicolon;
    public static SymbolType Tilde;
    public static SymbolType Lambda;
    public static SymbolType Abstract;
    public static SymbolType As;
    public static SymbolType Base;
    public static SymbolType Break;
    public static SymbolType Case;
    public static SymbolType Catch;
    public static SymbolType Checked;
    public static SymbolType Class;
    public static SymbolType Const;
    public static SymbolType Continue;
    public static SymbolType Default;
    public static SymbolType Delegate;
    public static SymbolType Do;
    public static SymbolType Else;
    public static SymbolType Enum;
    public static SymbolType Event;
    public static SymbolType Explicit;
    public static SymbolType Extern;
    public static SymbolType False;
    public static SymbolType Finally;
    public static SymbolType Fixed;
    public static SymbolType For;
    public static SymbolType Foreach;
    public static SymbolType Goto;
    public static SymbolType If;
    public static SymbolType Implicit;
    public static SymbolType In;
    public static SymbolType Interface;
    public static SymbolType Internal;
    public static SymbolType Is;
    public static SymbolType Lock;
    public static SymbolType Namespace;
    public static SymbolType New;
    public static SymbolType Null;
    public static SymbolType Operator;
    public static SymbolType Out;
    public static SymbolType Override;
    public static SymbolType Params;
    public static SymbolType Private;
    public static SymbolType Protected;
    public static SymbolType Public;
    public static SymbolType Readonly;
    public static SymbolType Ref;
    public static SymbolType Return;
    public static SymbolType Sealed;
    public static SymbolType Sizeof;
    public static SymbolType Stackalloc;
    public static SymbolType Static;
    public static SymbolType Struct;
    public static SymbolType Switch;
    public static SymbolType This;
    public static SymbolType Throw;
    public static SymbolType True;
    public static SymbolType Try;
    public static SymbolType Typeof;
    public static SymbolType Unchecked;
    public static SymbolType Unsafe;
    public static SymbolType Using;
    public static SymbolType Virtual;
    public static SymbolType Volatile;
    public static SymbolType While;
    public static SymbolType Other;
    public static SymbolType WhiteSpace;
    public static SymbolType EndOfLine;
    public static SymbolType String;
    public static SymbolType Number;
    public static SymbolType SingleLineComment;
    public static SymbolType MultiLineComment;
    public static SymbolType PreprocessorDirective;
    public static SymbolType Attribute;
    public static SymbolType XmlHeaderLine;
    public static SymbolType NameOf;
    public static SymbolType NullConditional;
}
public class StyleCop.CSharp.ThrowStatement : Statement {
    private Expression thrownExpression;
    public Expression ThrownExpression { get; }
    internal ThrowStatement(CsTokenList tokens, Expression thrownExpression);
    public Expression get_ThrownExpression();
}
public class StyleCop.CSharp.TryStatement : Statement {
    private BlockStatement embeddedStatement;
    private ICollection`1<CatchStatement> catchStatements;
    private FinallyStatement finallyStatement;
    public IEnumerable`1<Statement> AttachedStatements { get; }
    public ICollection`1<CatchStatement> CatchStatements { get; internal set; }
    public BlockStatement EmbeddedStatement { get; }
    public FinallyStatement FinallyStatement { get; internal set; }
    internal TryStatement(BlockStatement embeddedStatement);
    public virtual IEnumerable`1<Statement> get_AttachedStatements();
    public ICollection`1<CatchStatement> get_CatchStatements();
    internal void set_CatchStatements(ICollection`1<CatchStatement> value);
    public BlockStatement get_EmbeddedStatement();
    public FinallyStatement get_FinallyStatement();
    internal void set_FinallyStatement(FinallyStatement value);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.CSharp.TypeNames : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Accessor { get; }
    internal static string AccessorPlural { get; }
    internal static string AnonymousMethodExpression { get; }
    internal static string AnonymousMethodExpressionPlural { get; }
    internal static string ArithmeticExpression { get; }
    internal static string ArithmeticExpressionPlural { get; }
    internal static string ArrayAccessExpression { get; }
    internal static string ArrayAccessExpressionPlural { get; }
    internal static string ArrayInitializerExpression { get; }
    internal static string ArrayInitializerExpressionPlural { get; }
    internal static string AsExpression { get; }
    internal static string AsExpressionPlural { get; }
    internal static string AssemblyOrModuleAttribute { get; }
    internal static string AssemblyOrModuleAttributePlural { get; }
    internal static string AssignmentExpression { get; }
    internal static string AssignmentExpressionPlural { get; }
    internal static string AttributeExpression { get; }
    internal static string AttributeExpressionPlural { get; }
    internal static string BlockStatement { get; }
    internal static string BlockStatementPlural { get; }
    internal static string BreakStatement { get; }
    internal static string BreakStatementPlural { get; }
    internal static string CastExpression { get; }
    internal static string CastExpressionPlural { get; }
    internal static string CatchStatement { get; }
    internal static string CatchStatementPlural { get; }
    internal static string CheckedExpression { get; }
    internal static string CheckedExpressionPlural { get; }
    internal static string CheckedStatement { get; }
    internal static string CheckedStatementPlural { get; }
    internal static string Class { get; }
    internal static string ClassPlural { get; }
    internal static string CollectionInitializerExpression { get; }
    internal static string CollectionInitializerExpressionPlural { get; }
    internal static string ConditionalExpression { get; }
    internal static string ConditionalExpressionPlural { get; }
    internal static string ConditionalLogicalExpression { get; }
    internal static string ConditionalLogicalExpressionPlural { get; }
    internal static string Constructor { get; }
    internal static string ConstructorInitializerStatement { get; }
    internal static string ConstructorInitializerStatementPlural { get; }
    internal static string ConstructorPlural { get; }
    internal static string ContinueStatement { get; }
    internal static string ContinueStatementPlural { get; }
    internal static string DecrementExpression { get; }
    internal static string DecrementExpressionPlural { get; }
    internal static string DefaultValueExpression { get; }
    internal static string DefaultValueExpressionPlural { get; }
    internal static string Delegate { get; }
    internal static string DelegatePlural { get; }
    internal static string Destructor { get; }
    internal static string DestructorPlural { get; }
    internal static string DocumentRoot { get; }
    internal static string DocumentRootPlural { get; }
    internal static string DoWhileStatement { get; }
    internal static string DoWhileStatementPlural { get; }
    internal static string ElseStatement { get; }
    internal static string ElseStatementPlural { get; }
    internal static string EmptyElement { get; }
    internal static string EmptyElementPlural { get; }
    internal static string EmptyStatement { get; }
    internal static string EmptyStatementPlural { get; }
    internal static string Enum { get; }
    internal static string EnumItem { get; }
    internal static string EnumItemPlural { get; }
    internal static string EnumPlural { get; }
    internal static string Event { get; }
    internal static string EventPlural { get; }
    internal static string ExpressionStatement { get; }
    internal static string ExpressionStatementPlural { get; }
    internal static string ExternAliasDirective { get; }
    internal static string ExternAliasDirectivePlural { get; }
    internal static string Field { get; }
    internal static string FieldPlural { get; }
    internal static string FinallyStatement { get; }
    internal static string FinallyStatementPlural { get; }
    internal static string FixedStatement { get; }
    internal static string FixedStatementPlural { get; }
    internal static string ForeachStatement { get; }
    internal static string ForeachStatementPlural { get; }
    internal static string ForStatement { get; }
    internal static string ForStatementPlural { get; }
    internal static string GotoStatement { get; }
    internal static string GotoStatementPlural { get; }
    internal static string IfStatement { get; }
    internal static string IfStatementPlural { get; }
    internal static string IncrementExpression { get; }
    internal static string IncrementExpressionPlural { get; }
    internal static string Indexer { get; }
    internal static string IndexerPlural { get; }
    internal static string Interface { get; }
    internal static string InterfacePlural { get; }
    internal static string IsExpression { get; }
    internal static string IsExpressionPlural { get; }
    internal static string LabelStatement { get; }
    internal static string LabelStatementPlural { get; }
    internal static string LambdaExpression { get; }
    internal static string LambdaExpressionPlural { get; }
    internal static string LiteralExpression { get; }
    internal static string LiteralExpressionPlural { get; }
    internal static string LockStatement { get; }
    internal static string LockStatementPlural { get; }
    internal static string LogicalExpression { get; }
    internal static string LogicalExpressionPlural { get; }
    internal static string MemberAccessExpression { get; }
    internal static string MemberAccessExpressionPlural { get; }
    internal static string Method { get; }
    internal static string MethodInvocationExpression { get; }
    internal static string MethodInvocationExpressionPlural { get; }
    internal static string MethodPlural { get; }
    internal static string Namespace { get; }
    internal static string NamespacePlural { get; }
    internal static string NewArrayExpression { get; }
    internal static string NewArrayExpressionPlural { get; }
    internal static string NewExpression { get; }
    internal static string NewExpressionPlural { get; }
    internal static string NullCoalescingExpression { get; }
    internal static string NullCoalescingExpressionPlural { get; }
    internal static string ObjectInitializerExpression { get; }
    internal static string ObjectInitializerExpressionPlural { get; }
    internal static string ParenthesizedExpression { get; }
    internal static string ParenthesizedExpressionPlural { get; }
    internal static string Property { get; }
    internal static string PropertyPlural { get; }
    internal static string QueryContinuationClause { get; }
    internal static string QueryContinuationClausePlural { get; }
    internal static string QueryExpression { get; }
    internal static string QueryExpressionPlural { get; }
    internal static string QueryFromClause { get; }
    internal static string QueryFromClausePlural { get; }
    internal static string QueryGroupClause { get; }
    internal static string QueryGroupClausePlural { get; }
    internal static string QueryJoinClause { get; }
    internal static string QueryJoinClausePlural { get; }
    internal static string QueryLetClause { get; }
    internal static string QueryLetClausePlural { get; }
    internal static string QueryOrderByClause { get; }
    internal static string QueryOrderByClausePlural { get; }
    internal static string QuerySelectClause { get; }
    internal static string QuerySelectClausePlural { get; }
    internal static string QueryWhereClause { get; }
    internal static string QueryWhereClausePlural { get; }
    internal static string RelationalExpression { get; }
    internal static string RelationalExpressionPlural { get; }
    internal static string ReturnStatement { get; }
    internal static string ReturnStatementPlural { get; }
    internal static string SizeofExpression { get; }
    internal static string SizeofExpressionPlural { get; }
    internal static string StackallocExpression { get; }
    internal static string StackallocExpressionPlural { get; }
    internal static string Struct { get; }
    internal static string StructPlural { get; }
    internal static string SwitchCaseStatement { get; }
    internal static string SwitchCaseStatementPlural { get; }
    internal static string SwitchDefaultStatement { get; }
    internal static string SwitchDefaultStatementPlural { get; }
    internal static string SwitchStatement { get; }
    internal static string SwitchStatementPlural { get; }
    internal static string ThrowStatement { get; }
    internal static string ThrowStatementPlural { get; }
    internal static string TryStatement { get; }
    internal static string TryStatementPlural { get; }
    internal static string TypeofExpression { get; }
    internal static string TypeofExpressionPlural { get; }
    internal static string UnaryExpression { get; }
    internal static string UnaryExpressionPlural { get; }
    internal static string UncheckedExpression { get; }
    internal static string UncheckedExpressionPlural { get; }
    internal static string UncheckedStatement { get; }
    internal static string UncheckedStatementPlural { get; }
    internal static string UnsafeAccessExpression { get; }
    internal static string UnsafeAccessExpressionPlural { get; }
    internal static string UnsafeStatement { get; }
    internal static string UnsafeStatementPlural { get; }
    internal static string UsingDirective { get; }
    internal static string UsingDirectivePlural { get; }
    internal static string UsingStatement { get; }
    internal static string UsingStatementPlural { get; }
    internal static string VariableDeclarationExpression { get; }
    internal static string VariableDeclarationExpressionPlural { get; }
    internal static string VariableDeclarationStatement { get; }
    internal static string VariableDeclarationStatementPlural { get; }
    internal static string VariableDeclaratorExpression { get; }
    internal static string VariableDeclaratorExpressionPlural { get; }
    internal static string WhileStatement { get; }
    internal static string WhileStatementPlural { get; }
    internal static string YieldStatement { get; }
    internal static string YieldStatementPlural { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Accessor();
    internal static string get_AccessorPlural();
    internal static string get_AnonymousMethodExpression();
    internal static string get_AnonymousMethodExpressionPlural();
    internal static string get_ArithmeticExpression();
    internal static string get_ArithmeticExpressionPlural();
    internal static string get_ArrayAccessExpression();
    internal static string get_ArrayAccessExpressionPlural();
    internal static string get_ArrayInitializerExpression();
    internal static string get_ArrayInitializerExpressionPlural();
    internal static string get_AsExpression();
    internal static string get_AsExpressionPlural();
    internal static string get_AssemblyOrModuleAttribute();
    internal static string get_AssemblyOrModuleAttributePlural();
    internal static string get_AssignmentExpression();
    internal static string get_AssignmentExpressionPlural();
    internal static string get_AttributeExpression();
    internal static string get_AttributeExpressionPlural();
    internal static string get_BlockStatement();
    internal static string get_BlockStatementPlural();
    internal static string get_BreakStatement();
    internal static string get_BreakStatementPlural();
    internal static string get_CastExpression();
    internal static string get_CastExpressionPlural();
    internal static string get_CatchStatement();
    internal static string get_CatchStatementPlural();
    internal static string get_CheckedExpression();
    internal static string get_CheckedExpressionPlural();
    internal static string get_CheckedStatement();
    internal static string get_CheckedStatementPlural();
    internal static string get_Class();
    internal static string get_ClassPlural();
    internal static string get_CollectionInitializerExpression();
    internal static string get_CollectionInitializerExpressionPlural();
    internal static string get_ConditionalExpression();
    internal static string get_ConditionalExpressionPlural();
    internal static string get_ConditionalLogicalExpression();
    internal static string get_ConditionalLogicalExpressionPlural();
    internal static string get_Constructor();
    internal static string get_ConstructorInitializerStatement();
    internal static string get_ConstructorInitializerStatementPlural();
    internal static string get_ConstructorPlural();
    internal static string get_ContinueStatement();
    internal static string get_ContinueStatementPlural();
    internal static string get_DecrementExpression();
    internal static string get_DecrementExpressionPlural();
    internal static string get_DefaultValueExpression();
    internal static string get_DefaultValueExpressionPlural();
    internal static string get_Delegate();
    internal static string get_DelegatePlural();
    internal static string get_Destructor();
    internal static string get_DestructorPlural();
    internal static string get_DocumentRoot();
    internal static string get_DocumentRootPlural();
    internal static string get_DoWhileStatement();
    internal static string get_DoWhileStatementPlural();
    internal static string get_ElseStatement();
    internal static string get_ElseStatementPlural();
    internal static string get_EmptyElement();
    internal static string get_EmptyElementPlural();
    internal static string get_EmptyStatement();
    internal static string get_EmptyStatementPlural();
    internal static string get_Enum();
    internal static string get_EnumItem();
    internal static string get_EnumItemPlural();
    internal static string get_EnumPlural();
    internal static string get_Event();
    internal static string get_EventPlural();
    internal static string get_ExpressionStatement();
    internal static string get_ExpressionStatementPlural();
    internal static string get_ExternAliasDirective();
    internal static string get_ExternAliasDirectivePlural();
    internal static string get_Field();
    internal static string get_FieldPlural();
    internal static string get_FinallyStatement();
    internal static string get_FinallyStatementPlural();
    internal static string get_FixedStatement();
    internal static string get_FixedStatementPlural();
    internal static string get_ForeachStatement();
    internal static string get_ForeachStatementPlural();
    internal static string get_ForStatement();
    internal static string get_ForStatementPlural();
    internal static string get_GotoStatement();
    internal static string get_GotoStatementPlural();
    internal static string get_IfStatement();
    internal static string get_IfStatementPlural();
    internal static string get_IncrementExpression();
    internal static string get_IncrementExpressionPlural();
    internal static string get_Indexer();
    internal static string get_IndexerPlural();
    internal static string get_Interface();
    internal static string get_InterfacePlural();
    internal static string get_IsExpression();
    internal static string get_IsExpressionPlural();
    internal static string get_LabelStatement();
    internal static string get_LabelStatementPlural();
    internal static string get_LambdaExpression();
    internal static string get_LambdaExpressionPlural();
    internal static string get_LiteralExpression();
    internal static string get_LiteralExpressionPlural();
    internal static string get_LockStatement();
    internal static string get_LockStatementPlural();
    internal static string get_LogicalExpression();
    internal static string get_LogicalExpressionPlural();
    internal static string get_MemberAccessExpression();
    internal static string get_MemberAccessExpressionPlural();
    internal static string get_Method();
    internal static string get_MethodInvocationExpression();
    internal static string get_MethodInvocationExpressionPlural();
    internal static string get_MethodPlural();
    internal static string get_Namespace();
    internal static string get_NamespacePlural();
    internal static string get_NewArrayExpression();
    internal static string get_NewArrayExpressionPlural();
    internal static string get_NewExpression();
    internal static string get_NewExpressionPlural();
    internal static string get_NullCoalescingExpression();
    internal static string get_NullCoalescingExpressionPlural();
    internal static string get_ObjectInitializerExpression();
    internal static string get_ObjectInitializerExpressionPlural();
    internal static string get_ParenthesizedExpression();
    internal static string get_ParenthesizedExpressionPlural();
    internal static string get_Property();
    internal static string get_PropertyPlural();
    internal static string get_QueryContinuationClause();
    internal static string get_QueryContinuationClausePlural();
    internal static string get_QueryExpression();
    internal static string get_QueryExpressionPlural();
    internal static string get_QueryFromClause();
    internal static string get_QueryFromClausePlural();
    internal static string get_QueryGroupClause();
    internal static string get_QueryGroupClausePlural();
    internal static string get_QueryJoinClause();
    internal static string get_QueryJoinClausePlural();
    internal static string get_QueryLetClause();
    internal static string get_QueryLetClausePlural();
    internal static string get_QueryOrderByClause();
    internal static string get_QueryOrderByClausePlural();
    internal static string get_QuerySelectClause();
    internal static string get_QuerySelectClausePlural();
    internal static string get_QueryWhereClause();
    internal static string get_QueryWhereClausePlural();
    internal static string get_RelationalExpression();
    internal static string get_RelationalExpressionPlural();
    internal static string get_ReturnStatement();
    internal static string get_ReturnStatementPlural();
    internal static string get_SizeofExpression();
    internal static string get_SizeofExpressionPlural();
    internal static string get_StackallocExpression();
    internal static string get_StackallocExpressionPlural();
    internal static string get_Struct();
    internal static string get_StructPlural();
    internal static string get_SwitchCaseStatement();
    internal static string get_SwitchCaseStatementPlural();
    internal static string get_SwitchDefaultStatement();
    internal static string get_SwitchDefaultStatementPlural();
    internal static string get_SwitchStatement();
    internal static string get_SwitchStatementPlural();
    internal static string get_ThrowStatement();
    internal static string get_ThrowStatementPlural();
    internal static string get_TryStatement();
    internal static string get_TryStatementPlural();
    internal static string get_TypeofExpression();
    internal static string get_TypeofExpressionPlural();
    internal static string get_UnaryExpression();
    internal static string get_UnaryExpressionPlural();
    internal static string get_UncheckedExpression();
    internal static string get_UncheckedExpressionPlural();
    internal static string get_UncheckedStatement();
    internal static string get_UncheckedStatementPlural();
    internal static string get_UnsafeAccessExpression();
    internal static string get_UnsafeAccessExpressionPlural();
    internal static string get_UnsafeStatement();
    internal static string get_UnsafeStatementPlural();
    internal static string get_UsingDirective();
    internal static string get_UsingDirectivePlural();
    internal static string get_UsingStatement();
    internal static string get_UsingStatementPlural();
    internal static string get_VariableDeclarationExpression();
    internal static string get_VariableDeclarationExpressionPlural();
    internal static string get_VariableDeclarationStatement();
    internal static string get_VariableDeclarationStatementPlural();
    internal static string get_VariableDeclaratorExpression();
    internal static string get_VariableDeclaratorExpressionPlural();
    internal static string get_WhileStatement();
    internal static string get_WhileStatementPlural();
    internal static string get_YieldStatement();
    internal static string get_YieldStatementPlural();
}
public class StyleCop.CSharp.TypeofExpression : Expression {
    private TypeToken type;
    public TypeToken Type { get; }
    internal TypeofExpression(CsTokenList tokens, LiteralExpression type);
    public TypeToken get_Type();
}
public class StyleCop.CSharp.TypeParameterConstraintClause : object {
    private ICollection`1<CsToken> constraints;
    private Reference`1<ICodePart> parent;
    private CsTokenList tokens;
    private CsToken type;
    [CompilerGeneratedAttribute]
private CsElement <ParentElement>k__BackingField;
    public CodePartType CodePartType { get; }
    public ICollection`1<CsToken> Constraints { get; }
    public int LineNumber { get; }
    public CodeLocation Location { get; }
    public ICodePart Parent { get; }
    public CsElement ParentElement { get; internal set; }
    public CsTokenList Tokens { get; }
    public CsToken Type { get; }
    internal TypeParameterConstraintClause(CsTokenList tokens, CsToken type, ICollection`1<CsToken> constraints, Reference`1<ICodePart> parent);
    public sealed virtual CodePartType get_CodePartType();
    public ICollection`1<CsToken> get_Constraints();
    public sealed virtual int get_LineNumber();
    public sealed virtual CodeLocation get_Location();
    public sealed virtual ICodePart get_Parent();
    [CompilerGeneratedAttribute]
public CsElement get_ParentElement();
    [CompilerGeneratedAttribute]
internal void set_ParentElement(CsElement value);
    public CsTokenList get_Tokens();
    public CsToken get_Type();
}
public class StyleCop.CSharp.TypeToken : CsToken {
    private MasterList`1<CsToken> childTokens;
    public MasterList`1<CsToken> ChildTokens { get; }
    private ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.Tokens { get; }
    internal TypeToken(MasterList`1<CsToken> childTokens, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    internal TypeToken(MasterList`1<CsToken> childTokens, CodeLocation location, Reference`1<ICodePart> parent, CsTokenClass tokenClass, bool generated);
    public MasterList`1<CsToken> get_ChildTokens();
    private sealed virtual override ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.get_Tokens();
    protected virtual void CreateTextString();
}
public class StyleCop.CSharp.UnaryExpression : Expression {
    private Operator operatorType;
    private Expression value;
    public Operator OperatorType { get; }
    public Expression Value { get; }
    internal UnaryExpression(CsTokenList tokens, Operator operatorType, Expression value);
    public Operator get_OperatorType();
    public Expression get_Value();
}
public class StyleCop.CSharp.UncheckedExpression : Expression {
    private Expression internalExpression;
    public Expression InternalExpression { get; }
    internal UncheckedExpression(CsTokenList tokens, Expression internalExpression);
    public Expression get_InternalExpression();
}
public class StyleCop.CSharp.UncheckedStatement : Statement {
    private BlockStatement embeddedStatement;
    public BlockStatement EmbeddedStatement { get; }
    internal UncheckedStatement(CsTokenList tokens, BlockStatement embeddedStatement);
    public BlockStatement get_EmbeddedStatement();
}
public class StyleCop.CSharp.UnsafeAccessExpression : Expression {
    private Operator operatorType;
    private Expression value;
    public Operator OperatorType { get; }
    public Expression Value { get; }
    internal UnsafeAccessExpression(CsTokenList tokens, Operator operatorType, Expression value);
    public Operator get_OperatorType();
    public Expression get_Value();
}
public class StyleCop.CSharp.UnsafeStatement : Statement {
    private BlockStatement embeddedStatement;
    public BlockStatement EmbeddedStatement { get; }
    internal UnsafeStatement(CsTokenList tokens, BlockStatement embeddedStatement);
    public BlockStatement get_EmbeddedStatement();
}
public class StyleCop.CSharp.UsingDirective : CsElement {
    private string alias;
    private string namespaceType;
    private bool isStatic;
    public string Alias { get; }
    public string NamespaceType { get; }
    public bool IsStatic { get; }
    internal UsingDirective(CsDocument document, CsElement parent, Declaration declaration, bool generated, bool isStatic, string namespace, string alias);
    public string get_Alias();
    public string get_NamespaceType();
    public bool get_IsStatic();
    internal virtual void Initialize();
}
public class StyleCop.CSharp.UsingStatement : Statement {
    private Expression resource;
    private Statement embeddedStatement;
    public Statement EmbeddedStatement { get; internal set; }
    public Expression Resource { get; }
    internal UsingStatement(CsTokenList tokens, Expression resource);
    public Statement get_EmbeddedStatement();
    internal void set_EmbeddedStatement(Statement value);
    public Expression get_Resource();
}
public class StyleCop.CSharp.Variable : object {
    private bool generated;
    private CodeLocation location;
    private VariableModifiers modifiers;
    private string name;
    private Reference`1<ICodePart> parent;
    private TypeToken type;
    public CodePartType CodePartType { get; }
    public bool Generated { get; }
    public int LineNumber { get; }
    public CodeLocation Location { get; }
    public VariableModifiers Modifiers { get; }
    public string Name { get; }
    public ICodePart Parent { get; }
    public TypeToken Type { get; }
    internal Variable(TypeToken type, string name, VariableModifiers modifiers, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public sealed virtual CodePartType get_CodePartType();
    public bool get_Generated();
    public sealed virtual int get_LineNumber();
    public sealed virtual CodeLocation get_Location();
    public VariableModifiers get_Modifiers();
    public string get_Name();
    public sealed virtual ICodePart get_Parent();
    public TypeToken get_Type();
}
[DefaultMemberAttribute("Item")]
public class StyleCop.CSharp.VariableCollection : object {
    private static Variable[] EmptyVariableArray;
    private static LegacyEnumeratorAdapter`1<Variable> emptyVariableArrayEnumerator;
    private Dictionary`2<string, Variable> variables;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Variable Item { get; }
    private static VariableCollection();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public Variable get_Item(string name);
    public bool Contains(string name);
    public sealed virtual void CopyTo(Variable[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<Variable> GetEnumerator();
    public Variable GetVariable(string name);
    private sealed virtual override void System.Collections.Generic.ICollection<StyleCop.CSharp.Variable>.Add(Variable variable);
    private sealed virtual override void System.Collections.Generic.ICollection<StyleCop.CSharp.Variable>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<StyleCop.CSharp.Variable>.Contains(Variable variable);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<StyleCop.CSharp.Variable>.Remove(Variable variable);
    internal void Add(Variable variable);
    internal void AddRange(IEnumerable`1<Variable> items);
}
public class StyleCop.CSharp.VariableDeclarationExpression : Expression {
    private ICollection`1<VariableDeclaratorExpression> declarators;
    private TypeToken type;
    public ICollection`1<VariableDeclaratorExpression> Declarators { get; }
    public TypeToken Type { get; }
    internal VariableDeclarationExpression(CsTokenList tokens, LiteralExpression type, ICollection`1<VariableDeclaratorExpression> declarators);
    public ICollection`1<VariableDeclaratorExpression> get_Declarators();
    public TypeToken get_Type();
}
public class StyleCop.CSharp.VariableDeclarationStatement : Statement {
    private bool constant;
    private VariableDeclarationExpression expression;
    public bool Constant { get; }
    public ICollection`1<VariableDeclaratorExpression> Declarators { get; }
    public VariableDeclarationExpression InnerExpression { get; }
    public TypeToken Type { get; }
    internal VariableDeclarationStatement(CsTokenList tokens, bool constant, VariableDeclarationExpression expression);
    public bool get_Constant();
    public ICollection`1<VariableDeclaratorExpression> get_Declarators();
    public VariableDeclarationExpression get_InnerExpression();
    public TypeToken get_Type();
}
public class StyleCop.CSharp.VariableDeclaratorExpression : Expression {
    private LiteralExpression identifier;
    private Expression initializer;
    [CompilerGeneratedAttribute]
private VariableDeclarationExpression <ParentVariable>k__BackingField;
    public LiteralExpression Identifier { get; }
    public Expression Initializer { get; }
    public VariableDeclarationExpression ParentVariable { get; internal set; }
    internal VariableDeclaratorExpression(CsTokenList tokens, LiteralExpression identifier, Expression initializer);
    public LiteralExpression get_Identifier();
    public Expression get_Initializer();
    [CompilerGeneratedAttribute]
public VariableDeclarationExpression get_ParentVariable();
    [CompilerGeneratedAttribute]
internal void set_ParentVariable(VariableDeclarationExpression value);
}
[FlagsAttribute]
public enum StyleCop.CSharp.VariableModifiers : Enum {
    public int value__;
    public static VariableModifiers None;
    public static VariableModifiers Const;
    public static VariableModifiers Readonly;
}
public class StyleCop.CSharp.WhenStatement : Statement {
    private Expression whenValue;
    public Expression WhenValue { get; }
    internal WhenStatement(CsTokenList tokens, Expression whenValue);
    public Expression get_WhenValue();
}
public class StyleCop.CSharp.WhileStatement : Statement {
    private Expression conditionExpression;
    private Statement embeddedStatement;
    public Expression ConditionExpression { get; }
    public Statement EmbeddedStatement { get; internal set; }
    internal WhileStatement(CsTokenList tokens, Expression conditionExpression);
    public Expression get_ConditionExpression();
    public Statement get_EmbeddedStatement();
    internal void set_EmbeddedStatement(Statement value);
}
public class StyleCop.CSharp.Whitespace : CsToken {
    private int spaceCount;
    private int tabCount;
    public int SpaceCount { get; }
    public int TabCount { get; }
    internal Whitespace(string text, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public int get_SpaceCount();
    public int get_TabCount();
    public virtual string ToString();
}
public class StyleCop.CSharp.XmlHeader : CsToken {
    private MasterList`1<CsToken> childTokens;
    private string rawText;
    [CompilerGeneratedAttribute]
private CsElement <Element>k__BackingField;
    public MasterList`1<CsToken> ChildTokens { get; }
    public CsElement Element { get; internal set; }
    public string RawText { get; }
    private ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.Tokens { get; }
    internal XmlHeader(MasterList`1<CsToken> childTokens, CodeLocation location, Reference`1<ICodePart> parent, bool generated);
    public MasterList`1<CsToken> get_ChildTokens();
    [CompilerGeneratedAttribute]
public CsElement get_Element();
    [CompilerGeneratedAttribute]
internal void set_Element(CsElement value);
    public string get_RawText();
    private sealed virtual override ICollection`1<CsToken> StyleCop.CSharp.ITokenContainer.get_Tokens();
    protected virtual void CreateTextString();
    private static string ExtractTextFromHeaderLine(string originalText);
    private void CreateRawTextString();
}
public class StyleCop.CSharp.YieldStatement : Statement {
    private Expression returnValue;
    private Type type;
    public Expression ReturnValue { get; }
    public Type YieldType { get; }
    internal YieldStatement(CsTokenList tokens, Type type, Expression returnValue);
    public Expression get_ReturnValue();
    public Type get_YieldType();
}
