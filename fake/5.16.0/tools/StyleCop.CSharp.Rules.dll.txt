public static class StyleCop.CSharp.CachedCodeStrings : object {
    private static string classText;
    private static CultureInfo culture;
    private static string exampleHeaderSummaryForDestructor;
    private static string exampleHeaderSummaryForInstanceConstructor;
    private static string exampleHeaderSummaryForPrivateInstanceConstructor;
    private static string exampleHeaderSummaryForStaticConstructor;
    private static string headerSummaryForBooleanGetAccessor;
    private static string headerSummaryForBooleanGetAndSetAccessor;
    private static string headerSummaryForBooleanSetAccessor;
    private static string headerSummaryForDestructor;
    private static string headerSummaryForGetAccessor;
    private static string headerSummaryForGetAndSetAccessor;
    private static string headerSummaryForInstanceConstructor;
    private static string headerSummaryForPrivateInstanceConstructor;
    private static string headerSummaryForSetAccessor;
    private static string headerSummaryForStaticConstructor;
    private static string parameterNotUsed;
    private static string structText;
    public static string ClassText { get; }
    public static CultureInfo Culture { get; public set; }
    public static string ExampleHeaderSummaryForDestructor { get; }
    public static string ExampleHeaderSummaryForInstanceConstructor { get; }
    public static string ExampleHeaderSummaryForPrivateInstanceConstructor { get; }
    public static string ExampleHeaderSummaryForStaticConstructor { get; }
    public static string HeaderSummaryForBooleanGetAccessor { get; }
    public static string HeaderSummaryForBooleanGetAndSetAccessor { get; }
    public static string HeaderSummaryForBooleanSetAccessor { get; }
    public static string HeaderSummaryForDestructor { get; }
    public static string HeaderSummaryForGetAccessor { get; }
    public static string HeaderSummaryForGetAndSetAccessor { get; }
    public static string HeaderSummaryForInstanceConstructor { get; }
    public static string HeaderSummaryForPrivateInstanceConstructor { get; }
    public static string HeaderSummaryForSetAccessor { get; }
    public static string HeaderSummaryForStaticConstructor { get; }
    public static string ParameterNotUsed { get; }
    public static string StructText { get; }
    public static string get_ClassText();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_ExampleHeaderSummaryForDestructor();
    public static string get_ExampleHeaderSummaryForInstanceConstructor();
    public static string get_ExampleHeaderSummaryForPrivateInstanceConstructor();
    public static string get_ExampleHeaderSummaryForStaticConstructor();
    public static string get_HeaderSummaryForBooleanGetAccessor();
    public static string get_HeaderSummaryForBooleanGetAndSetAccessor();
    public static string get_HeaderSummaryForBooleanSetAccessor();
    public static string get_HeaderSummaryForDestructor();
    public static string get_HeaderSummaryForGetAccessor();
    public static string get_HeaderSummaryForGetAndSetAccessor();
    public static string get_HeaderSummaryForInstanceConstructor();
    public static string get_HeaderSummaryForPrivateInstanceConstructor();
    public static string get_HeaderSummaryForSetAccessor();
    public static string get_HeaderSummaryForStaticConstructor();
    public static string get_ParameterNotUsed();
    public static string get_StructText();
    private static void ClearCachedStrings();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.CSharp.CodeStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Class { get; }
    internal static string ExampleHeaderSummaryForDestructor { get; }
    internal static string ExampleHeaderSummaryForInstanceConstructor { get; }
    internal static string ExampleHeaderSummaryForPrivateInstanceConstructor { get; }
    internal static string ExampleHeaderSummaryForStaticConstructor { get; }
    internal static string HeaderSummaryForBooleanGetAccessor { get; }
    internal static string HeaderSummaryForBooleanGetAndSetAccessor { get; }
    internal static string HeaderSummaryForBooleanSetAccessor { get; }
    internal static string HeaderSummaryForDestructor { get; }
    internal static string HeaderSummaryForGetAccessor { get; }
    internal static string HeaderSummaryForGetAndSetAccessor { get; }
    internal static string HeaderSummaryForInstanceConstructor { get; }
    internal static string HeaderSummaryForPrivateInstanceConstructor { get; }
    internal static string HeaderSummaryForSetAccessor { get; }
    internal static string HeaderSummaryForStaticConstructor { get; }
    internal static string ParameterNotUsed { get; }
    internal static string Struct { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Class();
    internal static string get_ExampleHeaderSummaryForDestructor();
    internal static string get_ExampleHeaderSummaryForInstanceConstructor();
    internal static string get_ExampleHeaderSummaryForPrivateInstanceConstructor();
    internal static string get_ExampleHeaderSummaryForStaticConstructor();
    internal static string get_HeaderSummaryForBooleanGetAccessor();
    internal static string get_HeaderSummaryForBooleanGetAndSetAccessor();
    internal static string get_HeaderSummaryForBooleanSetAccessor();
    internal static string get_HeaderSummaryForDestructor();
    internal static string get_HeaderSummaryForGetAccessor();
    internal static string get_HeaderSummaryForGetAndSetAccessor();
    internal static string get_HeaderSummaryForInstanceConstructor();
    internal static string get_HeaderSummaryForPrivateInstanceConstructor();
    internal static string get_HeaderSummaryForSetAccessor();
    internal static string get_HeaderSummaryForStaticConstructor();
    internal static string get_ParameterNotUsed();
    internal static string get_Struct();
}
internal static class StyleCop.CSharp.CommentVerifier : object {
    internal static int MinimumCharacterPercentage;
    internal static int MinimumHeaderCommentLength;
    public static void ExtractTextFromCommentXml(XmlNode commentXml, String& textWithAttributesRemoved, String& textWithAttributesPreserved);
    public static InvalidCommentType IsGarbageComment(string commentWithAttributesRemoved, string commentWithAttributesPreserved, CsElement element, String& spellingError);
    public static InvalidCommentType IsGarbageComment(XmlNode commentXml, CsElement element, String& spellingError);
    private static void AddAttributeValue(StringBuilder commentWithAttributesBuilder, XmlNode childNode, string attributeName);
    private static bool IsSpelledCorrectly(NamingService namingService, string word);
    private static bool TextContainsIncorectSpelling(CsElement element, string text, String& spellingError);
}
public class StyleCop.CSharp.CompanyInformation : UserControl {
    private SourceAnalyzer analyzer;
    private bool dirty;
    private PropertyControl tabControl;
    private IContainer components;
    private CheckBox checkBox;
    private Label companyNameLabel;
    private Label copyrightLabel;
    private TextBox companyName;
    private TextBox copyright;
    public bool Dirty { get; public set; }
    public string TabName { get; }
    public CompanyInformation(DocumentationRules analyzer);
    public sealed virtual bool get_Dirty();
    public sealed virtual void set_Dirty(bool value);
    public sealed virtual string get_TabName();
    public sealed virtual void Activate(bool activated);
    public sealed virtual bool Apply();
    public sealed virtual void Initialize(PropertyControl propertyControl);
    public sealed virtual void PostApply(bool wasDirty);
    public sealed virtual bool PreApply();
    public sealed virtual void RefreshSettingsOverrideState();
    private void CheckBoxCheckedChanged(object sender, EventArgs e);
    private void CompanyNameTextChanged(object sender, EventArgs e);
    private void CopyrightTextChanged(object sender, EventArgs e);
    private void DetectBoldState();
    private void DetectCompanyNameBoldState();
    private void DetectCopyrightBoldState();
    private void InitializeSettings();
    private void SetBoldState(TextBox item, bool bold);
    protected virtual void Dispose(bool disposing);
    private void InitializeComponent();
}
[SourceAnalyzerAttribute("StyleCop.CSharp.CsParser")]
public class StyleCop.CSharp.DocumentationRules : SourceAnalyzer {
    internal static string CompanyNameProperty;
    internal static string CopyrightProperty;
    internal static string IgnoreInternals;
    internal static bool IgnoreInternalsDefaultValue;
    internal static string IgnorePrivates;
    internal static bool IgnorePrivatesDefaultValue;
    internal static bool IncludeFieldsDefaultValue;
    internal static string IncludeFieldsProperty;
    private static string CrefGenericParamsRegex;
    private static string CrefRegex;
    private static Int32[] CopyrightCharTable;
    private Dictionary`2<string, CachedXmlDocument> includedDocs;
    public ICollection`1<IPropertyControlPage> SettingsPages { get; }
    private static DocumentationRules();
    public virtual ICollection`1<IPropertyControlPage> get_SettingsPages();
    public virtual void AnalyzeDocument(CodeDocument document);
    public virtual bool DelayAnalysis(CodeDocument document, int passNumber);
    public virtual bool DoAnalysis(CodeDocument document);
    public virtual int GetDependantFilesHashCode(CultureInfo culture);
    public virtual void PostAnalyze();
    public virtual void PreAnalyze();
    private static string BuildCrefValidationStringForType(ClassBase type);
    private static string BuildGenericParametersRegex(String[] genericParams);
    private static void BuildRegExForAllTypeOptions(ClassBase type, String& regexWithGenerics, String& regexWithoutGenerics);
    private static string BuildRegExStringFromTypeName(string qualifiedTypeName);
    private static string BuildTypeNameStringWithGenerics(string typeName);
    private static string BuildTypeNameStringWithParamsNumber(string typeName);
    private static bool CharacterIsCopyright(char character);
    private static int CountOfStringInStringOccurrences(string text, String[] stringsToFind);
    private static XmlNodeList ExtractDocumentationNodeFromIncludedFile(XmlDocument document, string xpath);
    private static String[] ExtractGenericParametersFromType(string typeName, int index);
    private static List`1<string> ExtractGenericTypeList(string name);
    private static string ExtractGenericTypeParameter(string fullType, int startIndex, int endIndex);
    private static void ExtractIncludeTagFileAndPath(XmlNode documentationNode, String& file, String& path);
    private static XmlDocument FormatXmlDocument(XmlDocument doc);
    private static string GetActualQualifiedNamespace(ClassBase type);
    private static string GetExampleSummaryTextForConstructorType(Constructor constructor, string type);
    private static string GetExampleSummaryTextForDestructor(Destructor destructor);
    private static string GetExpectedSummaryTextForConstructorType(Constructor constructor, string type, string typeRegex);
    private static string GetExpectedSummaryTextForDestructor(string typeRegex);
    private static bool IncludeSetAccessorInDocumentation(Property property, Accessor setAccessor);
    private static bool IsNonPublicStaticExternDllImport(CsElement element);
    private static bool IsXmlHeaderLineEmpty(CsToken token);
    private static CachedXmlDocument LoadDocFileFromDisk(string path);
    private static bool MatchCopyrightText(string copyright1, string copyright2);
    private static string RemoveGenericsFromTypeName(string typeName);
    private static int XmlHeaderLineCodeElementCount(CsToken token);
    private void CheckClassElementHeader(ClassBase classElement, AnalyzerSettings settings);
    private void CheckConstructorSummaryText(Constructor constructor, XmlDocument formattedDocs);
    private void CheckDestructorSummaryText(Destructor destructor, XmlDocument formattedDocs);
    private bool CheckDocumentationForElement(CsElement element, CsElement parentElement, AnalyzerSettings settings);
    private void CheckDocumentationValidity(CsElement element, int lineNumber, XmlNode documentationXml, string documentationType);
    private void CheckElementComments(CsElement element);
    private void CheckElementDocumentation(CsDocument document);
    private void CheckEnumHeaders(Enum element, AnalyzerSettings settings);
    private void CheckFileHeader(CsDocument document);
    private void CheckFileHeader(CsDocument document, string copyright, string companyName);
    private void CheckForBlankLinesInDocumentationHeader(CsElement element, XmlHeader header);
    private void CheckForRepeatingComments(CsElement element, XmlDocument formattedDocs);
    private void CheckGenericTypeParams(CsElement element, XmlDocument formattedDocs);
    private void CheckHeader(CsElement element, AnalyzerSettings settings, bool partialElement);
    private void CheckHeaderElementsForEmptyText(CsElement element, XmlDocument formattedDocs);
    private void CheckHeaderParams(CsElement element, ICollection`1<Parameter> parameters, XmlDocument formattedDocs);
    private void CheckHeaderReturnValue(CsElement element, TypeToken returnType, XmlDocument formattedDocs);
    private void CheckHeaderSummary(CsElement element, int lineNumber, bool partialElement, XmlDocument formattedDocs);
    private void CheckInheritDocRules(CsElement element);
    private void CheckPropertySummaryFormatting(Property property, XmlDocument formattedDocs);
    private void CheckPropertyValueTag(CsElement element, XmlDocument formattedDocs);
    private void CheckSingleLineComments(DocumentRoot root);
    private bool GetFirstTypeName(CsElement parentElement, String& firstTypeName, ElementType& firstTypeElementType);
    private string GetShortestItem(String[] items);
    private bool InsertIncludedDocumentation(CsElement element, XmlDocument documentation);
    private bool InsertIncludedDocumentationForChildNodes(CsElement element, XmlNode documentationNode);
    private bool InsertIncludedDocumentationForNode(CsElement element, XmlNode documentationNode);
    private bool LoadAndReplaceIncludeTag(CsElement element, XmlNode documentationNode);
    private void LoadHeaderIntoDocuments(CsElement element, XmlHeader header, int lineNumber, XmlDocument& rawDocs, XmlDocument& formattedDocs);
    private CachedXmlDocument LoadIncludedDocumentationFile(string basePath, string file);
    private void ParseHeader(CsElement element, XmlHeader header, int lineNumber, bool partialElement);
    private string RemoveExtensions(string path);
    private bool ReplaceIncludeTagWithIncludedDocumentationContents(CsElement element, XmlNode documentationNode, CachedXmlDocument includedDocument, XmlNodeList includedDocumentationNodes);
}
[FlagsAttribute]
internal enum StyleCop.CSharp.InvalidCommentType : Enum {
    public int value__;
    public static InvalidCommentType Valid;
    public static InvalidCommentType Empty;
    public static InvalidCommentType TooShort;
    public static InvalidCommentType NoCapitalLetter;
    public static InvalidCommentType NoPeriod;
    public static InvalidCommentType TooFewCharacters;
    public static InvalidCommentType NoWhitespace;
    public static InvalidCommentType IncorrectSpelling;
}
[SourceAnalyzerAttribute("StyleCop.CSharp.CsParser")]
public class StyleCop.CSharp.LayoutRules : SourceAnalyzer {
    public virtual void AnalyzeDocument(CodeDocument document);
    public virtual bool DoAnalysis(CodeDocument document);
    private static bool BracketSharesLine(Node`1<CsToken> bracketNode, bool allowTrailingCharacters);
    private static bool DoesAccessorHaveBody(Accessor accessor);
    private static Statement GetFirstChildStatement(Statement statement);
    private static Node`1<CsToken> GetOpenBracket(CsTokenList tokens);
    private static string GetOpeningOrClosingBracketText(Bracket bracket);
    private static bool IsAutomaticProperty(Property property);
    private static bool IsCommentInFileHeader(Node`1<CsToken> comment);
    private static bool IsTokenADot(CsToken token);
    private void CheckBracketPlacement(CsElement parentElement, Statement parentStatement, CsTokenList tokens, Node`1<CsToken> openBracketNode, bool allowAllOnOneLine);
    private void CheckChildElementSpacing(CsElement element);
    private void CheckElementBracketPlacement(CsElement element, bool allowAllOnOneLine);
    private void CheckElementCurlyBracketPlacement(CsElement element);
    private bool CheckExpressionCurlyBracketPlacement(Expression expression, Expression parentExpression, Statement parentStatement, CsElement parentElement, object context);
    private void CheckLineSpacing(CsDocument document);
    private void CheckLineSpacingNewline(Node`1<CsToken> precedingTokenNode, Node`1<CsToken> node, int count);
    private void CheckLineSpacingNonWhitespace(CsDocument document, Node`1<CsToken> precedingTokenNode, CsToken token, bool fileHeader, bool firstTokenOnLine, int count);
    private void CheckMissingBlock(CsElement parentElement, Statement statement, Statement embeddedStatement, string statementType, bool allowStacks);
    private void CheckSiblingAccessors(CsElement accessor, Node`1<CsToken> openingBracketNode);
    private bool CheckStatementCurlyBracketPlacement(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, object context);
    private bool VisitElement(CsElement element, CsElement parentElement, object context);
}
[SourceAnalyzerAttribute("StyleCop.CSharp.CsParser")]
public class StyleCop.CSharp.MaintainabilityRules : SourceAnalyzer {
    public virtual void AnalyzeDocument(CodeDocument document);
    public virtual bool DoAnalysis(CodeDocument document);
    private static bool ArgumentTokensMatchStringEmpty(Argument argument);
    private static void CheckFileContents(CsElement element, CsElement parentElement, TopLevelElements topLevelElements);
    private static bool IsEmptyElement(CsElement element);
    private static bool IsEmptyParentOfBlockStatement(Statement statement);
    private static bool IsEmptyString(string text);
    private static bool IsSuppressMessage(MethodInvocationExpression expression);
    private static bool IsUnnecessaryTryStatement(TryStatement tryStatement);
    private void CheckAccessModifierRulesForElement(CsElement element);
    private void CheckAnonymousMethodParenthesis(CsElement element, AnonymousMethodExpression expression);
    private void CheckArithmeticExpressionParenthesis(CsElement element, ArithmeticExpression expression);
    private bool CheckArithmeticParenthesisForExpressionAndChild(CsElement element, ArithmeticExpression expression, ArithmeticExpression childExpression);
    private void CheckCodeAnalysisAttributeJustifications(CsElement element);
    private void CheckCodeAnalysisSuppressionForJustification(CsElement element, MethodInvocationExpression suppression);
    private void CheckConditionalLogicalExpressionParenthesis(CsElement element, ConditionalLogicalExpression expression);
    private bool CheckConditionalLogicalParenthesisForExpressionAndChild(CsElement element, ConditionalLogicalExpression expression, ConditionalLogicalExpression childExpression);
    private void CheckDebugAssertMessage(CsElement element, MethodInvocationExpression debugAssertMethodCall);
    private void CheckDebugFailMessage(CsElement element, MethodInvocationExpression debugFailMethodCall);
    private void CheckFieldAccessModifiers(CsElement element);
    private void CheckForAccessModifier(CsElement element);
    private void CheckForEmptyElements(CsElement element);
    private void CheckForUnnecessaryStatements(Statement statement, CsElement parentElement);
    private void CheckParenthesisForAttributeConstructors(CsElement element);
    private void CheckParenthesizedExpression(CsElement element, ParenthesizedExpression parenthesizedExpression);
    private bool ProcessElement(CsElement element, CsElement parentElement, TopLevelElements topLevelElements);
    private bool ProcessExpression(Expression expression, Expression parentExpression, Statement parentStatement, CsElement parentElement, TopLevelElements context);
    private bool ProcessStatement(Statement statement, Expression parentExpression, Statement parentStatement, CsElement parentElement, TopLevelElements context);
}
[SourceAnalyzerAttribute("StyleCop.CSharp.CsParser")]
public class StyleCop.CSharp.NamingRules : SourceAnalyzer {
    internal static string AllowedPrefixesProperty;
    public ICollection`1<IPropertyControlPage> SettingsPages { get; }
    public virtual ICollection`1<IPropertyControlPage> get_SettingsPages();
    public virtual void AnalyzeDocument(CodeDocument document);
    public virtual bool DoAnalysis(CodeDocument document);
    private static int MovePastPrefix(string name);
    private void CheckCase(CsElement element, string name, int line, bool upper);
    private void CheckFieldPrefix(Field field, Dictionary`2<string, string> validPrefixes);
    private void CheckFieldUnderscores(CsElement field);
    private void CheckHungarian(string name, int startIndex, int line, CsElement element, Dictionary`2<string, string> validPrefixes);
    private void CheckMethodVariablePrefix(Variable variable, CsElement element, Dictionary`2<string, string> validPrefixes);
    private void CheckUnderscores(CsElement element, VariableCollection variables);
    private Dictionary`2<string, string> GetPrefixes(Settings settings);
    private bool ProcessElement(CsElement element, Dictionary`2<string, string> validPrefixes, bool nativeMethods);
    private void ProcessExpression(Expression expression, CsElement element, Dictionary`2<string, string> validPrefixes);
    private void ProcessStatement(Statement statement, CsElement element, Dictionary`2<string, string> validPrefixes);
    private void ProcessStatementContainer(CsElement element, Dictionary`2<string, string> validPrefixes);
}
[SourceAnalyzerAttribute("StyleCop.CSharp.CsParser")]
public class StyleCop.CSharp.OrderingRules : SourceAnalyzer {
    internal static bool GeneratedCodeElementOrderDefaultValueProperty;
    internal static string GeneratedCodeElementOrderProperty;
    public virtual void AnalyzeDocument(CodeDocument document);
    public virtual bool DoAnalysis(CodeDocument document);
    private static string AccessModifierTypeString(AccessModifierType type);
    private static bool CheckNamespaceOrdering(string namespace1, string namespace2);
    private static int GetElementOrder(CsElement element);
    private void CheckChildElementOrdering(CsElement element, bool checkGeneratedCode);
    private void CheckDeclarationKeywordOrder(CsElement element);
    private void CheckElementOrder(CsElement element, bool checkGeneratedCode);
    private void CheckOrderOfUsingDirectivesInList(List`1<UsingDirective> usings);
    private void CheckOrderOfUsingDirectivesUnderElement(CsElement element);
    private void CheckUsingDirectiveOrder(CsElement rootElement);
    private void CheckUsingDirectivePlacement(CsElement element);
    private void CheckNoValueFirstComparison(CsElement element, bool checkGeneratedCode);
    private bool ExpressionCallback(Expression expression, Expression parentExpression, Statement parentStatement, CsElement parentElement, object context);
    private bool IsValueExpression(Expression expression);
    private bool CompareItems(CsElement first, CsElement second, bool foundFirst);
    private bool CompareOrderOfUsingDirectives(UsingDirective firstUsing, UsingDirective secondUsing);
    private bool ProcessElements(CsElement element, bool checkGeneratedCode);
}
[SourceAnalyzerAttribute("StyleCop.CSharp.CsParser")]
public class StyleCop.CSharp.ReadabilityRules : SourceAnalyzer {
    private String[][] builtInTypes;
    public virtual void AnalyzeDocument(CodeDocument document);
    public virtual bool DoAnalysis(CodeDocument document);
    private static bool IsConstVariableDeclaration(Node`1<CsToken> assignmentOperator);
    private static bool IsMethodParameterDeclaration(Node`1<CsToken> node);
    private void CheckBuiltInType(Node`1<CsToken> type, CsDocument document);
    private void CheckBuiltInTypeForMemberAccessExpressions(Node`1<CsToken> type);
    private void CheckEmptyString(Node`1<CsToken> stringNode);
    private void CheckForRegionsInElement(CsElement element, Settings settings);
    private void CheckShorthandForNullableTypes(CsToken type);
    private void IterateTokenList(CsDocument document, Settings settings);
    private bool ProcessElement(CsElement element, CsElement parentElement, object context);
    private bool ProcessExpression(Expression expression, Expression parentExpression, Statement parentStatement, CsElement parentElement, object context);
    private void CheckForEmptyComments(DocumentRoot element);
    private static void DetermineMethodParameterPlacementScheme(IArgumentList arguments, Boolean& someParametersShareLine, Boolean& someParameterOnDifferentLines);
    private static CsTokenList GetArgumentListTokens(CsTokenList tokens, Node`1<CsToken> methodNameLastToken, CsTokenType openBracketType, CsTokenType closeBracketType);
    private static CsTokenList GetParameterListTokens(CsTokenList tokens, CsTokenType openBracketType, CsTokenType closeBracketType);
    private static int MeasureCommentLinesAfter(Node`1<CsToken> start);
    private static int MeasureCommentLinesBetween(Node`1<CsToken> start, Node`1<CsToken> end, bool includeAttributes);
    private static int ParameterPrewordOffset(Node`1<CsToken> tokenNode);
    private void CheckIndexerAccessParameters(CsElement element, ArrayAccessExpression expression);
    private void CheckMethodArgumentList(CsElement element, IArgumentList arguments, Node`1<CsToken> openingBracketNode, int methodLineNumber, string friendlyTypeText);
    private void CheckMethodClosingBracket(CsElement element, CsTokenList parameterListTokens, Node`1<CsToken> openingBracketNode, CsTokenType closingBracketType, IArgumentList arguments);
    private void CheckMethodInvocationParameters(CsElement element, MethodInvocationExpression expression);
    private Node`1<CsToken> CheckMethodOpeningBracket(CsElement element, CsTokenList parameterListTokens, CsTokenType openingBracketType, string textToUseForContainingElement);
    private void CheckMethodParameters(CsElement element);
    private void CheckParameters(CsElement element, CsTokenList parameterListTokens, IArgumentList methodArguments, int methodStartLineNumber, CsTokenType openBracketType, CsTokenType closeBracketType, string friendlyTypeText);
    private void CheckSplitMethodArgumentList(CsElement element, IArgumentList arguments, Node`1<CsToken> openingBracketNode, string friendlyTypeText);
    public virtual bool DelayAnalysis(CodeDocument document, int passNumber);
    private static bool ContainsVariable(VariableCollection variables, string word, CsToken item);
    private static bool IsLiteralTokenPrecededByMemberAccessSymbol(Node`1<CsToken> literalTokenNode, MasterList`1<CsToken> masterList);
    private static bool IsLocalMember(string word, CsToken item, ICodeUnit parent);
    private static bool IsObjectInitializerLeftHandSideExpression(Expression expression);
    private static bool IsThisRequiredFromMemberList(Expression expression, ClassBase parentClass, IEnumerable`1<CsElement> matchesForPassedMethod, IEnumerable`1<CsElement> matchesForGenericMethod, string memberName);
    private static bool IsThisRequiredFromMemberList(IEnumerable`1<CsElement> matchesForPassedMethod);
    private bool CheckClassMemberRulesForElements(CsElement element, ClassBase parentClass, Dictionary`2<string, List`1<CsElement>> members);
    private void CheckClassMemberRulesForExpression(Expression expression, Expression parentExpression, CsElement parentElement, ClassBase parentClass, Dictionary`2<string, List`1<CsElement>> members);
    private void CheckClassMemberRulesForExpressions(IEnumerable`1<Expression> expressions, Expression parentExpression, CsElement parentElement, ClassBase parentClass, Dictionary`2<string, List`1<CsElement>> members);
    private void CheckClassMemberRulesForLiteralToken(Node`1<CsToken> tokenNode, Expression expression, Expression parentExpression, CsElement parentElement, ClassBase parentClass, Dictionary`2<string, List`1<CsElement>> members);
    private void CheckClassMemberRulesForStatements(ICollection`1<Statement> statements, CsElement parentElement, ClassBase parentClass, Dictionary`2<string, List`1<CsElement>> members);
    private bool IsBaseRequired(string memberName, ClassBase parentClass, Dictionary`2<string, List`1<CsElement>> members);
    private bool IsThisRequired(Node`1<CsToken> tokenNode, Expression expression, ClassBase parentClass, Dictionary`2<string, List`1<CsElement>> members);
    private static BlockStatement GetChildBlockStatement(Statement statement);
    private static Node`1<CsToken> GetClosingBracketFromStatement(Statement statement);
    private static CsToken GetNextToken(Node`1<CsToken> tokenNode, MasterList`1<CsToken> tokenList);
    private static Node`1<CsToken> GetOpeningCurlyBracketFromStatement(Statement statement);
    private static CsToken GetPreviousToken(Node`1<CsToken> tokenNode, MasterList`1<CsToken> tokenList);
    private void CheckBlockStatementsCurlyBracketPlacement(CsElement element, Statement statement);
    private void CheckChainedStatementCurlyBracketPlacement(CsElement element, Statement statement);
    private void CheckStatementCurlyBracketPlacement(CsElement element, Statement statement);
    private void CheckStatementFormattingRulesForElement(CsElement element);
    private void CheckStatementFormattingRulesForExpressions(CsElement element, ICollection`1<Expression> expressions);
    private void CheckStatementFormattingRulesForStatement(CsElement element, Statement statement, Statement previousStatement);
    private void CheckStatementFormattingRulesForStatements(CsElement element, ICollection`1<Statement> statements);
    private void CheckTokenPrecedingOrFollowingCurlyBracket(CsElement element, CsToken previousOrNextToken);
    private void CheckTrailingStatementCurlyBracketPlacement(CsElement element, Statement statement);
    private void CheckQueryExpression(CsElement element, QueryExpression queryExpression);
    private bool ProcessQueryClauses(CsElement element, QueryExpression expression, ICollection`1<QueryClause> clauses, QueryClause& previousClause, Boolean& clauseOnSameLine, Boolean& clauseOnSeparateLine);
}
internal enum StyleCop.CSharp.Rules : Enum {
    public int value__;
    public static Rules AccessModifierMustBeDeclared;
    public static Rules CurlyBracketsForMultiLineStatementsMustNotShareLine;
    public static Rules StatementMustNotBeOnSingleLine;
    public static Rules ElementMustNotBeOnSingleLine;
    public static Rules CurlyBracketsMustNotBeOmitted;
    public static Rules AllAccessorsMustBeMultiLineOrSingleLine;
    public static Rules ElementsMustBeDocumented;
    public static Rules PartialElementsMustBeDocumented;
    public static Rules ElementDocumentationMustHaveSummary;
    public static Rules PartialElementDocumentationMustHaveSummary;
    public static Rules ElementDocumentationMustHaveSummaryText;
    public static Rules PartialElementDocumentationMustHaveSummaryText;
    public static Rules ElementParametersMustBeDocumented;
    public static Rules ElementParameterDocumentationMustDeclareParameterName;
    public static Rules ElementParameterDocumentationMustHaveText;
    public static Rules ElementReturnValueMustBeDocumented;
    public static Rules ElementReturnValueDocumentationMustHaveText;
    public static Rules VoidReturnValueMustNotBeDocumented;
    public static Rules GenericTypeParametersMustBeDocumented;
    public static Rules GenericTypeParametersMustBeDocumentedPartialClass;
    public static Rules GenericTypeParameterDocumentationMustMatchTypeParameters;
    public static Rules GenericTypeParameterDocumentationMustDeclareParameterName;
    public static Rules GenericTypeParameterDocumentationMustHaveText;
    public static Rules ElementDocumentationMustNotHaveDefaultSummary;
    public static Rules DocumentationMustContainValidXml;
    public static Rules EnumerationItemsMustBeDocumented;
    public static Rules ElementParameterDocumentationMustMatchElementParameters;
    public static Rules PropertyDocumentationMustHaveValue;
    public static Rules PropertyDocumentationMustHaveValueText;
    public static Rules DocumentationTextMustNotBeEmpty;
    public static Rules DocumentationTextMustEndWithAPeriod;
    public static Rules DocumentationTextMustBeginWithACapitalLetter;
    public static Rules DocumentationTextMustContainWhitespace;
    public static Rules DocumentationMustMeetCharacterPercentage;
    public static Rules DocumentationTextMustMeetMinimumCharacterLength;
    public static Rules ConstructorSummaryDocumentationMustBeginWithStandardText;
    public static Rules DestructorSummaryDocumentationMustBeginWithStandardText;
    public static Rules DocumentationHeadersMustNotContainBlankLines;
    public static Rules IncludedDocumentationFileDoesNotExist;
    public static Rules IncludedDocumentationXPathDoesNotExist;
    public static Rules IncludeNodeDoesNotContainValidFileAndPath;
    public static Rules InheritDocMustBeUsedWithInheritingClass;
    public static Rules PropertySummaryDocumentationMustMatchAccessors;
    public static Rules PropertySummaryDocumentationMustOmitSetAccessorWithRestrictedAccess;
    public static Rules ElementDocumentationMustNotBeCopiedAndPasted;
    public static Rules SingleLineCommentsMustNotUseDocumentationStyleSlashes;
    public static Rules FileMustHaveHeader;
    public static Rules FileHeaderMustShowCopyright;
    public static Rules FileHeaderMustHaveCopyrightText;
    public static Rules FileHeaderCopyrightTextMustMatch;
    public static Rules FileHeaderMustContainFileName;
    public static Rules FileHeaderFileNameDocumentationMustMatchFileName;
    public static Rules FileHeaderMustHaveValidCompanyText;
    public static Rules FileHeaderCompanyNameTextMustMatch;
    public static Rules FileHeaderMustHaveSummary;
    public static Rules ThisMissing;
    public static Rules BaseUsed;
    public static Rules ConstFieldNamesMustBeginWithUpperCaseLetter;
    public static Rules NonPrivateReadonlyFieldsMustBeginWithUpperCaseLetter;
    public static Rules AccessibleFieldsMustBeginWithUpperCaseLetter;
    public static Rules FieldNamesMustBeginWithLowerCaseLetter;
    public static Rules FieldNamesMustNotUseHungarianNotation;
    public static Rules VariableNamesMustNotBePrefixed;
    public static Rules ElementMustBeginWithLowerCaseLetter;
    public static Rules ElementMustBeginWithUpperCaseLetter;
    public static Rules InterfaceNamesMustBeginWithI;
    public static Rules FieldNamesMustNotBeginWithUnderscore;
    public static Rules FieldNamesMustNotContainUnderscore;
    public static Rules CodeMustNotContainMultipleBlankLinesInARow;
    public static Rules ClosingCurlyBracketsMustNotBePrecededByBlankLine;
    public static Rules OpeningCurlyBracketsMustNotBePrecededByBlankLine;
    public static Rules OpeningCurlyBracketsMustNotBeFollowedByBlankLine;
    public static Rules ClosingCurlyBracketMustBeFollowedByBlankLine;
    public static Rules SingleLineCommentMustBePrecededByBlankLine;
    public static Rules ElementsMustBeSeparatedByBlankLine;
    public static Rules ElementDocumentationHeaderMustBePrecededByBlankLine;
    public static Rules ElementDocumentationHeadersMustNotBeFollowedByBlankLine;
    public static Rules ChainedStatementBlocksMustNotBePrecededByBlankLine;
    public static Rules SingleLineCommentsMustNotBeFollowedByBlankLine;
    public static Rules WhileDoFooterMustNotBePrecededByBlankLine;
    public static Rules ElementsMustAppearInTheCorrectOrder;
    public static Rules PartialElementsMustDeclareAccess;
    public static Rules ElementsMustBeOrderedByAccess;
    public static Rules StaticElementsMustAppearBeforeInstanceElements;
    public static Rules FileMayOnlyContainASingleClass;
    public static Rules FileMayOnlyContainASingleNamespace;
    public static Rules CodeAnalysisSuppressionMustHaveJustification;
    public static Rules DebugAssertMustProvideMessageText;
    public static Rules DebugFailMustProvideMessageText;
    public static Rules ArithmeticExpressionsMustDeclarePrecedence;
    public static Rules ConditionalExpressionsMustDeclarePrecedence;
    public static Rules RemoveUnnecessaryCode;
    public static Rules RemoveDelegateParenthesisWhenPossible;
    public static Rules FieldsMustBePrivate;
    public static Rules ConstantsMustAppearBeforeFields;
    public static Rules KeywordsMustBeSpacedCorrectly;
    public static Rules CommasMustBeSpacedCorrectly;
    public static Rules SemicolonsMustBeSpacedCorrectly;
    public static Rules SymbolsMustBeSpacedCorrectly;
    public static Rules OpeningParenthesisMustBeSpacedCorrectly;
    public static Rules ClosingParenthesisMustBeSpacedCorrectly;
    public static Rules OpeningSquareBracketsMustBeSpacedCorrectly;
    public static Rules ClosingSquareBracketsMustBeSpacedCorrectly;
    public static Rules OpeningCurlyBracketsMustBeSpacedCorrectly;
    public static Rules ClosingCurlyBracketsMustBeSpacedCorrectly;
    public static Rules OpeningGenericBracketsMustBeSpacedCorrectly;
    public static Rules ClosingGenericBracketsMustBeSpacedCorrectly;
    public static Rules OpeningAttributeBracketsMustBeSpacedCorrectly;
    public static Rules ClosingAttributeBracketsMustBeSpacedCorrectly;
    public static Rules NullableTypeSymbolsMustNotBePrecededBySpace;
    public static Rules MemberAccessSymbolsMustBeSpacedCorrectly;
    public static Rules IncrementDecrementSymbolsMustBeSpacedCorrectly;
    public static Rules NegativeSignsMustBeSpacedCorrectly;
    public static Rules PositiveSignsMustBeSpacedCorrectly;
    public static Rules DereferenceAndAccessOfSymbolsMustBeSpacedCorrectly;
    public static Rules ColonsMustBeSpacedCorrectly;
    public static Rules TabsMustNotBeUsed;
    public static Rules CodeMustNotContainMultipleWhitespaceInARow;
    public static Rules CodeMustNotContainSpaceAfterNewKeywordInImplicitlyTypedArrayAllocation;
    public static Rules StatementMustNotUseUnnecessaryParenthesis;
    public static Rules PreprocessorKeywordsMustNotBePrecededBySpace;
    public static Rules OperatorKeywordMustBeFollowedBySpace;
    public static Rules SingleLineCommentsMustBeginWithSingleSpace;
    public static Rules DocumentationLinesMustBeginWithSingleSpace;
    public static Rules UsingDirectivesMustBePlacedWithinNamespace;
    public static Rules OpeningParenthesisMustBeOnDeclarationLine;
    public static Rules ClosingParenthesisMustBeOnLineOfLastParameter;
    public static Rules ClosingParenthesisMustBeOnLineOfOpeningParenthesis;
    public static Rules ParameterMustNotSpanMultipleLines;
    public static Rules CommaMustBeOnSameLineAsPreviousParameter;
    public static Rules ParameterListMustFollowDeclaration;
    public static Rules ParameterMustFollowComma;
    public static Rules SplitParametersMustStartOnLineAfterDeclaration;
    public static Rules ParametersMustBeOnSameLineOrSeparateLines;
    public static Rules CodeMustNotContainEmptyStatements;
    public static Rules CodeMustNotContainMultipleStatementsOnOneLine;
    public static Rules BlockStatementsMustNotContainEmbeddedComments;
    public static Rules BlockStatementsMustNotContainEmbeddedRegions;
    public static Rules DoNotPrefixCallsWithBaseUnlessLocalImplementationExists;
    public static Rules PrefixLocalCallsWithThis;
    public static Rules DeclarationKeywordsMustFollowOrder;
    public static Rules ProtectedMustComeBeforeInternal;
    public static Rules SystemUsingDirectivesMustBePlacedBeforeOtherUsingDirectives;
    public static Rules UsingAliasDirectivesMustBePlacedAfterOtherUsingDirectives;
    public static Rules UsingDirectivesMustBeOrderedAlphabeticallyByNamespace;
    public static Rules UsingAliasDirectivesMustBeOrderedAlphabeticallyByAliasName;
    public static Rules PropertyAccessorsMustFollowOrder;
    public static Rules EventAccessorsMustFollowOrder;
    public static Rules CommentsMustContainText;
    public static Rules QueryClauseMustFollowPreviousClause;
    public static Rules QueryClausesMustBeOnSeparateLinesOrAllOnOneLine;
    public static Rules QueryClauseMustBeginOnNewLineWhenPreviousClauseSpansMultipleLines;
    public static Rules QueryClausesSpanningMultipleLinesMustBeginOnOwnLine;
    public static Rules UseBuiltInTypeAlias;
    public static Rules AvoidVarType;
    public static Rules UseShorthandForNullableTypes;
    public static Rules UseStringEmptyForEmptyStrings;
    public static Rules DoNotPlaceRegionsWithinElements;
    public static Rules DoNotUseRegions;
    public static Rules CodeMustNotContainBlankLinesAtStartOfFile;
    public static Rules CodeMustNotContainBlankLinesAtEndOfFile;
    public static Rules AttributeConstructorMustNotUseUnnecessaryParenthesis;
    public static Rules FileHeaderFileNameDocumentationMustMatchTypeName;
    public static Rules StaticReadonlyElementsMustAppearBeforeStaticNonReadonlyElements;
    public static Rules InstanceReadonlyElementsMustAppearBeforeInstanceNonReadonlyElements;
    public static Rules NoValueFirstComparison;
    public static Rules PrefixCallsCorrectly;
    public static Rules StaticReadonlyFieldsMustBeginWithUpperCaseLetter;
    public static Rules ElementDocumentationMustBeSpelledCorrectly;
    public static Rules DoNotSplitNullConditionalOperators;
    public static Rules UsingStaticDirectivesMustBePlacedAfterUsingNamespaceDirectives;
}
[SourceAnalyzerAttribute("StyleCop.CSharp.CsParser")]
public class StyleCop.CSharp.SpacingRules : SourceAnalyzer {
    public virtual void AnalyzeDocument(CodeDocument document);
    public virtual bool DoAnalysis(CodeDocument document);
    private static bool IsAllowedAfterClosingParenthesis(CsToken token);
    private static bool IsTokenADot(CsToken token);
    private void CheckAttributeTokenCloseBracket(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckAttributeTokenOpenBracket(Node`1<CsToken> tokenNode);
    private void CheckCloseCurlyBracket(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckCloseParen(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckCloseSquareBracket(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode, Node`1<CsToken> parentTokenNode);
    private void CheckGenericSpacing(MasterList`1<CsToken> tokens, Node`1<CsToken> genericTokenNode);
    private void CheckGenericTokenCloseBracket(Node`1<CsToken> closeBracketTokenNode, Node`1<CsToken> genericTokenNode);
    private void CheckGenericTokenOpenBracket(Node`1<CsToken> tokenNode);
    private void CheckIncrementDecrement(Node`1<CsToken> tokenNode);
    private void CheckKeywordWithSpace(Node`1<CsToken> tokenNode);
    private void CheckKeywordWithoutSpace(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckLabelColon(Node`1<CsToken> tokenNode);
    private void CheckMemberAccessSymbol(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckNewKeywordSpacing(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckNullableTypeSymbol(Node`1<CsToken> tokenNode);
    private void CheckOpenCurlyBracket(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckOpenParen(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckOpenSquareBracket(Node`1<CsToken> tokenNode);
    private void CheckOperatorKeyword(Node`1<CsToken> tokenNode);
    private void CheckPositiveOrNegativeSign(Node`1<CsToken> tokenNode, bool positiveToken);
    private void CheckPreprocessorSpacing(CsToken preprocessor);
    private void CheckSemicolonAndComma(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckSingleLineComment(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckSpacing(MasterList`1<CsToken> tokens, bool type, Node`1<CsToken> parentTokenNode);
    private void CheckSymbol(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckTabsInComment(CsToken comment);
    private void CheckUnarySymbol(MasterList`1<CsToken> tokens, Node`1<CsToken> tokenNode);
    private void CheckUnsafeAccessSymbols(Node`1<CsToken> tokenNode, bool type, Node`1<CsToken> parentTokenNode);
    private void CheckWhitespace(Node`1<CsToken> tokenNode);
    private void CheckXmlHeaderComment(XmlHeader header);
    private bool IsTokenFirstNonWhitespaceTokenOnLine(MasterList`1<CsToken> tokens, Node`1<CsToken> node);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StyleCop.CSharp.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AccessModifier { get; }
    internal static string Closing { get; }
    internal static string CompanyInformationTab { get; }
    internal static string CurlyBracketsInFileDoNotMatch { get; }
    internal static string EnterValidPrefix { get; }
    internal static string Files { get; }
    internal static string HungarianTab { get; }
    internal static string MissingCompanyOrCopyright { get; }
    internal static string Opening { get; }
    internal static string Other { get; }
    internal static string Static { get; }
    internal static string Title { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AccessModifier();
    internal static string get_Closing();
    internal static string get_CompanyInformationTab();
    internal static string get_CurlyBracketsInFileDoNotMatch();
    internal static string get_EnterValidPrefix();
    internal static string get_Files();
    internal static string get_HungarianTab();
    internal static string get_MissingCompanyOrCopyright();
    internal static string get_Opening();
    internal static string get_Other();
    internal static string get_Static();
    internal static string get_Title();
}
internal class StyleCop.CSharp.Utils : object {
    public static Dictionary`2<string, List`1<CsElement>> CollectClassMembers(ClassBase parentClass);
    public static bool ContainsPartialMembers(CsElement element);
    public static CsToken ExtractBaseClassMemberName(Expression parentExpression, Node`1<CsToken> baseTokenNode);
    public static ICollection`1<CsElement> FindClassMember(string word, ClassBase parentClass, Dictionary`2<string, List`1<CsElement>> members, bool interfaces);
    public static ClassBase GetClassBase(CsElement element);
    public static bool HasABaseClassSpecified(ClassBase classBase);
    public static bool HasImplementedInterfaces(ClassBase classBase);
    public static bool IsAReSharperComment(CsToken token);
    public static bool IsExpressionInsideContainer(Expression expresion, Type[] codeUnits);
    public static bool TokenContainNullable(Node`1<CsToken> token);
    private static void AddClassMember(Dictionary`2<string, List`1<CsElement>> members, CsElement child, string name);
    private static void AddClassMemberAux(Dictionary`2<string, List`1<CsElement>> members, CsElement child, string name);
    private static void CollectClassMembersAux(ClassBase class, Dictionary`2<string, List`1<CsElement>> members);
    private static ICollection`1<CsElement> MatchClassMember(string word, Dictionary`2<string, List`1<CsElement>> members, bool interfaces);
}
internal class StyleCop.CSharp.ValidPrefixes : UserControl {
    private SourceAnalyzer analyzer;
    private Button addButton;
    private TextBox addPrefix;
    private ColumnHeader columnHeader1;
    private bool dirty;
    private IButtonControl formAcceptButton;
    private Label label1;
    private Label label2;
    private Label label3;
    private ListView prefixList;
    private Button removeButton;
    private PropertyControl tabControl;
    public bool Dirty { get; public set; }
    public string TabName { get; }
    public ValidPrefixes(NamingRules analyzer);
    public sealed virtual bool get_Dirty();
    public sealed virtual void set_Dirty(bool value);
    public sealed virtual string get_TabName();
    public sealed virtual void Activate(bool activated);
    public sealed virtual bool Apply();
    public sealed virtual void Initialize(PropertyControl propertyControl);
    public sealed virtual void PostApply(bool wasDirty);
    public sealed virtual bool PreApply();
    public sealed virtual void RefreshSettingsOverrideState();
    private void AddButtonClick(object sender, EventArgs e);
    private void AddParentPrefixes();
    private void AddPrefixGotFocus(object sender, EventArgs e);
    private void AddPrefixKeyDown(object sender, KeyEventArgs e);
    private void AddPrefixLostFocus(object sender, EventArgs e);
    private void EnableDisableRemoveButton();
    private void InitializeComponent();
    private void PrefixListItemSelectionChanged(object sender, ListViewItemSelectionChangedEventArgs e);
    private void PrefixListKeyDown(object sender, KeyEventArgs e);
    private void RemoveButtonClick(object sender, EventArgs e);
    private void SetBoldState(ListViewItem item);
}
