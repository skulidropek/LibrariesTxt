public enum FileHelpers.AlignMode : Enum {
    public int value__;
    public static AlignMode Left;
    public static AlignMode Center;
    public static AlignMode Right;
}
internal class FileHelpers.AssignDelegate : MulticastDelegate {
    public AssignDelegate(object object, IntPtr method);
    public virtual void Invoke(object record, Object[] values);
    public virtual IAsyncResult BeginInvoke(object record, Object[] values, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class FileHelpers.BadUsageException : FileHelpersException {
    protected internal BadUsageException(string message);
    protected internal BadUsageException(int line, int column, string message);
    internal BadUsageException(LineInfo line, string message);
}
public class FileHelpers.BigFileSorter : BigFileSorter`1<SorterRecord> {
    public BigFileSorter(int blockFileSizeInBytes);
    public BigFileSorter(Encoding encoding);
    public BigFileSorter(Comparison`1<string> sorter);
    public BigFileSorter(Comparison`1<string> sorter, int blockFileSizeInBytes);
    public BigFileSorter(Comparison`1<string> sorter, Encoding encoding, int blockFileSizeInBytes);
    private static Comparison`1<SorterRecord> CreateSorter(Comparison`1<string> sorter);
}
public class FileHelpers.BigFileSorter`1 : object {
    private static int DefaultBlockSize;
    private static int MaxBufferSize;
    private static int MinBlockSize;
    private static int AutoBlockSizeRatio;
    private Comparison`1<T> mSorter;
    private bool AutoSetBlockSize;
    [CompilerGeneratedAttribute]
private static Encoding <DefaultEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlockFileSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteTempFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunGcCollectForEachPart>k__BackingField;
    private static Encoding DefaultEncoding { get; private set; }
    public string TempDirectory { get; public set; }
    public int BlockFileSizeInBytes { get; public set; }
    public bool DeleteTempFiles { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool RunGcCollectForEachPart { get; public set; }
    private static BigFileSorter`1();
    public BigFileSorter`1(int blockFileSizeInBytes);
    public BigFileSorter`1(Encoding encoding);
    public BigFileSorter`1(Encoding encoding, int blockFileSizeInBytes);
    internal BigFileSorter`1(Comparison`1<T> sorter, Encoding encoding, int blockFileSizeInBytes);
    [CompilerGeneratedAttribute]
private static Encoding get_DefaultEncoding();
    [CompilerGeneratedAttribute]
private static void set_DefaultEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public string get_TempDirectory();
    [CompilerGeneratedAttribute]
public void set_TempDirectory(string value);
    [CompilerGeneratedAttribute]
public int get_BlockFileSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_BlockFileSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public bool get_DeleteTempFiles();
    [CompilerGeneratedAttribute]
public void set_DeleteTempFiles(bool value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public bool get_RunGcCollectForEachPart();
    [CompilerGeneratedAttribute]
public void set_RunGcCollectForEachPart(bool value);
    public void Sort(string sourceFile, string destinationFile);
    private SortQueue`1[] CreateQueues(List`1<string> parts);
    private FileHelperAsyncEngine`1<T> SplitAndSortParts(string file, List`1<string> res);
    private void WritePart(string file, List`1<T> lines, int partNumber, List`1<string> res);
    private int BlockSizeFromFileSize(string sourceFile);
    protected StreamWriter CreateStream(string filename, int bufferSize);
    protected string GetSplitName(string file, int splitNum);
    internal void MergeTheChunks(SortQueue`1[] queues, string destinationFile, string headerText, string footerText);
}
public static class FileHelpers.CommonEngine : object {
    public static Object[] ReadFile(Type recordClass, string fileName);
    public static Object[] ReadFile(Type recordClass, string fileName, int maxRecords);
    public static DataTable ReadFileAsDT(Type recordClass, string fileName);
    public static DataTable ReadFileAsDT(Type recordClass, string fileName, int maxRecords);
    public static T[] ReadFile(string fileName);
    public static T[] ReadFile(string fileName, int maxRecords);
    public static Object[] ReadString(Type recordClass, string input);
    public static Object[] ReadString(Type recordClass, string input, int maxRecords);
    public static T[] ReadString(string input);
    public static void WriteFile(string fileName, IEnumerable`1<T> records);
    public static string WriteString(IEnumerable`1<T> records);
    public static int TransformFileFast(string sourceFile, string destFile);
    public static Object[] TransformFile(string sourceFile, string destFile);
    public static Object[] ReadSortedFile(Type recordClass, string fileName);
    public static void SortFile(Type recordClass, string sourceFile, string sortedFile);
    public static void SortFileByField(Type recordClass, string fieldName, bool asc, string sourceFile, string sortedFile);
    public static void SortRecordsByField(Object[] records, string fieldName);
    public static void SortRecordsByField(Object[] records, string fieldName, bool ascending);
    public static void SortRecords(Object[] records);
    public static DataTable RecordsToDataTable(ICollection records);
    public static DataTable RecordsToDataTable(ICollection records, int maxRecords);
    public static DataTable RecordsToDataTable(ICollection records, Type recordType);
    public static DataTable RecordsToDataTable(ICollection records, Type recordType, int maxRecords);
    public static void MergeFiles(Type recordType, string file1, string file2, string destinationFile);
    public static Object[] MergeAndSortFile(Type recordType, string file1, string file2, string destFile, string field);
    public static Object[] MergeAndSortFile(Type recordType, string file1, string file2, string destFile, string field, bool ascending);
    public static Object[] MergeAndSortFile(Type recordType, string file1, string file2, string destFile);
    public static void DataTableToCsv(DataTable dt, string filename);
    public static void DataTableToCsv(DataTable dt, string filename, char delimiter);
    public static void DataTableToCsv(DataTable dt, string filename, CsvOptions options);
    public static DataTable CsvToDataTable(string filename, char delimiter);
    public static DataTable CsvToDataTable(string filename, string classname, char delimiter);
    public static DataTable CsvToDataTable(string filename, string classname, char delimiter, bool hasHeader);
    public static DataTable CsvToDataTable(string filename, CsvOptions options);
    public static T[] RemoveDuplicateRecords(T[] arr);
    public static IEnumerable`1<RecordIndexer> ReadCsv(string filename);
    public static IEnumerable`1<RecordIndexer> ReadCsv(string filename, char delimiter);
    public static IEnumerable`1<RecordIndexer> ReadCsv(string filename, char delimiter, int headerLines);
    public static IEnumerable`1<RecordIndexer> ReadCsv(string filename, char delimiter, Encoding encoding);
    public static IEnumerable`1<RecordIndexer> ReadCsv(string filename, char delimiter, int headerLines, Encoding encoding);
    public static void SortBigFile(string source, string destination);
    public static void SortBigFile(Encoding encoding, string source, string destination);
}
[AttributeUsageAttribute("4")]
public class FileHelpers.ConditionalRecordAttribute : Attribute {
    [CompilerGeneratedAttribute]
private RecordCondition <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConditionSelector>k__BackingField;
    public RecordCondition Condition { get; private set; }
    public string ConditionSelector { get; private set; }
    public ConditionalRecordAttribute(RecordCondition condition, string conditionSelector);
    [CompilerGeneratedAttribute]
public RecordCondition get_Condition();
    [CompilerGeneratedAttribute]
private void set_Condition(RecordCondition value);
    [CompilerGeneratedAttribute]
public string get_ConditionSelector();
    [CompilerGeneratedAttribute]
private void set_ConditionSelector(string value);
    private static void CheckNullOrEmpty(string val, string paramName);
}
public abstract class FileHelpers.ConverterBase : object {
    private static string mDefaultDateTimeFormat;
    internal Type mDestinationType;
    public static string DefaultDateTimeFormat { get; public set; }
    [ObsoleteAttribute("This option will be removed: Please prepare your converter to accept null as input")]
protected internal bool CustomNullHandling { get; }
    private static ConverterBase();
    public static string get_DefaultDateTimeFormat();
    public static void set_DefaultDateTimeFormat(string value);
    public abstract virtual object StringToField(string from);
    public virtual string FieldToString(object from);
    protected internal virtual bool get_CustomNullHandling();
    protected void ThrowConvertException(string from, string errorMsg);
}
public enum FileHelpers.ConverterKind : Enum {
    public int value__;
    public static ConverterKind None;
    public static ConverterKind Date;
    public static ConverterKind Boolean;
    public static ConverterKind Byte;
    public static ConverterKind Int16;
    public static ConverterKind Int32;
    public static ConverterKind Int64;
    public static ConverterKind Decimal;
    public static ConverterKind Double;
    public static ConverterKind PercentDouble;
    public static ConverterKind Single;
    public static ConverterKind SByte;
    public static ConverterKind UInt16;
    public static ConverterKind UInt32;
    public static ConverterKind UInt64;
    public static ConverterKind DateMultiFormat;
    public static ConverterKind Char;
    public static ConverterKind Guid;
}
internal class FileHelpers.Converters.BooleanConverter : ConverterBase {
    private string mTrueString;
    private string mFalseString;
    private string mTrueStringLower;
    private string mFalseStringLower;
    public BooleanConverter(string trueStr, string falseStr);
    public virtual object StringToField(string from);
    public virtual string FieldToString(object from);
}
internal class FileHelpers.Converters.ByteConverter : CultureConverter {
    public ByteConverter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.CharConverter : ConverterBase {
    private CharFormat mFormat;
    public CharConverter(string format);
    public virtual object StringToField(string from);
    public virtual string FieldToString(object from);
}
internal static class FileHelpers.Converters.ConvertHelpers : object {
    internal static string DefaultDecimalSep;
    internal static ConverterBase GetDefaultConverter(string fieldName, Type fieldType, string defaultCultureName);
    internal static string RemoveBlanks(string source);
}
internal abstract class FileHelpers.Converters.CultureConverter : ConverterBase {
    protected CultureInfo mCulture;
    protected Type mType;
    protected CultureConverter(Type T, string decimalSepOrCultureName);
    public sealed virtual string FieldToString(object from);
    private static CultureInfo CreateCulture(string decimalSepOrCultureName);
}
internal class FileHelpers.Converters.DateTimeConverter : ConverterBase {
    private string mFormat;
    private CultureInfo mCulture;
    public DateTimeConverter(string format);
    public DateTimeConverter(string format, string culture);
    public virtual object StringToField(string from);
    public virtual string FieldToString(object from);
}
internal class FileHelpers.Converters.DateTimeMultiFormatConverter : ConverterBase {
    private String[] mFormats;
    public DateTimeMultiFormatConverter(string format1, string format2);
    public DateTimeMultiFormatConverter(string format1, string format2, string format3);
    private DateTimeMultiFormatConverter(String[] formats);
    public virtual object StringToField(string from);
    private string CreateFormats();
    public virtual string FieldToString(object from);
}
internal class FileHelpers.Converters.DecimalConverter : CultureConverter {
    public DecimalConverter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.DoubleConverter : CultureConverter {
    public DoubleConverter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.GuidConverter : ConverterBase {
    private string mFormat;
    public GuidConverter(string format);
    public virtual object StringToField(string from);
    public virtual string FieldToString(object from);
}
public interface FileHelpers.Converters.IConverter {
    public abstract virtual object StringToField(string from);
    public abstract virtual string FieldToString(object from);
}
internal class FileHelpers.Converters.Int16Converter : CultureConverter {
    public Int16Converter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.Int32Converter : CultureConverter {
    public Int32Converter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.Int64Converter : CultureConverter {
    public Int64Converter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.PercentDoubleConverter : CultureConverter {
    public PercentDoubleConverter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.SByteConverter : CultureConverter {
    public SByteConverter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.SingleConverter : CultureConverter {
    public SingleConverter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.UInt16Converter : CultureConverter {
    public UInt16Converter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.UInt32Converter : CultureConverter {
    public UInt32Converter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
internal class FileHelpers.Converters.UInt64Converter : CultureConverter {
    public UInt64Converter(string decimalSepOrCultureName);
    public virtual object StringToField(string from);
}
public class FileHelpers.ConvertException : FileHelpersException {
    [CompilerGeneratedAttribute]
private Type <FieldType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldStringValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageExtra>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageOriginal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    public Type FieldType { get; private set; }
    public string FieldStringValue { get; private set; }
    public string MessageExtra { get; private set; }
    public string MessageOriginal { get; private set; }
    public string FieldName { get; internal set; }
    public int LineNumber { get; internal set; }
    public int ColumnNumber { get; internal set; }
    public ConvertException(string origValue, Type destType);
    public ConvertException(string origValue, Type destType, string extraInfo);
    public ConvertException(string origValue, Type destType, string fieldName, int lineNumber, int columnNumber, string extraInfo, Exception innerEx);
    [CompilerGeneratedAttribute]
public Type get_FieldType();
    [CompilerGeneratedAttribute]
private void set_FieldType(Type value);
    [CompilerGeneratedAttribute]
public string get_FieldStringValue();
    [CompilerGeneratedAttribute]
private void set_FieldStringValue(string value);
    [CompilerGeneratedAttribute]
public string get_MessageExtra();
    [CompilerGeneratedAttribute]
private void set_MessageExtra(string value);
    [CompilerGeneratedAttribute]
public string get_MessageOriginal();
    [CompilerGeneratedAttribute]
private void set_MessageOriginal(string value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
internal void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
internal void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
internal void set_ColumnNumber(int value);
    private static string MessageBuilder(string origValue, Type destType, string fieldName, int lineNumber, int columnNumber, string extraInfo);
}
internal static class FileHelpers.Core.Attributes : object {
    public static T GetFirst(MemberInfo type);
    public static T GetFirstInherited(MemberInfo type);
    private static T GetFirstCore(MemberInfo type, bool inherited);
    public static void WorkWithFirst(MemberInfo type, Action`1<T> action);
}
internal static class FileHelpers.Core.ComparerCache : object {
    private static CultureInfo mCulture;
    internal static CompareInfo CreateComparer();
}
internal static class FileHelpers.Core.ConditionHelper : object {
    public static bool BeginsWith(string line, string selector);
    public static bool EndsWith(string line, string selector);
    public static bool Contains(string line, string selector);
    public static bool Enclosed(string line, string selector);
}
internal class FileHelpers.CreateAndAssignDelegate : MulticastDelegate {
    public CreateAndAssignDelegate(object object, IntPtr method);
    public virtual object Invoke(Object[] values);
    public virtual IAsyncResult BeginInvoke(Object[] values, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class FileHelpers.CreateObjectDelegate : MulticastDelegate {
    public CreateObjectDelegate(object object, IntPtr method);
    public virtual object Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("CsvEngine. ErrorMode: {ErrorManager.ErrorMode.ToString()}. Encoding: {Encoding.EncodingName}")]
public class FileHelpers.CsvEngine : FileHelperEngine {
    public CsvEngine(string className, char delimiter, string sampleFile);
    public CsvEngine(string className, char delimiter, int numberOfFields);
    public CsvEngine(CsvOptions options);
    public static DataTable CsvToDataTable(string filename, char delimiter);
    public static DataTable CsvToDataTable(string filename, string classname, char delimiter);
    public static DataTable CsvToDataTable(string filename, string classname, char delimiter, bool hasHeader);
    public static DataTable CsvToDataTable(string filename, string classname, char delimiter, bool hasHeader, bool ignoreEmptyLines);
    public static DataTable CsvToDataTable(string filename, CsvOptions options);
    public static void DataTableToCsv(DataTable dt, string filename);
    public static void DataTableToCsv(DataTable dt, string filename, char delimiter);
    public static void DataTableToCsv(DataTable dt, string filename, CsvOptions options);
    private static Type GetMappingClass(CsvOptions options);
    private static void Append(TextWriter fs, CsvOptions options, IList`1<object> fields);
}
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public class FileHelpers.DataLink.AccessStorage : DatabaseStorage {
    private string mAccessFile;
    private string mAccessPassword;
    public string AccessFileName { get; public set; }
    public string AccessFilePassword { get; public set; }
    public AccessStorage(Type recordType);
    public AccessStorage(Type recordType, string accessFile);
    protected sealed virtual IDbConnection CreateConnection();
    public string get_AccessFileName();
    public void set_AccessFileName(string value);
    public string get_AccessFilePassword();
    public void set_AccessFilePassword(string value);
}
internal static class FileHelpers.DataLink.DataBaseHelper : object {
    private static string AccessConnStr;
    private static string AppName;
    private static DataBaseHelper();
    public static string GetAccessConnection(string db, string password);
    public static string SqlConnectionString(string server, string dbName, string user, string pass);
}
[EditorBrowsableAttribute("2")]
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public abstract class FileHelpers.DataLink.DatabaseStorage : DataStorage {
    private string mSelectSql;
    private IDbConnection mConn;
    private int mCommandTimeout;
    private InsertSqlHandler mInsertSqlCallback;
    private FillRecordHandler mFillRecordCallback;
    private int mExecuteInBatchSize;
    private TransactionMode mTransactionMode;
    private string mConnectionString;
    public string SelectSql { get; public set; }
    public int CommandTimeout { get; public set; }
    protected bool ExecuteInBatch { get; }
    public InsertSqlHandler InsertSqlCallback { get; public set; }
    public FillRecordHandler FillRecordCallback { get; public set; }
    public int ExecuteInBatchSize { get; public set; }
    public TransactionMode TransactionMode { get; public set; }
    public string ConnectionString { get; public set; }
    protected DatabaseStorage(Type recordType);
    private object FillRecord(Object[] fieldValues);
    private string GetSelectSql();
    public string get_SelectSql();
    public void set_SelectSql(string value);
    private string GetInsertSql(object record);
    protected abstract virtual IDbConnection CreateConnection();
    private void InitConnection();
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public virtual Object[] ExtractRecords();
    protected virtual bool get_ExecuteInBatch();
    public virtual void InsertRecords(Object[] records);
    private int ExecuteAndLeaveOpen(string sql);
    private int ExecuteAndClose(string sql);
    public InsertSqlHandler get_InsertSqlCallback();
    public void set_InsertSqlCallback(InsertSqlHandler value);
    public FillRecordHandler get_FillRecordCallback();
    public void set_FillRecordCallback(FillRecordHandler value);
    public int get_ExecuteInBatchSize();
    public void set_ExecuteInBatchSize(int value);
    public TransactionMode get_TransactionMode();
    public void set_TransactionMode(TransactionMode value);
    private IDbTransaction InitTransaction(IDbConnection conn);
    private void CommitTransaction(IDbTransaction trans);
    private void RollBackTransaction(IDbTransaction trans);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
}
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public abstract class FileHelpers.DataLink.DataStorage : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<ProgressEventArgs> Progress;
    private Type mRecordType;
    internal IRecordInfo mRecordInfo;
    protected ErrorManager mErrorManager;
    public Type RecordType { get; }
    public IEnumerable`1<string> FieldFriendlyNames { get; }
    public ErrorManager ErrorManager { get; }
    protected int RecordFieldCount { get; }
    protected DataStorage(Type recordClass);
    [CompilerGeneratedAttribute]
public void add_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Progress(EventHandler`1<ProgressEventArgs> value);
    protected void OnProgress(ProgressEventArgs e);
    public Type get_RecordType();
    public abstract virtual Object[] ExtractRecords();
    public DataTable ExtractRecordsAsDT();
    public abstract virtual void InsertRecords(Object[] records);
    public IEnumerable`1<string> get_FieldFriendlyNames();
    public void RemoveField(string fieldName);
    public ErrorManager get_ErrorManager();
    protected void AddError(int lineNumber, Exception ex, string recordLine, string recordTypeName);
    protected object ValuesToRecord(Object[] values);
    protected Object[] RecordToValues(object record);
    protected int get_RecordFieldCount();
}
public enum FileHelpers.DataLink.ExcelReadStopBehavior : Enum {
    public int value__;
    public static ExcelReadStopBehavior StopOnEmptyFirstCell;
    public static ExcelReadStopBehavior StopOnEmptyRow;
}
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public abstract class FileHelpers.DataLink.ExcelStorageBase : DataStorage {
    private ExcelUpdateLinksMode mUpdateLinks;
    private string mSheetName;
    private string mFileName;
    private int mStartRow;
    private int mStartColumn;
    private int mHeaderRows;
    private string mTemplateFile;
    private ExcelReadStopBehavior mExcelReadStopBehavior;
    private int mExcelReadStopAfterEmptyRows;
    private List`1<string> mColumnHeaders;
    private bool mOverrideFile;
    public ExcelUpdateLinksMode UpdateLinks { get; public set; }
    public int StartRow { get; public set; }
    public int StartColumn { get; public set; }
    public int HeaderRows { get; public set; }
    public string FileName { get; public set; }
    public string SheetName { get; public set; }
    public bool OverrideFile { get; public set; }
    public string TemplateFile { get; public set; }
    public ExcelReadStopBehavior ExcelReadStopBehavior { get; public set; }
    public int ExcelReadStopAfterEmptyRows { get; public set; }
    public List`1<string> ColumnsHeaders { get; public set; }
    public ExcelStorageBase(Type recordType);
    public ExcelStorageBase(Type recordType, int startRow, int startCol);
    public ExcelStorageBase(Type recordType, string fileName, int startRow, int startCol);
    public ExcelUpdateLinksMode get_UpdateLinks();
    public void set_UpdateLinks(ExcelUpdateLinksMode value);
    public int get_StartRow();
    public void set_StartRow(int value);
    public int get_StartColumn();
    public void set_StartColumn(int value);
    public int get_HeaderRows();
    public void set_HeaderRows(int value);
    public string get_FileName();
    public void set_FileName(string value);
    public string get_SheetName();
    public void set_SheetName(string value);
    public bool get_OverrideFile();
    public void set_OverrideFile(bool value);
    public string get_TemplateFile();
    public void set_TemplateFile(string value);
    public ExcelReadStopBehavior get_ExcelReadStopBehavior();
    public void set_ExcelReadStopBehavior(ExcelReadStopBehavior value);
    public int get_ExcelReadStopAfterEmptyRows();
    public void set_ExcelReadStopAfterEmptyRows(int value);
    public List`1<string> get_ColumnsHeaders();
    public void set_ColumnsHeaders(List`1<string> value);
    protected bool CellIsEmpty(object row, object col);
    protected abstract virtual string CellAsString(object row, object col);
    protected bool RowIsEmpty(int cRow);
    protected bool ShouldStopOnRow(int cRow);
    protected bool ShouldReadRowData(int cRow);
}
public enum FileHelpers.DataLink.ExcelUpdateLinksMode : Enum {
    public int value__;
    public static ExcelUpdateLinksMode NeverUpdate;
    public static ExcelUpdateLinksMode UserPrompted;
    public static ExcelUpdateLinksMode AlwaysUpdate;
}
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public class FileHelpers.DataLink.FileDataLink : object {
    private FileHelperEngine mHelperEngine;
    private DataStorage mProvider;
    private Object[] mLastExtractedRecords;
    private Object[] mLastInsertedRecords;
    public FileHelperEngine FileHelperEngine { get; }
    public DataStorage DataStorage { get; }
    public Object[] LastExtractedRecords { get; }
    public Object[] LastInsertedRecords { get; }
    public FileDataLink(DataStorage provider);
    public FileHelperEngine get_FileHelperEngine();
    public DataStorage get_DataStorage();
    public Object[] get_LastExtractedRecords();
    public Object[] get_LastInsertedRecords();
    public Object[] ExtractToFile(string fileName);
    public Object[] ExtractToStream(StreamWriter writer);
    public Object[] InsertFromFile(string fileName);
    public Object[] InsertFromStream(StreamReader reader);
    public static Object[] EasyExtractToFile(DataStorage storage, string filename);
    public static Object[] EasyInsertFromFile(DataStorage storage, string filename);
}
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public class FileHelpers.DataLink.FileStorage : DataStorage {
    private FileHelperEngine mEngine;
    private string mFileName;
    public FileHelperEngine Engine { get; }
    public string FileName { get; public set; }
    public FileStorage(Type type, string fileName);
    public virtual Object[] ExtractRecords();
    public FileHelperEngine get_Engine();
    public string get_FileName();
    public void set_FileName(string value);
    public virtual void InsertRecords(Object[] records);
}
public class FileHelpers.DataLink.FillRecordHandler : MulticastDelegate {
    public FillRecordHandler(object object, IntPtr method);
    public virtual void Invoke(object record, Object[] fieldValues);
    public virtual IAsyncResult BeginInvoke(object record, Object[] fieldValues, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public class FileHelpers.DataLink.GenericDatabaseStorage`1 : DatabaseStorage {
    protected bool ExecuteInBatch { get; }
    public GenericDatabaseStorage`1(Type recordType, string connectionString);
    protected virtual bool get_ExecuteInBatch();
    protected sealed virtual IDbConnection CreateConnection();
}
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public class FileHelpers.DataLink.GenericDataLink : object {
    private DataStorage mDataStorage1;
    private DataStorage mDataStorage2;
    public DataStorage DataStorage1 { get; }
    public DataStorage DataStorage2 { get; }
    public GenericDataLink(DataStorage provider1, DataStorage provider2);
    public Object[] CopyDataFrom1To2();
    public Object[] CopyDataFrom2To1();
    public DataStorage get_DataStorage1();
    public DataStorage get_DataStorage2();
    private void ValidateRecordTypes();
}
public class FileHelpers.DataLink.InsertSqlHandler : MulticastDelegate {
    public InsertSqlHandler(object object, IntPtr method);
    public virtual string Invoke(object record);
    public virtual IAsyncResult BeginInvoke(object record, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public class FileHelpers.DataLink.OleDbStorage : DatabaseStorage {
    public OleDbStorage(Type recordType, string oleDbConnString);
    protected sealed virtual IDbConnection CreateConnection();
}
[ObsoleteAttribute("Datalink feature is outdated and will be rewritten, see https://www.filehelpers.net/mustread/")]
public class FileHelpers.DataLink.SqlServerStorage : DatabaseStorage {
    private string mServerName;
    private string mDatabaseName;
    private string mUserName;
    private string mUserPass;
    public string ServerName { get; public set; }
    public string DatabaseName { get; public set; }
    public string UserName { get; public set; }
    public string UserPass { get; public set; }
    protected bool ExecuteInBatch { get; }
    public SqlServerStorage(Type recordType);
    public SqlServerStorage(Type recordType, string connectionStr);
    public SqlServerStorage(Type recordType, string server, string database);
    public SqlServerStorage(Type recordType, string server, string database, string user, string pass);
    protected sealed virtual IDbConnection CreateConnection();
    public string get_ServerName();
    public void set_ServerName(string value);
    public string get_DatabaseName();
    public void set_DatabaseName(string value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_UserPass();
    public void set_UserPass(string value);
    protected virtual bool get_ExecuteInBatch();
}
public enum FileHelpers.DataLink.TransactionMode : Enum {
    public int value__;
    public static TransactionMode NoTransaction;
    public static TransactionMode UseDefault;
    public static TransactionMode UseChaosLevel;
    public static TransactionMode UseReadCommitted;
    public static TransactionMode UseReadUnCommitted;
    public static TransactionMode UseRepeatableRead;
    public static TransactionMode UseSerializable;
}
public class FileHelpers.DelimitedField : FieldBase {
    private static CompareInfo mCompare;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private MultilineMode <QuoteMultiline>k__BackingField;
    [CompilerGeneratedAttribute]
private QuoteMode <QuoteMode>k__BackingField;
    [CompilerGeneratedAttribute]
private char <QuoteChar>k__BackingField;
    internal string Separator { get; internal set; }
    internal int CharsToDiscard { get; }
    public MultilineMode QuoteMultiline { get; public set; }
    public QuoteMode QuoteMode { get; public set; }
    public char QuoteChar { get; public set; }
    internal DelimitedField(FieldInfo fi, string sep, string defaultCultureName);
    private static DelimitedField();
    [CompilerGeneratedAttribute]
internal string get_Separator();
    [CompilerGeneratedAttribute]
internal void set_Separator(string value);
    internal virtual int get_CharsToDiscard();
    [CompilerGeneratedAttribute]
public MultilineMode get_QuoteMultiline();
    [CompilerGeneratedAttribute]
public void set_QuoteMultiline(MultilineMode value);
    [CompilerGeneratedAttribute]
public QuoteMode get_QuoteMode();
    [CompilerGeneratedAttribute]
public void set_QuoteMode(QuoteMode value);
    [CompilerGeneratedAttribute]
public char get_QuoteChar();
    [CompilerGeneratedAttribute]
public void set_QuoteChar(char value);
    internal virtual ExtractedInfo ExtractFieldString(LineInfo line);
    private static ExtractedInfo ExtractQuotedString(LineInfo line, char quoteChar, bool allowMultiline);
    private ExtractedInfo BasicExtractString(LineInfo line);
    protected virtual void CreateFieldString(StringBuilder sb, string field, bool isLast);
    private static void CreateQuotedString(StringBuilder sb, string source, char quoteChar);
    protected virtual FieldBase CreateClone();
}
[DebuggerDisplayAttribute("DelimitedFileEngine for type: {RecordType.Name}. ErrorMode: {ErrorManager.ErrorMode.ToString()}. Encoding: {Encoding.EncodingName}")]
public class FileHelpers.DelimitedFileEngine : FileHelperEngine {
    public DelimitedRecordOptions Options { get; }
    public DelimitedFileEngine(Type recordType);
    public DelimitedFileEngine(Type recordType, Encoding encoding);
    public DelimitedRecordOptions get_Options();
}
[DebuggerDisplayAttribute("DelimitedFileEngine for type: {RecordType.Name}. ErrorMode: {ErrorManager.ErrorMode.ToString()}. Encoding: {Encoding.EncodingName}")]
public class FileHelpers.DelimitedFileEngine`1 : FileHelperEngine`1<T> {
    public DelimitedRecordOptions Options { get; }
    public DelimitedFileEngine`1(Encoding encoding);
    public DelimitedRecordOptions get_Options();
}
[AttributeUsageAttribute("4")]
public class FileHelpers.DelimitedRecordAttribute : TypedRecordAttribute {
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    public string Separator { get; private set; }
    public DelimitedRecordAttribute(string delimiter, string defaultCultureName);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
private void set_Separator(string value);
}
internal class FileHelpers.Detection.DelimiterInfo : object {
    [CompilerGeneratedAttribute]
private int <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Average>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Deviation>k__BackingField;
    public int Max { get; public set; }
    public int Min { get; public set; }
    public int Average { get; public set; }
    public char Delimiter { get; public set; }
    public double Deviation { get; public set; }
    public DelimiterInfo(char delimiter, double average, int max, int min, double deviation);
    [CompilerGeneratedAttribute]
public int get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(int value);
    [CompilerGeneratedAttribute]
public int get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(int value);
    [CompilerGeneratedAttribute]
public int get_Average();
    [CompilerGeneratedAttribute]
public void set_Average(int value);
    [CompilerGeneratedAttribute]
public char get_Delimiter();
    [CompilerGeneratedAttribute]
public void set_Delimiter(char value);
    [CompilerGeneratedAttribute]
public double get_Deviation();
    [CompilerGeneratedAttribute]
public void set_Deviation(double value);
}
public enum FileHelpers.Detection.FormatHint : Enum {
    public int value__;
    public static FormatHint Unknown;
    public static FormatHint FixedLength;
    public static FormatHint Delimited;
    public static FormatHint DelimitedByTab;
    public static FormatHint DelimitedByComma;
    public static FormatHint DelimitedBySemicolon;
}
internal static class FileHelpers.Detection.QuoteHelper : object {
    public static int CountNumberOfDelimiters(string line, char delimiter, char quotedChar);
    private static string DiscardUntilQuotedChar(string line, char quoteChar);
}
public class FileHelpers.Detection.RecordFormatInfo : object {
    internal int mConfidence;
    internal ClassBuilder mClassBuilder;
    public int Confidence { get; }
    public ClassBuilder ClassBuilder { get; }
    public FixedLengthClassBuilder ClassBuilderAsFixed { get; }
    public DelimitedClassBuilder ClassBuilderAsDelimited { get; }
    public int get_Confidence();
    public ClassBuilder get_ClassBuilder();
    public FixedLengthClassBuilder get_ClassBuilderAsFixed();
    public DelimitedClassBuilder get_ClassBuilderAsDelimited();
}
public class FileHelpers.Detection.SmartFormatDetector : object {
    private static int MinSampleData;
    private static double MinDelimitedDeviation;
    private FormatHint mFormatHint;
    private int mMaxSampleLines;
    private Encoding mEncoding;
    private double mFixedLengthDeviationTolerance;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FileHasHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private char <QuotedChar>k__BackingField;
    public FormatHint FormatHint { get; public set; }
    public int MaxSampleLines { get; public set; }
    public Encoding Encoding { get; public set; }
    public Nullable`1<bool> FileHasHeaders { get; public set; }
    public double FixedLengthDeviationTolerance { get; public set; }
    private char QuotedChar { get; private set; }
    public FormatHint get_FormatHint();
    public void set_FormatHint(FormatHint value);
    public int get_MaxSampleLines();
    public void set_MaxSampleLines(int value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_FileHasHeaders();
    [CompilerGeneratedAttribute]
public void set_FileHasHeaders(Nullable`1<bool> value);
    public double get_FixedLengthDeviationTolerance();
    public void set_FixedLengthDeviationTolerance(double value);
    public RecordFormatInfo[] DetectFileFormat(string file);
    public RecordFormatInfo[] DetectFileFormat(IEnumerable`1<string> files);
    public RecordFormatInfo[] DetectFileFormat(IEnumerable`1<TextReader> files);
    private void DetectQuoted(RecordFormatInfo format, String[][] data);
    private void DetectTypes(RecordFormatInfo format, String[][] data);
    private void DetectOptionals(RecordFormatInfo option, String[][] data);
    private void CreateMixedOptions(String[][] data, List`1<RecordFormatInfo> res);
    private void CreateFixedLengthOptions(String[][] data, List`1<RecordFormatInfo> res);
    private void CreateFixedLengthFields(String[][] data, FixedLengthClassBuilder builder);
    private List`1<FixedColumnInfo> CreateFixedLengthCandidates(String[] lines);
    private List`1<FixedColumnInfo> JoinFixedColCandidates(List`1<FixedColumnInfo> cand1, List`1<FixedColumnInfo> cand2);
    private bool HeadersInData(DelimiterInfo info, String[] headerValues, String[] rows);
    private bool DetectIfContainsHeaders(DelimiterInfo info, String[][] sampleData);
    private bool SameFirstLine(DelimiterInfo info, String[][] sampleData);
    private bool SameHeaders(DelimiterInfo info, string line1, string line2);
    private bool AreAllHeaders(String[] rowData);
    private void CreateDelimiterOptions(String[][] sampleData, List`1<RecordFormatInfo> res, char delimiter);
    private void AdjustConfidence(RecordFormatInfo format, DelimiterInfo info);
    private String[][] GetSampleLines(IEnumerable`1<string> files, int nroOfLines);
    private static String[][] GetSampleLines(IEnumerable`1<TextReader> files, int nroOfLines);
    private static int NumberOfLines(String[][] data);
    private static String[] RawReadFirstLinesArray(string file, int lines, Encoding encoding);
    private static String[] RawReadFirstLinesArray(TextReader stream, int lines);
    private DelimiterInfo GetDelimiterInfo(String[][] data, char delimiter);
    private List`1<DelimiterInfo> GetDelimiters(String[][] data);
    [CompilerGeneratedAttribute]
private char get_QuotedChar();
    [CompilerGeneratedAttribute]
private void set_QuotedChar(char value);
}
internal class FileHelpers.Dynamic.AttributesBuilder : object {
    private StringBuilder mSb;
    private NetLanguage mLang;
    private bool mFirst;
    public AttributesBuilder(NetLanguage lang);
    public void AddAttribute(string attribute);
    public string GetAttributesCode();
}
public abstract class FileHelpers.Dynamic.ClassBuilder : object {
    private static List`1<string> mReferences;
    private static object mReferencesLock;
    [CompilerGeneratedAttribute]
private List`1<Assembly> <AdditionalReferences>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
internal ArrayList mFields;
    [DebuggerBrowsableAttribute("0")]
private string mClassName;
    [DebuggerBrowsableAttribute("0")]
private int mIgnoreFirstLines;
    [DebuggerBrowsableAttribute("0")]
private int mIgnoreLastLines;
    [DebuggerBrowsableAttribute("0")]
private bool mIgnoreEmptyLines;
    [DebuggerBrowsableAttribute("0")]
private bool mGenerateProperties;
    [DebuggerBrowsableAttribute("0")]
private string mCommentText;
    [DebuggerBrowsableAttribute("0")]
private NetVisibility mVisibility;
    [DebuggerBrowsableAttribute("0")]
private bool mSealedClass;
    [DebuggerBrowsableAttribute("0")]
private string mNamespace;
    [DebuggerBrowsableAttribute("0")]
private RecordConditionInfo mRecordConditionInfo;
    [DebuggerBrowsableAttribute("0")]
private IgnoreCommentInfo mIgnoreCommentInfo;
    public List`1<Assembly> AdditionalReferences { get; private set; }
    public FieldBuilder[] Fields { get; }
    public int FieldCount { get; }
    public string ClassName { get; public set; }
    public int IgnoreFirstLines { get; public set; }
    public int IgnoreLastLines { get; public set; }
    public bool IgnoreEmptyLines { get; public set; }
    public bool GenerateProperties { get; public set; }
    public string CommentText { get; public set; }
    public NetVisibility Visibility { get; public set; }
    public bool SealedClass { get; public set; }
    public string Namespace { get; public set; }
    public RecordConditionInfo RecordCondition { get; }
    public IgnoreCommentInfo IgnoreCommentedLines { get; }
    internal ClassBuilder(string className);
    private static ClassBuilder();
    public static Type ClassFromString(string classStr);
    public static Type ClassFromString(string classStr, NetLanguage lang);
    public static Type ClassFromString(string classStr, string className);
    public static Type ClassFromString(string classStr, string className, NetLanguage lang, List`1<Assembly> additionalReferences);
    public static Type ClassFromSourceFile(string filename);
    public static Type ClassFromSourceFile(string filename, NetLanguage lang);
    public static Type ClassFromSourceFile(string filename, string className);
    public static Type ClassFromSourceFile(string filename, string className, NetLanguage lang);
    public static Type ClassFromBinaryFile(string filename);
    public static Type ClassFromBinaryFile(string filename, NetLanguage lang);
    public static Type ClassFromBinaryFile(string filename, string className, NetLanguage lang);
    public static Type ClassFromBinaryFile(string filename, string className, NetLanguage lang, string password);
    public static Type ClassFromXmlFile(string filename);
    public static void ClassToBinaryFile(string filename, string classSource);
    public static void ClassToBinaryFile(string filename, string classSource, string password);
    [CompilerGeneratedAttribute]
public List`1<Assembly> get_AdditionalReferences();
    [CompilerGeneratedAttribute]
private void set_AdditionalReferences(List`1<Assembly> value);
    public void SaveToSourceFile(string filename);
    public void SaveToSourceFile(string filename, NetLanguage lang);
    public void SaveToBinaryFile(string filename);
    public void SaveToBinaryFile(string filename, NetLanguage lang);
    public Type CreateRecordClass();
    public void ClearFields();
    internal void AddFieldInternal(FieldBuilder field);
    public FieldBuilder[] get_Fields();
    public int get_FieldCount();
    public FieldBuilder FieldByIndex(int index);
    public string get_ClassName();
    public void set_ClassName(string value);
    public int get_IgnoreFirstLines();
    public void set_IgnoreFirstLines(int value);
    public int get_IgnoreLastLines();
    public void set_IgnoreLastLines(int value);
    public bool get_IgnoreEmptyLines();
    public void set_IgnoreEmptyLines(bool value);
    public bool get_GenerateProperties();
    public void set_GenerateProperties(bool value);
    public string GetClassBinaryCode(NetLanguage lang);
    public string GetClassSourceCode(NetLanguage lang);
    private void ValidateClass();
    internal abstract virtual void AddAttributesCode(AttributesBuilder attbs, NetLanguage lang);
    private void AddAttributesInternal(AttributesBuilder attbs);
    private static Byte[] Encrypt(Byte[] clearData, Byte[] key, Byte[] iv);
    private static string Encrypt(string clearText, string Password);
    private static Byte[] Decrypt(Byte[] cipherData, Byte[] key, Byte[] iv);
    private static string Decrypt(string cipherText, string password);
    public string get_CommentText();
    public void set_CommentText(string value);
    public NetVisibility get_Visibility();
    public void set_Visibility(NetVisibility value);
    public bool get_SealedClass();
    public void set_SealedClass(bool value);
    public string get_Namespace();
    public void set_Namespace(string value);
    internal static string GetVisibility(NetLanguage lang, NetVisibility visibility);
    private string GetSealed(NetLanguage lang);
    private void BeginNamespace(NetLanguage lang, StringBuilder sb);
    private void EndNamespace(NetLanguage lang, StringBuilder sb);
    public static ClassBuilder LoadFromXmlString(string xml);
    public static ClassBuilder LoadFromXml(XmlDocument document);
    public static ClassBuilder LoadFromXml(string filename);
    public string SaveToXmlString();
    public void SaveToXml(string filename);
    public void SaveToXml(Stream stream);
    public void SaveToXml(TextWriter writer);
    internal abstract virtual void WriteHeaderElement(XmlHelper writer);
    internal abstract virtual void WriteExtraElements(XmlHelper writer);
    internal abstract virtual void ReadClassElements(XmlDocument document);
    internal abstract virtual void ReadField(XmlNode node);
    public RecordConditionInfo get_RecordCondition();
    public IgnoreCommentInfo get_IgnoreCommentedLines();
    internal static string TypeToString(Type type);
}
[EditorBrowsableAttribute("1")]
public class FileHelpers.Dynamic.ConverterBuilder : object {
    private ConverterKind mKind;
    private string mTypeName;
    private string mArg1;
    private string mArg2;
    private string mArg3;
    public ConverterKind Kind { get; public set; }
    public string TypeName { get; public set; }
    public string Arg1 { get; public set; }
    public string Arg2 { get; public set; }
    public string Arg3 { get; public set; }
    public ConverterKind get_Kind();
    public void set_Kind(ConverterKind value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_Arg1();
    public void set_Arg1(string value);
    public string get_Arg2();
    public void set_Arg2(string value);
    public string get_Arg3();
    public void set_Arg3(string value);
    internal void WriteXml(XmlHelper writer);
    internal void LoadXml(XmlNode node);
    internal string GetConverterCode(NetLanguage lang);
}
public class FileHelpers.Dynamic.CsvClassBuilder : DelimitedClassBuilder {
    public CsvClassBuilder(string className, char delimiter, string sampleFile);
    public CsvClassBuilder(string className, char delimiter, int numberOfFields);
    public CsvClassBuilder(CsvOptions options);
    public virtual DelimitedFieldBuilder AddField(string fieldName, string fieldType);
    public virtual void AddFields(int number);
    public void AddFields(int number, string prefix);
    private static string RawReadFirstLines(string file, int lines);
}
public class FileHelpers.Dynamic.DelimitedClassBuilder : ClassBuilder {
    [DebuggerBrowsableAttribute("0")]
private string mDelimiter;
    public string Delimiter { get; public set; }
    public DelimitedFieldBuilder[] Fields { get; }
    public DelimitedFieldBuilder LastField { get; }
    public DelimitedClassBuilder(string className, string delimiter);
    public DelimitedClassBuilder(string className);
    public DelimitedClassBuilder(string className, string delimiter, DataTable dt);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public DelimitedFieldBuilder FieldByIndex(int index);
    public DelimitedFieldBuilder[] get_Fields();
    public virtual DelimitedFieldBuilder AddField(string fieldName, string fieldType);
    public DelimitedFieldBuilder AddField(string fieldName, Type fieldType);
    public virtual DelimitedFieldBuilder AddField(string fieldName);
    public DelimitedFieldBuilder AddField(DelimitedFieldBuilder field);
    public DelimitedFieldBuilder get_LastField();
    internal virtual void AddAttributesCode(AttributesBuilder attbs, NetLanguage lang);
    private static string GetDelimiter(string delimiter, NetLanguage lang);
    internal virtual void WriteHeaderElement(XmlHelper writer);
    internal virtual void WriteExtraElements(XmlHelper writer);
    internal static DelimitedClassBuilder LoadXmlInternal(XmlDocument document);
    internal virtual void ReadClassElements(XmlDocument document);
    internal virtual void ReadField(XmlNode node);
    public virtual void AddFields(int numberOfFields);
}
public class FileHelpers.Dynamic.DelimitedFieldBuilder : FieldBuilder {
    [DebuggerBrowsableAttribute("0")]
private bool mFieldQuoted;
    [DebuggerBrowsableAttribute("0")]
private char mQuoteChar;
    [DebuggerBrowsableAttribute("0")]
private QuoteMode mQuoteMode;
    [DebuggerBrowsableAttribute("0")]
private MultilineMode mQuoteMultiline;
    public bool FieldQuoted { get; public set; }
    public char QuoteChar { get; public set; }
    public QuoteMode QuoteMode { get; public set; }
    public MultilineMode QuoteMultiline { get; public set; }
    internal DelimitedFieldBuilder(string fieldName, string fieldType);
    internal DelimitedFieldBuilder(string fieldName, Type fieldType);
    public bool get_FieldQuoted();
    public void set_FieldQuoted(bool value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public QuoteMode get_QuoteMode();
    public void set_QuoteMode(QuoteMode value);
    public MultilineMode get_QuoteMultiline();
    public void set_QuoteMultiline(MultilineMode value);
    internal virtual void AddAttributesCode(AttributesBuilder attbs, NetLanguage lang);
    internal virtual void WriteHeaderAttributes(XmlHelper writer);
    internal virtual void WriteExtraElements(XmlHelper writer);
    internal virtual void ReadFieldInternal(XmlNode node);
}
public class FileHelpers.Dynamic.DynamicCompilationException : FileHelpersException {
    private string mSourceCode;
    private CompilerErrorCollection mCompilerErrors;
    public string SourceCode { get; }
    public CompilerErrorCollection CompilerErrors { get; }
    internal DynamicCompilationException(string message, string sourceCode, CompilerErrorCollection errors);
    public string get_SourceCode();
    public CompilerErrorCollection get_CompilerErrors();
}
[EditorBrowsableAttribute("1")]
public abstract class FileHelpers.Dynamic.FieldBuilder : object {
    [DebuggerBrowsableAttribute("0")]
private string mFieldName;
    [DebuggerBrowsableAttribute("0")]
private string mFieldType;
    [DebuggerBrowsableAttribute("0")]
private TrimMode mTrimMode;
    [DebuggerBrowsableAttribute("0")]
private string mTrimChars;
    [DebuggerBrowsableAttribute("0")]
internal int mFieldIndex;
    [DebuggerBrowsableAttribute("0")]
private bool mFieldInNewLine;
    [DebuggerBrowsableAttribute("0")]
private bool mFieldHidden;
    [DebuggerBrowsableAttribute("0")]
private bool mFieldValueDiscarded;
    [DebuggerBrowsableAttribute("0")]
private bool mFieldOptional;
    [DebuggerBrowsableAttribute("0")]
private object mFieldNullValue;
    [DebuggerBrowsableAttribute("0")]
private bool mFieldNotEmpty;
    [DebuggerBrowsableAttribute("0")]
private ConverterBuilder mConverter;
    [DebuggerBrowsableAttribute("0")]
internal ClassBuilder mClassBuilder;
    [DebuggerBrowsableAttribute("0")]
private NetVisibility mVisibility;
    public TrimMode TrimMode { get; public set; }
    public string TrimChars { get; public set; }
    public int FieldIndex { get; }
    public bool FieldInNewLine { get; public set; }
    public bool FieldHidden { get; public set; }
    public bool FieldValueDiscarded { get; public set; }
    public bool FieldOptional { get; public set; }
    public ConverterBuilder Converter { get; }
    public string FieldName { get; public set; }
    public string FieldType { get; public set; }
    public object FieldNullValue { get; public set; }
    public bool FieldNotEmpty { get; public set; }
    public NetVisibility Visibility { get; public set; }
    internal FieldBuilder(string fieldName, Type fieldType);
    internal FieldBuilder(string fieldName, string fieldType);
    public TrimMode get_TrimMode();
    public void set_TrimMode(TrimMode value);
    public string get_TrimChars();
    public void set_TrimChars(string value);
    public int get_FieldIndex();
    public bool get_FieldInNewLine();
    public void set_FieldInNewLine(bool value);
    public bool get_FieldHidden();
    public void set_FieldHidden(bool value);
    public bool get_FieldValueDiscarded();
    public void set_FieldValueDiscarded(bool value);
    public bool get_FieldOptional();
    public void set_FieldOptional(bool value);
    public ConverterBuilder get_Converter();
    public string get_FieldName();
    public void set_FieldName(string value);
    public string get_FieldType();
    public void set_FieldType(string value);
    public object get_FieldNullValue();
    public void set_FieldNullValue(object value);
    public bool get_FieldNotEmpty();
    public void set_FieldNotEmpty(bool value);
    internal string GetFieldCode(NetLanguage lang);
    internal abstract virtual void AddAttributesCode(AttributesBuilder attbs, NetLanguage lang);
    private void AddAttributesInternal(AttributesBuilder attbs, NetLanguage lang);
    public NetVisibility get_Visibility();
    public void set_Visibility(NetVisibility value);
    internal void SaveToXml(XmlHelper writer);
    internal abstract virtual void WriteHeaderAttributes(XmlHelper writer);
    internal abstract virtual void WriteExtraElements(XmlHelper writer);
    internal void ReadField(XmlNode node);
    internal abstract virtual void ReadFieldInternal(XmlNode node);
}
public class FileHelpers.Dynamic.FixedFieldBuilder : FieldBuilder {
    [DebuggerBrowsableAttribute("0")]
private int mFieldLength;
    [DebuggerBrowsableAttribute("0")]
private AlignMode mAlignMode;
    [DebuggerBrowsableAttribute("0")]
private char mAlignChar;
    public int FieldLength { get; public set; }
    public AlignMode AlignMode { get; public set; }
    public char AlignChar { get; public set; }
    internal FixedFieldBuilder(string fieldName, int length, Type fieldType);
    internal FixedFieldBuilder(string fieldName, int length, string fieldType);
    public int get_FieldLength();
    public void set_FieldLength(int value);
    public AlignMode get_AlignMode();
    public void set_AlignMode(AlignMode value);
    public char get_AlignChar();
    public void set_AlignChar(char value);
    internal virtual void AddAttributesCode(AttributesBuilder attbs, NetLanguage lang);
    internal virtual void WriteHeaderAttributes(XmlHelper writer);
    internal virtual void WriteExtraElements(XmlHelper writer);
    internal virtual void ReadFieldInternal(XmlNode node);
}
public class FileHelpers.Dynamic.FixedLengthClassBuilder : ClassBuilder {
    [DebuggerBrowsableAttribute("0")]
private FixedMode mFixedMode;
    public FixedFieldBuilder[] Fields { get; }
    public FixedFieldBuilder LastField { get; }
    public FixedMode FixedMode { get; public set; }
    public FixedLengthClassBuilder(string className);
    public FixedLengthClassBuilder(string className, Int32[] lengths);
    public FixedLengthClassBuilder(string className, DataTable dt, int defaultLength);
    public FixedLengthClassBuilder(string className, FixedMode mode);
    public FixedFieldBuilder FieldByIndex(int index);
    public FixedFieldBuilder[] get_Fields();
    public FixedFieldBuilder AddField(string fieldName, int length, string fieldType);
    public FixedFieldBuilder AddField(string fieldName, int length, Type fieldType);
    public FixedFieldBuilder AddField(FixedFieldBuilder field);
    public FixedFieldBuilder get_LastField();
    internal virtual void AddAttributesCode(AttributesBuilder attbs, NetLanguage lang);
    internal virtual void WriteHeaderElement(XmlHelper writer);
    internal virtual void WriteExtraElements(XmlHelper writer);
    public void SetFieldsLength(Int32[] lengths);
    public FixedMode get_FixedMode();
    public void set_FixedMode(FixedMode value);
    internal virtual void ReadClassElements(XmlDocument document);
    internal virtual void ReadField(XmlNode node);
    internal static FixedLengthClassBuilder LoadXmlInternal(XmlDocument document);
}
internal static class FileHelpers.Dynamic.StringHelper : object {
    private static string ReplaceRecursive(string original, string oldValue, string newValue);
    internal static string ToValidIdentifier(string original);
}
internal static class FileHelpers.Dynamic.ValidIdentifierValidator : object {
    internal static bool ValidIdentifier(string id);
    internal static bool ValidIdentifier(string id, bool isType);
}
internal class FileHelpers.Dynamic.XmlHelper : object {
    internal XmlTextWriter Writer;
    internal XmlTextReader Reader;
    public void BeginWriteFile(string filename);
    public void BeginWriteStream(TextWriter writer);
    public void BeginReadFile(string filename);
    public void WriteElement(string element, string valueStr);
    public void WriteElement(string element, string valueStr, string defaultVal);
    public void WriteElement(string element, bool mustWrite);
    public void WriteAttribute(string attb, string valueStr, string defaultVal);
    public void WriteAttribute(string attb, string valueStr);
    public void EndWrite();
    public void EndRead();
    public void ReadToNextElement();
    public sealed virtual void Dispose();
}
[EditorBrowsableAttribute("1")]
public abstract class FileHelpers.EngineBase : object {
    internal static int DefaultReadBufferSize;
    internal static int DefaultWriteBufferSize;
    [CompilerGeneratedAttribute]
private IRecordInfo <RecordInfo>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
internal int mLineNumber;
    [DebuggerBrowsableAttribute("0")]
internal int mTotalRecords;
    [DebuggerBrowsableAttribute("0")]
private Type mRecordType;
    [CompilerGeneratedAttribute]
private string <HeaderText>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
protected string mFooterText;
    [DebuggerBrowsableAttribute("0")]
protected Encoding mEncoding;
    [DebuggerBrowsableAttribute("0")]
private string mNewLineForWrite;
    [DebuggerBrowsableAttribute("0")]
protected ErrorManager mErrorManager;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProgressEventArgs> Progress;
    [CompilerGeneratedAttribute]
private RecordOptions <Options>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
internal IRecordInfo RecordInfo { get; }
    public int LineNumber { get; }
    public int TotalRecords { get; }
    public Type RecordType { get; }
    public string HeaderText { get; public set; }
    public string FooterText { get; public set; }
    public Encoding Encoding { get; public set; }
    public string NewLineForWrite { get; public set; }
    public ErrorManager ErrorManager { get; }
    public ErrorMode ErrorMode { get; public set; }
    protected bool MustNotifyProgress { get; }
    public RecordOptions Options { get; private set; }
    internal EngineBase(Type recordType);
    internal EngineBase(Type recordType, Encoding encoding);
    internal EngineBase(RecordInfo ri);
    [CompilerGeneratedAttribute]
internal IRecordInfo get_RecordInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_TotalRecords();
    public string GetFileHeader();
    public sealed virtual Type get_RecordType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_HeaderText();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HeaderText(string value);
    public sealed virtual string get_FooterText();
    public sealed virtual void set_FooterText(string value);
    internal void WriteFooter(TextWriter writer);
    public sealed virtual Encoding get_Encoding();
    public sealed virtual void set_Encoding(Encoding value);
    public sealed virtual string get_NewLineForWrite();
    public sealed virtual void set_NewLineForWrite(string value);
    public sealed virtual ErrorManager get_ErrorManager();
    public sealed virtual ErrorMode get_ErrorMode();
    public sealed virtual void set_ErrorMode(ErrorMode value);
    internal void ResetFields();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Progress(EventHandler`1<ProgressEventArgs> value);
    protected bool get_MustNotifyProgress();
    protected void OnProgress(ProgressEventArgs e);
    private void CreateRecordOptions();
    internal static RecordOptions CreateRecordOptionsCore(IRecordInfo info);
    [CompilerGeneratedAttribute]
public sealed virtual RecordOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(RecordOptions value);
    internal void WriteHeader(TextWriter textWriter);
}
internal static class FileHelpers.Engines.StreamHelper : object {
    internal static TextWriter CreateFileAppender(string fileName, Encoding encode, bool correctEnd, bool disposeStream, int bufferSize);
}
internal class FileHelpers.EnumConverter : ConverterBase {
    private Type mEnumType;
    private EnumFormat mFormat;
    public EnumConverter(Type sourceEnum, EnumFormat format);
    public EnumConverter(Type sourceEnum, string format);
    public virtual object StringToField(string from);
    public virtual string FieldToString(object from);
    private static EnumFormat GetEnumFormat(string format);
}
public enum FileHelpers.Enums.OverflowMode : Enum {
    public int value__;
    public static OverflowMode DiscardEnd;
    public static OverflowMode Error;
}
[DelimitedRecordAttribute("|", "")]
[IgnoreFirstAttribute("2")]
[DebuggerDisplayAttribute("Line: {LineNumber}. Error: {ExceptionInfo.Message}.")]
public class FileHelpers.ErrorInfo : object {
    [DebuggerBrowsableAttribute("0")]
internal int mLineNumber;
    [DebuggerBrowsableAttribute("0")]
[FieldQuotedAttribute("3")]
internal string mRecordString;
    [DebuggerBrowsableAttribute("0")]
[FieldQuotedAttribute("3")]
internal string mRecordTypeName;
    [DebuggerBrowsableAttribute("0")]
[FieldConverterAttribute("FileHelpers.ErrorInfo/ExceptionConverter")]
[FieldQuotedAttribute("3")]
internal Exception mExceptionInfo;
    public int LineNumber { get; }
    public string RecordString { get; }
    public string RecordTypeName { get; }
    public Exception ExceptionInfo { get; }
    public int get_LineNumber();
    public string get_RecordString();
    public string get_RecordTypeName();
    public Exception get_ExceptionInfo();
}
[DebuggerDisplayAttribute("{ErrorsDescription()}. ErrorMode: {ErrorMode.ToString()}")]
public class FileHelpers.ErrorManager : object {
    [CompilerGeneratedAttribute]
private int <ErrorLimit>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private List`1<ErrorInfo> mErrorsArray;
    [CompilerGeneratedAttribute]
private ErrorMode <ErrorMode>k__BackingField;
    public int ErrorLimit { get; public set; }
    [DebuggerBrowsableAttribute("3")]
public ErrorInfo[] Errors { get; }
    public ErrorMode ErrorMode { get; public set; }
    public int ErrorCount { get; }
    public bool HasErrors { get; }
    public ErrorManager(ErrorMode mode);
    [CompilerGeneratedAttribute]
public int get_ErrorLimit();
    [CompilerGeneratedAttribute]
public void set_ErrorLimit(int value);
    private string ErrorsDescription();
    public ErrorInfo[] get_Errors();
    [CompilerGeneratedAttribute]
public ErrorMode get_ErrorMode();
    [CompilerGeneratedAttribute]
public void set_ErrorMode(ErrorMode value);
    public int get_ErrorCount();
    public bool get_HasErrors();
    public void ClearErrors();
    internal void AddError(ErrorInfo error);
    internal void AddErrors(ErrorManager errors);
    public void SaveErrors(string fileName);
    public void SaveErrors(string fileName, string header);
    public static ErrorInfo[] LoadErrors(string fileName);
    public sealed virtual IEnumerator GetEnumerator();
}
public enum FileHelpers.ErrorMode : Enum {
    public int value__;
    public static ErrorMode ThrowException;
    public static ErrorMode SaveAndContinue;
    public static ErrorMode IgnoreAndContinue;
}
[EditorBrowsableAttribute("1")]
public abstract class FileHelpers.EventEngineBase`1 : EngineBase {
    [CompilerGeneratedAttribute]
private BeforeReadHandler`1<T> BeforeReadRecord;
    [CompilerGeneratedAttribute]
private AfterReadHandler`1<T> AfterReadRecord;
    [CompilerGeneratedAttribute]
private BeforeWriteHandler`1<T> BeforeWriteRecord;
    [CompilerGeneratedAttribute]
private AfterWriteHandler`1<T> AfterWriteRecord;
    [ObsoleteAttribute("Caution: It checks the property RecordInfo, which might not be updated in a multi record scenario.")]
protected bool MustNotifyRead { get; }
    [ObsoleteAttribute("Caution: It checks the property RecordInfo, which might not be updated in a multi record scenario.")]
protected bool MustNotifyWrite { get; }
    protected EventEngineBase`1(Type recordType);
    protected EventEngineBase`1(Type recordType, Encoding encoding);
    internal EventEngineBase`1(RecordInfo ri);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeReadRecord(BeforeReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeReadRecord(BeforeReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AfterReadRecord(AfterReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AfterReadRecord(AfterReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeWriteRecord(BeforeWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeWriteRecord(BeforeWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AfterWriteRecord(AfterWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AfterWriteRecord(AfterWriteHandler`1<T> value);
    protected bool get_MustNotifyRead();
    protected bool get_MustNotifyWrite();
    private bool MustNotifyWriteForRecord(IRecordInfo rec);
    internal bool MustNotifyReadForRecord(IRecordInfo rec);
    protected bool OnBeforeReadRecord(BeforeReadEventArgs`1<T> e);
    protected bool OnAfterReadRecord(string line, T record, bool lineChanged, int lineNumber);
    protected bool OnBeforeWriteRecord(T record, int lineNumber);
    protected string OnAfterWriteRecord(string line, T record);
    internal void WriteRecord(T record, int recordIndex, int totalRecord, TextWriter textWriter, IRecordInfo info);
    internal object ReadRecord(IRecordInfo recordInfo, int currentRecord, LineInfo line);
}
public class FileHelpers.Events.AfterReadEventArgs : ReadEventArgs {
    internal AfterReadEventArgs(EngineBase engine, string line, bool lineChanged, int lineNumber);
}
public class FileHelpers.Events.AfterReadEventArgs`1 : AfterReadEventArgs {
    [CompilerGeneratedAttribute]
private T <Record>k__BackingField;
    public T Record { get; public set; }
    internal AfterReadEventArgs`1(EventEngineBase`1<T> engine, string line, bool lineChanged, T newRecord, int lineNumber);
    [CompilerGeneratedAttribute]
public T get_Record();
    [CompilerGeneratedAttribute]
public void set_Record(T value);
}
public class FileHelpers.Events.AfterReadHandler`1 : MulticastDelegate {
    public AfterReadHandler`1(object object, IntPtr method);
    public virtual void Invoke(EngineBase engine, AfterReadEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(EngineBase engine, AfterReadEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class FileHelpers.Events.AfterWriteEventArgs : WriteEventArgs {
    [CompilerGeneratedAttribute]
private string <RecordLine>k__BackingField;
    public string RecordLine { get; public set; }
    internal AfterWriteEventArgs(EngineBase engine, int lineNumber, string line);
    [CompilerGeneratedAttribute]
public string get_RecordLine();
    [CompilerGeneratedAttribute]
public void set_RecordLine(string value);
}
public class FileHelpers.Events.AfterWriteEventArgs`1 : AfterWriteEventArgs {
    [CompilerGeneratedAttribute]
private T <Record>k__BackingField;
    public T Record { get; private set; }
    internal AfterWriteEventArgs`1(EngineBase engine, T record, int lineNumber, string line);
    [CompilerGeneratedAttribute]
public T get_Record();
    [CompilerGeneratedAttribute]
private void set_Record(T value);
}
public class FileHelpers.Events.AfterWriteHandler`1 : MulticastDelegate {
    public AfterWriteHandler`1(object object, IntPtr method);
    public virtual void Invoke(EngineBase engine, AfterWriteEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(EngineBase engine, AfterWriteEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class FileHelpers.Events.BeforeReadEventArgs : ReadEventArgs {
    internal BeforeReadEventArgs(EngineBase engine, string line, int lineNumber);
}
public class FileHelpers.Events.BeforeReadEventArgs`1 : BeforeReadEventArgs {
    [CompilerGeneratedAttribute]
private T <Record>k__BackingField;
    public T Record { get; private set; }
    internal BeforeReadEventArgs`1(EngineBase engine, T record, string line, int lineNumber);
    [CompilerGeneratedAttribute]
public T get_Record();
    [CompilerGeneratedAttribute]
private void set_Record(T value);
}
public class FileHelpers.Events.BeforeReadHandler`1 : MulticastDelegate {
    public BeforeReadHandler`1(object object, IntPtr method);
    public virtual void Invoke(EngineBase engine, BeforeReadEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(EngineBase engine, BeforeReadEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class FileHelpers.Events.BeforeWriteEventArgs : WriteEventArgs {
    [CompilerGeneratedAttribute]
private bool <SkipThisRecord>k__BackingField;
    public bool SkipThisRecord { get; public set; }
    internal BeforeWriteEventArgs(EngineBase engine, int lineNumber);
    [CompilerGeneratedAttribute]
public bool get_SkipThisRecord();
    [CompilerGeneratedAttribute]
public void set_SkipThisRecord(bool value);
}
public class FileHelpers.Events.BeforeWriteEventArgs`1 : BeforeWriteEventArgs {
    [CompilerGeneratedAttribute]
private T <Record>k__BackingField;
    public T Record { get; private set; }
    internal BeforeWriteEventArgs`1(EngineBase engine, T record, int lineNumber);
    [CompilerGeneratedAttribute]
public T get_Record();
    [CompilerGeneratedAttribute]
private void set_Record(T value);
}
public class FileHelpers.Events.BeforeWriteHandler`1 : MulticastDelegate {
    public BeforeWriteHandler`1(object object, IntPtr method);
    public virtual void Invoke(EngineBase engine, BeforeWriteEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(EngineBase engine, BeforeWriteEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class FileHelpers.Events.FileHelpersEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EngineBase <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    public EngineBase Engine { get; public set; }
    public int LineNumber { get; private set; }
    protected FileHelpersEventArgs(EngineBase engine, int lineNumber);
    [CompilerGeneratedAttribute]
public EngineBase get_Engine();
    [CompilerGeneratedAttribute]
public void set_Engine(EngineBase value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
}
public interface FileHelpers.Events.INotifyRead {
    public abstract virtual void BeforeRead(BeforeReadEventArgs e);
    public abstract virtual void AfterRead(AfterReadEventArgs e);
}
public interface FileHelpers.Events.INotifyWrite {
    public abstract virtual void BeforeWrite(BeforeWriteEventArgs e);
    public abstract virtual void AfterWrite(AfterWriteEventArgs e);
}
public class FileHelpers.Events.ProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private double <Percent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalRecords>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalBytes>k__BackingField;
    public double Percent { get; private set; }
    public int CurrentRecord { get; private set; }
    public int TotalRecords { get; private set; }
    public long CurrentBytes { get; private set; }
    public long TotalBytes { get; private set; }
    public ProgressEventArgs(int currentRecord, int totalRecords);
    public ProgressEventArgs(int currentRecord, int totalRecords, long currentBytes, long totalBytes);
    [CompilerGeneratedAttribute]
public double get_Percent();
    [CompilerGeneratedAttribute]
private void set_Percent(double value);
    [CompilerGeneratedAttribute]
public int get_CurrentRecord();
    [CompilerGeneratedAttribute]
private void set_CurrentRecord(int value);
    [CompilerGeneratedAttribute]
public int get_TotalRecords();
    [CompilerGeneratedAttribute]
private void set_TotalRecords(int value);
    [CompilerGeneratedAttribute]
public long get_CurrentBytes();
    [CompilerGeneratedAttribute]
private void set_CurrentBytes(long value);
    [CompilerGeneratedAttribute]
public long get_TotalBytes();
    [CompilerGeneratedAttribute]
private void set_TotalBytes(long value);
}
[EditorBrowsableAttribute("1")]
public abstract class FileHelpers.Events.ReadEventArgs : FileHelpersEventArgs {
    private string mRecordLine;
    [CompilerGeneratedAttribute]
private bool <RecordLineChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipThisRecord>k__BackingField;
    public string RecordLine { get; public set; }
    public bool RecordLineChanged { get; protected set; }
    public bool SkipThisRecord { get; public set; }
    internal ReadEventArgs(EngineBase engine, string line, int lineNumber);
    public string get_RecordLine();
    public void set_RecordLine(string value);
    [CompilerGeneratedAttribute]
public bool get_RecordLineChanged();
    [CompilerGeneratedAttribute]
protected void set_RecordLineChanged(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipThisRecord();
    [CompilerGeneratedAttribute]
public void set_SkipThisRecord(bool value);
}
[EditorBrowsableAttribute("1")]
public abstract class FileHelpers.Events.WriteEventArgs : FileHelpersEventArgs {
    internal WriteEventArgs(EngineBase engine, int lineNumber);
}
[ExtensionAttribute]
public static class FileHelpers.ExtensionsFileHelpers : object {
    [ExtensionAttribute]
public static DataTable ToDataTable(T[] records);
}
[DebuggerDisplayAttribute("{ExtractedString()} [{ExtractedFrom}-{ExtractedTo}]")]
internal class FileHelpers.ExtractedInfo : ValueType {
    internal string mCustomExtractedString;
    private LineInfo mLine;
    public int ExtractedFrom;
    public int ExtractedTo;
    internal static ExtractedInfo Empty;
    public ExtractedInfo(LineInfo line);
    public ExtractedInfo(LineInfo line, int extractTo);
    public ExtractedInfo(string customExtract);
    private static ExtractedInfo();
    public string ExtractedString();
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldAlignAttribute : Attribute {
    [CompilerGeneratedAttribute]
private AlignMode <Align>k__BackingField;
    [CompilerGeneratedAttribute]
private char <AlignChar>k__BackingField;
    public AlignMode Align { get; private set; }
    public char AlignChar { get; private set; }
    public FieldAlignAttribute(AlignMode align);
    public FieldAlignAttribute(AlignMode align, char alignChar);
    [CompilerGeneratedAttribute]
public AlignMode get_Align();
    [CompilerGeneratedAttribute]
private void set_Align(AlignMode value);
    [CompilerGeneratedAttribute]
public char get_AlignChar();
    [CompilerGeneratedAttribute]
private void set_AlignChar(char value);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldArrayLengthAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public int MinLength { get; private set; }
    public int MaxLength { get; private set; }
    public FieldArrayLengthAttribute(int minLength, int maxLength);
    public FieldArrayLengthAttribute(int length);
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
private void set_MinLength(int value);
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    [CompilerGeneratedAttribute]
private void set_MaxLength(int value);
}
[AttributeUsageAttribute("256")]
[EditorBrowsableAttribute("1")]
public abstract class FileHelpers.FieldAttribute : Attribute {
}
public abstract class FileHelpers.FieldBase : object {
    [CompilerGeneratedAttribute]
private Type <FieldType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConverterBase <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <FieldTypeInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArrayMinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArrayMaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ArrayType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Discarded>k__BackingField;
    [CompilerGeneratedAttribute]
private object <NullValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStringField>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldInfo <FieldInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private TrimMode <TrimMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <TrimChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FieldOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullableType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldFriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNotEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldCaption>k__BackingField;
    [CompilerGeneratedAttribute]
private RecordOptions <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParentIndex>k__BackingField;
    public Type FieldType { get; private set; }
    public ConverterBase Converter { get; private set; }
    internal int CharsToDiscard { get; }
    internal Type FieldTypeInternal { get; private set; }
    public bool IsArray { get; private set; }
    public int ArrayMinLength { get; public set; }
    public int ArrayMaxLength { get; public set; }
    private Type ArrayType { get; private set; }
    public bool Discarded { get; public set; }
    internal object NullValue { get; private set; }
    private bool IsStringField { get; private set; }
    internal FieldInfo FieldInfo { get; private set; }
    public TrimMode TrimMode { get; public set; }
    internal Char[] TrimChars { get; internal set; }
    public bool IsOptional { get; public set; }
    internal bool NextIsOptional { get; }
    internal bool IsFirst { get; }
    internal bool IsLast { get; }
    internal bool InNewLine { get; private set; }
    internal Nullable`1<int> FieldOrder { get; private set; }
    internal bool IsNullableType { get; private set; }
    internal string FieldFriendlyName { get; private set; }
    public bool IsNotEmpty { get; public set; }
    internal string FieldCaption { get; private set; }
    internal string FieldName { get; }
    private RecordOptions Parent { get; internal set; }
    private int ParentIndex { get; internal set; }
    internal FieldBase(FieldInfo fi, string defaultCultureName);
    [CompilerGeneratedAttribute]
public Type get_FieldType();
    [CompilerGeneratedAttribute]
private void set_FieldType(Type value);
    [CompilerGeneratedAttribute]
public ConverterBase get_Converter();
    [CompilerGeneratedAttribute]
private void set_Converter(ConverterBase value);
    internal virtual int get_CharsToDiscard();
    [CompilerGeneratedAttribute]
internal Type get_FieldTypeInternal();
    [CompilerGeneratedAttribute]
private void set_FieldTypeInternal(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
private void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public int get_ArrayMinLength();
    [CompilerGeneratedAttribute]
public void set_ArrayMinLength(int value);
    [CompilerGeneratedAttribute]
public int get_ArrayMaxLength();
    [CompilerGeneratedAttribute]
public void set_ArrayMaxLength(int value);
    [CompilerGeneratedAttribute]
private Type get_ArrayType();
    [CompilerGeneratedAttribute]
private void set_ArrayType(Type value);
    [CompilerGeneratedAttribute]
public bool get_Discarded();
    [CompilerGeneratedAttribute]
public void set_Discarded(bool value);
    [CompilerGeneratedAttribute]
internal object get_NullValue();
    [CompilerGeneratedAttribute]
private void set_NullValue(object value);
    [CompilerGeneratedAttribute]
private bool get_IsStringField();
    [CompilerGeneratedAttribute]
private void set_IsStringField(bool value);
    [CompilerGeneratedAttribute]
internal FieldInfo get_FieldInfo();
    [CompilerGeneratedAttribute]
private void set_FieldInfo(FieldInfo value);
    [CompilerGeneratedAttribute]
public TrimMode get_TrimMode();
    [CompilerGeneratedAttribute]
public void set_TrimMode(TrimMode value);
    [CompilerGeneratedAttribute]
internal Char[] get_TrimChars();
    [CompilerGeneratedAttribute]
internal void set_TrimChars(Char[] value);
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
    internal bool get_NextIsOptional();
    internal bool get_IsFirst();
    internal bool get_IsLast();
    [CompilerGeneratedAttribute]
internal bool get_InNewLine();
    [CompilerGeneratedAttribute]
private void set_InNewLine(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_FieldOrder();
    [CompilerGeneratedAttribute]
private void set_FieldOrder(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal bool get_IsNullableType();
    [CompilerGeneratedAttribute]
private void set_IsNullableType(bool value);
    [CompilerGeneratedAttribute]
internal string get_FieldFriendlyName();
    [CompilerGeneratedAttribute]
private void set_FieldFriendlyName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsNotEmpty();
    [CompilerGeneratedAttribute]
public void set_IsNotEmpty(bool value);
    [CompilerGeneratedAttribute]
internal string get_FieldCaption();
    [CompilerGeneratedAttribute]
private void set_FieldCaption(string value);
    internal string get_FieldName();
    public static FieldBase CreateField(FieldInfo fi, TypedRecordAttribute recordAttribute);
    [CompilerGeneratedAttribute]
private RecordOptions get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(RecordOptions value);
    [CompilerGeneratedAttribute]
private int get_ParentIndex();
    [CompilerGeneratedAttribute]
internal void set_ParentIndex(int value);
    internal static string AutoPropertyName(FieldInfo fi);
    internal abstract virtual ExtractedInfo ExtractFieldString(LineInfo line);
    private void CreateFieldString(StringBuilder sb, object fieldValue, bool isLast);
    protected abstract virtual void CreateFieldString(StringBuilder sb, string field, bool isLast);
    private string ConvertToString(object fieldValue);
    internal object ExtractFieldValue(LineInfo line);
    private AssignResult AssignFromString(ExtractedInfo fieldString, LineInfo line);
    private string TrimString(string extractedString);
    private object GetNullValue(LineInfo line);
    private object GetDiscardedNullValue();
    public object CreateValueForField(object fieldValue);
    internal void AssignToString(StringBuilder sb, object fieldValue);
    internal FieldBase Clone();
    protected abstract virtual FieldBase CreateClone();
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldCaptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Caption>k__BackingField;
    public string Caption { get; private set; }
    public FieldCaptionAttribute(string caption);
    [CompilerGeneratedAttribute]
public string get_Caption();
    [CompilerGeneratedAttribute]
private void set_Caption(string value);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldConverterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ConverterBase <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private ConverterKind <Kind>k__BackingField;
    public ConverterBase Converter { get; private set; }
    public ConverterKind Kind { get; private set; }
    public FieldConverterAttribute(ConverterKind converter);
    public FieldConverterAttribute(ConverterKind converter, string arg1);
    public FieldConverterAttribute(ConverterKind converter, string arg1, string arg2);
    public FieldConverterAttribute(ConverterKind converter, string arg1, string arg2, string arg3);
    private FieldConverterAttribute(ConverterKind converter, String[] args);
    public FieldConverterAttribute(Type customConverter, string arg1);
    public FieldConverterAttribute(Type customConverter, string arg1, string arg2);
    public FieldConverterAttribute(Type customConverter, string arg1, string arg2, string arg3);
    public FieldConverterAttribute(Type customConverter, Object[] args);
    public FieldConverterAttribute(Type customConverter);
    [CompilerGeneratedAttribute]
public ConverterBase get_Converter();
    [CompilerGeneratedAttribute]
private void set_Converter(ConverterBase value);
    [CompilerGeneratedAttribute]
public ConverterKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(ConverterKind value);
    private void CreateConverter(Type convType, Object[] args);
    private static Type[] ArgsToTypes(Object[] args);
    private static string ArgsDesc(Object[] args);
    private static string DisplayType(object o);
    internal void ValidateTypes(FieldInfo fi);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldDelimiterAttribute : FieldAttribute {
    [CompilerGeneratedAttribute]
private string <Delimiter>k__BackingField;
    public string Delimiter { get; private set; }
    public FieldDelimiterAttribute(string separator);
    [CompilerGeneratedAttribute]
public string get_Delimiter();
    [CompilerGeneratedAttribute]
private void set_Delimiter(string value);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldFixedLengthAttribute : FieldAttribute {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private OverflowMode <OverflowMode>k__BackingField;
    public int Length { get; private set; }
    public OverflowMode OverflowMode { get; public set; }
    public FieldFixedLengthAttribute(int length);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
public OverflowMode get_OverflowMode();
    [CompilerGeneratedAttribute]
public void set_OverflowMode(OverflowMode value);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldHiddenAttribute : FieldAttribute {
}
[AttributeUsageAttribute("256")]
[ObsoleteAttribute("You must use [FieldHidden] instead", "False")]
[EditorBrowsableAttribute("1")]
public class FileHelpers.FieldIgnoredAttribute : FieldAttribute {
}
internal class FileHelpers.FieldInfoCacheManipulator : object {
    private static PropertyInfo mCacheProperty;
    public static void ResetFieldInfoCache(Type type);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldInNewLineAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldNotEmptyAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
[ObsoleteAttribute("You must use [FieldHidden] instead", "False")]
[EditorBrowsableAttribute("1")]
public class FileHelpers.FieldNotInFileAttribute : FieldAttribute {
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldNullValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <NullValue>k__BackingField;
    public object NullValue { get; private set; }
    public FieldNullValueAttribute(object nullValue);
    public FieldNullValueAttribute(Type type, string nullValue);
    [CompilerGeneratedAttribute]
public object get_NullValue();
    [CompilerGeneratedAttribute]
private void set_NullValue(object value);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldOptionalAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; private set; }
    public FieldOrderAttribute(int order);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
private void set_Order(int value);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldQuotedAttribute : Attribute {
    [CompilerGeneratedAttribute]
private char <QuoteChar>k__BackingField;
    internal QuoteMode mQuoteMode;
    internal MultilineMode mQuoteMultiline;
    public char QuoteChar { get; private set; }
    public QuoteMode QuoteMode { get; internal set; }
    public MultilineMode QuoteMultiline { get; internal set; }
    public FieldQuotedAttribute(char quoteChar);
    public FieldQuotedAttribute(QuoteMode mode);
    public FieldQuotedAttribute(QuoteMode mode, MultilineMode multiline);
    public FieldQuotedAttribute(char quoteChar, QuoteMode mode);
    public FieldQuotedAttribute(char quoteChar, QuoteMode mode, MultilineMode multiline);
    public FieldQuotedAttribute(MultilineMode multiline);
    [CompilerGeneratedAttribute]
public char get_QuoteChar();
    [CompilerGeneratedAttribute]
private void set_QuoteChar(char value);
    public QuoteMode get_QuoteMode();
    internal void set_QuoteMode(QuoteMode value);
    public MultilineMode get_QuoteMultiline();
    internal void set_QuoteMultiline(MultilineMode value);
}
internal static class FileHelpers.Fields.TypeHelper : object {
    public static bool IsNumericType(Type type);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldTrimAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Char[] <TrimChars>k__BackingField;
    [CompilerGeneratedAttribute]
private TrimMode <TrimMode>k__BackingField;
    public Char[] TrimChars { get; private set; }
    public TrimMode TrimMode { get; private set; }
    public FieldTrimAttribute(TrimMode mode);
    public FieldTrimAttribute(TrimMode mode, Char[] chars);
    public FieldTrimAttribute(TrimMode mode, string trimChars);
    [CompilerGeneratedAttribute]
public Char[] get_TrimChars();
    [CompilerGeneratedAttribute]
private void set_TrimChars(Char[] value);
    [CompilerGeneratedAttribute]
public TrimMode get_TrimMode();
    [CompilerGeneratedAttribute]
private void set_TrimMode(TrimMode value);
}
[AttributeUsageAttribute("384")]
public class FileHelpers.FieldValueDiscardedAttribute : Attribute {
}
[DebuggerDisplayAttribute("FileDiffEngine for type: {RecordType.Name}. ErrorMode: {ErrorManager.ErrorMode.ToString()}. Encoding: {Encoding.EncodingName}")]
public class FileHelpers.FileDiffEngine`1 : EngineBase {
    public T[] OnlyNewRecords(string sourceFile, string newFile);
    public T[] OnlyMissingRecords(string sourceFile, string newFile);
    private FileHelperEngine`1<T> CreateEngineAndClearErrors();
    public T[] OnlyDuplicatedRecords(string file1, string file2);
    private static void ApplyDiffInBoth(T[] col1, T[] col2, List`1<T> arr);
    private static void ApplyDiffOnlyIn1(T[] col1, T[] col2, List`1<T> arr);
    private static void ApplyDiff(T[] col1, T[] col2, List`1<T> arr, bool addIfIn1);
    public T[] OnlyNoDuplicatedRecords(string file1, string file2);
    public T[] WriteNewRecords(string sourceFile, string newFile, string destFile);
}
public class FileHelpers.FileHelperAsyncEngine : FileHelperAsyncEngine`1<object> {
    public FileHelperAsyncEngine(Type recordType);
    public FileHelperAsyncEngine(Type recordType, Encoding encoding);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("FileHelperAsyncEngine for type: {RecordType.Name}. ErrorMode: {ErrorManager.ErrorMode.ToString()}. Encoding: {Encoding.EncodingName}")]
public class FileHelpers.FileHelperAsyncEngine`1 : EventEngineBase`1<T> {
    [DebuggerBrowsableAttribute("0")]
private ForwardReader mAsyncReader;
    [DebuggerBrowsableAttribute("0")]
private TextWriter mAsyncWriter;
    [DebuggerBrowsableAttribute("0")]
private T mLastRecord;
    private Object[] mLastRecordValues;
    private int mCurrentRecord;
    private StreamInfoProvider mStreamInfo;
    [CompilerGeneratedAttribute]
private EngineState<T> <State>k__BackingField;
    public T LastRecord { get; }
    public Object[] LastRecordValues { get; }
    public object Item { get; public set; }
    public object Item { get; public set; }
    private EngineState<T> State { get; private set; }
    protected FileHelperAsyncEngine`1(Type recordType);
    public FileHelperAsyncEngine`1(Encoding encoding);
    protected FileHelperAsyncEngine`1(Type recordType, Encoding encoding);
    public sealed virtual T get_LastRecord();
    public sealed virtual Object[] get_LastRecordValues();
    public object get_Item(int fieldIndex);
    public void set_Item(int fieldIndex, object value);
    public object get_Item(string fieldName);
    public void set_Item(string fieldName, object value);
    public sealed virtual IDisposable BeginReadStream(TextReader reader);
    public sealed virtual IDisposable BeginReadFile(string fileName);
    public IDisposable BeginReadFile(string fileName, int bufferSize);
    public sealed virtual IDisposable BeginReadString(string sourceData);
    public sealed virtual T ReadNext();
    private void ReadNextRecord();
    public sealed virtual T[] ReadToEnd();
    public sealed virtual T[] ReadNexts(int numberOfRecords);
    public sealed virtual void Flush();
    public sealed virtual void Close();
    public sealed virtual IDisposable BeginWriteStream(TextWriter writer);
    public sealed virtual IDisposable BeginWriteFile(string fileName);
    public IDisposable BeginWriteFile(string fileName, int bufferSize);
    public sealed virtual IDisposable BeginAppendToFile(string fileName);
    public IDisposable BeginAppendToFile(string fileName, int bufferSize);
    public sealed virtual void WriteNext(T record);
    public sealed virtual void WriteNexts(IEnumerable`1<T> records);
    public sealed virtual void WriteNextValues();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
private EngineState<T> get_State();
    [CompilerGeneratedAttribute]
private void set_State(EngineState<T> value);
}
public class FileHelpers.FileHelperEngine : FileHelperEngine`1<object> {
    public FileHelperEngine(Type recordType);
    public FileHelperEngine(Type recordType, Encoding encoding);
}
[DebuggerDisplayAttribute("FileHelperEngine for type: {RecordType.Name}. ErrorMode: {ErrorManager.ErrorMode.ToString()}. Encoding: {Encoding.EncodingName}")]
public class FileHelpers.FileHelperEngine`1 : EventEngineBase`1<T> {
    private bool mObjectEngine;
    public FileHelperEngine`1(Encoding encoding);
    protected FileHelperEngine`1(Type recordType, Encoding encoding);
    public sealed virtual T[] ReadFile(string fileName);
    public sealed virtual T[] ReadFile(string fileName, int maxRecords);
    public List`1<T> ReadFileAsList(string fileName);
    public List`1<T> ReadFileAsList(string fileName, int maxRecords);
    [EditorBrowsableAttribute("2")]
public sealed virtual T[] ReadStream(TextReader reader);
    [EditorBrowsableAttribute("2")]
public sealed virtual T[] ReadStream(TextReader reader, int maxRecords);
    private void ReadStream(TextReader reader, int maxRecords, DataTable dt);
    [EditorBrowsableAttribute("2")]
public List`1<T> ReadStreamAsList(TextReader reader, int maxRecords);
    private IList ReadStreamAsList(TextReader reader, int maxRecords, DataTable dt);
    public sealed virtual T[] ReadString(string source);
    public sealed virtual T[] ReadString(string source, int maxRecords);
    public List`1<T> ReadStringAsList(string source);
    public List`1<T> ReadStringAsList(string source, int maxRecords);
    public sealed virtual void WriteFile(string fileName, IEnumerable`1<T> records);
    public sealed virtual void WriteFile(string fileName, IEnumerable`1<T> records, int maxRecords);
    [EditorBrowsableAttribute("2")]
public sealed virtual void WriteStream(TextWriter writer, IEnumerable`1<T> records);
    [EditorBrowsableAttribute("2")]
public sealed virtual void WriteStream(TextWriter writer, IEnumerable`1<T> records, int maxRecords);
    public sealed virtual string WriteString(IEnumerable`1<T> records);
    public sealed virtual string WriteString(IEnumerable`1<T> records, int maxRecords);
    public sealed virtual void AppendToFile(string fileName, T record);
    public sealed virtual void AppendToFile(string fileName, IEnumerable`1<T> records);
    public sealed virtual DataTable ReadFileAsDT(string fileName);
    public sealed virtual DataTable ReadFileAsDT(string fileName, int maxRecords);
    public sealed virtual DataTable ReadStringAsDT(string source);
    public sealed virtual DataTable ReadStringAsDT(string source, int maxRecords);
    public sealed virtual DataTable ReadStreamAsDT(TextReader reader);
    public sealed virtual DataTable ReadStreamAsDT(TextReader reader, int maxRecords);
}
public class FileHelpers.FileHelpersException : Exception {
    public FileHelpersException(string message);
    public FileHelpersException(string message, Exception innerEx);
    public FileHelpersException(int line, int column, string message);
}
internal static class FileHelpers.FileTransformEngine.ExHelper : object {
    public static void CheckNullParam(string param, string paramName);
    public static void CheckNullParam(object param, string paramName);
    public static void CheckDifferentsParams(object param1, string param1Name, object param2, string param2Name);
}
[DebuggerDisplayAttribute("FileTransformanEngine for types: {SourceType.Name} --> {DestinationType.Name}. Source Encoding: {SourceEncoding.EncodingName}. Destination Encoding: {DestinationEncoding.EncodingName}")]
public class FileHelpers.FileTransformEngine`2 : object {
    [DebuggerBrowsableAttribute("0")]
private Encoding mSourceEncoding;
    [DebuggerBrowsableAttribute("0")]
private Encoding mDestinationEncoding;
    private ErrorMode mErrorMode;
    private ErrorManager mSourceErrorManager;
    private ErrorManager mDestinationErrorManager;
    public ErrorMode ErrorMode { get; public set; }
    public ErrorManager SourceErrorManager { get; }
    public ErrorManager DestinationErrorManager { get; }
    public Type SourceType { get; }
    public Type DestinationType { get; }
    public Encoding SourceEncoding { get; public set; }
    public Encoding DestinationEncoding { get; public set; }
    public ErrorMode get_ErrorMode();
    public void set_ErrorMode(ErrorMode value);
    public ErrorManager get_SourceErrorManager();
    public ErrorManager get_DestinationErrorManager();
    public TDestination[] TransformFile(string sourceFile, string destFile);
    public int TransformFileFast(string sourceFile, string destFile);
    public int TransformFileFast(TextReader sourceStream, string destFile);
    public int TransformFileFast(TextReader sourceStream, StreamWriter destStream);
    public int TransformFileFast(string sourceFile, StreamWriter destStream);
    public TDestination[] TransformRecords(TSource[] sourceRecords);
    public TDestination[] ReadAndTransformRecords(string sourceFile);
    private TDestination[] CoreTransform(InternalStreamReader sourceFile, StreamWriter destFile);
    private TDestination[] CoreTransformRecords(TSource[] sourceRecords);
    private TDestination[] CoreTransformFile(string sourceFile, string destFile);
    private int CoreTransformAsync(TextReader sourceFile, StreamWriter destFile);
    public Type get_SourceType();
    public Type get_DestinationType();
    public Encoding get_SourceEncoding();
    public void set_SourceEncoding(Encoding value);
    public Encoding get_DestinationEncoding();
    public void set_DestinationEncoding(Encoding value);
}
[DebuggerDisplayAttribute("FixedFileEngine for type: {RecordType.Name}. ErrorMode: {ErrorManager.ErrorMode.ToString()}. Encoding: {Encoding.EncodingName}")]
public class FileHelpers.FixedFileEngine : FileHelperEngine {
    public FixedRecordOptions Options { get; }
    public FixedFileEngine(Type recordType);
    public FixedFileEngine(Type recordType, Encoding encoding);
    public FixedRecordOptions get_Options();
}
[DebuggerDisplayAttribute("FixedFileEngine for type: {RecordType.Name}. ErrorMode: {ErrorManager.ErrorMode.ToString()}. Encoding: {Encoding.EncodingName}")]
public class FileHelpers.FixedFileEngine`1 : FileHelperEngine`1<T> {
    public FixedRecordOptions Options { get; }
    public FixedFileEngine`1(Encoding encoding);
    public FixedRecordOptions get_Options();
}
public class FileHelpers.FixedLengthField : FieldBase {
    [CompilerGeneratedAttribute]
private int <FieldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldAlignAttribute <Align>k__BackingField;
    [CompilerGeneratedAttribute]
private FixedMode <FixedMode>k__BackingField;
    [CompilerGeneratedAttribute]
private OverflowMode <OverflowMode>k__BackingField;
    internal int FieldLength { get; private set; }
    internal FieldAlignAttribute Align { get; private set; }
    internal FixedMode FixedMode { get; internal set; }
    private OverflowMode OverflowMode { get; private set; }
    internal FixedLengthField(FieldInfo fi, int length, OverflowMode overflowMode, FieldAlignAttribute align, string defaultCultureName);
    [CompilerGeneratedAttribute]
internal int get_FieldLength();
    [CompilerGeneratedAttribute]
private void set_FieldLength(int value);
    [CompilerGeneratedAttribute]
internal FieldAlignAttribute get_Align();
    [CompilerGeneratedAttribute]
private void set_Align(FieldAlignAttribute value);
    [CompilerGeneratedAttribute]
internal FixedMode get_FixedMode();
    [CompilerGeneratedAttribute]
internal void set_FixedMode(FixedMode value);
    [CompilerGeneratedAttribute]
private OverflowMode get_OverflowMode();
    [CompilerGeneratedAttribute]
private void set_OverflowMode(OverflowMode value);
    internal virtual ExtractedInfo ExtractFieldString(LineInfo line);
    protected virtual void CreateFieldString(StringBuilder sb, string field, bool isLast);
    private string GetActualValueBasedOnFieldConfiguration(string field);
    protected virtual FieldBase CreateClone();
}
[AttributeUsageAttribute("4")]
public class FileHelpers.FixedLengthRecordAttribute : TypedRecordAttribute {
    [CompilerGeneratedAttribute]
private FixedMode <FixedMode>k__BackingField;
    public FixedMode FixedMode { get; private set; }
    public FixedLengthRecordAttribute(FixedMode fixedMode, string defaultCultureName);
    [CompilerGeneratedAttribute]
public FixedMode get_FixedMode();
    [CompilerGeneratedAttribute]
private void set_FixedMode(FixedMode value);
}
public enum FileHelpers.FixedMode : Enum {
    public int value__;
    public static FixedMode ExactLength;
    public static FixedMode AllowMoreChars;
    public static FixedMode AllowLessChars;
    public static FixedMode AllowVariableLength;
}
internal class FileHelpers.ForwardReader : object {
    private IRecordReader mReader;
    private String[] mFowardStrings;
    private int mForwardIndex;
    private int mRemainingLines;
    private int mLineNumber;
    private bool mDiscardForward;
    private int mFowardLines;
    public int LineNumber { get; }
    public bool DiscardForward { get; public set; }
    public int FowardLines { get; }
    public string RemainingText { get; }
    internal ForwardReader(IRecordReader reader, int forwardLines);
    internal ForwardReader(IRecordReader reader, int forwardLines, int startLine);
    public int get_LineNumber();
    public bool get_DiscardForward();
    public void set_DiscardForward(bool value);
    public int get_FowardLines();
    public string ReadNextLine();
    public string get_RemainingText();
    public void Close();
    private sealed virtual override void System.IDisposable.Dispose();
}
public interface FileHelpers.IFileHelperAsyncEngine`1 {
    public T LastRecord { get; }
    public Object[] LastRecordValues { get; }
    public RecordOptions Options { get; }
    public int LineNumber { get; }
    public int TotalRecords { get; }
    public Type RecordType { get; }
    public string HeaderText { get; public set; }
    public string FooterText { get; public set; }
    public string NewLineForWrite { get; public set; }
    public Encoding Encoding { get; public set; }
    public ErrorManager ErrorManager { get; }
    public ErrorMode ErrorMode { get; public set; }
    public abstract virtual T get_LastRecord();
    public abstract virtual Object[] get_LastRecordValues();
    public abstract virtual RecordOptions get_Options();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_TotalRecords();
    public abstract virtual Type get_RecordType();
    public abstract virtual string get_HeaderText();
    public abstract virtual void set_HeaderText(string value);
    public abstract virtual string get_FooterText();
    public abstract virtual void set_FooterText(string value);
    public abstract virtual string get_NewLineForWrite();
    public abstract virtual void set_NewLineForWrite(string value);
    public abstract virtual Encoding get_Encoding();
    public abstract virtual void set_Encoding(Encoding value);
    public abstract virtual ErrorManager get_ErrorManager();
    public abstract virtual ErrorMode get_ErrorMode();
    public abstract virtual void set_ErrorMode(ErrorMode value);
    public abstract virtual IDisposable BeginReadStream(TextReader reader);
    public abstract virtual IDisposable BeginReadFile(string fileName);
    public abstract virtual IDisposable BeginReadString(string sourceData);
    public abstract virtual T ReadNext();
    public abstract virtual T[] ReadToEnd();
    public abstract virtual T[] ReadNexts(int numberOfRecords);
    public abstract virtual void Flush();
    public abstract virtual void Close();
    public abstract virtual IDisposable BeginWriteStream(TextWriter writer);
    public abstract virtual IDisposable BeginWriteFile(string fileName);
    public abstract virtual IDisposable BeginAppendToFile(string fileName);
    public abstract virtual void WriteNext(T record);
    public abstract virtual void WriteNexts(IEnumerable`1<T> records);
    public abstract virtual void WriteNextValues();
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeReadRecord(BeforeReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeReadRecord(BeforeReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterReadRecord(AfterReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterReadRecord(AfterReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeWriteRecord(BeforeWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeWriteRecord(BeforeWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterWriteRecord(AfterWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterWriteRecord(AfterWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Progress(EventHandler`1<ProgressEventArgs> value);
}
public interface FileHelpers.IFileHelperEngine`1 {
    public RecordOptions Options { get; }
    public int LineNumber { get; }
    public int TotalRecords { get; }
    public Type RecordType { get; }
    public string HeaderText { get; public set; }
    public string FooterText { get; public set; }
    public string NewLineForWrite { get; public set; }
    public Encoding Encoding { get; public set; }
    public ErrorManager ErrorManager { get; }
    public ErrorMode ErrorMode { get; public set; }
    public abstract virtual T[] ReadFile(string fileName);
    public abstract virtual T[] ReadFile(string fileName, int maxRecords);
    [EditorBrowsableAttribute("2")]
public abstract virtual T[] ReadStream(TextReader reader);
    [EditorBrowsableAttribute("2")]
public abstract virtual T[] ReadStream(TextReader reader, int maxRecords);
    public abstract virtual T[] ReadString(string source);
    public abstract virtual T[] ReadString(string source, int maxRecords);
    public abstract virtual void WriteFile(string fileName, IEnumerable`1<T> records);
    public abstract virtual void WriteFile(string fileName, IEnumerable`1<T> records, int maxRecords);
    [EditorBrowsableAttribute("2")]
public abstract virtual void WriteStream(TextWriter writer, IEnumerable`1<T> records);
    [EditorBrowsableAttribute("2")]
public abstract virtual void WriteStream(TextWriter writer, IEnumerable`1<T> records, int maxRecords);
    public abstract virtual string WriteString(IEnumerable`1<T> records);
    public abstract virtual string WriteString(IEnumerable`1<T> records, int maxRecords);
    public abstract virtual void AppendToFile(string fileName, T record);
    public abstract virtual void AppendToFile(string fileName, IEnumerable`1<T> records);
    public abstract virtual DataTable ReadFileAsDT(string fileName);
    public abstract virtual DataTable ReadFileAsDT(string fileName, int maxRecords);
    public abstract virtual DataTable ReadStringAsDT(string source);
    public abstract virtual DataTable ReadStringAsDT(string source, int maxRecords);
    public abstract virtual DataTable ReadStreamAsDT(TextReader reader);
    public abstract virtual DataTable ReadStreamAsDT(TextReader reader, int maxRecords);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeReadRecord(BeforeReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeReadRecord(BeforeReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterReadRecord(AfterReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterReadRecord(AfterReadHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeWriteRecord(BeforeWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeWriteRecord(BeforeWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterWriteRecord(AfterWriteHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterWriteRecord(AfterWriteHandler`1<T> value);
    public abstract virtual RecordOptions get_Options();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_TotalRecords();
    public abstract virtual Type get_RecordType();
    public abstract virtual string get_HeaderText();
    public abstract virtual void set_HeaderText(string value);
    public abstract virtual string get_FooterText();
    public abstract virtual void set_FooterText(string value);
    public abstract virtual string get_NewLineForWrite();
    public abstract virtual void set_NewLineForWrite(string value);
    public abstract virtual Encoding get_Encoding();
    public abstract virtual void set_Encoding(Encoding value);
    public abstract virtual ErrorManager get_ErrorManager();
    public abstract virtual ErrorMode get_ErrorMode();
    public abstract virtual void set_ErrorMode(ErrorMode value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Progress(EventHandler`1<ProgressEventArgs> value);
}
[AttributeUsageAttribute("4")]
[ObsoleteAttribute("This attribute will be removed in next version, use INotifyRead to provide custom filtering")]
public class FileHelpers.IgnoreCommentedLinesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CommentMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AnyPlace>k__BackingField;
    public string CommentMarker { get; private set; }
    public bool AnyPlace { get; private set; }
    public IgnoreCommentedLinesAttribute(string commentMarker);
    public IgnoreCommentedLinesAttribute(string commentMarker, bool anyPlace);
    [CompilerGeneratedAttribute]
public string get_CommentMarker();
    [CompilerGeneratedAttribute]
private void set_CommentMarker(string value);
    [CompilerGeneratedAttribute]
public bool get_AnyPlace();
    [CompilerGeneratedAttribute]
private void set_AnyPlace(bool value);
}
[AttributeUsageAttribute("4")]
public class FileHelpers.IgnoreEmptyLinesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IgnoreSpaces>k__BackingField;
    public bool IgnoreSpaces { get; private set; }
    public IgnoreEmptyLinesAttribute(bool ignoreSpaces);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSpaces();
    [CompilerGeneratedAttribute]
private void set_IgnoreSpaces(bool value);
}
[AttributeUsageAttribute("4")]
public class FileHelpers.IgnoreFirstAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <NumberOfLines>k__BackingField;
    public int NumberOfLines { get; private set; }
    public IgnoreFirstAttribute(int numberOfLines);
    [CompilerGeneratedAttribute]
public int get_NumberOfLines();
    [CompilerGeneratedAttribute]
private void set_NumberOfLines(int value);
}
[AttributeUsageAttribute("4")]
public class FileHelpers.IgnoreInheritedClassAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class FileHelpers.IgnoreLastAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <NumberOfLines>k__BackingField;
    public int NumberOfLines { get; private set; }
    public IgnoreLastAttribute(int numberOfLines);
    [CompilerGeneratedAttribute]
public int get_NumberOfLines();
    [CompilerGeneratedAttribute]
private void set_NumberOfLines(int value);
}
internal interface FileHelpers.IRecordInfo {
    public bool IsDelimited { get; }
    public int FieldCount { get; }
    public FieldBase[] Fields { get; }
    public int IgnoreFirst { get; public set; }
    public int IgnoreLast { get; public set; }
    public bool NotifyRead { get; }
    public bool NotifyWrite { get; }
    public int SizeHint { get; }
    public Type RecordType { get; }
    public bool IgnoreEmptyLines { get; public set; }
    public bool IgnoreEmptySpaces { get; }
    public string CommentMarker { get; public set; }
    public bool CommentAnyPlace { get; public set; }
    public RecordCondition RecordCondition { get; public set; }
    public Regex RecordConditionRegEx { get; }
    public string RecordConditionSelector { get; public set; }
    public RecordOperations Operations { get; }
    public abstract virtual bool get_IsDelimited();
    public abstract virtual int get_FieldCount();
    public abstract virtual FieldBase[] get_Fields();
    public abstract virtual int get_IgnoreFirst();
    public abstract virtual void set_IgnoreFirst(int value);
    public abstract virtual int get_IgnoreLast();
    public abstract virtual void set_IgnoreLast(int value);
    public abstract virtual bool get_NotifyRead();
    public abstract virtual bool get_NotifyWrite();
    public abstract virtual int get_SizeHint();
    public abstract virtual Type get_RecordType();
    public abstract virtual bool get_IgnoreEmptyLines();
    public abstract virtual void set_IgnoreEmptyLines(bool value);
    public abstract virtual bool get_IgnoreEmptySpaces();
    public abstract virtual string get_CommentMarker();
    public abstract virtual void set_CommentMarker(string value);
    public abstract virtual bool get_CommentAnyPlace();
    public abstract virtual void set_CommentAnyPlace(bool value);
    public abstract virtual RecordCondition get_RecordCondition();
    public abstract virtual void set_RecordCondition(RecordCondition value);
    public abstract virtual Regex get_RecordConditionRegEx();
    public abstract virtual string get_RecordConditionSelector();
    public abstract virtual void set_RecordConditionSelector(string value);
    public abstract virtual int GetFieldIndex(string fieldName);
    public abstract virtual FieldInfo GetFieldInfo(string name);
    public abstract virtual RecordOperations get_Operations();
    public abstract virtual void RemoveField(string fieldname);
}
public interface FileHelpers.IRecordReader {
    public abstract virtual string ReadRecordString();
    public abstract virtual void Close();
}
public interface FileHelpers.ITransformable`1 {
    public abstract virtual T TransformTo();
}
[DebuggerDisplayAttribute("{DebuggerDisplayStr()}")]
internal class FileHelpers.LineInfo : object {
    internal string mLineStr;
    internal ForwardReader mReader;
    internal int mCurrentPos;
    internal static Char[] WhitespaceChars;
    private static CompareInfo mCompare;
    public string CurrentString { get; }
    public int CurrentLength { get; }
    public LineInfo(string line);
    private static LineInfo();
    public string Substring(int from, int count);
    private string DebuggerDisplayStr();
    public string get_CurrentString();
    public bool IsEOL();
    public int get_CurrentLength();
    public bool EmptyFromPos();
    public void TrimStart(Char[] toTrim);
    private void TrimStartSorted(Char[] toTrim);
    public bool StartsWith(string str);
    public bool StartsWithTrim(string str);
    public void ReadNextLine();
    public int IndexOf(string foundThis);
    internal void ReLoad(string line);
}
public enum FileHelpers.MasterDetail.CommonSelector : Enum {
    public int value__;
    public static CommonSelector MasterIfContains;
    public static CommonSelector MasterIfBegins;
    public static CommonSelector MasterIfEnds;
    public static CommonSelector MasterIfEnclosed;
    public static CommonSelector DetailIfContains;
    public static CommonSelector DetailIfBegins;
    public static CommonSelector DetailIfEnds;
    public static CommonSelector DetailIfEnclosed;
}
public class FileHelpers.MasterDetail.MasterDetailEngine : MasterDetailEngine`2<object, object> {
    public MasterDetailEngine(Type masterType, Type detailType);
    public MasterDetailEngine(Type masterType, Type detailType, MasterDetailSelector recordSelector);
    public MasterDetailEngine(Type masterType, Type detailType, CommonSelector action, string selector);
}
public class FileHelpers.MasterDetail.MasterDetailEngine`2 : EngineBase {
    [CompilerGeneratedAttribute]
private RecordOptions <MasterOptions>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private IRecordInfo mMasterInfo;
    [DebuggerBrowsableAttribute("0")]
private MasterDetailSelector mRecordSelector;
    [DebuggerBrowsableAttribute("0")]
private Type mMasterType;
    public RecordOptions MasterOptions { get; private set; }
    public Type MasterType { get; }
    public MasterDetailSelector RecordSelector { get; public set; }
    public MasterDetailEngine`2(MasterDetailSelector recordSelector);
    internal MasterDetailEngine`2(Type masterType, Type detailType, MasterDetailSelector recordSelector);
    public MasterDetailEngine`2(CommonSelector action, string selector);
    internal MasterDetailEngine`2(Type masterType, Type detailType, CommonSelector action, string selector);
    [CompilerGeneratedAttribute]
public RecordOptions get_MasterOptions();
    [CompilerGeneratedAttribute]
private void set_MasterOptions(RecordOptions value);
    public Type get_MasterType();
    public MasterDetailSelector get_RecordSelector();
    public void set_RecordSelector(MasterDetailSelector value);
    public MasterDetails`2[] ReadFile(string fileName);
    public MasterDetails`2[] ReadStream(TextReader reader);
    public MasterDetails`2[] ReadString(string source);
    public void WriteFile(string fileName, IEnumerable`1<MasterDetails`2<TMaster, TDetail>> records);
    public void WriteFile(string fileName, IEnumerable`1<MasterDetails`2<TMaster, TDetail>> records, int maxRecords);
    public void WriteStream(TextWriter writer, IEnumerable`1<MasterDetails`2<TMaster, TDetail>> records);
    public void WriteStream(TextWriter writer, IEnumerable`1<MasterDetails`2<TMaster, TDetail>> records, int maxRecords);
    public string WriteString(IEnumerable`1<MasterDetails`2<TMaster, TDetail>> records);
    public string WriteString(IEnumerable`1<MasterDetails`2<TMaster, TDetail>> records, int maxRecords);
    public void AppendToFile(string fileName, MasterDetails`2<TMaster, TDetail> record);
    public void AppendToFile(string fileName, IEnumerable`1<MasterDetails`2<TMaster, TDetail>> records);
}
[DebuggerDisplayAttribute("Master: {Master.ToString()} - Details: {Details.Length}")]
[TypeConverterAttribute("System.ComponentModel.ExpandableObjectConverter")]
public class FileHelpers.MasterDetail.MasterDetails : MasterDetails`2<object, object> {
    public MasterDetails(object master, Object[] details);
}
public class FileHelpers.MasterDetail.MasterDetails`2 : object {
    private static MasterDetails`2<M, D> mEmpty;
    protected M mMaster;
    protected D[] mDetails;
    public static MasterDetails`2<M, D> Empty { get; }
    public M Master { get; public set; }
    public D[] Details { get; public set; }
    public MasterDetails`2(M master, D[] details);
    private static MasterDetails`2();
    public static MasterDetails`2<M, D> get_Empty();
    public M get_Master();
    public void set_Master(M value);
    public D[] get_Details();
    public void set_Details(D[] value);
}
public class FileHelpers.MasterDetail.MasterDetailSelector : MulticastDelegate {
    public MasterDetailSelector(object object, IntPtr method);
    public virtual RecordAction Invoke(string recordString);
    public virtual IAsyncResult BeginInvoke(string recordString, AsyncCallback callback, object object);
    public virtual RecordAction EndInvoke(IAsyncResult result);
}
public enum FileHelpers.MasterDetail.RecordAction : Enum {
    public int value__;
    public static RecordAction Skip;
    public static RecordAction Master;
    public static RecordAction Detail;
}
public enum FileHelpers.MultilineMode : Enum {
    public int value__;
    public static MultilineMode AllowForBoth;
    public static MultilineMode AllowForRead;
    public static MultilineMode AllowForWrite;
    public static MultilineMode NotAllow;
}
[DebuggerDisplayAttribute("ErrorMode: {ErrorManager.ErrorMode.ToString()}. Encoding: {Encoding.EncodingName}")]
public class FileHelpers.MultiRecordEngine : EventEngineBase`1<object> {
    [DebuggerBrowsableAttribute("0")]
private IRecordInfo[] mMultiRecordInfo;
    [DebuggerBrowsableAttribute("0")]
private Dictionary`2<Type, IRecordInfo> mRecordInfoTable;
    [DebuggerBrowsableAttribute("0")]
private RecordTypeSelector mRecordSelector;
    [DebuggerBrowsableAttribute("0")]
private ForwardReader mAsyncReader;
    [DebuggerBrowsableAttribute("0")]
private TextWriter mAsyncWriter;
    [DebuggerBrowsableAttribute("0")]
private object mLastRecord;
    public RecordTypeSelector RecordSelector { get; public set; }
    public object LastRecord { get; }
    public MultiRecordEngine(Type[] recordTypes);
    public MultiRecordEngine(RecordTypeSelector recordSelector, Type[] recordTypes);
    public RecordTypeSelector get_RecordSelector();
    public void set_RecordSelector(RecordTypeSelector value);
    public Object[] ReadFile(string fileName);
    public Object[] ReadStream(TextReader reader);
    public Object[] ReadStream(IRecordReader reader);
    public Object[] ReadString(string source);
    public void WriteFile(string fileName, IEnumerable records);
    public void WriteFile(string fileName, IEnumerable records, int maxRecords);
    public void WriteStream(TextWriter writer, IEnumerable records);
    public void WriteStream(TextWriter writer, IEnumerable records, int maxRecords);
    public string WriteString(IEnumerable records);
    public string WriteString(IEnumerable records, int maxRecords);
    public void AppendToFile(string fileName, object record);
    public void AppendToFile(string fileName, IEnumerable records);
    private static Type GetFirstType(Type[] types);
    public object get_LastRecord();
    public void BeginReadStream(TextReader reader);
    [EditorBrowsableAttribute("2")]
public void BeginReadStream(IRecordReader reader);
    public void BeginReadFile(string fileName);
    public void BeginReadString(string sourceData);
    public void Flush();
    public void Close();
    public object ReadNext();
    private void ReadNextRecord();
    public Object[] ReadNexts(int numberOfRecords);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual override void Finalize();
    public void WriteNext(object record);
    public void WriteNexts(IEnumerable records);
    public void BeginWriteStream(TextWriter writer);
    public void BeginWriteFile(string fileName);
    public void BeginAppendToFile(string fileName);
}
public enum FileHelpers.NetLanguage : Enum {
    public int value__;
    [DescriptionAttribute("C#")]
public static NetLanguage CSharp;
    [DescriptionAttribute("VB.NET")]
public static NetLanguage VbNet;
}
public enum FileHelpers.NetVisibility : Enum {
    public int value__;
    public static NetVisibility Public;
    public static NetVisibility Internal;
    public static NetVisibility Protected;
    public static NetVisibility Private;
}
internal class FileHelpers.NewLineDelimitedRecordReader : object {
    private TextReader mReader;
    public NewLineDelimitedRecordReader(TextReader reader);
    public sealed virtual string ReadRecordString();
    public sealed virtual void Close();
}
public class FileHelpers.NullValueNotFoundException : BadUsageException {
    protected internal NullValueNotFoundException(string message);
    protected internal NullValueNotFoundException(int line, int column, string message);
    internal NullValueNotFoundException(LineInfo line, string message);
}
internal class FileHelpers.ObjectToValuesDelegate : MulticastDelegate {
    public ObjectToValuesDelegate(object object, IntPtr method);
    public virtual Object[] Invoke(object record);
    public virtual IAsyncResult BeginInvoke(object record, AsyncCallback callback, object object);
    public virtual Object[] EndInvoke(IAsyncResult result);
}
public class FileHelpers.Options.CsvOptions : object {
    private string mSampleFileName;
    private char mDelimiter;
    private char mHeaderDelimiter;
    private int mHeaderLines;
    private string mRecordClassName;
    private int mNumberOfFields;
    private string mFieldsPrefix;
    private string mDateFormat;
    private string mDecimalSeparator;
    private Encoding mEncoding;
    private bool mIgnoreEmptyLines;
    private bool mIncludeHeaderNames;
    private DecimalConverter mDecimalConv;
    private DoubleConverter mDoubleConv;
    private SingleConverter mSingleConv;
    private DateTimeConverter mDateConv;
    public string SampleFileName { get; public set; }
    public char Delimiter { get; public set; }
    public char HeaderDelimiter { get; public set; }
    public string RecordClassName { get; public set; }
    public string FieldsPrefix { get; public set; }
    public int NumberOfFields { get; public set; }
    public int HeaderLines { get; public set; }
    public bool IncludeHeaderNames { get; public set; }
    public string DateFormat { get; public set; }
    public string DecimalSeparator { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool IgnoreEmptyLines { get; public set; }
    public CsvOptions(string className, char delimiter, int numberOfFields);
    public CsvOptions(string className, char delimiter, int numberOfFields, int headerLines);
    public CsvOptions(string className, char delimiter, string sampleFile);
    public CsvOptions(string className, char delimiter, char headerDelimiter, string sampleFile);
    public string get_SampleFileName();
    public void set_SampleFileName(string value);
    public char get_Delimiter();
    public void set_Delimiter(char value);
    public char get_HeaderDelimiter();
    public void set_HeaderDelimiter(char value);
    public string get_RecordClassName();
    public void set_RecordClassName(string value);
    public string get_FieldsPrefix();
    public void set_FieldsPrefix(string value);
    public int get_NumberOfFields();
    public void set_NumberOfFields(int value);
    public int get_HeaderLines();
    public void set_HeaderLines(int value);
    public bool get_IncludeHeaderNames();
    public void set_IncludeHeaderNames(bool value);
    public string get_DateFormat();
    public void set_DateFormat(string value);
    public string get_DecimalSeparator();
    public void set_DecimalSeparator(string value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_IgnoreEmptyLines();
    public void set_IgnoreEmptyLines(bool value);
    internal string ValueToString(object o);
}
public class FileHelpers.Options.DelimitedRecordOptions : RecordOptions {
    public string Delimiter { get; public set; }
    internal DelimitedRecordOptions(IRecordInfo info);
    public string get_Delimiter();
    public void set_Delimiter(string value);
}
public class FileHelpers.Options.FieldBaseCollection : List`1<FieldBase> {
    internal FieldBaseCollection(FieldBase[] fields);
}
public class FileHelpers.Options.FixedRecordOptions : RecordOptions {
    [DebuggerBrowsableAttribute("0")]
private int mRecordLength;
    public FixedMode FixedMode { get; public set; }
    public int RecordLength { get; }
    internal FixedRecordOptions(IRecordInfo info);
    public FixedMode get_FixedMode();
    public void set_FixedMode(FixedMode value);
    public int get_RecordLength();
}
[EditorBrowsableAttribute("2")]
public abstract class FileHelpers.Options.RecordOptions : object {
    [DebuggerBrowsableAttribute("0")]
internal IRecordInfo mRecordInfo;
    [DebuggerBrowsableAttribute("0")]
private String[] mFieldNames;
    [DebuggerBrowsableAttribute("0")]
private Type[] mFieldTypes;
    [DebuggerBrowsableAttribute("0")]
private RecordConditionInfo mRecordConditionInfo;
    [DebuggerBrowsableAttribute("0")]
private IgnoreCommentInfo mIgnoreCommentInfo;
    public FieldBaseCollection Fields { get; }
    public int FieldCount { get; }
    public String[] FieldsNames { get; }
    public Type[] FieldsTypes { get; }
    public int IgnoreFirstLines { get; public set; }
    public int IgnoreLastLines { get; public set; }
    public bool IgnoreEmptyLines { get; public set; }
    public RecordConditionInfo RecordCondition { get; }
    public IgnoreCommentInfo IgnoreCommentedLines { get; }
    internal RecordOptions(IRecordInfo info);
    public FieldBaseCollection get_Fields();
    public void RemoveField(string fieldname);
    public int get_FieldCount();
    public String[] get_FieldsNames();
    public Type[] get_FieldsTypes();
    public int get_IgnoreFirstLines();
    public void set_IgnoreFirstLines(int value);
    public int get_IgnoreLastLines();
    public void set_IgnoreLastLines(int value);
    public bool get_IgnoreEmptyLines();
    public void set_IgnoreEmptyLines(bool value);
    public RecordConditionInfo get_RecordCondition();
    public IgnoreCommentInfo get_IgnoreCommentedLines();
    public string RecordToString(object record);
    public Object[] RecordToValues(object record);
    private static void PositiveValue(int val);
}
public enum FileHelpers.QuoteMode : Enum {
    public int value__;
    public static QuoteMode AlwaysQuoted;
    public static QuoteMode OptionalForRead;
    public static QuoteMode OptionalForWrite;
    public static QuoteMode OptionalForBoth;
}
public enum FileHelpers.RecordCondition : Enum {
    public int value__;
    public static RecordCondition None;
    public static RecordCondition IncludeIfContains;
    public static RecordCondition IncludeIfBegins;
    public static RecordCondition IncludeIfEnds;
    public static RecordCondition IncludeIfEnclosed;
    public static RecordCondition IncludeIfMatchRegex;
    public static RecordCondition ExcludeIfContains;
    public static RecordCondition ExcludeIfBegins;
    public static RecordCondition ExcludeIfEnds;
    public static RecordCondition ExcludeIfEnclosed;
    public static RecordCondition ExcludeIfMatchRegex;
}
[DefaultMemberAttribute("Item")]
[DelimitedRecordAttribute(",", "")]
[EditorBrowsableAttribute("2")]
public class FileHelpers.RecordIndexer : object {
    [FieldQuotedAttribute("1", "1")]
private String[] values;
    public int FieldCount { get; }
    public string Item { get; }
    public int get_FieldCount();
    public string get_Item(int index);
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class FileHelpers.RecordInfo : object {
    [CompilerGeneratedAttribute]
private int <SizeHint>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RecordType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreEmptyLines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreEmptySpaces>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommentMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldBase[] <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IgnoreFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IgnoreLast>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotifyRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotifyWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CommentAnyPlace>k__BackingField;
    [CompilerGeneratedAttribute]
private RecordCondition <RecordCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private Regex <RecordConditionRegEx>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RecordConditionSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private RecordOperations <Operations>k__BackingField;
    private Dictionary`2<string, int> mMapFieldIndex;
    public int SizeHint { get; private set; }
    public Type RecordType { get; private set; }
    public bool IgnoreEmptyLines { get; public set; }
    public bool IgnoreEmptySpaces { get; private set; }
    public string CommentMarker { get; public set; }
    public int FieldCount { get; }
    public FieldBase[] Fields { get; private set; }
    public int IgnoreFirst { get; public set; }
    public int IgnoreLast { get; public set; }
    public bool NotifyRead { get; private set; }
    public bool NotifyWrite { get; private set; }
    public bool CommentAnyPlace { get; public set; }
    public RecordCondition RecordCondition { get; public set; }
    public Regex RecordConditionRegEx { get; private set; }
    public string RecordConditionSelector { get; public set; }
    public RecordOperations Operations { get; private set; }
    public bool IsDelimited { get; }
    private RecordInfo(Type recordType);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SizeHint();
    [CompilerGeneratedAttribute]
private void set_SizeHint(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_RecordType();
    [CompilerGeneratedAttribute]
private void set_RecordType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IgnoreEmptyLines();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IgnoreEmptyLines(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IgnoreEmptySpaces();
    [CompilerGeneratedAttribute]
private void set_IgnoreEmptySpaces(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CommentMarker();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CommentMarker(string value);
    public sealed virtual int get_FieldCount();
    [CompilerGeneratedAttribute]
public sealed virtual FieldBase[] get_Fields();
    [CompilerGeneratedAttribute]
private void set_Fields(FieldBase[] value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IgnoreFirst();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IgnoreFirst(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_IgnoreLast();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IgnoreLast(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NotifyRead();
    [CompilerGeneratedAttribute]
private void set_NotifyRead(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NotifyWrite();
    [CompilerGeneratedAttribute]
private void set_NotifyWrite(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CommentAnyPlace();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CommentAnyPlace(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual RecordCondition get_RecordCondition();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RecordCondition(RecordCondition value);
    [CompilerGeneratedAttribute]
public sealed virtual Regex get_RecordConditionRegEx();
    [CompilerGeneratedAttribute]
private void set_RecordConditionRegEx(Regex value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RecordConditionSelector();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RecordConditionSelector(string value);
    [CompilerGeneratedAttribute]
public sealed virtual RecordOperations get_Operations();
    [CompilerGeneratedAttribute]
private void set_Operations(RecordOperations value);
    public sealed virtual bool get_IsDelimited();
    private void InitRecordFields();
    private static FieldBase[] CreateCoreFields(IList`1<FieldInfo> fields, TypedRecordAttribute recordAttribute);
    private static int SumOrder(List`1<FieldBase> fields);
    private static void CheckForOptionalAndArrayProblems(List`1<FieldBase> resFields);
    private static void SortFieldsByOrder(List`1<FieldBase> resFields);
    private static void CheckForOrderProblems(FieldBase currentField, List`1<FieldBase> resFields);
    public sealed virtual int GetFieldIndex(string fieldName);
    public sealed virtual FieldInfo GetFieldInfo(string name);
    public static IRecordInfo Resolve(Type type);
    private IRecordInfo Clone();
    private static bool CheckInterface(Type type, Type interfaceType);
    public sealed virtual void RemoveField(string fieldname);
    private void AdjustParentIndex();
    [CompilerGeneratedAttribute]
private void <InitRecordFields>b__67_0(IgnoreFirstAttribute a);
    [CompilerGeneratedAttribute]
private void <InitRecordFields>b__67_1(IgnoreLastAttribute a);
    [CompilerGeneratedAttribute]
private void <InitRecordFields>b__67_2(IgnoreEmptyLinesAttribute a);
    [CompilerGeneratedAttribute]
private void <InitRecordFields>b__67_3(IgnoreCommentedLinesAttribute a);
    [CompilerGeneratedAttribute]
private void <InitRecordFields>b__67_4(ConditionalRecordAttribute a);
}
internal class FileHelpers.RecordOperations : object {
    private IRecordInfo mRecordInfo;
    private CreateAndAssignDelegate mCreateHandler;
    private AssignDelegate mAssignHandler;
    private CreateObjectDelegate mFastConstructor;
    private ObjectToValuesDelegate mObjectToValuesHandler;
    private ObjectToValuesDelegate ObjectToValuesHandler { get; }
    private CreateAndAssignDelegate CreateHandler { get; }
    private AssignDelegate AssignHandler { get; }
    internal CreateObjectDelegate CreateRecordHandler { get; }
    public RecordOperations(IRecordInfo recordInfo);
    public object StringToRecord(LineInfo line, Object[] values);
    public bool StringToRecord(object record, LineInfo line, Object[] values);
    private bool MustIgnoreLine(string line);
    public string RecordToString(object record);
    public string RecordValuesToString(Object[] recordValues);
    public object ValuesToRecord(Object[] values);
    public Object[] RecordToValues(object record);
    public DataTable RecordsToDataTable(ICollection records);
    public DataTable RecordsToDataTable(ICollection records, int maxRecords);
    public DataTable CreateEmptyDataTable();
    private ObjectToValuesDelegate get_ObjectToValuesHandler();
    private CreateAndAssignDelegate get_CreateHandler();
    private AssignDelegate get_AssignHandler();
    internal CreateObjectDelegate get_CreateRecordHandler();
    private FieldInfo[] GetFieldInfoArray();
    public RecordOperations Clone(RecordInfo ri);
    public static bool StartsWithIgnoringWhiteSpaces(string source, string value, StringComparison comparisonType);
}
public class FileHelpers.RecordTypeSelector : MulticastDelegate {
    public RecordTypeSelector(object object, IntPtr method);
    public virtual Type Invoke(MultiRecordEngine engine, string recordString);
    public virtual IAsyncResult BeginInvoke(MultiRecordEngine engine, string recordString, AsyncCallback callback, object object);
    public virtual Type EndInvoke(IAsyncResult result);
}
internal static class FileHelpers.ReflectionHelper : object {
    public static ObjectToValuesDelegate ObjectToValuesMethod(Type recordType, FieldInfo[] fields);
    public static ConstructorInfo GetDefaultConstructor(Type recordType);
    public static CreateAndAssignDelegate CreateAndAssignValuesMethod(Type recordType, FieldInfo[] fields);
    public static AssignDelegate AssignValuesMethod(Type recordType, FieldInfo[] fields);
    public static CreateObjectDelegate CreateFastConstructor(Type recordType);
    public static IEnumerable`1<FieldInfo> RecursiveGetFields(Type currentType);
}
internal class FileHelpers.SortQueue`1 : object {
    private string mFile;
    private bool mDeleteFile;
    [CompilerGeneratedAttribute]
private FileHelperAsyncEngine`1<T> <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public FileHelperAsyncEngine`1<T> Engine { get; private set; }
    public T Current { get; private set; }
    public SortQueue`1(Encoding encoding, string file, bool deleteFile);
    [CompilerGeneratedAttribute]
public FileHelperAsyncEngine`1<T> get_Engine();
    [CompilerGeneratedAttribute]
private void set_Engine(FileHelperAsyncEngine`1<T> value);
    [CompilerGeneratedAttribute]
public T get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(T value);
    public void MoveNext();
    public sealed virtual void Dispose();
}
internal class FileHelpers.Streams.InternalStreamReader : TextReader {
    private bool mCheckPreamble;
    private bool mClosable;
    private bool mDetectEncoding;
    private bool mIsBlocked;
    private int mMaxCharsPerBuffer;
    private Byte[] mPreamble;
    private Byte[] mByteBuffer;
    private int mByteLen;
    private int mBytePos;
    private Char[] mCharBuffer;
    private int mCharLen;
    private int mCharPos;
    private Decoder mDecoder;
    private Encoding mEncoding;
    private static int MinBufferSize;
    private Stream mStream;
    public long Position { get; }
    internal bool Closable { get; }
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    public bool EndOfStream { get; }
    public InternalStreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public virtual void Close();
    private void CompressBuffer(int n);
    private void DetectEncoding();
    public void DiscardBufferedData();
    protected virtual void Dispose(bool disposing);
    private void Init(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    private bool IsPreamble();
    public virtual int Peek();
    public virtual int Read();
    public long get_Position();
    private int ReadBuffer();
    public virtual string ReadLine();
    internal bool get_Closable();
    public Encoding get_CurrentEncoding();
    public Stream get_BaseStream();
    public bool get_EndOfStream();
}
internal class FileHelpers.Streams.InternalStringReader : TextReader {
    private string mS;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal int Length { get; private set; }
    internal int Position { get; private set; }
    public InternalStringReader(string s);
    [CompilerGeneratedAttribute]
internal int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    public virtual string ReadToEnd();
}
internal class FileHelpers.Streams.StreamInfoProvider : object {
    private GetValue mPositionCalculator;
    private long mLength;
    public long Position { get; }
    public long TotalBytes { get; }
    public StreamInfoProvider(TextReader reader);
    public long get_Position();
    public long get_TotalBytes();
}
public enum FileHelpers.TrimMode : Enum {
    public int value__;
    public static TrimMode None;
    public static TrimMode Both;
    public static TrimMode Left;
    public static TrimMode Right;
}
[AttributeUsageAttribute("4")]
[EditorBrowsableAttribute("1")]
public abstract class FileHelpers.TypedRecordAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefaultCultureName>k__BackingField;
    public string DefaultCultureName { get; }
    protected TypedRecordAttribute(string defaultCultureName);
    [CompilerGeneratedAttribute]
public string get_DefaultCultureName();
}
