public interface DevExpress.Charts.ChartData.IMinMaxValuesCalculator {
    public abstract virtual double GetMinAbsValue(ICollection`1<RefinedSeries> seriesCollection);
    public abstract virtual MinMaxValues GetMinMaxValues(ICollection`1<RefinedSeries> seriesCollection, IMinMaxValues rangeForFiltering, List`1<IAffectsAxisRange> indicators);
}
public class DevExpress.Charts.ChartData.InteractionManager : object {
    private Dictionary`2<object, SeriesContainer> containers;
    private Dictionary`2<object, SeriesInteractionContainer> seriesGroupsContainers;
    public ICollection`1<SeriesContainer> InteractionContainers { get; }
    public ICollection`1<object> InteractionContainersKeys { get; }
    public ICollection`1<SeriesInteractionContainer> SeriesGroupsInteractionContainers { get; }
    public ICollection`1<SeriesContainer> get_InteractionContainers();
    public ICollection`1<object> get_InteractionContainersKeys();
    public ICollection`1<SeriesInteractionContainer> get_SeriesGroupsInteractionContainers();
    private void FindIndex(SortedArgumentRefinedPointCollection points, IMinMaxValues range, Int32& minIndex, Int32& maxIndex);
    private List`1<object> FindInteractionKeys(ICollection`1<RefinedSeries> seriesCollection);
    private SeriesContainer GetContainer(RefinedSeries refinedSeries, bool onlyExisting);
    private object GetKey(RefinedSeries refinedSeries);
    private sealed virtual override double DevExpress.Charts.ChartData.IMinMaxValuesCalculator.GetMinAbsValue(ICollection`1<RefinedSeries> seriesCollection);
    private sealed virtual override MinMaxValues DevExpress.Charts.ChartData.IMinMaxValuesCalculator.GetMinMaxValues(ICollection`1<RefinedSeries> seriesCollection, IMinMaxValues rangeForFiltering, List`1<IAffectsAxisRange> indicators);
    private MinMaxValues GetMinMaxValuesForWholePoints(ICollection`1<RefinedSeries> seriesCollection);
    private SeriesRangeCalculatorBase CreateRangeCalculator(ISeriesView seriesView);
    private MinMaxValues GetMinMaxValuesWithFiltering(ICollection`1<RefinedSeries> seriesCollection, IMinMaxValues rangeForFiltering);
    private SeriesInteractionContainer GetSeriesGroupsContainer(RefinedSeries refinedSeries, bool onlyExisting);
    private object GetSeriesGroupsKey(RefinedSeries refinedSeries);
    private bool IsFullStackedSeries(ISeriesView view);
    private bool IsStackedSeries(ISeriesView view);
    internal MinMaxValues GetSeriesValuesRange(RefinedSeries series);
    internal void UpdatePoints(RefinedSeriesPointsUpdateInfo updateResult);
    public void AddSeries(RefinedSeries refinedSeries);
    public void Clear();
    public void RecalculateFor(ICollection`1<RefinedSeries> seriesCollection);
    public void RemoveSeries(RefinedSeries refinedSeries);
    public void UpdateSeriesGroupsKeys();
    public SeriesContainer GetSeriesContainer(RefinedSeries refinedSeries);
}
internal class DevExpress.Charts.ChartData.SeriesRangeCalculator : SeriesRangeCalculatorBase {
    protected virtual void UpdateMinMaxValues(MinMaxValuesContainer minMaxValues, ISeriesView view, RefinedPoint point);
}
internal abstract class DevExpress.Charts.ChartData.SeriesRangeCalculatorBase : object {
    protected abstract virtual void UpdateMinMaxValues(MinMaxValuesContainer minMaxValues, ISeriesView view, RefinedPoint point);
    public MinMaxValues GetMinMaxFromSeries(MinMaxValues totalRange, ISeriesView view, SortedArgumentRefinedPointCollection points, int minIndexX, int maxIndexX);
}
internal class DevExpress.Charts.ChartData.SingleValueSeriesRangeCalculator : SeriesRangeCalculatorBase {
    protected virtual void UpdateMinMaxValues(MinMaxValuesContainer minMaxValues, ISeriesView view, RefinedPoint point);
}
internal class DevExpress.Charts.ChartData.StackedSeriesRangeCalculator : SeriesRangeCalculatorBase {
    protected virtual void UpdateMinMaxValues(MinMaxValuesContainer minMaxValues, ISeriesView view, RefinedPoint point);
}
public class DevExpress.Charts.Heatmap.HeatmapCell : object {
    [CompilerGeneratedAttribute]
private CellIndex <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private object <XArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private object <YArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ColorValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    internal CellIndex Index { get; }
    public object XArgument { get; }
    public object YArgument { get; }
    public object ColorValue { get; }
    public object Tag { get; }
    internal HeatmapCell(object xArgument, object yArgument, object colorValue, object tag, CellIndex cellIndex);
    public static bool op_Equality(HeatmapCell a, HeatmapCell b);
    public static bool op_Inequality(HeatmapCell a, HeatmapCell b);
    [CompilerGeneratedAttribute]
internal CellIndex get_Index();
    [CompilerGeneratedAttribute]
public object get_XArgument();
    [CompilerGeneratedAttribute]
public object get_YArgument();
    [CompilerGeneratedAttribute]
public object get_ColorValue();
    [CompilerGeneratedAttribute]
public object get_Tag();
    private bool AreEqual(object a, object b);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(HeatmapCell heatmapCell);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Heatmap.Native.CellIndex : ValueType {
    public static CellIndex Invalid;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    public int Y { get; private set; }
    public int X { get; private set; }
    public bool IsValid { get; }
    public CellIndex(int xIndex, int yIndex);
    private static CellIndex();
    public static bool op_Equality(CellIndex a, CellIndex b);
    public static bool op_Inequality(CellIndex a, CellIndex b);
    [CompilerGeneratedAttribute]
public int get_Y();
    [CompilerGeneratedAttribute]
private void set_Y(int value);
    [CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
private void set_X(int value);
    public bool get_IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(CellIndex other);
}
public class DevExpress.Charts.Heatmap.Native.HeatmapBindingProcedure : BindingProcedure {
    private IHeatmapDataSourceProvider dataSourceProvider;
    public HeatmapBindingProcedure(IHeatmapDataSourceProvider dataSourceProvider);
    public IList`1<HeatmapItem> Process(MinMaxValues& valueRange);
    protected virtual Dictionary`2<string, IDataMemberContainer> CreateAdditionalDataMemberContainers();
    protected virtual List`1<IDataMemberContainer> CreateDataMemberContainers();
}
public class DevExpress.Charts.Heatmap.Native.HeatmapData : object {
    [CompilerGeneratedAttribute]
private static HeatmapData <Empty>k__BackingField;
    private IHeatmapAdapter adapter;
    private IHeatmapDataSourceProvider dataSourceAdapter;
    private Object[0...,0...] tags;
    [CompilerGeneratedAttribute]
private IList`1<object> <XCoords>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<object> <YCoords>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[0...,0...] <Colors>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <ValueRange>k__BackingField;
    public static HeatmapData Empty { get; }
    public IList`1<object> XCoords { get; }
    public IList`1<object> YCoords { get; }
    public Int32[0...,0...] Colors { get; public set; }
    public MinMaxValues ValueRange { get; private set; }
    public bool IsEmpty { get; }
    public HeatmapData(Int32[0...,0...] colors, IList`1<object> xCoords, IList`1<object> yCoords, Object[0...,0...] tags, MinMaxValues valueRange, IHeatmapAdapter adapter);
    private static HeatmapData();
    [CompilerGeneratedAttribute]
public static HeatmapData get_Empty();
    private static IList`1<T> ToList(IEnumerable items);
    private static MinMaxValues CalculateValueRange(Double[0...,0...] values);
    private static HeatmapData GenerateData(Double[0...,0...] values, IList`1<object> xArguments, IList`1<object> yArguments, MinMaxValues valueRange, IHeatmapMatrixProvider matrixProvider);
    private static Int32[0...,0...] CreateMatrix(Double[0...,0...] values, IList`1<object> xArguments, IList`1<object> yArguments, MinMaxValues valueRange, IHeatmapColorProvider colorProvider);
    private static IList`1<object> GetFirstItems(IList`1<object> items, int n);
    private static HeatmapData CreateHeatmapData(IList`1<HeatmapItem> items, MinMaxValues valueRange, IHeatmapDataSourceProvider adapter);
    private static IList`1<object> CreateAxisValues(IList`1<HeatmapItem> items, Func`2<HeatmapItem, object> valueGetter, IComparer valuesComparer);
    private static Int32[0...,0...] CreateMatrix(IList`1<HeatmapItem> items, IList`1<object> axisXValues, IList`1<object> axisYValues, MinMaxValues valueRange, IHeatmapColorProvider colorProvider, Object[0...,0...]& tags);
    private static Dictionary`2<object, int> CreateAxisMapping(IList`1<object> axisValues);
    private static bool MembersAreValid(IHeatmapDataSourceProvider dataSourceProvider);
    private static bool MembersAreValid(IHeatmapMatrixProvider matrixProvider);
    public static HeatmapData Create(IHeatmapMatrixProvider matrixProvider);
    public static HeatmapData Create(IHeatmapDataSourceProvider dataSourceProvider);
    [CompilerGeneratedAttribute]
public IList`1<object> get_XCoords();
    [CompilerGeneratedAttribute]
public IList`1<object> get_YCoords();
    [CompilerGeneratedAttribute]
public Int32[0...,0...] get_Colors();
    [CompilerGeneratedAttribute]
public void set_Colors(Int32[0...,0...] value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_ValueRange();
    [CompilerGeneratedAttribute]
private void set_ValueRange(MinMaxValues value);
    public bool get_IsEmpty();
    public sealed virtual object GetTag(int x, int y);
    public sealed virtual object GetColorValue(int x, int y);
    public object GetCustomValue(int x, int y, string constant);
    public sealed virtual bool IsCellEmpty(int x, int y);
    public HeatmapCell GetCell(int x, int y);
    public List`1<HeatmapCell> GetCellsByTagList(IList selectedItems);
}
public class DevExpress.Charts.Heatmap.Native.HeatmapGeometry : object {
    private IAdditionalValuesProvider emptyCellsProvider;
    private Func`2<int, int> getLeftIndex;
    private Func`2<int, int> getTopIndex;
    private Func`2<int, int> getRightIndex;
    private Func`2<int, int> getBottomIndex;
    [CompilerGeneratedAttribute]
private bool <ReverseX>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReverseY>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<int> <XSeparators>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<int> <YSeparators>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstVisibleXIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstVisibleYIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private DXRectangle <Bounds>k__BackingField;
    private bool ReverseX { get; }
    private bool ReverseY { get; }
    public IList`1<int> XSeparators { get; }
    public IList`1<int> YSeparators { get; }
    public int FirstVisibleXIndex { get; }
    public int FirstVisibleYIndex { get; }
    public DXRectangle Bounds { get; }
    public HeatmapGeometry(IList`1<int> xSeparators, IList`1<int> ySeparators, int firstVisibleXIndex, int firstVisibleYIndex, DXPoint location, IAdditionalValuesProvider emptyCellsProvider);
    public static HeatmapGeometry Calculate(HeatmapRefinedSeries series, IAxisData axisX, IAxisData axisY, Func`3<double, double, DXPoint> getScreenPoint);
    private static IList`1<int> ConvertToScreenCoord(IList`1<double> coords, int start, int end, Func`2<double, int> convert);
    private static Limits CalculateVisualCellIndexes(IList`1<double> values, double minRangeValue, double maxRangeValue);
    private static int ToVisualRangePixelCoord(double value, double min, double size, int visualRangePixelWidth, bool reverse);
    [CompilerGeneratedAttribute]
private bool get_ReverseX();
    [CompilerGeneratedAttribute]
private bool get_ReverseY();
    [CompilerGeneratedAttribute]
public IList`1<int> get_XSeparators();
    [CompilerGeneratedAttribute]
public IList`1<int> get_YSeparators();
    [CompilerGeneratedAttribute]
public int get_FirstVisibleXIndex();
    [CompilerGeneratedAttribute]
public int get_FirstVisibleYIndex();
    [CompilerGeneratedAttribute]
public DXRectangle get_Bounds();
    private int CalculateViewportCellAxisIndex(IList`1<int> separators, double coord, bool isIncreasing);
    private bool AreBoundsCorrect(int leftSeparatorIndex, int topSeparatorIndex, int rightSeparatorIndex, int bottomSeparatorIndex);
    private DXRectangle GetAbsoluteBounds(int leftSeparatorIndex, int topSeparatorIndex, int rightSeparatorIndex, int bottomSeparatorIndex, bool shouldCalcRelative);
    private void DrawRect(Int32[] heatmap, int left, int top, int right, int bottom, int color, int screenWidth);
    private List`1<DXRectangle> MergeLineCells(List`1<DXRectangle> cells);
    public Int32[] CreateHeatmap(HeatmapData heatmapData);
    public DXRectangle GetCellBounds(CellIndex cellIndex, bool shouldCalcRelative);
    public List`1<DXRectangle> GetRowBounds(int rowIndex, bool shouldCalcRelative);
    public List`1<DXRectangle> GetColumnBounds(int columnIndex, bool shouldCalcRelative);
    public CellIndex CalculateCellIndex(DXPoint point);
}
public class DevExpress.Charts.Heatmap.Native.HeatmapItem : object {
    [CompilerGeneratedAttribute]
private object <XArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private object <YArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    public object XArgument { get; }
    public object YArgument { get; }
    public object Value { get; }
    public object Tag { get; }
    public HeatmapItem(object xArgument, object yArgument, object value, object tag);
    [CompilerGeneratedAttribute]
public object get_XArgument();
    [CompilerGeneratedAttribute]
public object get_YArgument();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public object get_Tag();
}
public class DevExpress.Charts.Heatmap.Native.HeatmapPatternDataProvider : PatternDataProvider {
    private string patternConstant;
    private HeatmapData heatmapData;
    private CellIndex CellIndex { get; }
    public HeatmapPatternDataProvider(string patternConstant, HeatmapData heatmapData);
    private CellIndex get_CellIndex();
    private object GetValue();
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public class DevExpress.Charts.Heatmap.Native.HeatmapPatternHelper : object {
    private PatternParser parser;
    private HeatmapData heatmapData;
    public HeatmapPatternHelper(string pattern, HeatmapData heatmapData);
    private sealed virtual override PatternDataProvider DevExpress.Charts.Native.IPatternHolder.GetDataProvider(string patternConstant);
    public string GetText(CellIndex index);
}
public class DevExpress.Charts.Heatmap.Native.HeatmapRefinedSeries : RefinedSeries {
    private HeatmapData heatmapData;
    [CompilerGeneratedAttribute]
private IList`1<double> <CellXCoords>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<double> <CellYCoords>k__BackingField;
    public HeatmapData HeatmapData { get; public set; }
    public IList`1<double> CellXCoords { get; private set; }
    public IList`1<double> CellYCoords { get; private set; }
    public double MinValue { get; }
    public double MaxValue { get; }
    public ActualScaleTypeCore ArgumentScaleType { get; }
    public ActualScaleTypeCore ValueScaleType { get; }
    protected internal bool IsEmpty { get; }
    public HeatmapRefinedSeries(HeatmapData heatmapData, ISeries series, IRefinedSeriesContainer seriesContainer);
    public HeatmapData get_HeatmapData();
    public void set_HeatmapData(HeatmapData value);
    [CompilerGeneratedAttribute]
public IList`1<double> get_CellXCoords();
    [CompilerGeneratedAttribute]
private void set_CellXCoords(IList`1<double> value);
    [CompilerGeneratedAttribute]
public IList`1<double> get_CellYCoords();
    [CompilerGeneratedAttribute]
private void set_CellYCoords(IList`1<double> value);
    public double get_MinValue();
    public double get_MaxValue();
    public virtual ActualScaleTypeCore get_ArgumentScaleType();
    public virtual ActualScaleTypeCore get_ValueScaleType();
    private void UpdateRefinedCoords();
    private IList`1<double> CreateCellCoords(IList`1<object> axisCoords, AxisScaleTypeMap scaleMap);
    private double CalculateCellSize(IList`1<object> axisCoords, AxisScaleTypeMap scaleMap);
    protected internal virtual bool get_IsEmpty();
    protected internal virtual void PopulateArgumentAxisScaleMap(AxisQualitativeMap qualitativeMap);
    protected internal virtual void PopulateArgument2AxisScaleMap(AxisQualitativeMap qualitativeMap);
    protected internal virtual void PopulateValueAxisScaleMap(AxisQualitativeMap qualitativeMap);
    public virtual double GetMinArgument(AxisScaleTypeMap scaleMap);
    public virtual double GetMaxArgument(AxisScaleTypeMap scaleMap);
    public virtual void UpdateData();
}
public interface DevExpress.Charts.Heatmap.Native.IAdditionalValuesProvider {
    public abstract virtual object GetTag(int x, int y);
    public abstract virtual object GetColorValue(int x, int y);
    public abstract virtual bool IsCellEmpty(int x, int y);
}
public interface DevExpress.Charts.Heatmap.Native.IHeatmapAdapter {
    public HeatmapData HeatmapData { get; }
    public IHeatmapColorProvider ColorProvider { get; }
    public abstract virtual HeatmapData get_HeatmapData();
    public abstract virtual IHeatmapColorProvider get_ColorProvider();
    public abstract virtual object GetColorValue(int x, int y);
    public abstract virtual bool IsCellEmpty(int x, int y);
}
public interface DevExpress.Charts.Heatmap.Native.IHeatmapColorProvider {
    public bool ShouldConvertColorForMatrix { get; }
    public abstract virtual int GetItemColor(HeatmapItem value, MinMaxValues valueRange);
    public abstract virtual bool get_ShouldConvertColorForMatrix();
}
public interface DevExpress.Charts.Heatmap.Native.IHeatmapDataProvider {
    public HeatmapData HeatmapData { get; }
    public abstract virtual HeatmapData get_HeatmapData();
}
public interface DevExpress.Charts.Heatmap.Native.IHeatmapDataSourceProvider {
    public object DataSource { get; }
    public string XArgumentDataMember { get; }
    public string YArgumentDataMember { get; }
    public string ColorDataMember { get; }
    public IComparer XArgumentComparer { get; }
    public IComparer YArgumentComparer { get; }
    public abstract virtual object get_DataSource();
    public abstract virtual string get_XArgumentDataMember();
    public abstract virtual string get_YArgumentDataMember();
    public abstract virtual string get_ColorDataMember();
    public abstract virtual IComparer get_XArgumentComparer();
    public abstract virtual IComparer get_YArgumentComparer();
    public abstract virtual object GetValue(int x, int y, string dataMember);
}
public interface DevExpress.Charts.Heatmap.Native.IHeatmapMatrixProvider {
    public IEnumerable XArguments { get; }
    public IEnumerable YArguments { get; }
    public Double[0...,0...] Values { get; }
    public abstract virtual IEnumerable get_XArguments();
    public abstract virtual IEnumerable get_YArguments();
    public abstract virtual Double[0...,0...] get_Values();
}
internal static class DevExpress.Charts.Native.ActionTypeHelper : object {
    public static bool ShouldRecalculateArgumentScale(CommonActionType updateType);
    public static bool ShouldUpdatePointsIndices(CommonActionType updateType);
    public static bool ShouldUpdateSeriesGroupsInteraction(CommonActionType updateType);
    public static bool ShouldUpdateCrosshair(CommonActionType updateType);
    public static bool ShouldDeserializeRange(CommonActionType updateType);
    public static bool ShouldUpdateMeasureUnits(CommonActionType updateType);
    public static bool ShouldResetSelectedItems(CommonActionType updateType);
    public static bool ShouldCommit(CommonActionType updateType);
    public static bool EndLoading(CommonActionType updateType);
    public static bool ShouldRaiseWholeRangeChanged(CommonActionType updateType);
    public static bool ShouldRaiseVisualRangeChanged(CommonActionType updateType);
    public static bool ShouldUpdateVisualPointIndicesOnly(CommonActionType updateType);
    public static bool ShouldUpdateSeriesGroupsInteractionKeys(CommonActionType updateType);
    public static bool ShouldUpdateIndicators(CommonActionType updateType);
    public static bool ShouldAnimateChart(CommonActionType updateType);
    public static bool ShouldUpdateAutoScale(SeriesActionType updateType);
    public static bool ShouldUpdateInteraction(SeriesActionType updateType);
    public static bool ShouldRemoveRefinedSeriesFromGroup(SeriesActionType updateType);
    public static bool ShouldUpdateRefinedSeriesData(SeriesActionType updateType);
    public static bool ShouldUpdateSeriesPointKey(SeriesActionType updateType);
    public static bool ShouldUpdateSeriesPointMode(SeriesActionType updateType);
    public static bool ShouldUpdatePointsFilter(SeriesActionType updateType);
    public static bool ShouldUpdatePointValuesOnly(SeriesActionType updateType);
    public static bool ShouldUpdateScaleMap(AxisActionType updateType);
    public static bool ShouldRemoveSeriesGroup(AxisActionType updateType);
    public static bool ShouldUpdateSeriesGroup(AxisActionType updateType);
    public static bool ShouldUpdatePointsFilter(AxisActionType updateType);
    public static bool ShouldUpdatePointsAggregation(AxisActionType updateType);
    public static bool ShouldInsertInCollection(CollectionActionType updateType);
    public static bool ShouldRemoveFromCollection(CollectionActionType updateType);
    public static bool ShouldCleanCollection(CollectionActionType updateType);
    public static bool ShouldMoveInCollection(CollectionActionType updateType);
    public static bool ShouldSwapInCollection(CollectionActionType updateType);
}
public enum DevExpress.Charts.Native.ActualScaleTypeCore : Enum {
    public int value__;
    public static ActualScaleTypeCore Numerical;
    public static ActualScaleTypeCore DateTime;
    public static ActualScaleTypeCore Qualitative;
    public static ActualScaleTypeCore TimeSpan;
}
public class DevExpress.Charts.Native.AggregatedFunctionPointsCreator : AggregatedPointsCreatorBase {
    private IAggregationCalculator calculator;
    private ErrorBarsPointsCalculator errorBarsPointsCalculator;
    public AggregatedFunctionPointsCreator(RefinedSeries series, AxisScaleTypeMap axisXScaleTypeMap, AxisScaleTypeMap axisYScaleTypeMap, IAggregationCalculator calculator, ErrorBarsPointsCalculator errorBarsPointsCalculator);
    private Double[] CalculateClusterErrorBarValues(IAggregationCalculator calculator, IList`1<RefinedPoint> points, int index, int count);
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.AggregatedFunctionPointsCreator/<CreateAggregatedPoints>d__4")]
public virtual IEnumerable`1<RefinedPoint> CreateAggregatedPoints(IList`1<RefinedPoint> sourcePoints, int clusterStartIndex, int clusterCount, double currentAlignedArgument);
}
public abstract class DevExpress.Charts.Native.AggregatedPointsCreatorBase : object {
    private AxisScaleTypeMap axisXScaleTypeMap;
    private AxisScaleTypeMap axisYScaleTypeMap;
    private RefinedSeries series;
    public AggregatedPointsCreatorBase(RefinedSeries series, AxisScaleTypeMap axisXScaleTypeMap, AxisScaleTypeMap axisYScaleTypeMap);
    public static AggregatedPointsCreatorBase Create(RefinedSeries series, AxisScaleTypeMap axisXScaleTypeMap, AxisScaleTypeMap axisYScaleTypeMap, IAggregationCalculator calculator, ErrorBarsPointsCalculator errorBarsPointsCalculator);
    private T[] InternalToNative(Double[] values);
    protected RefinedPoint CreateAggregatedPoint(IList`1<RefinedPoint> sourcePoints, int clusterStartIndex, int clusterCount, double clusterArgument, Double[] values, Double[] errorBarsValues, CorePointState state);
    public abstract virtual IEnumerable`1<RefinedPoint> CreateAggregatedPoints(IList`1<RefinedPoint> sourcePoints, int index, int count, double currentAlignedArgument);
}
public abstract class DevExpress.Charts.Native.AggregatedSeriesArgumentContainer`1 : AggregatedSeriesArgumentContainerBase {
    private T typedArgument;
    protected T TypedArgument { get; }
    protected double NumericalArgument { get; }
    protected DateTime DateTimeArgument { get; }
    protected TimeSpan TimeSpanArgument { get; }
    protected AggregatedSeriesArgumentContainer`1(object argument);
    protected T get_TypedArgument();
    protected virtual double get_NumericalArgument();
    protected virtual DateTime get_DateTimeArgument();
    protected virtual TimeSpan get_TimeSpanArgument();
    protected abstract virtual T Convert(object value);
}
public abstract class DevExpress.Charts.Native.AggregatedSeriesArgumentContainerBase : object {
    private object userArgument;
    public object Argument { get; public set; }
    protected Scale Scale { get; }
    protected string QualitativeArgument { get; }
    protected double NumericalArgument { get; }
    protected DateTime DateTimeArgument { get; }
    protected TimeSpan TimeSpanArgument { get; }
    private Scale DevExpress.Charts.Native.ISeriesPointArgument.ArgumentScaleType { get; }
    private object DevExpress.Charts.Native.ISeriesPointArgument.UserArgument { get; }
    private string DevExpress.Charts.Native.ISeriesPointArgument.QualitativeArgument { get; }
    private double DevExpress.Charts.Native.ISeriesPointArgument.NumericalArgument { get; }
    private DateTime DevExpress.Charts.Native.ISeriesPointArgument.DateTimeArgument { get; }
    private TimeSpan DevExpress.Charts.Native.ISeriesPointArgument.TimeSpanArgument { get; }
    protected AggregatedSeriesArgumentContainerBase(object argument);
    public static AggregatedSeriesArgumentContainerBase CreateInstance(Scale argumentScaleType, object argument);
    public object get_Argument();
    public void set_Argument(object value);
    protected abstract virtual Scale get_Scale();
    protected abstract virtual string get_QualitativeArgument();
    protected abstract virtual double get_NumericalArgument();
    protected abstract virtual DateTime get_DateTimeArgument();
    protected abstract virtual TimeSpan get_TimeSpanArgument();
    private sealed virtual override Scale DevExpress.Charts.Native.ISeriesPointArgument.get_ArgumentScaleType();
    private sealed virtual override object DevExpress.Charts.Native.ISeriesPointArgument.get_UserArgument();
    private sealed virtual override string DevExpress.Charts.Native.ISeriesPointArgument.get_QualitativeArgument();
    private sealed virtual override double DevExpress.Charts.Native.ISeriesPointArgument.get_NumericalArgument();
    private sealed virtual override DateTime DevExpress.Charts.Native.ISeriesPointArgument.get_DateTimeArgument();
    private sealed virtual override TimeSpan DevExpress.Charts.Native.ISeriesPointArgument.get_TimeSpanArgument();
}
public class DevExpress.Charts.Native.AggregatedSeriesPoint : object {
    public static int NoColor;
    public static int EmptyColor;
    public static int HasColor;
    private AggregatedSeriesArgumentContainerBase argumentX;
    private AggregatedSeriesArgumentContainerBase argumentY;
    private ISeriesPointValues values;
    private RefinedSeries owner;
    private IList`1<RefinedPoint> sourcePoints;
    private int sourcePointsStartIndex;
    private int sourcePointsCount;
    private int colorStatus;
    private int color;
    private CorePointState pointState;
    private bool isAuxiliary;
    public AggregatedSeriesArgumentContainerBase ArgumentX { get; }
    public ISeries Series { get; }
    public ISeriesPointValues Values { get; }
    public bool IsEmpty { get; }
    public CorePointState State { get; }
    public IEnumerable`1<RefinedPoint> SourcePoints { get; }
    public int SourcePointsCount { get; }
    public bool IsAuxiliary { get; }
    public int ColorStatus { get; public set; }
    public int Color { get; public set; }
    private ISeries DevExpress.Charts.Native.ISeriesPoint.Owner { get; }
    private ISeriesPointArgument DevExpress.Charts.Native.ISeriesPoint.ArgumentX { get; }
    private ISeriesPointArgument DevExpress.Charts.Native.ISeriesPoint.ArgumentY { get; }
    private ISeriesPointValues DevExpress.Charts.Native.ISeriesPoint.Values { get; }
    private IIndicatorDataPoint DevExpress.Charts.Native.ISeriesPoint.IndicatorPoint { get; }
    private object DevExpress.Charts.Native.ISeriesPoint.ToolTipHint { get; private set; }
    private DataContextBase DevExpress.Charts.Native.ISeriesPoint.DataContext { get; }
    private object DevExpress.Charts.Native.ISeriesPoint.Tag { get; }
    private Nullable`1<int> DevExpress.Charts.Native.ISeriesPoint.ColorCore { get; }
    private double DevExpress.Charts.Native.IDataPoint.NumericalValue { get; }
    private object DevExpress.Charts.Native.IDataPoint.Argument { get; }
    private ISeriesPointArgument DevExpress.Charts.Native.IDataPoint.ArgumentX { get; }
    private AggregatedSeriesPoint(RefinedSeries owner, Scale argumentScaleTypeX, object argumentX, IList`1<RefinedPoint> sourcePoints, int index, int count, CorePointState state, bool isAuxiliary);
    public AggregatedSeriesPoint(RefinedSeries owner, Scale argumentScaleTypeX, object argumentX, Double[] values, IList`1<RefinedPoint> sourcePoints, int index, int count, CorePointState state, bool isAuxiliary);
    public AggregatedSeriesPoint(RefinedSeries owner, Scale argumentScaleTypeX, object argumentX, DateTime[] values, Double[] userValues, IList`1<RefinedPoint> sourcePoints, int index, int count, CorePointState state);
    public AggregatedSeriesPoint(RefinedSeries owner, Scale argumentScaleTypeX, object argumentX, TimeSpan[] values, Double[] userValues, IList`1<RefinedPoint> sourcePoints, int index, int count, CorePointState state);
    public AggregatedSeriesPoint(RefinedSeries owner, Scale argumentScaleTypeX, Scale argumentScaleTypeY, object argumentX, object argumentY, Double[] values, IList`1<RefinedPoint> sourcePoints, int index, int count, CorePointState state);
    public AggregatedSeriesArgumentContainerBase get_ArgumentX();
    public ISeries get_Series();
    public ISeriesPointValues get_Values();
    public sealed virtual bool get_IsEmpty();
    public CorePointState get_State();
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.AggregatedSeriesPoint/<get_SourcePoints>d__25")]
public IEnumerable`1<RefinedPoint> get_SourcePoints();
    public int get_SourcePointsCount();
    public bool get_IsAuxiliary();
    public int get_ColorStatus();
    public void set_ColorStatus(int value);
    public int get_Color();
    public void set_Color(int value);
    private sealed virtual override ISeries DevExpress.Charts.Native.ISeriesPoint.get_Owner();
    private sealed virtual override ISeriesPointArgument DevExpress.Charts.Native.ISeriesPoint.get_ArgumentX();
    private sealed virtual override ISeriesPointArgument DevExpress.Charts.Native.ISeriesPoint.get_ArgumentY();
    private sealed virtual override ISeriesPointValues DevExpress.Charts.Native.ISeriesPoint.get_Values();
    private sealed virtual override IIndicatorDataPoint DevExpress.Charts.Native.ISeriesPoint.get_IndicatorPoint();
    private sealed virtual override object DevExpress.Charts.Native.ISeriesPoint.get_ToolTipHint();
    private sealed virtual override void DevExpress.Charts.Native.ISeriesPoint.set_ToolTipHint(object value);
    private sealed virtual override bool DevExpress.Charts.Native.ISeriesPoint.IsEmpty(Scale scale);
    private sealed virtual override bool DevExpress.Charts.Native.ISeriesPoint.IsSamePoints(ISeriesPoint seriesPoint);
    private sealed virtual override void DevExpress.Charts.Native.ISeriesPoint.SetOwner(ISeries series);
    private sealed virtual override void DevExpress.Charts.Native.ISeriesPoint.ClearAnnotations();
    private sealed virtual override void DevExpress.Charts.Native.ISeriesPoint.UpdateAnnotationRepository();
    private sealed virtual override DataContextBase DevExpress.Charts.Native.ISeriesPoint.get_DataContext();
    private sealed virtual override object DevExpress.Charts.Native.ISeriesPoint.get_Tag();
    private sealed virtual override Nullable`1<int> DevExpress.Charts.Native.ISeriesPoint.get_ColorCore();
    private sealed virtual override double DevExpress.Charts.Native.IDataPoint.get_NumericalValue();
    private sealed virtual override object DevExpress.Charts.Native.IDataPoint.get_Argument();
    private sealed virtual override ISeriesPointArgument DevExpress.Charts.Native.IDataPoint.get_ArgumentX();
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.Apply(ISeries series, string toolTipHint);
    private sealed virtual override RefinedPoint DevExpress.Charts.Native.IDataPoint.GetRefinedPoint(IRefinedPointCreator pointCreator, IPointProcessor pointProcessor, List`1<AxisScaleTypeMap> argumentMaps);
    private sealed virtual override ISeriesPoint DevExpress.Charts.Native.IDataPoint.GetSeriesPoint(ISeriesPointCreator pointCreator);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetNumericalArgument(double value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetDateTimeArgument(DateTime value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetTimeSpanArgument(TimeSpan value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetQualitativeArgument(string value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetNumericalValues(Double[] value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetDateTimeValues(DateTime[] value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetTimeSpanValues(TimeSpan[] value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetTag(object tag);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.MakeEmpty();
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.ClearAnnotations();
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.UpdateAnnotationRepository();
    private T[] GetValuesArrayByDimension(T[] values, IList`1<RefinedPoint> sourcePoints);
    public RefinedPoint GetRefinedPoint(int index);
}
public class DevExpress.Charts.Native.AggregatedSourcePointsCreator : AggregatedPointsCreatorBase {
    public AggregatedSourcePointsCreator(RefinedSeries series, AxisScaleTypeMap axisXScaleTypeMap, AxisScaleTypeMap axisYScaleTypeMap);
    private Double[] GetErrorBarValues(IErrorBarPoint point);
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.AggregatedSourcePointsCreator/<CreateAggregatedPoints>d__2")]
public virtual IEnumerable`1<RefinedPoint> CreateAggregatedPoints(IList`1<RefinedPoint> sourcePoints, int clusterStartIndex, int clusterCount, double currentAlignedArgument);
}
public enum DevExpress.Charts.Native.AggregateFunctionNative : Enum {
    public int value__;
    public static AggregateFunctionNative Default;
    public static AggregateFunctionNative None;
    public static AggregateFunctionNative Average;
    public static AggregateFunctionNative Minimum;
    public static AggregateFunctionNative Maximum;
    public static AggregateFunctionNative Sum;
    public static AggregateFunctionNative Count;
    public static AggregateFunctionNative Histogram;
    public static AggregateFunctionNative Financial;
    public static AggregateFunctionNative Custom;
}
public static class DevExpress.Charts.Native.AggregationCalculator : object {
    public static int ValuesCount;
    public static Double[] CreateArray();
    public static Double[] CreateArray(double defaultValue);
    public static Double[] CreateArray(double value1, double value2, double value3, double value4);
    public static IAggregationCalculator Create(AggregateFunctionNative aggregationFunction, int valuesDimension, Type pointInterfaceType, bool isAggregationSupportedBySeries);
}
public class DevExpress.Charts.Native.AggregationIntervalsInfo : object {
    [CompilerGeneratedAttribute]
private bool <UseUnderflow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<double> <Intervals>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinAxisValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxAxisValue>k__BackingField;
    [CompilerGeneratedAttribute]
private double <IntervalWidth>k__BackingField;
    public bool UseUnderflow { get; private set; }
    public bool UseOverflow { get; private set; }
    public List`1<double> Intervals { get; private set; }
    public bool IsValid { get; }
    public double MinAxisValue { get; private set; }
    public double MaxAxisValue { get; private set; }
    public double IntervalWidth { get; private set; }
    public AggregationIntervalsInfo(List`1<double> intervals, double intervalWidth, double minAxisValue, double maxAxisValue, bool useUnderflow, bool useOverflow);
    [CompilerGeneratedAttribute]
public bool get_UseUnderflow();
    [CompilerGeneratedAttribute]
private void set_UseUnderflow(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseOverflow();
    [CompilerGeneratedAttribute]
private void set_UseOverflow(bool value);
    [CompilerGeneratedAttribute]
public List`1<double> get_Intervals();
    [CompilerGeneratedAttribute]
private void set_Intervals(List`1<double> value);
    public bool get_IsValid();
    [CompilerGeneratedAttribute]
public double get_MinAxisValue();
    [CompilerGeneratedAttribute]
private void set_MinAxisValue(double value);
    [CompilerGeneratedAttribute]
public double get_MaxAxisValue();
    [CompilerGeneratedAttribute]
private void set_MaxAxisValue(double value);
    [CompilerGeneratedAttribute]
public double get_IntervalWidth();
    [CompilerGeneratedAttribute]
private void set_IntervalWidth(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.AggregationPointFilter : AggregationPointFilterBase {
    private ActualScaleTypeCore scaleTypeX;
    private ScaleOptionsInfo scaleOptionsInfo;
    public AggregationPointFilter(RefinedSeries refinedSeries);
    private bool IsSeriesContainsErrorBars();
    private bool ShouldAddMissingPoints(AxisScaleTypeMap axisXScaleMap, MissingArgumentsCalculator missingPointsCreator, double nextInternalArg, double refinedArg);
    private double AlignArgument(double argument, AxisScaleTypeMap axisXScaleMap);
    private PointsCacheEntry ClusterPoints(IList`1<RefinedPoint> points, AxisScaleTypeMap axisXScaleMap, AggregatedPointsCreatorBase aggregatedPointsCreator, MissingArgumentsCalculator missingPointsCreator);
    private IAggregationCalculator CreateAggregationCalculator(AxisScaleTypeMap axisXScaleTypeMap);
    protected virtual PointsCacheEntry GetAggregatedPointsEntry(IList`1<RefinedPoint> points, AxisScaleTypeMap axisXScaleTypeMap);
    protected virtual object GetPointsCacheKey();
    protected virtual bool IsEnabled();
    protected virtual bool IsNeedInvalidate();
    protected virtual bool IsNeedClearCache();
    protected virtual void SaveParameters();
    public ArgumentsWithoutGapsInfo GetArgumentsWithoutGaps();
}
public class DevExpress.Charts.Native.AggregationPointFilter3D : AggregationPointFilterBase {
    private ScaleOptionsInfo measureUnitX;
    private ScaleOptionsInfo measureUnitZ;
    private ActualScaleTypeCore scaleTypeX;
    private ActualScaleTypeCore scaleTypeZ;
    public AggregationPointFilter3D(RefinedSeries refinedSeries);
    private RefinedPoint CreateAggregatedPoint(RefinedPointsCluster3D cluster, Double[] values, AxisScaleTypeMap axisXScaleTypeMap, CorePointState state);
    private IList`1<RefinedPoint> GetAggregatedFunctionPoints(IList`1<RefinedPointsCluster3D> clusteredPoints, IAggregationCalculator calculator, AxisScaleTypeMap axisXScaleTypeMap);
    private IList`1<RefinedPoint> GetAggregatedSourcePoints(IList`1<RefinedPointsCluster3D> clusteredPoints, AxisScaleTypeMap axisXScaleTypeMap);
    protected virtual PointsCacheEntry GetAggregatedPointsEntry(IList`1<RefinedPoint> points, AxisScaleTypeMap axisXScaleTypeMap);
    protected virtual object GetPointsCacheKey();
    protected virtual bool IsEnabled();
    protected virtual bool IsNeedInvalidate();
    protected virtual bool IsNeedClearCache();
    protected virtual void SaveParameters();
}
public abstract class DevExpress.Charts.Native.AggregationPointFilterBase : PointsFilter {
    private Dictionary`2<object, PointsCacheEntry> pointsCache;
    private ICustomAggregateFunction userCalculator;
    private AggregateFunctionNative aggregateFunction;
    private ProcessMissingPointsModeNative processMissingPoints;
    private bool isAutogeneratedPoints;
    protected internal Dictionary`2<object, PointsCacheEntry> PointsCache { get; }
    protected ICustomAggregateFunction UserCalculator { get; }
    protected AggregateFunctionNative AggregateFunction { get; }
    protected ProcessMissingPointsModeNative ProcessMissingPoints { get; }
    public AggregationPointFilterBase(RefinedSeries refinedSeries);
    private static int GetAggregatedPointIndex(PointsCacheEntry cacheEntry, double argument, bool isFirst);
    private static int GetPointIndex(PointsFilterUpdateInfo updateInfo, double argument, bool isFirst);
    private static double FindRealPointArgument(AxisScaleTypeMap scaleMap, RefinedPoint point, bool isFirst);
    protected internal Dictionary`2<object, PointsCacheEntry> get_PointsCache();
    protected ICustomAggregateFunction get_UserCalculator();
    protected AggregateFunctionNative get_AggregateFunction();
    protected ProcessMissingPointsModeNative get_ProcessMissingPoints();
    private ProcessMissingPointsModeNative GetProcessMissingPoints();
    private AggregateFunctionNative GetAggregateFunction();
    private ICustomAggregateFunction GetCustomAggregateFunction();
    private PointsFilterUpdateInfo ProcessUpdate(PointsCacheEntry cacheEntry, PointsFilterUpdateInfo updateInfo);
    private List`1<DoubleLimits> UpdateArgumentIntervals(List`1<DoubleLimits> argumentsWithoutGaps, List`1<DoubleLimits> newArgumentIntervals);
    protected ScaleOptionsInfo GetScaleOptionsInfo(IAxisData axisData);
    protected bool IsAxisAggregationEnabled(IAxisData axisData, ISeriesView seriesView, ActualScaleTypeCore seriesScaleType);
    protected abstract virtual PointsCacheEntry GetAggregatedPointsEntry(IList`1<RefinedPoint> points, AxisScaleTypeMap axisXScaleTypeMap);
    protected abstract virtual object GetPointsCacheKey();
    protected abstract virtual bool IsEnabled();
    protected abstract virtual bool IsNeedInvalidate();
    protected virtual bool IsNeedClearCache();
    protected virtual void SaveParameters();
    protected virtual IList`1<RefinedPoint> Recalculate(IList`1<RefinedPoint> initialPoints);
    protected virtual IList`1<RefinedPoint> GetCachedPoints();
    public virtual void ClearCache();
    public virtual bool Update();
    public virtual PointsFilterUpdateInfo Update(PointsFilterUpdateInfo updateInfo);
}
internal class DevExpress.Charts.Native.AggregatorUpdateAction : object {
    private CommonActionType updateType;
    public CommonActionType UpdateType { get; }
    public AggregatorUpdateAction(CommonActionType updateType);
    public CommonActionType get_UpdateType();
}
internal class DevExpress.Charts.Native.AggregatorUpdatesExecutor : object {
    private SeriesController seriesController;
    public AggregatorUpdatesExecutor(SeriesController seriesController);
    private void UpdateCrosshairData(bool shouldUpdateCrosshair, ICollection`1<RefinedSeriesUpdateInfo> seriesUpdateInfo, ICollection`1<RefinedSeriesPointsUpdateInfo> pointsUpdateInfo);
    private void UpdatePointsIndices();
    private void UpdateArgumentScale();
    public sealed virtual SeriesControllerChanges Execute(IExecutorContext context);
}
public class DevExpress.Charts.Native.AlignedRangeControlGridUnit`1 : RangeControlGridUnit {
    private T alignment;
    public T Alignment { get; }
    public AlignedRangeControlGridUnit`1(T alignment, double spacing, double step, double offset);
    public T get_Alignment();
}
public static class DevExpress.Charts.Native.AnnotationLayoutCalculator : object {
    private static int defaultTailOffset;
    private static AnnotationLocation[] GetPriorityHorizontalLocations(AnnotationLocation location);
    private static AnnotationLocation[] GetPriorityVerticalLocations(AnnotationLocation location);
    private static double CalculateLayoutCriteria(GRealRect2D annotationBounds, List`1<GRealRect2D> reservedRects, GRealRect2D constraintBounds);
    public static GRealRect2D CalculateLocationBounds(GRealPoint2D anchorPoint, GRealSize2D size, AnnotationLocation location, GRealPoint2D offset, double cursorOffset);
    private static GRealPoint2D CalculateLayoutOffset(GRealPoint2D initOffset, bool showTail);
    private static void ApplyLayoutParams(IAnnotationLayout layout, GRealRect2D bounds, AnnotationLocation location, GRealPoint2D offset);
    private static void CalculateAutoLayout(IAnnotationLayout layout, AnnotationLocation[] priorityLocations, GRealRect2D constraintBounds, List`1<GRealRect2D> reservedRects);
    private static void CorrectLayoutByConstraint(IAnnotationLayout layout, GRealRect2D constraintBounds);
    public static void CalculateAutoLayout(IAnnotationLayout layout, AnnotationLocation defaultLocation, GRealRect2D constraintBounds);
    public static void CalculateAutoLayout(List`1<IAnnotationLayout> labels, GRealRect2D constraintBounds);
    public static void CalculateAutoLayout(List`1<IAnnotationLayout> labels);
    public static void CalculateAutoLayout(IAnnotationLayout layout);
}
public enum DevExpress.Charts.Native.AnnotationLocation : Enum {
    public int value__;
    public static AnnotationLocation TopRight;
    public static AnnotationLocation TopLeft;
    public static AnnotationLocation BottomRight;
    public static AnnotationLocation BottomLeft;
}
public class DevExpress.Charts.Native.AreaGeometrySplittedStripCreator : AreaGeometryStripCreator {
    private IStripSplitter stripSplitter;
    public AreaGeometrySplittedStripCreator(IStripSplitter stripSplitter);
    protected virtual IGeometryStrip ProcessIntervalsStrip(IGeometryStrip strip, List`1<IGeometryStrip> strips, IList`1<RefinedPoint> points, int index, List`1<ColoredStripInfo> coloredStripInfos);
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
    internal virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.AreaGeometryStripCreator : LineGeometryStripCreator {
    protected internal bool ShouldAddEmptyStrip { get; }
    protected internal virtual bool get_ShouldAddEmptyStrip();
    protected virtual IGeometryStrip AddStripElementCore(IList`1<RefinedPoint> points, int index, IGeometryStrip strip);
    protected internal virtual IGeometryStrip CreateStrip();
}
internal class DevExpress.Charts.Native.ArgumentCollectionContainer : object {
    private SortedCollection`1<PointArgument> sortedCollection;
    private double minDelta;
    private int leftMinDeltaIndex;
    private int rightMinDeltaIndex;
    private bool needRecalculateDelta;
    public double MinDelta { get; }
    public double get_MinDelta();
    private void UpdateMinDelta(int leftIndex, int rightIndex);
    private void CorrectIfNecessaryMinDelta(int insertedPointIndex);
    private void RecalculateMinDelta();
    public void Invalidate();
    public void InsertPointToCollection(PointArgument pointArgument);
    public void RemovePointFromCollection(PointArgument pointArgument);
}
public class DevExpress.Charts.Native.ArgumentDateTimeDataMemberContainer : ValueDateTimeDataMemberContainer {
    public ArgumentDateTimeDataMemberContainer(string dataMember, bool supportEmptyValue);
}
public class DevExpress.Charts.Native.ArgumentNumericDataMemberContainer : ValueNumericDataMemberContainer {
    public ArgumentNumericDataMemberContainer(string dataMember, bool supportEmptyValue);
}
public class DevExpress.Charts.Native.ArgumentQualitativeDataMemberContainer : ComparableDataMemberContainer`1<string> {
    protected string DefaultValue { get; }
    public object BoxedValue { get; }
    public ArgumentQualitativeDataMemberContainer(string dataMember, bool supportEmptyValue);
    protected virtual string get_DefaultValue();
    public virtual object get_BoxedValue();
    protected virtual bool IsCompatibleType(Type type);
    protected virtual bool IsEmptyValue(string value);
    protected virtual string ConvertValue(object value);
    protected virtual string ParseValue(object value);
}
public class DevExpress.Charts.Native.ArgumentsWithoutGapsInfo : object {
    [CompilerGeneratedAttribute]
private AxisScaleTypeMap <ScaleTypeMap>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DoubleLimits> <ArgumentsWithoutGaps>k__BackingField;
    public AxisScaleTypeMap ScaleTypeMap { get; public set; }
    public List`1<DoubleLimits> ArgumentsWithoutGaps { get; public set; }
    [CompilerGeneratedAttribute]
public AxisScaleTypeMap get_ScaleTypeMap();
    [CompilerGeneratedAttribute]
public void set_ScaleTypeMap(AxisScaleTypeMap value);
    [CompilerGeneratedAttribute]
public List`1<DoubleLimits> get_ArgumentsWithoutGaps();
    [CompilerGeneratedAttribute]
public void set_ArgumentsWithoutGaps(List`1<DoubleLimits> value);
}
public class DevExpress.Charts.Native.ArgumentTimeSpanDataMemberContainer : ValueTimeSpanDataMemberContainer {
    private bool supportEmptyValue;
    public bool SupportEmptyValue { get; }
    public ArgumentTimeSpanDataMemberContainer(string dataMember, bool supportEmptyValue);
    public virtual bool get_SupportEmptyValue();
}
public class DevExpress.Charts.Native.AverageAggregationCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private Double[] CalculateWithParts(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
    private Double[] CalculateWithSumAccumulation(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.AverageAggregationSingleValueCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private Double[] CalculateWithParts(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
    private Double[] CalculateWithSumAccumulation(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.AverageTrueRangeCalculator : object {
    private static int DesignTimePointsCount;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    public static bool IsCompatible(ISeriesView view);
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    private double CalcTrueRange(IFinancialPoint refinedPoint, IFinancialPoint preRefinedPoint);
    private double Max(double val1, double val2, double val3);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount);
}
public abstract class DevExpress.Charts.Native.AxesLayoutInteractionManagerBase : object {
    private IAxisData primaryAxisX;
    private IAxisData primaryAxisY;
    private List`1<GRealRect2D> insideAxesLabelBounds;
    private bool isZeroMode;
    private Nullable`1<double> intersectionValueX;
    private Nullable`1<double> intersectionValueY;
    private IAxisLabelLayout intersectionLabelLayoutX;
    private bool labelXIsOutside;
    private AxisLabelOverlappingResolver axisXOverlappingResolver;
    protected IAxisData PrimaryAxisX { get; }
    protected IAxisData PrimaryAxisY { get; }
    protected AxesLayoutInteractionManagerBase(IAxisData axisX, IAxisData axisY, bool isZeroMode);
    protected IAxisData get_PrimaryAxisX();
    protected IAxisData get_PrimaryAxisY();
    private bool IsPrimaryAxis(IAxisData axis);
    protected abstract virtual Nullable`1<double> GetIntersectionValueX();
    protected abstract virtual Nullable`1<double> GetIntersectionValueY();
    protected void ProcessIntersectionLabelLayout(IAxisData axis, IAxisLabelLayout intersectionLabelLayout, AxisLabelOverlappingResolver overlappingResolver, bool outsideLabels, int axisThickness, ITickmarksOwner tickmarks, double indentToAxis);
    protected Nullable`1<double> GetIntersectionInternalValue(IAxisData axis);
    protected void CacheAxisLabelBounds(GRealRect2D bounds);
    protected void ClearAxesLabelBounds();
}
public class DevExpress.Charts.Native.Axis3DMappingCore : SingleIntervalMappingCore {
    private GRealRect2D bounds;
    public GRealRect2D Bounds { get; }
    public Axis3DMappingCore(IAxisData axis, double axisLength, GRealRect2D bounds);
    public GRealRect2D get_Bounds();
}
[FlagsAttribute]
public enum DevExpress.Charts.Native.AxisActionType : Enum {
    public int value__;
    public static AxisActionType UpdateScaleMap;
    public static AxisActionType RemoveSeriesGroup;
    public static AxisActionType UpdatePointsFilter;
    public static AxisActionType UpdateSeriesGroup;
    public static AxisActionType UpdatePointsAggregation;
}
internal abstract class DevExpress.Charts.Native.AxisAggregationInterval : object {
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeMin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeMax>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnderflow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOverflow>k__BackingField;
    public object NativeMin { get; }
    public object NativeMax { get; }
    public double Min { get; private set; }
    public double Max { get; private set; }
    public bool IncludeMin { get; private set; }
    public bool IncludeMax { get; private set; }
    public bool IsUnderflow { get; private set; }
    public bool IsOverflow { get; private set; }
    protected AxisAggregationInterval(double min, double max, bool includeMin, bool includeMax, bool isUnderflow, bool isOverflow);
    public static string GetActualPattern(IAxisData axis, AxisAggregationInterval interval);
    public abstract virtual object get_NativeMin();
    public abstract virtual object get_NativeMax();
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(double value);
    [CompilerGeneratedAttribute]
public bool get_IncludeMin();
    [CompilerGeneratedAttribute]
private void set_IncludeMin(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeMax();
    [CompilerGeneratedAttribute]
private void set_IncludeMax(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsUnderflow();
    [CompilerGeneratedAttribute]
private void set_IsUnderflow(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOverflow();
    [CompilerGeneratedAttribute]
private void set_IsOverflow(bool value);
    public bool ContainsValue(double value);
    public string ToString(IAxisData axis);
    public virtual string ToString();
    public sealed virtual int CompareTo(AxisAggregationInterval obj);
}
public abstract class DevExpress.Charts.Native.AxisAggregationIntervalsCalculatorBase : object {
    protected AggregationIntervalsInfo CalculateAutoHistogramMode(IAxisData axis, IList`1<RefinedSeries> refinedSeries, Nullable`1<double> underflowValue, Nullable`1<double> overflowValue);
    protected AggregationIntervalsInfo CreateIntervals(double binWidth, Nullable`1<double> underflowValue, Nullable`1<double> overflowValue, IAxisData axis);
    protected abstract virtual double RoundValue(IAxisData axis, double value);
    protected abstract virtual double RoundUpValue(IAxisData axis, double value);
    protected abstract virtual SimpleStandardDeviationCalculator CreateAutoHistogramCalculator(IAxisData axis);
    protected virtual bool IsInvalidScaleMode(ScaleModeNative scaleMode);
    public abstract virtual bool UpdateIntervals(IAxisData axis, IList`1<RefinedSeries> refinedSeries);
}
public class DevExpress.Charts.Native.AxisCollectionBatchUpdateInfo : CollectionUpdateInfo`1<ICollection`1<IAxisData>> {
    public AxisCollectionBatchUpdateInfo(object sender, ChartCollectionOperation operation, ICollection`1<IAxisData> oldItem, int oldIndex, ICollection`1<IAxisData> newItem, int newIndex);
}
internal class DevExpress.Charts.Native.AxisCollectionBatchUpdateProcessor : AxisCollectionUpdateProcessorBase`1<AxisCollectionBatchUpdateInfo> {
    protected virtual IList`1<IUpdateAction> TypedProcess(AxisCollectionBatchUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.AxisCollectionUpdateInfo : CollectionUpdateInfo`1<IAxisData> {
    public AxisCollectionUpdateInfo(object sender, ChartCollectionOperation operation, IAxisData oldItem, int oldIndex, IAxisData newItem, int newIndex);
}
internal class DevExpress.Charts.Native.AxisCollectionUpdateProcessor : AxisCollectionUpdateProcessorBase`1<AxisCollectionUpdateInfo> {
    protected virtual IList`1<IUpdateAction> TypedProcess(AxisCollectionUpdateInfo updateInfo);
}
internal abstract class DevExpress.Charts.Native.AxisCollectionUpdateProcessorBase`1 : CollectionUpdateProcessor`1<T> {
    private IUpdateAction UpdateAxis(IAxisData axis, ChartCollectionOperation operation);
    protected IList`1<IUpdateAction> UpdateAxesCollection(IEnumerable`1<IAxisData> axesList, ChartCollectionOperation operation);
}
public class DevExpress.Charts.Native.AxisContainer : object {
    private IList`1<IAxisData> axes;
    private IList`1<IAxisData> secondaryAxes;
    private IList`1<IAxisData> totalSecondaryAxes;
    private IAxisData primaryAxis;
    public IList`1<IAxisData> Axes { get; }
    public IList`1<IAxisData> SecondaryAxes { get; }
    public IList`1<IAxisData> TotalSecondaryAxes { get; }
    public IAxisData PrimaryAxis { get; }
    public AxisContainer(IList`1<IAxisData> axes, IList`1<IAxisData> allSecondaryAxes);
    public IList`1<IAxisData> get_Axes();
    public IList`1<IAxisData> get_SecondaryAxes();
    public IList`1<IAxisData> get_TotalSecondaryAxes();
    public IAxisData get_PrimaryAxis();
}
public static class DevExpress.Charts.Native.AxisCoordCalculator : object {
    public static double GetCoord(IMinMaxValues range, double value, double dimension);
    public static double GetClampedCoord(IMinMaxValues range, double value, double dimension);
    public static double GetInternalValue(double min, double max, double ratio);
    public static double GetCoord(IMinMaxValues range, double value, double dimension, bool clamped);
}
public class DevExpress.Charts.Native.AxisDateTimeGridMapping : AxisGridMapping {
    private DateTimeMeasureUnitNative alignment;
    protected AxisDateTimeMap Map { get; }
    public double Offset { get; }
    public AxisDateTimeGridMapping(AxisDateTimeMap map, DateTimeGridAlignmentNative alignment, double offset);
    protected AxisDateTimeMap get_Map();
    public virtual double get_Offset();
    public virtual double InternalToAligned(double internalValue);
    public virtual double AlignedToInternal(double alignedValue);
}
public class DevExpress.Charts.Native.AxisDateTimeIntervalsMap : AxisDateTimeMap {
    private IAxisData axis;
    private DateTimeAxisIntervalsContainer intervalsContainer;
    protected IAxisData Axis { get; }
    internal DateTimeAxisIntervalsContainer IntervalsContainer { get; }
    public AxisDateTimeIntervalsMap(IAxisData axis, DateTimeMeasureUnitNative dateTimeMeasureUnit, int measureUnitMultiplier, IWorkdaysOptions workdaysOptions, IWorkTimeRuleCollection workTimeRules, AggregationIntervalsInfo info);
    protected IAxisData get_Axis();
    internal DateTimeAxisIntervalsContainer get_IntervalsContainer();
    protected virtual void Assign(AxisDateTimeMap map);
    protected virtual object GetUpdatedMin(double min);
    public virtual double InternalToRefined(double value);
    public virtual double RefinedToInternal(double value);
    public virtual object InternalToNative(double value);
    public virtual object InternalToNativeString(double value);
    public virtual object InternalToNativeInterval(double value);
    public virtual object InternalToNativeValue(double value);
    public virtual object InternalToNative(double value, DateTimeMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual double RefinedToInternal(double value, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public virtual double InternalToRefined(double value, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public virtual object InternalToNativeAligned(double alignedValue, DateTimeMeasureUnitNative alignment, double measureUnitMultiplier);
    public virtual double GetNextRefinedValueByMeasureUnit(double value);
    public virtual double NativeToInternal(object value);
    public virtual bool IsAxisValueVisible(object axisValue);
    public virtual AxisScaleTypeMap Clone();
}
public class DevExpress.Charts.Native.AxisDateTimeIntervalsWithoutGapsMap : AxisDateTimeIntervalsMap {
    private DateTimeAxisIntervalsMapWithoutGapsCalculator calculator;
    public bool SkipGaps { get; }
    public AxisDateTimeIntervalsWithoutGapsMap(IAxisData axis, DateTimeMeasureUnitNative dateTimeMeasureUnit, int measureUnitMultiplier, IWorkdaysOptions workdaysOptions, IWorkTimeRuleCollection workTimeRules, AggregationIntervalsInfo info, List`1<DoubleLimits> dataLimits);
    public virtual bool get_SkipGaps();
    public virtual double NativeToInternal(object value);
    public virtual object InternalToNative(double value, DateTimeMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual double RefinedToInternal(double value, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public virtual object InternalToNativeAligned(double alignedValue, DateTimeMeasureUnitNative alignment, double measureUnitMultiplier);
    public virtual object InternalToNativeString(double value);
    public virtual object InternalToNativeInterval(double value);
    public virtual object InternalToNativeValue(double value);
    public virtual bool IsAxisValueVisible(object axisValue);
    public virtual void UpdateArgumentsWithoutGaps(List`1<DoubleLimits> seriesArgumentsWithoutGaps);
    public virtual List`1<DoubleLimits> GetArgumentsWithoutGaps();
    internal Dictionary`2<Tuple`2<byte, int>, List`1<ValuesContainer<DateTime, byte>>> ValuesCacheAccessor();
}
public class DevExpress.Charts.Native.AxisDateTimeMap : AxisScaleTypeMap {
    private DateTimeMeasureUnitNative mapMeasureUnit;
    private int mapMeasureUnitMultiplier;
    private IWorkdaysOptions workdaysOptions;
    private WorkTimeRuleSetCore workTimeRules;
    private IWorkTimeRuleCollection initialWorkTimeRules;
    private Dictionary`2<DateTimeMeasureUnitNative, SortedList`2<DateTime, double>> internalCoordsOfCustomDatesCache;
    private double refinedValuesInMeasureUnit;
    private DateTime minValue;
    private double min;
    public IWorkdaysOptions WorkdaysOptions { get; }
    public IWorkTimeRuleCollection InitialWorkTimeRules { get; }
    public double Min { get; }
    public ActualScaleTypeCore ScaleType { get; }
    public object DefaultAxisValue { get; }
    public DateTimeMeasureUnitNative MeasureUnit { get; }
    public int MeasureUnitMultiplier { get; }
    public bool IsWorkdaysEnabled { get; }
    public bool IsWorkTimeEnabled { get; }
    public AxisDateTimeMap(IWorkdaysOptions workdaysOptions, IWorkTimeRuleCollection workTimeRules);
    public AxisDateTimeMap(DateTimeMeasureUnitNative dateTimeMeasureUnit, int measureUnitMultiplier, IWorkdaysOptions workdaysOptions, IWorkTimeRuleCollection workTimeRules);
    public IWorkdaysOptions get_WorkdaysOptions();
    public IWorkTimeRuleCollection get_InitialWorkTimeRules();
    public double get_Min();
    public virtual ActualScaleTypeCore get_ScaleType();
    public virtual object get_DefaultAxisValue();
    public DateTimeMeasureUnitNative get_MeasureUnit();
    public int get_MeasureUnitMultiplier();
    public bool get_IsWorkdaysEnabled();
    public bool get_IsWorkTimeEnabled();
    private sealed virtual override double DevExpress.Charts.Native.IPriorScaleMap.NativeToInternal(object value);
    private sealed virtual override object DevExpress.Charts.Native.IPriorScaleMap.InternalToNative(double value);
    private sealed virtual override void DevExpress.Charts.Native.IPriorScaleMap.UpdateMin(double min);
    private long CalcExcludedMeasureUnitsInternal(DateTime dateTime, DateTimeMeasureUnitNative measureUnit);
    private TimeSpan CalcLastDayTime(double muFromBeginOfDay, TimeIntervalSetCore sortedRestIntervals, DateTimeMeasureUnitNative measureUnit);
    private int CalcExcludedMeasureUnitsInDay(TimeIntervalSetCore restTimeIntervals, DateTimeMeasureUnitNative measureUnit);
    private int CalcExcludedMeasureUnitsInLastDay(DateTime dateTime, DateTimeMeasureUnitNative measureUnit);
    private bool IsEarlierOnThisWeek(DayOfWeek dayOfWeek1, DayOfWeek dayOfWeek2);
    private DateTime AlignToNextWorkday(DateTime value, DateTimeMeasureUnitNative measureUnit);
    private void CreateInternalCoordsOfCustomDatesCache(DateTimeMeasureUnitNative measureUnit);
    private double DateTimeToInternal(DateTime value, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    private WorkTimeStrategy CreateWorkTimeStrategy(DateTimeMeasureUnitNative measureUnit, double value);
    private Nullable`1<DateTime> InternalToDateTime(double value, DateTimeMeasureUnitNative measureUnit);
    private long CalcExcludedMeasureUnits(DateTime date, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    protected virtual void Assign(AxisDateTimeMap map);
    protected virtual object GetUpdatedMin(double min);
    public virtual double NativeToInternal(object value);
    public virtual double NativeToRefined(object value);
    public virtual object InternalToNative(double value);
    public virtual double InternalToRefined(double value);
    public virtual double RefinedToInternal(double value);
    public virtual bool TryNativeToInternal(object value, Double& result);
    public virtual bool TryNativeToRefined(object value, Double& result);
    public virtual double SeriesPointToRefined(ISeriesPointArgument point);
    public virtual double SeriesPointToInternal(ISeriesPointArgument point);
    public virtual object ConvertValue(object value, CultureInfo culture);
    public virtual object TryParse(object value, CultureInfo culture);
    public virtual bool IsCompatible(object value);
    public virtual bool IsCompatibleType(Type type);
    public virtual bool IsAxisValueVisible(object axisValue);
    public virtual AxisScaleTypeMap Clone();
    public virtual object InternalToNative(double value, DateTimeMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual double RefinedToInternal(double value, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public virtual double InternalToRefined(double value, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public virtual double InternalToRefinedExact(double value);
    public virtual double RefinedToInternalExact(double value);
    public virtual object RefinedToNative(double value);
    public virtual double GetNextRefinedValueByMeasureUnit(double value);
    public virtual object InternalToNativeAligned(double alignedValue, DateTimeMeasureUnitNative alignment, double measureUnitMultiplier);
    internal double CalcExcludedMeasureUnitsAccessor(DateTime date, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
}
public class DevExpress.Charts.Native.AxisDateTimeWithoutGapsMap : AxisDateTimeMap {
    private DateTimeMapWithoutGapsCalculator calculator;
    public bool SkipGaps { get; }
    public AxisDateTimeWithoutGapsMap(DateTimeMeasureUnitNative dateTimeMeasureUnit, int measureUnitMultiplier, IWorkdaysOptions workdaysOptions, IWorkTimeRuleCollection workTimeRules, List`1<DoubleLimits> dataLimits);
    public virtual bool get_SkipGaps();
    private object InternalToNativeWithGaps(double value);
    public virtual double NativeToInternal(object value);
    public virtual object InternalToNative(double value, DateTimeMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual double RefinedToInternal(double value, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public double RefinedToInternalWithGaps(double value);
    public double InternalToRefinedWithGaps(double value);
    public virtual object InternalToNativeAligned(double alignedValue, DateTimeMeasureUnitNative alignment, double measureUnitMultiplier);
    public virtual bool IsAxisValueVisible(object axisValue);
    public virtual AxisScaleTypeMap Clone();
    public virtual void UpdateArgumentsWithoutGaps(List`1<DoubleLimits> seriesArgumentsWithoutGaps);
    public virtual List`1<DoubleLimits> GetArgumentsWithoutGaps();
    internal Dictionary`2<Tuple`2<DateTimeMeasureUnitNative, int>, List`1<ValuesContainer<DateTime, DateTimeMeasureUnitNative>>> ValuesCacheAccessor();
}
public class DevExpress.Charts.Native.AxisElementUpdateInfo : PropertyUpdateInfo {
    private IAxisData axis;
    public IAxisData Axis { get; }
    public AxisElementUpdateInfo(object sender, IAxisData axis);
    public IAxisData get_Axis();
}
internal class DevExpress.Charts.Native.AxisElementUpdateProcessor : TypedUpdateProcessor`1<AxisElementUpdateInfo> {
    protected virtual IList`1<IUpdateAction> TypedProcess(AxisElementUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.AxisGridData : AxisGridTextDataBase {
    private static double Shift;
    private double gridSpacing;
    private int minorStep;
    private int minorCount;
    private AxisGridItemList items;
    private AxisGridItemList minorItems;
    private List`1<InterlacedData> interlacedData;
    private GridValueProvider gridValueProvider;
    [CompilerGeneratedAttribute]
private GridLayoutModeNative <GridLayoutMode>k__BackingField;
    public AxisGridItemList Items { get; }
    public AxisGridItemList MinorItems { get; }
    public List`1<InterlacedData> InterlacedData { get; }
    public GridLayoutModeNative GridLayoutMode { get; private set; }
    public double GridSpacing { get; }
    public AxisGridData(IAxisData axis, IAxisGridMapping mapping, IMinMaxValues visualRange, bool isRadarAxis, int minorCount, double gridSpacing, GridLayoutModeNative gridLayoutMode);
    private static GridValueProvider CreateGridValueProvider(double gridSpacing, IAxisGridMapping mapping, IMinMaxValues visualRange);
    public AxisGridItemList get_Items();
    public AxisGridItemList get_MinorItems();
    public List`1<InterlacedData> get_InterlacedData();
    [CompilerGeneratedAttribute]
public GridLayoutModeNative get_GridLayoutMode();
    [CompilerGeneratedAttribute]
private void set_GridLayoutMode(GridLayoutModeNative value);
    public double get_GridSpacing();
    private void GetGridValue(GridValueProvider provider, int index, GridLayoutModeNative gridLayoutMode, Double[]& values, Double[]& labelValues);
    private void ExtendRadarAxisRange();
    private void FillAutomaticValues(GridLayoutModeNative gridLayoutMode);
    private bool CreateStripsAndCustomLabels();
    private void CreateMajorValues(GridLayoutModeNative gridLayoutMode);
    private bool AddMajorValues(double actualOffset, GridLayoutModeNative gridLayoutMode, Double[] values, Double[] labelValues, int index);
    private void CreateMinorValues();
    private void CreateInterlacedData();
    private void CreateCustomInterlacedData();
    private bool IsValueWithinRange(double value, double min, double max);
    private bool IsValidValue(double value);
    private void AddCustomValue(double value, bool gridLineVisible);
    private void AddMajorValue(double value, double labelValue);
    private void AddValueCore(double value, double labelValue, bool isAutogenerated, bool gridLineVisible);
    public int GridIndex(double value);
    public bool IsValueInRange(double value);
}
public class DevExpress.Charts.Native.AxisGridItem : ValueType {
    private double value;
    private double labelValue;
    private bool isAutogenerated;
    private bool visible;
    private bool gridLineVisible;
    public double Value { get; }
    public double LabelValue { get; }
    public bool IsAutogenerated { get; }
    public bool Visible { get; }
    public bool GridLineVisible { get; }
    public AxisGridItem(double value, double labelValue, bool isAutogenerated, bool visible, bool gridLineVisible);
    public double get_Value();
    public double get_LabelValue();
    public bool get_IsAutogenerated();
    public bool get_Visible();
    public bool get_GridLineVisible();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.AxisGridItemList : object {
    private List`1<AxisGridItem> innerItems;
    private double minVisibleValue;
    private double maxVisibleValue;
    private int visibleItemsCount;
    private int invisibleItemsCount;
    private List`1<double> visibleTickMarkValues;
    private List`1<double> visibleGridLineValues;
    public List`1<double> VisibleTickMarkValues { get; }
    public List`1<double> VisibleGridLineValues { get; }
    public int VisibleItemsCount { get; }
    public int InvisibleItemsCount { get; }
    public double MinVisibleValue { get; }
    public double MaxVisibleValue { get; }
    public AxisGridItem Item { get; public set; }
    public int Count { get; }
    public AxisGridItem First { get; }
    public AxisGridItem Last { get; }
    public List`1<double> get_VisibleTickMarkValues();
    public List`1<double> get_VisibleGridLineValues();
    public int get_VisibleItemsCount();
    public int get_InvisibleItemsCount();
    public double get_MinVisibleValue();
    public double get_MaxVisibleValue();
    public AxisGridItem get_Item(int index);
    public void set_Item(int index, AxisGridItem value);
    public int get_Count();
    public AxisGridItem get_First();
    public AxisGridItem get_Last();
    private sealed virtual override IEnumerator`1<AxisGridItem> System.Collections.Generic.IEnumerable<DevExpress.Charts.Native.AxisGridItem>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void UpdateValues(AxisGridItem newItem);
    private void RemoveItem(AxisGridItem item);
    private void FillVisibleItems();
    private void Add(AxisGridItem item);
    private void Insert(int index, AxisGridItem item);
    public void AddUniqueValue(AxisGridItem value);
    public void AddValue(AxisGridItem value);
}
public abstract class DevExpress.Charts.Native.AxisGridMapping : object {
    private AxisScaleTypeMap map;
    private double offset;
    protected AxisScaleTypeMap Map { get; }
    public Transformation Transformation { get; }
    public double Offset { get; }
    public bool CanFloorAlignedValue { get; }
    protected AxisGridMapping(AxisScaleTypeMap map, double offset);
    protected AxisScaleTypeMap get_Map();
    public sealed virtual Transformation get_Transformation();
    public virtual double get_Offset();
    public virtual bool get_CanFloorAlignedValue();
    public sealed virtual bool IsCompatible(object value);
    public sealed virtual double NativeToInternal(object value);
    public virtual object InternalToNative(double alignedValue);
    public abstract virtual double InternalToAligned(double internalValue);
    public abstract virtual double AlignedToInternal(double alignedValue);
}
public abstract class DevExpress.Charts.Native.AxisGridTextDataBase : object {
    private IAxisData axis;
    private IAxisGridMapping mapping;
    private IMinMaxValues visualRange;
    private bool isRadarAxis;
    protected IAxisData Axis { get; }
    protected IAxisGridMapping Mapping { get; }
    protected IMinMaxValues VisualRange { get; }
    protected bool IsRadarAxis { get; }
    protected AxisGridTextDataBase(IAxisData axis, IAxisGridMapping mapping, IMinMaxValues visualRange, bool isRadarAxis);
    protected IAxisData get_Axis();
    protected IAxisGridMapping get_Mapping();
    protected IMinMaxValues get_VisualRange();
    protected bool get_IsRadarAxis();
    private double NormalizeStripValue(double value);
    private bool IsStripVisible(IStrip strip);
    private bool IsAxisValueVisible(object axisValue);
    private bool IsStripVisibleInGrid(IStrip strip);
    protected double CalcStripGridValue(IStrip strip);
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.AxisGridTextDataBase/<GetVisibleStrips>d__18")]
protected IEnumerable`1<IStrip> GetVisibleStrips();
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.AxisGridTextDataBase/<GetVisibleLabels>d__19")]
protected IEnumerable`1<ICustomAxisLabel> GetVisibleLabels();
}
public enum DevExpress.Charts.Native.AxisGroup : Enum {
    public int value__;
    public static AxisGroup ArgumentX;
    public static AxisGroup ArgumentY;
    public static AxisGroup Value;
}
public class DevExpress.Charts.Native.AxisInterval : ValueType {
    private IMinMaxValues range;
    private IMinMaxValues wholeRange;
    public IMinMaxValues Range { get; }
    public IMinMaxValues WholeRange { get; }
    public double Delta { get; }
    public AxisInterval(IMinMaxValues range, IMinMaxValues wholeRange);
    public IMinMaxValues get_Range();
    public IMinMaxValues get_WholeRange();
    public double get_Delta();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AxisInterval other);
}
public class DevExpress.Charts.Native.AxisIntervalLayout : object {
    private AxisInterval axisInterval;
    private Interval interval;
    public Interval Bounds { get; }
    public double End { get; }
    public AxisInterval Interval { get; }
    public IMinMaxValues Range { get; }
    public double Start { get; }
    public AxisIntervalLayout(AxisInterval axisInterval, int position, int length);
    private static AxisIntervalLayout CreateIntervalLayout(AxisInterval interval, double position, double nextPosition);
    public static List`1<AxisIntervalLayout> CreateIntervalsLayout(IIntervalContainer intervalContainer, int totalLength);
    public static List`1<AxisIntervalLayout> CreateIntervalsLayout(IList`1<AxisInterval> intervals, int totalLength, int separator);
    public Interval get_Bounds();
    public double get_End();
    public AxisInterval get_Interval();
    public IMinMaxValues get_Range();
    public double get_Start();
    public bool ValueWithinRange(double value);
}
public class DevExpress.Charts.Native.AxisIntervalLayoutCache : Dictionary`2<IXYDiagramPane, List`1<AxisIntervalLayout>> {
    public void SetAxisIntervalLayout(IXYDiagramPane pane, IEnumerable`1<AxisIntervalLayout> intervalLayouts);
    public Nullable`1<double> GetAxisValue(IXYDiagramPane pane, ITransformation transformation, int coordinate);
    private AxisIntervalLayout GetIntervalBounds(IXYDiagramPane pane, int location);
}
public class DevExpress.Charts.Native.AxisIntervalLayoutMapping : object {
    private AxisIntervalLayout axisIntervalLayout;
    private double deltaRange;
    private bool isIdentityTransform;
    private bool isZeroRange;
    private double min;
    private MinMaxValues minMaxValue;
    private double start;
    private ITransformation transformation;
    private AxisInterval axisInterval;
    private Interval interval;
    private MinMaxValues minMax;
    public double Min { get; }
    public double Max { get; }
    public AxisIntervalLayoutMapping(AxisIntervalLayout axisIntervalLayout, ITransformation transformation);
    public double get_Min();
    public double get_Max();
    public double GetClampedCoordCore(double value);
    private void UpdateTemporaryValues();
    public double GetClampedCoord(double value);
    public double GetCoord(double value);
    public double GetCoordCore(double value);
    public double GetCoordCoreRound(double value);
    public double GetInterimCoord(double value, bool clip, bool round);
    public double GetInterimCoordCore(double value, bool clip, bool round);
}
internal abstract class DevExpress.Charts.Native.AxisIntervalsContainer : object {
    private List`1<AxisAggregationInterval> intervals;
    private double intervalWidth;
    public int Count { get; }
    public AxisIntervalsContainer(AggregationIntervalsInfo info);
    public int get_Count();
    private int GetIndex(double value);
    protected abstract virtual double GetNextRefinedValue(double value);
    protected abstract virtual double GetPrevRefinedValue(double value);
    protected abstract virtual object GetNextNativeValue(object value);
    protected abstract virtual object GetPrevNativeValue(object value);
    protected abstract virtual AxisAggregationInterval CreateInterval(double min, double max, bool useUnderflow);
    protected abstract virtual AxisAggregationInterval CreateUnderflowInterval(double min, double max, bool useUnderflow);
    protected abstract virtual AxisAggregationInterval CreateOverflowInterval(double min, double max);
    public bool InternalToRefined(double value, Double& result);
    public bool RefinedToInternal(double value, Double& result);
    public bool InternalToNativeInterval(double value, bool convertToString, IAxisData axis, Object& result);
    public bool InternalToNativeValue(double value, Object& result);
    public bool NativeToInternal(object obj, IAxisData axis, Double& result);
}
public class DevExpress.Charts.Native.AxisIntervalsGenerator : object {
    private IAxisData axis;
    private IAutoScaleBreaksContainer autoScaleBreaksContainer;
    private double minLimit;
    private double maxLimit;
    public AxisIntervalsGenerator(IAxisData axis, IAutoScaleBreaksContainer autoScaleBreaksContainer, IMinMaxValues range);
    private int GetEdgeCounter(Edge edge, int counter);
    private IList`1<IMinMaxValues> EdgesToIntervalLimits(IList`1<Edge> edges);
    private IList`1<Edge> CreateEdges();
    public IList`1<IMinMaxValues> GenerateIntervalLimits();
    public IList`1<AxisInterval> GenerateIntervals();
}
public enum DevExpress.Charts.Native.AxisLabelAlignmentCore : Enum {
    public int value__;
    public static AxisLabelAlignmentCore Center;
    public static AxisLabelAlignmentCore Near;
    public static AxisLabelAlignmentCore Far;
}
public static class DevExpress.Charts.Native.AxisLabelOffsetCalculator : object {
    public static void CorrectLabelWithAlignment(List`1<IAxisLabelLayout> labels, IAxisData axis, AxisLabelAlignmentCore labelAlignment);
    public static void CorrectLabelForZeroMode(IAxisLabelLayout labelX, IAxisLabelLayout labelY, IAxisData axisX, IAxisData axisY, int axisYThickness, ITickmarksOwner axisYTickmarks, double indentToAxis, bool labelsYOutside, bool intersectionIsVisible);
    public static void CorrectSpecialLabelForCenterMode(IAxisLabelLayout labelX, IAxisLabelLayout labelY, IAxisData axisX, IAxisData axisY, bool labelsXOutside, bool labelsYOutside, double indentToAxis);
}
public class DevExpress.Charts.Native.AxisLabelOverlappingResolver : object {
    private static float angleMax;
    private static float angleStep;
    private State state;
    private OverlapState overlapState;
    private double maxHeight;
    private double maxWidth;
    private double maxWidthWithoutOverlap;
    private double currentAngle;
    private bool staggered;
    private bool isVertical;
    private List`1<IAxisLabelLayout> totalLabels;
    private List`1<IAxisLabelLayout> autoLabels;
    private List`1<IAxisLabelLayout> customLabels;
    private bool allowStagger;
    private bool allowRotate;
    private bool allowThinOut;
    private bool mirrored;
    private bool forceStagger;
    private bool useBoundsRound;
    private int indent;
    private bool adaptive;
    private bool canShowCustomWithAutoLabels;
    private GRealRect2D paneBounds;
    private bool RotationLimit { get; }
    public AxisLabelOverlappingResolver(List`1<IAxisLabelLayout> labels, IAxisData axis, bool isRadar, bool mirrored, bool useBoundsRound, GRealRect2D paneBounds);
    private bool get_RotationLimit();
    private void DivideLabels();
    private State NextState(State nextState);
    private void ResetOverlapState();
    private OverlapState CreateOverlapState(int itemsCount);
    private OverlapState CreateOverlapState();
    private GRealRect2D GetBounds(GRealRect2D bounds, bool roundBounds);
    private double GetValue(double value);
    private GRealRect2D InflateLabel(GRealRect2D rect);
    private bool IsOverlapped(List`1<IAxisLabelLayout> labels);
    private bool IsLabelVisible(IAxisLabelLayout label);
    private bool IsCorrectLabelSizeForRotatingComplete();
    private GRealSize2D RotatedSize(RotationMatrix rotation, GRealSize2D size);
    private void AnalyzeLabels();
    private GRealPoint2D GetStaggerOffset(bool rollback);
    private void DoStagger(List`1<IAxisLabelLayout> labels, bool rollback);
    private int CalculateStaggerIndex(List`1<IAxisLabelLayout> labels, bool forceStagger);
    private void DoRotate(List`1<IAxisLabelLayout> labels);
    private void DetectOverlapping(List`1<IAxisLabelLayout> labels);
    private void DoLimitedLabelsThinOut(List`1<IAxisLabelLayout> labels);
    private void DoLabelsThinOut(List`1<IAxisLabelLayout> visibleLabels, List`1<IAxisLabelLayout> otherLabels, bool useIndent, GRealRect2D initialNonOverlappedRect);
    private GRealRect2D CalculateLabelRect(GRealPoint2D location, GRealSize2D size, RotationMatrix transform);
    private void DoThinOut(List`1<IAxisLabelLayout> labels);
    private void LimitBounds(GRealRect2D labelsLimits);
    private void DoLabelsModifications(List`1[] labels);
    private void ProcessWholeLabels();
    private void ProcessSeparateLabels();
    public void ProcessCustomLabels();
    public void ProcessLabelsLimits(GRealRect2D labelsLimits);
    public void ProcessLabelsThinOut(GRealRect2D nonOverlappedRect);
    public void Process();
}
public class DevExpress.Charts.Native.AxisLabelPositionHelper : object {
    public static NearTextPosition Opposite(NearTextPosition position);
    public static GRealPoint2D CalculateLeftTopPoint(NearTextPosition position, GRealRect2D bounds, double angleDegree, double angleRadian, bool useBoundsRounding);
    public static TextRotation CalculateRotation(NearTextPosition position, double angleDegree);
}
public class DevExpress.Charts.Native.AxisLabelResolveOverlappingCache : object {
    private CacheItem[] items;
    private IResolveLabelsOverlappingAxis axis;
    public int Count { get; }
    public AxisLabelResolveOverlappingCache(IResolveLabelsOverlappingAxis axis, List`1<IAxisLabelLayout> labels);
    public int get_Count();
    public void Apply(List`1<IAxisLabelLayout> labels);
    public void Store();
}
public static class DevExpress.Charts.Native.AxisLabelRotationHelper : object {
    private static double GetValueHalf(double value, bool useRounding);
    private static double GetStrongRoundedValue(double value, bool useRounding);
    public static GRealPoint2D CalculateLeftTopPointForBottomPosition(GRealRect2D bounds, double angleDegree, double angleRadian, bool useBoundsRounding);
    public static GRealPoint2D CalculateLeftTopPointForLeftPosition(GRealRect2D bounds, double angleDegree, double angleRadian, bool useBoundsRounding);
    public static GRealPoint2D CalculateLeftTopPointForRightPosition(GRealRect2D bounds, double angleDegree, double angleRadian, bool useBoundsRounding);
    public static GRealPoint2D CalculateLeftTopPointForTopPosition(GRealRect2D bounds, double angleDegree, double angleRadian, bool useBoundsRounding);
    public static TextRotation CalculateRotationForBottomNearPosition(double degreeAngle);
    public static TextRotation CalculateRotationForLeftNearPosition(double degreeAngle);
    public static TextRotation CalculateRotationForRightNearPosition(double degreeAngle);
    public static TextRotation CalculateRotationForTopNearPosition(double degreeAngle);
    public static GRealPoint2D[] CalculateRotatedItemPoints(GRealRect2D bounds, double radianAngle);
    public static GRealPoint2D CalculateOffset(TextRotation rotation, GRealRect2D rect, double radianAngle);
    public static LineStrip RotateRectangleOverPoint(GRealRect2D rectangle, GRealPoint2D basePoint, double radianAngle);
}
public abstract class DevExpress.Charts.Native.AxisMappingCore : object {
    private IAxisData axis;
    private double axisLength;
    private double cutAxisLength;
    protected IAxisData Axis { get; }
    protected double CutAxisLength { get; }
    public double AxisLength { get; }
    protected AxisMappingCore(IAxisData axis, double axisLength);
    protected IAxisData get_Axis();
    protected double get_CutAxisLength();
    public sealed virtual double get_AxisLength();
    public static IAxisMappingCore Create(IIntervalLayoutProvider intervalLayoutProvider, IAxisData axis, double length);
    private double ApplyReverse(double value);
    private double GetCoord(double min, double max, double value, double dimension);
    private double GetAxisValueInternal(double value, bool exactValue);
    private double GetClampedAxisValueInternal(double value, bool exactValue);
    protected abstract virtual IntervalLayout GetIntervalLayout(double value, bool exactLayout);
    protected abstract virtual IntervalLayout GetIntervalLayoutByCoordinate(double coordinate);
    protected virtual IntervalLayout GetNearestIntervalLayout(double coordinate);
    public sealed virtual double GetAxisValue(double value);
    public sealed virtual double GetExactAxisValue(double value);
    public sealed virtual double GetRoundedAxisValue(double value);
    public sealed virtual double GetRoundedExactAxisValue(double value);
    public sealed virtual double GetClampedAxisValue(double value);
    public sealed virtual double GetClampedExactAxisValue(double value);
    public sealed virtual double GetRoundedClampedAxisValue(double value);
    public sealed virtual double GetInternalCoord(double value);
    public sealed virtual int GetRoundedInterval(double interval);
    public sealed virtual MinMaxValues GetCoordDiapasonInternal(double value, int diapason);
}
public class DevExpress.Charts.Native.AxisNumericalIntervalsMap : AxisNumericalMap {
    private IAxisData axis;
    private NumericAxisIntervalsContainer intervalsContainer;
    public object DefaultAxisValue { get; }
    public AxisNumericalIntervalsMap(AggregationIntervalsInfo info, IAxisData axis);
    public virtual object get_DefaultAxisValue();
    public virtual object InternalToNative(double value);
    public object InternalToNativeString(double value);
    public sealed virtual object InternalToNativeInterval(double value);
    public sealed virtual object InternalToNativeValue(double value);
    public virtual double InternalToRefined(double value);
    public virtual double RefinedToInternal(double value);
    public virtual double NativeToInternal(object value);
    public virtual double RefinedToInternalExact(double value);
    public virtual double GetNextRefinedValueByMeasureUnit(double value);
    public virtual AxisScaleTypeMap Clone();
}
public class DevExpress.Charts.Native.AxisNumericalMap : AxisScaleTypeMap {
    protected static double DoubleInaccuracy;
    private Nullable`1<double> measureUnit;
    public Nullable`1<double> MeasureUnit { get; }
    public ActualScaleTypeCore ScaleType { get; }
    public object DefaultAxisValue { get; }
    public AxisNumericalMap(double measureUnit);
    public Nullable`1<double> get_MeasureUnit();
    public virtual ActualScaleTypeCore get_ScaleType();
    public virtual object get_DefaultAxisValue();
    protected virtual Transformation CreateTransformation(IAxisData axis);
    public virtual double NativeToInternal(object value);
    public virtual double NativeToRefined(object value);
    public virtual bool TryNativeToInternal(object value, Double& result);
    public virtual bool TryNativeToRefined(object value, Double& result);
    public virtual object InternalToNative(double value);
    public virtual double InternalToRefined(double value);
    public virtual double RefinedToInternal(double value);
    public virtual double SeriesPointToRefined(ISeriesPointArgument point);
    public virtual double SeriesPointToInternal(ISeriesPointArgument point);
    public virtual object ConvertValue(object value, CultureInfo culture);
    public virtual object TryParse(object value, CultureInfo culture);
    public virtual bool IsCompatible(object value);
    public virtual bool IsCompatibleType(Type type);
    public virtual AxisScaleTypeMap Clone();
    public virtual double InternalToRefinedExact(double value);
    public virtual double RefinedToInternalExact(double value);
    public virtual object RefinedToNative(double value);
    public virtual double GetNextRefinedValueByMeasureUnit(double value);
    private sealed virtual override double DevExpress.Charts.Native.IPriorScaleMap.NativeToInternal(object value);
    private sealed virtual override object DevExpress.Charts.Native.IPriorScaleMap.InternalToNative(double value);
    private sealed virtual override void DevExpress.Charts.Native.IPriorScaleMap.UpdateMin(double min);
}
public class DevExpress.Charts.Native.AxisNumericGridMapping : AxisGridMapping {
    private double alignment;
    private NumericStartPointCore gridAlignmentStartPoint;
    private AxisNumericalMap NumericMap { get; }
    public bool CanFloorAlignedValue { get; }
    public AxisNumericGridMapping(AxisNumericalMap map, double alignment, double offset, NumericStartPointCore gridAlignmentStartPoint);
    private AxisNumericalMap get_NumericMap();
    public virtual bool get_CanFloorAlignedValue();
    public virtual double InternalToAligned(double internalValue);
    public virtual double AlignedToInternal(double alignedValue);
}
public class DevExpress.Charts.Native.AxisPaneContainer : Dictionary`2<IAxisData, IList`1<IPane>> {
    public AxisPaneContainer(PaneAxesContainerRepository paneAxisRepository);
    public IList`1<IPane> GetPanes(IAxisData axis);
    public IPane GetFirstPaneByAxes(IAxisData axisX, IAxisData axisY);
    public bool IsScrollingZoomingEnabledForAxis(IAxisData axis);
    private void RegisterAxis(IAxisData axis, IPane pane);
}
public class DevExpress.Charts.Native.AxisPatternDataProvider : PatternDataProvider {
    private string patternConstant;
    public AxisPatternDataProvider(string patternConstant);
    protected virtual bool TryGetValue(Object& value);
    private object GetValueFromAxisAggregationInterval(AxisAggregationInterval interval);
    public virtual bool CheckContext(object value);
}
public static class DevExpress.Charts.Native.AxisPatternUtils : object {
    public static String[] IntervalPatterns;
    public static String[] UnderflowValuePatterns;
    public static String[] OverflowValuePatterns;
    private static AxisPatternUtils();
}
internal class DevExpress.Charts.Native.AxisPropertiesUpdateProcessor : TypedUpdateProcessor`2<PropertyUpdateInfo, IAxisData> {
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo updateInfo, IAxisData axis);
}
public class DevExpress.Charts.Native.AxisQualitativeGridMapping : AxisGridMapping {
    public AxisQualitativeGridMapping(AxisQualitativeMap map, double offset);
    public virtual double InternalToAligned(double internalValue);
    public virtual object InternalToNative(double alignedValue);
    public virtual double AlignedToInternal(double alignedValue);
}
public class DevExpress.Charts.Native.AxisQualitativeMap : AxisScaleTypeMap {
    private List`1<string> uniqueValues;
    private List`1<ValueItem> sortedValues;
    private ValueItemComparer comparer;
    public ActualScaleTypeCore ScaleType { get; }
    public object DefaultAxisValue { get; }
    public int UniqueValuesCount { get; }
    public AxisQualitativeMap(List`1<string> uniqueValues);
    public virtual ActualScaleTypeCore get_ScaleType();
    public virtual object get_DefaultAxisValue();
    public int get_UniqueValuesCount();
    private void ModifyIndices(Predicate`1<int> shouldUpdateIndex, int dif);
    private int BinarySearchModified(ValueItem value, ValueItemComparer comparer);
    private int IndexOf(object value);
    public void AddValue(object value);
    public void Insert(object value, int index);
    public void InsertOrReplace(string value, int index);
    public void SortValues(IComparer comparer);
    public virtual double NativeToInternal(object value);
    public virtual double NativeToRefined(object value);
    public virtual bool TryNativeToInternal(object value, Double& result);
    public virtual bool TryNativeToRefined(object value, Double& result);
    public virtual object InternalToNative(double value);
    public virtual double RefinedToInternal(double value);
    public virtual double InternalToRefined(double value);
    public virtual double SeriesPointToRefined(ISeriesPointArgument point);
    public virtual double SeriesPointToInternal(ISeriesPointArgument point);
    public virtual object ConvertValue(object value, CultureInfo culture);
    public virtual object TryParse(object value, CultureInfo culture);
    public virtual bool IsCompatible(object value);
    public virtual bool IsCompatibleType(Type type);
    public virtual AxisScaleTypeMap Clone();
    public IList`1<string> GetValues();
    public virtual double InternalToRefinedExact(double value);
    public virtual double RefinedToInternalExact(double value);
    public virtual object RefinedToNative(double value);
    public virtual double GetNextRefinedValueByMeasureUnit(double value);
    private sealed virtual override double DevExpress.Charts.Native.IPriorScaleMap.NativeToInternal(object value);
    private sealed virtual override object DevExpress.Charts.Native.IPriorScaleMap.InternalToNative(double value);
    private sealed virtual override void DevExpress.Charts.Native.IPriorScaleMap.UpdateMin(double min);
}
public class DevExpress.Charts.Native.AxisRangeInfo : object {
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private object <MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <MaxValue>k__BackingField;
    public double Min { get; private set; }
    public double Max { get; private set; }
    public object MinValue { get; private set; }
    public object MaxValue { get; private set; }
    public AxisRangeInfo(IAxisRangeData axisRange);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(double value);
    [CompilerGeneratedAttribute]
public object get_MinValue();
    [CompilerGeneratedAttribute]
private void set_MinValue(object value);
    [CompilerGeneratedAttribute]
public object get_MaxValue();
    [CompilerGeneratedAttribute]
private void set_MaxValue(object value);
    public void ApplyState(IVisualAxisRangeData axisRange);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class DevExpress.Charts.Native.AxisScaleTypeMap : object {
    private Transformation transformation;
    public ActualScaleTypeCore ScaleType { get; }
    public Transformation Transformation { get; }
    public object DefaultAxisValue { get; }
    public bool SkipGaps { get; }
    public static bool CheckArgumentScaleType(ISeriesPoint point, Scale scaleType);
    public abstract virtual ActualScaleTypeCore get_ScaleType();
    public sealed virtual Transformation get_Transformation();
    public abstract virtual object get_DefaultAxisValue();
    public virtual bool get_SkipGaps();
    protected virtual Transformation CreateTransformation(IAxisData axis);
    public void BuildTransformation(IAxisData axis);
    public abstract virtual AxisScaleTypeMap Clone();
    public abstract virtual double NativeToInternal(object value);
    public abstract virtual double NativeToRefined(object value);
    public abstract virtual double SeriesPointToRefined(ISeriesPointArgument point);
    public abstract virtual double SeriesPointToInternal(ISeriesPointArgument point);
    public abstract virtual bool TryNativeToInternal(object value, Double& result);
    public abstract virtual bool TryNativeToRefined(object value, Double& result);
    public abstract virtual object InternalToNative(double value);
    public abstract virtual double InternalToRefined(double value);
    public abstract virtual double RefinedToInternal(double value);
    public abstract virtual object ConvertValue(object value, CultureInfo culture);
    public abstract virtual object TryParse(object value, CultureInfo culture);
    public abstract virtual bool IsCompatible(object value);
    public abstract virtual bool IsCompatibleType(Type type);
    public abstract virtual double InternalToRefinedExact(double value);
    public abstract virtual double RefinedToInternalExact(double value);
    public abstract virtual object RefinedToNative(double value);
    public abstract virtual double GetNextRefinedValueByMeasureUnit(double value);
    public virtual bool IsAxisValueVisible(object axisValue);
    public double NativeToFinalWithConversion(object nativeValue, CultureInfo cultureInfo);
    public virtual List`1<DoubleLimits> GetArgumentsWithoutGaps();
    public virtual void UpdateArgumentsWithoutGaps(List`1<DoubleLimits> seriesArgumentsWithoutGaps);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.AxisTextData : AxisGridTextDataBase {
    private bool scrollingEnabled;
    private AxisGridData gridData;
    private List`1<AxisTextItem> items;
    private AxisTextConstructor textConstructor;
    private IList`1<AxisTextItem> primaryItems;
    private IList`1<AxisTextItem> staggeredItems;
    public AxisTextItem Item { get; }
    public int Count { get; }
    public IList`1<AxisTextItem> PrimaryItems { get; }
    public IList`1<AxisTextItem> StaggeredItems { get; }
    public AxisTextData(IAxisData axis, IAxisGridMapping mapping, IMinMaxValues visualRange, bool isRadarAxis, bool scrollingEnabled, bool staggered, AxisGridData gridData, Nullable`1<double> intersectionAxisValue);
    public AxisTextItem get_Item(int index);
    public int get_Count();
    public IList`1<AxisTextItem> get_PrimaryItems();
    public IList`1<AxisTextItem> get_StaggeredItems();
    private IList`1<AxisTextItem> CalculatePrimaryItems();
    private IList`1<AxisTextItem> CalculateStaggeredItems();
    private object ConstructText(double value);
    private void FillStripsAndCustomLabels();
    private void AddAutomaticValue(double value, bool isIntervalEdge);
    private void AddItem(ICustomAxisLabel customAxisLabel, double value, object content, bool isCustom, bool isIntervalEdge);
    private void GenerateItemsWithGridData();
    private void GenerateIntersectionLabel(Nullable`1<double> intersectionAxisValue);
    private void Calculate(bool staggered);
    private AxisTextConstructor CreateTextConstructor(IAxisData axisData, GridLayoutModeNative gridLayoutMode);
    private AxisTextConstructor CreateTextConstructor(bool labelShifted, bool isIntervalMode);
}
public class DevExpress.Charts.Native.AxisTextItem : object {
    private ICustomAxisLabel customAxisLabel;
    private double value;
    private object content;
    private int gridIndex;
    private bool visible;
    private bool isCustomLabel;
    private bool isIntersectionAutoLabel;
    [CompilerGeneratedAttribute]
private bool <IsIntervalEdge>k__BackingField;
    public ICustomAxisLabel CustomAxisLabel { get; }
    public double Value { get; }
    public object Content { get; }
    public bool Visible { get; }
    public int GridIndex { get; }
    public bool IsCustomLabel { get; }
    public bool IsIntersectionAutoLabel { get; }
    public bool IsIntervalEdge { get; }
    public AxisTextItem(ICustomAxisLabel customAxisLabel, int gridIndex, double value, object content, bool visible, bool isCustomLabel, bool isIntervalEdge, bool isIntersectionAutoLabel);
    public ICustomAxisLabel get_CustomAxisLabel();
    public double get_Value();
    public object get_Content();
    public bool get_Visible();
    public int get_GridIndex();
    public bool get_IsCustomLabel();
    public bool get_IsIntersectionAutoLabel();
    [CompilerGeneratedAttribute]
public bool get_IsIntervalEdge();
    public sealed virtual int CompareTo(object obj);
}
public class DevExpress.Charts.Native.AxisTimeSpanGridMapping : AxisGridMapping {
    private TimeSpanMeasureUnitNative alignment;
    protected AxisTimeSpanMap Map { get; }
    public AxisTimeSpanGridMapping(AxisTimeSpanMap map, TimeSpanGridAlignmentNative alignment, double offset);
    protected AxisTimeSpanMap get_Map();
    public virtual double InternalToAligned(double internalValue);
    public virtual double AlignedToInternal(double alignedValue);
}
public class DevExpress.Charts.Native.AxisTimeSpanIntervalsMap : AxisTimeSpanMap {
    private IAxisData axis;
    private TimeSpanAxisIntervalsContainer intervalsContainer;
    public AxisTimeSpanIntervalsMap(IAxisData axis, TimeSpanMeasureUnitNative TimeSpanMeasureUnit, int measureUnitMultiplier, AggregationIntervalsInfo info);
    public virtual object InternalToNative(double value, TimeSpanMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual double RefinedToInternal(double value, TimeSpanMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual double InternalToRefined(double value, TimeSpanMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual double InternalToRefined(double value);
    public virtual double RefinedToInternal(double value);
    public virtual object InternalToNative(double value);
    public virtual double GetNextRefinedValueByMeasureUnit(double value);
    public virtual double NativeToInternal(object value);
    public virtual AxisScaleTypeMap Clone();
    public object InternalToNativeString(double value);
    public sealed virtual object InternalToNativeInterval(double value);
    public sealed virtual object InternalToNativeValue(double value);
}
public class DevExpress.Charts.Native.AxisTimeSpanMap : AxisScaleTypeMap {
    private TimeSpanMeasureUnitNative mapMeasureUnit;
    private int mapMeasureUnitMultiplier;
    private double refinedValuesInMeasureUnit;
    public ActualScaleTypeCore ScaleType { get; }
    public object DefaultAxisValue { get; }
    public TimeSpanMeasureUnitNative MeasureUnit { get; }
    public double MeasureUnitMultiplier { get; }
    public AxisTimeSpanMap(TimeSpanMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public virtual ActualScaleTypeCore get_ScaleType();
    public virtual object get_DefaultAxisValue();
    public TimeSpanMeasureUnitNative get_MeasureUnit();
    public double get_MeasureUnitMultiplier();
    public virtual double InternalToRefined(double value, TimeSpanMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual double RefinedToInternal(double value, TimeSpanMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual object InternalToNative(double value, TimeSpanMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public virtual double NativeToInternal(object value);
    public virtual double NativeToRefined(object value);
    public virtual object InternalToNative(double value);
    public virtual double InternalToRefined(double value);
    public virtual double RefinedToInternal(double value);
    public virtual bool TryNativeToInternal(object value, Double& result);
    public virtual bool TryNativeToRefined(object value, Double& result);
    public virtual double SeriesPointToRefined(ISeriesPointArgument point);
    public virtual double SeriesPointToInternal(ISeriesPointArgument point);
    public virtual object ConvertValue(object value, CultureInfo culture);
    public virtual object TryParse(object value, CultureInfo culture);
    public virtual bool IsCompatible(object value);
    public virtual bool IsCompatibleType(Type type);
    public virtual AxisScaleTypeMap Clone();
    public virtual double InternalToRefinedExact(double value);
    public virtual double RefinedToInternalExact(double value);
    public virtual object RefinedToNative(double value);
    public virtual double GetNextRefinedValueByMeasureUnit(double value);
}
public static class DevExpress.Charts.Native.AxisUtils : object {
    public static bool ShouldUpdateSkippingRangesWithoutPoints(IAxisData axisX, bool valueRangeChanged);
    public static object GetScaleMapNativeValue(IScaleMap map, double valueInternal);
}
public static class DevExpress.Charts.Native.AxisValueContainerHelper : object {
    private static bool DisableScaleBreaksOnScrolling;
    private static bool IsCompatibleWith(IAxisValueContainer container, IScaleMap map);
    private static void UpdateAxisValueContainer(IAxisValueContainer container, IScaleMap map);
    internal static void UpdateAxisElements(IAxisData axis);
    private static IMinMaxValues GetRangeMinMax(IAxisRangeData range);
    public static void UpdateAxisValue(IAxisValueContainer container, AxisScaleTypeMap map);
    public static void UpdateAxisValue(IAxisValueContainer container1, IAxisValueContainer container2, AxisScaleTypeMap map);
    private static bool IsZoomIn(IAxisData axis);
    private static void UpdateIntervals(bool scrollingEnabled, IAxisData axis);
    public static void UpdateAxisElementsAndIntervals(IXYDiagram diagram);
    public static void UpdateIntervals(bool performRangeCorrection, IXYDiagram diagram);
}
public class DevExpress.Charts.Native.AxisValuePair : ValueType {
    private IAxisData axis;
    private double value;
    public IAxisData Axis { get; }
    public double Value { get; }
    public AxisValuePair(IAxisData axis, double value);
    public IAxisData get_Axis();
    public double get_Value();
}
public class DevExpress.Charts.Native.AxisVisibilityInPanes : object {
    private IAxisData axis;
    private HashSet`1<IPane> panesForHide;
    private Dictionary`2<IPane, bool> visibility;
    protected IAxisData Axis { get; }
    public Dictionary`2<IPane, bool> Visibility { get; }
    public HashSet`1<IPane> PanesForHide { get; }
    public AxisVisibilityInPanes(IAxisData axis);
    protected IAxisData get_Axis();
    public Dictionary`2<IPane, bool> get_Visibility();
    public HashSet`1<IPane> get_PanesForHide();
    public virtual bool IsPaneVisible(IPane pane);
    public virtual bool GetVisibilityInPane(IPane pane);
    public void SetVisibilityInPaneCore(IPane pane, bool visible);
    public virtual void UpdateVisibilityInPanes(IList`1<IPane> newPanes);
    protected void Reset(bool visible);
}
internal class DevExpress.Charts.Native.BarSeriesViewPropertiesUpdateProcessor : TypedUpdateProcessor`2<PropertyUpdateInfo, IBarSeriesView> {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo updateInfo, IBarSeriesView sender);
}
public class DevExpress.Charts.Native.BarViewportIntersectionHolder : DiscreteViewportIntersectionHolder {
    public BarViewportIntersectionHolder(IXYSeriesView view);
    protected virtual bool IsValueInRange(RefinedPoint point, double y);
}
public abstract class DevExpress.Charts.Native.BasePointInteraction : object {
    public int Count { get; }
    public bool IsEmpty { get; }
    public double Argument { get; }
    private int DevExpress.Charts.Native.IPointInteraction.Count { get; }
    private bool DevExpress.Charts.Native.IPointInteraction.IsEmpty { get; }
    private double DevExpress.Charts.Native.IPointInteraction.ArgumentX { get; }
    private double DevExpress.Charts.Native.IPointInteraction.ArgumentY { get; }
    public abstract virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual double get_Argument();
    private sealed virtual override int DevExpress.Charts.Native.IPointInteraction.get_Count();
    private sealed virtual override bool DevExpress.Charts.Native.IPointInteraction.get_IsEmpty();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.get_ArgumentX();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.get_ArgumentY();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMinValue(ISeriesView seriesView);
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMaxValue(ISeriesView seriesView);
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMinAbsValue(ISeriesView seriesView);
    protected int InsertPointToList(List`1<RefinedPoint> list, Comparer`1<RefinedPoint> comparer, RefinedPoint point);
    protected int RemovePointFromList(List`1<RefinedPoint> list, Comparer`1<RefinedPoint> comparer, RefinedPoint point);
    protected void UpdatePointsInteractions(List`1<RefinedPoint> list);
    protected void UpdatePointsInteractions(List`1<RefinedPoint> list, int startIndex);
    public abstract virtual double GetMinValue(ISeriesView seriesView);
    public abstract virtual double GetMaxValue(ISeriesView seriesView);
    public abstract virtual double GetMinAbsValue(ISeriesView seriesView);
}
public abstract class DevExpress.Charts.Native.BezierColorizerSplitter : BezierSplitter {
    [CompilerGeneratedAttribute]
private BezierSplitCalculator <Calculator>k__BackingField;
    protected BezierSplitCalculator Calculator { get; private set; }
    [CompilerGeneratedAttribute]
protected BezierSplitCalculator get_Calculator();
    [CompilerGeneratedAttribute]
private void set_Calculator(BezierSplitCalculator value);
    private void AddBottomSplitPoints(List`1<GRealPoint2D> points, GRealPoint2D firstPoint, GRealPoint2D splitPoint, double t, bool isLast);
    protected double AdjustParameterT(double minT, double currentT);
    protected double GetClosestParameterT(List`1<double> roots, double currentT);
    protected abstract virtual void SplitStrip(BezierPointInfo pointInfo, double prevPointValue, bool isExtremumValue, GeometryStripStyle style, Boolean& needSplit, Double& currentT);
    protected GeometryStripStyle GetStripStyle(IList`1<RefinedPoint> points, double argument, double pointValue, double previousPointValue);
    protected abstract virtual Nullable`1<int> GetStripColor(IList`1<RefinedPoint> points, double argument, double pointValue, double previousPointValue);
    protected void UpdateBezierParametersState(GRealPoint2D point1, GRealPoint2D point2, GRealPoint2D point3, GRealPoint2D point4);
    protected double SplitLastSegmentStrip(bool needUpdateExtremum, BezierPointInfo value, double currentT, GeometryStripStyle stripStyle);
    protected void AddSplitPoints(GRealPoint2D point, double t, GeometryStripStyle stripStyle);
    public virtual bool SplitStrip(IList`1<RefinedPoint> points, List`1<GRealPoint2D> bezierPoints);
    public virtual bool SplitBottomStrip(Dictionary`2<int, GRealPoint2D> currentPointByIndex, List`1<GRealPoint2D> resultDrawingPoints, List`1<GRealPoint2D> originalDrawingPoints, int index, double x, bool isLast);
}
public class DevExpress.Charts.Native.BezierEmptyPointSplitter : BezierSplitter {
    private IEmptyPointColorizer emptyPointSegmentColorizer;
    public BezierEmptyPointSplitter(IEmptyPointColorizer emptyPointSegmentColorizer);
    private GeometryStripStyle GetStripStyle(IList`1<RefinedPoint> points, double argument);
    public virtual bool SplitStrip(IList`1<RefinedPoint> points, List`1<GRealPoint2D> bezierPoints);
    public virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.BezierPointSplitter : BezierSplitter {
    private IPointSegmentColorizer segmentColorizer;
    public BezierPointSplitter(IPointSegmentColorizer segmentColorizer);
    private GeometryStripStyle GetStripStyle(IList`1<RefinedPoint> points, double argument);
    public virtual bool SplitStrip(IList`1<RefinedPoint> points, List`1<GRealPoint2D> bezierPoints);
}
public class DevExpress.Charts.Native.BezierRangeSplitter : BezierColorizerSplitter {
    private IRangeSegmentColorizer rangeSegmentColorizer;
    public BezierRangeSplitter(IRangeSegmentColorizer rangeSegmentColorizer);
    private bool SplitStripByRangeStopCore(bool isExtremumValue, BezierPointInfo pointInfo, bool needSplit, Double& currentT, int newIndex, int colorIndex, bool isDescending);
    private double SplitSegmentStrip(double currentT, List`1<double> roots, double y, double colorValue);
    private bool SplitStripByRangeStop(bool isExtremumValue, BezierPointInfo value, Boolean& needSplit, Double& currentT, int newIndex, int colorIndex, bool isDescending);
    private int ProcessOutOfRangeSegment(Double& currentT, IList`1<double> rangeStops, int index, bool isDescending);
    protected virtual Nullable`1<int> GetStripColor(IList`1<RefinedPoint> points, double argument, double pointValue, double previousPointValue);
    protected virtual void SplitStrip(BezierPointInfo pointInfo, double prevPointValue, bool isExtremumValue, GeometryStripStyle style, Boolean& needSplit, Double& currentT);
}
public class DevExpress.Charts.Native.BezierRangeStrip : RangeStrip {
    private SplineAlgorithmCore splineAlgorithm;
    private double lineTension;
    private ITransformation transformationX;
    private ITransformation transformationY;
    public bool IsEmpty { get; }
    public BezierRangeStrip(SplineAlgorithmCore splineAlgorithm, double lineTension);
    public BezierRangeStrip(SplineAlgorithmCore splineAlgorithm, double lineTension, ITransformation transformationX, ITransformation transformationY);
    public virtual bool get_IsEmpty();
    private void GetPointsForDrawingInternal(LineStrip& topPoints, LineStrip& bottomPoints);
    protected virtual LineStrip CreateBorderStrip();
    public void GetPointsForDrawing(LineStrip& topPoints, LineStrip& bottomPoints);
    public void GetPointsForDrawing(LineStrip& topPoints, LineStrip& bottomPoints, double border);
    public GRealRect2D GetBoundingRectangle();
    public virtual RangeStrip CreateInstance();
    public virtual void CompleteFilling(IList`1<RefinedPoint> points, IBezierStripSplitter splitter);
    public sealed virtual MinMaxValues CalculateMinMaxValues();
    public sealed virtual MinMaxValues CalculateMinMaxArguments();
    private void GetPointsForRangeCorrection(LineStrip& topPoints, LineStrip& bottomPoints);
}
public class DevExpress.Charts.Native.BezierSplitCalculator : object {
    private GRealPoint2D p1;
    private GRealPoint2D p2;
    private GRealPoint2D p3;
    private GRealPoint2D p4;
    private double cx1;
    private double cx2;
    private double cx3;
    private double cy1;
    private double cy2;
    private double cy3;
    public BezierSplitCalculator(List`1<GRealPoint2D> points);
    public BezierSplitCalculator(GRealPoint2D p1, GRealPoint2D p2, GRealPoint2D p3, GRealPoint2D p4);
    private void UpdateParameters();
    private Double[] SolveQuadraticEquation(double a, double b, double c);
    private double CubicRoot(double n);
    private Double[] SolveCubicEquation(double a, double b, double c, double d);
    private List`1<double> CoerceParameterT(Double[] roots, bool isLastSegment);
    public IEnumerable`1<GRealPoint2D> GetCurrentPoints();
    public double CalcCoordinateX(double t);
    public double CalcCoordinateY(double t);
    public List`1<double> CalcParameterTForX(double x);
    public List`1<double> CalcParameterTForY(double y);
    public List`1<double> CalcParameterTExtremums();
    public GRealPoint2D[] Split(GRealPoint2D point, double t);
}
public class DevExpress.Charts.Native.BezierSplitter : object {
    public static int BezierStep;
    private BezierStripsContainer stripsContainer;
    public BezierStripsContainer StripContainer { get; }
    private List`1<BezierStrip> DevExpress.Charts.Native.IBezierStripSplitter.Strips { get; }
    public BezierStripsContainer get_StripContainer();
    private sealed virtual override List`1<BezierStrip> DevExpress.Charts.Native.IBezierStripSplitter.get_Strips();
    private sealed virtual override void DevExpress.Charts.Native.IBezierStripSplitter.SetSharedStripsContainer(BezierStripsContainer value);
    protected BezierStrip ProcessNewStrip(GeometryStripStyle stripStyle, GRealPoint2D point);
    public virtual bool SplitStrip(IList`1<RefinedPoint> points, List`1<GRealPoint2D> bezierPoints);
    public virtual bool SplitBottomStrip(Dictionary`2<int, GRealPoint2D> currentPointByIndex, List`1<GRealPoint2D> resultDrawingPoints, List`1<GRealPoint2D> originalDrawingPoints, int index, double x, bool isLast);
    public sealed virtual void Clear();
    public virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.BezierStrip : LineStrip {
    private SplineAlgorithmCore splineAlgorithm;
    private double lineTension;
    private ITransformation transformationX;
    private ITransformation transformationY;
    private bool clipLargeValues;
    private List`1<GRealPoint2D> drawingPoints;
    public bool ClipLargeValues { get; public set; }
    public SplineAlgorithmCore SplineAlgorithm { get; }
    public double LineTension { get; }
    public List`1<GRealPoint2D> DrawingPoints { get; }
    public bool IsEmpty { get; }
    public BezierStrip(SplineAlgorithmCore splineAlgorithm, double lineTension, ITransformation transformationX, ITransformation transformationY);
    public BezierStrip(SplineAlgorithmCore splineAlgorithm, double lineTension);
    private static GRealPoint2D CalculateCurveBezierEndPoint(GRealPoint2D endPoint, GRealPoint2D adjPoint, double tension);
    private static bool IsVecticallyBetweenPoints(int i, List`1<GRealPoint2D> points);
    public static MinMaxValues CalculateMinMaxValues(IList`1<GRealPoint2D> points);
    public static MinMaxValues CalculateMinMaxArguments(IList`1<GRealPoint2D> points);
    public bool get_ClipLargeValues();
    public void set_ClipLargeValues(bool value);
    public SplineAlgorithmCore get_SplineAlgorithm();
    public double get_LineTension();
    public List`1<GRealPoint2D> get_DrawingPoints();
    public virtual bool get_IsEmpty();
    private List`1<GRealPoint2D> TransformPointsForward(List`1<GRealPoint2D> points);
    private GRealPoint2D TransformPointBackward(GRealPoint2D point);
    private void TransformBackwardAndAdd(GRealPoint2D point, IList`1<GRealPoint2D> points);
    private List`1<GRealPoint2D> CalculateBezierPoints(IList`1<RefinedPoint> refinedPoints, List`1<GRealPoint2D> points, IBezierStripSplitter splitter);
    private List`1<GRealPoint2D> CalculateStrictMinMaxBezierPoints(IList`1<RefinedPoint> refinedPoints, List`1<GRealPoint2D> points, IBezierStripSplitter splitter);
    private List`1<GRealPoint2D> CalculateCardinalBezierPoints(IList`1<RefinedPoint> refinedPoints, List`1<GRealPoint2D> points, IBezierStripSplitter splitter);
    public List`1<GRealPoint2D> GetPointsForDrawing(bool completeFilling, bool clip);
    public List`1<GRealPoint2D> GetPointsForDrawingWithoutValidate(bool completeFilling, bool clip);
    public void SetPointsForDrawing(List`1<GRealPoint2D> points);
    public virtual LineStrip CreateInstance();
    public virtual void CompleteFilling(IList`1<RefinedPoint> points, IBezierStripSplitter splitter);
    public List`1<GRealPoint2D> CalculateBezierPoints(IList`1<RefinedPoint> refinedPoints, IBezierStripSplitter splitter);
    public virtual void Extend(GRealPoint2D point, bool toLeft);
    public virtual LineStrip ExtractSubStrip(int startIndex, int endIndex);
    public virtual void Substitute(int startIndex, int endIndex, LineStrip lineStrip);
    public virtual LineStrip CreateUniqueStrip();
    public sealed virtual MinMaxValues CalculateMinMaxValues();
    public sealed virtual MinMaxValues CalculateMinMaxArguments();
}
public class DevExpress.Charts.Native.BezierStripsContainer : object {
    [CompilerGeneratedAttribute]
private List`1<BezierStrip> <Strips>k__BackingField;
    public List`1<BezierStrip> Strips { get; }
    [CompilerGeneratedAttribute]
public List`1<BezierStrip> get_Strips();
}
public class DevExpress.Charts.Native.BezierStripSplitterContainer : object {
    private IEnumerable`1<IBezierStripSplitter> splitters;
    private BezierStripsContainer sharedStripsContainer;
    private List`1<BezierStrip> DevExpress.Charts.Native.IBezierStripSplitter.Strips { get; }
    public BezierStripSplitterContainer(IBezierStripSplitter[] splitters);
    private sealed virtual override List`1<BezierStrip> DevExpress.Charts.Native.IBezierStripSplitter.get_Strips();
    private sealed virtual override void DevExpress.Charts.Native.IBezierStripSplitter.Clear();
    private sealed virtual override bool DevExpress.Charts.Native.IBezierStripSplitter.SplitStrip(IList`1<RefinedPoint> points, List`1<GRealPoint2D> bezierPoints);
    private sealed virtual override bool DevExpress.Charts.Native.IBezierStripSplitter.SplitBottomStrip(Dictionary`2<int, GRealPoint2D> currentPointByIndex, List`1<GRealPoint2D> resultDrawingPoints, List`1<GRealPoint2D> originalDrawingPoints, int index, double x, bool isLast);
    private sealed virtual override bool DevExpress.Charts.Native.IBezierStripSplitter.CanProcessPoint(RefinedPoint point);
    private sealed virtual override void DevExpress.Charts.Native.IBezierStripSplitter.SetSharedStripsContainer(BezierStripsContainer container);
}
public class DevExpress.Charts.Native.BezierTrendSplitter : BezierColorizerSplitter {
    private ITrendSegmentColorizer segmentColorizer;
    private GeometryStripStyle previousStripStyle;
    public BezierTrendSplitter(ITrendSegmentColorizer segmentColorizer);
    protected virtual Nullable`1<int> GetStripColor(IList`1<RefinedPoint> points, double argument, double pointValue, double previousPointValue);
    protected virtual void SplitStrip(BezierPointInfo pointInfo, double prevPointValue, bool isExtremumValue, GeometryStripStyle stripStyle, Boolean& needSplit, Double& currentT);
}
public class DevExpress.Charts.Native.BindingEnvironment : object {
    private List`1<CalculatedFieldData> contextFields;
    private bool shouldDisposeDataContext;
    private object globalDataSource;
    private DataContextBase actualDataContext;
    public DataContextBase DataContext { get; }
    public object DataSource { get; }
    public BindingEnvironment(object dataSource, IEnumerable`1<ICalculatedField> calculatedFields);
    public BindingEnvironment(DataContextBase dataContext, object dataSource);
    public BindingEnvironment(DataContextBase dataContext, object dataSource, IEnumerable`1<ICalculatedField> calculatedFields);
    public BindingEnvironment(DataContextBase dataContext, object dataSource, IEnumerable`1<ICalculatedField> calculatedFields, bool createDataContextBase);
    public DataContextBase get_DataContext();
    public object get_DataSource();
    private sealed virtual override void System.IDisposable.Dispose();
    private ICalculatedField GetCalculatedField(string dataMember);
    public DataBrowser GetDataBrowser(string dataMember, bool suppressException);
    public string GetDataMemberDisplayName(string dataMember);
    public string GetDataMemberDisplayName(string dataMemberPrefix, string dataMember);
    public PropertyDescriptorCollection GetItemProperties(string dataMember);
    public PropertyDescriptorCollection GetListItemProperties(string dataMember);
}
public static class DevExpress.Charts.Native.BindingHelperCore : object {
    public static int CompareValues(object x, object y);
    public static bool IsValidDataParams(object dataSource, string dataMember);
    public static bool IsFit(ISeriesDataAdapter dataAdapter, object dataRow);
    public static bool TryGetValue(DataContextBase context, object dataRow, string dataMember, ISeriesDataAdapter seriesDataAdapter, Object& value);
    public static object GetValue(object dataRow, object dataSource, string dataMember);
    public static object GetValue(DataContextBase context, object dataRow, string dataMember, ISeriesDataAdapter seriesDataAdapter);
    public static string ConvertToActualDataMember(string rootDataMember, string dataMember);
    public static Type GetMemberType(DataContextBase dataContext, object dataSource, string dataMember, IEnumerable`1<ICalculatedField> calculatedFields);
    public static Scale GetScaleType(DataContextBase dataContext, object dataSource, string dataMember, IEnumerable`1<ICalculatedField> calculatedFields);
    public static DataBrowser CreateListBrowser(BindingEnvironment environment, string dataMember);
    public static DataBrowser CreateListBrowser(object dataSource, DataContextBase dataContext, string dataMember);
    public static IList`1<string> GetSummaryDataMembers(ISummaryBindingProvider summaryBindingProvider);
    public static IIndicatorDataPoint CreateIndicatorPoint(IList`1<IDataSourceIndicator> indicators, Dictionary`2<string, IDataMemberContainer> additionalContainers);
}
public abstract class DevExpress.Charts.Native.BindingProcedure : object {
    [CompilerGeneratedAttribute]
private BindingEnvironment <BindingEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DataMember>k__BackingField;
    protected BindingEnvironment BindingEnvironment { get; private set; }
    protected string DataMember { get; }
    protected BindingProcedure(DataContextBase dataContext, object dataSource, string dataMember, IEnumerable`1<ICalculatedField> calculatedFields);
    [CompilerGeneratedAttribute]
protected BindingEnvironment get_BindingEnvironment();
    [CompilerGeneratedAttribute]
private void set_BindingEnvironment(BindingEnvironment value);
    [CompilerGeneratedAttribute]
protected string get_DataMember();
    protected abstract virtual Dictionary`2<string, IDataMemberContainer> CreateAdditionalDataMemberContainers();
    protected abstract virtual List`1<IDataMemberContainer> CreateDataMemberContainers();
    protected void AddArgumentContainer(List`1<IDataMemberContainer> containers, Scale scaleType, string argumentMember, bool supportEmpty);
    protected void AddIndicatorContainer(Dictionary`2<string, IDataMemberContainer> containers, string dataMember);
    protected void AddObjectContainer(Dictionary`2<string, IDataMemberContainer> containers, string dataMember);
    protected void AddValueContainers(List`1<IDataMemberContainer> containers, Scale scaleType, IList`1<string> valueMembers, bool supportEmptyValue);
    protected RowDataReader CreateDataReader();
    public sealed virtual void Dispose();
}
public abstract class DevExpress.Charts.Native.BindingProcessorBase : object {
    public static int maxUpdatesInQueue;
    [CompilerGeneratedAttribute]
private IUpdateHelper <ElementHelper>k__BackingField;
    protected IUpdateHelper ElementHelper { get; protected set; }
    protected bool ShouldBreakUpdates { get; }
    private static Tuple`2<bool, bool> ProcessBindingUpdates(Dictionary`2<IBindingProvider, DataSourceUpdateInfoCollection> updates, bool seriesCountChanged);
    private static void SimplifyUpdate(DataSourceUpdateInfoCollection simplifyed, int updatesDelta, int batchDataCount, DataSourceUpdateInfoBase`1<IBindingProvider> firstBatchUpdate, Int32& lastRemoveUpdateIndex);
    protected static bool AllowUseResamplingBindingProcedure(IResamplingSupportSeries irss);
    public static DataSourceUpdateInfoCollection SimplifyUpdates(DataSourceUpdateInfoCollectionBase`1<IBindingProvider> updates, int existItemsCount);
    [CompilerGeneratedAttribute]
protected IUpdateHelper get_ElementHelper();
    [CompilerGeneratedAttribute]
protected void set_ElementHelper(IUpdateHelper value);
    protected virtual bool get_ShouldBreakUpdates();
    private DataSourceUpdateInfoCollection GetUpdatesCache(Dictionary`2<IBindingProvider, DataSourceUpdateInfoCollection> cache, IBindingProvider sender);
    private bool UpdateBindingAsync(Dictionary`2<IBindingProvider, DataSourceUpdateInfoCollection> updates, IChartWithData chart);
    protected bool IsInsertAndRemoveUpdate(DataSourceUpdateInfoCollection updates);
    protected SeriesBindingProcedure CreateBindingProcedure(ISeries series);
    protected void NotifyPointInsert(ISeries series, IDataPoint boundPoint, int index);
    protected void NotifyPointsChanged(ISeries series, ICollection`1<IDataPoint> removedPoints, ICollection`1<IDataPoint> insertedPoints, int index);
    protected void NotifyPointsClear(ISeries series);
    protected void NotifyPointsInsert(ISeries series, ICollection`1<IDataPoint> insertedPoints, int index);
    protected void NotifyPointsRemove(ISeries series, ICollection`1<IDataPoint> removedPoints, int index);
    public abstract virtual Tuple`3<bool, bool, bool> ProcessUpdate(DataSourceUpdateInfoBase`1<IBindingProvider> update);
    public virtual Tuple`2<bool, bool> ProcessUpdates(DataSourceUpdateInfoCollection updates, bool seriesCountChanged);
    public bool RefreshData(DataSourceUpdateInfoCollectionBase`1<IBindingProvider> updates, IChartWithData chart);
    public void QueryUpdate(DataSourceUpdateInfoCollectionBase`1<IBindingProvider> updates, IChartWithData chart);
}
public class DevExpress.Charts.Native.BollingerBandsCalculator : object {
    private static int DesignTimePointsCount;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LineStrip <MovingAveragePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private LineStrip <UpperBandPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private LineStrip <LowerBandPoints>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    public LineStrip MovingAveragePoints { get; private set; }
    public LineStrip UpperBandPoints { get; private set; }
    public LineStrip LowerBandPoints { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    [CompilerGeneratedAttribute]
public LineStrip get_MovingAveragePoints();
    [CompilerGeneratedAttribute]
private void set_MovingAveragePoints(LineStrip value);
    [CompilerGeneratedAttribute]
public LineStrip get_UpperBandPoints();
    [CompilerGeneratedAttribute]
private void set_UpperBandPoints(LineStrip value);
    [CompilerGeneratedAttribute]
public LineStrip get_LowerBandPoints();
    [CompilerGeneratedAttribute]
private void set_LowerBandPoints(LineStrip value);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount, double deviationMultiplier, ValueLevelInternal valueLevel);
    private double CalcStdDeviation(IList`1<RefinedPoint> refinedPoints, double sma, int index, int pointsCount, ValueLevelInternal valueLevel);
    private double CalcStdDeviation(Double[] values, double sma, int pointsCount);
    public void Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount, double deviationMultiplier, ValueLevelInternal valueLevel);
    public void UpdateIndicatorData(int startUpdateIndex, IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount, double deviationMultiplier, ValueLevelInternal valueLevel);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.BoundData : object {
    private Dictionary`2<object, BoundDataItem> boundData;
    private List`1<BoundDataItem> items;
    public BoundDataItem Item { get; }
    public List`1<BoundDataItem> Items { get; }
    public BoundDataItem get_Item(object argument);
    public List`1<BoundDataItem> get_Items();
    public bool ContainsArgument(object argument);
    public void Add(object argument);
}
public class DevExpress.Charts.Native.BoundDataItem : object {
    private object argument;
    private List`1<DataSourceValuesCore> values;
    private List`1<object> colorKeys;
    [CompilerGeneratedAttribute]
private string <ToolTipHint>k__BackingField;
    public object Argument { get; }
    public List`1<DataSourceValuesCore> Values { get; }
    public List`1<object> ColorKeys { get; }
    public string ToolTipHint { get; public set; }
    public BoundDataItem(object argument);
    public object get_Argument();
    public List`1<DataSourceValuesCore> get_Values();
    public List`1<object> get_ColorKeys();
    [CompilerGeneratedAttribute]
public string get_ToolTipHint();
    [CompilerGeneratedAttribute]
public void set_ToolTipHint(string value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.BoundPointsList : object {
    private List`1<IDataPoint> points;
    private int count;
    private int offset;
    public IDataPoint Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IDataPoint>.IsReadOnly { get; }
    public sealed virtual IDataPoint get_Item(int index);
    public sealed virtual void set_Item(int index, IDataPoint value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IDataPoint>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IDataPoint>.Contains(IDataPoint item);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.IDataPoint>.CopyTo(IDataPoint[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<IDataPoint> System.Collections.Generic.IEnumerable<DevExpress.Charts.Native.IDataPoint>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<DevExpress.Charts.Native.IDataPoint>.IndexOf(IDataPoint item);
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IDataPoint>.Remove(IDataPoint item);
    private void ClearOffset();
    private void CheckCapacity(int newItemsCount);
    public sealed virtual void Add(IDataPoint item);
    public void AddRange(IList`1<IDataPoint> values);
    public sealed virtual void Insert(int index, IDataPoint item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public void SetPoints(List`1<IDataPoint> pointsList);
}
public static class DevExpress.Charts.Native.BoxPlotConventions : object {
    public static double MissingNumericNativeValue;
    public static DateTime MissingDateTimeNativeValue;
    public static TimeSpan MissingTimeSpanNativeValue;
    public static double MissingRefinedValue;
    public static string MissingDataMember;
    public static int BoxPlotOutliersMemberIndex;
    private static BoxPlotConventions();
    public static bool IsMissingDateTimeNativeValue(DateTime dtValue);
    public static bool IsMissingTimeSpanNativeValue(TimeSpan tsValue);
    public static bool IsMissingNumericNativeValue(double dValue);
    public static bool IsMissingDataMember(string dataMember);
}
public class DevExpress.Charts.Native.BoxPlotMeanLineStrip : object {
    private GeometryStripStyle customStyle;
    private List`1<GRealPoint2D> points;
    private List`1<int> pixelOffsets;
    public int Count { get; }
    public bool IsEmpty { get; }
    public GeometryStripStyle Style { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual GeometryStripStyle get_Style();
    public void Add(double x, double y, int fixedArgOffset);
    public GRealPoint2D GetPoint(int index);
    public int GetPixelOffset(int index);
    public sealed virtual void CompleteFilling(IList`1<RefinedPoint> points, IBezierStripSplitter splitter);
}
public enum DevExpress.Charts.Native.BubbleSizeUnitCore : Enum {
    public int value__;
    public static BubbleSizeUnitCore AxisXMeasureUnit;
    public static BubbleSizeUnitCore Pixel;
}
public static class DevExpress.Charts.Native.BubbleUtils : object {
    internal static int MinimumMinSizeInPixels;
    internal static int MinimumMaxSizeInPixels;
    public static double MaxAutoSize;
    public static double MinAutoSize;
    private static Tuple`2<double, double> GetMinAxisLengthAndRange(GRealSize2D paneSize, double rangeDelta);
    private static double GetAutomaticSize(GRealSize2D paneSize, double rangeDelta, double percent, int minimumPixels);
    public static double GetAutomaticMinSize(BubbleSizeUnitCore sizeUnit, GRealSize2D paneSize, double rangeDelta);
    public static double GetAutomaticMaxSize(BubbleSizeUnitCore sizeUnit, GRealSize2D paneSize, double rangeDelta);
}
public class DevExpress.Charts.Native.CalculatedFieldData : object {
    private IChartCalculatedField initialField;
    private object dataSource;
    private object ActualDataSource { get; }
    public string Name { get; }
    public string Expression { get; }
    private string DevExpress.XtraReports.Native.ICalculatedField.DisplayName { get; }
    private string DevExpress.XtraReports.Native.ICalculatedField.Expression { get; }
    private FieldType DevExpress.XtraReports.Native.ICalculatedField.FieldType { get; }
    private string DevExpress.XtraReports.Native.ICalculatedField.DataMember { get; }
    private object DevExpress.XtraReports.Native.ICalculatedField.DataSource { get; }
    private object DevExpress.Charts.Native.IChartCalculatedField.OwnerDataSource { get; }
    private IChartCalculatedField DevExpress.Charts.Native.IChartCalculatedField.PlatformInstance { get; }
    private List`1<IDataColumnInfo> DevExpress.Data.IDataColumnInfo.Columns { get; }
    private string DevExpress.Data.IDataColumnInfo.UnboundExpression { get; }
    private string DevExpress.Data.IDataColumnInfo.Caption { get; }
    private string DevExpress.Data.IDataColumnInfo.FieldName { get; }
    private string DevExpress.Data.IDataColumnInfo.Name { get; }
    private Type DevExpress.Data.IDataColumnInfo.FieldType { get; }
    private DataControllerBase DevExpress.Data.IDataColumnInfo.Controller { get; }
    public CalculatedFieldData(IChartCalculatedField field);
    public CalculatedFieldData(IChartCalculatedField initialField, object dataSource);
    private object get_ActualDataSource();
    public sealed virtual string get_Name();
    public string get_Expression();
    private sealed virtual override string DevExpress.XtraReports.Native.ICalculatedField.get_DisplayName();
    private sealed virtual override string DevExpress.XtraReports.Native.ICalculatedField.get_Expression();
    private sealed virtual override FieldType DevExpress.XtraReports.Native.ICalculatedField.get_FieldType();
    private sealed virtual override string DevExpress.XtraReports.Native.ICalculatedField.get_DataMember();
    private sealed virtual override object DevExpress.XtraReports.Native.ICalculatedField.get_DataSource();
    private sealed virtual override object DevExpress.Charts.Native.IChartCalculatedField.get_OwnerDataSource();
    private sealed virtual override IChartCalculatedField DevExpress.Charts.Native.IChartCalculatedField.get_PlatformInstance();
    private sealed virtual override List`1<IDataColumnInfo> DevExpress.Data.IDataColumnInfo.get_Columns();
    private sealed virtual override string DevExpress.Data.IDataColumnInfo.get_UnboundExpression();
    private sealed virtual override string DevExpress.Data.IDataColumnInfo.get_Caption();
    private sealed virtual override string DevExpress.Data.IDataColumnInfo.get_FieldName();
    private sealed virtual override string DevExpress.Data.IDataColumnInfo.get_Name();
    private sealed virtual override Type DevExpress.Data.IDataColumnInfo.get_FieldType();
    private sealed virtual override DataControllerBase DevExpress.Data.IDataColumnInfo.get_Controller();
    private List`1<IDataColumnInfo> GetDataColumnInfos();
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.CalculatedFieldData/<GetDataSourceFields>d__39")]
public IEnumerable`1<PropertyDescriptor> GetDataSourceFields();
}
public class DevExpress.Charts.Native.Cell : object {
    private DXRectangle bounds;
    private int infillCount;
    public DXRectangle Bounds { get; }
    public bool IsEmpty { get; }
    public int InfillCount { get; }
    public Cell(DXRectangle bounds);
    public Cell(DXRectangle bounds, int infillCount);
    public DXRectangle get_Bounds();
    public bool get_IsEmpty();
    public int get_InfillCount();
    public sealed virtual int CompareTo(object obj);
    public void Infill();
    public void Clear();
}
public class DevExpress.Charts.Native.ChaikinsVolatilityCalculator : object {
    private static int DesignTimePointsCount;
    private LineStrip indicatorPoints;
    private List`1<double> emaValues;
    private MinMaxValues rangeByY;
    public MinMaxValues YRange { get; }
    public LineStrip IndicatorPoints { get; }
    public static bool IsCompatible(ISeriesView view);
    public MinMaxValues get_YRange();
    public LineStrip get_IndicatorPoints();
    private MinMaxValues CalculateRange();
    private double CalcChv(double ema, double oldEma);
    private double CalcNextEma(IFinancialPoint point, double preEma, double smoothingFactor);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount);
    private void ResetData();
    public void Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int startUpdateIndex, int pointsCount);
}
public abstract class DevExpress.Charts.Native.ChartBindingProcedure : BindingProcedure {
    private string seriesDataMember;
    private IDataSourceColorizer seriesColorizer;
    [CompilerGeneratedAttribute]
private List`1<ISeries> <AutoCreatedSeries>k__BackingField;
    [CompilerGeneratedAttribute]
private ISeriesFactory <SeriesFactory>k__BackingField;
    protected List`1<ISeries> AutoCreatedSeries { get; }
    protected ISeriesDataAdapter DataAdapter { get; }
    protected ISeriesFactory SeriesFactory { get; }
    protected ISeriesBase SeriesTemplate { get; }
    protected string ActualSeriesDataMember { get; }
    protected ChartBindingProcedure(string seriesDataMember, ISeriesFactory seriesTemplate);
    [CompilerGeneratedAttribute]
protected List`1<ISeries> get_AutoCreatedSeries();
    protected ISeriesDataAdapter get_DataAdapter();
    [CompilerGeneratedAttribute]
protected ISeriesFactory get_SeriesFactory();
    protected ISeriesBase get_SeriesTemplate();
    protected string get_ActualSeriesDataMember();
    private void UpdateSeriesColorizer(RowDataReader dataReader, object seriesValue);
    private IEnumerable`1<ISeries> CreateSortedSeriesList(Dictionary`2<object, ISeries> seriesList, SortMode sorting);
    protected abstract virtual void OnDataWereRead();
    protected abstract virtual void OnRowWasRead(ISeries series, object dataRow, RowDataReader dataReader);
    protected virtual Dictionary`2<string, IDataMemberContainer> CreateAdditionalDataMemberContainers();
    public IList`1<ISeries> CreateBindingSeries(SortMode sorting, IList`1<ISeries> autoCreatedSeries);
    public void SetSeriesColorizer(IDataSourceColorizer colorizer);
}
public class DevExpress.Charts.Native.ChartBoundProperty : object {
    private string displayName;
    private PropertyDescriptor property;
    private ChartBoundProperty parent;
    private ISeriesDataAdapter dataAdapter;
    private List`1<ChartBoundProperty> children;
    private ChartBoundProperty Parent { get; }
    private PropertyDescriptor PropertyDescriptor { get; }
    private bool DevExpress.Data.IBoundProperty.HasChildren { get; }
    private bool DevExpress.Data.IBoundProperty.IsAggregate { get; }
    private bool DevExpress.Data.IBoundProperty.IsList { get; }
    private string DevExpress.Data.IBoundProperty.Name { get; }
    private string DevExpress.Data.IBoundProperty.DisplayName { get; }
    private List`1<IBoundProperty> DevExpress.Data.IBoundProperty.Children { get; }
    private IBoundProperty DevExpress.Data.IBoundProperty.Parent { get; }
    private Type DevExpress.Data.IBoundProperty.Type { get; }
    private ITreeSelectableItem DevExpress.Data.ITreeSelectableItem.Parent { get; }
    private List`1<ITreeSelectableItem> DevExpress.Data.ITreeSelectableItem.Children { get; }
    private bool DevExpress.Data.ITreeSelectableItem.AllowSelect { get; }
    private string DevExpress.Data.ITreeSelectableItem.Text { get; }
    public ChartBoundProperty(ISeriesDataAdapter dataAdapter, ChartBoundProperty parent, PropertyDescriptor property, string displayName);
    private static bool IsUniqueProperty(ChartBoundProperty property, PropertyDescriptor childProperty);
    internal static string GetDisplayName(BindingEnvironment environment, string prefixMember, string member);
    private ChartBoundProperty get_Parent();
    private PropertyDescriptor get_PropertyDescriptor();
    private sealed virtual override bool DevExpress.Data.IBoundProperty.get_HasChildren();
    private sealed virtual override bool DevExpress.Data.IBoundProperty.get_IsAggregate();
    private sealed virtual override bool DevExpress.Data.IBoundProperty.get_IsList();
    private sealed virtual override string DevExpress.Data.IBoundProperty.get_Name();
    private sealed virtual override string DevExpress.Data.IBoundProperty.get_DisplayName();
    private sealed virtual override List`1<IBoundProperty> DevExpress.Data.IBoundProperty.get_Children();
    private sealed virtual override IBoundProperty DevExpress.Data.IBoundProperty.get_Parent();
    private sealed virtual override Type DevExpress.Data.IBoundProperty.get_Type();
    private sealed virtual override ITreeSelectableItem DevExpress.Data.ITreeSelectableItem.get_Parent();
    private sealed virtual override List`1<ITreeSelectableItem> DevExpress.Data.ITreeSelectableItem.get_Children();
    private sealed virtual override bool DevExpress.Data.ITreeSelectableItem.get_AllowSelect();
    private sealed virtual override string DevExpress.Data.ITreeSelectableItem.get_Text();
    private void InitChildren();
    protected string GetFullName();
}
public class DevExpress.Charts.Native.ChartBoundPropertyCollection : List`1<IBoundProperty> {
    private IBoundProperty DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.Item { get; }
    private IBoundProperty DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.Item { get; }
    private int DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.Count { get; }
    public ChartBoundPropertyCollection(ISeriesDataAdapter dataAdapter);
    private sealed virtual override IBoundProperty DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.get_Item(string fieldName);
    private sealed virtual override IBoundProperty DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.get_Item(int index);
    private sealed virtual override int DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.get_Count();
    private sealed virtual override void DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.Add(IBoundProperty property);
    private sealed virtual override void DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.Clear();
    private sealed virtual override IBoundPropertyCollection DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.CreateChildrenProperties(IBoundProperty listProperty);
    private sealed virtual override string DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.GetDisplayPropertyName(OperandProperty property, string fullPath);
    private sealed virtual override string DevExpress.XtraEditors.Filtering.IBoundPropertyCollection.GetValueScreenText(OperandProperty property, object value);
}
public enum DevExpress.Charts.Native.ChartCollectionOperation : Enum {
    public int value__;
    public static ChartCollectionOperation Reset;
    public static ChartCollectionOperation InsertItem;
    public static ChartCollectionOperation RemoveItem;
    public static ChartCollectionOperation UpdateItem;
    public static ChartCollectionOperation MoveItem;
    public static ChartCollectionOperation SwapItem;
}
public class DevExpress.Charts.Native.ChartComplexPropertyDescriptor : ComplexPropertyDescriptor {
    private BindingEnvironment environment;
    private List`1<PropertyDescriptor> descriptors;
    private PropertyDescriptor Root { get; }
    private PropertyDescriptor Last { get; }
    private List`1<PropertyDescriptor> Descriptors { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    public Type ComponentType { get; }
    public string DisplayName { get; }
    public ChartComplexPropertyDescriptor(BindingEnvironment environment, string path);
    private PropertyDescriptor get_Root();
    private PropertyDescriptor get_Last();
    private List`1<PropertyDescriptor> get_Descriptors();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    public virtual Type get_ComponentType();
    public virtual string get_DisplayName();
    protected virtual AttributeCollection CreateAttributeCollection();
    private PropertyDescriptor GetPropertyDescriptor(string path, string name);
    private int GetFirstNotIEnumerableMemberIndex();
    protected virtual void Prepare();
    public virtual void SetValue(object component, object value);
    public virtual object GetOwnerOfLast(object component);
    public virtual object GetValue(object component);
}
public class DevExpress.Charts.Native.ChartDataContext : XRDataContextBase {
    public ChartDataContext(IEnumerable`1<ICalculatedField> calculatedFields);
    public static DataContextBase CreateActualInstance(IEnumerable`1<ICalculatedField> calculatedFields, bool createDataContextBase);
    protected virtual DataBrowser CreateDataBrowserInternal(DataPair data);
}
public enum DevExpress.Charts.Native.ChartDataSourceUpdateType : Enum {
    public int value__;
    public static ChartDataSourceUpdateType Reset;
    public static ChartDataSourceUpdateType Insert;
    public static ChartDataSourceUpdateType Remove;
    public static ChartDataSourceUpdateType ItemChanged;
    public static ChartDataSourceUpdateType ViewportChanged;
}
public static class DevExpress.Charts.Native.ChartDebug : object {
    public static void Assert(bool condition);
    public static void Assert(bool condition, string message);
    public static void Fail();
    public static void Fail(string message);
    public static void Write(object value);
    public static void Write(string message);
    public static void Write(object value, string category);
    public static void Write(string message, string category);
    public static void WriteLine(object value);
    public static void WriteLine(string message);
    public static void WriteLine(string message, string category);
    public static void WriteWarning(string message);
    public static void WriteLine(object value, string category);
}
[FlagsAttribute]
public enum DevExpress.Charts.Native.ChartElementChange : Enum {
    public int value__;
    public static ChartElementChange None;
    public static ChartElementChange ClearDiagramCache;
    public static ChartElementChange CollectionModified;
    public static ChartElementChange UpdateSeriesBinding;
    public static ChartElementChange UpdateChartBinding;
    public static ChartElementChange UpdateAutoSeries;
    public static ChartElementChange UpdateAutoSeriesProperties;
    public static ChartElementChange UpdateXYDiagram2DItems;
    public static ChartElementChange Diagram3DOnly;
    public static ChartElementChange UpdateActualPanes;
    public static ChartElementChange UpdatePanesItems;
    public static ChartElementChange UpdateIndicators;
    public static ChartElementChange UpdateChartPalette;
    public static ChartElementChange ClearSeriesCache;
    public static ChartElementChange UpdateLegendItems;
    public static ChartElementChange UpdateAxisLabelsMeasure;
    public static ChartElementChange ClearTextureCache;
    public static ChartElementChange SeriesPointCollectionChanged;
    public static ChartElementChange SeriesPointFiltersChanged;
    public static ChartElementChange RangeChanged;
    public static ChartElementChange DiagramElementsChanged;
    public static ChartElementChange NonSpecific;
    public static ChartElementChange RangeControlChanged;
    public static ChartElementChange UpdateSelectionState;
    public static ChartElementChange SeriesColorizerChanged;
    public static ChartElementChange NonUpdate;
}
public enum DevExpress.Charts.Native.ChartElementVisibilityPriority : Enum {
    public int value__;
    public static ChartElementVisibilityPriority Breadcrumbs;
    public static ChartElementVisibilityPriority ChartTitle;
    public static ChartElementVisibilityPriority AxisX;
    public static ChartElementVisibilityPriority AxisY;
    public static ChartElementVisibilityPriority PaneTitle;
    public static ChartElementVisibilityPriority SeriesTitle;
    public static ChartElementVisibilityPriority AxisXTitle;
    public static ChartElementVisibilityPriority AxisYTitle;
    public static ChartElementVisibilityPriority Legend;
}
public static class DevExpress.Charts.Native.ChartsCommonUtils : object {
    public static double IncrementDouble(double value);
    public static double DecrementDouble(double value);
}
public class DevExpress.Charts.Native.ChartUpdate : object {
    private ChartElementChange change;
    [CompilerGeneratedAttribute]
private ChartUpdateInfoBase <UpdateInfo>k__BackingField;
    public ChartElementChange Change { get; public set; }
    public bool ShouldUpdateAutoSeries { get; }
    public bool ShouldUpdateAutoSeriesProperties { get; }
    public bool ShouldUpdateSeriesBinding { get; }
    public ChartUpdateInfoBase UpdateInfo { get; private set; }
    public ChartUpdate(ChartUpdateInfoBase updateInfo);
    public ChartUpdate(object sender, ChartElementChange change);
    public ChartUpdate(ChartElementChange change, ChartUpdateInfoBase updateInfo);
    public ChartElementChange get_Change();
    public void set_Change(ChartElementChange value);
    public bool get_ShouldUpdateAutoSeries();
    public bool get_ShouldUpdateAutoSeriesProperties();
    public bool get_ShouldUpdateSeriesBinding();
    [CompilerGeneratedAttribute]
public ChartUpdateInfoBase get_UpdateInfo();
    [CompilerGeneratedAttribute]
private void set_UpdateInfo(ChartUpdateInfoBase value);
}
internal class DevExpress.Charts.Native.ChartUpdateAggregator : object {
    private List`1<UpdateActionsGroupBase> updateGroups;
    private List`1<UpdateActionsGroupBase> groupsToRemove;
    private CommonActionType aggregatorActionType;
    public CommonActionType UpdateType { get; }
    public CommonActionType get_UpdateType();
    private void Add(IUpdateAction update);
    private void Add(AggregatorUpdateAction update);
    private void RefreshGroups(int removedSeriesIndex);
    private void RemoveGroups();
    public void AddRange(IEnumerable`1<IUpdateAction> updates);
    public IEnumerable`1<T> GetUpdates();
    public void Clear();
    public SeriesControllerChanges GetSeriesControllerChanges();
}
public abstract class DevExpress.Charts.Native.ChartUpdateInfoBase : object {
    private object sender;
    public object Sender { get; }
    protected ChartUpdateInfoBase(object sender);
    public object get_Sender();
}
[FlagsAttribute]
internal enum DevExpress.Charts.Native.ChartUpdateType : Enum {
    public int value__;
    public static ChartUpdateType NonUpdate;
    public static ChartUpdateType UpdateRangeControl;
    public static ChartUpdateType ThrowChanged;
    public static ChartUpdateType ClearTextureCache;
    public static ChartUpdateType ClearDiagramCache;
    public static ChartUpdateType ThrowRangeControlOptionsChanged;
    public static ChartUpdateType InvalidateRangeControl;
    public static ChartUpdateType UpdateSelectionState;
    public static ChartUpdateType UpdateSelectionStateForLegend;
    public static ChartUpdateType UpdateSeriesColorizer;
    public static ChartUpdateType ClearCaches;
}
public class DevExpress.Charts.Native.CircularAxisXMapping : SingleIntervalMappingCore {
    private List`1<Segment> segments;
    private double axisRadius;
    private GRealPoint2D axisCenter;
    private double startAngleInRadian;
    private CircularDiagramShapeStyleCore diagramShapeStyle;
    private CircularDiagramRotationDirectionCore rotationDirection;
    private bool looped;
    private double maxAxisValue;
    private double minAxisValue;
    public CircularAxisXMapping(IAxisData axis, ICircularDiagram circularDiagram, double radius, IList`1<double> values, bool looped);
    private double GetNormalizedAngleRadian(Segment segment, double normalizedValue);
    private double GetValueScaleByAngle(Segment segment, double angle);
    private double GetValueScale(Segment segment, double normalizedValue);
    private Segment FindSegment(double value);
    private Segment FindSegmentByAngle(double angle);
    private GRealPoint2D GetPoint(double angle, double radius, GRealPoint2D center);
    public double NormalizeValue(double value);
    public double GetNormalizedAngleRadian(double value);
    public double GetValueScale(double value);
    public double GetValueScaleByAngle(double angle);
    public GRealPoint2D GetPointOnCircularAxis(double value, GRealPoint2D center);
    public GRealPoint2D GetPointOnCircularAxis(double value);
    public bool IsLastValue(double value);
    public List`1<GRealPoint2D> GetMeshPoints(double radius);
    public bool ValueInRange(double value);
}
public class DevExpress.Charts.Native.CircularAxisYMappingCore : SingleIntervalMappingCore {
    public CircularAxisYMappingCore(IAxisData axis, double length);
}
public enum DevExpress.Charts.Native.CircularDiagramRotationDirectionCore : Enum {
    public int value__;
    public static CircularDiagramRotationDirectionCore Counterclockwise;
    public static CircularDiagramRotationDirectionCore Clockwise;
}
public enum DevExpress.Charts.Native.CircularDiagramShapeStyleCore : Enum {
    public int value__;
    public static CircularDiagramShapeStyleCore Circle;
    public static CircularDiagramShapeStyleCore Polygon;
}
public class DevExpress.Charts.Native.Cluster : object {
    private List`1<double> values;
    private double minHole;
    private double maxHole;
    private int maxHoleIndex;
    public List`1<double> Values { get; }
    public double FirstValue { get; }
    public double LastValue { get; }
    public double MinHole { get; }
    public double MaxHole { get; }
    public int MaxHoleIndex { get; }
    public double Size { get; }
    public Cluster(IEnumerable`1<double> sortedValues);
    public List`1<double> get_Values();
    public double get_FirstValue();
    public double get_LastValue();
    public double get_MinHole();
    public double get_MaxHole();
    public int get_MaxHoleIndex();
    public double get_Size();
    private void AddValue(double value);
    public void Split(Cluster& cluster1, Cluster& cluster2);
}
public class DevExpress.Charts.Native.Clusters : List`1<Cluster> {
    protected static double DefaultFactor;
    private double topHoleLimit;
    private double maxSize;
    private double minDistance;
    public double MaxSize { get; }
    public double MinDistance { get; }
    public Clusters(List`1<double> initialValues);
    public Clusters(List`1<double> initialValues, int clusterMaxCount, double factor);
    public double get_MaxSize();
    public double get_MinDistance();
    private void CalculateMaxSize();
    private void CalculateMinDistance();
    private int GetIndexOfClusterWithMaxHole();
}
public class DevExpress.Charts.Native.CohenSutherlandLineClipAlgorithm : object {
    private static int INSIDE;
    private static int LEFT;
    private static int RIGHT;
    private static int TOP;
    private static int BOTTOM;
    private double xMin;
    private double yMin;
    private double xMax;
    private double yMax;
    public CohenSutherlandLineClipAlgorithm(double xMin, double yMin, double xMax, double yMax);
    private int ComputeOutCode(double x, double y);
    public Tuple`4<double, double, double, double> GetCutLine(double x0, double y0, double x1, double y1);
}
[FlagsAttribute]
internal enum DevExpress.Charts.Native.CollectionActionType : Enum {
    public int value__;
    public static CollectionActionType InsertInCollection;
    public static CollectionActionType RemoveFromCollection;
    public static CollectionActionType MoveInCollection;
    public static CollectionActionType SwapInCollection;
    public static CollectionActionType CleanCollection;
}
public class DevExpress.Charts.Native.CollectionManager : object {
    protected RefinedSeries refinedSeries;
    private RefinedPointCollection points;
    private RefinedPointsArgumentComparer argumentComparer;
    private List`1<SortedRefinedPointCollectionBase> sortedCollections;
    private SortedArgumentRefinedPointCollection pointsSortedByArgument;
    private SortedRefinedPointCollection pointsSortedBySettings;
    private int minUpdatePointIndex;
    private bool ShouldSort { get; }
    public RefinedPointCollectionBase Points { get; }
    public RefinedPointCollectionBase PointsSortedBySettings { get; }
    public SortedArgumentRefinedPointCollection PointsSortedByArgument { get; }
    public CollectionManager(RefinedSeries refinedSeries);
    private bool get_ShouldSort();
    public RefinedPointCollectionBase get_Points();
    public RefinedPointCollectionBase get_PointsSortedBySettings();
    public SortedArgumentRefinedPointCollection get_PointsSortedByArgument();
    private sealed virtual override RefinedPoint DevExpress.Charts.Native.IRefinedPointCreator.CreateRefinedPoint(IPointProcessor processor, ISeriesPoint seriesPoint, List`1<AxisScaleTypeMap> argumentMaps);
    private void UpdateCollectionsList();
    private RefinedPoint RefinePoint(IPointProcessor processor, IDataPoint seriesPoint, List`1<AxisScaleTypeMap> argumentMaps);
    private void ProcessPoint(IPointProcessor processor, RefinedPoint point, List`1<AxisScaleTypeMap> argumentMaps);
    private void ProcessPointValues(IPointProcessor processor, RefinedPoint point);
    private void CleanSeriesPoints();
    internal virtual RefinedPoint[] InsertSeriesPoints(IPointProcessor processor, int insertIndex, ICollection`1<IDataPoint> insertPoints);
    private RefinedPoint[] RemoveSeriesPoints(int removeIndex, int pointsCount);
    private void MoveSeriesSinglePoint(int oldIndex, int newIndex);
    private void SwapSeriesSinglePoint(int index1, int index2);
    private bool DetectPointIndexOverflow(int pointsCount, int pointIndex);
    private void TryUpdatePointsIndices(int sourceCollectionStartIndex, RefinedPoint[] refinedPoints);
    private RefinedPoint FindRefinePointBySeriesPoint(IDataPoint seriesPoint);
    private RefinedSeriesPointsUpdateInfo CreateResetInfo();
    internal virtual RefinedSeriesPointsUpdateInfo UpdateCollections(IPointProcessor processor, SeriesPointsCollectionAction updateAction);
    internal List`1<RefinedSeriesPointsUpdateInfo> UpdatePoint(IPointProcessor processor, IDataPoint seriesPoint, List`1<AxisScaleTypeMap> argumentMaps);
    internal List`1<RefinedPoint> FindAllPointsWithSameArgument(RefinedPoint refinedPoint);
    internal void ReplacePoint(IDataPoint seriesPoint, int indexInCollection);
    public void UpdatePointsIndices();
    public void ProcessPoints(IPointProcessor processor);
    public void ProcessPointsValues(IPointProcessor processor);
    public void ProcessSortingPointModeUpdate(SortMode newSortingMode, SeriesPointKeyNative pointsSortingKey);
    public void ProcessSortingPointKeyUpdate(SeriesPointKeyNative newSortingKey, SortMode pointsSortingMode);
    public double GetMinAbsArgument();
    public RefinedPoint GetMinPoint(double argument);
    public RefinedPoint GetMaxPoint(double argument);
}
public abstract class DevExpress.Charts.Native.CollectionUpdateInfo : ChartUpdateInfoBase {
    private ChartCollectionOperation operation;
    private int oldIndex;
    private int newIndex;
    private object oldItem;
    private object newItem;
    public ChartCollectionOperation Operation { get; }
    public int OldIndex { get; }
    public int NewIndex { get; }
    public object OldItem { get; }
    public object NewItem { get; }
    protected CollectionUpdateInfo(object sender, ChartCollectionOperation operation, int oldIndex, int newIndex, object oldItem, object newItem);
    public ChartCollectionOperation get_Operation();
    public int get_OldIndex();
    public int get_NewIndex();
    public object get_OldItem();
    public object get_NewItem();
}
public class DevExpress.Charts.Native.CollectionUpdateInfo`1 : CollectionUpdateInfo {
    public T OldItem { get; }
    public T NewItem { get; }
    public CollectionUpdateInfo`1(object sender, ChartCollectionOperation operation, T oldItem, int oldIndex, T newItem, int newIndex);
    public T get_OldItem();
    public T get_NewItem();
}
internal abstract class DevExpress.Charts.Native.CollectionUpdateProcessor`1 : TypedUpdateProcessor`1<T> {
    protected CommonActionType AdditionalUpdates { get; }
    protected virtual CommonActionType get_AdditionalUpdates();
    protected virtual IList`1<IUpdateAction> TypedProcess(T updateInfo);
}
public class DevExpress.Charts.Native.ColoredStripInfo : ValueType {
    [CompilerGeneratedAttribute]
private GRealPoint2D <SplitPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private GeometryStripStyle <Style>k__BackingField;
    public GRealPoint2D SplitPoint { get; private set; }
    public GeometryStripStyle Style { get; private set; }
    public ColoredStripInfo(GRealPoint2D splitPoint, Nullable`1<int> color, GeometryStripStyleKey styleKey);
    public ColoredStripInfo(GRealPoint2D splitPoint, GeometryStripStyle style);
    [CompilerGeneratedAttribute]
public GRealPoint2D get_SplitPoint();
    [CompilerGeneratedAttribute]
private void set_SplitPoint(GRealPoint2D value);
    [CompilerGeneratedAttribute]
public GeometryStripStyle get_Style();
    [CompilerGeneratedAttribute]
private void set_Style(GeometryStripStyle value);
}
public class DevExpress.Charts.Native.ColorizerBindingProcedure : BindingProcedure {
    private IDataSourceColorizer colorizer;
    public ColorizerBindingProcedure(IDataSourceColorizer colorizer, DataContextBase dataContext, object dataSource, string dataMember, IEnumerable`1<ICalculatedField> calculatedFields);
    public void PopulateColorizer();
    protected virtual List`1<IDataMemberContainer> CreateDataMemberContainers();
    protected virtual Dictionary`2<string, IDataMemberContainer> CreateAdditionalDataMemberContainers();
}
public class DevExpress.Charts.Native.CommodityChannelIndexCalculator : object {
    private static int DesignTimePointsCount;
    private static double ReductionFactor;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    public static bool IsCompatible(ISeriesView view);
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    private double CalculateTypicalPrice(IFinancialPoint refinedPoint);
    private double CalculateMad(Queue`1<double> typicalPriceQueue, double tpma);
    private double CalculateCCI(double typicalPrice, double tpma, double mad);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount);
}
[FlagsAttribute]
public enum DevExpress.Charts.Native.CommonActionType : Enum {
    public int value__;
    public static CommonActionType Empty;
    public static CommonActionType UpdateSeriesGroupsInteraction;
    public static CommonActionType UpdateCrosshair;
    public static CommonActionType ResetSelectedItems;
    public static CommonActionType DeserializeRange;
    public static CommonActionType UpdatePointsIndices;
    public static CommonActionType UpdateMeasureUnits;
    public static CommonActionType Commit;
    public static CommonActionType RaiseWholeRangeChanged;
    public static CommonActionType RaiseVisualRangeChanged;
    public static CommonActionType RecalculateArgumentScale;
    public static CommonActionType UpdateVisualPointIndicesOnly;
    public static CommonActionType EndLoading;
    public static CommonActionType UpdateSeriesGroupsInteractionKeys;
    public static CommonActionType UpdateIndicators;
    public static CommonActionType AnimateChart;
}
public abstract class DevExpress.Charts.Native.ComparableDataMemberContainer`1 : DataMemberContainer`1<T> {
    private bool supportEmptyValue;
    public bool SupportEmptyValue { get; }
    public IComparable ComparableValue { get; }
    public ComparableDataMemberContainer`1(string dataMember, bool supportEmptyValue);
    public virtual bool get_SupportEmptyValue();
    public sealed virtual IComparable get_ComparableValue();
}
public enum DevExpress.Charts.Native.CompatibleViewType : Enum {
    public int value__;
    public static CompatibleViewType XYView;
    public static CompatibleViewType SimpleView;
    public static CompatibleViewType RadarView;
    public static CompatibleViewType PolarView;
    public static CompatibleViewType GanttView;
    public static CompatibleViewType SwiftPlotView;
}
public enum DevExpress.Charts.Native.Condition : Enum {
    public int value__;
    public static Condition Equal;
    public static Condition GreaterThan;
    public static Condition GreaterThanOrEqual;
    public static Condition LessThan;
    public static Condition LessThanOrEqual;
    public static Condition NotEqual;
}
public enum DevExpress.Charts.Native.Conjunction : Enum {
    public int value__;
    public static Conjunction And;
    public static Conjunction Or;
}
public enum DevExpress.Charts.Native.CorePointState : Enum {
    public int value__;
    public static CorePointState HasValues;
    public static CorePointState Empty;
    public static CorePointState EmptyWithNonDefaultValues;
}
public class DevExpress.Charts.Native.CountAggregationCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.CrosshairAxisInfo : object {
    private string text;
    private GRealPoint2D anchorPoint;
    private GRealSize2D maxSize;
    private IAxisData axis;
    private object value;
    private GRealSize2D size;
    public string Text { get; }
    public GRealPoint2D AnchorPoint { get; }
    public IAxisData Axis { get; }
    public GRealSize2D Size { get; public set; }
    public GRealSize2D MaxSize { get; }
    public GRealRect2D Bounds { get; }
    public object Value { get; }
    public CrosshairAxisInfo(string text, GRealPoint2D anchorPoint, GRealSize2D maxSize, IAxisData axis, object value);
    public string get_Text();
    public GRealPoint2D get_AnchorPoint();
    public IAxisData get_Axis();
    public GRealSize2D get_Size();
    public void set_Size(GRealSize2D value);
    public GRealSize2D get_MaxSize();
    public GRealRect2D get_Bounds();
    public object get_Value();
}
public class DevExpress.Charts.Native.CrosshairCollectionSynchronizer`2 : object {
    public void Synchronize(IList`1<D> masterCollection, IList`1<B> slaveCollection);
}
public enum DevExpress.Charts.Native.CrosshairContentShowModeCore : Enum {
    public int value__;
    public static CrosshairContentShowModeCore Label;
    public static CrosshairContentShowModeCore Legend;
}
public abstract class DevExpress.Charts.Native.CrosshairDataCalculator : object {
    public static CrosshairDataCalculator CreateCalculator(IXYSeriesView seriesView, bool snapToArgument, bool scrollingEnabled);
    public static Func`2<int, double> GetSeriesPointArgumentAction(IList`1<RefinedPoint> points);
    public static Func`2<int, IEnumerable`1<double>> GetSeriesPointValuesAction(IList`1<RefinedPoint> points, IXYSeriesView seriesView);
    public static Func`2<int, double> GetIndicatorPointArgumentAction(IIndicator indicator);
    public static Func`2<int, IEnumerable`1<double>> GetIndicatorPointValuesAction(IIndicator indicator);
    public static bool IsValueInScaleBreak(IEnumerable`1<IScaleBreak> scaleBreaks, double value);
    public abstract virtual void ProcessPoints(CrosshairDataList crosshairSortedData, IList`1<RefinedPoint> pointsInfo, int startPointIndex, int endPointIndex);
    public abstract virtual void ProcessIndicatorPoints(CrosshairDataList crosshairSortedData, IIndicator indicator, int startPointIndex, int endPointIndex);
}
public class DevExpress.Charts.Native.CrosshairDataCalculatorByArgument : CrosshairDataCalculator {
    private void ProcessPointsCore(CrosshairDataList crosshairSortedData, Func`2<int, double> getArgument, int startPointIndex, int endPointIndex);
    public virtual void ProcessPoints(CrosshairDataList crosshairSortedData, IList`1<RefinedPoint> pointsInfo, int startPointIndex, int endPointIndex);
    public virtual void ProcessIndicatorPoints(CrosshairDataList crosshairSortedData, IIndicator indicator, int startPointIndex, int endPointIndex);
}
public class DevExpress.Charts.Native.CrosshairDataCalculatorByArgumentWithScaleBreaks : CrosshairDataCalculator {
    private IXYSeriesView seriesView;
    private IEnumerable`1<IScaleBreak> argumentScaleBreaks;
    private IEnumerable`1<IScaleBreak> valueScaleBreaks;
    public CrosshairDataCalculatorByArgumentWithScaleBreaks(IXYSeriesView seriesView, IEnumerable`1<IScaleBreak> argumentScaleBreaks, IEnumerable`1<IScaleBreak> valueScaleBreaks);
    private void ProcessPointsCore(CrosshairDataList crosshairSortedData, Func`2<int, double> getArgument, Func`2<int, IEnumerable`1<double>> getValues, int startPointIndex, int endPointIndex);
    public virtual void ProcessPoints(CrosshairDataList crosshairSortedData, IList`1<RefinedPoint> pointsInfo, int startPointIndex, int endPointIndex);
    public virtual void ProcessIndicatorPoints(CrosshairDataList crosshairSortedData, IIndicator indicator, int startPointIndex, int endPointIndex);
}
public class DevExpress.Charts.Native.CrosshairDataCalculatorByValue : CrosshairDataCalculator {
    private IXYSeriesView seriesView;
    public CrosshairDataCalculatorByValue(IXYSeriesView seriesView);
    private void ProcessPointsCore(CrosshairDataList crosshairSortedData, Func`2<int, IEnumerable`1<double>> getCrosshairValues, int startPointIndex, int endPointIndex);
    public virtual void ProcessPoints(CrosshairDataList crosshairSortedData, IList`1<RefinedPoint> pointsInfo, int startPointIndex, int endPointIndex);
    public virtual void ProcessIndicatorPoints(CrosshairDataList crosshairSortedData, IIndicator indicator, int startPointIndex, int endPointIndex);
}
public class DevExpress.Charts.Native.CrosshairDataCalculatorByValueWithScaleBreaks : CrosshairDataCalculator {
    private IXYSeriesView seriesView;
    private IEnumerable`1<IScaleBreak> valueScaleBreaks;
    public CrosshairDataCalculatorByValueWithScaleBreaks(IXYSeriesView seriesView, IEnumerable`1<IScaleBreak> valueScaleBreaks);
    private void ProcessPointsCore(CrosshairDataList crosshairSortedData, Func`2<int, IEnumerable`1<double>> getValues, int startPointIndex, int endPointIndex);
    public virtual void ProcessPoints(CrosshairDataList crosshairSortedData, IList`1<RefinedPoint> pointsInfo, int startPointIndex, int endPointIndex);
    public virtual void ProcessIndicatorPoints(CrosshairDataList crosshairSortedData, IIndicator indicator, int startPointIndex, int endPointIndex);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.CrosshairDataList : object {
    private static int DefaultCapacity;
    private static int MaxCapacityStep;
    private CrosshairValueItem[] data;
    private int capacity;
    private int count;
    public CrosshairValueItem Item { get; }
    public int Count { get; }
    public CrosshairValueItem get_Item(int index);
    public int get_Count();
    private static int Closest(int value);
    private int CalculateCapacity(int initialCapacity, int newCount);
    public void Realloc(int newCount);
    public void Add(double value, int index);
    public void Sort(IComparer`1<CrosshairValueItem> comparer);
    public int BinarySearch(CrosshairValueItem value, IComparer`1<CrosshairValueItem> comparer);
    public void Clear();
}
public class DevExpress.Charts.Native.CrosshairElementPoint : object {
    private CrosshairLine crosshairLine;
    private CrosshairAxisInfo crosshairAxisInfo;
    public CrosshairLine CrosshairLine { get; internal set; }
    public CrosshairAxisInfo CrosshairAxisInfo { get; internal set; }
    public CrosshairLine get_CrosshairLine();
    internal void set_CrosshairLine(CrosshairLine value);
    public CrosshairAxisInfo get_CrosshairAxisInfo();
    internal void set_CrosshairAxisInfo(CrosshairAxisInfo value);
}
public class DevExpress.Charts.Native.CrosshairGroupHeaderValueToStringConverter : ToolTipValueToStringConverter {
    protected string DefaultValuePattern { get; }
    protected string GroupedPointValuePattern { get; }
    public CrosshairGroupHeaderValueToStringConverter(ISeries series, bool allowArgument, bool allowValue);
    protected virtual string get_DefaultValuePattern();
    protected virtual string get_GroupedPointValuePattern();
}
public class DevExpress.Charts.Native.CrosshairIndicatorPatternHolder : object {
    public sealed virtual PatternDataProvider GetDataProvider(string patternConstant);
}
public class DevExpress.Charts.Native.CrosshairIndicatorPoint : CrosshairSeriesPointBase {
    private static CrosshairIndicatorPatternHolder crosshairIndicatorPatternHolder;
    private Dictionary`2<IndicatorValueLevelCore, double> valuesByType;
    public Dictionary`2<IndicatorValueLevelCore, double> ValuesByType { get; }
    public object PatternGroupContext { get; }
    public IIndicator Indicator { get; }
    public CrosshairContentShowModeCore CrosshairContentShowMode { get; }
    public CrosshairIndicatorPoint(PointProjectionOnAxis argument, PointProjectionOnAxis value, GRealPoint2D anchorPoint, IRefinedSeries refinedSeries, ILegendItem legendItem, Dictionary`2<IndicatorValueLevelCore, double> valuesByType);
    private static CrosshairIndicatorPoint();
    public Dictionary`2<IndicatorValueLevelCore, double> get_ValuesByType();
    public virtual object get_PatternGroupContext();
    public IIndicator get_Indicator();
    public virtual CrosshairContentShowModeCore get_CrosshairContentShowMode();
    protected virtual string GetActualPattern(ICrosshairOptions options, bool isInGroup);
    protected virtual IPatternHolder GetPatternHolder();
    protected virtual void SetPatternParseContext(PatternParser patternParser, bool isGroupPattern);
    protected virtual void AddToGroup(int index, CrosshairPointsGroup group);
    protected virtual int GetCorrectPointIndex(int index);
    public virtual void AddToCrosshairInfo(CrosshairInfo crosshairInfo);
    public virtual MinMaxValues CalculateMinMaxRange(double range, bool isHorizontalCrosshair, IXYDiagram xYDiagram, CrosshairPaneInfo crosshairPaneInfo, CrosshairSnapModeCore snapMode);
}
public static class DevExpress.Charts.Native.CrosshairIndicatorPointsCalculator : object {
    private static double CalculateLineCoordinateCore(double cursorCoordinate1, double cursorCoordinate2, double minCoordinateAxis1, double maxCoordinateAxis1, double startCoordinateAxis2, double endCoordinateAxis2, bool extrapolateToNegativeInfinity, bool extrapolateToPositiveInfinity);
    public static Dictionary`2<IndicatorValueLevelCore, double> CalculateIndicatorValuesByType(Dictionary`2<IndicatorValueLevelCore, List`1<GRealPoint2D>> linesPoints, int index);
    public static Dictionary`2<IndicatorValueLevelCore, double> CalculateErrorBarValuesByType(int index, List`1<ErrorBarData> errorBarData, ErrorBarDirectionCore direction);
    public static double CalculateLineCoordinate(double cursorCoordinate1, double cursorCoordinate2, double startCoordinateAxis1, double endCoordinateAxis1, double startCoordinateAxis2, double endCoordinateAxis2, bool extrapolateToNegativeInfinity, bool extrapolateToPositiveInfinity);
}
public class DevExpress.Charts.Native.CrosshairInfo : object {
    private List`1<CrosshairPaneInfo> crosshairPaneInfos;
    private List`1<CrosshairLegendPoint> emptyLegendPoints;
    private List`1<CrosshairSeriesPoint> seriesLegendPoints;
    private List`1<CrosshairIndicatorPoint> indicatorLegendPoints;
    public List`1<CrosshairPaneInfo> CrosshairPaneInfos { get; }
    public List`1<CrosshairLegendPoint> EmptyLegendPoints { get; }
    public List`1<CrosshairSeriesPoint> SeriesLegendPoints { get; }
    public List`1<CrosshairIndicatorPoint> IndicatorLegendPoints { get; }
    public List`1<CrosshairPaneInfo> get_CrosshairPaneInfos();
    public List`1<CrosshairLegendPoint> get_EmptyLegendPoints();
    public List`1<CrosshairSeriesPoint> get_SeriesLegendPoints();
    public List`1<CrosshairIndicatorPoint> get_IndicatorLegendPoints();
    public void AddPaneInfo(CrosshairPaneInfo paneInfo);
    public CrosshairPaneInfo GetByPane(IPane pane);
    public void CompleteLabelsLayout();
}
public class DevExpress.Charts.Native.CrosshairLabelInfo : object {
    private ICollection`1<CrosshairPointsGroup> pointGroups;
    private GRealPoint2D anchorPoint;
    private GRealSize2D size;
    private GRealRect2D bounds;
    private bool showTail;
    private AnnotationLocation location;
    private GRealPoint2D offset;
    private GRealPoint2D initOffset;
    public ICollection`1<CrosshairPointsGroup> PointGroups { get; }
    public GRealPoint2D AnchorPoint { get; }
    public GRealSize2D Size { get; public set; }
    public GRealRect2D Bounds { get; public set; }
    public bool ShowTail { get; public set; }
    public double CursorOffset { get; }
    public AnnotationLocation Location { get; public set; }
    public GRealPoint2D Offset { get; public set; }
    public GRealPoint2D InitOffset { get; }
    public CrosshairLabelInfo(IList`1<CrosshairPointsGroup> pointGroups, GRealPoint2D anchorPoint, AnnotationLocation defaultLocation, bool showTail, GRealPoint2D initOffset);
    public ICollection`1<CrosshairPointsGroup> get_PointGroups();
    public sealed virtual GRealPoint2D get_AnchorPoint();
    public sealed virtual GRealSize2D get_Size();
    public void set_Size(GRealSize2D value);
    public sealed virtual GRealRect2D get_Bounds();
    public sealed virtual void set_Bounds(GRealRect2D value);
    public sealed virtual bool get_ShowTail();
    public void set_ShowTail(bool value);
    public sealed virtual double get_CursorOffset();
    public sealed virtual AnnotationLocation get_Location();
    public sealed virtual void set_Location(AnnotationLocation value);
    public sealed virtual GRealPoint2D get_Offset();
    public sealed virtual void set_Offset(GRealPoint2D value);
    public sealed virtual GRealPoint2D get_InitOffset();
}
public enum DevExpress.Charts.Native.CrosshairLabelModeCore : Enum {
    public int value__;
    public static CrosshairLabelModeCore ShowForEachSeries;
    public static CrosshairLabelModeCore ShowForNearestSeries;
    public static CrosshairLabelModeCore ShowCommonForAllSeries;
}
public class DevExpress.Charts.Native.CrosshairLegendPoint : CrosshairElementPoint {
    private ILegendItem legendItem;
    public string CrosshairSeriesText { get; }
    public ILegendItem LegendItem { get; }
    public CrosshairLegendPoint(ILegendItem legendItem);
    public virtual string get_CrosshairSeriesText();
    public ILegendItem get_LegendItem();
}
public class DevExpress.Charts.Native.CrosshairLine : object {
    private GRealLine2D line;
    private bool isValueLine;
    public GRealLine2D Line { get; }
    public bool IsValueLine { get; }
    public CrosshairLine(GRealLine2D line, bool isValueLine);
    public GRealLine2D get_Line();
    public bool get_IsValueLine();
}
public enum DevExpress.Charts.Native.CrosshairLinesModeCore : Enum {
    public int value__;
    public static CrosshairLinesModeCore Auto;
    public static CrosshairLinesModeCore Free;
}
public class DevExpress.Charts.Native.CrosshairManager : object {
    private IXYDiagram xyDiagram;
    private Dictionary`2<IRefinedSeries, CrosshairSeriesData> crosshairDataList;
    private IList`1<PaneAxesContainer> paneAxisRepositories;
    private bool IsHorizontalCrosshair { get; }
    private ICrosshairFreePosition LabelPosition { get; }
    private bool SnapToArgument { get; }
    private ICrosshairOptions CrosshairOptions { get; }
    public CrosshairManager(IXYDiagram diagram);
    public static MinMaxValues CalculateMinMaxMarkerSeriesRangeValues(CrosshairSeriesPointBase point, double range, bool isHorizontalCrosshair);
    public static MinMaxValues CalculateMinMaxContinuousSeriesRangeValues(CrosshairSeriesPoint point, double range, bool isHorizontalCrosshair, CrosshairPaneInfo crosshairPaneInfo, CrosshairSnapModeCore snapMode);
    public static MinMaxValues CalculateMinMaxBarRangeValues(CrosshairSeriesPoint point, double range, bool isHorizontalCrosshair, IXYDiagram diagram, IPane pane, CrosshairSnapModeCore snapMode, double minBarValue, double maxBarValue);
    public static CrosshairSeriesPoint CreateCrosshairSeriesPoint(IXYDiagram xyDiagram, IXYSeriesView seriesView, double pointArgument, double pointValue, CrosshairPaneInfo crosshairPaneInfo, IRefinedSeries refinedSeries, RefinedPoint nearestPointInfo, PointPositionInSeries pointPosition, int pointIndex);
    public static CrosshairIndicatorPoint CreateCrosshairIndicatorPoint(IXYDiagram xyDiagram, double pointArgument, double pointValue, IRefinedSeries refinedSeries, IIndicator indicator, Dictionary`2<IndicatorValueLevelCore, double> valuesByType);
    private bool get_IsHorizontalCrosshair();
    private ICrosshairFreePosition get_LabelPosition();
    private bool get_SnapToArgument();
    private ICrosshairOptions get_CrosshairOptions();
    private CrosshairSeriesData GetCrosshairData(IRefinedSeries refinedSeries);
    private void CalculatePanesCrosshairPoints(List`1<CrosshairPaneInfo> crosshairPaneInfos, IList`1<IRefinedSeries> refinedSeries);
    private void AddCrosshairPoint(IList`1<CrosshairSeriesPointBase> crosshairPoints, CrosshairSeriesPoint crosshairSeriesPoint, List`1<IRefinedSeries> calculatedSeries, HashSet`1<IAxisData> qualitativeAxes);
    private void FillCrosshairPoints(List`1<CrosshairSeriesPointBase> paneCrosshairPoints, IRefinedSeries refinedSeries, CrosshairSeriesData crosshairSeriesData, CrosshairPaneInfo crosshairPaneInfo, List`1<IRefinedSeries> calculatedSeries, List`1<IIndicator> calculatedIndicators, HashSet`1<IAxisData> qualitativeAxes);
    private void FillIndicatorPoints(List`1<CrosshairSeriesPointBase> paneCrosshairPoints, IEnumerable`1<IIndicator> indicators, List`1<IIndicator> calculatedIndicators, CrosshairPaneInfo crosshairPaneInfo, double crosshairArgument, CrosshairSeriesData crosshairSeriesData, Func`2<CrosshairIndicatorPoint, bool> needAddPoint, bool crosshairSeriesPointAdded);
    private void FillPointGroups(List`1<CrosshairSeriesPointBase> crosshairPoints, CrosshairSeriesPoint crosshairPoint, CrosshairPaneInfo crosshairPaneInfo, List`1<IRefinedSeries> calculatedSeries, List`1<IIndicator> calculatedIndicators, HashSet`1<IAxisData> qualitativeAxes, double crosshairArgument);
    private List`1<CrosshairSeriesPointBase> FindDifferentPointsByValueSelectionMode(HashSet`1<IAxisData> qualitativeAxes, CrosshairPaneInfo crosshairPaneInfo, IEnumerable`1<CrosshairSeriesPointBase> crosshairSeriesPoints);
    private PointProjectionOnAxis GetPointProjection(CrosshairSeriesPointBase point, CrosshairSnapModeCore snapMode);
    private List`1<CrosshairSeriesPointBase> RemoveDifferentPoints(CrosshairPaneInfo crosshairPaneInfo, IEnumerable`1<CrosshairSeriesPointBase> crosshairSeriesPoints);
    private AxisScaleTypeCollectionManagerBase CreateCollectionManager(CrosshairSnapModeCore snapMode, PointProjectionOnAxis pointProjection, IAxisData axis, object crosshairAxisValue);
    private List`1<CrosshairSeriesPointBase> RemoveDifferentPointsByValueSelectionMode(HashSet`1<IAxisData> qualitativeAxes, CrosshairPaneInfo crosshairPaneInfo, IEnumerable`1<CrosshairSeriesPointBase> crosshairSeriesPoints);
    private List`1<CrosshairSeriesPointBase> CalculateNearestPoint(List`1<CrosshairSeriesPointBase> crosshairSeriesPoints, GRealPoint2D crosshairLocation);
    private void CreateCrosshairPaneInfos(CrosshairInfo crosshairInfo, GRealPoint2D crosshairLocation, IPane focusedPane, IXYDiagram diagram, InternalCoordinatesCalculator calculator);
    private bool IsValidBounds(Nullable`1<GRealRect2D> bounds);
    private void CalculateAxisValues(CrosshairPaneInfo crosshairPaneInfo, IEnumerable`1<CrosshairSeriesPointBase> crosshairPoints, ICrosshairOptions options);
    private void AddAxisValuesForCursorSnapAxes(CrosshairPaneInfo crosshairPaneInfo, ICrosshairOptions options);
    private PaneAxesContainer GetPaneAxesContainer(IPane pane);
    private List`1<PointProjectionOnAxis> GetAxisValueForCursorSnapAxes(PointProjectionsForPane crosshairCoords, IPane pane, bool isFocusedPane, bool snapToArguments);
    private void AddAxisValuesByPoints(CrosshairPaneInfo crosshairPaneInfo, IEnumerable`1<CrosshairSeriesPointBase> crosshairPoints, ICrosshairOptions options);
    private Dictionary`2<PointProjectionOnAxis, GRealPoint2D> BindAxisValueAndScreenCoords(ICrosshairOptions options, CrosshairPaneInfo crosshairPaneInfo);
    private void CalculateCrossLines(CrosshairPaneInfo crosshairPaneInfo, IEnumerable`1<CrosshairSeriesPointBase> crosshairPoints, Dictionary`2<PointProjectionOnAxis, GRealPoint2D> screenCoords);
    private void CalculateAxisLabels(CrosshairPaneInfo crosshairPaneInfo, IEnumerable`1<CrosshairSeriesPointBase> crosshairPoints, Dictionary`2<PointProjectionOnAxis, GRealPoint2D> screenCoords, bool needGenerateFullInfo);
    private void CreateCrosshairLabels(GRealRect2D labelsConstraint, IPane focusedPane, ICrosshairOptions options, CrosshairInfo crosshairInfo);
    private void CreateCrosshairLegendInfos(ICrosshairOptions options, CrosshairInfo crosshairInfo, IEnumerable`1<ILegendItem> legendCrosshairItems);
    private PointProjectionOnAxis GetAxisValuePair(ICrosshairOptions options, CrosshairSeriesPointBase point);
    private CrosshairAxisInfo CreateCrosshairAxisInfo(CrosshairPaneInfo crosshairPaneInfo, Dictionary`2<PointProjectionOnAxis, GRealPoint2D> screenCoords, PointProjectionOnAxis axisValue);
    private bool IsAxisLabelVisible(PointProjectionOnAxis axisValuePair);
    private CrosshairLine CreateCrossLine(Dictionary`2<PointProjectionOnAxis, GRealPoint2D> screenCoords, GRealRect2D mappingBounds, PointProjectionOnAxis axisValue);
    private CrosshairLine CreateCrossLine(double startX, double startY, double endX, double endY, bool isValueLine);
    private bool IsScreenCoordInBounds(bool axisIsVertical, GRealPoint2D screenCoord, GRealRect2D mappingBounds);
    private bool IsSeriesForCrosshair(ISeries series);
    private void ProcessSeriesUpdateInfo(RefinedSeriesUpdateInfo updateInfo);
    public void UpdateIndicatorsData();
    public void ClearCrosshairData();
    public void UpdateDataForSeries(IList`1<RefinedSeries> seriesCollection);
    public void UpdateCrosshairData(ICollection`1<RefinedSeriesUpdateInfo> seriesUpdateInfo, ICollection`1<RefinedSeriesPointsUpdateInfo> pointsUpdateInfo);
    public static void CalculateAnchorLocation(IXYDiagram diagram, ICrosshairFreePosition labelPosition, GRealPoint2D& anchorPoint, AnnotationLocation& annotationLocation);
    public CrosshairInfo CalculateCrosshairInfoForLegends(IEnumerable`1<ILegendItem> legendCrosshairItems);
    public CrosshairInfo CalculateCrosshairInfo(GRealPoint2D crosshairLocation, bool crosshairLocationIsEmpty, GRealRect2D labelsConstraint, IList`1<PaneAxesContainer> paneAxisRepositories, IPane focusedPane, IList`1<IRefinedSeries> refinedSeries, IEnumerable`1<ILegendItem> legendCrosshairItems, bool needGenerateFullInfo);
    public CrosshairInfo CalculateCrosshairInfo(object argument, object value, bool outOfRange, GRealRect2D labelsConstraint, IList`1<PaneAxesContainer> paneAxisRepositories, IPane focusedPane, IAxisData axisX, IAxisData axisY, IList`1<IRefinedSeries> refinedSeries, IEnumerable`1<ILegendItem> legendCrosshairItems, bool needGenerateFullInfo);
    private void CalculateCrosshairInfoElements(CrosshairInfo crosshairInfo, IList`1<IRefinedSeries> refinedSeries, GRealRect2D labelsConstraint, IPane focusedPane, bool needGenerateFullInfo);
    public CrosshairDataList GetCrosshairSortedData(IRefinedSeries refinedSeries);
    public CrosshairDataList GetCrosshairSortedData(IIndicator indicator, IRefinedSeries refinedSeries);
}
internal class DevExpress.Charts.Native.CrosshairOptionsPropertiesUpdateProcessor : TypedUpdateProcessor`2<PropertyUpdateInfo, ICrosshairOptions> {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo updateInfo, ICrosshairOptions sender);
}
public class DevExpress.Charts.Native.CrosshairPaneInfo : object {
    private IPane pane;
    private bool isFocusedPane;
    private GRealRect2D mappingBounds;
    private GRealPoint2D cursorLocation;
    private PointProjectionsForPane cursorCoords;
    private GRealRect2D labelsConstraint;
    private List`1<PointProjectionOnAxis> allPointProjections;
    private List`1<CrosshairSeriesPointBase> labelSeriesPoints;
    private List`1<CrosshairSeriesPointBase> legendSeriesPoints;
    private List`1<CrosshairSeriesPoint> pointsForHighlight;
    private List`1<CrosshairLabelInfo> labelsInfo;
    private HashSet`1<PointProjectionOnAxis> hashes;
    private CrosshairLine cursorArgumentCrossLine;
    private CrosshairLine cursorValueCrossLine;
    private List`1<CrosshairAxisInfo> cursorAxesInfo;
    [CompilerGeneratedAttribute]
private bool <ContainsSeriesForCrosshair>k__BackingField;
    public IPane Pane { get; }
    public bool IsFocusedPane { get; }
    public GRealRect2D MappingBounds { get; }
    public GRealPoint2D CursorLocation { get; }
    public PointProjectionsForPane CursorCoords { get; }
    public List`1<PointProjectionOnAxis> AllAxesValues { get; }
    public List`1<CrosshairSeriesPointBase> LabelSeriesPoints { get; }
    public List`1<CrosshairSeriesPointBase> LegendSeriesPoints { get; }
    public IEnumerable`1<CrosshairSeriesPoint> PointsForHighlight { get; }
    public IEnumerable`1<CrosshairSeriesPointBase> AllPoints { get; }
    public List`1<CrosshairLabelInfo> LabelsInfo { get; }
    public GRealRect2D LabelsConstraint { get; public set; }
    public CrosshairLine CursorArgumentCrossLine { get; internal set; }
    public CrosshairLine CursorValueCrossLine { get; internal set; }
    public List`1<CrosshairAxisInfo> CursorAxesInfo { get; }
    public bool ContainsSeriesForCrosshair { get; public set; }
    public CrosshairPaneInfo(IPane pane, bool isFocusedPane, GRealRect2D mappingBounds, GRealPoint2D cursorLocation, PointProjectionsForPane cursorCoords);
    public static string ConstructAxisText(PointProjectionOnAxis axisValue);
    public static string GetActualPattern(string crosshairLabelPattern, ToolTipPointDataToStringConverter converter);
    public static string ConstructXYZSeriesText(XYZPointProjections pointProjections, IXYSeriesView view, RefinedPoint refinedPoint);
    public IPane get_Pane();
    public bool get_IsFocusedPane();
    public GRealRect2D get_MappingBounds();
    public GRealPoint2D get_CursorLocation();
    public PointProjectionsForPane get_CursorCoords();
    public List`1<PointProjectionOnAxis> get_AllAxesValues();
    public List`1<CrosshairSeriesPointBase> get_LabelSeriesPoints();
    public List`1<CrosshairSeriesPointBase> get_LegendSeriesPoints();
    public IEnumerable`1<CrosshairSeriesPoint> get_PointsForHighlight();
    public IEnumerable`1<CrosshairSeriesPointBase> get_AllPoints();
    public List`1<CrosshairLabelInfo> get_LabelsInfo();
    public GRealRect2D get_LabelsConstraint();
    public void set_LabelsConstraint(GRealRect2D value);
    public CrosshairLine get_CursorArgumentCrossLine();
    internal void set_CursorArgumentCrossLine(CrosshairLine value);
    public CrosshairLine get_CursorValueCrossLine();
    internal void set_CursorValueCrossLine(CrosshairLine value);
    public List`1<CrosshairAxisInfo> get_CursorAxesInfo();
    [CompilerGeneratedAttribute]
public bool get_ContainsSeriesForCrosshair();
    [CompilerGeneratedAttribute]
public void set_ContainsSeriesForCrosshair(bool value);
    public void AddValue(PointProjectionOnAxis axisValue);
    public void AddSeriesPoint(CrosshairSeriesPointBase seriesPointBase);
    public void AddCrosshairLabel(List`1<CrosshairSeriesPointBase> seriesPoints, GRealPoint2D anchorPoint, AnnotationLocation defaultLocation, bool showTail, GRealPoint2D initOffset, ICrosshairOptions crosshairOptions);
    public void AddCrosshairLabel(CrosshairSeriesPointBase seriesPoint, ICrosshairOptions crosshairOptions);
    public void CompleteLabelsLayout();
}
internal class DevExpress.Charts.Native.CrosshairPointComparer : Comparer`1<CrosshairSeriesPointBase> {
    public virtual int Compare(CrosshairSeriesPointBase point1, CrosshairSeriesPointBase point2);
}
public class DevExpress.Charts.Native.CrosshairPointsGroup : object {
    private string headerText;
    private List`1<CrosshairSeriesPoint> seriesPoints;
    private double anchorValue;
    private List`1<CrosshairSeriesPointBase> points;
    internal double AnchorValue { get; }
    public List`1<CrosshairSeriesPoint> SeriesPoints { get; }
    public List`1<CrosshairSeriesPointBase> Points { get; }
    public string HeaderText { get; internal set; }
    internal CrosshairPointsGroup(double anchorValue);
    internal double get_AnchorValue();
    public List`1<CrosshairSeriesPoint> get_SeriesPoints();
    public List`1<CrosshairSeriesPointBase> get_Points();
    public string get_HeaderText();
    internal void set_HeaderText(string value);
    public void InsertSeriesPoint(int index, CrosshairSeriesPoint crosshairSeriesPoint);
}
public class DevExpress.Charts.Native.CrosshairSeriesData : object {
    private static double crosshairRange;
    private static int crosshairPixelsRange;
    private static CrosshairSortedPointsInfoComparer crosshairComparer;
    private IXYDiagram diagram;
    private IRefinedSeries series;
    private CrosshairDataList crosshairSeriesPointsSortedData;
    private Dictionary`2<IIndicator, CrosshairDataList> crosshairIndicatorPointsSortedData;
    private IXYSeriesView seriesView;
    private IList`1<RefinedPoint> pointsInfo;
    private int prevPointsCount;
    private bool ShowCrosshair { get; }
    private bool ShowSeriesCrosshair { get; }
    private bool SnapToArgument { get; }
    private bool IsHorizontalCrosshair { get; }
    public Dictionary`2<IIndicator, CrosshairDataList> CrosshairIndicatorPointsSortedData { get; }
    public CrosshairDataList CrosshairSortedData { get; }
    public CrosshairSeriesData(IXYDiagram diagram, IRefinedSeries series);
    private static CrosshairSeriesData();
    private bool get_ShowCrosshair();
    private bool get_ShowSeriesCrosshair();
    private bool get_SnapToArgument();
    private bool get_IsHorizontalCrosshair();
    public Dictionary`2<IIndicator, CrosshairDataList> get_CrosshairIndicatorPointsSortedData();
    public CrosshairDataList get_CrosshairSortedData();
    private int CheckPointsWithSameValue(CrosshairDataList crosshairSortedData, int crosshairValueItemIndex, double cursorPoint, Func`2<int, IEnumerable`1<double>> getValues, Func`2<int, double> getArgument, Double& nearestValue);
    private double GetMinDistance(CrosshairDataList crosshairSortedData, double cursorPoint, int crosshairValueItemIndex, Func`2<int, IEnumerable`1<double>> getValues, Func`2<int, double> getArgument, Double& value);
    private double GetMinValueDistance(CrosshairDataList crosshairSortedData, double value, int crosshairValueItemIndex, Func`2<int, IEnumerable`1<double>> getValues, Double& pointValue);
    private double GetMinArgumentDistance(CrosshairDataList crosshairSortedData, double argument, int crosshairValueItemIndex, Func`2<int, double> getArgument, Double& pointArgument);
    private PointPositionInSeries CalculatePointPositionInSeries(int pointIndex);
    private bool IsPointsArgumentGreater(IEnumerable`1<RefinedPoint> points, double maxArgument);
    private void ProcessIndicatorPoints(CrosshairDataCalculator calculator, bool force);
    private Int32[] GetCrosshairPointIndices(CrosshairDataList crosshairSortedData, double argument, double value);
    private RefinedPoint GetCrosshairPoint(int valueItemIndex, double argument, double value, Double& pointArgument, Double& pointValue, Int32& pointIndex);
    private Dictionary`2<IndicatorValueLevelCore, double> GetIndicatorInfo(CrosshairDataList indicatorSortedData, IIndicator indicator, int valueItemIndex, double argument, double value, Double& pointArgument, Double& pointValue);
    private bool IsPointInVisualRange(double minPointArgument, double maxPointArgument, double pointValue, IAxisData axisYData);
    private bool IsPointInCrosshairRange(CrosshairSeriesPointBase point, CrosshairPaneInfo crosshairPaneInfo);
    public bool InsertPoints(IEnumerable`1<RefinedPoint> points);
    public void UpdatePoints();
    public void UpdateSeriesData();
    public CrosshairSeriesPoint GetCrosshairPoint(CrosshairPaneInfo crosshairPaneInfo, double crosshairArgument, double crosshairValue);
    public CrosshairIndicatorPoint GetCrosshairIndicatorPoint(IIndicator indicator, CrosshairPaneInfo crosshairPaneInfo, double crosshairArgument, double crosshairValue, bool crosshairSeriesPointAdded);
    public CrosshairIndicatorPoint GetCrosshairStraightLineIndicatorPoint(CrosshairPaneInfo crosshairPaneInfo, IIndicator indicator, double crosshairArgument, double crosshairValue);
    public void UpdateIndicatorData();
}
public class DevExpress.Charts.Native.CrosshairSeriesPoint : CrosshairSeriesPointBase {
    private RefinedPoint refinedPoint;
    private PointPositionInSeries position;
    private int pointIndex;
    public RefinedPoint RefinedPoint { get; }
    public PointPositionInSeries Position { get; }
    public int PointIndex { get; }
    public object PatternGroupContext { get; }
    public CrosshairContentShowModeCore CrosshairContentShowMode { get; }
    public CrosshairSeriesPoint(PointProjectionOnAxis argument, PointProjectionOnAxis value, GRealPoint2D anchorPoint, GRealPoint2D pointCenterLocation, RefinedPoint refinedPoint, IRefinedSeries refinedSeries, ILegendItem legendItem);
    public CrosshairSeriesPoint(PointProjectionOnAxis argument, PointProjectionOnAxis value, GRealPoint2D anchorPoint, GRealPoint2D pointCenterLocation, RefinedPoint refinedPoint, IRefinedSeries refinedSeries, ILegendItem legendItem, PointPositionInSeries position, int pointIndex);
    public RefinedPoint get_RefinedPoint();
    public PointPositionInSeries get_Position();
    public int get_PointIndex();
    public virtual object get_PatternGroupContext();
    public virtual CrosshairContentShowModeCore get_CrosshairContentShowMode();
    protected virtual string GetActualPattern(ICrosshairOptions options, bool isInGroup);
    protected virtual IPatternHolder GetPatternHolder();
    protected virtual void SetPatternParseContext(PatternParser patternParser, bool isGroupPattern);
    protected virtual void AddToGroup(int index, CrosshairPointsGroup group);
    public virtual void AddToCrosshairInfo(CrosshairInfo crosshairInfo);
    public virtual MinMaxValues CalculateMinMaxRange(double range, bool isHorizontalCrosshair, IXYDiagram diagram, CrosshairPaneInfo crosshairPaneInfo, CrosshairSnapModeCore snapMode);
}
public abstract class DevExpress.Charts.Native.CrosshairSeriesPointBase : CrosshairLegendPoint {
    private IRefinedSeries refinedSeries;
    private PointProjectionOnAxis argumentProjection;
    private PointProjectionOnAxis valueProjection;
    private GRealPoint2D anchorPoint;
    private GRealPoint2D pointCenter;
    private string crosshairSeriesText;
    public IRefinedSeries RefinedSeries { get; }
    public IXYSeriesView View { get; }
    public PointProjectionOnAxis AxisXProjection { get; }
    public PointProjectionOnAxis AxisYProjection { get; }
    public GRealPoint2D AnchorPoint { get; }
    public GRealPoint2D PointCenter { get; }
    public string CrosshairSeriesText { get; }
    public CrosshairContentShowModeCore CrosshairContentShowMode { get; }
    public object PatternGroupContext { get; }
    public CrosshairSeriesPointBase(PointProjectionOnAxis argument, PointProjectionOnAxis value, GRealPoint2D anchorPoint, GRealPoint2D pointCenterLocation, IRefinedSeries refinedSeries, ILegendItem legendItem);
    public IRefinedSeries get_RefinedSeries();
    public IXYSeriesView get_View();
    public PointProjectionOnAxis get_AxisXProjection();
    public PointProjectionOnAxis get_AxisYProjection();
    public GRealPoint2D get_AnchorPoint();
    public GRealPoint2D get_PointCenter();
    public virtual string get_CrosshairSeriesText();
    public abstract virtual CrosshairContentShowModeCore get_CrosshairContentShowMode();
    public abstract virtual object get_PatternGroupContext();
    private string GetActualGroupHeaderPattern(ICrosshairOptions options);
    private string ConstructTextCore(string pattern, bool isGroupPattern);
    protected abstract virtual IPatternHolder GetPatternHolder();
    protected abstract virtual string GetActualPattern(ICrosshairOptions options, bool isInGroup);
    protected abstract virtual void SetPatternParseContext(PatternParser patternParser, bool isGroupPattern);
    protected abstract virtual void AddToGroup(int index, CrosshairPointsGroup group);
    protected virtual int GetCorrectPointIndex(int index);
    protected double GetAnchorValue(bool snapsToArgument);
    public abstract virtual void AddToCrosshairInfo(CrosshairInfo crosshairInfo);
    public abstract virtual MinMaxValues CalculateMinMaxRange(double range, bool isHorizontalCrosshair, IXYDiagram xYDiagram, CrosshairPaneInfo crosshairPaneInfo, CrosshairSnapModeCore snapMode);
    public CrosshairPointsGroup CreateGroup(bool snapsToArgument);
    public bool TryAddToGroup(CrosshairPointsGroup group, bool snapsToArgument);
    public void ConstructSeriesText(ICrosshairOptions options, bool isInGroup);
    public string ConstructGroupHeaderText(ICrosshairOptions crosshairOptions);
}
public enum DevExpress.Charts.Native.CrosshairSnapModeCore : Enum {
    public int value__;
    public static CrosshairSnapModeCore NearestArgument;
    public static CrosshairSnapModeCore NearestValue;
}
public class DevExpress.Charts.Native.CrosshairSortedPointsInfoComparer : object {
    public sealed virtual int Compare(CrosshairValueItem item1, CrosshairValueItem item2);
}
internal class DevExpress.Charts.Native.CrosshairUpdateProcessor : TypedUpdateProcessor`1<PropertyUpdateInfo> {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.CrosshairValueItem : ValueType {
    private double value;
    private int pointIndex;
    public double Value { get; }
    public int PointIndex { get; }
    public CrosshairValueItem(double value, int index);
    public double get_Value();
    public int get_PointIndex();
    public void UpdateItem(double value, int index);
}
public enum DevExpress.Charts.Native.CrosshairValueSelectionModeCore : Enum {
    public int value__;
    public static CrosshairValueSelectionModeCore Default;
    public static CrosshairValueSelectionModeCore Value;
    public static CrosshairValueSelectionModeCore ValueRange;
}
public static class DevExpress.Charts.Native.CustomAxisElementsHelper : object {
    private static bool IsAxisValueContainerVisible(IAxisValueContainer container);
    public static bool IsAxisValueVisible(IAxisData axis, object axisValue);
    public static bool IsStripVisible(IScaleMap map, IStrip strip);
    public static bool IsConstantLineVisible(IConstantLine constantLine);
    public static bool IsCustomLabelVisible(ICustomAxisLabel label);
}
public class DevExpress.Charts.Native.CustomDate : ValueType {
    private bool isHoliday;
    private DateTime date;
    public bool IsHoliday { get; }
    public DateTime Date { get; }
    public CustomDate(bool isHoliday, DateTime date);
    public bool get_IsHoliday();
    public DateTime get_Date();
}
public class DevExpress.Charts.Native.CustomDateCollection : object {
    private List`1<CustomDate> dates;
    private CustomDateComparer comparer;
    public IEnumerable`1<CustomDate> Dates { get; }
    public IEnumerable`1<CustomDate> get_Dates();
    public void Clear();
    public void SetDate(DateTime date, bool isHoliday);
    public void ResetDate(DateTime date);
}
internal class DevExpress.Charts.Native.DataAdapterUpdateProcessor : TypedUpdateProcessor`1<SeriesDataAdapterPropertyUpdateInfo> {
    protected virtual IList`1<IUpdateAction> TypedProcess(SeriesDataAdapterPropertyUpdateInfo updateInfo);
}
public static class DevExpress.Charts.Native.DataFilterToCriteriaConverter : object {
    public static BinaryOperatorType Convert(Condition condition);
    public static GroupOperatorType Convert(Conjunction conjunction);
    public static CriteriaOperator Convert(IDataFilter filter);
    public static CriteriaOperator Convert(IEnumerable`1<IDataFilter> filters, Conjunction conjunction);
}
public static class DevExpress.Charts.Native.DataItemsHelper : object {
    public static double DefaultNumericValue;
    public static DateTime DefaultDateTimeValue;
    public static TimeSpan DefaultTimeSpanValue;
    public static string DefaultQualitativeValue;
    private static DataItemsHelper();
    private static Nullable`1<TimeSpan> ParseTimeSpan(object value);
    private static Nullable`1<double> ParseNumerical(object value, NumberStyles numberStyles);
    public static bool IsValidNumeric(double value);
    public static bool IsValidDateTime(DateTime value);
    public static bool IsValidTimeSpan(TimeSpan value);
    public static bool IsValidQualitative(string value);
    public static Nullable`1<double> ParseNumerical(object value);
    public static double ParseNumerical(object value, double defaultValue);
    public static DateTime ParseDateTime(object value, DateTime defaultValue);
    public static Nullable`1<DateTime> ParseDateTime(object value);
    public static TimeSpan ParseTimeSpan(object value, TimeSpan defaultValue);
    public static double ConvertToDouble(object value);
    public static DateTime ConvertToDateTime(object value);
    public static TimeSpan ConvertToTimeSpan(object value);
    public static Scale ConvertToScale(ActualScaleTypeCore scaleType);
}
public abstract class DevExpress.Charts.Native.DataMemberContainer`1 : object {
    private string dataMember;
    private bool isTypedBrowser;
    private DataBrowser browser;
    [CompilerGeneratedAttribute]
private bool <IsEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    protected bool AllowDBNull { get; }
    protected T DefaultValue { get; }
    public bool SupportEmptyValue { get; }
    public bool IsEmpty { get; private set; }
    public T Value { get; private set; }
    public string DataMember { get; }
    public object BoxedValue { get; }
    public DataMemberContainer`1(string dataMember);
    protected virtual bool get_AllowDBNull();
    protected abstract virtual T get_DefaultValue();
    public abstract virtual bool get_SupportEmptyValue();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEmpty();
    [CompilerGeneratedAttribute]
private void set_IsEmpty(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public sealed virtual string get_DataMember();
    public virtual object get_BoxedValue();
    protected abstract virtual bool IsCompatibleType(Type type);
    protected abstract virtual bool IsEmptyValue(T value);
    protected abstract virtual T ConvertValue(object value);
    protected abstract virtual T ParseValue(object value);
    public sealed virtual void Read();
    public sealed virtual bool CreateDataBrowser(BindingEnvironment environment);
}
public class DevExpress.Charts.Native.DataSourceBasedErrorBarsCalculator : ErrorBarsCalculator {
    public void Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
}
public class DevExpress.Charts.Native.DataSourcePatternDataProvider : PatternDataProvider {
    private string patternConstant;
    private ISeriesPointEnsurer seriesPointEnsurer;
    private ISeriesPoint SeriesPoint { get; }
    public DataSourcePatternDataProvider(string patternConstant, ISeriesPointEnsurer seriesPointEnsurer);
    private ISeriesPoint get_SeriesPoint();
    protected virtual bool TryGetValue(Object& value);
    protected virtual void SetContext(object value);
    public virtual bool CheckContext(object value);
}
public class DevExpress.Charts.Native.DataSourceUpdateInfoBase`1 : object {
    private int count;
    private TSender sender;
    private ChartDataSourceUpdateType type;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public TSender Sender { get; }
    public ChartDataSourceUpdateType Type { get; }
    public int Count { get; }
    public int Index { get; public set; }
    public DataSourceUpdateInfoBase`1(TSender sender, ChartDataSourceUpdateType type, int index, int count);
    public TSender get_Sender();
    public ChartDataSourceUpdateType get_Type();
    public int get_Count();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
}
public class DevExpress.Charts.Native.DataSourceUpdateInfoCollection : DataSourceUpdateInfoCollectionBase`1<IBindingProvider> {
    public DataSourceUpdateInfoCollection(IBindingProvider sender, NotifyCollectionChangedEventArgs args);
    public DataSourceUpdateInfoCollection(IBindingProvider sender, ListChangedEventArgs args);
    public DataSourceUpdateInfoCollection(IBindingProvider sender, ChartDataSourceUpdateType dataSourceUpdateType, int index, int count);
    public static DataSourceUpdateInfoCollection CreateReset(IBindingProvider owner);
    public static DataSourceUpdateInfoCollection CreateResetView(IBindingProvider owner);
    protected virtual DataSourceUpdateInfoBase`1<IBindingProvider> CreateChild(IBindingProvider sender, ChartDataSourceUpdateType type, int index, int count);
}
public abstract class DevExpress.Charts.Native.DataSourceUpdateInfoCollectionBase`1 : List`1<DataSourceUpdateInfoBase`1<TSender>> {
    protected DataSourceUpdateInfoCollectionBase`1(TSender sender, NotifyCollectionChangedEventArgs args);
    protected DataSourceUpdateInfoCollectionBase`1(TSender sender, ListChangedEventArgs args);
    protected DataSourceUpdateInfoCollectionBase`1(TSender sender, ChartDataSourceUpdateType dataSourceUpdateType, int index, int count);
    protected void AddChild(TSender sender, ChartDataSourceUpdateType type, int index, int count);
    protected abstract virtual DataSourceUpdateInfoBase`1<TSender> CreateChild(TSender sender, ChartDataSourceUpdateType type, int index, int count);
    public void AddReset(TSender sender);
    public void AddResetView(TSender sender);
    public bool IsUpdatesTypeOf(ChartDataSourceUpdateType type);
    public bool IsExistUpdateTypeOf(ChartDataSourceUpdateType type);
}
public abstract class DevExpress.Charts.Native.DataSourceValuesCore : SortedDictionary`2<string, object> {
}
public class DevExpress.Charts.Native.DateTimeAggregatedSeriesArgumentContainer : AggregatedSeriesArgumentContainer`1<DateTime> {
    protected Scale Scale { get; }
    protected DateTime DateTimeArgument { get; }
    protected string QualitativeArgument { get; }
    public DateTimeAggregatedSeriesArgumentContainer(object argument);
    protected virtual Scale get_Scale();
    protected virtual DateTime get_DateTimeArgument();
    protected virtual string get_QualitativeArgument();
    protected virtual DateTime Convert(object value);
}
public class DevExpress.Charts.Native.DateTimeArgumentSimpleStandardDeviationCalculator : SimpleStandardDeviationCalculator {
    private AxisDateTimeMap map;
    public DateTimeArgumentSimpleStandardDeviationCalculator(AxisDateTimeMap map);
    protected virtual double GetValue(RefinedPoint point);
}
internal class DevExpress.Charts.Native.DateTimeAxisAggregationInterval : AxisAggregationInterval {
    private object nativeMin;
    private object nativeMax;
    public object NativeMin { get; }
    public object NativeMax { get; }
    public DateTimeAxisAggregationInterval(double min, double max, bool includeMin, bool includeMax, bool isUnderflow, bool isOverflow);
    public virtual object get_NativeMin();
    public virtual object get_NativeMax();
}
public class DevExpress.Charts.Native.DateTimeAxisAggregationIntervalsCalculator : DivisionModeAxisAggregationIntervalsCalculator`1<DateTimeMeasureUnitNative> {
    protected virtual double CalcBinWidth(IAxisData axis, double intervalWidth, DateTimeMeasureUnitNative measureUnit);
    protected virtual double RoundValue(IAxisData axis, double value);
    protected virtual double RoundUpValue(IAxisData axis, double value);
    protected virtual SimpleStandardDeviationCalculator CreateAutoHistogramCalculator(IAxisData axis);
    public virtual bool UpdateIntervals(IAxisData axis, IList`1<RefinedSeries> refinedSeries);
}
internal class DevExpress.Charts.Native.DateTimeAxisIntervalsContainer : AxisIntervalsContainer {
    private static double Precision;
    public DateTimeAxisIntervalsContainer(AggregationIntervalsInfo info);
    protected virtual double GetNextRefinedValue(double value);
    protected virtual double GetPrevRefinedValue(double value);
    protected virtual object GetNextNativeValue(object value);
    protected virtual object GetPrevNativeValue(object value);
    protected virtual AxisAggregationInterval CreateInterval(double min, double max, bool useUnderflow);
    protected virtual AxisAggregationInterval CreateOverflowInterval(double min, double max);
    protected virtual AxisAggregationInterval CreateUnderflowInterval(double min, double max, bool useUnderflow);
}
internal class DevExpress.Charts.Native.DateTimeAxisIntervalsMapWithoutGapsCalculator : MapWithoutGapsCalculator`2<DateTime, byte> {
    private DateTimeAxisIntervalsContainer intervalsContainer;
    public DateTimeAxisIntervalsMapWithoutGapsCalculator(DateTimeAxisIntervalsContainer intervalsContainer, List`1<DoubleLimits> dataLimits);
    protected virtual List`1<ValuesContainer<DateTime, byte>> CalculateValuesByMeasureUnit(byte measureUnit, int measureUnitMultiplier);
    protected virtual double NativeToRefinedSimple(DateTime value);
    protected virtual DateTime InternalToNativeSimple(double value, byte measureUnit, int measureUnitMultiplier);
    protected virtual double NativeToInternalSimple(DateTime value, byte measureUnit, int measureUnitMultiplier);
    protected virtual DateTime RefinedToNativeSimple(double value);
    public DateTime InternalToNative(double value);
    public object InternalToNativeInterval(double value, bool convertToString, IAxisData axis);
    public double RefinedToInternal(double value);
    public double NativeToInternal(DateTime value);
}
public class DevExpress.Charts.Native.DatetimeAxisRangeUpdateStrategy : RangeUpdateStrategy {
    public DatetimeAxisRangeUpdateStrategy(IAxisData axis, MinMaxValues minMaxInternal, MinMaxValues minMaxRefined, ICollection`1<RefinedSeries> refinedSeries, bool scaleMapWasChanged);
    protected virtual InternalRange CheckInternalValue(IAxisRangeData range, MinMaxValues internalValues);
    protected virtual InternalRange ApplySideMargins(MinMaxValues internalValues, MinMaxValues sideMargins, bool autoCorrectionMin, bool autoCorrectionMax);
    protected virtual NativeRange GetNativeValues(MinMaxValues internalValues, MinMaxValues correctedInternalValues, IAxisRangeData range);
    protected virtual RangeSnapshot DefaultRange(IAxisRangeData range);
    protected virtual MinMaxValues NarrowToActualWholeRange(MinMaxValues wholeRangeValues, IWholeAxisRangeData wholeRange);
}
public abstract class DevExpress.Charts.Native.DateTimeDateTimeSeriesPointDataContainer : SeriesPointDataContainer {
    private DateTime argument;
    protected DateTime Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public DateTime DateTimeArgument { get; public set; }
    public string QualitativeArgument { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    public DateTimeDateTimeSeriesPointDataContainer(DateTime argument);
    public static DateTimeDateTimeSeriesPointDataContainer CreateContainer(DateTime argument, DateTime[] values);
    public static DateTimeDateTimeSeriesPointDataContainer CreateContainer(DateTime argument, int dimension);
    protected DateTime get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual DateTime get_DateTimeArgument();
    public virtual void set_DateTimeArgument(DateTime value);
    public virtual string get_QualitativeArgument();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.DateTimeFormatParts : ValueType {
    private DateTimeOptionsFormat format;
    private string formatString;
    public DateTimeOptionsFormat Format { get; }
    public string FormatString { get; }
    public DateTimeFormatParts(DateTimeOptionsFormat format, string formatString);
    public DateTimeOptionsFormat get_Format();
    public string get_FormatString();
}
public enum DevExpress.Charts.Native.DateTimeGridAlignmentNative : Enum {
    public int value__;
    public static DateTimeGridAlignmentNative Millisecond;
    public static DateTimeGridAlignmentNative Second;
    public static DateTimeGridAlignmentNative Minute;
    public static DateTimeGridAlignmentNative Hour;
    public static DateTimeGridAlignmentNative Day;
    public static DateTimeGridAlignmentNative Week;
    public static DateTimeGridAlignmentNative Month;
    public static DateTimeGridAlignmentNative Quarter;
    public static DateTimeGridAlignmentNative Year;
}
public abstract class DevExpress.Charts.Native.DateTimeLabelFormatterBase : object {
    protected DateTimeGridAlignmentNative GridAlignment { get; }
    protected abstract virtual DateTimeGridAlignmentNative get_GridAlignment();
    private sealed virtual override object System.IFormatProvider.GetFormat(Type formatType);
    private sealed virtual override string System.ICustomFormatter.Format(string format, object arg, IFormatProvider formatProvider);
}
internal class DevExpress.Charts.Native.DateTimeMapWithoutGapsCalculator : MapWithoutGapsCalculator`2<DateTime, DateTimeMeasureUnitNative> {
    private DayOfWeek firstDayOfWeek;
    private DateTimeMeasureUnitNative currentMeasureUnit;
    private int currentMeasureUnitMultiplier;
    private DayOfWeek FirstDayOfWeek { get; }
    public DateTimeMapWithoutGapsCalculator(DateTimeMeasureUnitNative dateTimeMeasureUnit, int measureUnitMultiplier, List`1<DoubleLimits> dataLimits, DayOfWeek firstDayOfWeek);
    private DayOfWeek get_FirstDayOfWeek();
    private object AlignToNextValue(DateTime dateTime);
    protected virtual List`1<ValuesContainer<DateTime, DateTimeMeasureUnitNative>> CalculateValuesByMeasureUnit(DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    protected virtual double NativeToRefinedSimple(DateTime value);
    protected virtual DateTime InternalToNativeSimple(double value, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    protected virtual double NativeToInternalSimple(DateTime value, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    protected virtual DateTime RefinedToNativeSimple(double value);
    public object InternalToNativeAligned(double alignedValue, DateTimeMeasureUnitNative alignment, double measureUnitMultiplier);
}
public class DevExpress.Charts.Native.DateTimeMeasureUnitsCalculatorCore : MeasureUnitsCalculatorBase`2<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative> {
    private double previousThreshold;
    private IDateTimeScaleOptions DateTimeScaleOptions { get; }
    protected bool UseMinMeasureUnit { get; }
    protected IScaleOptionsBase`1<DateTimeMeasureUnitNative> ScaleOptions { get; }
    public DateTimeMeasureUnitsCalculatorCore(IAxisData axis);
    private IDateTimeScaleOptions get_DateTimeScaleOptions();
    protected virtual bool get_UseMinMeasureUnit();
    protected virtual IScaleOptionsBase`1<DateTimeMeasureUnitNative> get_ScaleOptions();
    private GridAlignment<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative> AlignToRange(GridAlignment<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative> selectedAlignment, DateTime min, DateTime max);
    private GridAlignment<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative> CalculateGridAlignment(double pixelsPerUnit, DateTime min, DateTime max);
    protected virtual UnitSelector`2<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative> CreateUnitSelector();
    protected virtual void UpdateAutomaticGrid(double pixelsPerUnit, IMinMaxValues visualRange);
    protected virtual bool UpdateAutomaticUnits(DateTimeMeasureUnitNative measureUnit, int pixelsPerUnit);
}
public abstract class DevExpress.Charts.Native.DateTimeNumericSeriesPointDataContainer : SeriesPointDataContainer {
    private DateTime argument;
    protected DateTime Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public DateTime DateTimeArgument { get; public set; }
    public string QualitativeArgument { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected DateTimeNumericSeriesPointDataContainer(DateTime argument);
    public static DateTimeNumericSeriesPointDataContainer CreateContainer(DateTime argument, int dimension);
    public static DateTimeNumericSeriesPointDataContainer CreateContainer(DateTime argument, Double[] values);
    protected DateTime get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual DateTime get_DateTimeArgument();
    public virtual void set_DateTimeArgument(DateTime value);
    public virtual string get_QualitativeArgument();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public enum DevExpress.Charts.Native.DateTimeOptionsFormat : Enum {
    public int value__;
    public static DateTimeOptionsFormat ShortDate;
    public static DateTimeOptionsFormat LongDate;
    public static DateTimeOptionsFormat ShortTime;
    public static DateTimeOptionsFormat LongTime;
    public static DateTimeOptionsFormat General;
    public static DateTimeOptionsFormat MonthAndDay;
    public static DateTimeOptionsFormat MonthAndYear;
    public static DateTimeOptionsFormat QuarterAndYear;
    public static DateTimeOptionsFormat Custom;
}
public static class DevExpress.Charts.Native.DateTimeOptionsHelper : object {
    public static string GetValueText(DateTime dateTime, IDateTimeOptions options);
    public static string GetFormatString(IDateTimeOptions options);
}
public class DevExpress.Charts.Native.DateTimeRangeControlClientGridMapping : RangeControlClientGridMapping {
    private IWorkdaysOptions workdaysOptions;
    public DateTimeRangeControlClientGridMapping(IWorkdaysOptions workdaysOptions);
    protected double CorrectGridUnits(double gridUnits, RangeControlGridUnit unit, double offset, bool ceil);
    protected virtual double RoundValue(RangeControlGridUnit unit, double value, double offset, bool ceil);
    protected internal virtual double CeilValue(RangeControlGridUnit unit, double value, double offset);
    protected internal virtual double FloorValue(RangeControlGridUnit unit, double value, double offset);
    protected internal virtual double GetGridValue(RangeControlGridUnit unit, double index);
}
public class DevExpress.Charts.Native.DateTimeSeriesPointDataContainer : SeriesPointDataContainer {
    private DateTime argument;
    private int dimension;
    public Scale ArgumentScaleType { get; }
    public DateTime DateTimeArgument { get; public set; }
    public string QualitativeArgument { get; }
    public int Dimension { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    public DateTimeSeriesPointDataContainer(DateTime argument, int dimension);
    public static SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, int dimension);
    public virtual Scale get_ArgumentScaleType();
    public virtual DateTime get_DateTimeArgument();
    public virtual void set_DateTimeArgument(DateTime value);
    public virtual string get_QualitativeArgument();
    public virtual int get_Dimension();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer SetDimension(int dimension);
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.DateTimeSeriesPointValuesContainer : SeriesPointValuesContainer`1<DateTime> {
    protected Scale ScaleType { get; }
    public DateTime[] DateTimeValues { get; }
    public DateTimeSeriesPointValuesContainer(DateTime[] values, Double[] userValues);
    protected virtual Scale get_ScaleType();
    public virtual DateTime[] get_DateTimeValues();
}
public abstract class DevExpress.Charts.Native.DateTimeTimeSpanSeriesPointDataContainer : SeriesPointDataContainer {
    private DateTime argument;
    protected DateTime Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public DateTime DateTimeArgument { get; public set; }
    public string QualitativeArgument { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected DateTimeTimeSpanSeriesPointDataContainer(DateTime argument);
    public static DateTimeTimeSpanSeriesPointDataContainer CreateContainer(DateTime argument, TimeSpan[] values);
    public static DateTimeTimeSpanSeriesPointDataContainer CreateContainer(DateTime argument, int dimension);
    protected DateTime get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual DateTime get_DateTimeArgument();
    public virtual void set_DateTimeArgument(DateTime value);
    public virtual string get_QualitativeArgument();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.DateTimeUnitSelector : DateTimeUnitSelectorBase`2<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative> {
    private static double sizeMillisecond;
    private static double sizeSecond;
    private static double sizeMinute;
    private static double sizeHour;
    private static double sizeDay;
    private static double sizeWeek;
    private static double sizeMonth;
    private static double sizeQuarter;
    private static double sizeYear;
    public static double DefaultGridSpacing;
    public static DateTimeMeasureUnitNative DefaultMeasureUnit { get; }
    public static DateTimeGridAlignmentNative DefaultGridAlignment { get; }
    public static DateTimeMeasureUnitNative get_DefaultMeasureUnit();
    public static DateTimeGridAlignmentNative get_DefaultGridAlignment();
    private static DateTimeGridAlignmentNative GetPreviousAlignment(DateTimeGridAlignmentNative alignment);
    public static double GetMeasureUnitValue(DateTimeGridAlignmentNative alignment);
    public static double GetMeasureUnitValue(DateTimeMeasureUnitNative measureUnit);
    public static GridAlignment<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative> GetPreviousGridAlignment(GridAlignment<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative> gridAlignment);
    protected virtual List`1<MeasureItem<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative>> FillMeasureSteps();
    protected virtual List`1<AlignmentItem<DateTimeMeasureUnitNative, DateTimeGridAlignmentNative>> FillAlignmentSteps();
}
public abstract class DevExpress.Charts.Native.DateTimeUnitSelectorBase`2 : UnitSelector`2<TMeasureUnit, TGridAlignment> {
    private UnitContainer<TMeasureUnit, TGridAlignment> commonUnitContainer;
    private IList`1<MeasureItem<TMeasureUnit, TGridAlignment>> FilterActiveMeasureUnits(double min, double max);
    private IList`1<AlignmentItem<TMeasureUnit, TGridAlignment>> FilterActiveAlignmentUnits(double min, double max);
    protected abstract virtual List`1<MeasureItem<TMeasureUnit, TGridAlignment>> FillMeasureSteps();
    protected abstract virtual List`1<AlignmentItem<TMeasureUnit, TGridAlignment>> FillAlignmentSteps();
    public virtual void UpdateActiveUnits(double min, double max);
}
public static class DevExpress.Charts.Native.DateTimeUtils : object {
    private static int DaysInWeek;
    private static int MonthsInYear;
    private static int HoursInDay;
    private static int MinutesInDay;
    private static int SecondsInDay;
    private static int MillisecondsInDay;
    private static double TicksInDay;
    public static int MonthsInQuarter;
    private static DateTime Add(DateTime dateTime, DateTimeMeasureUnitNative measureUnit, bool isNegative);
    private static int CalcHolidaysCountInWeek(IWorkdaysOptions workdaysOptions);
    private static double TotalUnits(DateTime dateTime, bool workdaysOnly, IWorkdaysOptions workdaysOptions, int majorUnit);
    private static double CalcWeekAddition(IWorkdaysOptions workdaysOptions, DateTime date, DateTime roundedToWeek);
    private static double CorrectDifferenceBasedOnHolidays(IWorkdaysOptions workdaysOptions, DateTime fromDate, double value, int multiplier);
    private static DateTime AddUnits(DateTimeMeasureUnitNative measureUnit, DateTime date, double range, double factor, IWorkdaysOptions workdaysOptions);
    private static double CorrectRangeBasedOnHolidays(IWorkdaysOptions workdaysOptions, DateTime date, double range, int multiplier);
    public static bool IsHoliday(IWorkdaysOptions workdaysOptions, DateTime dateTime, bool applyHolidays, bool applyExactWorkdays);
    public static DateTime SkipHoliday(IWorkdaysOptions workdaysOptions, DateTime dateTime);
    public static DateTime SkipHolidayReverted(IWorkdaysOptions workdaysOptions, DateTime dateTime);
    public static DateTime Floor(DateTime dateTime, DateTimeMeasureUnitNative measureUnit);
    public static DateTime AddRange(DateTimeMeasureUnitNative measureUnit, DateTimeMeasureUnitNative gridAlignment, DateTime date, double range, IWorkdaysOptions workdaysOptions);
    public static DateTime Increase(DateTime dateTime, DateTimeMeasureUnitNative measureUnit);
    public static DateTime Decrease(DateTime dateTime, DateTimeMeasureUnitNative measureUnit);
    public static double GetDifference(DateTimeMeasureUnitNative measureUnit, DateTimeMeasureUnitNative gridAlignment, DateTime fromDate, DateTime toDate, IWorkdaysOptions workdaysOptions);
}
public static class DevExpress.Charts.Native.DateTimeUtilsExt : object {
    private static int DaysInWeek;
    private static int MonthsInQuarter;
    private static int MonthsInYear;
    private static int HoursInDay;
    private static int MinutesInDay;
    private static int SecondsInDay;
    private static int MillisecondsInDay;
    private static int MillisecondsInHour;
    private static int MillisecondsInMinute;
    private static int MillisecondsInSecond;
    private static double MaxMonths;
    public static double MaxMilliseconds { get; }
    public static DateTime MinDateTime { get; }
    public static DateTime MaxDateTime { get; }
    public static TimeSpan MinTimeSpan { get; }
    public static TimeSpan MaxTimeSpan { get; }
    public static DayOfWeek FirstDayOfWeek { get; }
    private static DateTimeUtilsExt();
    public static double get_MaxMilliseconds();
    public static DateTime get_MinDateTime();
    public static DateTime get_MaxDateTime();
    public static TimeSpan get_MinTimeSpan();
    public static TimeSpan get_MaxTimeSpan();
    public static DayOfWeek get_FirstDayOfWeek();
    private static int MondayBasedDay(DayOfWeek day);
    public static bool MaskDay(DayOfWeek day, WeekdayCore flags);
    public static WeekdayCore Invert(WeekdayCore flags);
    private static double TotalFloorMonths(DateTime dateTime);
    private static double GetMonthMilliseconds(DateTimeMeasureUnitNative measureUnit, DateTime date, double range, double factor);
    public static int SizeOfDay(DateTimeMeasureUnitNative measureUnit);
    public static double GetMaximumMillisecondsInUnit(DateTimeMeasureUnitNative measureUnit);
    public static DateTime RestoreCustomDays(DateTime baseDate, IEnumerable`1<CustomDate> customDays, WeekdayCore workdays);
    public static double MillisecondsInMeasureUnit(DateTimeMeasureUnitNative measureUnit);
    public static DateTime Floor(DateTime dateTime, DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier, DayOfWeek firstDayOfWeek);
    public static DateTime Round(DateTime dateTime, DateTimeMeasureUnitNative measureUnit, DayOfWeek firstDayOfWeek);
    public static double GetAdditionalMilliseconds(DateTime dateTime, DateTime roundedDate, DateTimeMeasureUnitNative measureUnit, double measureUnitMultiplier, double range, DayOfWeek firstDayOfWeek);
    public static Nullable`1<DateTime> Add(DateTime dateTime, DateTimeMeasureUnitNative measureUnit, double measureUnitMultiplier, double range, DayOfWeek firstDayOfWeek);
    private static double GetDiffInMonths(DateTime fromDate, DateTime toDate);
    private static int GetActualDayOfWeek(DateTime dateTime, DayOfWeek firstDayOfWeek);
    public static TimeSpan ToTimeSpan(double value, DateTimeMeasureUnitNative measureUnit);
    public static double TimeSpanToMeasureUnit(TimeSpan value, TimeSpanMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public static Nullable`1<TimeSpan> ToTimeSpan(double value, TimeSpanMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public static TimeSpan Floor(TimeSpan timeSpan, TimeSpanMeasureUnitNative measureUnit);
    public static TimeSpan Floor(TimeSpan timeSpan, TimeSpanMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public static TimeSpan Round(TimeSpan timeSpan, TimeSpanMeasureUnitNative measureUnit);
    public static TimeSpan AddRange(TimeSpanMeasureUnitNative measureUnit, TimeSpanMeasureUnitNative gridAlignment, TimeSpan value, int range);
    public static DateTime AddRange(DateTime dateTime, DateTimeMeasureUnitNative measureUnit, int range);
    public static double Difference(DateTime fromDate, DateTime toDate, DateTimeMeasureUnitNative measureUnit, double measureUnitMultiplier, DayOfWeek firstDayOfWeek);
    public static DayOfWeek GetFirstDayOfWeek(IWorkdaysOptions workdaysOptions);
    internal static DateTime GetMonday(DateTime date);
    internal static int GetNumberOfHolidaysInWeek(WeekdayCore holidays);
    internal static int GetHolidaysCountInWeek(DayOfWeek day, WeekdayCore holidays);
    internal static int RestoreDay(int day, WeekdayCore holidays);
    internal static int GetHolidaysCount(DateTime date, WeekdayCore holidays);
    internal static int GetHolidaysCount(DateTime date, IWorkdaysOptions options);
    internal static bool IsHoliday(DateTime date, WeekdayCore workdays);
    internal static Nullable`1<DateTime> ReverseHolidays(double value, IWorkdaysOptions options, DateTimeMeasureUnitNative measureUnit, double measureUnitMultiplier);
    public static DateTimeFormatParts SelectFormat(DateTimeGridAlignmentNative measureUnit);
    public static string CreateLongTimePatternWithMillisecond();
    public static double GetMilliseconds(TimeSpan value);
    public static double DateTimeToDouble(DateTime dateTime);
    public static DateTime DoubleToDateTime(double value);
}
public static class DevExpress.Charts.Native.DefaultAutomaticScaleBreaksCalculator : object {
    [CompilerGeneratedAttribute]
private static Func`3<List`1<double>, int, Clusters> <CreateClusters>k__BackingField;
    public static Func`3<List`1<double>, int, Clusters> CreateClusters { get; public set; }
    private static DefaultAutomaticScaleBreaksCalculator();
    [CompilerGeneratedAttribute]
public static Func`3<List`1<double>, int, Clusters> get_CreateClusters();
    [CompilerGeneratedAttribute]
public static void set_CreateClusters(Func`3<List`1<double>, int, Clusters> value);
    public static IList`1<IScaleDiapason> Calculate(IAutoScaleBreaksCreator scaleBreaksCreator, List`1<double> axisValues, int maxScaleBreaksCount);
}
public class DevExpress.Charts.Native.DefaultBezierSplitter : BezierSplitter {
    private static DefaultBezierSplitter instance;
    public static DefaultBezierSplitter Instance { get; }
    public static DefaultBezierSplitter get_Instance();
}
public class DevExpress.Charts.Native.DetrendedPriceOscillatorCalculator : object {
    private static int DesignTimePointsCount;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount, ValueLevelInternal valueLevel);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
internal class DevExpress.Charts.Native.DiagramPropertyUpdateProcessor : TypedUpdateProcessor`2<PropertyUpdateInfo`1<IAxisData>, IDiagram> {
    private bool IsQualitativeScaleType(IAxisData axis);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo`1<IAxisData> updateInfo, IDiagram sender);
}
public enum DevExpress.Charts.Native.DirectionCore : Enum {
    public int value__;
    public static DirectionCore LeftToRight;
    public static DirectionCore RightToLeft;
    public static DirectionCore TopToBottom;
    public static DirectionCore BottomToTop;
}
public class DevExpress.Charts.Native.DiscreteViewportIntersectionHolder : ViewportIntersectionHolder {
    public DiscreteViewportIntersectionHolder(IXYSeriesView view);
    protected virtual bool IsArgumentInRange(MinMaxValues pointRangeX);
    protected virtual bool IsValueInRange(RefinedPoint point, double y);
    protected virtual int CollectViewportIntersection(List`1<GRealPoint2D> pointsOfIntersection, IList`1<RefinedPoint> points, int firstIndex, int lastIndex, bool isLeftIntersection, Action`1<int> setIndex);
    protected virtual Func`3<int, int, bool> CreateContinueCycle(bool isLeftIntersection);
    public virtual List`1<GRealPoint2D> CorrectValuesByViewport(double pointArgument, double zeroValue, double pointValue, bool alwaysOnDiagramEdge);
}
public abstract class DevExpress.Charts.Native.DivisionModeAxisAggregationIntervalsCalculator`1 : MeasureUnitAxisAggregationIntervalsCalculator`1<TMeasureUnit> {
    private AggregationIntervalsInfo CalculateIntervalWidthMode(IAxisData axis, IScaleOptionsDivisionModeSupport`1<TMeasureUnit> scaleOptions);
    private AggregationIntervalsInfo CalculateIntervalsCountMode(IAxisData axis, IScaleOptionsDivisionModeSupport`1<TMeasureUnit> scaleOptions);
    protected abstract virtual double CalcBinWidth(IAxisData axis, double intervalWidth, TMeasureUnit measureUnit);
    protected virtual AggregationIntervalsInfo CreateAggregationIntervalsInfo(IAxisData axis, IScaleOptionsBase`1<TMeasureUnit> scaleOptions, IList`1<RefinedSeries> refinedSeries);
}
public enum DevExpress.Charts.Native.DockCornerCore : Enum {
    public int value__;
    public static DockCornerCore TopRight;
    public static DockCornerCore TopLeft;
    public static DockCornerCore BottomRight;
    public static DockCornerCore BottomLeft;
}
public class DevExpress.Charts.Native.DoubleLimits : object {
    public double Start;
    public double End;
    public DoubleLimits(double start, double end);
    public DoubleLimits(double limit);
    public bool IntersectWith(DoubleLimits limits);
    public DoubleLimits Union(DoubleLimits limits);
    public bool Contains(DoubleLimits doubleLimits);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class DevExpress.Charts.Native.DoubleLimitsEndComparer : object {
    public sealed virtual int Compare(DoubleLimits x, DoubleLimits y);
}
internal class DevExpress.Charts.Native.DoubleLimitsStartComparer : object {
    public sealed virtual int Compare(DoubleLimits x, DoubleLimits y);
}
public class DevExpress.Charts.Native.DoubleLimitsUnionInfo : object {
    [CompilerGeneratedAttribute]
private List`1<DoubleLimits> <UnionResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FirstIntervalWasChanged>k__BackingField;
    public List`1<DoubleLimits> UnionResult { get; public set; }
    public bool FirstIntervalWasChanged { get; public set; }
    public DoubleLimitsUnionInfo(List`1<DoubleLimits> union, bool firstIntervalWasChanged);
    [CompilerGeneratedAttribute]
public List`1<DoubleLimits> get_UnionResult();
    [CompilerGeneratedAttribute]
public void set_UnionResult(List`1<DoubleLimits> value);
    [CompilerGeneratedAttribute]
public bool get_FirstIntervalWasChanged();
    [CompilerGeneratedAttribute]
public void set_FirstIntervalWasChanged(bool value);
}
public abstract class DevExpress.Charts.Native.EdgeGeometry : object {
    public static int MaxCrosswiseStep;
    private bool shouldCutEdge;
    protected EdgeGeometry(bool shouldCutEdge);
    private static EdgeGeometry();
    protected abstract virtual IList`1<GRealPoint2D> CreateGraphicsPath(double startX, double startY, double length, bool vertical);
    public IList`1<GRealPoint2D> CreateLeftSideGraphicsPath(GRealRect2D bounds);
    public IList`1<GRealPoint2D> CreateRightSideGraphicsPath(GRealRect2D bounds);
    public IList`1<GRealPoint2D> CreateTopSideGraphicsPath(GRealRect2D bounds);
    public IList`1<GRealPoint2D> CreateBottomSideGraphicsPath(GRealRect2D bounds);
}
public enum DevExpress.Charts.Native.ElementSelectionModeCore : Enum {
    public int value__;
    public static ElementSelectionModeCore None;
    public static ElementSelectionModeCore Single;
    public static ElementSelectionModeCore Multiple;
    public static ElementSelectionModeCore Extended;
}
public enum DevExpress.Charts.Native.EmptyPointProcessingMode : Enum {
    public int value__;
    public static EmptyPointProcessingMode SetZeroValue;
    public static EmptyPointProcessingMode SetAverageValue;
    public static EmptyPointProcessingMode Remove;
    public static EmptyPointProcessingMode NoAction;
}
public class DevExpress.Charts.Native.EmptyPointsFilter : PointsFilter {
    private IList`1<RefinedPoint> processedPoints;
    private EmptyPointProcessingMode lastProcessedMode;
    private EmptyPointsFilterBehaviorBase behavior;
    private EmptyPointProcessingMode ActualMode { get; }
    public bool AffectsMapping { get; }
    public EmptyPointsFilter(RefinedSeries series);
    private static EmptyPointsFilterBehaviorBase CreateBehavior(EmptyPointProcessingMode mode, int pointDimension);
    public static List`1<RefinedPoint> ProcessPointsWithoutCache(List`1<RefinedPoint> points, ISeriesView view);
    private EmptyPointProcessingMode get_ActualMode();
    public virtual bool get_AffectsMapping();
    private IList`1<RefinedPoint> ProcessPoints(IList`1<RefinedPoint> initialPoints);
    protected virtual IList`1<RefinedPoint> Recalculate(IList`1<RefinedPoint> initialPoints);
    protected virtual IList`1<RefinedPoint> GetCachedPoints();
    public virtual void ClearCache();
    public virtual bool Update();
    public virtual PointsFilterUpdateInfo Update(PointsFilterUpdateInfo updateInfo);
}
public abstract class DevExpress.Charts.Native.EmptyPointsFilterBehaviorBase : object {
    public abstract virtual List`1<RefinedPoint> Process(IList`1<RefinedPoint> initialPoints);
}
public class DevExpress.Charts.Native.EmptyPointsFilterRemoveBehavior : EmptyPointsFilterBehaviorBase {
    public virtual List`1<RefinedPoint> Process(IList`1<RefinedPoint> initialPoints);
}
public class DevExpress.Charts.Native.EmptyPointsFilterSetAverageValueBehavior : EmptyPointsFilterBehaviorBase {
    private int valuesDimension;
    public EmptyPointsFilterSetAverageValueBehavior(int valuesDimension);
    private double CalulateValue(RefinedPoint firstPoint, RefinedPoint lastPoint, RefinedPoint point, Func`2<RefinedPoint, double> getValue);
    public virtual List`1<RefinedPoint> Process(IList`1<RefinedPoint> initialPoints);
}
public class DevExpress.Charts.Native.EmptyPointsFilterSetZeroValueBehavior : EmptyPointsFilterBehaviorBase {
    private int valuesDimension;
    public EmptyPointsFilterSetZeroValueBehavior(int valuesDimension);
    public virtual List`1<RefinedPoint> Process(IList`1<RefinedPoint> initialPoints);
}
public class DevExpress.Charts.Native.EmptyPointStripSplitter : StripSplitter {
    private IEmptyPointColorizer emptyPointSegmentColorizer;
    public EmptyPointStripSplitter(IEmptyPointColorizer emptyPointSegmentColorizer);
    public virtual List`1<ColoredStripInfo> SplitStrip(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, Func`2<RefinedPoint, double> getActualValue);
    public virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.EmptySeriesPointDataContainer : SeriesPointDataContainer {
    private int dimension;
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public int Dimension { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    public EmptySeriesPointDataContainer(int dimension);
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual int get_Dimension();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer SetDimension(int dimension);
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.EmptyUpdateInfo : ChartUpdateInfoBase {
    public EmptyUpdateInfo(object sender);
}
internal class DevExpress.Charts.Native.EmptyUpdateProcessor : TypedUpdateProcessor`1<ChartUpdateInfoBase> {
    protected virtual IList`1<IUpdateAction> TypedProcess(ChartUpdateInfoBase updateInfo);
}
public static class DevExpress.Charts.Native.EnumHelper : object {
    public static Array GetValues(Type enumType);
}
public class DevExpress.Charts.Native.ErrorBarData : object {
    [CompilerGeneratedAttribute]
private bool <ShouldBeSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Center>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Top>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Bottom>k__BackingField;
    [CompilerGeneratedAttribute]
private RefinedPoint <RefinedPoint>k__BackingField;
    public bool ShouldBeSkipped { get; }
    public double Center { get; }
    public double Top { get; }
    public double Bottom { get; }
    public RefinedPoint RefinedPoint { get; }
    public ErrorBarData(RefinedPoint refinedPoint, double center, double top, double bottom, bool shouldBeSkipped);
    [CompilerGeneratedAttribute]
public bool get_ShouldBeSkipped();
    [CompilerGeneratedAttribute]
public double get_Center();
    [CompilerGeneratedAttribute]
public double get_Top();
    [CompilerGeneratedAttribute]
public double get_Bottom();
    [CompilerGeneratedAttribute]
public RefinedPoint get_RefinedPoint();
    public virtual string ToString();
}
public enum DevExpress.Charts.Native.ErrorBarDirectionCore : Enum {
    public int value__;
    public static ErrorBarDirectionCore Both;
    public static ErrorBarDirectionCore Minus;
    public static ErrorBarDirectionCore Plus;
}
public class DevExpress.Charts.Native.ErrorBarIndicatorPointToStringConverter : MultiValuesIndicatorPointToStringConverter {
    protected string DefaultValuePart { get; }
    protected string DefaultLegendValuePart { get; }
    public ErrorBarIndicatorPointToStringConverter(ISeries series, bool isTextInLegend);
    protected virtual string get_DefaultValuePart();
    protected virtual string get_DefaultLegendValuePart();
}
public abstract class DevExpress.Charts.Native.ErrorBarsCalculator : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ErrorBarData> <ErrorBarDataList>k__BackingField;
    public Nullable`1<bool> Calculated { get; protected set; }
    public MinMaxValues YRange { get; protected set; }
    public List`1<ErrorBarData> ErrorBarDataList { get; private set; }
    public static bool IsCompatible(ISeriesView view);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Calculated();
    [CompilerGeneratedAttribute]
protected void set_Calculated(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
protected void set_YRange(MinMaxValues value);
    [CompilerGeneratedAttribute]
public List`1<ErrorBarData> get_ErrorBarDataList();
    [CompilerGeneratedAttribute]
private void set_ErrorBarDataList(List`1<ErrorBarData> value);
    protected virtual bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
    protected void CalculateForFixedErrors(IList`1<RefinedPoint> refinedPoints, double negativeError, double positiveError, double specialValue);
}
public class DevExpress.Charts.Native.ErrorBarsPointsCalculator : object {
    public Double[] CalculateErrorBars(IList`1<RefinedPoint> points, int index, int count);
}
public enum DevExpress.Charts.Native.ErrorBarValueInternal : Enum {
    public int value__;
    public static ErrorBarValueInternal Low;
    public static ErrorBarValueInternal High;
}
public class DevExpress.Charts.Native.ExponentialMovingAverageCalculator : MovingAverageCalculator {
    public virtual void UpdateMovingAverageData(IList`1<RefinedPoint> refinedPoints, int startUpdateIndex, int pointsCount, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
internal class DevExpress.Charts.Native.ExponentialRegressionCalculator : object {
    public Tuple`2<double, double> Calculate(IList`1<RefinedPoint> points, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.FibonacciArcsCalculator : FinancialIndicatorCalculator {
    public List`1<FibonacciCircle> Calculate(IRefinedSeries seriesInfo, AxisScaleTypeMap axisXScaleTypeMap, CultureInfo cultureInfo, object argument1, ValueLevelInternal valueLevel1, object argument2, ValueLevelInternal valueLevel2, IList`1<double> levels);
}
public class DevExpress.Charts.Native.FibonacciCircle : object {
    [CompilerGeneratedAttribute]
private GRealPoint2D <Center>k__BackingField;
    [CompilerGeneratedAttribute]
private GRealPoint2D <PointInCircle>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private GRealPoint2D <ScreenCenter>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ScreenRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private GRealPoint2D <ScreenPointInCircle>k__BackingField;
    public GRealPoint2D Center { get; private set; }
    public GRealPoint2D PointInCircle { get; private set; }
    public double Level { get; private set; }
    public GRealPoint2D ScreenCenter { get; public set; }
    public double ScreenRadius { get; public set; }
    public GRealPoint2D ScreenPointInCircle { get; public set; }
    public FibonacciCircle(GRealPoint2D center, GRealPoint2D pointInCircle, double level);
    [CompilerGeneratedAttribute]
public GRealPoint2D get_Center();
    [CompilerGeneratedAttribute]
private void set_Center(GRealPoint2D value);
    [CompilerGeneratedAttribute]
public GRealPoint2D get_PointInCircle();
    [CompilerGeneratedAttribute]
private void set_PointInCircle(GRealPoint2D value);
    [CompilerGeneratedAttribute]
public double get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(double value);
    [CompilerGeneratedAttribute]
public GRealPoint2D get_ScreenCenter();
    [CompilerGeneratedAttribute]
public void set_ScreenCenter(GRealPoint2D value);
    [CompilerGeneratedAttribute]
public double get_ScreenRadius();
    [CompilerGeneratedAttribute]
public void set_ScreenRadius(double value);
    [CompilerGeneratedAttribute]
public GRealPoint2D get_ScreenPointInCircle();
    [CompilerGeneratedAttribute]
public void set_ScreenPointInCircle(GRealPoint2D value);
}
public class DevExpress.Charts.Native.FibonacciFansCalculator : FinancialIndicatorCalculator {
    public List`1<FibonacciLine> CalculateLines(GRealPoint2D startPoint, GRealPoint2D endPoint, IList`1<double> levels);
    public List`1<FibonacciLine> Calculate(IRefinedSeries seriesInfo, AxisScaleTypeMap axisXScaleTypeMap, CultureInfo cultureInfo, object argument1, ValueLevelInternal valueLevel1, object argument2, ValueLevelInternal valueLevel2, IList`1<double> levels);
}
public class DevExpress.Charts.Native.FibonacciLine : object {
    private double level;
    private GRealPoint2D start;
    private GRealPoint2D end;
    private GRealPoint2D screenStart;
    private GRealPoint2D screenEnd;
    public double Level { get; }
    public GRealPoint2D Start { get; public set; }
    public GRealPoint2D End { get; public set; }
    public GRealPoint2D ScreenStart { get; public set; }
    public GRealPoint2D ScreenEnd { get; public set; }
    public FibonacciLine(double level, GRealPoint2D start, GRealPoint2D end);
    public FibonacciLine(double level, double startX, double startY, double endX, double endY);
    public FibonacciLine(double level, GRealPoint2D startPoint, double endPointX, double endPointY);
    public double get_Level();
    public GRealPoint2D get_Start();
    public void set_Start(GRealPoint2D value);
    public GRealPoint2D get_End();
    public void set_End(GRealPoint2D value);
    public GRealPoint2D get_ScreenStart();
    public void set_ScreenStart(GRealPoint2D value);
    public GRealPoint2D get_ScreenEnd();
    public void set_ScreenEnd(GRealPoint2D value);
}
public class DevExpress.Charts.Native.FibonacciRetracementCalculator : FinancialIndicatorCalculator {
    public List`1<FibonacciLine> CalculateLines(GRealPoint2D startPoint, GRealPoint2D endPoint, IList`1<double> levels);
    public List`1<FibonacciLine> Calculate(IRefinedSeries seriesInfo, AxisScaleTypeMap axisXScaleTypeMap, CultureInfo cultureInfo, object argument1, ValueLevelInternal valueLevel1, object argument2, ValueLevelInternal valueLevel2, double axisXMaxValueInternal, IList`1<double> levels);
}
public class DevExpress.Charts.Native.FinancialAggregationCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public abstract class DevExpress.Charts.Native.FinancialIndicatorCalculator : object {
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    public bool Calculated { get; protected set; }
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
protected void set_Calculated(bool value);
    protected bool IsStartPointAboveEndPoint(GRealPoint2D startPoint, GRealPoint2D endPoint);
    internal static RefinedPoint GetPointByArgument(bool fromEnd, AxisScaleTypeMap axisXScaleTypeMap, IRefinedSeries seriesInfo, object argument, CultureInfo cultureInfo);
    protected void CompareRefinedPointsByArgument(RefinedPoint refinedPoint1, ValueLevelInternal valueLevel1, RefinedPoint refinedPoint2, ValueLevelInternal valueLevel2, RefinedPoint& leftPointInfo, ValueLevelInternal& leftValueLevel, RefinedPoint& rightPointInfo, ValueLevelInternal& rightValueLevel);
}
public class DevExpress.Charts.Native.FinancialViewportIntersectionHolder : DiscreteViewportIntersectionHolder {
    public FinancialViewportIntersectionHolder(IXYSeriesView view);
    protected virtual bool IsValueInRange(RefinedPoint point, double y);
}
public class DevExpress.Charts.Native.FirstEntryReturningAggregationCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.FixedErrorBarsCalculator : ErrorBarsCalculator {
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, double negativeError, double positiveError);
    public void Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, double negativeError, double positiveError);
}
public static class DevExpress.Charts.Native.FormatUtils : object {
    private static string format;
    public static string Format { get; }
    private static FormatUtils();
    public static string get_Format();
    public static string ToString(object value);
}
public class DevExpress.Charts.Native.FullStackedInteractionContainer : StackedInteractionContainer {
    public FullStackedInteractionContainer(ISeriesView view);
    public FullStackedInteractionContainer(ISeriesView view, bool isContinuousView);
    protected virtual StackedPointInteraction CreatePointInteraction(int seriesIndex, RefinedPoint point);
}
public class DevExpress.Charts.Native.FullStackedPointInteraction : StackedPointInteraction {
    public double MaxValue { get; }
    public double MinValue { get; }
    public FullStackedPointInteraction(List`1<RefinedSeries> series, int seriesIndex, RefinedPoint point);
    public virtual double get_MaxValue();
    public virtual double get_MinValue();
    private double GetNormalizedValue(double value);
    public virtual double GetStackedPointMinValue(int pointIndex);
    public virtual double GetStackedPointMaxValue(int pointIndex);
}
public class DevExpress.Charts.Native.FullStackedStepInteractionContainer : FullStackedInteractionContainer {
    public FullStackedStepInteractionContainer(ISeriesView view);
    public FullStackedStepInteractionContainer(ISeriesView view, bool isContinuousView);
    protected virtual double CalculateSupplyValue(double currentArgument, double anotherArgumentPrev, double anotherValuePrev, double anotherArgumentNext, double anotherValueNext);
}
public class DevExpress.Charts.Native.Funnel2DLayoutCalculator : object {
    private GRealSize2D bounds;
    private IList`1<RefinedPoint> points;
    private double centerX;
    private double actualPointDistance;
    private double heightOfPolygon;
    public Funnel2DLayoutCalculator(GRealSize2D bounds, IList`1<RefinedPoint> points, double pointDistance);
    public static Nullable`1<GRealPoint2D> CalcIntersectionPoint(GRealPoint2D p1, GRealPoint2D p2, double y);
    private FunnelPointInfo CalculateSeriesPointLayout(IFunnelPoint point, IFunnelPoint bottomPoint, double topY);
    private GRealPoint2D CalcBottomPoint(double topY, double bottomY, double topWidth, double bottomWidth, bool isLeftPoint);
    public List`1<FunnelPointInfo> Calculate(bool isRectanglePointShapesUsed);
}
public class DevExpress.Charts.Native.FunnelLabelInfo : object {
    private RefinedPoint refinedPoint;
    private GRealSize2D labelSize;
    private FunnelPointInfo pointInfo;
    public RefinedPoint RefinedPoint { get; }
    public GRealSize2D LabelSize { get; }
    public FunnelPointInfo PointInfo { get; }
    public FunnelLabelInfo(RefinedPoint refinedPoint, GRealSize2D labelSize, FunnelPointInfo pointInfo);
    public RefinedPoint get_RefinedPoint();
    public GRealSize2D get_LabelSize();
    public FunnelPointInfo get_PointInfo();
}
public class DevExpress.Charts.Native.FunnelNormalizedValuesCalculator : NormalizedValuesCalculator {
    public FunnelNormalizedValuesCalculator(ISeries series);
    protected virtual Double[] CalculateNormValues();
}
public class DevExpress.Charts.Native.FunnelPointInfo : object {
    [CompilerGeneratedAttribute]
private GRealPoint2D <TopLeftPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private GRealPoint2D <TopRightPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private GRealPoint2D <BottomLeftPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private GRealPoint2D <BottomRightPoint>k__BackingField;
    public GRealPoint2D TopLeftPoint { get; public set; }
    public GRealPoint2D TopRightPoint { get; public set; }
    public GRealPoint2D BottomLeftPoint { get; public set; }
    public GRealPoint2D BottomRightPoint { get; public set; }
    [CompilerGeneratedAttribute]
public GRealPoint2D get_TopLeftPoint();
    [CompilerGeneratedAttribute]
public void set_TopLeftPoint(GRealPoint2D value);
    [CompilerGeneratedAttribute]
public GRealPoint2D get_TopRightPoint();
    [CompilerGeneratedAttribute]
public void set_TopRightPoint(GRealPoint2D value);
    [CompilerGeneratedAttribute]
public GRealPoint2D get_BottomLeftPoint();
    [CompilerGeneratedAttribute]
public void set_BottomLeftPoint(GRealPoint2D value);
    [CompilerGeneratedAttribute]
public GRealPoint2D get_BottomRightPoint();
    [CompilerGeneratedAttribute]
public void set_BottomRightPoint(GRealPoint2D value);
}
public class DevExpress.Charts.Native.FunnelPointPatternDataProvider : SimplePointPatternDataProvider {
    public FunnelPointPatternDataProvider(string patternConstant, ISeriesPointEnsurer seriesPointEnsurer);
    protected virtual object GetPercentValue();
}
public static class DevExpress.Charts.Native.GeometricUtils : object {
    public static int StrongRound(double value);
    public static double CalcDistance(GRealPoint2D point1, GRealPoint2D point2);
    public static GRealPoint2D CalcPointInLine(GRealPoint2D start, GRealPoint2D end, double ration);
    public static GRealVector2D LinearInterpolation(GRealVector2D start, GRealVector2D end, double lerpValue);
    private static List`1<GRealPoint2D> CalcLineWithEllipseIntersection(GRealPoint2D segmentPoint1, GRealPoint2D segmentPoint2, GRealPoint2D leftTopEllipseRect, GRealPoint2D rightBottomEllipseRect);
    private static List`1<GRealPoint2D> CalcLineSegmentWithArcIntersection(GRealPoint2D segmentPoint1, GRealPoint2D segmentPoint2, GRealPoint2D leftTopEllipseRect, GRealPoint2D rightBottomEllipseRect, double startAngle, double sweepAngle);
    public static double CalcBetweenPointsAngle(GRealPoint2D p1, GRealPoint2D p2);
    public static List`1<double> CalcQuadraticEquation(double a, double b, double c);
    public static GRealRect2D CalcBounds(IList`1<GRealPoint2D> points);
    public static Nullable`1<GRealPoint2D> CalcLinesIntersection(GRealPoint2D line1P1, GRealPoint2D line1P2, GRealPoint2D line2P1, GRealPoint2D line2P2, bool intervalMode);
    public static IntersectionInfo CalcLineSegmentWithRectIntersection(GRealPoint2D segmentPoint1, GRealPoint2D segmentPoint2, GRealPoint2D leftTopRectPoint, GRealPoint2D rightBottomRectPoint);
    public static IntersectionInfo CalcLineSegmentWithRoundedRectIntersection(GRealPoint2D startPoint, GRealPoint2D endPoint, GRealPoint2D leftTopRectPoint, GRealPoint2D rightBottomRectPoint, double fillet);
    public static IntersectionInfo CalcLineSegmentWithRoundedRectIntersection(GRealPoint2D startPoint, GRealPoint2D endPoint, GRealPoint2D leftTopRectPoint, GRealPoint2D rightBottomRectPoint, double leftBottomFillet, double leftTopFillet, double rightTopFillet, double rightBottomFillet);
    public static IntersectionInfo CalcLineSegmentWithEllipseIntersection(GRealPoint2D segmentPoint1, GRealPoint2D segmentPoint2, GRealPoint2D leftTopEllipseRect, GRealPoint2D rightBottomEllipseRect);
    public static List`1<GRealPoint2D> CalcRectWithEllipseIntersection(GRealRect2D rect, GRealEllipse ellipse);
    public static double NormalizeRadian(double angleRadian);
    public static double ScalarProduct(GRealVector2D v1, GRealVector2D v2);
    public static DXPoint StrongRound(GRealPoint2D point);
    public static DXRectangle StrongRound(GRealRect2D rect);
    public static GRealPoint2D CalcMean(ICollection`1<GRealPoint2D> points);
    public static bool IsValidDouble(double value);
}
public class DevExpress.Charts.Native.GeometryCalculator : object {
    private Dictionary`2<StackedInteractionContainer, SplineStackedAreaGeometryStripCreator> stackedSplineCreators;
    internal static IList`1<IGeometryStrip> CreateStrips(IRefinedSeries refinedSeries, GeometryStripCreator stripCreator);
    private IList`1<IGeometryStrip> CreateStackedSplineStrips(RefinedSeries series, IGeometryHolder geometryHolder);
    public IList`1<IGeometryStrip> CreateStrips(IRefinedSeries refinedSeries);
}
public abstract class DevExpress.Charts.Native.GeometryStripCreator : object {
    protected internal bool Closed { get; }
    protected internal bool ShouldAddEmptyStrip { get; }
    protected internal bool FilteringPointsSupported { get; }
    protected internal int StripMaxCapacity { get; }
    protected internal bool HasStripMaxCapacityLimit { get; }
    protected internal abstract virtual bool get_Closed();
    protected internal abstract virtual bool get_ShouldAddEmptyStrip();
    protected internal virtual bool get_FilteringPointsSupported();
    protected internal virtual int get_StripMaxCapacity();
    protected internal virtual bool get_HasStripMaxCapacityLimit();
    protected internal abstract virtual IGeometryStrip CreateStrip();
    protected internal IGeometryStrip CreateStrip(GeometryStripStyle style);
    protected internal virtual int GetMinVisiblePointIndex(IRefinedSeries refinedSeries);
    protected internal virtual int GetMaxVisiblePointIndex(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
    protected internal virtual GRealPoint2D GetPreviousPoint(IGeometryStrip strip);
    internal virtual void CompleteFillingStrip(IList`1<RefinedPoint> points, List`1<IGeometryStrip> strips, IGeometryStrip currentStrip);
    internal abstract virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
    internal virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.GeometryStripStyle : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private GeometryStripStyleKey <StyleKey>k__BackingField;
    public Nullable`1<int> Color { get; private set; }
    public GeometryStripStyleKey StyleKey { get; private set; }
    public bool HasColor { get; }
    public bool ShouldAddNextSplitPoint { get; }
    public bool IsEmptyPointStyle { get; }
    public GeometryStripStyle(Nullable`1<int> stripColor);
    public GeometryStripStyle(Nullable`1<int> stripColor, GeometryStripStyleKey styleKey);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Color();
    [CompilerGeneratedAttribute]
private void set_Color(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public GeometryStripStyleKey get_StyleKey();
    [CompilerGeneratedAttribute]
private void set_StyleKey(GeometryStripStyleKey value);
    public bool get_HasColor();
    public bool get_ShouldAddNextSplitPoint();
    public bool get_IsEmptyPointStyle();
    public void Assign(GeometryStripStyle other);
    public bool Equals(GeometryStripStyle obj);
}
public enum DevExpress.Charts.Native.GeometryStripStyleKey : Enum {
    public int value__;
    public static GeometryStripStyleKey OwnerStyle;
    public static GeometryStripStyleKey EmptyPointStyle;
}
public class DevExpress.Charts.Native.GestureZoomManager : object {
    private PaneAxesContainer axisContainer;
    private double refinedMinX;
    private double refinedMaxX;
    private double refinedMinY;
    private double refinedMaxY;
    private GestureZoomManager(PaneAxesContainer axisContainer);
    public static GestureZoomManager Initialize(PaneAxesContainer axisContainer);
    public void Zoom(DXPoint center, double xZoomPercent, double yZoomPercent, bool dependentValueRange);
}
public class DevExpress.Charts.Native.GPolygon2D : object {
    private GRealPoint2D[] vertices;
    public GRealPoint2D[] Vertices { get; }
    public GPolygon2D(GRealPoint2D[] vertices);
    public GRealPoint2D[] get_Vertices();
}
public class DevExpress.Charts.Native.GRealEllipse : object {
    private GRealPoint2D center;
    private double radiusX;
    private double radiusY;
    public GRealPoint2D Center { get; }
    public double RadiusX { get; }
    public double RadiusY { get; }
    public GRealEllipse(GRealPoint2D leftTop, GRealPoint2D rightBottom);
    public GRealEllipse(GRealRect2D bounds);
    public GRealEllipse(GRealPoint2D center, double radiusX, double radiusY);
    public GRealPoint2D get_Center();
    public double get_RadiusX();
    public double get_RadiusY();
}
public class DevExpress.Charts.Native.GRealLine2D : ValueType {
    private GRealPoint2D start;
    private GRealPoint2D end;
    public GRealPoint2D Start { get; }
    public GRealPoint2D End { get; }
    public GRealLine2D(GRealPoint2D start, GRealPoint2D end);
    public GRealLine2D(double x1, double y1, double x2, double y2);
    public GRealPoint2D get_Start();
    public GRealPoint2D get_End();
}
public class DevExpress.Charts.Native.GRealPoint2D : ValueType {
    private double x;
    private double y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public GRealPoint2D(double x, double y);
    public static bool op_Inequality(GRealPoint2D p1, GRealPoint2D p2);
    public static bool op_Equality(GRealPoint2D p1, GRealPoint2D p2);
    public static GRealVector2D op_Subtraction(GRealPoint2D p1, GRealPoint2D p2);
    public static GRealPoint2D op_Explicit(DXPoint point);
    public static double CalculateDistance(GRealPoint2D point1, GRealPoint2D point2);
    public sealed virtual bool Equals(GRealPoint2D other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
}
public class DevExpress.Charts.Native.GRealRect2D : ValueType {
    public static GRealRect2D Empty;
    private double left;
    private double right;
    private double top;
    private double bottom;
    private double width;
    private double height;
    public double Left { get; }
    public double Right { get; }
    public double Top { get; }
    public double Bottom { get; }
    public double Width { get; }
    public double Height { get; }
    public GRealPoint2D Center { get; }
    public bool IsEmpty { get; }
    public GRealSize2D Size { get; }
    public GRealRect2D(GRealPoint2D p1, GRealPoint2D p2);
    public GRealRect2D(double left, double top, double width, double height);
    private static GRealRect2D();
    public static bool IsIntersected(GRealRect2D rect1, GRealRect2D rect2);
    public static GRealRect2D Intersect(GRealRect2D rect1, GRealRect2D rect2);
    public static GRealRect2D Inflate(GRealRect2D rect, double dx, double dy);
    public double get_Left();
    public double get_Right();
    public double get_Top();
    public double get_Bottom();
    public double get_Width();
    public double get_Height();
    public GRealPoint2D get_Center();
    public bool get_IsEmpty();
    public GRealSize2D get_Size();
    private void CalcRightBottom();
    public void Offset(double dx, double dy);
    public void Inflate(double dx, double dy);
    public bool Contains(GRealPoint2D point);
    public bool ContainsIncludeBounds(GRealPoint2D point);
    public bool Contains(GRealRect2D rect);
    public virtual string ToString();
}
public class DevExpress.Charts.Native.GRealSize2D : ValueType {
    private double width;
    private double height;
    public static GRealSize2D Empty { get; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public bool IsEmpty { get; }
    public GRealSize2D(double width, double height);
    public static bool op_Equality(GRealSize2D size1, GRealSize2D size2);
    public static bool op_Inequality(GRealSize2D size1, GRealSize2D size2);
    public static GRealSize2D get_Empty();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public bool get_IsEmpty();
    public sealed virtual bool Equals(GRealSize2D other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class DevExpress.Charts.Native.GRealVector2D : ValueType {
    private double x;
    private double y;
    public double X { get; }
    public double Y { get; }
    public double SquaredLength { get; }
    public double Length { get; }
    public GRealVector2D UnitVector { get; }
    public GRealVector2D(double x, double y);
    public GRealVector2D(GRealPoint2D start, GRealPoint2D end);
    public static bool op_Equality(GRealVector2D v1, GRealVector2D v2);
    public static bool op_Inequality(GRealVector2D v1, GRealVector2D v2);
    public static GRealVector2D op_Addition(GRealVector2D v1, GRealVector2D v2);
    public static GRealVector2D op_Subtraction(GRealVector2D v1, GRealVector2D v2);
    public static GRealPoint2D op_Addition(GRealPoint2D point, GRealVector2D vector);
    public static GRealPoint2D op_Subtraction(GRealPoint2D point, GRealVector2D vector);
    public static GRealVector2D op_Multiply(GRealVector2D vector, double scalar);
    public static GRealVector2D op_Multiply(double scalar, GRealVector2D vector);
    public static GRealVector2D op_Division(GRealVector2D vector, double scalar);
    public double get_X();
    public double get_Y();
    public double get_SquaredLength();
    public double get_Length();
    public GRealVector2D get_UnitVector();
    public void Normalize();
    public sealed virtual bool Equals(GRealVector2D other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.GridAndTextData : object {
    private IAxisData axis;
    private IMinMaxValues visualRange;
    private bool scrollingEnabled;
    private bool staggered;
    private double axisLength;
    private IAxisGridMapping mapping;
    private IScaleOptionsBase actualScaleOptions;
    private AxisGridData gridData;
    private AxisTextData textData;
    private IScaleOptionsBase ActualScaleOptions { get; }
    public double AxisLength { get; }
    public AxisGridData GridData { get; }
    public GridAndTextData(IEnumerable`1<ISeries> seriesList, IAxisData axis, bool scrollingEnabled, IMinMaxValues visualRange, double axisLength, bool staggered);
    private IScaleOptionsBase get_ActualScaleOptions();
    public double get_AxisLength();
    public AxisGridData get_GridData();
    private AxisGridData CalculateGridData(IAxisGridMapping mapping);
    private AxisTextData CalculateTextData(IAxisGridMapping mapping, bool scrollingEnabled, Nullable`1<double> intersectionAxisInternalValue);
    private IAxisGridMapping GetAxisMapping(IEnumerable`1<ISeries> seriesList);
    private IScaleOptionsBase GetActualScaleOptions();
    private void UpdateDateTimeAutomaticGrid(IEnumerable`1<ISeries> seriesList, double axisLength);
    private void UpdateScaleOptionsGridSpacing(double gridSpacing);
    public AxisTextData GetTextData(Nullable`1<double> intersectionAxisInternalValue);
    public double CalculateGridSpacing();
}
public class DevExpress.Charts.Native.GridAsLinearLayoutCalculator : LinearLayoutCalculator {
    private IList`1<IGridLayoutItem> items;
    private IGridLayoutOptions options;
    private Limits[] rowsSizes;
    private Limits[] columnsSizes;
    private IList`1<GridLayoutInfo> infos;
    public GridAsLinearLayoutCalculator(IList`1<IGridLayoutItem> items, IGridLayoutOptions options, LayoutCalculatorHelper layoutHelper);
    public static LayoutInfoList Calculate(IList`1<IGridLayoutItem> items, IGridLayoutOptions layoutOptions, int itemsDistance, DXRectangle originalMaxBounds, DXRectangle maxBounds);
    public static LayoutInfoList Calculate(IList`1<IGridLayoutItem> items, IGridLayoutOptions layoutOptions, int itemsDistance, DXRectangle originalMaxBounds, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
    private void HideInvisibleItems(IList`1<GridLayoutInfo> items, IList`1<ILinearLayoutItem> rowDefinitions, IList`1<ILinearLayoutItem> columnDefinitions);
    protected virtual IList`1<DXRectangle> GetItemsBounds(int itemsDistance, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
    protected virtual LayoutInfoList CreateLayoutInfo(List`1<LayoutInfo> list, List`1<SeparatorInfo> separators);
    protected virtual void UpdateSeparatorsInfos(List`1<SeparatorInfo> separators);
    [CompilerGeneratedAttribute]
private bool <GetItemsBounds>b__9_0(int i);
}
public class DevExpress.Charts.Native.GridClusterPointsFactory : object {
    private RefinedSeries refinedSeries;
    private AxisScaleTypeMap scaleMapArgumentX;
    private AxisScaleTypeMap scaleMapArgumentY;
    public GridClusterPointsFactory(RefinedSeries refinedSeries, AxisScaleTypeMap scaleMapArgumentX, AxisScaleTypeMap scaleMapArgumentY);
    public RefinedPoint CreateAggregatedPoint(double argumentX, double argumentY, double value, IList`1<RefinedPoint> sourcePoints);
}
public class DevExpress.Charts.Native.GridGenerator : object {
    public List`1<double> GenerateGridValues(double min, double max, RangeControlGridUnit gridUnit, RangeControlClientGridMapping gridMapping, RangeControlMapping map);
}
public class DevExpress.Charts.Native.GridLayoutCalculator : LayoutCalculator {
    private IList`1<IGridLayoutItem> items;
    private IGridLayoutOptions options;
    private Limits[] rowsSizes;
    private Limits[] columnsSizes;
    private IList`1<GridLayoutInfo> infos;
    public GridLayoutCalculator(IList`1<IGridLayoutItem> items, IGridLayoutOptions options, LayoutCalculatorHelper layoutHelper);
    public static LayoutInfoList Calculate(IList`1<IGridLayoutItem> items, IGridLayoutOptions layoutOptions, int itemsDistance, DXRectangle originalMaxBounds, DXRectangle maxBounds);
    public static LayoutInfoList Calculate(IList`1<IGridLayoutItem> items, IGridLayoutOptions layoutOptions, int itemsDistance, DXRectangle originalMaxBounds, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
    private List`1<DXRectangle> CalculateCollapsedItemsBounds(List`1<LayoutItem> collapsedItems, int itemsDistance, DXRectangle maxBounds, Int32& maxCollapsedLineWidth);
    private List`1<LayoutItem> GenerateLayoutItems(int itemsDistance, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
    protected virtual IList`1<DXRectangle> GetItemsBounds(int itemsDistance, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
    protected virtual void UpdateSeparatorsInfos(List`1<SeparatorInfo> separators);
    protected virtual LayoutInfoList CreateLayoutInfo(List`1<LayoutInfo> list, List`1<SeparatorInfo> separators);
    protected virtual List`1<SeparatorInfo> GetSeparatorsBoundsInternal(List`1<SeparatorInfo> list);
}
public class DevExpress.Charts.Native.GridLayoutInfo : object {
    private int gridRow;
    private int gridColumn;
    private int rowSpan;
    private int columnSpan;
    private bool visible;
    public int Row { get; }
    public int Column { get; }
    public int RowSpan { get; }
    public int ColumnSpan { get; }
    public bool VisibleInLayout { get; }
    public GridLayoutInfo(int gridRow, int gridColumn, int rowSpan, int columnSpan, bool visible);
    public sealed virtual int get_Row();
    public sealed virtual int get_Column();
    public sealed virtual int get_RowSpan();
    public sealed virtual int get_ColumnSpan();
    public sealed virtual bool get_VisibleInLayout();
}
public class DevExpress.Charts.Native.GridLayoutInfoList : LayoutInfoList {
    public Limits[] RowsSizes;
    public Limits[] ColumnsSizes;
    public int RowsCount { get; }
    public int ColumnsCount { get; }
    public GridLayoutInfoList(List`1<LayoutInfo> layoutInfos, Limits[] rowsSizes, Limits[] columnsSizes, List`1<SeparatorInfo> separators);
    public int get_RowsCount();
    public int get_ColumnsCount();
}
public class DevExpress.Charts.Native.GridLayoutItem : LayoutItem {
    private bool isFixedHorizontal;
    private bool isFixedVertical;
    public bool FixedHorizontal { get; }
    public bool FixedVertical { get; }
    public int HorizontalSizeInPixels { get; }
    public int VerticalSizeInPixels { get; }
    public GridLayoutItem(int index, DXRectangle bounds, bool isFixedVertical, bool isFixedHorizontal);
    public bool get_FixedHorizontal();
    public bool get_FixedVertical();
    public int get_HorizontalSizeInPixels();
    public int get_VerticalSizeInPixels();
}
public enum DevExpress.Charts.Native.GridLayoutModeNative : Enum {
    public int value__;
    public static GridLayoutModeNative GridAndLabelCentered;
    public static GridLayoutModeNative GridShiftedLabelCentered;
    public static GridLayoutModeNative GridAndLabelShifted;
}
public class DevExpress.Charts.Native.GridPlacementStrategy : object {
    private LayoutCalculatorHelper layoutHelper;
    private IList`1<IGridLayoutItem> items;
    private IGridLayoutOptions options;
    private List`1<LayoutItem> collapsedItems;
    private GridLayoutInfo[] infos;
    private bool autoPrimaryDimension;
    private bool autoSecondaryDimension;
    private int primaryDefinitionsCount;
    private int secondaryDefinitionsCount;
    private Int32[0...,0...] itemsMap;
    private int primaryFilledDimension;
    private int secondaryFilledDimension;
    private int primaryDimension;
    private int secondaryDimension;
    public int RowsCount { get; }
    public int ColumnsCount { get; }
    public GridPlacementStrategy(IList`1<IGridLayoutItem> items, IGridLayoutOptions options);
    public GridPlacementStrategy(IList`1<IGridLayoutItem> items, IGridLayoutOptions options, List`1<LayoutItem> collapsedItems);
    public int get_RowsCount();
    public int get_ColumnsCount();
    private void CreateItemsMap();
    private List`1<IGridLayoutItem> FillItemsMap();
    private bool CanPlaceInGrid(Int32[0...,0...] itemsMap, int row, int column, int rowSpan, int columnSpan);
    private bool TryPlaceItems(IList`1<IGridLayoutItem> initialUnplacedItems, Int32[0...,0...] itemsMap, int primaryVisibleDimension, int secondaryVisibleDimension, GridLayoutInfo[]& infos, Int32& linesCount);
    private GridLayoutInfo[] PlaceItems(List`1<IGridLayoutItem> unplacedItems, Int32& primaryCalculatedDimension, Int32& secondaryCalculatedDimension);
    private GridLayoutInfo TryUnionInfos(GridLayoutInfo info1, GridLayoutInfo info2);
    private List`1<GridLayoutInfo> UnionAvailableSpaces(List`1<GridLayoutInfo> spaces);
    private int CheckPrimary(int pCell, int secondaryGridIndex, int secondaryGridSpan, int secondaryDimension);
    private int CheckSecondary(int sCell, int primaryGridIndex, int primaryGridSpan, int primaryDimension);
    private bool ResizeItem(GridLayoutInfo availableArea);
    private void CollapseItems();
    public void Calculate();
    public IList`1<GridLayoutInfo> GetInfos();
}
public abstract class DevExpress.Charts.Native.GridPointsCalculatorBase : object {
    private GridClusterPointsFactory pointFactory;
    private RefinedPointsGridCluster[0...,0...] clusters;
    private MinMaxValues rangeX;
    private MinMaxValues rangeY;
    private double stepX;
    private double stepY;
    private int countX;
    private int countY;
    protected GridClusterPointsFactory PointFactory { get; }
    protected double MinX { get; }
    protected double MinY { get; }
    protected double StepX { get; }
    protected double StepY { get; }
    protected internal int ClusterSizeX { get; }
    protected internal int ClusterSizeY { get; }
    protected internal RefinedPointsGridCluster[0...,0...] Clusters { get; }
    protected GridPointsCalculatorBase(GridClusterPointsFactory factory);
    protected GridClusterPointsFactory get_PointFactory();
    protected double get_MinX();
    protected double get_MinY();
    protected double get_StepX();
    protected double get_StepY();
    protected internal int get_ClusterSizeX();
    protected internal int get_ClusterSizeY();
    protected internal RefinedPointsGridCluster[0...,0...] get_Clusters();
    private MinMaxValues GetRangeX(IList`1<RefinedPoint> points);
    private MinMaxValues GetRangeY(IList`1<RefinedPoint> points);
    private int CorrectGridNodesCount(int realCount, int thresholdCount);
    private void UpdateMetrics(IList`1<RefinedPoint> points, int gridNodesCount);
    protected RefinedPoint CreateAggregatedPoint(RefinedPointsGridCluster cluster);
    protected virtual RefinedPointsGridCluster[0...,0...] CreateEmptyClusters(int countX, int countY);
    protected virtual void ProcessPointForCluster(int indexX, int indexY, RefinedPoint point);
    protected abstract virtual IList`1<RefinedPoint> CreateClusterPoints();
    protected internal abstract virtual bool CanProcessPoints(int pointsCount, int gridNodesCount);
    public IList`1<RefinedPoint> Calculate(IList`1<RefinedPoint> points, int thresholdPointsCount);
}
public class DevExpress.Charts.Native.GridSpacingCalculator : object {
    private IAxisData axis;
    private IAxisGridMapping mapping;
    private IScaleOptionsBase actualScaleOptions;
    private double axisLength;
    private double delta;
    private bool IsLogarithmic { get; }
    private GridSpacingCalculator(IAxisData axis, IAxisGridMapping mapping, IScaleOptionsBase actualScaleOptions, IMinMaxValues visualRange, double axisLength);
    public static double Calculate(double axisRangeDelta, double screenDelta, double gridSpacingFactor);
    public static double Calculate(IAxisData axis, IAxisGridMapping mapping, IScaleOptionsBase actualScaleOptions, IMinMaxValues visualRange, double axisLength);
    private bool get_IsLogarithmic();
    private double CalculateDelta(IMinMaxValues visualRange);
    private double CalculateManualGridSpacing();
    private double CalculateLogarithmicGridSpacing();
    private double CalculateNumericGridSpacing();
    private double CalculateQualitativeGridSpacing();
    private double CalculateGridSpacing();
}
internal class DevExpress.Charts.Native.GroupProcessor`1 : TypedUpdateProcessor`1<T> {
    private IUpdateProcessor[] children;
    public GroupProcessor`1(IUpdateProcessor[] children);
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual bool ShouldForceUpdate();
    protected virtual IList`1<IUpdateAction> TypedProcess(T updateInfo);
    protected virtual IList`1<IUpdateAction> Process(ChartUpdateInfoBase updateInfo);
}
internal class DevExpress.Charts.Native.GroupProcessor`2 : GroupProcessor`1<T> {
    public GroupProcessor`2(IUpdateProcessor[] children);
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
}
public class DevExpress.Charts.Native.HeatmapRangeStopCore : object {
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private HeatmapRangeStopTypeCore <Type>k__BackingField;
    public double Value { get; public set; }
    public HeatmapRangeStopTypeCore Type { get; public set; }
    public HeatmapRangeStopCore(double value);
    public HeatmapRangeStopCore(double value, HeatmapRangeStopTypeCore type);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    [CompilerGeneratedAttribute]
public HeatmapRangeStopTypeCore get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(HeatmapRangeStopTypeCore value);
    public double GetAbsolute(MinMaxValues valueRange);
    public double GetAbsolute(double min, double max);
    public double GetPercentage(MinMaxValues valueRange);
    public double GetPercentage(double min, double max);
}
public enum DevExpress.Charts.Native.HeatmapRangeStopTypeCore : Enum {
    public int value__;
    public static HeatmapRangeStopTypeCore Absolute;
    public static HeatmapRangeStopTypeCore Percentage;
}
public class DevExpress.Charts.Native.HistogramAggregationCalculator : object {
    private bool isRangeView;
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    public HistogramAggregationCalculator(bool isRangeView);
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public static class DevExpress.Charts.Native.HolidaysLoader : object {
    private static HolidayBaseCollection LoadHolidaysFromXml(string xml);
    private static HolidayBaseCollection LoadHolidaysFromOutlook(string fileName);
    public static HolidayBaseCollection LoadHolidaysCollection(string fileName, string msgFileNotFound, string msgCantImportHolidays);
}
public class DevExpress.Charts.Native.HorizontalLayoutCalculatorHelper : LayoutCalculatorHelper {
    public virtual int GetStartValue(DXRectangle bounds);
    public virtual int GetEndValue(DXRectangle bounds);
    public virtual int GetLength(DXRectangle bounds);
    public virtual int GetLeft(DXRectangle bounds);
    public virtual int GetRight(DXRectangle bounds);
    public virtual DXRectangle CreateNewBounds(DXRectangle oldBounds, int start, int length);
    public virtual int GetFixedSize(GridLayoutItem item);
    public virtual bool IsFixed(GridLayoutItem item);
    public virtual IList`1<ILinearLayoutItem> GetPrimaryDefinitionCollection(IGridLayoutOptions options);
    public virtual IList`1<ILinearLayoutItem> GetPrimaryDefinitionCollection(IList`1<ILinearLayoutItem> rowDefinitions, IList`1<ILinearLayoutItem> columnDefinitions);
    public virtual IList`1<ILinearLayoutItem> GetSecondaryDefinitionCollection(IGridLayoutOptions options);
    public virtual int GetPrimaryGridIndex(IGridLayoutItem options);
    public virtual int GetSecondaryGridIndex(IGridLayoutItem options);
    public virtual int GetPrimaryGridSpan(IGridLayoutItem options);
    public virtual int GetSecondaryGridSpan(IGridLayoutItem options);
    public virtual int GetVerticalValue(int primaryValue, int secondaryValue);
    public virtual int GetHorizontalValue(int primaryValue, int secondaryValue);
}
public abstract class DevExpress.Charts.Native.HorizontalStep : Step {
    private int startRowIndex;
    protected int StartRowIndex { get; }
    protected HorizontalStep(int position, int startRowIndex, DXRectangle rect, RectanglesLayout layout);
    protected int get_StartRowIndex();
    protected abstract virtual DXPoint CalcNearPosition(Cell cell);
    protected abstract virtual void CalcFarPositions(Cell cell, DXPoint& point1, DXPoint& point2);
    protected virtual void UpdatePrimaryTestPositions();
    protected virtual void UpdateSecondaryTestPositions();
}
public interface DevExpress.Charts.Native.IAffectsAxisRange {
    public IAxisData AxisYData { get; }
    public abstract virtual IAxisData get_AxisYData();
    public abstract virtual MinMaxValues GetMinMaxValues(IMinMaxValues visualRangeOfOtherAxisForFiltering);
}
public interface DevExpress.Charts.Native.IAggregateFunctionProvider {
    public AggregateFunctionNative AggregateFunction { get; }
    public abstract virtual AggregateFunctionNative get_AggregateFunction();
}
public interface DevExpress.Charts.Native.IAggregationCalculator {
    public bool CanKeepSinglePoint { get; }
    public bool CanSupportErrorBars { get; }
    public abstract virtual bool get_CanKeepSinglePoint();
    public abstract virtual bool get_CanSupportErrorBars();
    public abstract virtual Double[] Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& pointState);
}
public interface DevExpress.Charts.Native.IAnnotationLayout {
    public GRealPoint2D AnchorPoint { get; }
    public double CursorOffset { get; }
    public bool ShowTail { get; }
    public GRealPoint2D InitOffset { get; }
    public GRealSize2D Size { get; }
    public AnnotationLocation Location { get; public set; }
    public GRealRect2D Bounds { get; public set; }
    public GRealPoint2D Offset { get; public set; }
    public abstract virtual GRealPoint2D get_AnchorPoint();
    public abstract virtual double get_CursorOffset();
    public abstract virtual bool get_ShowTail();
    public abstract virtual GRealPoint2D get_InitOffset();
    public abstract virtual GRealSize2D get_Size();
    public abstract virtual AnnotationLocation get_Location();
    public abstract virtual void set_Location(AnnotationLocation value);
    public abstract virtual GRealRect2D get_Bounds();
    public abstract virtual void set_Bounds(GRealRect2D value);
    public abstract virtual GRealPoint2D get_Offset();
    public abstract virtual void set_Offset(GRealPoint2D value);
}
public interface DevExpress.Charts.Native.IArgumentPoint {
    public double Argument { get; public set; }
    public abstract virtual double get_Argument();
    public abstract virtual void set_Argument(double value);
}
public interface DevExpress.Charts.Native.IAutoScaleBreaksContainer {
    public bool Enabled { get; }
    public bool IsArgumentContainer { get; }
    public IList`1<IScaleDiapason> ScaleDiapasons { get; }
    public IAutoScaleBreaksCreator Creator { get; }
    public int MaxCount { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual bool get_IsArgumentContainer();
    public abstract virtual IList`1<IScaleDiapason> get_ScaleDiapasons();
    public abstract virtual IAutoScaleBreaksCreator get_Creator();
    public abstract virtual int get_MaxCount();
}
public interface DevExpress.Charts.Native.IAutoScaleBreaksCreator {
    public abstract virtual IEnumerable`1<IScaleDiapason> Calculate(List`1<double> axisValues, int maxScaleBreaksCount);
    public abstract virtual IScaleDiapason CreatePlatformAutoScaleBreak(double edge1, double edge2);
}
public interface DevExpress.Charts.Native.IAxisData {
    public AxisGroup AxisGroup { get; }
    public bool AutoScroll { get; }
    public bool IsArgumentAxis { get; }
    public bool IsValueAxis { get; }
    public bool ShowLabels { get; }
    public bool ShowMajorTickmarks { get; }
    public bool ShowMinorTickmarks { get; }
    public bool ShowMajorGridlines { get; }
    public bool ShowMinorGridlines { get; }
    public bool Interlaced { get; }
    public bool IsVertical { get; }
    public bool FixedRange { get; }
    public bool Reverse { get; }
    public bool IsRadarAxis { get; }
    public bool IsUpdating { get; public set; }
    public IAxisLabel Label { get; }
    public int GridSpacingFactor { get; }
    public int MinorCount { get; }
    public bool CanShowCustomWithAutoLabels { get; }
    public bool ShouldCalculateRangeLimits { get; }
    public AxisScaleTypeMap AxisScaleTypeMap { get; public set; }
    public IAxisRange Range { get; }
    public IAxisRange ScrollingRange { get; }
    public IVisualAxisRangeData VisualRange { get; }
    public IWholeAxisRangeData WholeRange { get; }
    public IAxisTitle Title { get; }
    public IAggregateFunctionProvider AggregateFunctionProvider { get; }
    public INumericScaleOptions NumericScaleOptions { get; }
    public IDateTimeScaleOptions DateTimeScaleOptions { get; }
    public ITimeSpanScaleOptions TimeSpanScaleOptions { get; }
    public IScaleOptionsBase QualitativeScaleOptions { get; }
    public IComparer QualitativeScaleComparer { get; }
    public IAxisGridMapping GridMapping { get; }
    public AxisVisibilityInPanes AxisVisibilityInPanes { get; }
    public abstract virtual AxisGroup get_AxisGroup();
    public abstract virtual bool get_AutoScroll();
    public abstract virtual bool get_IsArgumentAxis();
    public abstract virtual bool get_IsValueAxis();
    public abstract virtual bool get_ShowLabels();
    public abstract virtual bool get_ShowMajorTickmarks();
    public abstract virtual bool get_ShowMinorTickmarks();
    public abstract virtual bool get_ShowMajorGridlines();
    public abstract virtual bool get_ShowMinorGridlines();
    public abstract virtual bool get_Interlaced();
    public abstract virtual bool get_IsVertical();
    public abstract virtual bool get_FixedRange();
    public abstract virtual bool get_Reverse();
    public abstract virtual bool get_IsRadarAxis();
    public abstract virtual bool get_IsUpdating();
    public abstract virtual void set_IsUpdating(bool value);
    public abstract virtual IAxisLabel get_Label();
    public abstract virtual int get_GridSpacingFactor();
    public abstract virtual int get_MinorCount();
    public abstract virtual bool get_CanShowCustomWithAutoLabels();
    public abstract virtual bool get_ShouldCalculateRangeLimits();
    public abstract virtual AxisScaleTypeMap get_AxisScaleTypeMap();
    public abstract virtual void set_AxisScaleTypeMap(AxisScaleTypeMap value);
    public abstract virtual IAxisRange get_Range();
    public abstract virtual IAxisRange get_ScrollingRange();
    public abstract virtual IVisualAxisRangeData get_VisualRange();
    public abstract virtual IWholeAxisRangeData get_WholeRange();
    public abstract virtual IAxisTitle get_Title();
    public abstract virtual IAggregateFunctionProvider get_AggregateFunctionProvider();
    public abstract virtual INumericScaleOptions get_NumericScaleOptions();
    public abstract virtual IDateTimeScaleOptions get_DateTimeScaleOptions();
    public abstract virtual ITimeSpanScaleOptions get_TimeSpanScaleOptions();
    public abstract virtual IScaleOptionsBase get_QualitativeScaleOptions();
    public abstract virtual IComparer get_QualitativeScaleComparer();
    public abstract virtual IAxisGridMapping get_GridMapping();
    public abstract virtual AxisVisibilityInPanes get_AxisVisibilityInPanes();
    public abstract virtual void Deserialize();
    public abstract virtual void UpdateUserValues();
    public abstract virtual void UpdateAutoMeasureUnit();
    public abstract virtual void UpdateIntervals();
    public abstract virtual RangeValue IncreaseRange(RangeValue range, bool applySideMargins);
    public abstract virtual GRealRect2D GetLabelBounds(IPane pane);
    public abstract virtual bool RaiseBeforeZoom(IMinMaxValues rangeInternalCoords);
    public abstract virtual bool RaiseBeforeScroll(IMinMaxValues rangeInternalCoords);
}
public interface DevExpress.Charts.Native.IAxisElementContainer {
    public IEnumerable`1<IScaleBreak> ScaleBreaks { get; }
    public IEnumerable`1<IConstantLine> ConstantLines { get; }
    public IEnumerable`1<IStrip> Strips { get; }
    public IEnumerable`1<ICustomAxisLabel> CustomLabels { get; }
    public abstract virtual IEnumerable`1<IScaleBreak> get_ScaleBreaks();
    public abstract virtual IEnumerable`1<IConstantLine> get_ConstantLines();
    public abstract virtual IEnumerable`1<IStrip> get_Strips();
    public abstract virtual IEnumerable`1<ICustomAxisLabel> get_CustomLabels();
}
public interface DevExpress.Charts.Native.IAxisGridMapping {
    public Transformation Transformation { get; }
    public double Offset { get; }
    public bool CanFloorAlignedValue { get; }
    public abstract virtual Transformation get_Transformation();
    public abstract virtual double get_Offset();
    public abstract virtual bool get_CanFloorAlignedValue();
    public abstract virtual bool IsCompatible(object value);
    public abstract virtual double InternalToAligned(double internalValue);
    public abstract virtual double AlignedToInternal(double alignedValue);
    public abstract virtual object InternalToNative(double alignedValue);
    public abstract virtual double NativeToInternal(object value);
}
public interface DevExpress.Charts.Native.IAxisLabel {
    public bool Staggered { get; }
    public int Angle { get; }
    public IAxisLabelResolveOverlappingOptions ResolveOverlappingOptions { get; }
    public IAxisLabelFormatterCore Formatter { get; public set; }
    public string TextPattern { get; }
    public abstract virtual bool get_Staggered();
    public abstract virtual int get_Angle();
    public abstract virtual IAxisLabelResolveOverlappingOptions get_ResolveOverlappingOptions();
    public abstract virtual IAxisLabelFormatterCore get_Formatter();
    public abstract virtual void set_Formatter(IAxisLabelFormatterCore value);
    public abstract virtual string get_TextPattern();
}
public interface DevExpress.Charts.Native.IAxisLabelFormatterCore {
    public abstract virtual string GetAxisLabelText(object axisValue);
}
public interface DevExpress.Charts.Native.IAxisLabelLayout {
    public string Text { get; }
    public GRealSize2D Size { get; }
    public GRealPoint2D Pivot { get; }
    public GRealRect2D Bounds { get; }
    public double Angle { get; public set; }
    public GRealPoint2D Offset { get; public set; }
    public GRealPoint2D LimitsOffset { get; public set; }
    public bool Visible { get; public set; }
    public bool IsCustomLabel { get; }
    public bool IsIntersectionAutoLabel { get; }
    public int GridIndex { get; }
    public bool IsIntervalEdge { get; }
    public abstract virtual string get_Text();
    public abstract virtual GRealSize2D get_Size();
    public abstract virtual GRealPoint2D get_Pivot();
    public abstract virtual GRealRect2D get_Bounds();
    public abstract virtual double get_Angle();
    public abstract virtual void set_Angle(double value);
    public abstract virtual GRealPoint2D get_Offset();
    public abstract virtual void set_Offset(GRealPoint2D value);
    public abstract virtual GRealPoint2D get_LimitsOffset();
    public abstract virtual void set_LimitsOffset(GRealPoint2D value);
    public abstract virtual bool get_Visible();
    public abstract virtual void set_Visible(bool value);
    public abstract virtual bool get_IsCustomLabel();
    public abstract virtual bool get_IsIntersectionAutoLabel();
    public abstract virtual int get_GridIndex();
    public abstract virtual bool get_IsIntervalEdge();
}
public interface DevExpress.Charts.Native.IAxisLabelResolveOverlappingOptions {
    public bool AllowHide { get; }
    public bool AllowStagger { get; }
    public bool AllowRotate { get; }
    public int MinIndent { get; }
    public abstract virtual bool get_AllowHide();
    public abstract virtual bool get_AllowStagger();
    public abstract virtual bool get_AllowRotate();
    public abstract virtual int get_MinIndent();
}
public interface DevExpress.Charts.Native.IAxisMappingCore {
    public double AxisLength { get; }
    public abstract virtual double get_AxisLength();
    public abstract virtual double GetAxisValue(double value);
    public abstract virtual double GetExactAxisValue(double value);
    public abstract virtual double GetRoundedAxisValue(double value);
    public abstract virtual double GetRoundedExactAxisValue(double value);
    public abstract virtual double GetClampedAxisValue(double value);
    public abstract virtual double GetClampedExactAxisValue(double value);
    public abstract virtual double GetRoundedClampedAxisValue(double value);
    public abstract virtual double GetInternalCoord(double value);
    public abstract virtual int GetRoundedInterval(double interval);
    public abstract virtual MinMaxValues GetCoordDiapasonInternal(double coordinate, int diapason);
}
public interface DevExpress.Charts.Native.IAxisProvider {
    public IEnumerable`1<IAxisData> AxesX { get; }
    public IEnumerable`1<IAxisData> AxesY { get; }
    public IEnumerable`1<IAxisData> AxesZ { get; }
    public abstract virtual IEnumerable`1<IAxisData> get_AxesX();
    public abstract virtual IEnumerable`1<IAxisData> get_AxesY();
    public abstract virtual IEnumerable`1<IAxisData> get_AxesZ();
}
public interface DevExpress.Charts.Native.IAxisRange {
    public object MinValue { get; }
    public object MaxValue { get; }
    public double MinValueInternal { get; }
    public double MaxValueInternal { get; }
    public abstract virtual object get_MinValue();
    public abstract virtual object get_MaxValue();
    public abstract virtual double get_MinValueInternal();
    public abstract virtual double get_MaxValueInternal();
    public abstract virtual void Assign(IAxisRange source);
    public abstract virtual void Assign(IAxisRangeData source);
    public abstract virtual void UpdateRange(object min, object max, double internalMin, double internalMax);
}
public interface DevExpress.Charts.Native.IAxisRangeData {
    public bool Auto { get; }
    public object MinValue { get; public set; }
    public object MaxValue { get; public set; }
    public MinMaxValues SideMargins { get; public set; }
    public double ActualStartSideMargin { get; public set; }
    public double ActualEndSideMargin { get; public set; }
    public bool AutoCorrectMin { get; public set; }
    public bool AutoCorrectMax { get; public set; }
    public double RefinedMin { get; public set; }
    public double RefinedMax { get; public set; }
    public RangeCorrectionMode CorrectionMode { get; public set; }
    public bool AlwaysShowZeroLevel { get; public set; }
    public SideMarginMode AutoSideMargins { get; public set; }
    public SideMarginSizeUnitNative SideMarginSizeUnit { get; public set; }
    public abstract virtual bool get_Auto();
    public abstract virtual object get_MinValue();
    public abstract virtual void set_MinValue(object value);
    public abstract virtual object get_MaxValue();
    public abstract virtual void set_MaxValue(object value);
    public abstract virtual MinMaxValues get_SideMargins();
    public abstract virtual void set_SideMargins(MinMaxValues value);
    public abstract virtual double get_ActualStartSideMargin();
    public abstract virtual void set_ActualStartSideMargin(double value);
    public abstract virtual double get_ActualEndSideMargin();
    public abstract virtual void set_ActualEndSideMargin(double value);
    public abstract virtual bool get_AutoCorrectMin();
    public abstract virtual void set_AutoCorrectMin(bool value);
    public abstract virtual bool get_AutoCorrectMax();
    public abstract virtual void set_AutoCorrectMax(bool value);
    public abstract virtual double get_RefinedMin();
    public abstract virtual void set_RefinedMin(double value);
    public abstract virtual double get_RefinedMax();
    public abstract virtual void set_RefinedMax(double value);
    public abstract virtual RangeCorrectionMode get_CorrectionMode();
    public abstract virtual void set_CorrectionMode(RangeCorrectionMode value);
    public abstract virtual bool get_AlwaysShowZeroLevel();
    public abstract virtual void set_AlwaysShowZeroLevel(bool value);
    public abstract virtual SideMarginMode get_AutoSideMargins();
    public abstract virtual void set_AutoSideMargins(SideMarginMode value);
    public abstract virtual SideMarginSizeUnitNative get_SideMarginSizeUnit();
    public abstract virtual void set_SideMarginSizeUnit(SideMarginSizeUnitNative value);
    public abstract virtual void Reset(bool needUpdate, bool resetMin, bool resetMax);
    public abstract virtual bool Contains(double value);
    public abstract virtual void UpdateRange(object min, object max, double internalMin, double internalMax);
    public abstract virtual void ApplyState(RangeSnapshot rangeSnapshot);
}
public interface DevExpress.Charts.Native.IAxisTitle {
    public object Content { get; }
    public abstract virtual object get_Content();
}
public interface DevExpress.Charts.Native.IAxisValueContainer {
    public IAxisData Axis { get; }
    public bool IsEnabled { get; }
    public CultureInfo Culture { get; }
    public object UserValue { get; }
    public object AxisValue { get; public set; }
    public double Value { get; public set; }
    public abstract virtual IAxisData get_Axis();
    public abstract virtual bool get_IsEnabled();
    public abstract virtual CultureInfo get_Culture();
    public abstract virtual object get_UserValue();
    public abstract virtual object get_AxisValue();
    public abstract virtual void set_AxisValue(object value);
    public abstract virtual double get_Value();
    public abstract virtual void set_Value(double value);
}
public interface DevExpress.Charts.Native.IBarSeriesView {
    public double BarWidth { get; public set; }
    public abstract virtual double get_BarWidth();
    public abstract virtual void set_BarWidth(double value);
}
public interface DevExpress.Charts.Native.IBasePoint {
    public ISeriesPoint SeriesPoint { get; }
    public IEnumerable`1<RefinedPoint> Children { get; }
    public bool IsEmpty { get; }
    public abstract virtual ISeriesPoint get_SeriesPoint();
    public abstract virtual IEnumerable`1<RefinedPoint> get_Children();
    public abstract virtual bool get_IsEmpty();
}
public interface DevExpress.Charts.Native.IBezierStrip {
    public abstract virtual MinMaxValues CalculateMinMaxValues();
    public abstract virtual MinMaxValues CalculateMinMaxArguments();
}
public interface DevExpress.Charts.Native.IBezierStripSplitter {
    public List`1<BezierStrip> Strips { get; }
    public abstract virtual List`1<BezierStrip> get_Strips();
    public abstract virtual bool SplitStrip(IList`1<RefinedPoint> points, List`1<GRealPoint2D> bezierPoints);
    public abstract virtual bool SplitBottomStrip(Dictionary`2<int, GRealPoint2D> currentPointByIndex, List`1<GRealPoint2D> resultDrawingPoints, List`1<GRealPoint2D> originalDrawingPoints, int index, double x, bool isLast);
    public abstract virtual void Clear();
    public abstract virtual bool CanProcessPoint(RefinedPoint point);
    public abstract virtual void SetSharedStripsContainer(BezierStripsContainer container);
}
public interface DevExpress.Charts.Native.IBindingProcessorBase {
    public abstract virtual Tuple`2<bool, bool> ProcessUpdates(DataSourceUpdateInfoCollection updates, bool seriesCountChanged);
}
public interface DevExpress.Charts.Native.IBindingProvider {
    public IBindingProcessorBase BindingProcessor { get; }
    public object DataSource { get; }
    public bool IsValidMembersForBinding { get; }
    public int ExistItemsCount { get; }
    public abstract virtual IBindingProcessorBase get_BindingProcessor();
    public abstract virtual object get_DataSource();
    public abstract virtual bool get_IsValidMembersForBinding();
    public abstract virtual int get_ExistItemsCount();
}
public interface DevExpress.Charts.Native.IBoxPlotPoint {
    public double Min { get; public set; }
    public double Quartile1 { get; public set; }
    public double Median { get; public set; }
    public double Quartile3 { get; public set; }
    public double Max { get; public set; }
    public double Mean { get; public set; }
    public Double[] Outliers { get; public set; }
    public abstract virtual double get_Min();
    public abstract virtual void set_Min(double value);
    public abstract virtual double get_Quartile1();
    public abstract virtual void set_Quartile1(double value);
    public abstract virtual double get_Median();
    public abstract virtual void set_Median(double value);
    public abstract virtual double get_Quartile3();
    public abstract virtual void set_Quartile3(double value);
    public abstract virtual double get_Max();
    public abstract virtual void set_Max(double value);
    public abstract virtual double get_Mean();
    public abstract virtual void set_Mean(double value);
    public abstract virtual Double[] get_Outliers();
    public abstract virtual void set_Outliers(Double[] value);
}
public interface DevExpress.Charts.Native.IChartBindingProvider {
    public string SeriesDataMember { get; }
    public ISeriesFactory SeriesFactory { get; }
    public abstract virtual bool UpdateAutoSeries(IList`1<ISeries> autoCreatedSeries);
    public abstract virtual string get_SeriesDataMember();
    public abstract virtual ISeriesFactory get_SeriesFactory();
}
public interface DevExpress.Charts.Native.IChartCalculatedField {
    public object OwnerDataSource { get; }
    public IChartCalculatedField PlatformInstance { get; }
    public abstract virtual object get_OwnerDataSource();
    public abstract virtual IChartCalculatedField get_PlatformInstance();
}
public interface DevExpress.Charts.Native.IChartDataContainer {
    public IEnumerable`1<ISeries> Series { get; }
    public ISeriesBase SeriesTemplate { get; }
    public bool ShouldUseSeriesTemplate { get; }
    public bool DesignMode { get; }
    public abstract virtual IEnumerable`1<ISeries> get_Series();
    public abstract virtual ISeriesBase get_SeriesTemplate();
    public abstract virtual bool get_ShouldUseSeriesTemplate();
    public abstract virtual bool get_DesignMode();
}
public interface DevExpress.Charts.Native.IChartWithData {
    public object Parent { get; }
    public bool Loading { get; }
    public bool WasMeasured { get; }
    public ISeriesTemplateContainer Diagram { get; }
    public IChartWithDataViewController ViewController { get; }
    public Dictionary`2<IBindingProvider, DataSourceUpdateInfoCollection> DataSourceUpdateCache { get; }
    public abstract virtual object get_Parent();
    public abstract virtual bool get_Loading();
    public abstract virtual bool get_WasMeasured();
    public abstract virtual ISeriesTemplateContainer get_Diagram();
    public abstract virtual IChartWithDataViewController get_ViewController();
    public abstract virtual Dictionary`2<IBindingProvider, DataSourceUpdateInfoCollection> get_DataSourceUpdateCache();
    public abstract virtual void InvalidateMeasure();
    public abstract virtual void RaiseBoundDataChangedEvent();
}
public interface DevExpress.Charts.Native.IChartWithDataViewController {
    public abstract virtual void BeginUpdateData();
    public abstract virtual void EndUpdateData(bool value);
}
public interface DevExpress.Charts.Native.ICircularDiagram {
    public double StartAngle { get; }
    public CircularDiagramRotationDirectionCore RotationDirection { get; }
    public CircularDiagramShapeStyleCore ShapeStyle { get; }
    public GRealPoint2D AxisCenter { get; }
    public abstract virtual double get_StartAngle();
    public abstract virtual CircularDiagramRotationDirectionCore get_RotationDirection();
    public abstract virtual CircularDiagramShapeStyleCore get_ShapeStyle();
    public abstract virtual GRealPoint2D get_AxisCenter();
}
internal interface DevExpress.Charts.Native.ICollectionUpdateProcessor {
    public bool HasInsertUpdates { get; }
    public bool HasRemoveUpdates { get; }
    public abstract virtual bool get_HasInsertUpdates();
    public abstract virtual bool get_HasRemoveUpdates();
}
public interface DevExpress.Charts.Native.IComparableDataMemberContainer {
    public IComparable ComparableValue { get; }
    public abstract virtual IComparable get_ComparableValue();
}
public interface DevExpress.Charts.Native.IConstantLine {
    public bool Visible { get; }
    public abstract virtual bool get_Visible();
}
public interface DevExpress.Charts.Native.ICoreReference {
}
public interface DevExpress.Charts.Native.ICrosshairAxis {
    public string LabelPattern { get; }
    public bool LabelVisible { get; }
    public abstract virtual string get_LabelPattern();
    public abstract virtual bool get_LabelVisible();
}
public interface DevExpress.Charts.Native.ICrosshairFreePosition {
    public bool IsMousePosition { get; }
    public GRealRect2D DockBounds { get; }
    public DockCornerCore DockCorner { get; }
    public GRealPoint2D Offset { get; }
    public abstract virtual bool get_IsMousePosition();
    public abstract virtual GRealRect2D get_DockBounds();
    public abstract virtual DockCornerCore get_DockCorner();
    public abstract virtual GRealPoint2D get_Offset();
}
public interface DevExpress.Charts.Native.ICrosshairOptions {
    public bool ShowOnlyInFocusedPane { get; }
    public bool ShowArgumentLine { get; }
    public bool ShowValueLine { get; }
    public bool ShowGroupHeaders { get; }
    public bool ShowTail { get; }
    public bool ShowOutOfRangePoints { get; }
    public string GroupHeaderPattern { get; }
    public CrosshairSnapModeCore SnapMode { get; }
    public CrosshairLabelModeCore LabelMode { get; }
    public ICrosshairFreePosition LabelPosition { get; }
    public CrosshairValueSelectionModeCore ValueSelectionMode { get; }
    public CrosshairLinesModeCore LinesMode { get; }
    public abstract virtual bool get_ShowOnlyInFocusedPane();
    public abstract virtual bool get_ShowArgumentLine();
    public abstract virtual bool get_ShowValueLine();
    public abstract virtual bool get_ShowGroupHeaders();
    public abstract virtual bool get_ShowTail();
    public abstract virtual bool get_ShowOutOfRangePoints();
    public abstract virtual string get_GroupHeaderPattern();
    public abstract virtual CrosshairSnapModeCore get_SnapMode();
    public abstract virtual CrosshairLabelModeCore get_LabelMode();
    public abstract virtual ICrosshairFreePosition get_LabelPosition();
    public abstract virtual CrosshairValueSelectionModeCore get_ValueSelectionMode();
    public abstract virtual CrosshairLinesModeCore get_LinesMode();
}
public interface DevExpress.Charts.Native.ICustomAggregateFunction {
    public abstract virtual Double[] Calculate(object nativeArgument, IEnumerable`1<double> values1, IEnumerable`1<double> values2, IEnumerable`1<double> values3, IEnumerable`1<double> values4);
}
public interface DevExpress.Charts.Native.ICustomAxisLabel {
    public bool Visible { get; }
    public bool GridLineVisible { get; }
    public object Content { get; }
    public abstract virtual bool get_Visible();
    public abstract virtual bool get_GridLineVisible();
    public abstract virtual object get_Content();
}
public interface DevExpress.Charts.Native.IDataFilter {
    public bool Required { get; }
    public object Value { get; }
    public string ColumnName { get; }
    public Type DataType { get; }
    public Condition Condition { get; }
    public abstract virtual bool get_Required();
    public abstract virtual object get_Value();
    public abstract virtual string get_ColumnName();
    public abstract virtual Type get_DataType();
    public abstract virtual Condition get_Condition();
    public abstract virtual CriteriaOperator ToCriteriaOperator();
}
public interface DevExpress.Charts.Native.IDataMemberContainer {
    public bool SupportEmptyValue { get; }
    public bool IsEmpty { get; }
    public string DataMember { get; }
    public object BoxedValue { get; }
    public abstract virtual bool get_SupportEmptyValue();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual string get_DataMember();
    public abstract virtual object get_BoxedValue();
    public abstract virtual void Read();
    public abstract virtual bool CreateDataBrowser(BindingEnvironment environment);
}
public interface DevExpress.Charts.Native.IDataMemberContainer`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
public interface DevExpress.Charts.Native.IDataPoint {
    public bool IsEmpty { get; }
    public ISeriesPointArgument ArgumentX { get; }
    public object Argument { get; }
    public double NumericalValue { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual ISeriesPointArgument get_ArgumentX();
    public abstract virtual object get_Argument();
    public abstract virtual double get_NumericalValue();
    public abstract virtual RefinedPoint GetRefinedPoint(IRefinedPointCreator pointCreator, IPointProcessor pointProcessor, List`1<AxisScaleTypeMap> argumentMaps);
    public abstract virtual ISeriesPoint GetSeriesPoint(ISeriesPointCreator pointCreator);
    public abstract virtual void Apply(ISeries series, string toolTipHint);
    public abstract virtual void SetNumericalArgument(double value);
    public abstract virtual void SetDateTimeArgument(DateTime value);
    public abstract virtual void SetTimeSpanArgument(TimeSpan value);
    public abstract virtual void SetQualitativeArgument(string value);
    public abstract virtual void SetNumericalValues(Double[] value);
    public abstract virtual void SetDateTimeValues(DateTime[] value);
    public abstract virtual void SetTimeSpanValues(TimeSpan[] value);
    public abstract virtual void SetTag(object tag);
    public abstract virtual void MakeEmpty();
    public abstract virtual void ClearAnnotations();
    public abstract virtual void UpdateAnnotationRepository();
}
public interface DevExpress.Charts.Native.IDataSourceColorizer {
    public object DataSource { get; }
    public string SeriesKeyMember { get; }
    public string SeriesColorMember { get; }
    public Dictionary`2<object, object> SeriesValueToColorKeyMapping { get; }
    public abstract virtual object get_DataSource();
    public abstract virtual string get_SeriesKeyMember();
    public abstract virtual string get_SeriesColorMember();
    public abstract virtual Dictionary`2<object, object> get_SeriesValueToColorKeyMapping();
    public abstract virtual bool IsColorMappingContainsKey(object key);
    public abstract virtual void AddColorMappingElement(object key, object color);
}
public interface DevExpress.Charts.Native.IDataSourceIndicator {
    public IList`1<string> ValueDataMembers { get; }
    public abstract virtual IList`1<string> get_ValueDataMembers();
    public abstract virtual IIndicatorDataPoint CreatePoint(Double[] values);
}
public interface DevExpress.Charts.Native.IDateTimeOptions {
    public DateTimeOptionsFormat Format { get; }
    public string FormatString { get; }
    public string QuarterFormat { get; }
    public abstract virtual DateTimeOptionsFormat get_Format();
    public abstract virtual string get_FormatString();
    public abstract virtual string get_QuarterFormat();
}
public interface DevExpress.Charts.Native.IDateTimeScaleOptions {
    public DateTimeGridAlignmentNative GridAlignment { get; }
    public IWorkdaysOptions WorkdaysOptions { get; }
    public IWorkTimeRuleCollection WorkTimeRules { get; }
    public bool SkipRangesWithoutPoints { get; }
    public DateTimeMeasureUnitsCalculatorCore Calculator { get; }
    public int MeasureUnitMultiplier { get; }
    public abstract virtual DateTimeGridAlignmentNative get_GridAlignment();
    public abstract virtual IWorkdaysOptions get_WorkdaysOptions();
    public abstract virtual IWorkTimeRuleCollection get_WorkTimeRules();
    public abstract virtual bool get_SkipRangesWithoutPoints();
    public abstract virtual DateTimeMeasureUnitsCalculatorCore get_Calculator();
    public abstract virtual int get_MeasureUnitMultiplier();
    public abstract virtual bool UpdateAutomaticUnits(DateTimeMeasureUnitNative measureUnit, DateTimeGridAlignmentNative gridAlignment, double spacing);
    public abstract virtual void UpdateAutomaticGrid(DateTimeGridAlignmentNative gridAlignment, double gridSpacing);
    public abstract virtual void RaiseScaleChanged();
}
public interface DevExpress.Charts.Native.IDateTimeSummaryOptions {
    public DateTimeMeasureUnitNative MeasureUnit { get; }
    public int MeasureUnitMultiplier { get; }
    public bool UseAxisMeasureUnit { get; }
    public abstract virtual DateTimeMeasureUnitNative get_MeasureUnit();
    public abstract virtual int get_MeasureUnitMultiplier();
    public abstract virtual bool get_UseAxisMeasureUnit();
}
public class DevExpress.Charts.Native.IdentityTransformation : Transformation {
    public bool IsIdentity { get; }
    public virtual bool get_IsIdentity();
    public virtual double TransformForward(double value);
    public virtual double TransformBackward(double value);
}
public interface DevExpress.Charts.Native.IDiagram {
    public GRealRect2D ChartBounds { get; }
    public bool IsThreePlanesDiagram { get; }
    public abstract virtual GRealRect2D get_ChartBounds();
    public abstract virtual bool get_IsThreePlanesDiagram();
}
public interface DevExpress.Charts.Native.IDiagramProvider {
    public IDiagram Diagram { get; }
    public bool IsDiagram3D { get; }
    public Nullable`1<CompatibleViewType> CompatibleViewFormDiagram { get; }
    public abstract virtual IDiagram get_Diagram();
    public abstract virtual bool get_IsDiagram3D();
    public abstract virtual Nullable`1<CompatibleViewType> get_CompatibleViewFormDiagram();
}
public interface DevExpress.Charts.Native.IEmptyPointColorizer {
    public Nullable`1<int> Color { get; }
    public abstract virtual Nullable`1<int> get_Color();
}
public interface DevExpress.Charts.Native.IErrorBarPoint {
    public double HighValue { get; public set; }
    public double LowValue { get; public set; }
    public abstract virtual double get_HighValue();
    public abstract virtual void set_HighValue(double value);
    public abstract virtual double get_LowValue();
    public abstract virtual void set_LowValue(double value);
}
public interface DevExpress.Charts.Native.IFinancialPoint {
    public double Open { get; public set; }
    public double Close { get; public set; }
    public double Low { get; public set; }
    public double High { get; public set; }
    public abstract virtual double get_Open();
    public abstract virtual void set_Open(double value);
    public abstract virtual double get_Close();
    public abstract virtual void set_Close(double value);
    public abstract virtual double get_Low();
    public abstract virtual void set_Low(double value);
    public abstract virtual double get_High();
    public abstract virtual void set_High(double value);
}
public interface DevExpress.Charts.Native.IFinancialSeriesView {
}
public interface DevExpress.Charts.Native.IFullStackedPoint {
    public double NormalizedValue { get; }
    public double TotalValue { get; }
    public abstract virtual double get_NormalizedValue();
    public abstract virtual double get_TotalValue();
}
public interface DevExpress.Charts.Native.IFunnelLabelLayout {
    public bool ResolveOverlapping { get; }
    public bool IsLeftColumn { get; }
    public abstract virtual bool get_ResolveOverlapping();
    public abstract virtual bool get_IsLeftColumn();
}
public interface DevExpress.Charts.Native.IFunnelPoint {
    public double NormalizedValue { get; }
    public abstract virtual double get_NormalizedValue();
}
public interface DevExpress.Charts.Native.IGeometryHolder {
    public abstract virtual GeometryStripCreator CreateStripCreator();
}
public interface DevExpress.Charts.Native.IGeometryStrip {
    public int Count { get; }
    public bool IsEmpty { get; }
    public GeometryStripStyle Style { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual GeometryStripStyle get_Style();
    public abstract virtual void CompleteFilling(IList`1<RefinedPoint> points, IBezierStripSplitter splitter);
}
public interface DevExpress.Charts.Native.IGeometryStripCreator {
    public abstract virtual IGeometryStrip CreateStrip();
}
public interface DevExpress.Charts.Native.IGridLayoutItem {
    public int Row { get; }
    public int Column { get; }
    public int RowSpan { get; }
    public int ColumnSpan { get; }
    public bool VisibleInLayout { get; }
    public abstract virtual int get_Row();
    public abstract virtual int get_Column();
    public abstract virtual int get_RowSpan();
    public abstract virtual int get_ColumnSpan();
    public abstract virtual bool get_VisibleInLayout();
}
public interface DevExpress.Charts.Native.IGridLayoutOptions {
    public IList`1<ILinearLayoutItem> RowDefinitions { get; }
    public IList`1<ILinearLayoutItem> ColumnDefinitions { get; }
    public abstract virtual IList`1<ILinearLayoutItem> get_RowDefinitions();
    public abstract virtual IList`1<ILinearLayoutItem> get_ColumnDefinitions();
}
public interface DevExpress.Charts.Native.IIndicator {
    public string Name { get; }
    public string CrosshairLabelPattern { get; }
    public IndicatorPointToStringConverter IndicatorPointToStringConverter { get; }
    public int StartIndex { get; }
    public IPane Pane { get; }
    public IAxisData AxisXData { get; }
    public IAxisData AxisYData { get; }
    public CrosshairContentShowModeCore CrosshairContentShowMode { get; }
    public bool IsStraightLine { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_CrosshairLabelPattern();
    public abstract virtual IndicatorPointToStringConverter get_IndicatorPointToStringConverter();
    public abstract virtual int get_StartIndex();
    public abstract virtual IPane get_Pane();
    public abstract virtual IAxisData get_AxisXData();
    public abstract virtual IAxisData get_AxisYData();
    public abstract virtual CrosshairContentShowModeCore get_CrosshairContentShowMode();
    public abstract virtual bool get_IsStraightLine();
    public abstract virtual Dictionary`2<IndicatorValueLevelCore, double> GetValuesByIndex(int index, double cursorArgument, double cursorValue);
    public abstract virtual double GetArgumentByIndex(int index, double cursorValue, double cursorArgument);
}
public interface DevExpress.Charts.Native.IIndicatorCalculator {
    public abstract virtual void Invalidate(ICollection`1<RefinedSeries> seriesList);
    public abstract virtual void UpdateSeriesIndicators(RefinedSeries refinedSeries, ICollection`1<RefinedSeriesPointsUpdateInfo> pointsUpdateInfo);
}
public interface DevExpress.Charts.Native.IIndicatorDataPoint {
    public Double[] Values { get; }
    public abstract virtual Double[] get_Values();
}
public interface DevExpress.Charts.Native.IIndicatorValueProvider {
    public abstract virtual double GetValueForIndicator(RefinedPoint point, ValueLevelInternal valueLevel);
}
public interface DevExpress.Charts.Native.IIntervalContainer {
    public IList`1<AxisInterval> Intervals { get; public set; }
    public int IntervalsDistance { get; }
    public abstract virtual IList`1<AxisInterval> get_Intervals();
    public abstract virtual void set_Intervals(IList`1<AxisInterval> value);
    public abstract virtual int get_IntervalsDistance();
}
public interface DevExpress.Charts.Native.IIntervalLayoutKey {
}
public interface DevExpress.Charts.Native.IIntervalLayoutProvider {
    public abstract virtual List`1<IntervalLayout> GetIntervalLayouts(IIntervalLayoutKey intervalLayoutKey);
}
public interface DevExpress.Charts.Native.IIntervalScaleMap {
    public abstract virtual object InternalToNativeInterval(double value);
    public abstract virtual object InternalToNativeValue(double value);
}
public interface DevExpress.Charts.Native.IKnownDate {
    public DateTime Date { get; }
    public abstract virtual DateTime get_Date();
}
public interface DevExpress.Charts.Native.ILabelLayout {
    public bool Visible { get; public set; }
    public DXRectangle LabelBounds { get; public set; }
    public abstract virtual bool get_Visible();
    public abstract virtual void set_Visible(bool value);
    public abstract virtual DXRectangle get_LabelBounds();
    public abstract virtual void set_LabelBounds(DXRectangle value);
}
public interface DevExpress.Charts.Native.ILayoutOptions {
    public LayoutDirectionNative Direction { get; }
    public abstract virtual LayoutDirectionNative get_Direction();
}
public interface DevExpress.Charts.Native.ILegendItem {
    public bool CrosshairLegendTextVisible { get; }
    public abstract virtual bool get_CrosshairLegendTextVisible();
}
public interface DevExpress.Charts.Native.ILinearLayoutItem {
    public bool Fixed { get; }
    public double Weight { get; }
    public int SizeInPixels { get; }
    public abstract virtual bool get_Fixed();
    public abstract virtual double get_Weight();
    public abstract virtual int get_SizeInPixels();
}
public interface DevExpress.Charts.Native.ILogarithmic {
    public bool Enabled { get; }
    public double Base { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual double get_Base();
}
public interface DevExpress.Charts.Native.IMinMaxValues {
    public double Delta { get; }
    public bool IsZeroRange { get; }
    public double Max { get; public set; }
    public double Min { get; public set; }
    public abstract virtual double CalculateCenter();
    public abstract virtual void Intersection(IMinMaxValues minMaxValues);
    public abstract virtual double get_Delta();
    public abstract virtual bool get_IsZeroRange();
    public abstract virtual double get_Max();
    public abstract virtual void set_Max(double value);
    public abstract virtual double get_Min();
    public abstract virtual void set_Min(double value);
}
public class DevExpress.Charts.Native.IndicatorDataPointCore : object {
    private Double[] values;
    public Double[] Values { get; }
    public IndicatorDataPointCore(Double[] values);
    public sealed virtual Double[] get_Values();
}
public class DevExpress.Charts.Native.IndicatorPatternDataProvider : PatternDataProvider {
    protected IIndicator Indicator { get; }
    protected IIndicator get_Indicator();
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public class DevExpress.Charts.Native.IndicatorPointPatternDataProvider : PatternDataProvider {
    private string patternConstant;
    protected CrosshairIndicatorPoint CrosshairIndicatorPoint { get; }
    public IndicatorPointPatternDataProvider(string patternConstant);
    protected CrosshairIndicatorPoint get_CrosshairIndicatorPoint();
    private object GetIndicatorValue();
    private double GetValueByType();
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public class DevExpress.Charts.Native.IndicatorPointToStringConverter : object {
    private static string defaultLegendNumericFormat;
    private static string defaultNumericFormat;
    private ISeries series;
    private bool isTextInLegend;
    private string DefaultNumericFormat { get; }
    private string DefaultLabelPattern { get; }
    protected string DefaultArgumentPart { get; }
    protected string DefaultGroupArgumentPart { get; }
    protected string DefaultValuePart { get; }
    protected string DefaultLegendValuePart { get; }
    public string DefaultLegendPattern { get; }
    public string DefaultGroupPattern { get; }
    public IndicatorPointToStringConverter(ISeries series, bool isTextInLegend);
    private string get_DefaultNumericFormat();
    private string get_DefaultLabelPattern();
    protected virtual string get_DefaultArgumentPart();
    protected virtual string get_DefaultGroupArgumentPart();
    protected virtual string get_DefaultValuePart();
    protected virtual string get_DefaultLegendValuePart();
    public string get_DefaultLegendPattern();
    public string get_DefaultGroupPattern();
    protected string GetDefaultValueFormat();
    public string GetDefaultPattern(bool isInGroup);
}
public class DevExpress.Charts.Native.IndicatorSeriesPatternDataProvider : PatternDataProvider {
    protected ISeries Series { get; }
    protected ISeries get_Series();
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public class DevExpress.Charts.Native.IndicatorUpdateInfo : ChartUpdateInfoBase {
    public IndicatorUpdateInfo(object sender);
}
internal class DevExpress.Charts.Native.IndicatorUpdateProcessor : TypedUpdateProcessor`1<IndicatorUpdateInfo> {
    protected virtual IList`1<IUpdateAction> TypedProcess(IndicatorUpdateInfo updateInfo);
}
public enum DevExpress.Charts.Native.IndicatorValueLevelCore : Enum {
    public int value__;
    public static IndicatorValueLevelCore Value;
    public static IndicatorValueLevelCore Average;
    public static IndicatorValueLevelCore Lower;
    public static IndicatorValueLevelCore Upper;
    public static IndicatorValueLevelCore Top;
    public static IndicatorValueLevelCore Bottom;
    public static IndicatorValueLevelCore Signal;
}
public class DevExpress.Charts.Native.IndicatorValueProvider : object {
    private sealed virtual override double DevExpress.Charts.Native.IIndicatorValueProvider.GetValueForIndicator(RefinedPoint point, ValueLevelInternal valueLevel);
}
public class DevExpress.Charts.Native.IndicatorWaterfallValueProvider : object {
    private sealed virtual override double DevExpress.Charts.Native.IIndicatorValueProvider.GetValueForIndicator(RefinedPoint point, ValueLevelInternal valueLevel);
}
public interface DevExpress.Charts.Native.INestedDoughnutRefinedSeries {
    public double StartOffset { get; }
    public double StartOffsetInPixels { get; }
    public double HoleRadius { get; }
    public double TotalGroupIndentInPixels { get; }
    public double NormalizedWeight { get; }
    public double ExplodedFactor { get; }
    public bool IsExploded { get; }
    public abstract virtual double get_StartOffset();
    public abstract virtual double get_StartOffsetInPixels();
    public abstract virtual double get_HoleRadius();
    public abstract virtual double get_TotalGroupIndentInPixels();
    public abstract virtual double get_NormalizedWeight();
    public abstract virtual double get_ExplodedFactor();
    public abstract virtual bool get_IsExploded();
}
public interface DevExpress.Charts.Native.INestedDoughnutSeriesView {
    public double HoleRadiusPercent { get; }
    public double Weight { get; }
    public double InnerIndent { get; }
    public Nullable`1<bool> IsOutside { get; public set; }
    public abstract virtual double get_HoleRadiusPercent();
    public abstract virtual double get_Weight();
    public abstract virtual double get_InnerIndent();
    public abstract virtual Nullable`1<bool> get_IsOutside();
    public abstract virtual void set_IsOutside(Nullable`1<bool> value);
    public abstract virtual bool HasExplodedPoints(IRefinedSeries refinedSeries);
    public abstract virtual double GetExplodedDistancePercentage(IRefinedSeries refinedSeries);
}
public class DevExpress.Charts.Native.InteractionComparerByArgument : Comparer`1<IPointInteraction> {
    public virtual int Compare(IPointInteraction interaction1, IPointInteraction interaction2);
}
public class DevExpress.Charts.Native.InteractionComparerByMaxValue : Comparer`1<IPointInteraction> {
    private ISeriesView seriesView;
    public InteractionComparerByMaxValue(ISeriesView seriesView);
    public virtual int Compare(IPointInteraction interaction1, IPointInteraction interaction2);
}
public class DevExpress.Charts.Native.InteractionComparerByMinAbsValue : Comparer`1<IPointInteraction> {
    private ISeriesView seriesView;
    public InteractionComparerByMinAbsValue(ISeriesView seriesView);
    public virtual int Compare(IPointInteraction interaction1, IPointInteraction interaction2);
}
public class DevExpress.Charts.Native.InteractionComparerByMinValue : Comparer`1<IPointInteraction> {
    private ISeriesView seriesView;
    public InteractionComparerByMinValue(ISeriesView seriesView);
    public virtual int Compare(IPointInteraction interaction1, IPointInteraction interaction2);
}
internal class DevExpress.Charts.Native.InteractionExecutor : object {
    private SeriesController seriesController;
    public InteractionExecutor(SeriesController seriesController);
    private void UpdateSeriesGroupsInteraction();
    private void ApplySeriesInteractionData();
    private void UpdateIndicators(bool shouldUpdateIndicators, ICollection`1<RefinedSeriesUpdateInfo> updatesSeriesInfo, ICollection`1<RefinedSeriesPointsUpdateInfo> updatedPointsInfo);
    public sealed virtual SeriesControllerChanges Execute(IExecutorContext context);
}
public class DevExpress.Charts.Native.InteractionKey : ValueType {
    private Type seriesViewType;
    private IPane pane;
    private IAxisData axisX;
    private IAxisData axisY;
    private object userKey;
    public object UserKey { get; }
    public InteractionKey(ISeriesView view, bool isSideBySideInteraction);
    public static bool op_Equality(InteractionKey a, InteractionKey b);
    public static bool op_Inequality(InteractionKey a, InteractionKey b);
    public object get_UserKey();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InteractionKey key);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.InterimValueCalculator : object {
    public static Nullable`1<double> Calculate(double value, IAxisData axis, DXRectangle mappingBounds, List`1<AxisIntervalLayout> intervalsLayout, Boolean& outOfRange);
    private static Nullable`1<double> GetCoord(double value, IAxisData axis, List`1<AxisIntervalLayout> intervalsLayout);
}
public class DevExpress.Charts.Native.InterlacedData : ValueType {
    private double near;
    private double far;
    public double Near { get; }
    public double Far { get; }
    public InterlacedData(double near, double far);
    public double get_Near();
    public double get_Far();
}
public class DevExpress.Charts.Native.InternalCoordinates : object {
    private IPane pane;
    private List`1<AxisValuePair> axesXValues;
    private List`1<AxisValuePair> axesYValues;
    public List`1<AxisValuePair> AxesXValues { get; }
    public List`1<AxisValuePair> AxesYValues { get; }
    public InternalCoordinates(IPane pane);
    public List`1<AxisValuePair> get_AxesXValues();
    public List`1<AxisValuePair> get_AxesYValues();
    private double GetValueByAxis(IAxisData axis, List`1<AxisValuePair> axesValues);
    public void AddAxisXValue(IAxisData axis, double argument);
    public void AddAxisYValue(IAxisData axis, double value);
    public double GetValueByAxisY(IAxisData axis);
    public double GetArgumentByAxisX(IAxisData axis);
}
public class DevExpress.Charts.Native.InternalRange : object {
    private MinMaxValues values;
    private MinMaxValues sideMargins;
    private MinMaxValues sideMarginsValue;
    public double Delta { get; }
    public MinMaxValues SideMarginsValue { get; }
    public MinMaxValues Values { get; }
    public MinMaxValues SideMargins { get; }
    public InternalRange(MinMaxValues values, MinMaxValues sideMarginsValue);
    public InternalRange(MinMaxValues values, MinMaxValues sideMargins, MinMaxValues sideMarginsValue);
    public double get_Delta();
    public MinMaxValues get_SideMarginsValue();
    public MinMaxValues get_Values();
    public MinMaxValues get_SideMargins();
}
public class DevExpress.Charts.Native.IntersectionInfo : ValueType {
    private Nullable`1<GRealPoint2D> intersectionPoint;
    private SegmentKind segmentKind;
    public bool HasIntersection { get; }
    public GRealPoint2D IntersectionPoint { get; public set; }
    public SegmentKind SegmentKind { get; public set; }
    public IntersectionInfo(GRealPoint2D intersectionPoint, SegmentKind segmentKind);
    public bool get_HasIntersection();
    public GRealPoint2D get_IntersectionPoint();
    public void set_IntersectionPoint(GRealPoint2D value);
    public SegmentKind get_SegmentKind();
    public void set_SegmentKind(SegmentKind value);
}
public class DevExpress.Charts.Native.Interval : ValueType {
    private double start;
    private double end;
    private double length;
    public double End { get; }
    public double Length { get; }
    public double Start { get; }
    public Interval(double start, double end);
    public static MinMaxValues op_Subtraction(Interval x, Interval y);
    public static bool op_Inequality(Interval x, Interval y);
    public static Interval op_BitwiseAnd(Interval x, Interval y);
    public static Interval op_BitwiseOr(Interval x, Interval y);
    public static bool op_Equality(Interval x, Interval y);
    public double get_End();
    public double get_Length();
    public double get_Start();
    public bool Contains(double value);
    public double DistanceFrom(double value);
    public sealed virtual bool Equals(Interval other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.IntervalData : object {
    private int endIntervalDataIndex;
    private ResamplerData resamplerData;
    [CompilerGeneratedAttribute]
private IComparable <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IntervalManagerIndex>k__BackingField;
    public IComparable Argument { get; public set; }
    public int EndIntervalDataIndex { get; public set; }
    public int IntervalManagerIndex { get; public set; }
    public ResamplerData ResamplerData { get; public set; }
    public IntervalData(int dataSourceIndex, IComparable startIntervalArgument, ResamplerData rdata, int intervalManagerIndex);
    [CompilerGeneratedAttribute]
public IComparable get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(IComparable value);
    public int get_EndIntervalDataIndex();
    public void set_EndIntervalDataIndex(int value);
    [CompilerGeneratedAttribute]
public int get_IntervalManagerIndex();
    [CompilerGeneratedAttribute]
public void set_IntervalManagerIndex(int value);
    public ResamplerData get_ResamplerData();
    public void set_ResamplerData(ResamplerData value);
}
public enum DevExpress.Charts.Native.IntervalDivisionModeNative : Enum {
    public int value__;
    public static IntervalDivisionModeNative Auto;
    public static IntervalDivisionModeNative Width;
    public static IntervalDivisionModeNative Count;
}
public class DevExpress.Charts.Native.IntervalLayout : object {
    private AxisInterval interval;
    private Interval bounds;
    public AxisInterval Interval { get; }
    public Interval Bounds { get; }
    public IntervalLayout(AxisInterval interval, Interval bounds);
    public AxisInterval get_Interval();
    public Interval get_Bounds();
}
public class DevExpress.Charts.Native.IntervalManager : object {
    public static int DefaultCapacity;
    private List`1<IntervalData> intervals;
    [CompilerGeneratedAttribute]
private IntervalManagerArgumentComparer <ArgumentComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private IntervalManagerIndexComparer <IndexComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private IMinMaxValues <WholeRange>k__BackingField;
    public IntervalManagerArgumentComparer ArgumentComparer { get; public set; }
    public IntervalManagerIndexComparer IndexComparer { get; public set; }
    public IList`1<IntervalData> Intervals { get; }
    public IMinMaxValues WholeRange { get; public set; }
    [CompilerGeneratedAttribute]
public IntervalManagerArgumentComparer get_ArgumentComparer();
    [CompilerGeneratedAttribute]
public void set_ArgumentComparer(IntervalManagerArgumentComparer value);
    [CompilerGeneratedAttribute]
public IntervalManagerIndexComparer get_IndexComparer();
    [CompilerGeneratedAttribute]
public void set_IndexComparer(IntervalManagerIndexComparer value);
    public IList`1<IntervalData> get_Intervals();
    [CompilerGeneratedAttribute]
public IMinMaxValues get_WholeRange();
    [CompilerGeneratedAttribute]
public void set_WholeRange(IMinMaxValues value);
    private void InvalidateIntervals(int startIndex, int endIndex, int count, bool shouldReset);
    private void InvalidateInterval(IntervalData interval, int count, bool shouldReset);
    private void CalculateVisibleIndexes(int rowCount, double minValue, double maxValue, Int32& startVisibleIndex, Int32& endVisibleIndex);
    public int GuessStepByIntervalData();
    public bool Invalidate(DataSourceUpdateInfoBase`1<IBindingProvider> update);
    public void Populate(ResamplerData data);
    public void Add(int startDatasourceIndex, double startIntervalArgument, ResamplerData point);
    public int CalculateVisibleIndexesWithOffset(ResamplerData resampledData, int rowCount, Int32& startVisibleIndex, Int32& endVisibleIndex);
    public int CalculatePointCount(ResamplerData resampledData, int rowCount);
    public IntervalData GetIntervalByDatasourceIndex(int index);
    public IntervalData GetNearest(IComparable value);
}
public class DevExpress.Charts.Native.IntervalMappingCore : AxisMappingCore {
    private IntervalLayout intervalLayout;
    public IntervalMappingCore(IAxisData axis, double length, IntervalLayout intervalLayout);
    protected virtual IntervalLayout GetIntervalLayout(double value, bool exactLayout);
    protected virtual IntervalLayout GetIntervalLayoutByCoordinate(double coordinate);
}
public interface DevExpress.Charts.Native.INumericOptions {
    public NumericOptionsFormat Format { get; }
    public int Precision { get; }
    public abstract virtual NumericOptionsFormat get_Format();
    public abstract virtual int get_Precision();
}
public interface DevExpress.Charts.Native.INumericScaleOptions {
    public double GridAlignment { get; }
    public NumericStartPointCore GridAlignmentStartPoint { get; }
    public abstract virtual double get_GridAlignment();
    public abstract virtual NumericStartPointCore get_GridAlignmentStartPoint();
    public abstract virtual bool UpdateAutomaticUnits(double measureUnit);
    public abstract virtual void RaiseScaleChanged();
}
public interface DevExpress.Charts.Native.INumericSummaryOptions {
    public double MeasureUnit { get; }
    public bool UseAxisMeasureUnit { get; }
    public abstract virtual double get_MeasureUnit();
    public abstract virtual bool get_UseAxisMeasureUnit();
}
public interface DevExpress.Charts.Native.IOutliersDataMemberContainer`1 {
    public IList`1<T> Values { get; }
    public abstract virtual IList`1<T> get_Values();
}
public interface DevExpress.Charts.Native.IPane {
    public int PaneIndex { get; }
    public Nullable`1<GRealRect2D> MappingBounds { get; }
    public abstract virtual int get_PaneIndex();
    public abstract virtual Nullable`1<GRealRect2D> get_MappingBounds();
}
public interface DevExpress.Charts.Native.IPaneAxesContainer {
}
public interface DevExpress.Charts.Native.IPatternHolder {
    public abstract virtual PatternDataProvider GetDataProvider(string patternConstant);
}
public interface DevExpress.Charts.Native.IPatternValuesSource {
    public object Argument { get; }
    public object Value { get; }
    public double PercentValue { get; }
    public string Series { get; }
    public object SeriesGroup { get; }
    public object Value1 { get; }
    public object Value2 { get; }
    public object ValueDuration { get; }
    public double HighValue { get; }
    public double LowValue { get; }
    public double OpenValue { get; }
    public double CloseValue { get; }
    public object PointHint { get; }
    public double Weight { get; }
    public double TotalValue { get; }
    public object IntervalArgumentMin { get; }
    public object IntervalArgumentMax { get; }
    public string OpeningBracket { get; }
    public string ClosingBracket { get; }
    public string UnderflowSymbol { get; }
    public string OverflowSymbol { get; }
    public abstract virtual object get_Argument();
    public abstract virtual object get_Value();
    public abstract virtual double get_PercentValue();
    public abstract virtual string get_Series();
    public abstract virtual object get_SeriesGroup();
    public abstract virtual object get_Value1();
    public abstract virtual object get_Value2();
    public abstract virtual object get_ValueDuration();
    public abstract virtual double get_HighValue();
    public abstract virtual double get_LowValue();
    public abstract virtual double get_OpenValue();
    public abstract virtual double get_CloseValue();
    public abstract virtual object get_PointHint();
    public abstract virtual double get_Weight();
    public abstract virtual double get_TotalValue();
    public abstract virtual object get_IntervalArgumentMin();
    public abstract virtual object get_IntervalArgumentMax();
    public abstract virtual string get_OpeningBracket();
    public abstract virtual string get_ClosingBracket();
    public abstract virtual string get_UnderflowSymbol();
    public abstract virtual string get_OverflowSymbol();
}
public interface DevExpress.Charts.Native.IPieLabelLayout {
    public double Angle { get; }
    public bool ResolveOverlapping { get; }
    public abstract virtual double get_Angle();
    public abstract virtual bool get_ResolveOverlapping();
}
public interface DevExpress.Charts.Native.IPiePoint {
    public double NormalizedValue { get; }
    public double TotalValue { get; }
    public bool IsMaxPoint { get; }
    public bool IsMinPoint { get; }
    public abstract virtual double get_NormalizedValue();
    public abstract virtual double get_TotalValue();
    public abstract virtual bool get_IsMaxPoint();
    public abstract virtual bool get_IsMinPoint();
}
public interface DevExpress.Charts.Native.IPointInteraction {
    public int Count { get; }
    public double ArgumentX { get; }
    public double ArgumentY { get; }
    public bool IsEmpty { get; }
    public abstract virtual int get_Count();
    public abstract virtual double get_ArgumentX();
    public abstract virtual double get_ArgumentY();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual double GetMinValue(ISeriesView seriesView);
    public abstract virtual double GetMaxValue(ISeriesView seriesView);
    public abstract virtual double GetMinAbsValue(ISeriesView seriesView);
}
public interface DevExpress.Charts.Native.IPointProcessor {
    public abstract virtual void ProcessPoint(RefinedPoint point, IList`1<AxisScaleTypeMap> argumentMaps, AxisScaleTypeMap valueMap, bool isEmpty);
    public abstract virtual void UpdatePointInternalArguments(RefinedPoint point, IList`1<AxisScaleTypeMap> argumentMaps);
    public abstract virtual void ProcessPointValues(RefinedPoint point, AxisScaleTypeMap valueMap, bool isEmpty);
}
public interface DevExpress.Charts.Native.IPointProcessorProvider {
    public IPointProcessor Processor { get; }
    public abstract virtual IPointProcessor get_Processor();
}
public interface DevExpress.Charts.Native.IPointSegmentColorizer {
    public abstract virtual Nullable`1<int> GetColor(IList`1<RefinedPoint> points, int index);
}
public interface DevExpress.Charts.Native.IPointsFilterOptions {
    public bool Enable { get; }
    public PointsFilterType FilterType { get; }
    public double ThresholdValue { get; }
    public bool ShowOthers { get; }
    public string OthersArgument { get; }
    public abstract virtual bool get_Enable();
    public abstract virtual PointsFilterType get_FilterType();
    public abstract virtual double get_ThresholdValue();
    public abstract virtual bool get_ShowOthers();
    public abstract virtual string get_OthersArgument();
}
public interface DevExpress.Charts.Native.IPriorScaleMap {
    public abstract virtual double NativeToInternal(object value);
    public abstract virtual object InternalToNative(double value);
    public abstract virtual void UpdateMin(double min);
}
public interface DevExpress.Charts.Native.IRangePoint {
    public double Value1 { get; public set; }
    public double Value2 { get; public set; }
    public double Min { get; }
    public double Max { get; }
    public abstract virtual double get_Value1();
    public abstract virtual void set_Value1(double value);
    public abstract virtual double get_Value2();
    public abstract virtual void set_Value2(double value);
    public abstract virtual double get_Min();
    public abstract virtual double get_Max();
}
public interface DevExpress.Charts.Native.IRangeSegmentColorizer {
    public IList`1<double> RangeStops { get; }
    public abstract virtual IList`1<double> get_RangeStops();
    public abstract virtual Nullable`1<int> GetColor(double value);
    public abstract virtual int GetRangeIndex(double value);
}
public interface DevExpress.Charts.Native.IRangeSeriesView {
}
public interface DevExpress.Charts.Native.IRefinedPointCreator {
    public abstract virtual RefinedPoint CreateRefinedPoint(IPointProcessor processor, ISeriesPoint seriesPoint, List`1<AxisScaleTypeMap> argumentMaps);
}
public interface DevExpress.Charts.Native.IRefinedSeries {
    public ISeries Series { get; }
    public ISeriesView SeriesView { get; }
    public IList`1<RefinedPoint> Points { get; }
    public ActualScaleTypeCore ArgumentScaleType { get; }
    public ActualScaleTypeCore ValueScaleType { get; }
    public bool IsPointsAutoGenerated { get; }
    public bool IsActive { get; }
    public abstract virtual ISeries get_Series();
    public abstract virtual ISeriesView get_SeriesView();
    public abstract virtual IList`1<RefinedPoint> get_Points();
    public abstract virtual ActualScaleTypeCore get_ArgumentScaleType();
    public abstract virtual ActualScaleTypeCore get_ValueScaleType();
    public abstract virtual bool get_IsPointsAutoGenerated();
    public abstract virtual bool get_IsActive();
    public abstract virtual int GetMinVisiblePointIndex(bool onlyByArgument);
    public abstract virtual int GetMaxVisiblePointIndex(bool onlyByArgument);
    public abstract virtual double GetMinArgument(AxisScaleTypeMap scaleMap);
    public abstract virtual double GetMaxArgument(AxisScaleTypeMap scaleMap);
    public abstract virtual RefinedPoint GetMinPoint(double argument);
    public abstract virtual RefinedPoint GetMaxPoint(double argument);
    public abstract virtual RefinedPoint GetRefinedPoint(IScaleMap scaleMap, ISeriesPoint seriesPoint);
    public abstract virtual List`1<RefinedPoint> FindFinalPointsWithNearestArgument(double argument);
    public abstract virtual List`1<RefinedPoint> FindAllPointsWithSameArgument(RefinedPoint refinedPoint);
    public abstract virtual IList`1<RefinedPoint> GetContinuesDrawingPoints();
    public abstract virtual IList`1<RefinedPoint> GetDrawingPoints();
    public abstract virtual RefinedPoint GetCorrectRefinedPointForLabel(RefinedPoint refinedPoint, List`1<GRealPoint2D> interPoints);
}
public interface DevExpress.Charts.Native.IRefinedSeriesContainer {
    public bool IsContainsProcessedPoints { get; }
    public bool IsDesignMode { get; }
    public abstract virtual bool get_IsContainsProcessedPoints();
    public abstract virtual bool get_IsDesignMode();
    public abstract virtual MinMaxValues GetValuesRange(RefinedSeries series);
}
public interface DevExpress.Charts.Native.IRefinedSeriesFactory {
    public abstract virtual RefinedSeries Create(ISeries series, IRefinedSeriesContainer seriesContainer);
}
public interface DevExpress.Charts.Native.IResamplingSupportSeries {
    public Nullable`1<int> MaximumPointCount { get; }
    public ResamplerData ResamplerData { get; public set; }
    public bool AllowResample { get; }
    public bool Require2dResampling { get; }
    public abstract virtual Nullable`1<int> get_MaximumPointCount();
    public abstract virtual ResamplerData get_ResamplerData();
    public abstract virtual void set_ResamplerData(ResamplerData value);
    public abstract virtual bool get_AllowResample();
    public abstract virtual bool get_Require2dResampling();
    public abstract virtual RefinedSeries GetRefinedSeries();
    public abstract virtual void UpdateVisibleFromDataSource(RefinedSeries refinedSeries);
    public abstract virtual void Invoke(Action action);
    public abstract virtual void ForceInitialize();
}
public interface DevExpress.Charts.Native.IResolveLabelsOverlappingAxis {
    public AxisLabelResolveOverlappingCache OverlappingCache { get; public set; }
    public abstract virtual AxisLabelResolveOverlappingCache get_OverlappingCache();
    public abstract virtual void set_OverlappingCache(AxisLabelResolveOverlappingCache value);
}
public interface DevExpress.Charts.Native.IRowData {
    public bool IsEmpty { get; }
    public List`1<IDataMemberContainer> DataMemberContainers { get; }
    public Dictionary`2<string, IDataMemberContainer> AdditionalContainers { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual List`1<IDataMemberContainer> get_DataMemberContainers();
    public abstract virtual Dictionary`2<string, IDataMemberContainer> get_AdditionalContainers();
}
public interface DevExpress.Charts.Native.IScaleBreak {
    public IAxisValueContainer Edge1 { get; }
    public IAxisValueContainer Edge2 { get; }
    public bool Visible { get; }
    public abstract virtual IAxisValueContainer get_Edge1();
    public abstract virtual IAxisValueContainer get_Edge2();
    public abstract virtual bool get_Visible();
}
public interface DevExpress.Charts.Native.IScaleBreakOptions {
    public ScaleBreakStyleCore Style { get; }
    public abstract virtual ScaleBreakStyleCore get_Style();
}
public interface DevExpress.Charts.Native.IScaleDiapason {
    public bool Visible { get; }
    public double Edge1 { get; }
    public double Edge2 { get; }
    public abstract virtual bool get_Visible();
    public abstract virtual double get_Edge1();
    public abstract virtual double get_Edge2();
}
public interface DevExpress.Charts.Native.IScaleMap {
    public Transformation Transformation { get; }
    public abstract virtual Transformation get_Transformation();
    public abstract virtual double NativeToInternal(object value);
    public abstract virtual double NativeToRefined(object value);
    public abstract virtual object InternalToNative(double value);
    public abstract virtual double InternalToRefined(double value);
    public abstract virtual double RefinedToInternal(double value);
    public abstract virtual bool IsCompatible(object value);
}
public interface DevExpress.Charts.Native.IScaleOptionsBase {
    public bool GridSpacingAuto { get; }
    public double GridSpacing { get; public set; }
    public double GridOffset { get; }
    public GridLayoutModeNative GridLayoutMode { get; }
    public ScaleModeNative ScaleMode { get; }
    public AggregateFunctionNative AggregateFunction { get; }
    public ProcessMissingPointsModeNative ProcessMissingPoints { get; }
    public ICustomAggregateFunction CustomAggregateFunction { get; }
    public abstract virtual bool get_GridSpacingAuto();
    public abstract virtual double get_GridSpacing();
    public abstract virtual void set_GridSpacing(double value);
    public abstract virtual double get_GridOffset();
    public abstract virtual GridLayoutModeNative get_GridLayoutMode();
    public abstract virtual ScaleModeNative get_ScaleMode();
    public abstract virtual AggregateFunctionNative get_AggregateFunction();
    public abstract virtual ProcessMissingPointsModeNative get_ProcessMissingPoints();
    public abstract virtual ICustomAggregateFunction get_CustomAggregateFunction();
}
public interface DevExpress.Charts.Native.IScaleOptionsBase`1 {
    public bool UseCustomMeasureUnit { get; }
    public TMeasureUnit MeasureUnit { get; }
    public AggregationIntervalsInfo AggregationIntervalsInfo { get; public set; }
    public string IntervalPattern { get; }
    public string UnderflowPattern { get; }
    public string OverflowPattern { get; }
    public Nullable`1<double> UnderflowValue { get; }
    public Nullable`1<double> OverflowValue { get; }
    public abstract virtual bool get_UseCustomMeasureUnit();
    public abstract virtual TMeasureUnit get_MeasureUnit();
    public abstract virtual AggregationIntervalsInfo get_AggregationIntervalsInfo();
    public abstract virtual void set_AggregationIntervalsInfo(AggregationIntervalsInfo value);
    public abstract virtual string get_IntervalPattern();
    public abstract virtual string get_UnderflowPattern();
    public abstract virtual string get_OverflowPattern();
    public abstract virtual Nullable`1<double> get_UnderflowValue();
    public abstract virtual Nullable`1<double> get_OverflowValue();
    public abstract virtual TMeasureUnit CalculateCustomMeasureUnit(IEnumerable`1<ISeries> series, double axisLength, int pixelsPerUnit, double visualMin, double visualMax, double wholeMin, double wholeMax);
}
public interface DevExpress.Charts.Native.IScaleOptionsDivisionModeSupport`1 {
    public IntervalDivisionModeNative DivisionMode { get; }
    public Nullable`1<double> IntervalWidth { get; }
    public Nullable`1<int> IntervalCount { get; }
    public abstract virtual IntervalDivisionModeNative get_DivisionMode();
    public abstract virtual Nullable`1<double> get_IntervalWidth();
    public abstract virtual Nullable`1<int> get_IntervalCount();
}
public interface DevExpress.Charts.Native.ISeparatePaneIndicator {
    public IPane Pane { get; }
    public abstract virtual IPane get_Pane();
}
public interface DevExpress.Charts.Native.ISeries {
    public string Name { get; }
    public object Tag { get; }
    public IList`1<IDataPoint> ActualPoints { get; }
    public bool ArePointsSorted { get; }
    public bool DataSourceSorted { get; }
    public bool Visible { get; }
    public bool LabelsVisibility { get; }
    public bool ShouldBeDrawnOnDiagram { get; }
    public SortMode SeriesPointsSortingMode { get; }
    public SeriesPointKeyNative SeriesPointsSortingKey { get; }
    public abstract virtual string get_Name();
    public abstract virtual object get_Tag();
    public abstract virtual IList`1<IDataPoint> get_ActualPoints();
    public abstract virtual bool get_ArePointsSorted();
    public abstract virtual bool get_DataSourceSorted();
    public abstract virtual bool get_Visible();
    public abstract virtual bool get_LabelsVisibility();
    public abstract virtual bool get_ShouldBeDrawnOnDiagram();
    public abstract virtual SortMode get_SeriesPointsSortingMode();
    public abstract virtual SeriesPointKeyNative get_SeriesPointsSortingKey();
    public abstract virtual void SetArgumentScaleType(Scale scaleType, AxisGroup axisGroup);
    public abstract virtual void AddSeriesPoint(IDataPoint point);
    public abstract virtual void PointsRemoved(RefinedPoint[] points);
    public abstract virtual void ResetDataSourceArgumentScaleType();
}
public interface DevExpress.Charts.Native.ISeriesBase {
    public bool IsTwoArgumentsSeries { get; }
    public bool ProcessMissingArguments { get; }
    public bool ProcessMissingValues { get; }
    public Scale ArgumentScaleType { get; }
    public Scale UserArgumentScaleType { get; }
    public Scale ActualUserArgumentScaleType { get; }
    public Scale ArgumentScaleType2 { get; }
    public Scale UserArgumentScaleType2 { get; }
    public Scale ValueScaleType { get; }
    public ISeriesView SeriesView { get; }
    public IList`1<IDataSourceIndicator> Indicators { get; }
    public abstract virtual bool get_IsTwoArgumentsSeries();
    public abstract virtual bool get_ProcessMissingArguments();
    public abstract virtual bool get_ProcessMissingValues();
    public abstract virtual Scale get_ArgumentScaleType();
    public abstract virtual Scale get_UserArgumentScaleType();
    public abstract virtual Scale get_ActualUserArgumentScaleType();
    public abstract virtual Scale get_ArgumentScaleType2();
    public abstract virtual Scale get_UserArgumentScaleType2();
    public abstract virtual Scale get_ValueScaleType();
    public abstract virtual ISeriesView get_SeriesView();
    public abstract virtual IList`1<IDataSourceIndicator> get_Indicators();
}
public interface DevExpress.Charts.Native.ISeriesBindingProvider {
    public bool IsUseDataFilters { get; }
    public ISeries Series { get; }
    public abstract virtual void BindingClear(bool clearBoundPoints);
    public abstract virtual bool get_IsUseDataFilters();
    public abstract virtual ISeries get_Series();
}
public interface DevExpress.Charts.Native.ISeriesDataAdapter {
    public object DataSource { get; }
    public string DataMember { get; }
    public string ToolTipHintDataMember { get; }
    public string ColorDataMember { get; }
    public string ArgumentDataMember { get; }
    public string ArgumentDataMember2 { get; }
    public CriteriaOperator Criteria { get; }
    public SeriesFilterHelper FilterHelper { get; }
    public DataContextBase DataContext { get; }
    public IEnumerable`1<ICalculatedField> CalculatedFields { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ArgumentScaleType2 { get; }
    public Scale ValueScaleType { get; }
    public abstract virtual object get_DataSource();
    public abstract virtual string get_DataMember();
    public abstract virtual string get_ToolTipHintDataMember();
    public abstract virtual string get_ColorDataMember();
    public abstract virtual string get_ArgumentDataMember();
    public abstract virtual string get_ArgumentDataMember2();
    public abstract virtual CriteriaOperator get_Criteria();
    public abstract virtual SeriesFilterHelper get_FilterHelper();
    public abstract virtual DataContextBase get_DataContext();
    public abstract virtual IEnumerable`1<ICalculatedField> get_CalculatedFields();
    public abstract virtual Scale get_ArgumentScaleType();
    public abstract virtual Scale get_ArgumentScaleType2();
    public abstract virtual Scale get_ValueScaleType();
    public abstract virtual IList`1<string> GetSeriesValueDataMembers();
}
public interface DevExpress.Charts.Native.ISeriesFactory {
    public string SeriesNameBeginText { get; }
    public string SeriesNameEndText { get; }
    public ISeriesBase SeriesTemplate { get; }
    public abstract virtual string get_SeriesNameBeginText();
    public abstract virtual string get_SeriesNameEndText();
    public abstract virtual ISeriesBase get_SeriesTemplate();
    public abstract virtual ISeries CreateSeriesForBinding(string seriesName, object seriesValue, ISeries existing);
}
public interface DevExpress.Charts.Native.ISeriesPoint {
    public ISeries Owner { get; }
    public ISeriesPointArgument ArgumentX { get; }
    public ISeriesPointArgument ArgumentY { get; }
    public ISeriesPointValues Values { get; }
    public object ToolTipHint { get; public set; }
    public IIndicatorDataPoint IndicatorPoint { get; }
    public DataContextBase DataContext { get; }
    public object Tag { get; }
    public Nullable`1<int> ColorCore { get; }
    public abstract virtual ISeries get_Owner();
    public abstract virtual ISeriesPointArgument get_ArgumentX();
    public abstract virtual ISeriesPointArgument get_ArgumentY();
    public abstract virtual ISeriesPointValues get_Values();
    public abstract virtual object get_ToolTipHint();
    public abstract virtual void set_ToolTipHint(object value);
    public abstract virtual IIndicatorDataPoint get_IndicatorPoint();
    public abstract virtual DataContextBase get_DataContext();
    public abstract virtual object get_Tag();
    public abstract virtual Nullable`1<int> get_ColorCore();
    public abstract virtual bool IsEmpty(Scale scale);
    public abstract virtual bool IsSamePoints(ISeriesPoint seriesPoint);
    public abstract virtual void SetOwner(ISeries series);
    public abstract virtual void ClearAnnotations();
    public abstract virtual void UpdateAnnotationRepository();
}
public interface DevExpress.Charts.Native.ISeriesPointArgument {
    public Scale ArgumentScaleType { get; }
    public object UserArgument { get; }
    public string QualitativeArgument { get; }
    public double NumericalArgument { get; }
    public DateTime DateTimeArgument { get; }
    public TimeSpan TimeSpanArgument { get; }
    public abstract virtual Scale get_ArgumentScaleType();
    public abstract virtual object get_UserArgument();
    public abstract virtual string get_QualitativeArgument();
    public abstract virtual double get_NumericalArgument();
    public abstract virtual DateTime get_DateTimeArgument();
    public abstract virtual TimeSpan get_TimeSpanArgument();
}
public interface DevExpress.Charts.Native.ISeriesPointCreator {
    public abstract virtual ISeriesPoint CreateSeriesPoint(RefinedPoint point);
}
public interface DevExpress.Charts.Native.ISeriesPointEnsurer {
    public abstract virtual ISeriesPoint Ensure(RefinedPoint refinedPoint);
}
public interface DevExpress.Charts.Native.ISeriesPointFactory {
    public ISeriesDataAdapter DataAdapter { get; }
    public abstract virtual ISeriesDataAdapter get_DataAdapter();
    public abstract virtual SeriesPointDataContainer CreateTemplateContainer();
    public abstract virtual ISeriesPoint CreateSeriesPoint(ISeries owner, object argument);
    public abstract virtual IDataPoint CreateSeriesPoint(ISeries owner, object tag, SeriesPointDataContainer templateContainer, IRowData rowData);
    public abstract virtual IDataPoint CreateSeriesPoint(ISeries owner, object argument, Object[] values, object tag, Object[] colors);
}
public interface DevExpress.Charts.Native.ISeriesPointValues {
    public Scale ValueScaleType { get; }
    public int Dimension { get; }
    public Double[] NumericalValues { get; }
    public DateTime[] DateTimeValues { get; }
    public TimeSpan[] TimeSpanValues { get; }
    public abstract virtual Scale get_ValueScaleType();
    public abstract virtual int get_Dimension();
    public abstract virtual Double[] get_NumericalValues();
    public abstract virtual DateTime[] get_DateTimeValues();
    public abstract virtual TimeSpan[] get_TimeSpanValues();
}
public interface DevExpress.Charts.Native.ISeriesTemplate {
    public abstract virtual void ResetDataSourceScale();
    public abstract virtual void UpdateDataFilters();
}
public interface DevExpress.Charts.Native.ISeriesTemplateContainer {
    public ISeriesTemplate SeriesTemplate { get; }
    public abstract virtual void OnDataWasChanged();
    public abstract virtual ISeriesTemplate get_SeriesTemplate();
}
internal interface DevExpress.Charts.Native.ISeriesUpdateAction {
    public ISeriesBase Series { get; }
    public abstract virtual ISeriesBase get_Series();
}
public interface DevExpress.Charts.Native.ISeriesView {
    public ISeriesBase Owner { get; }
    public bool Is3DView { get; }
    public bool ShouldSortPoints { get; }
    public bool NeedSeriesInteraction { get; }
    public bool NeedSeriesGroupsInteraction { get; }
    public bool NeedFilterVisiblePoints { get; }
    public bool IsPointAggregationSupported { get; }
    public int PointDimension { get; }
    public Type PointInterfaceType { get; }
    public CompatibleViewType CompatibleViewType { get; }
    public EmptyPointProcessingMode EmptyPointProcessingMode { get; }
    public bool ShouldCalculateEdgeLabelText { get; }
    public ViewportIntersectionHolder ViewportIntersectionHolder { get; }
    public bool MinMaxValuesAreSame { get; }
    public abstract virtual ISeriesBase get_Owner();
    public abstract virtual bool get_Is3DView();
    public abstract virtual bool get_ShouldSortPoints();
    public abstract virtual bool get_NeedSeriesInteraction();
    public abstract virtual bool get_NeedSeriesGroupsInteraction();
    public abstract virtual bool get_NeedFilterVisiblePoints();
    public abstract virtual bool get_IsPointAggregationSupported();
    public abstract virtual int get_PointDimension();
    public abstract virtual Type get_PointInterfaceType();
    public abstract virtual CompatibleViewType get_CompatibleViewType();
    public abstract virtual EmptyPointProcessingMode get_EmptyPointProcessingMode();
    public abstract virtual bool get_ShouldCalculateEdgeLabelText();
    public abstract virtual ViewportIntersectionHolder get_ViewportIntersectionHolder();
    public abstract virtual double GetRefinedPointMin(RefinedPoint point);
    public abstract virtual double GetRefinedPointMax(RefinedPoint point);
    public abstract virtual bool get_MinMaxValuesAreSame();
    public abstract virtual double GetRefinedPointAbsMin(RefinedPoint refinedPoint);
    public abstract virtual bool IsCorrectValueLevel(ValueLevelInternal valueLevel);
    public abstract virtual SeriesContainer CreateContainer();
    public abstract virtual SeriesInteractionContainer CreateSeriesGroupsContainer();
    public abstract virtual IList`1<IDataPoint> GenerateRandomPoints(Scale argumentScaleType, Scale valueScaleType);
    public abstract virtual MinMaxValues CalculateMinMaxPointRangeValues(CrosshairSeriesPoint point, double range, bool isHorizontalCrosshair, IXYDiagram diagram, CrosshairPaneInfo crosshairPaneInfo, CrosshairSnapModeCore snapMode);
}
public interface DevExpress.Charts.Native.ISideBySideBarPoint {
    public bool Interacted { get; }
    public abstract virtual bool get_Interacted();
}
public interface DevExpress.Charts.Native.ISideBySideBarSeriesView {
    public double BarDistance { get; public set; }
    public int BarDistanceFixed { get; public set; }
    public bool EqualBarWidth { get; public set; }
    public abstract virtual double get_BarDistance();
    public abstract virtual void set_BarDistance(double value);
    public abstract virtual int get_BarDistanceFixed();
    public abstract virtual void set_BarDistanceFixed(int value);
    public abstract virtual bool get_EqualBarWidth();
    public abstract virtual void set_EqualBarWidth(bool value);
}
public interface DevExpress.Charts.Native.ISideBySidePoint {
    public int FixedOffset { get; }
    public double Offset { get; }
    public double BarWidth { get; }
    public abstract virtual int get_FixedOffset();
    public abstract virtual double get_Offset();
    public abstract virtual double get_BarWidth();
}
public interface DevExpress.Charts.Native.ISideBySideStackedBarSeriesView {
    public object StackedGroup { get; public set; }
    public abstract virtual object get_StackedGroup();
    public abstract virtual void set_StackedGroup(object value);
}
public interface DevExpress.Charts.Native.ISimpleDiagram {
    public SimpleDiagramLayoutDirection LayoutDirection { get; }
    public int Dimension { get; }
    public abstract virtual SimpleDiagramLayoutDirection get_LayoutDirection();
    public abstract virtual int get_Dimension();
}
public interface DevExpress.Charts.Native.ISimpleSeriesView {
}
public interface DevExpress.Charts.Native.ISplineSeriesView {
    public bool ShouldCorrectRanges { get; }
    public abstract virtual bool get_ShouldCorrectRanges();
}
public interface DevExpress.Charts.Native.ISplineView {
    public SplineAlgorithmCore SplineAlgorithm { get; public set; }
    public int LineTensionPercent { get; public set; }
    public abstract virtual SplineAlgorithmCore get_SplineAlgorithm();
    public abstract virtual void set_SplineAlgorithm(SplineAlgorithmCore value);
    public abstract virtual int get_LineTensionPercent();
    public abstract virtual void set_LineTensionPercent(int value);
}
public interface DevExpress.Charts.Native.IStackedPoint {
    public double MinValue { get; }
    public double MaxValue { get; }
    public double TotalValue { get; }
    public double TotalMinValue { get; }
    public double TotalMaxValue { get; }
    public IList`1<RefinedPoint> ConnectedPoints { get; }
    public abstract virtual double get_MinValue();
    public abstract virtual double get_MaxValue();
    public abstract virtual double get_TotalValue();
    public abstract virtual double get_TotalMinValue();
    public abstract virtual double get_TotalMaxValue();
    public abstract virtual IList`1<RefinedPoint> get_ConnectedPoints();
}
public interface DevExpress.Charts.Native.IStackedSplineView {
}
public interface DevExpress.Charts.Native.IStackedView {
}
public interface DevExpress.Charts.Native.IStepSeriesView {
    public bool InvertedStep { get; public set; }
    public bool SnapCrosshairToActualStep { get; }
    public abstract virtual bool get_InvertedStep();
    public abstract virtual void set_InvertedStep(bool value);
    public abstract virtual bool get_SnapCrosshairToActualStep();
}
public interface DevExpress.Charts.Native.IStrip {
    public bool Visible { get; }
    public IStripLimit MinLimit { get; }
    public IStripLimit MaxLimit { get; }
    public string AxisLabelText { get; }
    public abstract virtual bool get_Visible();
    public abstract virtual IStripLimit get_MinLimit();
    public abstract virtual IStripLimit get_MaxLimit();
    public abstract virtual string get_AxisLabelText();
    public abstract virtual void CorrectLimits();
}
public interface DevExpress.Charts.Native.IStripLimit {
    public double ActualValue { get; }
    public abstract virtual double get_ActualValue();
}
public interface DevExpress.Charts.Native.IStripSplitter {
    public bool NeedContinueFirstStrip { get; }
    public abstract virtual bool get_NeedContinueFirstStrip();
    public abstract virtual List`1<ColoredStripInfo> SplitStrip(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, Func`2<RefinedPoint, double> getActualValue);
    public abstract virtual bool CanProcessPoint(RefinedPoint point);
}
public interface DevExpress.Charts.Native.ISubtotal {
    public int PointIndex { get; }
    public string Label { get; }
    public abstract virtual int get_PointIndex();
    public abstract virtual string get_Label();
}
public interface DevExpress.Charts.Native.ISummaryBindingProvider {
    public string IncorrectSummaryFunctionMessage { get; }
    public ISummaryOptionsBase Options { get; }
    public string FunctionString { get; }
    public abstract virtual string get_IncorrectSummaryFunctionMessage();
    public abstract virtual DataSourceValuesCore CreateDataSourceValues();
    public abstract virtual IDataPoint[] CreatePoints(ISeries series, object argument, String[] functionArguments, DataSourceValuesCore[] values, Object[] colors);
    public abstract virtual ISummaryOptionsBase get_Options();
    public abstract virtual string get_FunctionString();
}
public interface DevExpress.Charts.Native.ISummaryOptionsBase {
}
public interface DevExpress.Charts.Native.ISupportMinMaxValues {
    public double Max { get; }
    public double Min { get; }
    public abstract virtual double get_Max();
    public abstract virtual double get_Min();
    public abstract virtual double GetAbsMinValue();
}
public interface DevExpress.Charts.Native.ISupportSeriesGroups {
    public object SeriesGroup { get; public set; }
    public abstract virtual object get_SeriesGroup();
    public abstract virtual void set_SeriesGroup(object value);
}
public interface DevExpress.Charts.Native.ISupportVisibilityControlElement {
    public bool Visible { get; public set; }
    public int Priority { get; }
    public GRealRect2D Bounds { get; }
    public VisibilityElementOrientation Orientation { get; }
    public int Id { get; public set; }
    public abstract virtual bool get_Visible();
    public abstract virtual void set_Visible(bool value);
    public abstract virtual int get_Priority();
    public abstract virtual GRealRect2D get_Bounds();
    public abstract virtual VisibilityElementOrientation get_Orientation();
    public abstract virtual int get_Id();
    public abstract virtual void set_Id(int value);
}
public interface DevExpress.Charts.Native.ISurfaceSeriesView {
    public int ThresholdPointsCount { get; }
    public SurfaceDataSourceMode DataMode { get; }
    public int DimensionX { get; public set; }
    public int DimensionY { get; public set; }
    public abstract virtual int get_ThresholdPointsCount();
    public abstract virtual SurfaceDataSourceMode get_DataMode();
    public abstract virtual int get_DimensionX();
    public abstract virtual void set_DimensionX(int value);
    public abstract virtual int get_DimensionY();
    public abstract virtual void set_DimensionY(int value);
}
public interface DevExpress.Charts.Native.ISwiftPlotDiagram {
}
public interface DevExpress.Charts.Native.ITickmarksOwner {
    public bool TickmarksVisible { get; }
    public bool TickmarksMinorVisible { get; }
    public int TickmarksThickness { get; }
    public int TickmarksMinorThickness { get; }
    public int TickmarksLength { get; }
    public int TickmarksMinorLength { get; }
    public bool TickmarksCrossAxis { get; }
    public abstract virtual bool get_TickmarksVisible();
    public abstract virtual bool get_TickmarksMinorVisible();
    public abstract virtual int get_TickmarksThickness();
    public abstract virtual int get_TickmarksMinorThickness();
    public abstract virtual int get_TickmarksLength();
    public abstract virtual int get_TickmarksMinorLength();
    public abstract virtual bool get_TickmarksCrossAxis();
}
public interface DevExpress.Charts.Native.ITimeInterval {
    public int StartHour { get; }
    public int StartMinute { get; }
    public int StartSecond { get; }
    public int EndHour { get; }
    public int EndMinute { get; }
    public int EndSecond { get; }
    public abstract virtual int get_StartHour();
    public abstract virtual int get_StartMinute();
    public abstract virtual int get_StartSecond();
    public abstract virtual int get_EndHour();
    public abstract virtual int get_EndMinute();
    public abstract virtual int get_EndSecond();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.Charts.Native.ITimeIntervalCollection {
    public ITimeInterval Item { get; }
    public int Count { get; }
    public abstract virtual ITimeInterval get_Item(int index);
    public abstract virtual int get_Count();
}
public interface DevExpress.Charts.Native.ITimeSpanScaleOptions {
    public TimeSpanGridAlignmentNative GridAlignment { get; }
    public int MeasureUnitMultiplier { get; }
    public TimeSpanMeasureUnitsCalculatorCore Calculator { get; }
    public abstract virtual TimeSpanGridAlignmentNative get_GridAlignment();
    public abstract virtual int get_MeasureUnitMultiplier();
    public abstract virtual TimeSpanMeasureUnitsCalculatorCore get_Calculator();
    public abstract virtual bool UpdateAutomaticUnits(TimeSpanMeasureUnitNative measureUnit, TimeSpanGridAlignmentNative gridAlignment, double spacing);
    public abstract virtual void UpdateAutomaticGrid(TimeSpanGridAlignmentNative gridAlignment, double gridSpacing);
    public abstract virtual void RaiseScaleChanged();
}
public interface DevExpress.Charts.Native.ITimeSpanSummaryOptions {
    public TimeSpanMeasureUnitNative MeasureUnit { get; }
    public int MeasureUnitMultiplier { get; }
    public bool UseAxisMeasureUnit { get; }
    public abstract virtual TimeSpanMeasureUnitNative get_MeasureUnit();
    public abstract virtual int get_MeasureUnitMultiplier();
    public abstract virtual bool get_UseAxisMeasureUnit();
}
public interface DevExpress.Charts.Native.ITransformation {
    public abstract virtual double TransformForward(double value);
    public abstract virtual double TransformBackward(double value);
}
public interface DevExpress.Charts.Native.ITrendSegmentColorizer {
    public abstract virtual Nullable`1<int> GetColor(double value, double previousValue);
}
internal interface DevExpress.Charts.Native.IUpdateAction {
}
internal interface DevExpress.Charts.Native.IUpdateActionExecutor {
    public abstract virtual SeriesControllerChanges Execute(IExecutorContext context);
}
public interface DevExpress.Charts.Native.IUpdateHelper {
    public abstract virtual void Update(ISeries series, ChartUpdate update);
}
internal interface DevExpress.Charts.Native.IUpdateProcessor {
    public abstract virtual IList`1<IUpdateAction> Process(ChartUpdateInfoBase updateInfo);
    public abstract virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    public abstract virtual bool ShouldForceUpdate();
}
public interface DevExpress.Charts.Native.IValuePoint {
    public double Value { get; public set; }
    public abstract virtual double get_Value();
    public abstract virtual void set_Value(double value);
}
public interface DevExpress.Charts.Native.IViewportChangedNotifiable {
    public abstract virtual void Notify();
}
public interface DevExpress.Charts.Native.IVisualAxisRangeData {
    public bool SynchronizeWithWholeRange { get; public set; }
    public abstract virtual bool get_SynchronizeWithWholeRange();
    public abstract virtual void set_SynchronizeWithWholeRange(bool value);
    public abstract virtual void ScrollOrZoomRange(object min, object max, double internalMin, double internalMax);
    public abstract virtual void ScrollOrZoomRange(object min, object max, double internalMin, double internalMax, bool notifyUpdate);
}
public interface DevExpress.Charts.Native.IWaterfallPoint {
    public double AnchorValue { get; }
    public double RelativeValue { get; }
    public double AbsoluteValue { get; }
    public bool IsSubTotal { get; }
    public abstract virtual double get_AnchorValue();
    public abstract virtual double get_RelativeValue();
    public abstract virtual double get_AbsoluteValue();
    public abstract virtual bool get_IsSubTotal();
}
public interface DevExpress.Charts.Native.IWaterfallSeriesView {
    public IWaterfallValueOptions ValueOptions { get; }
    public abstract virtual IWaterfallValueOptions get_ValueOptions();
    public abstract virtual bool IsSubtotalPoint(ISeriesPoint point);
    public abstract virtual ISeriesPoint CreateSubtotalPoint(ISeries series, string argument, double value, Nullable`1<int> colorCore, object tag);
}
public interface DevExpress.Charts.Native.IWaterfallValueOptions {
    public double StartValue { get; }
    public string StartLabel { get; }
    public IList`1<ISubtotal> SortedSubtotals { get; }
    public string TotalLabel { get; }
    public bool ShouldUpdateScaleMap { get; }
    public abstract virtual double get_StartValue();
    public abstract virtual string get_StartLabel();
    public abstract virtual IList`1<ISubtotal> get_SortedSubtotals();
    public abstract virtual string get_TotalLabel();
    public abstract virtual bool get_ShouldUpdateScaleMap();
    public abstract virtual WaterfallPointInteraction CreatePointInteraction(List`1<RefinedSeries> series, int seriesIndex, RefinedPoint point);
    public abstract virtual WaterfallFilterBehavior CreateFilterBehavior(RefinedSeries refinedSeries);
}
public interface DevExpress.Charts.Native.IWholeAxisRangeData {
}
public interface DevExpress.Charts.Native.IWorkdaysOptions {
    public bool WorkdaysOnly { get; }
    public DayOfWeek FirstDayOfWeek { get; }
    public WeekdayCore Workdays { get; }
    public IEnumerable`1<DateTime> Holidays { get; }
    public IEnumerable`1<DateTime> ExactWorkdays { get; }
    public IEnumerable`1<CustomDate> CustomDates { get; }
    public abstract virtual bool get_WorkdaysOnly();
    public abstract virtual DayOfWeek get_FirstDayOfWeek();
    public abstract virtual WeekdayCore get_Workdays();
    public abstract virtual IEnumerable`1<DateTime> get_Holidays();
    public abstract virtual IEnumerable`1<DateTime> get_ExactWorkdays();
    public abstract virtual IEnumerable`1<CustomDate> get_CustomDates();
}
public interface DevExpress.Charts.Native.IWorkTimeRule {
    public Nullable`1<DateTime> Date { get; }
    public WeekdayCore Weekdays { get; }
    public ITimeIntervalCollection WorkIntervals { get; }
    public bool IsActive { get; }
    public abstract virtual Nullable`1<DateTime> get_Date();
    public abstract virtual WeekdayCore get_Weekdays();
    public abstract virtual ITimeIntervalCollection get_WorkIntervals();
    public abstract virtual bool get_IsActive();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.Charts.Native.IWorkTimeRuleCollection {
    public bool WorkTimeOnly { get; }
    public int Count { get; }
    public IWorkTimeRule Item { get; }
    public abstract virtual bool get_WorkTimeOnly();
    public abstract virtual int get_Count();
    public abstract virtual IWorkTimeRule get_Item(int index);
}
public interface DevExpress.Charts.Native.IXYDiagram {
    public IList`1<IPane> Panes { get; }
    public IAxisData AxisX { get; }
    public IAxisData AxisY { get; }
    public IEnumerable`1<IAxisData> SecondaryAxesX { get; }
    public IEnumerable`1<IAxisData> SecondaryAxesY { get; }
    public IEnumerable`1<IAxisData> AllAxes { get; }
    public bool ScrollingEnabled { get; }
    public bool Rotated { get; }
    public bool UseRangeDependentEnqueuer { get; public set; }
    public bool DependentValueRange { get; }
    public ICrosshairOptions CrosshairOptions { get; }
    public abstract virtual IList`1<IPane> get_Panes();
    public abstract virtual IAxisData get_AxisX();
    public abstract virtual IAxisData get_AxisY();
    public abstract virtual IEnumerable`1<IAxisData> get_SecondaryAxesX();
    public abstract virtual IEnumerable`1<IAxisData> get_SecondaryAxesY();
    public abstract virtual IEnumerable`1<IAxisData> get_AllAxes();
    public abstract virtual bool get_ScrollingEnabled();
    public abstract virtual bool get_Rotated();
    public abstract virtual bool get_UseRangeDependentEnqueuer();
    public abstract virtual void set_UseRangeDependentEnqueuer(bool value);
    public abstract virtual bool get_DependentValueRange();
    public abstract virtual ICrosshairOptions get_CrosshairOptions();
    public abstract virtual IList`1<IPane> GetCrosshairSyncPanes(IPane focusedPane, bool isHorizontalSync);
    public abstract virtual InternalCoordinates MapPointToInternal(IPane pane, GRealPoint2D point);
    public abstract virtual GRealPoint2D MapInternalToPoint(IPane pane, IAxisData axisX, IAxisData axisY, double argument, double value);
    public abstract virtual List`1<IPaneAxesContainer> GetPaneAxesContainers(IList`1<RefinedSeries> activeSeries);
    public abstract virtual void UpdateCrosshairData(ICollection`1<RefinedSeriesUpdateInfo> seriesUpdateInfo, ICollection`1<RefinedSeriesPointsUpdateInfo> pointsUpdateInfo);
    public abstract virtual void UpdateAutoMeasureUnits();
    public abstract virtual int GetAxisXLength(IAxisData axis);
}
public interface DevExpress.Charts.Native.IXYDiagramLabelLayout {
    public ResolveOverlappingModeCore ResolveOverlappingMode { get; }
    public DXPoint AnchorPoint { get; }
    public DXRectangle ValidRectangle { get; }
    public DXRectangle ExcludedRectangle { get; }
    public abstract virtual ResolveOverlappingModeCore get_ResolveOverlappingMode();
    public abstract virtual DXPoint get_AnchorPoint();
    public abstract virtual DXRectangle get_ValidRectangle();
    public abstract virtual DXRectangle get_ExcludedRectangle();
}
public interface DevExpress.Charts.Native.IXYDiagramPane {
}
public interface DevExpress.Charts.Native.IXYPoint {
}
public interface DevExpress.Charts.Native.IXYSeriesView {
    public bool SideMarginsEnabled { get; }
    public bool CrosshairEnabled { get; }
    public CrosshairContentShowModeCore CrosshairContentShowMode { get; }
    public string CrosshairLabelPattern { get; }
    public int PixelsPerArgument { get; }
    public IAxisData AxisXData { get; }
    public IAxisData AxisYData { get; }
    public IAxisData AxisZData { get; }
    public IPane Pane { get; }
    public AggregateFunctionNative AggregateFunction { get; }
    public ICustomAggregateFunction CustomAggregateFunction { get; }
    public ToolTipPointDataToStringConverter CrosshairConverter { get; }
    public IEnumerable`1<IIndicator> CrosshairIndicators { get; }
    public abstract virtual bool get_SideMarginsEnabled();
    public abstract virtual bool get_CrosshairEnabled();
    public abstract virtual CrosshairContentShowModeCore get_CrosshairContentShowMode();
    public abstract virtual string get_CrosshairLabelPattern();
    public abstract virtual int get_PixelsPerArgument();
    public abstract virtual IAxisData get_AxisXData();
    public abstract virtual IAxisData get_AxisYData();
    public abstract virtual IAxisData get_AxisZData();
    public abstract virtual IPane get_Pane();
    public abstract virtual AggregateFunctionNative get_AggregateFunction();
    public abstract virtual ICustomAggregateFunction get_CustomAggregateFunction();
    public abstract virtual ToolTipPointDataToStringConverter get_CrosshairConverter();
    public abstract virtual IEnumerable`1<IIndicator> get_CrosshairIndicators();
    public abstract virtual IEnumerable`1<double> GetCrosshairValues(RefinedPoint refinedPoint);
    public abstract virtual List`1<ISeparatePaneIndicator> GetSeparatePaneIndicators();
    public abstract virtual List`1<IAffectsAxisRange> GetIndicatorsAffectRange();
    public abstract virtual MinMaxValues CalcArgumentRange(RefinedPoint point);
}
public interface DevExpress.Charts.Native.IXYWPoint {
    public double Weight { get; public set; }
    public double Size { get; }
    public abstract virtual double get_Weight();
    public abstract virtual void set_Weight(double value);
    public abstract virtual double get_Size();
}
public interface DevExpress.Charts.Native.IXYWSeriesView {
    public double MinSize { get; }
    public double MaxSize { get; }
    public abstract virtual double get_MinSize();
    public abstract virtual double get_MaxSize();
    public abstract virtual double GetSideMargins(AxisGroup axisGroup, double min, double max);
    public abstract virtual double GetMarkerSizeInAxisUnits(IXYWPoint point);
}
public interface DevExpress.Charts.Native.IXYZBarSeriesView {
    public double BarDepth { get; public set; }
    public abstract virtual double get_BarDepth();
    public abstract virtual void set_BarDepth(double value);
}
public interface DevExpress.Charts.Native.IXYZDiagram {
    public IAxisData AxisZ { get; }
    public IEnumerable`1<IAxisData> SecondaryAxesZ { get; }
    public abstract virtual IAxisData get_AxisZ();
    public abstract virtual IEnumerable`1<IAxisData> get_SecondaryAxesZ();
}
public interface DevExpress.Charts.Native.IXYZPoint {
    public double ArgumentY { get; public set; }
    public abstract virtual double get_ArgumentY();
    public abstract virtual void set_ArgumentY(double value);
}
public interface DevExpress.Charts.Native.IXYZWPoint {
    public double Weight { get; public set; }
    public double Size { get; }
    public abstract virtual double get_Weight();
    public abstract virtual void set_Weight(double value);
    public abstract virtual double get_Size();
}
public interface DevExpress.Charts.Native.IZoomablePane {
    public bool Rotated { get; }
    public bool ScrollingByXEnabled { get; }
    public bool ScrollingByYEnabled { get; }
    public bool ZoomingByXEnabled { get; }
    public bool ZoomingByYEnabled { get; }
    public double AxisXMaxZoomPercent { get; }
    public double AxisYMaxZoomPercent { get; }
    public ZoomStack ZoomStack { get; }
    public DXRectangle Bounds { get; }
    public abstract virtual bool get_Rotated();
    public abstract virtual bool get_ScrollingByXEnabled();
    public abstract virtual bool get_ScrollingByYEnabled();
    public abstract virtual bool get_ZoomingByXEnabled();
    public abstract virtual bool get_ZoomingByYEnabled();
    public abstract virtual double get_AxisXMaxZoomPercent();
    public abstract virtual double get_AxisYMaxZoomPercent();
    public abstract virtual ZoomStack get_ZoomStack();
    public abstract virtual DXRectangle get_Bounds();
    public abstract virtual void RangeLimitsUpdated();
    public abstract virtual void BeginZooming();
    public abstract virtual void EndZooming(NavigationType navigationType, RangesSnapshot oldRange, RangesSnapshot newRange, IAxisData axisX, IAxisData axisY);
    public abstract virtual void EndScrolling(ScrollingOrientation orientation, NavigationType navigationType, RangesSnapshot oldRange, RangesSnapshot newRange, IAxisData axisX, IAxisData axisY);
}
public class DevExpress.Charts.Native.LabelLayoutByAreaComparer : Comparer`1<IXYDiagramLabelLayout> {
    public virtual int Compare(IXYDiagramLabelLayout x, IXYDiagramLabelLayout y);
}
public static class DevExpress.Charts.Native.LargeScaleHelper : object {
    private static int mistakeCriterion;
    private static bool IsValid(double value);
    private static bool IsValid(GRealPoint2D point);
    private static double Validate(double value);
    private static GRealPoint2D Validate(GRealPoint2D point);
    public static void Validate(List`1<GRealPoint2D> points);
}
public abstract class DevExpress.Charts.Native.LayoutCalculator : object {
    private static int SeparatorThickness;
    private LayoutCalculatorHelper layoutHelper;
    protected LayoutCalculatorHelper LayoutHelper { get; }
    protected LayoutCalculator(LayoutCalculatorHelper layoutHelper);
    protected static bool CanUnionRectangles(DXRectangle rect1, DXRectangle rect2);
    protected LayoutCalculatorHelper get_LayoutHelper();
    private List`1<DXRectangle> WidenMaxBounds(IList`1<DXRectangle> boundsList, DXRectangle originalMaxBounds, DXRectangle maxBounds, int distance);
    private List`1<SeparatorInfo> GetSeparatorsBounds(List`1<DXRectangle> boundsList, int separatorThickness, List`1<LayoutItem> collapsedItems);
    protected virtual List`1<SeparatorInfo> GetSeparatorsBoundsInternal(List`1<SeparatorInfo> list);
    protected abstract virtual IList`1<DXRectangle> GetItemsBounds(int itemsDistance, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
    protected abstract virtual void UpdateSeparatorsInfos(List`1<SeparatorInfo> separators);
    protected virtual LayoutInfoList CreateLayoutInfo(List`1<LayoutInfo> list, List`1<SeparatorInfo> separators);
    protected LayoutInfoList Calculate(int itemsDistance, DXRectangle originalMaxBounds, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
}
public abstract class DevExpress.Charts.Native.LayoutCalculatorHelper : object {
    public static LayoutCalculatorHelper CreateInstance(LayoutDirectionNative direction);
    public abstract virtual int GetStartValue(DXRectangle bounds);
    public abstract virtual int GetEndValue(DXRectangle bounds);
    public abstract virtual int GetLength(DXRectangle bounds);
    public abstract virtual int GetLeft(DXRectangle bounds);
    public abstract virtual int GetRight(DXRectangle bounds);
    public abstract virtual DXRectangle CreateNewBounds(DXRectangle oldBounds, int start, int length);
    public abstract virtual int GetFixedSize(GridLayoutItem item);
    public abstract virtual bool IsFixed(GridLayoutItem item);
    public abstract virtual IList`1<ILinearLayoutItem> GetPrimaryDefinitionCollection(IGridLayoutOptions options);
    public abstract virtual IList`1<ILinearLayoutItem> GetPrimaryDefinitionCollection(IList`1<ILinearLayoutItem> rowDefinitions, IList`1<ILinearLayoutItem> columnDefinitions);
    public abstract virtual IList`1<ILinearLayoutItem> GetSecondaryDefinitionCollection(IGridLayoutOptions options);
    public abstract virtual int GetPrimaryGridIndex(IGridLayoutItem options);
    public abstract virtual int GetSecondaryGridIndex(IGridLayoutItem options);
    public abstract virtual int GetPrimaryGridSpan(IGridLayoutItem options);
    public abstract virtual int GetSecondaryGridSpan(IGridLayoutItem options);
    public abstract virtual int GetVerticalValue(int primaryValue, int secondaryValue);
    public abstract virtual int GetHorizontalValue(int primaryValue, int secondaryValue);
}
public enum DevExpress.Charts.Native.LayoutDirectionNative : Enum {
    public int value__;
    public static LayoutDirectionNative Vertical;
    public static LayoutDirectionNative Horizontal;
}
public class DevExpress.Charts.Native.LayoutInfo : object {
    public DXRectangle OuterBounds;
    public DXRectangle OuterBoundsWithItemsDistance;
    public DXRectangle MappingBounds;
    public int LinearSizeInPixels;
    public LayoutInfo(DXRectangle outerBounds, DXRectangle outerBoundsWithItemsDistance, DXRectangle mappingBounds, int linearSizeInPixels);
}
public class DevExpress.Charts.Native.LayoutInfoList : object {
    public List`1<LayoutInfo> List;
    public List`1<SeparatorInfo> Separators;
    public LayoutInfoList(List`1<LayoutInfo> list, List`1<SeparatorInfo> separators);
}
public class DevExpress.Charts.Native.LayoutItem : object {
    private int index;
    private DXRectangle bounds;
    public int Index { get; }
    public DXRectangle Bounds { get; public set; }
    public LayoutItem(int index, DXRectangle bounds);
    public int get_Index();
    public DXRectangle get_Bounds();
    public void set_Bounds(DXRectangle value);
}
public static class DevExpress.Charts.Native.LayoutItemsCalculator : object {
    private static Limits[] CalculateCellsSizes(int count, IList`1<ILinearLayoutItem> definitions, int start, int length, int cellsDistance);
    public static DXRectangle[] CalculateGridItemsBounds(IList`1<GridLayoutInfo> items, int rowsCount, int columnsCount, DXRectangle availableSize, int itemsDistance, IList`1<ILinearLayoutItem> rowDefinitions, IList`1<ILinearLayoutItem> columnDefinitions, Limits[]& firstColumn, Limits[]& firstRow);
    public static IList`1<ILinearLayoutItem> EnsureDefinitions(int count, IList`1<ILinearLayoutItem> definitions);
}
public class DevExpress.Charts.Native.LengthCalculator : object {
    private IList`1<LinearLayoutInfo> itemsInfo;
    private int length;
    private LengthCalculator(IList`1<LinearLayoutInfo> itemsInfo, int length);
    public static bool Calculate(IList`1<LinearLayoutInfo> itemsInfo, int length);
    private int CalculateFixedLength(Int32& noResizableLength, Boolean& allItemsFixed);
    private int CalculateInitialItemsInfoListsWhenNormalCase(List`1<LengthInfo> fixedLengthList, List`1<WeightInfo> resizableWeightList);
    private int GetSizeInPixelsOfFirstFixedItem(Int32& index);
    private void CalculateInitialItemInfoListsWhenOverflowCase(List`1<WeightInfo> resizableWeightList);
    private int CalculateInitialItemInfoLists(List`1<LengthInfo> fixedLengthList, List`1<WeightInfo> resizableWeightList);
    private double CalculateWeightSum(List`1<WeightInfo> resizableWeightList);
    private List`1<LengthInfo> CalculateResizableLengthList(List`1<WeightInfo> resizableWeightList, int resizableLength);
    private void CalculateTotalLength(List`1<LengthInfo> fixedLengthList, List`1<LengthInfo> resizableLengthList);
    private bool Calculate();
}
public abstract class DevExpress.Charts.Native.LightUpdateInfoBase : ChartUpdateInfoBase {
    protected LightUpdateInfoBase(object sender);
}
internal abstract class DevExpress.Charts.Native.LightUpdateProcessorBase`1 : TypedUpdateProcessor`1<T> {
    protected virtual IList`1<IUpdateAction> Process(ChartUpdateInfoBase updateInfo);
}
public class DevExpress.Charts.Native.Limits : ValueType {
    public static Limits Invalid;
    public int Start;
    public int End;
    public int Length { get; }
    public bool IsValid { get; }
    public Limits(int start, int end);
    private static Limits();
    public int get_Length();
    public bool get_IsValid();
}
public static class DevExpress.Charts.Native.LimitsCalculator : object {
    public static DoubleLimitsUnionInfo CalculateUnion(List`1<List`1<DoubleLimits>> globalIntervals);
}
public abstract class DevExpress.Charts.Native.LinearLayoutCalculator : LayoutCalculator {
    protected LinearLayoutCalculator(LayoutCalculatorHelper layoutHelper);
    protected IList`1<DXRectangle> GetItemsBoundsInternal(IList`1<ILinearLayoutItem> items, int itemsDistance, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
    protected void NonProportionalResizeItems(IList`1<DXRectangle> bounds, DXRectangle maxBounds, int itemsDistance, List`1<LayoutItem> collapsedItems, Func`2<int, bool> isVisibleInLayout);
    protected void ProcessBounds(List`1<LinearLayoutInfo> infos, IList`1<DXRectangle> bounds, int startIndex, int itemsDistance, int start, int length, DXRectangle maxBounds);
    protected virtual void UpdateSeparatorsInfos(List`1<SeparatorInfo> separators);
}
public class DevExpress.Charts.Native.LinearLayoutInfo : object {
    private LayoutItem owner;
    private double weight;
    private bool canBeResized;
    private int size;
    public bool CanBeResized { get; }
    public bool FixedSize { get; }
    public double Weight { get; }
    public int SizeInPixels { get; public set; }
    private bool DevExpress.Charts.Native.ILinearLayoutItem.Fixed { get; }
    private double DevExpress.Charts.Native.ILinearLayoutItem.Weight { get; }
    private int DevExpress.Charts.Native.ILinearLayoutItem.SizeInPixels { get; }
    public LinearLayoutInfo(double weight, int size, bool canBeResized, LayoutItem owner);
    public static LinearLayoutInfo Create(ILinearLayoutItem definition, LayoutItem owner);
    public bool get_CanBeResized();
    public bool get_FixedSize();
    public double get_Weight();
    public int get_SizeInPixels();
    public void set_SizeInPixels(int value);
    private sealed virtual override bool DevExpress.Charts.Native.ILinearLayoutItem.get_Fixed();
    private sealed virtual override double DevExpress.Charts.Native.ILinearLayoutItem.get_Weight();
    private sealed virtual override int DevExpress.Charts.Native.ILinearLayoutItem.get_SizeInPixels();
}
public class DevExpress.Charts.Native.LinearNonProportionalLayoutCalculator : LinearLayoutCalculator {
    private IList`1<ILinearLayoutItem> items;
    public LinearNonProportionalLayoutCalculator(IList`1<ILinearLayoutItem> items, LayoutCalculatorHelper layoutHelper);
    public static LayoutInfoList Calculate(IList`1<ILinearLayoutItem> items, ILayoutOptions layoutOptions, int itemsDistance, DXRectangle originalMaxBounds, DXRectangle maxBounds);
    public static LayoutInfoList Calculate(IList`1<ILinearLayoutItem> items, ILayoutOptions layoutOptions, int itemsDistance, DXRectangle originalMaxBounds, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
    protected virtual IList`1<DXRectangle> GetItemsBounds(int itemsDistance, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
}
public class DevExpress.Charts.Native.LinearProportionalLayoutCalculator : LinearLayoutCalculator {
    private IList`1<ILinearLayoutItem> items;
    public LinearProportionalLayoutCalculator(IList`1<ILinearLayoutItem> items, LayoutCalculatorHelper layoutHelper);
    public static LayoutInfoList Calculate(IList`1<ILinearLayoutItem> items, ILayoutOptions layoutOptions, int itemsDistance, DXRectangle originalMaxBounds, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
    protected virtual IList`1<DXRectangle> GetItemsBounds(int itemsDistance, DXRectangle maxBounds, List`1<LayoutItem> collapsedItems);
}
public class DevExpress.Charts.Native.LineGeometrySplittedStripCreator : LineGeometryStripCreator {
    private IStripSplitter stripSplitter;
    public LineGeometrySplittedStripCreator(IStripSplitter stripSplitter, bool closed, bool shouldAddEmptyStrip);
    protected virtual IGeometryStrip ProcessIntervalsStrip(IGeometryStrip strip, List`1<IGeometryStrip> strips, IList`1<RefinedPoint> points, int index, List`1<ColoredStripInfo> coloredStripInfos);
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
    internal virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.LineGeometryStripCreator : GeometryStripCreator {
    private bool closed;
    private bool shouldAddEmptyStrip;
    protected internal bool Closed { get; }
    protected internal bool ShouldAddEmptyStrip { get; }
    protected internal bool FilteringPointsSupported { get; }
    public LineGeometryStripCreator(bool closed, bool shouldAddEmptyStrip);
    protected internal virtual bool get_Closed();
    protected internal virtual bool get_ShouldAddEmptyStrip();
    protected internal virtual bool get_FilteringPointsSupported();
    protected virtual double GetActualValue(RefinedPoint refinedPoint);
    protected virtual double GetPointMinValue(RefinedPoint refinedPoint);
    protected IGeometryStrip ProcessSplitStrip(IStripSplitter stripSplitter, IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
    protected virtual IGeometryStrip ProcessIntervalsStrip(IGeometryStrip strip, List`1<IGeometryStrip> strips, IList`1<RefinedPoint> points, int index, List`1<ColoredStripInfo> coloredStripInfos);
    protected virtual IGeometryStrip AddStripElementCore(IList`1<RefinedPoint> points, int index, IGeometryStrip strip);
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
    protected internal virtual IGeometryStrip CreateStrip();
    [CompilerGeneratedAttribute]
private double <ProcessSplitStrip>b__11_0(RefinedPoint rPoint);
}
public class DevExpress.Charts.Native.LineStrip : List`1<GRealPoint2D> {
    private GeometryStripStyle customStyle;
    public bool IsEmpty { get; }
    public GeometryStripStyle Style { get; }
    public LineStrip(int pointsCount);
    public LineStrip(IList`1<GRealPoint2D> points);
    public LineStrip(IList`1<GRealPoint2D> points, Nullable`1<int> color);
    public virtual bool get_IsEmpty();
    public sealed virtual GeometryStripStyle get_Style();
    public void AddUniquePoint(GRealPoint2D point);
    public void AddStepToPoint(GRealPoint2D point, bool invertedStep);
    public virtual LineStrip CreateInstance();
    public virtual void CompleteFilling(IList`1<RefinedPoint> points, IBezierStripSplitter splitter);
    public virtual LineStrip CreateUniqueStrip();
    public virtual void Extend(GRealPoint2D point, bool toLeft);
    public virtual LineStrip ExtractSubStrip(int startIndex, int endIndex);
    public virtual void Substitute(int startIndex, int endIndex, LineStrip lineStrip);
}
public class DevExpress.Charts.Native.LineViewportIntersectionHolder : ViewportIntersectionHolder {
    public LineViewportIntersectionHolder(IXYSeriesView view);
}
internal class DevExpress.Charts.Native.LogarithmicRegressionCalculator : object {
    public Tuple`2<double, double> Calculate(IList`1<RefinedPoint> points, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.LogarithmicTransformation : Transformation {
    private static double defaultIndentFromZero;
    private bool coerenceNegative;
    private double logarithmicBase;
    private double indentFromZero;
    private double minAbsValue;
    private double minLogValue;
    public double LogarithmicBase { get; }
    public double MinLogValue { get; }
    public bool IsIdentity { get; }
    public LogarithmicTransformation(double logarithmicBase);
    public LogarithmicTransformation(double logarithmicBase, double indentFromZero);
    internal LogarithmicTransformation(double logarithmicBase, double indentFromZero, bool coerenceNegative);
    public double get_LogarithmicBase();
    public double get_MinLogValue();
    public virtual bool get_IsIdentity();
    public virtual double TransformForward(double value);
    public virtual double TransformBackward(double value);
    public virtual void Reset();
    public virtual void Update(Double[] values);
    public virtual void CompleteUpdate();
    private bool IsSpecialValue(double value);
}
public class DevExpress.Charts.Native.MACDIndicatorPointToStringConverter : MultiValuesIndicatorPointToStringConverter {
    protected string DefaultValuePart { get; }
    public MACDIndicatorPointToStringConverter(ISeries series, bool isTextInLegend);
    protected virtual string get_DefaultValuePart();
}
internal abstract class DevExpress.Charts.Native.MapWithoutGapsCalculator`2 : object {
    private List`1<DoubleLimits> dataLimits;
    private Dictionary`2<Tuple`2<Unit, int>, List`1<ValuesContainer<T, Unit>>> valuesCache;
    internal List`1<DoubleLimits> DataLimits { get; }
    public MapWithoutGapsCalculator`2(List`1<DoubleLimits> dataLimits);
    internal List`1<DoubleLimits> get_DataLimits();
    private List`1<ValuesContainer<T, Unit>> GetValuesByMeasureUnit(Unit measureUnit, int measureUnitMultiplier);
    protected abstract virtual List`1<ValuesContainer<T, Unit>> CalculateValuesByMeasureUnit(Unit measureUnit, int measureUnitMultiplier);
    protected abstract virtual double NativeToRefinedSimple(T value);
    protected abstract virtual double NativeToInternalSimple(T value, Unit measureUnit, int measureUnitMultiplier);
    protected abstract virtual T InternalToNativeSimple(double value, Unit measureUnit, int measureUnitMultiplier);
    protected abstract virtual T RefinedToNativeSimple(double value);
    protected double AlignToNextRefinedValue(double refinedValue);
    protected double GetGapForInternalValue(double value, Unit measureUnit, int measureUnitMultiplier);
    public double NativeToInternal(T value, Unit measureUnit, int measureUnitMultiplier);
    public T InternalToNative(double value, Unit measureUnit, int measureUnitMultiplier);
    public double RefinedToInternal(double value, Unit measureUnit, int measureUnitMultiplier);
    public bool IsAxisValueVisible(T axisValue);
    internal Dictionary`2<Tuple`2<Unit, int>, List`1<ValuesContainer<T, Unit>>> ValuesCacheAccessor();
}
public class DevExpress.Charts.Native.MassIndexCalculator : object {
    private static int DesignTimeMaPointsCountCount;
    private static int DesignTimeSumPointsCount;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    public static bool IsCompatible(ISeriesView view);
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int movingAveragePointsCount, int sumPointsCount);
    private double CalcNextEma(double value, double preEma, double smoothingFactor);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int movingAveragePointsCount, int sumPointsCount);
}
public static class DevExpress.Charts.Native.MathUtilsCore : object {
    public static double MinMax(double value, double firstBound, double secondBound);
}
public class DevExpress.Charts.Native.MaxAggregationCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.MaxAggregationSingleValueCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.MaxValueFilterBehavior : ValueThresholdFilterBehavior {
    protected virtual IList`1<RefinedPoint> FilterPoints(IList`1<RefinedPoint> initialPoints, double thresholdValue);
}
public class DevExpress.Charts.Native.MeanLineGeometryStripCreator : GeometryStripCreator {
    protected internal bool Closed { get; }
    protected internal bool ShouldAddEmptyStrip { get; }
    protected internal virtual bool get_Closed();
    protected internal virtual bool get_ShouldAddEmptyStrip();
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
    protected internal virtual IGeometryStrip CreateStrip();
}
public abstract class DevExpress.Charts.Native.MeasureUnitAxisAggregationIntervalsCalculator`1 : AxisAggregationIntervalsCalculatorBase {
    protected bool UpdateIntervalsCore(IAxisData axis, IScaleOptionsBase`1<TMeasureUnit> scaleOptions, IList`1<RefinedSeries> refinedSeries);
    protected virtual AggregationIntervalsInfo CreateAggregationIntervalsInfo(IAxisData axis, IScaleOptionsBase`1<TMeasureUnit> scaleOptions, IList`1<RefinedSeries> refinedSeries);
}
public class DevExpress.Charts.Native.MeasureUnitPair : ValueType {
    private ScaleOptionsInfo measureUnitX;
    private ScaleOptionsInfo measureUnitZ;
    public MeasureUnitPair(ScaleOptionsInfo measureUnitX, ScaleOptionsInfo measureUnitZ);
    public static bool op_Equality(MeasureUnitPair a, MeasureUnitPair b);
    public static bool op_Inequality(MeasureUnitPair a, MeasureUnitPair b);
    public sealed virtual bool Equals(MeasureUnitPair other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class DevExpress.Charts.Native.MeasureUnitsCalculatorBase : object {
    public static double CalculateAutoMeasureUnit(double wholeRange, double visualRange, double visualRangeLength, int pixelsPerUnit);
    public abstract virtual bool UpdateAutomaticMeasureUnit(double axisLength, IEnumerable`1<ISeries> seriesList);
}
public abstract class DevExpress.Charts.Native.MeasureUnitsCalculatorBase`2 : MeasureUnitsCalculatorBase {
    private IAxisData axis;
    private UnitSelector`2<TMeasureUnit, TGridAlignment> unitSelector;
    private double minMeasureUnit;
    private double currentMeasureUnit;
    protected IAxisData Axis { get; }
    protected UnitSelector`2<TMeasureUnit, TGridAlignment> UnitSelector { get; }
    protected double CurrentMeasureUnit { get; }
    protected IScaleOptionsBase`1<TMeasureUnit> ScaleOptions { get; }
    protected bool UseMinMeasureUnit { get; }
    public double MinMeasureUnit { get; }
    public IList`1<TMeasureUnit> MeasureUnitsList { get; }
    protected MeasureUnitsCalculatorBase`2(IAxisData axis);
    protected IAxisData get_Axis();
    protected UnitSelector`2<TMeasureUnit, TGridAlignment> get_UnitSelector();
    protected double get_CurrentMeasureUnit();
    protected abstract virtual IScaleOptionsBase`1<TMeasureUnit> get_ScaleOptions();
    protected abstract virtual bool get_UseMinMeasureUnit();
    public double get_MinMeasureUnit();
    public IList`1<TMeasureUnit> get_MeasureUnitsList();
    private int GetPixelsPerUnit(IEnumerable`1<ISeries> seriesList);
    private MeasureUnitCalculationInfo<TMeasureUnit, TGridAlignment> CalculateMeasureUnitInfo(double axisLength, int pixelsPerUnit, IEnumerable`1<ISeries> seriesList, RefinedRangeAccessor<TMeasureUnit, TGridAlignment> rangeAccessor);
    private Nullable`1<TMeasureUnit> CalculateAutoMeasureUnit(IEnumerable`1<ISeries> seriesList, double axisLength, int pixelsPerUnit, RefinedRangeAccessor<TMeasureUnit, TGridAlignment> rangeAccessor);
    private Nullable`1<TMeasureUnit> CalculateCustomMeasureUnit(IEnumerable`1<ISeries> seriesList, double axisLength, int pixelsPerUnit);
    protected abstract virtual bool UpdateAutomaticUnits(TMeasureUnit measureUnit, int pixelsPerUnit);
    protected abstract virtual void UpdateAutomaticGrid(double pixelsPerUnit, IMinMaxValues visualRange);
    protected abstract virtual UnitSelector`2<TMeasureUnit, TGridAlignment> CreateUnitSelector();
    public virtual bool UpdateAutomaticMeasureUnit(double axisLength, IEnumerable`1<ISeries> seriesList);
    public void UpdateAutomaticGrid(double axisLength, IEnumerable`1<ISeries> seriesList, IMinMaxValues visualRange);
}
public class DevExpress.Charts.Native.MedianPriceCalculator : object {
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    public bool Calculated { get; private set; }
    public static bool IsCompatible(ISeriesView view);
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    private bool IsParameterCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
}
public class DevExpress.Charts.Native.MinAggregationCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.MinAggregationSingleValueCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.MinMaxValues : ValueType {
    private double min;
    private double max;
    private bool isZeroRangeDirty;
    private bool isZeroRange;
    public static MinMaxValues Empty { get; }
    public double Delta { get; }
    public bool HasValues { get; }
    public bool IsEmpty { get; }
    public bool IsZeroRange { get; }
    public double Max { get; public set; }
    public double Min { get; public set; }
    public MinMaxValues(double value);
    public MinMaxValues(IMinMaxValues values);
    public MinMaxValues(double min, double max);
    public static MinMaxValues get_Empty();
    public static bool IsEmptyValue(IMinMaxValues value);
    public static bool IsValid(IMinMaxValues value);
    public static double CalculateCenter(IMinMaxValues minMaxValues);
    public static MinMaxValues Intersection(IMinMaxValues first, IMinMaxValues second);
    public static MinMaxValues Union(MinMaxValues a, MinMaxValues b);
    public static bool op_Inequality(MinMaxValues a, MinMaxValues b);
    public static bool op_Equality(MinMaxValues a, MinMaxValues b);
    public sealed virtual double get_Delta();
    public bool get_HasValues();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsZeroRange();
    public sealed virtual double get_Max();
    public sealed virtual void set_Max(double value);
    public sealed virtual double get_Min();
    public sealed virtual void set_Min(double value);
    private static MinMaxValues Clone(IMinMaxValues value);
    internal void UpdateZeroRange();
    public sealed virtual double CalculateCenter();
    public MinMaxValues Clone();
    public sealed virtual bool Equals(MinMaxValues other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool InRange(double value);
    public sealed virtual void Intersection(IMinMaxValues minMaxValues);
    public virtual string ToString();
    public void Union(double value);
    public MinMaxValues Union(MinMaxValues value);
}
public class DevExpress.Charts.Native.MissingArgumentsCalculator : object {
    private AxisScaleTypeMap axisXScaleMap;
    private ISeries series;
    private int valuesCount;
    private ProcessMissingPointsModeNative processMissingPoints;
    private MissingArgumentsCalculator(AxisScaleTypeMap axisXScaleMap, ISeries series, int valuesCount, ProcessMissingPointsModeNative processMissingPoints);
    public static MissingArgumentsCalculator Create(AxisScaleTypeMap axisXScaleMap, ISeries series, int valuesCount, ProcessMissingPointsModeNative processMissingPoints);
    public RefinedPoint CreatePointForMissingArgument(double internalArgument);
}
public abstract class DevExpress.Charts.Native.MovingAverageCalculator : object {
    private LineStrip movingAverageData;
    private LineStrip upperEnvelopeData;
    private LineStrip lowerEnvelopeData;
    public LineStrip MovingAverageData { get; }
    public LineStrip UpperEnvelopeData { get; }
    public LineStrip LowerEnvelopeData { get; }
    public LineStrip get_MovingAverageData();
    public LineStrip get_UpperEnvelopeData();
    public LineStrip get_LowerEnvelopeData();
    public abstract virtual void UpdateMovingAverageData(IList`1<RefinedPoint> refinedPoints, int startUpdateIndex, int pointsCount, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
    public void CalculateEnvelopeData(double envelopePercent, int startUpdateIndex);
    public void Calculate(IList`1<RefinedPoint> points, int pointsCount, ValueLevelInternal valueLevel, double envelopePercent, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.MovingAverageConvergenceDivergenceCalculator : object {
    private static int DesignTimeShortPeriod;
    private static int DesignTimeLongPeriod;
    private static int DesignTimeSmoothingPeriod;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LineStrip <MacdPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private LineStrip <SignalPoints>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    public LineStrip MacdPoints { get; private set; }
    public LineStrip SignalPoints { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    [CompilerGeneratedAttribute]
public LineStrip get_MacdPoints();
    [CompilerGeneratedAttribute]
private void set_MacdPoints(LineStrip value);
    [CompilerGeneratedAttribute]
public LineStrip get_SignalPoints();
    [CompilerGeneratedAttribute]
private void set_SignalPoints(LineStrip value);
    private double CalculateNextEma(double value, double preEma, double smoothingFactor);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int shortPeriod, int longPeriod, int smoothingPeriod, ValueLevelInternal valueLevel);
    public void Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int shortPeriod, int longPeriod, int smoothingPeriod, ValueLevelInternal valueLevel);
}
public class DevExpress.Charts.Native.MovingAverageIndicatorPointToStringConverter : MultiValuesIndicatorPointToStringConverter {
    private static string average;
    private static string upperEnveloper;
    private static string lowerEnveloper;
    private MovingAverageKindInternal kind;
    protected bool UseMultiValues { get; }
    protected string DefaultValuePart { get; }
    protected string DefaultLegendValuePart { get; }
    public MovingAverageIndicatorPointToStringConverter(ISeries series, bool isTextInLegend, MovingAverageKindInternal kind);
    protected virtual bool get_UseMultiValues();
    protected virtual string get_DefaultValuePart();
    protected virtual string get_DefaultLegendValuePart();
}
public enum DevExpress.Charts.Native.MovingAverageKindInternal : Enum {
    public int value__;
    public static MovingAverageKindInternal MovingAverage;
    public static MovingAverageKindInternal Envelope;
    public static MovingAverageKindInternal MovingAverageAndEnvelope;
}
public class DevExpress.Charts.Native.MultiIntervalMappingCore : AxisMappingCore {
    private IIntervalLayoutProvider intervalLayoutsProvider;
    public MultiIntervalMappingCore(IAxisData axis, IIntervalLayoutProvider intervalLayoutsProvider, double axisLength);
    protected virtual IntervalLayout GetIntervalLayout(double value, bool exactLayout);
    protected virtual IntervalLayout GetIntervalLayoutByCoordinate(double coordinate);
    protected virtual IntervalLayout GetNearestIntervalLayout(double coordinate);
}
public class DevExpress.Charts.Native.MultiValuesIndicatorPointToStringConverter : IndicatorPointToStringConverter {
    protected bool UseMultiValues { get; }
    protected string DefaultArgumentPart { get; }
    protected string DefaultGroupArgumentPart { get; }
    public MultiValuesIndicatorPointToStringConverter(ISeries series, bool isTextInLegend);
    protected virtual bool get_UseMultiValues();
    protected virtual string get_DefaultArgumentPart();
    protected virtual string get_DefaultGroupArgumentPart();
}
public static class DevExpress.Charts.Native.NameGenerator : object {
    private static bool TestName(IList`1<string> nameList, string name);
    public static string UniqueName(string baseName, IList`1<string> nameList, bool useFirstItemIndex);
}
public class DevExpress.Charts.Native.NativeRange : ValueType {
    private object min;
    private object max;
    public object Min { get; }
    public object Max { get; }
    public NativeRange(object min, object max);
    public object get_Min();
    public object get_Max();
}
public enum DevExpress.Charts.Native.NavigationType : Enum {
    public int value__;
    public static NavigationType LargeDecrement;
    public static NavigationType LargeIncrement;
    public static NavigationType SmallDecrement;
    public static NavigationType SmallIncrement;
    public static NavigationType ThumbPosition;
    public static NavigationType LeftButtonMouseDrag;
    public static NavigationType MiddleButtonMouseDrag;
    public static NavigationType ArrowKeys;
    public static NavigationType ZoomIn;
    public static NavigationType ZoomOut;
    public static NavigationType SetRange;
    public static NavigationType ZoomUndo;
    public static NavigationType Command;
    public static NavigationType Gesture;
    public static NavigationType ZoomThumbRelease;
    public static NavigationType ZoomReset;
}
public enum DevExpress.Charts.Native.NearTextPosition : Enum {
    public int value__;
    public static NearTextPosition Bottom;
    public static NearTextPosition Left;
    public static NearTextPosition Right;
    public static NearTextPosition Top;
    public static NearTextPosition None;
}
public class DevExpress.Charts.Native.NestedDoughnutInteractionContainer : SeriesGroupsInteractionContainer {
    private Double[] totalGroupIndentsInPixels;
    private Double[] holeRadiuses;
    private Double[] startOffsets;
    private Double[] startOffsetsInPixels;
    private Double[] normalizedWeights;
    private Double[] explodedFactors;
    private Boolean[] isExploded;
    public IList`1<IPointInteraction> PointInteractions { get; }
    public NestedDoughnutInteractionContainer(ISeriesView view);
    public virtual IList`1<IPointInteraction> get_PointInteractions();
    private double GetDoubleArrayValue(IList`1<double> array, int index);
    private void UpdateInteractionKeys();
    protected virtual void InsertRefinedPoints(int seriesIndex, RefinedSeries refinedSeries);
    protected virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries refinedSeries, bool removeAll);
    protected virtual void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected virtual void RecalculateCore(int groupsCount);
    public double GetTotalGroupIndentInPixels(int index);
    public double GetHoleRadius(int index);
    public double GetStartOffset(int index);
    public double GetStartOffsetInPixels(int index);
    public double GetNormalizedWeight(int index);
    public double GetExplodedFactor(int index);
    public bool GetIsExploded(int index);
}
internal class DevExpress.Charts.Native.NestedDoughnutSeriesViewPropertiesUpdateProcessor : TypedUpdateProcessor`2<PropertyUpdateInfo, INestedDoughnutSeriesView> {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo updateInfo, INestedDoughnutSeriesView sender);
}
public abstract class DevExpress.Charts.Native.NormalizedValuesCalculator : object {
    private ISeries series;
    private Double[] normValues;
    protected ISeries Series { get; }
    protected IList`1<IDataPoint> Points { get; }
    protected NormalizedValuesCalculator(ISeries series);
    protected static double GetPointValue(IDataPoint point);
    protected ISeries get_Series();
    protected IList`1<IDataPoint> get_Points();
    public double CalculateNormalizedValue(IDataPoint point);
    protected abstract virtual Double[] CalculateNormValues();
}
public class DevExpress.Charts.Native.NumericAggregatedSeriesArgumentContainer : AggregatedSeriesArgumentContainer`1<double> {
    protected Scale Scale { get; }
    protected double NumericalArgument { get; }
    protected string QualitativeArgument { get; }
    public NumericAggregatedSeriesArgumentContainer(object argument);
    protected virtual Scale get_Scale();
    protected virtual double get_NumericalArgument();
    protected virtual string get_QualitativeArgument();
    protected virtual double Convert(object value);
}
public class DevExpress.Charts.Native.NumericalAxisRangeUpdateStrategy : RangeUpdateStrategy {
    public NumericalAxisRangeUpdateStrategy(IAxisData axis, MinMaxValues minMaxInternal, MinMaxValues minMaxRefined, ICollection`1<RefinedSeries> refinedSeries, bool scaleMapWasChanged);
    protected virtual MinMaxValues GetInternalForNativeValues(MinMaxValues internalValues, MinMaxValues correctedInternalValues, IAxisRangeData range);
    protected virtual NativeRange GetNativeValues(MinMaxValues internalValues, MinMaxValues correctedInternalValues, IAxisRangeData range);
    protected virtual InternalRange CheckInternalValue(IAxisRangeData range, MinMaxValues internalValues);
}
public class DevExpress.Charts.Native.NumericalLogarithmicAxisRangeUpdateStrategy : NumericalAxisRangeUpdateStrategy {
    public NumericalLogarithmicAxisRangeUpdateStrategy(IAxisData axis, MinMaxValues minMaxInternal, MinMaxValues minMaxRefined, ICollection`1<RefinedSeries> refinedSeries, bool scaleMapWasChanged);
    private MinMaxValues ValidateRange(MinMaxValues values);
    protected virtual SideMarginCalculatorBase CreateSideMarginCalculator(IAxisData axis, bool autoCorrectMin, bool autoCorrectMax);
    protected virtual InternalRange ApplySideMargins(MinMaxValues internalValues, MinMaxValues sideMargins, bool autoCorrectionMin, bool autoCorrectionMax);
    protected virtual MinMaxValues GetInternalForNativeValues(MinMaxValues internalValues, MinMaxValues correctedInternalValues, IAxisRangeData range);
}
public class DevExpress.Charts.Native.NumericalSeriesPointValuesContainer : SeriesPointValuesContainer {
    protected Scale ScaleType { get; }
    public NumericalSeriesPointValuesContainer(Double[] values);
    protected virtual Scale get_ScaleType();
}
public class DevExpress.Charts.Native.NumericArgumentSimpleStandardDeviationCalculator : SimpleStandardDeviationCalculator {
    protected virtual double GetValue(RefinedPoint point);
}
internal class DevExpress.Charts.Native.NumericAxisAggregationInterval : AxisAggregationInterval {
    public object NativeMin { get; }
    public object NativeMax { get; }
    public NumericAxisAggregationInterval(double min, double max, bool includeMin, bool includeMax, bool isUnderflow, bool isOverflow);
    public virtual object get_NativeMin();
    public virtual object get_NativeMax();
}
public class DevExpress.Charts.Native.NumericAxisAggregationIntervalsCalculator : DivisionModeAxisAggregationIntervalsCalculator`1<double> {
    protected virtual bool IsInvalidScaleMode(ScaleModeNative scaleMode);
    protected virtual double CalcBinWidth(IAxisData axis, double intervalWidth, double measureUnit);
    protected virtual double RoundValue(IAxisData axis, double value);
    protected virtual double RoundUpValue(IAxisData axis, double value);
    protected virtual SimpleStandardDeviationCalculator CreateAutoHistogramCalculator(IAxisData axis);
    public virtual bool UpdateIntervals(IAxisData axis, IList`1<RefinedSeries> refinedSeries);
}
internal class DevExpress.Charts.Native.NumericAxisIntervalsContainer : AxisIntervalsContainer {
    public NumericAxisIntervalsContainer(AggregationIntervalsInfo info);
    protected virtual double GetNextRefinedValue(double value);
    protected virtual double GetPrevRefinedValue(double value);
    protected virtual object GetNextNativeValue(object value);
    protected virtual object GetPrevNativeValue(object value);
    protected virtual AxisAggregationInterval CreateInterval(double min, double max, bool useUnderflow);
    protected virtual AxisAggregationInterval CreateOverflowInterval(double min, double max);
    protected virtual AxisAggregationInterval CreateUnderflowInterval(double min, double max, bool useUnderflow);
}
public abstract class DevExpress.Charts.Native.NumericDateTimeSeriesPointDataContainer : SeriesPointDataContainer {
    private double argument;
    protected double Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public double NumericalArgument { get; public set; }
    public string QualitativeArgument { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected NumericDateTimeSeriesPointDataContainer(double argument);
    public static NumericDateTimeSeriesPointDataContainer CreateContainer(double argument, DateTime[] values);
    public static NumericDateTimeSeriesPointDataContainer CreateContainer(double argument, int dimension);
    protected double get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual double get_NumericalArgument();
    public virtual void set_NumericalArgument(double value);
    public virtual string get_QualitativeArgument();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.NumericLabelFormatter : object {
    private sealed virtual override object System.IFormatProvider.GetFormat(Type formatType);
    private sealed virtual override string System.ICustomFormatter.Format(string format, object arg, IFormatProvider formatProvider);
}
public class DevExpress.Charts.Native.NumericMeasureUnitsCalculatorCore : MeasureUnitsCalculatorBase`2<double, double> {
    private INumericScaleOptions NumericScaleOptions { get; }
    protected bool UseMinMeasureUnit { get; }
    protected IScaleOptionsBase`1<double> ScaleOptions { get; }
    public NumericMeasureUnitsCalculatorCore(IAxisData axis);
    private INumericScaleOptions get_NumericScaleOptions();
    protected virtual bool get_UseMinMeasureUnit();
    protected virtual IScaleOptionsBase`1<double> get_ScaleOptions();
    protected virtual UnitSelector`2<double, double> CreateUnitSelector();
    protected virtual bool UpdateAutomaticUnits(double measureUnit, int pixelsPerUnit);
    protected virtual void UpdateAutomaticGrid(double pixelsPerUnit, IMinMaxValues visualRange);
}
public abstract class DevExpress.Charts.Native.NumericNumericSeriesPointDataContainer : SeriesPointDataContainer {
    private double argument;
    protected double Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public double NumericalArgument { get; public set; }
    public string QualitativeArgument { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected NumericNumericSeriesPointDataContainer(double argument);
    public static NumericNumericSeriesPointDataContainer CreateContainer(double argument, int dimension);
    public static NumericNumericSeriesPointDataContainer CreateContainer(double argument, Double[] values);
    protected double get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual double get_NumericalArgument();
    public virtual void set_NumericalArgument(double value);
    public virtual string get_QualitativeArgument();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public enum DevExpress.Charts.Native.NumericOptionsFormat : Enum {
    public int value__;
    public static NumericOptionsFormat General;
    public static NumericOptionsFormat Scientific;
    public static NumericOptionsFormat FixedPoint;
    public static NumericOptionsFormat Currency;
    public static NumericOptionsFormat Percent;
    public static NumericOptionsFormat Number;
}
public static class DevExpress.Charts.Native.NumericOptionsHelper : object {
    public static string GetFormatString(INumericOptions options);
    public static string GetValueText(double value, INumericOptions options);
}
public class DevExpress.Charts.Native.NumericRangeControlClientGridMapping : NumericRangeControlClientGridMappingBase {
}
public abstract class DevExpress.Charts.Native.NumericRangeControlClientGridMappingBase : RangeControlClientGridMapping {
    protected internal virtual double CeilValue(RangeControlGridUnit unit, double value, double offset);
    protected internal virtual double FloorValue(RangeControlGridUnit unit, double value, double offset);
    protected internal virtual double GetGridValue(RangeControlGridUnit unit, double index);
}
public class DevExpress.Charts.Native.NumericSeriesPointDataContainer : SeriesPointDataContainer {
    private double argument;
    private int dimension;
    public Scale ArgumentScaleType { get; }
    public double NumericalArgument { get; public set; }
    public string QualitativeArgument { get; }
    public int Dimension { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    public NumericSeriesPointDataContainer(double argument, int dimension);
    public static SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, int dimension);
    public virtual Scale get_ArgumentScaleType();
    public virtual double get_NumericalArgument();
    public virtual void set_NumericalArgument(double value);
    public virtual string get_QualitativeArgument();
    public virtual int get_Dimension();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer SetDimension(int dimension);
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public enum DevExpress.Charts.Native.NumericStartPointCore : Enum {
    public int value__;
    public static NumericStartPointCore Zero;
    public static NumericStartPointCore MinRangeValue;
}
public abstract class DevExpress.Charts.Native.NumericTimeSpanSeriesPointDataContainer : SeriesPointDataContainer {
    private double argument;
    protected double Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public double NumericalArgument { get; public set; }
    public string QualitativeArgument { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected NumericTimeSpanSeriesPointDataContainer(double argument);
    public static NumericTimeSpanSeriesPointDataContainer CreateContainer(double argument, TimeSpan[] values);
    public static NumericTimeSpanSeriesPointDataContainer CreateContainer(double argument, int dimension);
    protected double get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual double get_NumericalArgument();
    public virtual void set_NumericalArgument(double value);
    public virtual string get_QualitativeArgument();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.NumericUnitSelector : UnitSelector`2<double, double> {
    private static int autoMeasureUnitStep;
    public static int AutoMeasureUnitStep { get; }
    public static int get_AutoMeasureUnitStep();
    private static double RoundMeasureUnit(double measureUnit);
    public virtual void UpdateActiveUnits(double min, double max);
}
public class DevExpress.Charts.Native.ObjectDataMemberContainer : DataMemberContainer`1<object> {
    private bool allowDBNull;
    private bool supportEmptyValue;
    protected bool AllowDBNull { get; }
    protected object DefaultValue { get; }
    public bool SupportEmptyValue { get; }
    public ObjectDataMemberContainer(string dataMember, bool allowDBNull);
    public ObjectDataMemberContainer(string dataMember, bool allowDBNull, bool supportEmptyValue);
    protected virtual bool get_AllowDBNull();
    protected virtual object get_DefaultValue();
    public virtual bool get_SupportEmptyValue();
    protected virtual bool IsCompatibleType(Type type);
    protected virtual bool IsEmptyValue(object value);
    protected virtual object ConvertValue(object value);
    protected virtual object ParseValue(object value);
}
public class DevExpress.Charts.Native.ObjectsFactory : object {
    private static ObjectsFactory instance;
    private Stack`1<CrosshairDataList> crosshairDataListInstances;
    private object lockObj;
    public static ObjectsFactory Default { get; }
    private static ObjectsFactory();
    public CrosshairDataList CreateCrosshairDataList();
    public LineStrip CreateLineStrip();
    public RefinedPoint Create();
    public RefinedPoint Create(ISeriesPoint point);
    public RefinedPoint Create(double argument, double value);
    public RefinedPoint Create(ISeriesPoint point, double argument, double value);
    public RefinedPoint Create(ISeriesPoint point, double argument, IList`1<double> values);
    public RefinedPoint Create(ISeriesPoint point, double argument, IList`1<double> values, CorePointState state);
    public RefinedPoint Create(ISeriesPoint point, double argumentX, double argumentY, IList`1<double> values);
    public RefinedPoint Create(ISeriesPoint point, double argument, IList`1<double> values, IList`1<double> errorBarsValues);
    public RefinedPoint Create(ISeriesPoint point, double argumentX, double argumentY, IList`1<double> values, CorePointState state);
    public RefinedPoint Create(ISeriesPoint point, double argument, IList`1<double> values, IList`1<double> errorBarsValues, CorePointState state);
    public RefinedPoint CreateFromRefined(RefinedPoint point, double argument, IList`1<double> values);
    public sealed virtual void Dispose();
    public void Free(CrosshairDataList cdl);
    public static ObjectsFactory get_Default();
}
public static class DevExpress.Charts.Native.ObjectToDoubleConverter : object {
    public static double ObjectToDouble(object obj);
}
public static class DevExpress.Charts.Native.ObjectToStringConversion : object {
    public static string ObjectToString(object obj);
    public static object StringToObject(string str);
}
public class DevExpress.Charts.Native.ObjectTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[AttributeUsageAttribute("32767")]
public class DevExpress.Charts.Native.OldApiAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; private set; }
    public OldApiAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
}
public class DevExpress.Charts.Native.OnLoadEndUpdateInfo : ChartUpdateInfoBase {
    public OnLoadEndUpdateInfo(object sender);
}
internal class DevExpress.Charts.Native.OnLoadEndUpdateProcessor : TypedUpdateProcessor`1<OnLoadEndUpdateInfo> {
    private SeriesController controller;
    public OnLoadEndUpdateProcessor(SeriesController controller);
    protected virtual IList`1<IUpdateAction> TypedProcess(OnLoadEndUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.OptimizedLineStrip : LineStrip {
    private List`1<GRealRect2D> rectangles;
    private bool optimizedByXCoordinate;
    public List`1<GRealRect2D> Rectangles { get; }
    public bool OptimizedByXCoordinate { get; }
    public OptimizedLineStrip(bool optimizedByXCoordinate);
    public List`1<GRealRect2D> get_Rectangles();
    public bool get_OptimizedByXCoordinate();
    public virtual LineStrip CreateInstance();
    public virtual LineStrip CreateUniqueStrip();
}
public abstract class DevExpress.Charts.Native.OutliersDataMemberContainer`1 : object {
    private string dataMember;
    private List`1<T> values;
    private DataBrowser browser;
    private RelatedListBrowser listBrowser;
    public IList`1<T> Values { get; }
    public bool SupportEmptyValue { get; }
    public bool IsEmpty { get; }
    public string DataMember { get; }
    public object BoxedValue { get; }
    public OutliersDataMemberContainer`1(string dataMember);
    public sealed virtual IList`1<T> get_Values();
    public sealed virtual bool get_SupportEmptyValue();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual string get_DataMember();
    public sealed virtual object get_BoxedValue();
    private void AddValue(object currentValue);
    protected abstract virtual bool IsEmptyValue(T value);
    protected abstract virtual T ParseValue(object value);
    public sealed virtual void Read();
    public sealed virtual bool CreateDataBrowser(BindingEnvironment environment);
}
public class DevExpress.Charts.Native.OutliersDateTimeDataMemberContainer : OutliersDataMemberContainer`1<DateTime> {
    public OutliersDateTimeDataMemberContainer(string dataMember);
    protected virtual bool IsEmptyValue(DateTime value);
    protected virtual DateTime ParseValue(object value);
}
public class DevExpress.Charts.Native.OutliersNumericDataMemberContainer : OutliersDataMemberContainer`1<double> {
    public OutliersNumericDataMemberContainer(string dataMember);
    protected virtual bool IsEmptyValue(double value);
    protected virtual double ParseValue(object value);
}
public class DevExpress.Charts.Native.OutliersTimeSpanDataMemberContainer : OutliersDataMemberContainer`1<TimeSpan> {
    public OutliersTimeSpanDataMemberContainer(string dataMember);
    protected virtual bool IsEmptyValue(TimeSpan value);
    protected virtual TimeSpan ParseValue(object value);
}
public class DevExpress.Charts.Native.OutOfBoundsChecker : object {
    private IAxisData axis;
    private bool isHorizontal;
    private MinMaxValues bound;
    private MinMaxValues expandedBound;
    private IMinMaxValues range;
    public IAxisData Axis { get; }
    public bool NeedCorrection { get; }
    public OutOfBoundsChecker(IAxisData axis, bool isHorizontal, DXRectangle rangeBounds, IMinMaxValues range);
    public IAxisData get_Axis();
    public bool get_NeedCorrection();
    private MinMaxValues GetWholeRangeBound(IAxisData axis, int minBound, int maxBound);
    private MinMaxValues GetVertical(GRealRect2D bounds);
    private MinMaxValues GetHorizontal(GRealRect2D bounds);
    private MinMaxValues CalculateRange(bool reverse);
    public void CheckOutOfBounds(GRealRect2D bounds);
    public MinMaxValues GetCorrectedWholeRange();
}
public class DevExpress.Charts.Native.PaneAreaSide : object {
    private IScaleBreakOptions options;
    private bool isInner;
    public IScaleBreakOptions Options { get; }
    public bool IsInner { get; }
    public PaneAreaSide(IScaleBreakOptions options, bool isInner);
    public static PaneAreaSide CreateInner(IScaleBreakOptions options);
    public static PaneAreaSide CreateOuter();
    public IScaleBreakOptions get_Options();
    public bool get_IsInner();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.PaneAxesContainer : object {
    private IPane pane;
    private PaneAxesManager axesManager;
    private AxisContainer axisContainerX;
    private AxisContainer axisContainerY;
    public IPane Pane { get; }
    public IZoomablePane ZoomablePane { get; }
    public IList`1<IAxisData> AxesX { get; }
    public IList`1<IAxisData> AxesY { get; }
    public IList`1<IAxisData> SecondaryAxesX { get; }
    public IList`1<IAxisData> SecondaryAxesY { get; }
    public IList`1<IAxisData> TotalSecondaryAxesX { get; }
    public IList`1<IAxisData> TotalSecondaryAxesY { get; }
    public IAxisData PrimaryAxisX { get; }
    public IAxisData PrimaryAxisY { get; }
    public IEnumerable`1<IAxisData> Axes { get; }
    public IEnumerable`1<AxisContainer> AxisContainers { get; }
    public PaneAxesContainer(IPane pane);
    public PaneAxesContainer(IPane pane, IList`1<IAxisData> axesX, IList`1<IAxisData> axesY, IList`1<IAxisData> allSecondaryAxesX, IList`1<IAxisData> allSecondaryAxesY);
    public PaneAxesContainer(IPane pane, IAxisData axisX, IAxisData axisY);
    public IPane get_Pane();
    public IZoomablePane get_ZoomablePane();
    public IList`1<IAxisData> get_AxesX();
    public IList`1<IAxisData> get_AxesY();
    public IList`1<IAxisData> get_SecondaryAxesX();
    public IList`1<IAxisData> get_SecondaryAxesY();
    public IList`1<IAxisData> get_TotalSecondaryAxesX();
    public IList`1<IAxisData> get_TotalSecondaryAxesY();
    public IAxisData get_PrimaryAxisX();
    public IAxisData get_PrimaryAxisY();
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.PaneAxesContainer/<get_Axes>d__25")]
public IEnumerable`1<IAxisData> get_Axes();
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.PaneAxesContainer/<get_AxisContainers>d__27")]
public virtual IEnumerable`1<AxisContainer> get_AxisContainers();
    public void RangeLimitsUpdated();
    public PaneAxesManager GetManager();
}
public class DevExpress.Charts.Native.PaneAxesContainer3D : PaneAxesContainer {
    private AxisContainer axisContainerZ;
    public IEnumerable`1<AxisContainer> AxisContainers { get; }
    public PaneAxesContainer3D(IPane pane, IList`1<IAxisData> axesX, IList`1<IAxisData> axesY, IList`1<IAxisData> axesZ, IList`1<IAxisData> allSecondaryAxesX, IList`1<IAxisData> allSecondaryAxesY, IList`1<IAxisData> allSecondaryAxesZ);
    public PaneAxesContainer3D(IPane pane, IAxisData axisX, IAxisData axisY, IAxisData axisZ);
    public virtual IEnumerable`1<AxisContainer> get_AxisContainers();
}
public class DevExpress.Charts.Native.PaneAxesContainerRepository : object {
    private SortedList`2<IPane, PaneAxesContainer> repository;
    public IList`1<PaneAxesContainer> Values { get; }
    public PaneAxesContainerRepository(IAxisData primaryAxisX, IAxisData primaryAxisY, IEnumerable`1<IAxisData> secondaryAxesX, IEnumerable`1<IAxisData> secondaryAxesY, IList`1<IPane> actualPanes, IEnumerable`1<IRefinedSeries> seriesList);
    public IList`1<PaneAxesContainer> get_Values();
    private IList`1<IAxisData> CreateAxesList(IAxisData primaryAxis, IEnumerable`1<IAxisData> secondaryAxis);
    private PaneAxesDictionary MappingPaneToAxesViaSeries(IList`1<IAxisData> axesX, IList`1<IAxisData> axesY, IList`1<IPane> actualPanes, IEnumerable`1<IRefinedSeries> seriesList);
    public PaneAxesContainer GetContainer(IPane pane);
    public void UpdateRanges();
}
public class DevExpress.Charts.Native.PaneAxesManager : object {
    public static double DefaultMaximumZoomPercent;
    private PaneAxesContainer container;
    private IZoomablePane zoomablePane;
    private bool ZoomableByY { get; }
    private bool ZoomableByX { get; }
    private bool ScrollableByY { get; }
    private bool ScrollableByX { get; }
    private IAxisData PrimaryAxisY { get; }
    private IAxisData PrimaryAxisX { get; }
    public bool ScrollingEnabled { get; }
    public IZoomablePane ZoomablePane { get; }
    public PaneAxesManager(PaneAxesContainer container, IZoomablePane zoomablePane);
    private bool get_ZoomableByY();
    private bool get_ZoomableByX();
    private bool get_ScrollableByY();
    private bool get_ScrollableByX();
    private IAxisData get_PrimaryAxisY();
    private IAxisData get_PrimaryAxisX();
    public bool get_ScrollingEnabled();
    public IZoomablePane get_ZoomablePane();
    private static double ClampPosition(double value);
    private static double CalcAxisOffset(IAxisData axis, int step, int size, bool accountAxisReverse);
    private static void Scroll(IAxisData axis, double offset);
    private static bool ScrollTo(IAxisData axis, double position);
    private static IMinMaxValues TransformForward(IAxisData axis, IMinMaxValues minMaxValue);
    private static IMinMaxValues TransformBackward(IAxisData axis, IMinMaxValues minMaxValue);
    private static object InternalToNative(AxisScaleTypeMap scaleMap, double internalValue);
    public static void SetMinMax(IAxisData axis, double min, double max);
    public static bool CanZoomOutAxis(IAxisData axis);
    public static bool CanScrollAxis(IAxisData axis);
    public static double GetScrollBarPosition(IAxisData axis);
    public static double GetScrollBarRelativeSize(IAxisData axis);
    public static double GetZoomPercent(int delta);
    public static NavigationType GetNavigationType(int delta);
    private double GetMaximumZoomPercent(IAxisData axis);
    private double GetCenterInPercent(double boundsMin, double boundsMax, double min, double max);
    private void BeginZooming(ZoomingKind zoomingKind);
    private void FinishZooming(RangesSnapshot rangesSnapshot, NavigationType navigationType, IAxisData axisX, IAxisData axisY, bool synchronizeAxes);
    private void FinishScrolling(ScrollingOrientation scrollingOrientation, RangesSnapshot rangesSnapshot, NavigationType navigationType, IAxisData axisX, IAxisData axisY);
    private bool PerformZoom(IAxisData axis, IMinMaxValues range);
    private bool Zoom(DXRectangle bounds, DXPoint center, double xZoomPercent, double yZoomPercent, bool zoomToCenter);
    private void Zoom(IAxisData axis, double zoomPercent);
    private bool Zoom(IAxisData axis, double position, double zoomPercent, bool zoomToCenter);
    private void ResetZoom(IAxisData axis);
    private void SetAxisZoom(double factor, NavigationType navigationType, IAxisData axis);
    private void SetRange(IAxisData axis, double position1, double position2);
    private void SetAxisRange(double position1, double position2, NavigationType navigationType, IAxisData axis);
    private bool IsAxisZoomingEnabled(IAxisData axis);
    private IAxisData GetHorizontalAxis(bool isEnabledX, bool isEnabledY);
    private IAxisData GetVerticalAxis(bool isEnabledX, bool isEnabledY);
    internal void ZoomGesture(DXPoint center, double axisXMin, double axisXMax, double axisYMin, double axisYMax, double xZoomPercent, double yZoomPercent, ZoomingKind zoomingKind, NavigationType navigationType, bool dependentValueRange);
    public void Zoom(DXPoint center, double zoomPercent, ZoomingKind zoomingKind, NavigationType navigationType, bool zoomToCenter);
    public void Zoom(IAxisData axis, DXPoint center, double zoomPercent, ZoomingKind zoomingKind, NavigationType navigationType);
    public void Zoom(int delta, ZoomingKind zoomingKind);
    public void ZoomIn(DXRectangle rect);
    public void UndoZoom(ZoomItem zoomItem);
    public bool ResetZoom();
    public bool CanZoomInAxis(IAxisData axis);
    public bool CanZoomIn();
    public bool CanZoomOut();
    public bool CanScroll(int dx, int dy, bool useReverse);
    public bool CanScrollTo(ScrollingOrientation orientation);
    public bool Scroll(int dx, int dy, bool useReverse, NavigationType navigationType);
    public bool ScrollTo(double position, ScrollingOrientation orientation, NavigationType navigationType);
    public void SetAxisXRange(double position1, double position2, NavigationType navigationType);
    public void SetAxisYRange(double position1, double position2, NavigationType navigationType);
    public void SetAxisXZoom(double factor, NavigationType navigationType);
    public void SetAxisYZoom(double factor, NavigationType navigationType);
}
public static class DevExpress.Charts.Native.PatternConstants : object {
    private static HashSet`1<string> predefinedConstants;
    public static string Argument;
    public static string ArgumentX;
    public static string ArgumentY;
    public static string Value;
    public static string ValueZ;
    public static string PercentValue;
    public static string SeriesName;
    public static string SeriesGroup;
    public static string Weight;
    public static string Value1;
    public static string Value2;
    public static string PercentValue1;
    public static string PercentValue2;
    public static string HighValue;
    public static string LowValue;
    public static string OpenValue;
    public static string CloseValue;
    public static string PointHint;
    public static string ValueDuration;
    public static string ValueDurationDays;
    public static string ValueDurationHours;
    public static string ValueDurationMinutes;
    public static string ValueDurationSeconds;
    public static string ValueDurationMilliseconds;
    public static string TotalValue;
    public static string DurationFormatDays;
    public static string DurationFormatHours;
    public static string DurationFormatMinutes;
    public static string DurationFormatSeconds;
    public static string DurationFormatMilliseconds;
    public static string DateTimeFormatQuarter;
    public static string IndicatorName;
    public static string IndicatorMovingAverageValue;
    public static string MovingAverageCrosshairIndicatorLowerEnvelope;
    public static string MovingAverageCrosshairIndicatorUpperEnvelope;
    public static string ErrorBarIndicatorTop;
    public static string ErrorBarIndicatorBottom;
    public static string IndicatorMACDSignal;
    public static string OpeningBracket;
    public static string ClosingBracket;
    public static string OverflowSymbol;
    public static string UnderflowSymbol;
    public static string IntervalArgumentMin;
    public static string IntervalArgumentMax;
    public static string BoxPlotMin;
    public static string BoxPlotQuartile1;
    public static string BoxPlotMedian;
    public static string BoxPlotMean;
    public static string BoxPlotQuartile3;
    public static string BoxPlotMax;
    public static string AbsoluteValue;
    private static PatternConstants();
    private static List`1<FieldInfo> GetConstants(Type type);
    public static bool IsPredefinedConstant(string constant);
}
public abstract class DevExpress.Charts.Native.PatternDataProvider : object {
    private object context;
    public object Context { get; public set; }
    public object get_Context();
    public void set_Context(object value);
    protected abstract virtual bool TryGetValue(Object& value);
    protected virtual void SetContext(object value);
    public abstract virtual bool CheckContext(object value);
    public bool TryGetText(string format, String& text);
}
public class DevExpress.Charts.Native.PatternEditorValuesSource : object {
    private static double doubleValue;
    private TimeSpan timeSpanValue;
    private object argument;
    private object value;
    private object valueDuration;
    private string series;
    private object seriesGroup;
    private object intervalArgumentMin;
    private object intervalArgumentMax;
    private object DevExpress.Charts.Native.IPatternValuesSource.Argument { get; }
    private object DevExpress.Charts.Native.IPatternValuesSource.Value { get; }
    private object DevExpress.Charts.Native.IPatternValuesSource.Value1 { get; }
    private object DevExpress.Charts.Native.IPatternValuesSource.Value2 { get; }
    private object DevExpress.Charts.Native.IPatternValuesSource.ValueDuration { get; }
    private double DevExpress.Charts.Native.IPatternValuesSource.PercentValue { get; }
    private double DevExpress.Charts.Native.IPatternValuesSource.Weight { get; }
    private double DevExpress.Charts.Native.IPatternValuesSource.LowValue { get; }
    private double DevExpress.Charts.Native.IPatternValuesSource.HighValue { get; }
    private double DevExpress.Charts.Native.IPatternValuesSource.OpenValue { get; }
    private double DevExpress.Charts.Native.IPatternValuesSource.CloseValue { get; }
    private object DevExpress.Charts.Native.IPatternValuesSource.PointHint { get; }
    private string DevExpress.Charts.Native.IPatternValuesSource.Series { get; }
    private object DevExpress.Charts.Native.IPatternValuesSource.SeriesGroup { get; }
    private double DevExpress.Charts.Native.IPatternValuesSource.TotalValue { get; }
    private object DevExpress.Charts.Native.IPatternValuesSource.IntervalArgumentMin { get; }
    private object DevExpress.Charts.Native.IPatternValuesSource.IntervalArgumentMax { get; }
    private string DevExpress.Charts.Native.IPatternValuesSource.OpeningBracket { get; }
    private string DevExpress.Charts.Native.IPatternValuesSource.ClosingBracket { get; }
    private string DevExpress.Charts.Native.IPatternValuesSource.UnderflowSymbol { get; }
    private string DevExpress.Charts.Native.IPatternValuesSource.OverflowSymbol { get; }
    public PatternEditorValuesSource(object argument, object value);
    public PatternEditorValuesSource(object argument, object value, string series, object seriesGroup);
    public PatternEditorValuesSource(IMinMaxValues values);
    public PatternEditorValuesSource(object axisValue);
    private sealed virtual override object DevExpress.Charts.Native.IPatternValuesSource.get_Argument();
    private sealed virtual override object DevExpress.Charts.Native.IPatternValuesSource.get_Value();
    private sealed virtual override object DevExpress.Charts.Native.IPatternValuesSource.get_Value1();
    private sealed virtual override object DevExpress.Charts.Native.IPatternValuesSource.get_Value2();
    private sealed virtual override object DevExpress.Charts.Native.IPatternValuesSource.get_ValueDuration();
    private sealed virtual override double DevExpress.Charts.Native.IPatternValuesSource.get_PercentValue();
    private sealed virtual override double DevExpress.Charts.Native.IPatternValuesSource.get_Weight();
    private sealed virtual override double DevExpress.Charts.Native.IPatternValuesSource.get_LowValue();
    private sealed virtual override double DevExpress.Charts.Native.IPatternValuesSource.get_HighValue();
    private sealed virtual override double DevExpress.Charts.Native.IPatternValuesSource.get_OpenValue();
    private sealed virtual override double DevExpress.Charts.Native.IPatternValuesSource.get_CloseValue();
    private sealed virtual override object DevExpress.Charts.Native.IPatternValuesSource.get_PointHint();
    private sealed virtual override string DevExpress.Charts.Native.IPatternValuesSource.get_Series();
    private sealed virtual override object DevExpress.Charts.Native.IPatternValuesSource.get_SeriesGroup();
    private sealed virtual override double DevExpress.Charts.Native.IPatternValuesSource.get_TotalValue();
    private sealed virtual override object DevExpress.Charts.Native.IPatternValuesSource.get_IntervalArgumentMin();
    private sealed virtual override object DevExpress.Charts.Native.IPatternValuesSource.get_IntervalArgumentMax();
    private sealed virtual override string DevExpress.Charts.Native.IPatternValuesSource.get_OpeningBracket();
    private sealed virtual override string DevExpress.Charts.Native.IPatternValuesSource.get_ClosingBracket();
    private sealed virtual override string DevExpress.Charts.Native.IPatternValuesSource.get_UnderflowSymbol();
    private sealed virtual override string DevExpress.Charts.Native.IPatternValuesSource.get_OverflowSymbol();
    private sealed virtual override PatternDataProvider DevExpress.Charts.Native.IPatternHolder.GetDataProvider(string patternConstant);
}
public class DevExpress.Charts.Native.PatternParser : object {
    private string template;
    private IPatternHolder patternHolder;
    private List`1<PatternFragment> fragments;
    public PatternParser(string pattern, IPatternHolder patternHolder);
    public static string FullStackedToolTipPattern(string argumentFormat, string valueFormat);
    private void Parse();
    public void SetContext(Object[] contexts);
    public string GetText();
}
public static class DevExpress.Charts.Native.PatternUtils : object {
    private static string DefaultTimeSpanFormatString;
    public static string DefaultDateTimeFormat;
    public static string DefaultTimeSpanFormat;
    [CompilerGeneratedAttribute]
private static string <QuarterFormat>k__BackingField;
    public static string QuarterFormat { get; public set; }
    private static PatternUtils();
    [CompilerGeneratedAttribute]
public static string get_QuarterFormat();
    [CompilerGeneratedAttribute]
public static void set_QuarterFormat(string value);
    private static int ExtractElement(string pattern, String& element);
    private static string FormatTimeSpan(TimeSpan value, string format);
    private static bool IsIntervalLabel(IScaleOptionsBase scaleOptions);
    public static string GetDefaultArgumentPattern(string defaultArgFormatWithColon);
    public static string SelectFormat(DateTimeGridAlignmentNative gridAlignment);
    public static string GetTimeSpanFormat();
    public static List`1<string> SplitString(string splittingString, char leftSeparator, char rightSeparator);
    public static bool PrepareFragment(string fragment, String& patternConstant, String& format);
    public static int GetPrecision(double value, Int32& integralPartLength);
    private static int GetDigitsForRounding(IAxisData axis);
    private static double RoundNativeDoubleAxisValue(IAxisData axis, double value);
    public static object RoundNativeAxisValue(IAxisData axis, object value);
    public static object RoundUpNativeAxisValue(IAxisData axis, object value);
    public static List`1<string> ParsePattern(string pattern);
    public static string ReplacePlaceholder(string pattern, string oldPlaceholder, string newPlaceholder);
    public static string ReplacePlaceholder(string pattern, string oldPlaceholder, string newPlaceholder1, string newPlaceholder2);
    public static string ReplacePlaceholder(string pattern, string oldPlaceholder, string newPlaceholder1, string newPlaceholder2, string separator);
    public static string GetMinValuePlaceholder(RefinedPoint refinedPoint, Scale valueScaleType);
    public static string GetMaxValuePlaceholder(RefinedPoint refinedPoint, Scale valueScaleType);
    public static string Format(object value, string format);
    public static string GetArgumentFormat(string pattern);
    public static string ConstructDefaultPattern(IAxisData axis, string argumentPattern);
    public static string ConstructDefaultIntervalPattern(IAxisData axis);
    public static string ConstructDefaultUnderflowPattern(IAxisData axis);
    public static string ConstructDefaultOverflowPattern(IAxisData axis);
    public static IEnumerable`1<string> GetCustomDateTimeFormats();
}
public class DevExpress.Charts.Native.PercentageErrorBarsCalculator : ErrorBarsCalculator {
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, double percent);
    public void Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, double percent);
}
public class DevExpress.Charts.Native.PercentMaxValueFilterBehavior : ValueThresholdFilterBehavior {
    protected virtual IList`1<RefinedPoint> FilterPoints(IList`1<RefinedPoint> initialPoints, double thresholdValue);
}
public class DevExpress.Charts.Native.PieNormalizedValuesCalculator : NormalizedValuesCalculator {
    public PieNormalizedValuesCalculator(ISeries series);
    protected virtual Double[] CalculateNormValues();
}
internal class DevExpress.Charts.Native.PointArgument : object {
    private double argument;
    [CompilerGeneratedAttribute]
private int <OccurrenceCount>k__BackingField;
    public double Argument { get; }
    public int OccurrenceCount { get; public set; }
    public PointArgument(double argument);
    public double get_Argument();
    [CompilerGeneratedAttribute]
public int get_OccurrenceCount();
    [CompilerGeneratedAttribute]
public void set_OccurrenceCount(int value);
}
internal class DevExpress.Charts.Native.PointArgumentComparer : Comparer`1<PointArgument> {
    private static double Eps;
    public virtual int Compare(PointArgument argument1, PointArgument argument2);
}
public class DevExpress.Charts.Native.PointInteractionCollection : SortedCollection`1<IPointInteraction> {
    private IPointInteraction System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Count { get; }
    private bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.IsReadOnly { get; }
    public PointInteractionCollection(Comparer`1<IPointInteraction> comparer);
    private sealed virtual override IPointInteraction System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.set_Item(int index, IPointInteraction value);
    private sealed virtual override int System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Add(IPointInteraction item);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Contains(IPointInteraction item);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.CopyTo(IPointInteraction[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.IndexOf(IPointInteraction item);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.Insert(int index, IPointInteraction item);
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Remove(IPointInteraction item);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.RemoveAt(int index);
}
public static class DevExpress.Charts.Native.PointOptionsHelper : object {
    public static string DefaultPattern;
    public static PointViewKind DefaultPointView;
    public static string ConvertToPattern(PointViewKind pointView);
    public static PointViewKind ConvertToPointView(string pattern);
}
public class DevExpress.Charts.Native.PointPatternDataProvider : PatternDataProvider {
    private string patternConstant;
    private AxisScaleTypeMap AxisScaleTypeMap;
    protected string PatternConstant { get; }
    protected RefinedPoint RefinedPoint { get; }
    protected ISeriesPoint SeriesPoint { get; }
    public PointPatternDataProvider(string patternConstant, AxisScaleTypeMap axisScaleTypeMap);
    protected string get_PatternConstant();
    protected RefinedPoint get_RefinedPoint();
    protected ISeriesPoint get_SeriesPoint();
    private object GetDurationValue(RefinedPoint point);
    private TimeSpan GetTimeSpanDuration(RefinedPoint point);
    protected virtual object GetValueFormSeriesPoint();
    protected virtual object GetValueFromRefinedPoint();
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public enum DevExpress.Charts.Native.PointPositionInSeries : Enum {
    public int value__;
    public static PointPositionInSeries Left;
    public static PointPositionInSeries Center;
    public static PointPositionInSeries Right;
}
public class DevExpress.Charts.Native.PointProjectionOnAxis : ValueType {
    private IAxisData axis;
    private double value;
    public IAxisData Axis { get; }
    public double Value { get; }
    public PointProjectionOnAxis(IAxisData axis, double value);
    public IAxisData get_Axis();
    public double get_Value();
    public object CalculateNativeValue();
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.PointProjectionsForPane : object {
    private IPane pane;
    private List`1<PointProjectionOnAxis> axesXValues;
    private List`1<PointProjectionOnAxis> axesYValues;
    public List`1<PointProjectionOnAxis> AxesXValues { get; }
    public List`1<PointProjectionOnAxis> AxesYValues { get; }
    public PointProjectionsForPane(IPane pane, InternalCoordinates cursorCoordinates);
    public List`1<PointProjectionOnAxis> get_AxesXValues();
    public List`1<PointProjectionOnAxis> get_AxesYValues();
    private double GetValueByAxis(IAxisData axis, List`1<PointProjectionOnAxis> axesValues);
    private void SetValues(List`1<AxisValuePair> axesXValues, List`1<AxisValuePair> axesYValues);
    public double GetValueByAxisY(IAxisData axis);
    public double GetArgumentByAxisX(IAxisData axis);
}
public class DevExpress.Charts.Native.PointsCountThresholdFilter : PointsFilter {
    private IList`1<RefinedPoint> filteredPoints;
    private SurfaceDataSourceMode dataMode;
    private int thresholdPointsCount;
    private ISurfaceSeriesView SurfaceView { get; }
    public PointsCountThresholdFilter(RefinedSeries refinedSeries);
    private ISurfaceSeriesView get_SurfaceView();
    private bool IsEnabled();
    private GridPointsCalculatorBase CreateGridPointsCalculator();
    private void ProvideGridSizeToSurfaceView(GridPointsCalculatorBase gridCalculator);
    protected virtual IList`1<RefinedPoint> Recalculate(IList`1<RefinedPoint> initialPoints);
    protected virtual IList`1<RefinedPoint> GetCachedPoints();
    public virtual void ClearCache();
    public virtual bool Update();
    public virtual PointsFilterUpdateInfo Update(PointsFilterUpdateInfo updateInfo);
}
public abstract class DevExpress.Charts.Native.PointsFilter : object {
    private RefinedSeries refinedSeries;
    [CompilerGeneratedAttribute]
private bool <Enable>k__BackingField;
    protected IXYSeriesView XYSeriesView { get; }
    protected IAxisData AxisDataX { get; }
    protected IAxisData AxisDataY { get; }
    protected IAxisData AxisDataZ { get; }
    protected RefinedSeries RefinedSeries { get; }
    public bool Enable { get; protected set; }
    public bool AffectsMapping { get; }
    protected PointsFilter(RefinedSeries refinedSeries);
    protected IXYSeriesView get_XYSeriesView();
    protected IAxisData get_AxisDataX();
    protected IAxisData get_AxisDataY();
    protected IAxisData get_AxisDataZ();
    protected RefinedSeries get_RefinedSeries();
    [CompilerGeneratedAttribute]
public bool get_Enable();
    [CompilerGeneratedAttribute]
protected void set_Enable(bool value);
    public virtual bool get_AffectsMapping();
    protected abstract virtual IList`1<RefinedPoint> Recalculate(IList`1<RefinedPoint> initialPoints);
    protected abstract virtual IList`1<RefinedPoint> GetCachedPoints();
    public virtual IList`1<RefinedPoint> GetFilteredPoints(IList`1<RefinedPoint> initialPoints, bool needProcessNewPoint);
    public abstract virtual void ClearCache();
    public abstract virtual bool Update();
    public abstract virtual PointsFilterUpdateInfo Update(PointsFilterUpdateInfo updateInfo);
}
public enum DevExpress.Charts.Native.PointsFilterType : Enum {
    public int value__;
    public static PointsFilterType TopN;
    public static PointsFilterType MoreOrEqualValue;
    public static PointsFilterType MoreOrEqualPercentValue;
}
public class DevExpress.Charts.Native.PointsFilterUpdateInfo : object {
    private SortedArgumentRefinedPointCollection points;
    private double firstUpdatedArgument;
    private double lastUpdatedArgument;
    [CompilerGeneratedAttribute]
private bool <IsRemoveAction>k__BackingField;
    public bool IsRemoveAction { get; }
    public SortedArgumentRefinedPointCollection Points { get; }
    public double FirstUpdatedArgument { get; }
    public double LastUpdatedArgument { get; }
    public PointsFilterUpdateInfo(SortedArgumentRefinedPointCollection points);
    public PointsFilterUpdateInfo(SortedArgumentRefinedPointCollection points, double firstUpdatedArgument, double lastUpdatedArgument);
    public PointsFilterUpdateInfo(SortedArgumentRefinedPointCollection points, IList`1<RefinedPoint> affectedPoints, bool isRemoveAction);
    [CompilerGeneratedAttribute]
public bool get_IsRemoveAction();
    public SortedArgumentRefinedPointCollection get_Points();
    public double get_FirstUpdatedArgument();
    public double get_LastUpdatedArgument();
}
public class DevExpress.Charts.Native.PointsProcessor : object {
    private CollectionManager realCollections;
    private IList`1<ScaleCountersCalculatorBase> scaleCalculators;
    private List`1<PointsFilter> filters;
    private RefinedSeries refinedSeries;
    private Dictionary`2<object, SortedArgumentRefinedPointCollection> sortedPointsCache;
    private CollectionManager randomCollections;
    private BasePointProcessor pointProcessor;
    private RandomPointsState randomPointsState;
    private Nullable`1<bool> hasPositivePoint;
    protected ISeries Series { get; }
    private ISeriesView SeriesView { get; }
    protected RefinedSeries RefinedSeries { get; }
    internal IList`1<ScaleCountersCalculatorBase> ScaleCalculators { get; }
    internal ArgumentsWithoutGapsInfo ArgumentWithoutGaps { get; }
    internal List`1<PointsFilter> ActualFilters { get; }
    public bool NoArgumentScaleTypeX { get; }
    public bool HasPositivePoints { get; }
    public CollectionManager RealCollections { get; }
    public CollectionManager RandomCollections { get; }
    public CollectionManager ActualCollectionManager { get; }
    public bool IsContainsProcessedPoints { get; }
    public bool IsContainsProcessedNotEmptyPoints { get; }
    private IPointProcessor DevExpress.Charts.Native.IPointProcessorProvider.Processor { get; }
    public PointsProcessor(RefinedSeries refinedSeries);
    protected ISeries get_Series();
    private ISeriesView get_SeriesView();
    protected RefinedSeries get_RefinedSeries();
    internal IList`1<ScaleCountersCalculatorBase> get_ScaleCalculators();
    internal ArgumentsWithoutGapsInfo get_ArgumentWithoutGaps();
    internal List`1<PointsFilter> get_ActualFilters();
    public bool get_NoArgumentScaleTypeX();
    public bool get_HasPositivePoints();
    public CollectionManager get_RealCollections();
    public CollectionManager get_RandomCollections();
    public CollectionManager get_ActualCollectionManager();
    public bool get_IsContainsProcessedPoints();
    public bool get_IsContainsProcessedNotEmptyPoints();
    private sealed virtual override IPointProcessor DevExpress.Charts.Native.IPointProcessorProvider.get_Processor();
    private void InitScaleCalculators();
    private void InitFilters();
    private void InitCollections();
    private void ClearCache();
    private void UpdateRandomPoints();
    private void InsurePointProcessor();
    private SortedArgumentRefinedPointCollection GetSortedByArgumentPoints(IList`1<RefinedPoint> intermediate);
    private PointsFilterUpdateInfo UpdateFilters(SortedArgumentRefinedPointCollection initialPoints, RefinedSeriesPointsUpdateInfo updateInfo);
    protected virtual IList`1<RefinedPoint> GetInitialPoints(bool needProcessNewPoint);
    protected virtual CollectionManager CreateCollectionManager(RefinedSeries refinedSeries);
    internal void UpdateArgumentScale();
    internal bool IsFilterEnabled();
    internal void DetectScale();
    internal void Invalidate();
    internal virtual RefinedSeriesPointsUpdateInfo UpdatePoints(SeriesPointsCollectionAction updateAction);
    internal ICollection`1<RefinedSeriesPointsUpdateInfo> UpdatePoint(IDataPoint seriesPoint);
    internal void ReplacePoint(IDataPoint seriesPoint, int indexInCollection);
    public IList`1<RefinedPoint> GetPointsForMap();
    public virtual IList`1<RefinedPoint> GetProcessedPoints();
    public SortedArgumentRefinedPointCollection GetSortedProcessedPoints();
    public virtual void UpdateData();
    public void UpdateValues();
    public bool UpdateFilters();
    public void ProcessSortingPointKeyUpdate(SeriesPointKeyNative newSortingKey, SortMode pointsSortingMode);
    public void ProcessSortingPointModeUpdate(SortMode newSortingMode, SeriesPointKeyNative sortingKey);
    public void UpdatePointsInternalArguments(IList`1<RefinedPoint> points);
}
public enum DevExpress.Charts.Native.PointsSweepDirection : Enum {
    public int value__;
    public static PointsSweepDirection Counterclockwise;
    public static PointsSweepDirection Clockwise;
}
public class DevExpress.Charts.Native.PointsValueThresholdFilter : PointsFilter {
    private IPointProcessorProvider processorProvider;
    private IList`1<RefinedPoint> filteredPoints;
    private AggregatedSeriesPoint othersSeriesPoint;
    private RefinedPoint othersPoint;
    [CompilerGeneratedAttribute]
private double <ThresholdValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowOthers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OthersArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsFilterType <FilterType>k__BackingField;
    private double ThresholdValue { get; private set; }
    private bool ShowOthers { get; private set; }
    private string OthersArgument { get; private set; }
    private PointsFilterType FilterType { get; private set; }
    public bool AffectsMapping { get; }
    public PointsValueThresholdFilter(RefinedSeries series, IPointProcessorProvider processorProvider);
    [CompilerGeneratedAttribute]
private double get_ThresholdValue();
    [CompilerGeneratedAttribute]
private void set_ThresholdValue(double value);
    [CompilerGeneratedAttribute]
private bool get_ShowOthers();
    [CompilerGeneratedAttribute]
private void set_ShowOthers(bool value);
    [CompilerGeneratedAttribute]
private string get_OthersArgument();
    [CompilerGeneratedAttribute]
private void set_OthersArgument(string value);
    [CompilerGeneratedAttribute]
private PointsFilterType get_FilterType();
    [CompilerGeneratedAttribute]
private void set_FilterType(PointsFilterType value);
    public virtual bool get_AffectsMapping();
    private void UpdateOthersPoint();
    private ValueThresholdFilterBehavior CreateBehavior();
    private IPointsFilterOptions GetOptions();
    private IList`1<RefinedPoint> FilterPoints(IList`1<RefinedPoint> initialPoints);
    private Double[] CalculateSum(IList`1<RefinedPoint> list);
    private void ProcessOthersPoint(IPointProcessor processor, List`1<AxisScaleTypeMap> argumentMaps, AxisScaleTypeMap valueMap);
    protected virtual IList`1<RefinedPoint> Recalculate(IList`1<RefinedPoint> initialPoints);
    protected virtual IList`1<RefinedPoint> GetCachedPoints();
    public virtual void ClearCache();
    public virtual bool Update();
    public virtual PointsFilterUpdateInfo Update(PointsFilterUpdateInfo updateInfo);
    public virtual IList`1<RefinedPoint> GetFilteredPoints(IList`1<RefinedPoint> initialPoints, bool needProcessNewPoint);
}
public enum DevExpress.Charts.Native.PointViewKind : Enum {
    public int value__;
    public static PointViewKind Argument;
    public static PointViewKind Values;
    public static PointViewKind ArgumentAndValues;
    public static PointViewKind SeriesName;
    public static PointViewKind Undefined;
}
internal class DevExpress.Charts.Native.PolynomialRegressionCalculator : object {
    public static double Hypotenuse(double a, double b);
    public Double[] Calculate(int degree, IList`1<RefinedPoint> points, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
internal class DevExpress.Charts.Native.PowerRegressionCalculator : object {
    public Tuple`2<double, double> Calculate(IList`1<RefinedPoint> points, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public static class DevExpress.Charts.Native.PredefinedTypesHelper : object {
    public static Type[] NumericTypes;
    private static PredefinedTypesHelper();
    public static bool IsAssignableFrom(Type type, Type[] types);
    public static bool IsNumericalType(Type type);
    public static bool IsDateTimeType(Type type);
    public static bool IsTimeSpanType(Type type);
}
public enum DevExpress.Charts.Native.ProcessMissingPointsModeNative : Enum {
    public int value__;
    public static ProcessMissingPointsModeNative Skip;
    public static ProcessMissingPointsModeNative InsertZeroValues;
    public static ProcessMissingPointsModeNative InsertEmptyPoints;
}
internal class DevExpress.Charts.Native.PropertyDataSourceUpdateProcessor : TypedUpdateProcessor`1<PropertyUpdateInfo> {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo updateInfo);
}
internal class DevExpress.Charts.Native.PropertyDiagramUpdateProcessor : TypedUpdateProcessor`1<PropertyUpdateInfo`1<IDiagram>> {
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo`1<IDiagram> updateInfo);
}
public class DevExpress.Charts.Native.PropertyUpdateInfo : ChartUpdateInfoBase {
    private string name;
    public string Name { get; }
    public PropertyUpdateInfo(object sender, string name);
    public string get_Name();
}
public class DevExpress.Charts.Native.PropertyUpdateInfo`1 : PropertyUpdateInfo {
    private T oldValue;
    private T newValue;
    public T OldValue { get; }
    public T NewValue { get; }
    public PropertyUpdateInfo`1(object sender, string name, T oldValue, T newValue);
    public T get_OldValue();
    public T get_NewValue();
}
public class DevExpress.Charts.Native.PropertyUpdateInfo`2 : PropertyUpdateInfo`1<T> {
    private O owner;
    public O Owner { get; }
    public PropertyUpdateInfo`2(object sender, string name, T oldValue, T newValue, O owner);
    public O get_Owner();
}
public class DevExpress.Charts.Native.QualitativeAggregatedSeriesArgumentContainer : AggregatedSeriesArgumentContainer`1<string> {
    protected Scale Scale { get; }
    protected string QualitativeArgument { get; }
    public QualitativeAggregatedSeriesArgumentContainer(object argument);
    protected virtual Scale get_Scale();
    protected virtual string get_QualitativeArgument();
    protected virtual string Convert(object value);
}
public class DevExpress.Charts.Native.QualitativeAxisRangeUpdateStrategy : RangeUpdateStrategy {
    private static NativeRange DefaultNativeRange;
    public QualitativeAxisRangeUpdateStrategy(IAxisData axis, MinMaxValues minMaxInternal, MinMaxValues minMaxRefined, ICollection`1<RefinedSeries> refinedSeries, bool scaleMapWasChanged);
    private static QualitativeAxisRangeUpdateStrategy();
    private bool IsValueObject(object value);
    protected virtual InternalRange ApplySideMargins(MinMaxValues internalValues, MinMaxValues sideMargins, bool autoCorrectionMin, bool autoCorrectionMax);
    protected virtual NativeRange GetNativeValues(MinMaxValues internalValues, MinMaxValues correctedInternalValues, IAxisRangeData range);
    protected virtual RangeSnapshot DefaultRange(IAxisRangeData range);
    protected virtual bool IncorrectRelationBetweenMinAndMax(MinMaxValues internalValues);
    protected virtual InternalRange CheckInternalValue(IAxisRangeData range, MinMaxValues internalValues);
    protected virtual MinMaxValues ConvertValuesToInternalValues(IAxisRangeData range, MinMaxValues defaultMinMax);
}
public abstract class DevExpress.Charts.Native.QualitativeDateTimeArgDateTimeValueSeriesPointDataContainer : DateTimeDateTimeSeriesPointDataContainer {
    private string stringArgument;
    protected string StringArgument { get; }
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    public QualitativeDateTimeArgDateTimeValueSeriesPointDataContainer(string stringArgument, DateTime dateTimeArgument);
    public static QualitativeDateTimeArgDateTimeValueSeriesPointDataContainer CreateContainer(string stringArgument, DateTime dateTimeArgument, DateTime[] values);
    public static QualitativeDateTimeArgDateTimeValueSeriesPointDataContainer CreateContainer(string stringArgument, DateTime dateTimeArgument, int dimension);
    protected string get_StringArgument();
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeDateTimeArgNumericValueSeriesPointDataContainer : DateTimeNumericSeriesPointDataContainer {
    private string stringArgument;
    protected string StringArgument { get; }
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    protected QualitativeDateTimeArgNumericValueSeriesPointDataContainer(string stringArgument, DateTime dateTimeArgument);
    public static QualitativeDateTimeArgNumericValueSeriesPointDataContainer CreateContainer(string stringArgument, DateTime dateTimeArgument, Double[] values);
    public static QualitativeDateTimeArgNumericValueSeriesPointDataContainer CreateContainer(string stringArgument, DateTime dateTimeArgument, int dimension);
    protected string get_StringArgument();
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.QualitativeDateTimeArgSeriesPointDataContainer : DateTimeSeriesPointDataContainer {
    private string stringArgument;
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    public QualitativeDateTimeArgSeriesPointDataContainer(string stringArgument, DateTime dateTimeArgument, int dimension);
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeDateTimeArgTimeSpanValueSeriesPointDataContainer : DateTimeTimeSpanSeriesPointDataContainer {
    private string stringArgument;
    protected string StringArgument { get; }
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    protected QualitativeDateTimeArgTimeSpanValueSeriesPointDataContainer(string stringArgument, DateTime dateTimeArgument);
    public static QualitativeDateTimeArgTimeSpanValueSeriesPointDataContainer CreateContainer(string stringArgument, DateTime dateTimeArgument, TimeSpan[] values);
    public static QualitativeDateTimeArgTimeSpanValueSeriesPointDataContainer CreateContainer(string stringArgument, DateTime dateTimeArgument, int dimension);
    protected string get_StringArgument();
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeDateTimeSeriesPointDataContainer : SeriesPointDataContainer {
    private string argument;
    protected string Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public string QualitativeArgument { get; public set; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected QualitativeDateTimeSeriesPointDataContainer(string argument);
    public static QualitativeDateTimeSeriesPointDataContainer CreateContainer(string argument, DateTime[] values);
    public static QualitativeDateTimeSeriesPointDataContainer CreateContainer(string argument, int dimension);
    protected string get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual string get_QualitativeArgument();
    public virtual void set_QualitativeArgument(string value);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeNumericArgDateTimeValueSeriesPointDataContainer : NumericDateTimeSeriesPointDataContainer {
    private string stringArgument;
    protected string StringArgument { get; }
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    protected QualitativeNumericArgDateTimeValueSeriesPointDataContainer(string stringArgument, double doubleArgument);
    public static QualitativeNumericArgDateTimeValueSeriesPointDataContainer CreateContainer(string stringArgument, double doubleArgument, DateTime[] values);
    public static QualitativeNumericArgDateTimeValueSeriesPointDataContainer CreateContainer(string stringArgument, double doubleArgument, int dimension);
    protected string get_StringArgument();
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeNumericArgNumericValueSeriesPointDataContainer : NumericNumericSeriesPointDataContainer {
    private string stringArgument;
    protected string StringArgument { get; }
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    protected QualitativeNumericArgNumericValueSeriesPointDataContainer(string stringArgument, double doubleArgument);
    public static QualitativeNumericArgNumericValueSeriesPointDataContainer CreateContainer(string stringArgument, double doubleArgument, Double[] values);
    public static QualitativeNumericArgNumericValueSeriesPointDataContainer CreateContainer(string stringArgument, double doubleArgument, int dimension);
    protected string get_StringArgument();
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.QualitativeNumericArgSeriesPointDataContainer : NumericSeriesPointDataContainer {
    private string stringArgument;
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    public QualitativeNumericArgSeriesPointDataContainer(string stringArgument, double doubleArgument, int dimension);
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeNumericArgTimeSpanValueSeriesPointDataContainer : NumericTimeSpanSeriesPointDataContainer {
    private string stringArgument;
    protected string StringArgument { get; }
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    protected QualitativeNumericArgTimeSpanValueSeriesPointDataContainer(string stringArgument, double doubleArgument);
    public static QualitativeNumericArgTimeSpanValueSeriesPointDataContainer CreateContainer(string stringArgument, double doubleArgument, TimeSpan[] values);
    public static QualitativeNumericArgTimeSpanValueSeriesPointDataContainer CreateContainer(string stringArgument, double doubleArgument, int dimension);
    protected string get_StringArgument();
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeNumericSeriesPointDataContainer : SeriesPointDataContainer {
    private string argument;
    protected string Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public string QualitativeArgument { get; public set; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected QualitativeNumericSeriesPointDataContainer(string argument);
    public static QualitativeNumericSeriesPointDataContainer CreateContainer(string argument, int dimension);
    public static QualitativeNumericSeriesPointDataContainer CreateContainer(string argument, Double[] values);
    protected string get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual string get_QualitativeArgument();
    public virtual void set_QualitativeArgument(string value);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.QualitativeRangeControlClientGridMapping : NumericRangeControlClientGridMappingBase {
}
public class DevExpress.Charts.Native.QualitativeSeriesPointDataContainer : SeriesPointDataContainer {
    private string argument;
    private int dimension;
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public string QualitativeArgument { get; public set; }
    public int Dimension { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    public QualitativeSeriesPointDataContainer(string argument, int dimension);
    public static SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, int dimension);
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual string get_QualitativeArgument();
    public virtual void set_QualitativeArgument(string value);
    public virtual int get_Dimension();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer SetDimension(int dimension);
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeTimeSpanArgDateTimeValueSeriesPointDataContainer : TimeSpanDateTimeSeriesPointDataContainer {
    private string stringArgument;
    protected string StringArgument { get; }
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    protected QualitativeTimeSpanArgDateTimeValueSeriesPointDataContainer(string stringArgument, TimeSpan timeSpanArgument);
    public static QualitativeTimeSpanArgDateTimeValueSeriesPointDataContainer CreateContainer(string stringArgument, TimeSpan timeSpanArgument, DateTime[] values);
    public static QualitativeTimeSpanArgDateTimeValueSeriesPointDataContainer CreateContainer(string stringArgument, TimeSpan timeSpanArgument, int dimension);
    protected string get_StringArgument();
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeTimeSpanArgNumericValueSeriesPointDataContainer : TimeSpanNumericSeriesPointDataContainer {
    private string stringArgument;
    protected string StringArgument { get; }
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    protected QualitativeTimeSpanArgNumericValueSeriesPointDataContainer(string stringArgument, TimeSpan timeSpanArgument);
    public static QualitativeTimeSpanArgNumericValueSeriesPointDataContainer CreateContainer(string stringArgument, TimeSpan timeSpanArgument, Double[] values);
    public static QualitativeTimeSpanArgNumericValueSeriesPointDataContainer CreateContainer(string stringArgument, TimeSpan timeSpanArgument, int dimension);
    protected string get_StringArgument();
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.QualitativeTimeSpanArgSeriesPointDataContainer : TimeSpanSeriesPointDataContainer {
    private string stringArgument;
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    public QualitativeTimeSpanArgSeriesPointDataContainer(string stringArgument, TimeSpan TimeSpanArgument, int dimension);
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeTimeSpanArgTimeSpanValueSeriesPointDataContainer : TimeSpanTimeSpanSeriesPointDataContainer {
    private string stringArgument;
    protected string StringArgument { get; }
    public string QualitativeArgument { get; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    protected QualitativeTimeSpanArgTimeSpanValueSeriesPointDataContainer(string stringArgument, TimeSpan timeSpanArgument);
    public static QualitativeTimeSpanArgTimeSpanValueSeriesPointDataContainer CreateContainer(string stringArgument, TimeSpan timeSpanArgument, TimeSpan[] values);
    public static QualitativeTimeSpanArgTimeSpanValueSeriesPointDataContainer CreateContainer(string stringArgument, TimeSpan dateTimeArgument, int dimension);
    protected string get_StringArgument();
    public virtual string get_QualitativeArgument();
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public abstract class DevExpress.Charts.Native.QualitativeTimeSpanSeriesPointDataContainer : SeriesPointDataContainer {
    private string argument;
    protected string Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public string QualitativeArgument { get; public set; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected QualitativeTimeSpanSeriesPointDataContainer(string argument);
    public static QualitativeTimeSpanSeriesPointDataContainer CreateContainer(string argument, TimeSpan[] values);
    public static QualitativeTimeSpanSeriesPointDataContainer CreateContainer(string argument, int dimension);
    protected string get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual string get_QualitativeArgument();
    public virtual void set_QualitativeArgument(string value);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.RadarAreaGeometryStripCreator : GeometryStripCreator {
    private bool closed;
    protected internal bool Closed { get; }
    protected internal bool ShouldAddEmptyStrip { get; }
    public RadarAreaGeometryStripCreator(bool closed);
    protected internal virtual bool get_Closed();
    protected internal virtual bool get_ShouldAddEmptyStrip();
    protected internal virtual IGeometryStrip CreateStrip();
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
}
public class DevExpress.Charts.Native.RadarRangeAreaGeometryStripCreator : GeometryStripCreator {
    private bool closed;
    protected internal bool Closed { get; }
    protected internal bool ShouldAddEmptyStrip { get; }
    public RadarRangeAreaGeometryStripCreator(bool closed);
    protected internal virtual bool get_Closed();
    protected internal virtual bool get_ShouldAddEmptyStrip();
    protected internal virtual IGeometryStrip CreateStrip();
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
}
public class DevExpress.Charts.Native.RaggedEdgeGeometry : EdgeGeometry {
    private static int lengthwiseStep;
    public static int CrosswiseStep;
    private List`1<int> vertices;
    private NonCryptographicRandom random;
    public List`1<int> Vertices { get; }
    public RaggedEdgeGeometry(bool shouldCutEdge);
    public List`1<int> get_Vertices();
    protected virtual IList`1<GRealPoint2D> CreateGraphicsPath(double startX, double startY, double length, bool vertical);
    public void Update(double length);
}
public class DevExpress.Charts.Native.RangeAreaGeometrySplittedStripCreator : AreaGeometrySplittedStripCreator {
    public RangeAreaGeometrySplittedStripCreator(IStripSplitter stripSplitter);
    protected virtual IGeometryStrip ProcessIntervalsStrip(IGeometryStrip strip, List`1<IGeometryStrip> strips, IList`1<RefinedPoint> points, int index, List`1<ColoredStripInfo> coloredStripInfos);
    protected virtual IGeometryStrip AddStripElementCore(IList`1<RefinedPoint> points, int index, IGeometryStrip strip);
}
public class DevExpress.Charts.Native.RangeAreaGeometryStripCreator : GeometryStripCreator {
    protected internal bool Closed { get; }
    protected internal bool ShouldAddEmptyStrip { get; }
    protected internal virtual bool get_Closed();
    protected internal virtual bool get_ShouldAddEmptyStrip();
    protected internal virtual IGeometryStrip CreateStrip();
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
}
public class DevExpress.Charts.Native.RangeAreaViewportIntersectionHolder : LineViewportIntersectionHolder {
    public RangeAreaViewportIntersectionHolder(IXYSeriesView view);
    protected virtual void AddPoints(RefinedPoint point, List`1<GRealPoint2D> pointsOfIntersection, double y, double x);
    protected virtual double GetPointValue(RefinedPoint point);
    protected virtual bool CollectViewportIntersectionCore(List`1<GRealPoint2D> pointsOfIntersection, IList`1<RefinedPoint> points, bool isLeftIntersection, int i, double y, double x);
}
public class DevExpress.Charts.Native.RangeChangedUpdateInfo : LightUpdateInfoBase {
    private bool isArgumentAxis;
    public bool IsArgumentAxis { get; }
    public RangeChangedUpdateInfo(IAxisRangeData sender, bool isArgumentAxis);
    public bool get_IsArgumentAxis();
}
internal class DevExpress.Charts.Native.RangeChangedUpdateProcessor : LightUpdateProcessorBase`1<RangeChangedUpdateInfo> {
    protected virtual IList`1<IUpdateAction> TypedProcess(RangeChangedUpdateInfo updateInfo);
}
public abstract class DevExpress.Charts.Native.RangeControlClientGridMapping : object {
    protected internal abstract virtual double CeilValue(RangeControlGridUnit unit, double value, double offset);
    protected internal abstract virtual double FloorValue(RangeControlGridUnit unit, double value, double offset);
    protected internal abstract virtual double GetGridValue(RangeControlGridUnit unit, double index);
}
public class DevExpress.Charts.Native.RangeControlClientSnapCalculator : object {
    private RangeControlClientGridMapping gridMapping;
    private double axisRangeMin;
    private double axisRangeMax;
    private RangeControlMapping rangeControlMapping;
    public RangeControlClientSnapCalculator(RangeControlClientGridMapping gridMapping, RangeControlMapping mapping);
    private double GetValue(double normalizedArgument);
    private double NormalizeArgument(double argument);
    private double Normalize(double value);
    private int GetCorrectionDirectionBySideMargin(double value);
    private double CorrectValue(double value, int correction);
    private double ShiftValue(RangeControlGridUnit unit, double value, double offset);
    public double FloorValue(RangeControlGridUnit unit, double value);
    public double CeilValue(RangeControlGridUnit unit, double value);
    public double RoundValue(RangeControlGridUnit unit, double value, bool limitByRangeBounds);
    public MinMaxValues SnapRange(double rangeMin, double rangeMax, RangeValidationBase validationBase, RangeControlGridUnit unit, bool limitValuesByWholeRange);
    public MinMaxValues SnapNormalRange(MinMaxValues range, RangeValidationBase validationBase, RangeControlGridUnit unit);
}
public class DevExpress.Charts.Native.RangeControlGridUnit : object {
    private double step;
    private double spacing;
    private double offset;
    public double Step { get; }
    public double Spacing { get; }
    public double Offset { get; }
    public double ReversedOffset { get; }
    public bool IsValid { get; }
    public RangeControlGridUnit(double spacing, double step, double offset);
    public double get_Step();
    public double get_Spacing();
    public double get_Offset();
    public double get_ReversedOffset();
    public bool get_IsValid();
}
public class DevExpress.Charts.Native.RangeControlMapping : object {
    private double sideMargin;
    private IMinMaxValues wholeRange;
    private IMinMaxValues dataRange;
    private double rangeControlSideMargin;
    private IMinMaxValues rangeControlRange;
    internal IMinMaxValues RangeControlRange { get; }
    internal IMinMaxValues DataRange { get; }
    internal double ChartSideMargin { get; }
    protected RangeControlMapping(IMinMaxValues wholeRange, double sideMargin);
    public static RangeControlMapping Create(IAxisData axisData, bool excludeSideMargins);
    internal IMinMaxValues get_RangeControlRange();
    internal IMinMaxValues get_DataRange();
    internal double get_ChartSideMargin();
    public double RangeValueToValue(double rangeValue);
    public double ValueToRangeValue(double value);
    public double ValueToNormalValue(double value);
    public double LimitMinValueByWholeRange(double minValue);
    public double LimitMaxValueByWholeRange(double maxValue);
    public double NormalValueToValue(double normalValue);
    public bool IsCorrectGridValue(double value);
}
public enum DevExpress.Charts.Native.RangeCorrectionMode : Enum {
    public int value__;
    public static RangeCorrectionMode Auto;
    public static RangeCorrectionMode Values;
    public static RangeCorrectionMode InternalValues;
}
public static class DevExpress.Charts.Native.RangeHelper : object {
    public static bool RangeDataSwitch;
    public static bool RangeCalculationSwitch;
    private static RangeHelper();
    private static void SetSideMargins(IAxisRangeData range, MinMaxValues sideMargin);
    public static void SetDefaultRange(IAxisData axis);
    public static void ThrowRangeData(IAxisData axisData, IAxisRangeData pattern, IAxisRange target);
    public static void SynchronizeVisualRange(IWholeAxisRangeData wholeRange, IVisualAxisRangeData visualRange, bool needSyncWithWholeRange);
    private static void SetMin(object minValue, double minValueInternal, IAxisRangeData range);
    private static void SetMax(object maxValue, double maxValueInternal, IAxisRangeData range);
}
public class DevExpress.Charts.Native.RangeIndexes : ValueType {
    private int index1;
    private int index2;
    public int Min { get; }
    public int Max { get; }
    public RangeIndexes(int index1, int index2);
    public int get_Min();
    public int get_Max();
}
public class DevExpress.Charts.Native.RangePointInteraction : BasePointInteraction {
    private RefinedPointsRangeValue1Comparer value1Comparer;
    private RefinedPointsRangeValue2Comparer value2Comparer;
    private List`1<RefinedPoint> pointsByValue1;
    private List`1<RefinedPoint> pointsByValue2;
    public int Count { get; }
    public virtual int get_Count();
    public void AddPoint(RefinedPoint point);
    public void RemovePoint(RefinedPoint point);
    public void Clear();
    public virtual double GetMinValue(ISeriesView seriesView);
    public virtual double GetMaxValue(ISeriesView seriesView);
    public virtual double GetMinAbsValue(ISeriesView seriesView);
}
public class DevExpress.Charts.Native.RangeSeriesContainer : SingleSeriesContainer {
    private RangePointInteraction interaction;
    public double Max { get; }
    public double Min { get; }
    public IList`1<IPointInteraction> PointInteractions { get; }
    public RangeSeriesContainer(ISeriesView view);
    public sealed virtual double get_Max();
    public sealed virtual double get_Min();
    public virtual IList`1<IPointInteraction> get_PointInteractions();
    protected virtual void InsertRefinedPoints(int seriesIndex, RefinedSeries refinedSeries);
    protected virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries refinedSeries, bool removeAll);
    protected virtual void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    public sealed virtual double GetAbsMinValue();
}
public class DevExpress.Charts.Native.RangeSnapshot : object {
    private NativeRange nativeMinMaxValues;
    private MinMaxValues internalValues;
    private MinMaxValues refinedValues;
    private MinMaxValues sideMargins;
    private MinMaxValues sideMarginsValue;
    private SideMarginSizeUnitNative sideMarginSizeUnit;
    public object MinValue { get; }
    public object MaxValue { get; }
    public double Min { get; }
    public double Max { get; }
    public MinMaxValues RefinedValues { get; }
    public MinMaxValues InternalValues { get; }
    public MinMaxValues SideMargins { get; }
    public MinMaxValues SideMarginsValue { get; }
    public RangeSnapshot(IAxisRangeData range);
    public RangeSnapshot(NativeRange range, InternalRange internalRange, IMinMaxValues refinedValues, SideMarginSizeUnitNative sideMarginSizeUnit);
    public RangeSnapshot(NativeRange range, MinMaxValues internalValues, MinMaxValues refinedValues, MinMaxValues sideMargins, MinMaxValues sideMarginsValue, SideMarginSizeUnitNative sideMarginSizeUnit);
    public object get_MinValue();
    public object get_MaxValue();
    public double get_Min();
    public double get_Max();
    public MinMaxValues get_RefinedValues();
    public MinMaxValues get_InternalValues();
    public MinMaxValues get_SideMargins();
    public MinMaxValues get_SideMarginsValue();
    public bool IsSame(RangeSnapshot range);
    public void ApplyState(IAxisRangeData range);
}
public class DevExpress.Charts.Native.RangesSnapshot : object {
    private IAxisData axisX;
    private IAxisData axisY;
    private AxisRangeInfo xAxisRange;
    private AxisRangeInfo yAxisRange;
    public IAxisData AxisX { get; }
    public IAxisData AxisY { get; }
    public AxisRangeInfo XRange { get; }
    public AxisRangeInfo YRange { get; }
    public RangesSnapshot(IAxisData axisX, IAxisData axisY);
    private static double CalculateEdgeChange(IWholeAxisRangeData wholeRange, double value, double oldValue);
    private static double Correct(double value);
    private static void CorrectSecondaryAxesPositions(IList`1<IAxisData> axes, AxisRangeInfo oldRange, IAxisData primaryAxis, bool useDeltaFactor);
    public IAxisData get_AxisX();
    public IAxisData get_AxisY();
    public AxisRangeInfo get_XRange();
    public AxisRangeInfo get_YRange();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void CorrectAxesXPositions(IList`1<IAxisData> axes, bool useDeltaFactor);
    public void CorrectAxesYPositions(IList`1<IAxisData> axes, bool useDeltaFactor);
}
public class DevExpress.Charts.Native.RangeStrip : object {
    private GeometryStripStyle customStyle;
    private LineStrip topStrip;
    private LineStrip bottomStrip;
    public int Count { get; }
    public bool IsEmpty { get; }
    public LineStrip TopStrip { get; public set; }
    public LineStrip BottomStrip { get; public set; }
    public GeometryStripStyle Style { get; }
    public sealed virtual int get_Count();
    public virtual bool get_IsEmpty();
    public LineStrip get_TopStrip();
    public void set_TopStrip(LineStrip value);
    public LineStrip get_BottomStrip();
    public void set_BottomStrip(LineStrip value);
    public sealed virtual GeometryStripStyle get_Style();
    protected virtual LineStrip CreateBorderStrip();
    protected void EnsureStrips();
    public virtual RangeStrip CreateInstance();
    public virtual void CompleteFilling(IList`1<RefinedPoint> points, IBezierStripSplitter splitter);
    public void Add(StripRange range);
}
public class DevExpress.Charts.Native.RangeStripTriangulation : object {
    private double epsilon;
    private double epsilonSquare;
    private LineStrip topStrip;
    private LineStrip bottomStrip;
    private int topStripLength;
    private int bottomStripLength;
    private List`1<GPolygon2D> polygons;
    private LineStrip topBorderStrip;
    private LineStrip bottomBorderStrip;
    private RangeStripTriangulation(RangeStrip strip, double epsilon);
    public static RangeStripTriangulationResult Triangulate(RangeStrip strip, double epsilon);
    private bool ArePointsEquals(GRealPoint2D p1, GRealPoint2D p2);
    private void ProcessEmptyStrip();
    private void AddPointsToBorderStrips(GRealPoint2D topPoint, GRealPoint2D bottomPoint);
    private GRealPoint2D MakeStep(LineStrip strip, GRealPoint2D& point, Int32& stripIndex);
    private void ProcessRegularStrip();
    private void Process();
}
public class DevExpress.Charts.Native.RangeStripTriangulationResult : ValueType {
    private IList`1<GPolygon2D> polygons;
    private LineStrip borderStrip;
    public IList`1<GPolygon2D> Polygons { get; }
    public LineStrip BorderStrip { get; }
    public RangeStripTriangulationResult(IList`1<GPolygon2D> polygons, LineStrip borderStrip);
    public IList`1<GPolygon2D> get_Polygons();
    public LineStrip get_BorderStrip();
}
public class DevExpress.Charts.Native.RangeUpdateEnqueuer : object {
    private Dictionary`2<IAxisData, RefinedSeriesGroup> refinedSeriesGroups;
    private VisualRangeUpdateMode visualRangeUpdateMode;
    private List`1<IAxisData> axesForReset;
    private List`1<IPaneAxesContainer> containers;
    private RangeUpdateEnqueuer(Dictionary`2<IAxisData, RefinedSeriesGroup> refinedSeriesGroups, VisualRangeUpdateMode visualRangeUpdateMode, List`1<IPaneAxesContainer> containers, List`1<IAxisData> axesForReset);
    public static void Update(RefinedSeriesGroupController groupController, VisualRangeUpdateMode visualRangeUpdateMode, IXYDiagram diagram, IList`1<RefinedSeries> activeSeries, List`1<IAxisData> axesForReset);
    private void AddGroup(Dictionary`2<IAxisData, AxesGroup> groups, IAxisData pAxis, IList`1<IAxisData> sAxes, HashSet`1<IAxisData> addedAxes);
    private Dictionary`2<IAxisData, AxesGroup> CreateUpdateGroups();
    private void UpdateGroups(Dictionary`2<IAxisData, AxesGroup> groups, bool isAutoGroups);
    private Dictionary`2<IAxisData, HashSet`1<IAxisData>> GetDependentAxes(Dictionary`2<IAxisData, AxesGroup> groups);
    private void UpdateDependentGroups(Dictionary`2<IAxisData, AxesGroup> groups);
}
public abstract class DevExpress.Charts.Native.RangeUpdateStrategy : object {
    protected MinMaxValues DefaultSideMarginsValue;
    private IAxisData axis;
    private MinMaxValues minMaxInternal;
    private MinMaxValues minMaxRefined;
    private ICollection`1<RefinedSeries> refinedSeries;
    private bool scaleMapWasChanged;
    protected IAxisData Axis { get; }
    protected IVisualAxisRangeData VisualRange { get; }
    protected IWholeAxisRangeData WholeRange { get; }
    protected AxisScaleTypeMap Map { get; }
    protected bool ShowZeroLevel { get; }
    protected MinMaxValues MinMaxFromSeries { get; }
    protected Transformation Transformation { get; }
    protected RangeUpdateStrategy(IAxisData axis, MinMaxValues minMaxInternal, MinMaxValues minMaxRefined, ICollection`1<RefinedSeries> refinedSeries, bool scaleMapWasChanged);
    public static void UpdateRange(IAxisData axis, MinMaxValues minMaxInternal, MinMaxValues minMaxRefined, ICollection`1<RefinedSeries> refinedSeries, VisualRangeUpdateMode updateMode, bool scaleMapWasChanged);
    protected IAxisData get_Axis();
    protected IVisualAxisRangeData get_VisualRange();
    protected IWholeAxisRangeData get_WholeRange();
    protected AxisScaleTypeMap get_Map();
    protected bool get_ShowZeroLevel();
    protected MinMaxValues get_MinMaxFromSeries();
    protected Transformation get_Transformation();
    private MinMaxValues Validate(MinMaxValues values);
    private void UpdateDataRange(VisualRangeUpdateMode updateMode);
    private void UpdateRange(VisualRangeUpdateMode updateMode);
    private void RefreshInternalValues();
    private bool CanShowZeroLevel(MinMaxValues range);
    private bool NeedCorrect(IAxisRangeData range);
    private bool AutoSideMarginEnable(IAxisRangeData range);
    private void TryResetRange(IAxisRangeData rangeData);
    private bool TryConvertNativeValue(IAxisRangeData rangeData, object value);
    private RangeSnapshot SynchronizeVisualRange(RangeSnapshot wholeRangeNewState, RangeSnapshot visualRangeNewState, VisualRangeUpdateMode updateMode);
    private RangeSnapshot AdjustVisualRangeByWholeRange(RangeSnapshot visualRangeSnapshot, RangeSnapshot wholeRangeSnapshot, bool stickToEdge);
    private RangeSnapshot AdjustInternalValue(RangeSnapshot visualRangeSnapshot, RangeSnapshot wholeRangeSnapshot, bool stickToEdge, Boolean& isCorrected);
    private RangeSnapshot AdjustRefinedValue(RangeSnapshot visualRangeSnapshot, RangeSnapshot wholeRangeSnapshot, bool isCorrectedInternalValue);
    private RangeSnapshot CorrectAutoScrollVisualRange(RangeSnapshot wholeRangeNewState, RangeSnapshot visualRangeNewState);
    private RangeSnapshot CorrectProportionalVisualRange(IMinMaxValues wholeRangeNewState, IMinMaxValues visualRangeNewState, IMinMaxValues refinedValues);
    private MinMaxValues GetRefinedValues(IAxisRangeData range);
    private MinMaxValues GetInternalValuesForWholeRange();
    private MinMaxValues GetInternalValuesForVisualRange(VisualRangeUpdateMode updateMode, MinMaxValues defaultMinMax);
    private MinMaxValues AddSideMargins(MinMaxValues value, MinMaxValues sideMargins);
    private MinMaxValues ApplySideMargins(MinMaxValues values, MinMaxValues sideMargins);
    private InternalRange GetCorrectedInternalValues(IAxisRangeData range, MinMaxValues internalValues);
    private InternalRange CorrectWithSideMargins(IAxisRangeData range, MinMaxValues internalValues);
    private double GetInternalValue(bool isAutoCorrection, double defaultInternalValue, double internalValue, object nativeValue, double margin);
    private double GetZeroLevel(MinMaxValues internalValues);
    private RangeSnapshot CalculateVisualRangeStage(MinMaxValues internalValues, MinMaxValues refinedValues);
    private RangeSnapshot CalculateWholeRangeStage(MinMaxValues internalValues, MinMaxValues refinedValues);
    private MinMaxValues CorrectRefinedValuesByZeroLevel(MinMaxValues refinedValues);
    protected double CalcSideMargin(MinMaxValues internalValues, IAxisRangeData range);
    protected virtual SideMarginCalculatorBase CreateSideMarginCalculator(IAxisData axis, bool autoCorrectMin, bool autoCorrectMax);
    protected virtual MinMaxValues ConvertValuesToInternalValues(IAxisRangeData range, MinMaxValues defaultMinMax);
    protected virtual RangeSnapshot DefaultRange(IAxisRangeData range);
    protected virtual InternalRange ApplySideMargins(MinMaxValues internalValues, MinMaxValues sideMargins, bool autoCorrectionMin, bool autoCorrectionMax);
    protected virtual bool IncorrectRelationBetweenMinAndMax(MinMaxValues internalValues);
    protected virtual MinMaxValues NarrowToActualWholeRange(MinMaxValues wholeRangeValues, IWholeAxisRangeData wholeRange);
    protected abstract virtual NativeRange GetNativeValues(MinMaxValues internalValues, MinMaxValues correctedInternalValues, IAxisRangeData range);
    protected abstract virtual InternalRange CheckInternalValue(IAxisRangeData range, MinMaxValues internalValues);
    protected NativeRange InternalToNative(MinMaxValues range);
    protected NativeRange RefinedToNative(double min, double max);
    protected InternalRange RefinedToInternal(double min, double max, MinMaxValues sideMargins, MinMaxValues sideMarginsValue);
    protected MinMaxValues CheckZeroLevel(MinMaxValues newValues, MinMaxValues internalValues, bool autoCorrectionMin, bool autoCorrectionMax);
}
public enum DevExpress.Charts.Native.RangeValidationBase : Enum {
    public int value__;
    public static RangeValidationBase Minimum;
    public static RangeValidationBase Maximum;
    public static RangeValidationBase Average;
}
public class DevExpress.Charts.Native.RangeValue : ValueType {
    private static RangeValue empty;
    private double value1;
    private double value2;
    public static RangeValue Empty { get; }
    public double Value1 { get; public set; }
    public double Value2 { get; public set; }
    public RangeValue(double value1, double value2);
    public RangeValue(double value);
    private static RangeValue();
    public static RangeValue get_Empty();
    public double get_Value1();
    public void set_Value1(double value);
    public double get_Value2();
    public void set_Value2(double value);
}
public class DevExpress.Charts.Native.RangeWrapper : ValueType {
    private IMinMaxValues range;
    private double min;
    private double max;
    [CompilerGeneratedAttribute]
private bool <IsZeroRange>k__BackingField;
    public double Max { get; public set; }
    public double Min { get; public set; }
    public bool IsZeroRange { get; public set; }
    public double Delta { get; }
    public RangeWrapper(IMinMaxValues range);
    public sealed virtual double get_Max();
    public sealed virtual void set_Max(double value);
    public sealed virtual double get_Min();
    public sealed virtual void set_Min(double value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsZeroRange();
    [CompilerGeneratedAttribute]
public void set_IsZeroRange(bool value);
    public sealed virtual double get_Delta();
    public sealed virtual double CalculateCenter();
    public sealed virtual void Intersection(IMinMaxValues minMaxValues);
    public virtual string ToString();
}
public class DevExpress.Charts.Native.RateOfChangeCalculator : object {
    private static int DesignTimePointsCount;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    private double CalculateRoC(IList`1<RefinedPoint> refinedPoints, int currIndex, int usingPointsCount, ValueLevelInternal valueLevel);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointCount, ValueLevelInternal valueLevel);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointCount, ValueLevelInternal valueLevel);
}
public class DevExpress.Charts.Native.RectanglesLayout : object {
    private static int stepToLeftIndex;
    private static int stepToRightIndex;
    private static int stepToBottomIndex;
    private static int stepToTopIndex;
    private DXRectangle bounds;
    private Rows rows;
    private Step[] steps;
    private List`1<DXRectangle> occupiedRectList;
    private int unallocatableWidth;
    private int unallocatableHeight;
    private DXRectangle validRect;
    private DXRectangle lastValidRect;
    private List`1<TestPosition> testContainer;
    public int RowsCount { get; }
    public int ColumnsCount { get; }
    public IEnumerable`1<Step> Steps { get; }
    public Step StepToLeft { get; }
    public Step StepToRight { get; }
    public Step StepToBottom { get; }
    public Step StepToTop { get; }
    public DXRectangle ValidRect { get; }
    public RectanglesLayout(DXRectangle bounds);
    public int get_RowsCount();
    public int get_ColumnsCount();
    public IEnumerable`1<Step> get_Steps();
    public Step get_StepToLeft();
    public Step get_StepToRight();
    public Step get_StepToBottom();
    public Step get_StepToTop();
    public DXRectangle get_ValidRect();
    private void Arrange(DXRectangle& rect);
    private bool IsAlgorithmEnd();
    private bool IsEmptyRegion(DXRectangle rect);
    private DXRectangle RunAlgorithm(DXRectangle allocationRect);
    private void UpdateTestContainer();
    public void UpdateSteps(DXRectangle rect);
    public void UpdateValidRect(DXRectangle rect);
    public DXRectangle ArrangeRectangle(DXRectangle rect, int overlappingIndent, DXRectangle validRect, DXRectangle tempExcludedRect);
    public void AddOccupiedRectangle(DXRectangle rect);
    public bool IsEmptyRegion(DXRectangle rect, DXRectangle validRect);
    public bool IsEmptyRegionByList(DXRectangle rect);
    public Cell GetCell(int rowIndex, int columnIndex);
}
public class DevExpress.Charts.Native.RectanglesLayoutAlgorithm : object {
    private RectanglesLayout layout;
    private RectanglesLayout layoutWithExcludedRegions;
    private int overlappingIndent;
    public RectanglesLayoutAlgorithm(DXRectangle bounds, int overlappingIndent);
    public RectanglesLayoutAlgorithm(int overlappingIndent);
    public DXRectangle ArrangeRectangle(DXRectangle rect, DXRectangle validRect, bool useExcludedRegions);
    public DXRectangle ArrangeRectangle(DXRectangle rect, DXRectangle validRect, bool useExcludedRegions, DXRectangle tempExcludedRect);
    public void AddExcludedRectangle(DXRectangle rect);
    public void AddOccupiedRectangle(DXRectangle rect);
    public bool IsEmptyRegion(DXRectangle rect, bool useExcludedRegions);
    public bool IsEmptyRegionByList(DXRectangle rect, bool useExcludedRegions);
}
public class DevExpress.Charts.Native.RefinedPoint : object {
    public static int ValuesCount;
    private double argument;
    private IRefinedDataContainer dataContainer;
    private int index;
    private object tag;
    internal IPointInteraction Interaction { get; }
    internal bool IsSupplyPoint { get; internal set; }
    internal double Value1 { get; }
    internal double Value2 { get; }
    internal double Value3 { get; }
    internal double Value4 { get; }
    internal double Value5 { get; }
    internal double Value6 { get; }
    public Double[] AdditionalValues { get; }
    public double Argument { get; }
    public Scale ArgumentScaleX { get; }
    public Scale ArgumentScaleY { get; }
    public double ArgumentY { get; }
    public IEnumerable`1<RefinedPoint> Children { get; }
    public int Index { get; public set; }
    public bool IsEmpty { get; }
    public bool HasValues { get; }
    public CorePointState State { get; }
    public ISeriesPoint SeriesPoint { get; }
    public object ToolTipHint { get; }
    public object Tag { get; }
    public int ValuesDimension { get; }
    public double NumericalArgument { get; }
    public DateTime DateTimeArgument { get; }
    public TimeSpan TimeSpanArgument { get; }
    private double DevExpress.Charts.Native.IArgumentPoint.Argument { get; private set; }
    private double DevExpress.Charts.Native.IXYZPoint.ArgumentY { get; private set; }
    private bool DevExpress.Charts.Native.ILegendItem.CrosshairLegendTextVisible { get; }
    private double DevExpress.Charts.Native.IFunnelPoint.NormalizedValue { get; }
    private double DevExpress.Charts.Native.IValuePoint.Value { get; private set; }
    private bool DevExpress.Charts.Native.IPiePoint.IsMaxPoint { get; }
    private bool DevExpress.Charts.Native.IPiePoint.IsMinPoint { get; }
    private double DevExpress.Charts.Native.IPiePoint.NormalizedValue { get; }
    private double DevExpress.Charts.Native.IPiePoint.TotalValue { get; }
    private double DevExpress.Charts.Native.IXYZWPoint.Weight { get; private set; }
    private double DevExpress.Charts.Native.IXYZWPoint.Size { get; }
    private double DevExpress.Charts.Native.IXYWPoint.Weight { get; private set; }
    private double DevExpress.Charts.Native.IXYWPoint.Size { get; }
    private double DevExpress.Charts.Native.IFinancialPoint.Open { get; private set; }
    private double DevExpress.Charts.Native.IFinancialPoint.Close { get; private set; }
    private double DevExpress.Charts.Native.IFinancialPoint.Low { get; private set; }
    private double DevExpress.Charts.Native.IFinancialPoint.High { get; private set; }
    private double DevExpress.Charts.Native.IRangePoint.Value1 { get; private set; }
    private double DevExpress.Charts.Native.IRangePoint.Value2 { get; private set; }
    private double DevExpress.Charts.Native.IRangePoint.Min { get; }
    private double DevExpress.Charts.Native.IRangePoint.Max { get; }
    private int DevExpress.Charts.Native.IPointInteraction.Count { get; }
    private bool DevExpress.Charts.Native.IPointInteraction.IsEmpty { get; }
    private double DevExpress.Charts.Native.IPointInteraction.ArgumentX { get; }
    private double DevExpress.Charts.Native.IPointInteraction.ArgumentY { get; }
    private double DevExpress.Charts.Native.IStackedPoint.MinValue { get; }
    private double DevExpress.Charts.Native.IStackedPoint.MaxValue { get; }
    private double DevExpress.Charts.Native.IStackedPoint.TotalValue { get; }
    private double DevExpress.Charts.Native.IStackedPoint.TotalMinValue { get; }
    private double DevExpress.Charts.Native.IStackedPoint.TotalMaxValue { get; }
    private IList`1<RefinedPoint> DevExpress.Charts.Native.IStackedPoint.ConnectedPoints { get; }
    private double DevExpress.Charts.Native.IFullStackedPoint.NormalizedValue { get; }
    private double DevExpress.Charts.Native.IFullStackedPoint.TotalValue { get; }
    private double DevExpress.Charts.Native.IWaterfallPoint.AnchorValue { get; }
    private double DevExpress.Charts.Native.IWaterfallPoint.RelativeValue { get; }
    private double DevExpress.Charts.Native.IWaterfallPoint.AbsoluteValue { get; }
    private bool DevExpress.Charts.Native.IWaterfallPoint.IsSubTotal { get; }
    private double DevExpress.Charts.Native.ISideBySidePoint.BarWidth { get; }
    private double DevExpress.Charts.Native.ISideBySidePoint.Offset { get; }
    private int DevExpress.Charts.Native.ISideBySidePoint.FixedOffset { get; }
    private bool DevExpress.Charts.Native.ISideBySideBarPoint.Interacted { get; }
    private double DevExpress.Charts.Native.IErrorBarPoint.HighValue { get; private set; }
    private double DevExpress.Charts.Native.IErrorBarPoint.LowValue { get; private set; }
    private double DevExpress.Charts.Native.IBoxPlotPoint.Min { get; private set; }
    private double DevExpress.Charts.Native.IBoxPlotPoint.Quartile1 { get; private set; }
    private double DevExpress.Charts.Native.IBoxPlotPoint.Median { get; private set; }
    private double DevExpress.Charts.Native.IBoxPlotPoint.Quartile3 { get; private set; }
    private double DevExpress.Charts.Native.IBoxPlotPoint.Max { get; private set; }
    private double DevExpress.Charts.Native.IBoxPlotPoint.Mean { get; private set; }
    private Double[] DevExpress.Charts.Native.IBoxPlotPoint.Outliers { get; private set; }
    private double DevExpress.Charts.Native.IDataPoint.NumericalValue { get; }
    private object DevExpress.Charts.Native.IDataPoint.Argument { get; }
    private ISeriesPointArgument DevExpress.Charts.Native.IDataPoint.ArgumentX { get; }
    internal RefinedPoint(double argument, double value);
    internal RefinedPoint(ISeriesPoint point);
    internal RefinedPoint(ISeriesPoint point, double argument, double value);
    internal RefinedPoint(ISeriesPoint point, double argument, IList`1<double> values);
    internal RefinedPoint(ISeriesPoint point, double argument, IList`1<double> values, object tag);
    internal RefinedPoint(double argument, IList`1<double> values, CorePointState valuesState);
    internal RefinedPoint(double argumentX, double argumentY, IList`1<double> values, CorePointState valuesState);
    internal RefinedPoint(ISeriesPoint point, double argument, IList`1<double> values, CorePointState valuesState);
    internal RefinedPoint(ISeriesPoint point, double argumentX, double argumentY, IList`1<double> values, CorePointState valuesState);
    internal RefinedPoint(ISeriesPoint point, double argument, IList`1<double> values, IList`1<double> errorBarsValues, CorePointState valuesState);
    internal RefinedPoint(ISeriesPoint point, double argumentX, double argumentY, IList`1<double> values);
    internal RefinedPoint(ISeriesPoint point, double argument, IList`1<double> values, IList`1<double> errorBarsValues);
    private static bool PointIsEmpty(CorePointState mode);
    private static CorePointState GetPointState(ISeriesPoint point);
    internal IPointInteraction get_Interaction();
    internal bool get_IsSupplyPoint();
    internal void set_IsSupplyPoint(bool value);
    internal double get_Value1();
    internal double get_Value2();
    internal double get_Value3();
    internal double get_Value4();
    internal double get_Value5();
    internal double get_Value6();
    public Double[] get_AdditionalValues();
    public double get_Argument();
    public Scale get_ArgumentScaleX();
    public Scale get_ArgumentScaleY();
    public double get_ArgumentY();
    public sealed virtual IEnumerable`1<RefinedPoint> get_Children();
    public int get_Index();
    public void set_Index(int value);
    public sealed virtual bool get_IsEmpty();
    public bool get_HasValues();
    public CorePointState get_State();
    public sealed virtual ISeriesPoint get_SeriesPoint();
    public object get_ToolTipHint();
    public object get_Tag();
    public int get_ValuesDimension();
    public double get_NumericalArgument();
    public DateTime get_DateTimeArgument();
    public TimeSpan get_TimeSpanArgument();
    private sealed virtual override double DevExpress.Charts.Native.IArgumentPoint.get_Argument();
    private sealed virtual override void DevExpress.Charts.Native.IArgumentPoint.set_Argument(double value);
    private sealed virtual override double DevExpress.Charts.Native.IXYZPoint.get_ArgumentY();
    private sealed virtual override void DevExpress.Charts.Native.IXYZPoint.set_ArgumentY(double value);
    private sealed virtual override bool DevExpress.Charts.Native.ILegendItem.get_CrosshairLegendTextVisible();
    private sealed virtual override double DevExpress.Charts.Native.IFunnelPoint.get_NormalizedValue();
    private sealed virtual override double DevExpress.Charts.Native.IValuePoint.get_Value();
    private sealed virtual override void DevExpress.Charts.Native.IValuePoint.set_Value(double value);
    private sealed virtual override bool DevExpress.Charts.Native.IPiePoint.get_IsMaxPoint();
    private sealed virtual override bool DevExpress.Charts.Native.IPiePoint.get_IsMinPoint();
    private sealed virtual override double DevExpress.Charts.Native.IPiePoint.get_NormalizedValue();
    private sealed virtual override double DevExpress.Charts.Native.IPiePoint.get_TotalValue();
    private sealed virtual override double DevExpress.Charts.Native.IXYZWPoint.get_Weight();
    private sealed virtual override void DevExpress.Charts.Native.IXYZWPoint.set_Weight(double value);
    private sealed virtual override double DevExpress.Charts.Native.IXYZWPoint.get_Size();
    private sealed virtual override double DevExpress.Charts.Native.IXYWPoint.get_Weight();
    private sealed virtual override void DevExpress.Charts.Native.IXYWPoint.set_Weight(double value);
    private sealed virtual override double DevExpress.Charts.Native.IXYWPoint.get_Size();
    private sealed virtual override double DevExpress.Charts.Native.IFinancialPoint.get_Open();
    private sealed virtual override void DevExpress.Charts.Native.IFinancialPoint.set_Open(double value);
    private sealed virtual override double DevExpress.Charts.Native.IFinancialPoint.get_Close();
    private sealed virtual override void DevExpress.Charts.Native.IFinancialPoint.set_Close(double value);
    private sealed virtual override double DevExpress.Charts.Native.IFinancialPoint.get_Low();
    private sealed virtual override void DevExpress.Charts.Native.IFinancialPoint.set_Low(double value);
    private sealed virtual override double DevExpress.Charts.Native.IFinancialPoint.get_High();
    private sealed virtual override void DevExpress.Charts.Native.IFinancialPoint.set_High(double value);
    private sealed virtual override double DevExpress.Charts.Native.IRangePoint.get_Value1();
    private sealed virtual override void DevExpress.Charts.Native.IRangePoint.set_Value1(double value);
    private sealed virtual override double DevExpress.Charts.Native.IRangePoint.get_Value2();
    private sealed virtual override void DevExpress.Charts.Native.IRangePoint.set_Value2(double value);
    private sealed virtual override double DevExpress.Charts.Native.IRangePoint.get_Min();
    private sealed virtual override double DevExpress.Charts.Native.IRangePoint.get_Max();
    private sealed virtual override int DevExpress.Charts.Native.IPointInteraction.get_Count();
    private sealed virtual override bool DevExpress.Charts.Native.IPointInteraction.get_IsEmpty();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.get_ArgumentX();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.get_ArgumentY();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMinValue(ISeriesView seriesView);
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMaxValue(ISeriesView seriesView);
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMinAbsValue(ISeriesView seriesView);
    private sealed virtual override double DevExpress.Charts.Native.IStackedPoint.get_MinValue();
    private sealed virtual override double DevExpress.Charts.Native.IStackedPoint.get_MaxValue();
    private sealed virtual override double DevExpress.Charts.Native.IStackedPoint.get_TotalValue();
    private sealed virtual override double DevExpress.Charts.Native.IStackedPoint.get_TotalMinValue();
    private sealed virtual override double DevExpress.Charts.Native.IStackedPoint.get_TotalMaxValue();
    private sealed virtual override IList`1<RefinedPoint> DevExpress.Charts.Native.IStackedPoint.get_ConnectedPoints();
    private sealed virtual override double DevExpress.Charts.Native.IFullStackedPoint.get_NormalizedValue();
    private sealed virtual override double DevExpress.Charts.Native.IFullStackedPoint.get_TotalValue();
    private sealed virtual override double DevExpress.Charts.Native.IWaterfallPoint.get_AnchorValue();
    private sealed virtual override double DevExpress.Charts.Native.IWaterfallPoint.get_RelativeValue();
    private sealed virtual override double DevExpress.Charts.Native.IWaterfallPoint.get_AbsoluteValue();
    private sealed virtual override bool DevExpress.Charts.Native.IWaterfallPoint.get_IsSubTotal();
    private sealed virtual override double DevExpress.Charts.Native.ISideBySidePoint.get_BarWidth();
    private sealed virtual override double DevExpress.Charts.Native.ISideBySidePoint.get_Offset();
    private sealed virtual override int DevExpress.Charts.Native.ISideBySidePoint.get_FixedOffset();
    private sealed virtual override bool DevExpress.Charts.Native.ISideBySideBarPoint.get_Interacted();
    private sealed virtual override double DevExpress.Charts.Native.IErrorBarPoint.get_HighValue();
    private sealed virtual override void DevExpress.Charts.Native.IErrorBarPoint.set_HighValue(double value);
    private sealed virtual override double DevExpress.Charts.Native.IErrorBarPoint.get_LowValue();
    private sealed virtual override void DevExpress.Charts.Native.IErrorBarPoint.set_LowValue(double value);
    private sealed virtual override double DevExpress.Charts.Native.IBoxPlotPoint.get_Min();
    private sealed virtual override void DevExpress.Charts.Native.IBoxPlotPoint.set_Min(double value);
    private sealed virtual override double DevExpress.Charts.Native.IBoxPlotPoint.get_Quartile1();
    private sealed virtual override void DevExpress.Charts.Native.IBoxPlotPoint.set_Quartile1(double value);
    private sealed virtual override double DevExpress.Charts.Native.IBoxPlotPoint.get_Median();
    private sealed virtual override void DevExpress.Charts.Native.IBoxPlotPoint.set_Median(double value);
    private sealed virtual override double DevExpress.Charts.Native.IBoxPlotPoint.get_Quartile3();
    private sealed virtual override void DevExpress.Charts.Native.IBoxPlotPoint.set_Quartile3(double value);
    private sealed virtual override double DevExpress.Charts.Native.IBoxPlotPoint.get_Max();
    private sealed virtual override void DevExpress.Charts.Native.IBoxPlotPoint.set_Max(double value);
    private sealed virtual override double DevExpress.Charts.Native.IBoxPlotPoint.get_Mean();
    private sealed virtual override void DevExpress.Charts.Native.IBoxPlotPoint.set_Mean(double value);
    private sealed virtual override Double[] DevExpress.Charts.Native.IBoxPlotPoint.get_Outliers();
    private sealed virtual override void DevExpress.Charts.Native.IBoxPlotPoint.set_Outliers(Double[] value);
    private sealed virtual override double DevExpress.Charts.Native.IDataPoint.get_NumericalValue();
    private sealed virtual override object DevExpress.Charts.Native.IDataPoint.get_Argument();
    private sealed virtual override ISeriesPointArgument DevExpress.Charts.Native.IDataPoint.get_ArgumentX();
    private sealed virtual override RefinedPoint DevExpress.Charts.Native.IDataPoint.GetRefinedPoint(IRefinedPointCreator pointCreator, IPointProcessor pointProcessor, List`1<AxisScaleTypeMap> argumentMaps);
    private sealed virtual override ISeriesPoint DevExpress.Charts.Native.IDataPoint.GetSeriesPoint(ISeriesPointCreator pointCreator);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.Apply(ISeries series, string toolTipHint);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetNumericalArgument(double value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetDateTimeArgument(DateTime value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetTimeSpanArgument(TimeSpan value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetQualitativeArgument(string value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetNumericalValues(Double[] value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetDateTimeValues(DateTime[] value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetTimeSpanValues(TimeSpan[] value);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.SetTag(object tag);
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.ClearAnnotations();
    private sealed virtual override void DevExpress.Charts.Native.IDataPoint.UpdateAnnotationRepository();
    private void EnsureAdditionalContainer();
    private IRefinedDataContainer CreateDataContainer(int argumentsCount, int valuesCount);
    private void EnsureDataContainerType(int argumentsCount, int valuesCount);
    private void EnsureFullAdditionalContainer();
    private double GetValue(int index);
    private void SetTag(object tag);
    protected void ApplyErrorBars(IList`1<double> errorBarsValues);
    public double GetAdditionalValue(ErrorBarValueInternal valueLevel);
    public double GetPercentValue();
    public List`1<RefinedSeries> GetSideBySideSeries();
    public double GetTotalValue();
    public double GetValue(ValueLevelInternal valueLevel);
    public sealed virtual void MakeEmpty();
    public void ReplaceSeriesPoint(IDataPoint seriesPoint);
    public void ResetInteraction();
    public void ResetSeriesGroupsInteraction();
    public void SetInteraction(IPointInteraction data, int index);
    public void SetSeriesGroupsInteraction(IPointInteraction interaction, int index);
    public bool IsValueEmpty(Scale scale);
    public double GetRefinedArgument(AxisScaleTypeMap scaleMap);
    public object GetUserArgument(AxisScaleTypeMap scaleMap);
    public double GetNumericalValue(int index);
    public DateTime GetDateTimeValue(int index);
    public TimeSpan GetTimeSpanValue(int index);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.RefinedPointCollection : RefinedPointCollectionBase {
    public RefinedPointCollection(int capacity);
    public void Swap(int index1, int index2);
    public void Move(int oldIndex, int newIndex);
    public void Insert(int index, RefinedPoint item);
    public void InsertRange(int index, ICollection`1<RefinedPoint> collection);
    public virtual int IndexOf(RefinedPoint item);
    public virtual bool Contains(RefinedPoint item);
    public virtual void Add(RefinedPoint item);
    public virtual void AddRange(IList`1<RefinedPoint> collection, bool shouldSort);
}
[DefaultMemberAttribute("Item")]
public abstract class DevExpress.Charts.Native.RefinedPointCollectionBase : object {
    private static int minCollapsedCount;
    private static int defaultCapacity;
    private static int maxCapacityIncrease;
    private int count;
    private RefinedPoint[] points;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    private bool IsReadOnly { get; }
    protected int Offset { get; protected set; }
    protected RefinedPoint[] Points { get; }
    public int Count { get; }
    public RefinedPoint Item { get; public set; }
    private RefinedPoint System.Collections.Generic.IList<DevExpress.Charts.Native.RefinedPoint>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.RefinedPoint>.IsReadOnly { get; }
    protected RefinedPointCollectionBase(int capacity);
    private bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
protected int get_Offset();
    [CompilerGeneratedAttribute]
protected void set_Offset(int value);
    protected RefinedPoint[] get_Points();
    public sealed virtual int get_Count();
    public RefinedPoint get_Item(int index);
    public void set_Item(int index, RefinedPoint value);
    private sealed virtual override IEnumerator`1<RefinedPoint> System.Collections.Generic.IEnumerable<DevExpress.Charts.Native.RefinedPoint>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<DevExpress.Charts.Native.RefinedPoint>.IndexOf(RefinedPoint item);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Charts.Native.RefinedPoint>.Insert(int index, RefinedPoint item);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Charts.Native.RefinedPoint>.RemoveAt(int index);
    private sealed virtual override RefinedPoint System.Collections.Generic.IList<DevExpress.Charts.Native.RefinedPoint>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Charts.Native.RefinedPoint>.set_Item(int index, RefinedPoint value);
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.RefinedPoint>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.RefinedPoint>.Add(RefinedPoint item);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.RefinedPoint>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.RefinedPoint>.Contains(RefinedPoint item);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.RefinedPoint>.CopyTo(RefinedPoint[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.RefinedPoint>.Remove(RefinedPoint item);
    private int GetCapacityForCollapse();
    private int GetCapacityForExpand();
    private void CollapsePoints(int newSize);
    private void ExpandPoints();
    protected void Realloc(int newCount);
    protected void MovePoint(int oldIndex, int newIndex);
    public abstract virtual int IndexOf(RefinedPoint item);
    public abstract virtual bool Contains(RefinedPoint item);
    public abstract virtual void Add(RefinedPoint item);
    public abstract virtual void AddRange(IList`1<RefinedPoint> collection, bool shouldSort);
    public sealed virtual IEnumerator GetEnumerator();
    public void Clear();
    public bool Remove(RefinedPoint item);
    public bool RemoveRange(int index, int countToRemove);
    public void CopyTo(IBasePoint[] array, int index);
}
public abstract class DevExpress.Charts.Native.RefinedPointComparerBase : Comparer`1<RefinedPoint> {
    public virtual bool IsSupportedPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.RefinedPointFinder : object {
    [CompilerGeneratedAttribute]
private RefinedSeries <RefinedSeries>k__BackingField;
    protected RefinedSeries RefinedSeries { get; private set; }
    protected ISeriesView SeriesView { get; }
    public RefinedPointFinder(RefinedSeries refinedSeries);
    [CompilerGeneratedAttribute]
protected RefinedSeries get_RefinedSeries();
    [CompilerGeneratedAttribute]
private void set_RefinedSeries(RefinedSeries value);
    protected ISeriesView get_SeriesView();
    private void ProcessSearchBackward(SortedArgumentRefinedPointCollection points, int index, double nearestPointArgument, double argument, List`1<PointArgumentDistance> result, double markerWidth);
    private void ProcessSearchForward(SortedArgumentRefinedPointCollection points, int index, double nearestPointArgument, double argument, List`1<PointArgumentDistance> result, double markerWidth);
    private static int FindIndex(SortedArgumentRefinedPointCollection finalPoints, double argument);
    public static List`1<RefinedPoint> GetNearestPointsByArgument(SortedArgumentRefinedPointCollection finalPoints, double argument);
    protected double CalcSquaredDistance(PointArgumentDistance argumentDistance, double value, double xRange, double yRange);
    protected virtual double CalculateDistance(PointArgumentDistance argumentDistance, double value, double xRange, double yRange);
    protected virtual bool AddEqualArgPoint(RefinedPoint point, int indexInCollection, double nearestPointArgument, double argument, List`1<PointArgumentDistance> result, double markerWidth);
    protected virtual bool IsValueInPointRange(double value, RefinedPoint point, double xRange, double yRange);
    public List`1<PointArgumentDistance> FindNearestPointsByArgument(MinMaxValues axisXRange);
    public RefinedPoint FindNearestPoint(Nullable`1<MinMaxValues> internalAxisXDiapason, double internalAxisYValue, double xRange, double yRange);
}
public class DevExpress.Charts.Native.RefinedPointsAggregator3D : object {
    private AxisScaleTypeMap axisXScaleMap;
    private AxisScaleTypeMap axisZScaleMap;
    public RefinedPointsAggregator3D(AxisScaleTypeMap axisXScaleMap, AxisScaleTypeMap axisZScaleMap);
    public IList`1<RefinedPointsCluster3D> ClusterPoints(IList`1<RefinedPoint> points);
}
public class DevExpress.Charts.Native.RefinedPointsArgumentAndIndexComparer : RefinedPointsArgumentComparer {
    public virtual int Compare(RefinedPoint pointInArray, RefinedPoint newPoint);
}
public class DevExpress.Charts.Native.RefinedPointsArgumentComparer : RefinedPointComparerBase {
    public virtual bool IsSupportedPoint(RefinedPoint point);
    public virtual int Compare(RefinedPoint pointInArray, RefinedPoint newPoint);
}
public class DevExpress.Charts.Native.RefinedPointsCluster3D : ValueType {
    private double argumentX;
    private double argumentY;
    private List`1<RefinedPoint> clusterPoints;
    public double ArgumentX { get; }
    public double ArgumentY { get; }
    public List`1<RefinedPoint> Points { get; }
    public RefinedPointsCluster3D(double argumentX, double argumentY);
    public double get_ArgumentX();
    public double get_ArgumentY();
    public List`1<RefinedPoint> get_Points();
    public void AddPoint(RefinedPoint point);
    public double GetAverageX();
    public double GetAverageY();
}
public class DevExpress.Charts.Native.RefinedPointsGridCluster : object {
    private IList`1<RefinedPoint> points;
    private double cumulativeArgumentX;
    private double cumulativeArgumentY;
    private double cumulativeValue;
    private int nonEmptyPointsCount;
    public double AverageArgumentX { get; }
    public double AverageArgumentY { get; }
    public double AverageValue { get; }
    public double CumulativeValue { get; }
    public int NonEmptyPointsCount { get; }
    public IList`1<RefinedPoint> Points { get; }
    public double get_AverageArgumentX();
    public double get_AverageArgumentY();
    public double get_AverageValue();
    public double get_CumulativeValue();
    public int get_NonEmptyPointsCount();
    public IList`1<RefinedPoint> get_Points();
    public void AddPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.RefinedPointsRangeValue1Comparer : RefinedPointComparerBase {
    public virtual bool IsSupportedPoint(RefinedPoint point);
    public virtual int Compare(RefinedPoint pointInArray, RefinedPoint newPoint);
}
public class DevExpress.Charts.Native.RefinedPointsRangeValue2Comparer : RefinedPointComparerBase {
    public virtual bool IsSupportedPoint(RefinedPoint point);
    public virtual int Compare(RefinedPoint pointInArray, RefinedPoint newPoint);
}
public class DevExpress.Charts.Native.RefinedPointsValueComparer : RefinedPointComparerBase {
    public virtual bool IsSupportedPoint(RefinedPoint point);
    public virtual int Compare(RefinedPoint pointInArray, RefinedPoint newPoint);
}
public class DevExpress.Charts.Native.RefinedPointsWeightComparer : RefinedPointComparerBase {
    public virtual bool IsSupportedPoint(RefinedPoint point);
    public virtual int Compare(RefinedPoint pointInArray, RefinedPoint newPoint);
}
public class DevExpress.Charts.Native.RefinedSeries : object {
    private RefinedPointsArgumentComparer argumentComparer;
    private List`1<RefinedSeriesGroup> argumentGroups;
    private SeriesGroupsInteractionContainer data;
    private int interactionIndex;
    private Nullable`1<bool> isActive;
    private bool isInUpdateVisibleFromDataSource;
    private int maxVisibleIndex;
    private int minVisibleIndex;
    private PointsProcessor pointsProcessor;
    private ISeries series;
    private IRefinedSeriesContainer seriesContainer;
    private RefinedSeriesGroup valueGroup;
    [CompilerGeneratedAttribute]
private SeriesInteractionContainer <InteractionContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActiveIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GroupIndex>k__BackingField;
    private IList`1<RefinedPoint> RefinedPoints { get; }
    private ResamplerData ResamplerData { get; }
    private bool UseOnlyVisiblePoints { get; }
    internal ArgumentsWithoutGapsInfo ArgumentsWithoutGaps { get; }
    internal bool HasPositivePoints { get; }
    internal SeriesInteractionContainer InteractionContainer { get; internal set; }
    internal RefinedPointCollectionBase Points { get; }
    internal IList`1<RefinedPoint> PointsForMap { get; }
    public int ActiveIndex { get; public set; }
    public bool ActualIsActive { get; }
    public List`1<RefinedSeriesGroup> ArgumentGroups { get; }
    public ActualScaleTypeCore ArgumentScaleType { get; }
    public ActualScaleTypeCore ArgumentScaleType2 { get; }
    public IList`1<RefinedPoint> FinalPoints { get; }
    public SortedArgumentRefinedPointCollection FinalPointsSortedByArgument { get; }
    public int GroupIndex { get; internal set; }
    public Nullable`1<bool> IsActive { get; }
    public bool IsContainsProcessedNotEmptyPoints { get; }
    public bool IsContainsProcessedPoints { get; }
    public bool IsPointsAutoGenerated { get; }
    public double MaxRefinedArgument { get; }
    public int MaxVisiblePointIndex { get; }
    public double MinRefinedArgument { get; }
    public int MinVisiblePointIndex { get; }
    public bool NoArgumentScaleTypeX { get; }
    public SortedArgumentRefinedPointCollection PointsSortedByArgument { get; }
    public RefinedPointCollectionBase PointsSortedBySettings { get; }
    public ISeries Series { get; }
    public ISeriesView SeriesView { get; }
    public RefinedSeriesGroup ValueGroup { get; }
    public ActualScaleTypeCore ValueScaleType { get; }
    protected internal bool IsEmpty { get; }
    public bool ActualDataSourceSorted { get; }
    private double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.ExplodedFactor { get; }
    private double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.HoleRadius { get; }
    private bool DevExpress.Charts.Native.INestedDoughnutRefinedSeries.IsExploded { get; }
    private double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.NormalizedWeight { get; }
    private double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.StartOffset { get; }
    private double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.StartOffsetInPixels { get; }
    private double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.TotalGroupIndentInPixels { get; }
    private bool DevExpress.Charts.Native.IRefinedSeries.IsActive { get; }
    private IList`1<RefinedPoint> DevExpress.Charts.Native.IRefinedSeries.Points { get; }
    public RefinedSeries(ISeries series, IRefinedSeriesContainer seriesContainer);
    private IList`1<RefinedPoint> get_RefinedPoints();
    private ResamplerData get_ResamplerData();
    private bool get_UseOnlyVisiblePoints();
    internal ArgumentsWithoutGapsInfo get_ArgumentsWithoutGaps();
    internal bool get_HasPositivePoints();
    [CompilerGeneratedAttribute]
internal SeriesInteractionContainer get_InteractionContainer();
    [CompilerGeneratedAttribute]
internal void set_InteractionContainer(SeriesInteractionContainer value);
    internal RefinedPointCollectionBase get_Points();
    internal IList`1<RefinedPoint> get_PointsForMap();
    [CompilerGeneratedAttribute]
public int get_ActiveIndex();
    [CompilerGeneratedAttribute]
public void set_ActiveIndex(int value);
    public bool get_ActualIsActive();
    public List`1<RefinedSeriesGroup> get_ArgumentGroups();
    public virtual ActualScaleTypeCore get_ArgumentScaleType();
    public ActualScaleTypeCore get_ArgumentScaleType2();
    public IList`1<RefinedPoint> get_FinalPoints();
    public SortedArgumentRefinedPointCollection get_FinalPointsSortedByArgument();
    [CompilerGeneratedAttribute]
public int get_GroupIndex();
    [CompilerGeneratedAttribute]
internal void set_GroupIndex(int value);
    public Nullable`1<bool> get_IsActive();
    public bool get_IsContainsProcessedNotEmptyPoints();
    public bool get_IsContainsProcessedPoints();
    public sealed virtual bool get_IsPointsAutoGenerated();
    public virtual double GetMaxArgument(AxisScaleTypeMap scaleMap);
    public double get_MaxRefinedArgument();
    public int get_MaxVisiblePointIndex();
    public virtual double GetMinArgument(AxisScaleTypeMap scaleMap);
    public double get_MinRefinedArgument();
    public int get_MinVisiblePointIndex();
    public bool get_NoArgumentScaleTypeX();
    public SortedArgumentRefinedPointCollection get_PointsSortedByArgument();
    public RefinedPointCollectionBase get_PointsSortedBySettings();
    public sealed virtual ISeries get_Series();
    public sealed virtual ISeriesView get_SeriesView();
    public RefinedSeriesGroup get_ValueGroup();
    public virtual ActualScaleTypeCore get_ValueScaleType();
    protected internal virtual bool get_IsEmpty();
    public bool get_ActualDataSourceSorted();
    private sealed virtual override double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.get_ExplodedFactor();
    private sealed virtual override double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.get_HoleRadius();
    private sealed virtual override bool DevExpress.Charts.Native.INestedDoughnutRefinedSeries.get_IsExploded();
    private sealed virtual override double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.get_NormalizedWeight();
    private sealed virtual override double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.get_StartOffset();
    private sealed virtual override double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.get_StartOffsetInPixels();
    private sealed virtual override double DevExpress.Charts.Native.INestedDoughnutRefinedSeries.get_TotalGroupIndentInPixels();
    private sealed virtual override List`1<RefinedPoint> DevExpress.Charts.Native.IRefinedSeries.FindAllPointsWithSameArgument(RefinedPoint refinedPoint);
    private sealed virtual override List`1<RefinedPoint> DevExpress.Charts.Native.IRefinedSeries.FindFinalPointsWithNearestArgument(double argument);
    private sealed virtual override RefinedPoint DevExpress.Charts.Native.IRefinedSeries.GetCorrectRefinedPointForLabel(RefinedPoint refinedPoint, List`1<GRealPoint2D> intersectionPoints);
    private sealed virtual override IList`1<RefinedPoint> DevExpress.Charts.Native.IRefinedSeries.GetDrawingPoints();
    private sealed virtual override RefinedPoint DevExpress.Charts.Native.IRefinedSeries.GetMaxPoint(double argument);
    private sealed virtual override RefinedPoint DevExpress.Charts.Native.IRefinedSeries.GetMinPoint(double argument);
    private sealed virtual override int DevExpress.Charts.Native.IRefinedSeries.GetMaxVisiblePointIndex(bool onlyByArgument);
    private sealed virtual override int DevExpress.Charts.Native.IRefinedSeries.GetMinVisiblePointIndex(bool onlyByArgument);
    private sealed virtual override RefinedPoint DevExpress.Charts.Native.IRefinedSeries.GetRefinedPoint(IScaleMap scaleMap, ISeriesPoint seriesPoint);
    private sealed virtual override bool DevExpress.Charts.Native.IRefinedSeries.get_IsActive();
    private sealed virtual override IList`1<RefinedPoint> DevExpress.Charts.Native.IRefinedSeries.get_Points();
    private int CorrectVisiblePointIndex(SortedArgumentRefinedPointCollection points, int index);
    private RefinedPoint CreateViewportIntersectionPoint(RefinedPoint refinedPoint, List`1<GRealPoint2D> intersectionPoints);
    private RefinedPoint GetRefinedPoint(RefinedPoint refinedPoint, ISeriesPoint seriesPoint);
    private RefinedPoint GetRefinedPoint(IScaleMap scaleMap, ISeriesPoint seriesPoint);
    private RefinedPoint GetRefinedPoint(SortedArgumentRefinedPointCollection sortedPoints, int index, ISeriesPoint seriesPoint);
    private bool SetVisibleMinMaxResamplerInfo(IMinMaxValues maxValues);
    private void UpdateIndexesCore(IMinMaxValues visualRangeValues);
    private void UpdateResampler(IMinMaxValues visualRangeValues);
    private PointsProcessor CreatePointsProcessor(RefinedSeries refinedSeries);
    internal List`1<AxisScaleTypeMap> GetArgumentScaleMaps();
    internal RefinedPoint GetFinalPointByArgument(double argument, Int32& index);
    internal void InvalidateGroupsArgumentIntervals();
    internal bool IsPointsFilterEnabled();
    internal void RecalculateArgumentScale();
    internal void ReplacePoint(IDataPoint seriesPoint, int indexInCollection);
    internal ICollection`1<RefinedSeriesPointsUpdateInfo> UpdatePoint(IDataPoint seriesPoint);
    internal RefinedSeriesPointsUpdateInfo UpdatePoints(SeriesPointsCollectionAction updateAction);
    protected internal virtual void PopulateArgumentAxisScaleMap(AxisQualitativeMap qualitativeMap);
    protected internal virtual void PopulateArgument2AxisScaleMap(AxisQualitativeMap qualitativeMap);
    protected internal virtual void PopulateValueAxisScaleMap(AxisQualitativeMap qualitativeMap);
    public void BindInactive(List`1<RefinedSeriesGroup> argumentGroups, RefinedSeriesGroup valueGroup);
    public void BindToGroups(List`1<RefinedSeriesGroup> argumentGroups, RefinedSeriesGroup valueGroup);
    public void CalculateVisiblePointIndexes(IMinMaxValues visualRangeValues, Int32& minIndex, Int32& maxIndex);
    public void Deactivate();
    public void EnsureInteractions();
    public sealed virtual IList`1<RefinedPoint> GetContinuesDrawingPoints();
    public double GetMinAbsArgument();
    public MinMaxValues GetValuesRange();
    public void InvalidateData();
    public void ProcessSortingPointKeyUpdate();
    public void ProcessSortingPointModeUpdate();
    public void SetArgumentScale(Scale scale, AxisGroup axisGroup);
    public void SetGroupsInteraction(SeriesGroupsInteractionContainer data, int index);
    public virtual string ToString();
    public void UpdateAutoScale();
    public virtual void UpdateData();
    public bool UpdateFilters();
    public void UpdatePointsIndices();
    public void UpdatePointsInternalArguments();
    public void UpdatePointsValues();
    public void UpdateVisiblePointIndexes(IMinMaxValues internalMinMax, IMinMaxValues refinedMinMax, bool allowResamplerUpdates);
}
public abstract class DevExpress.Charts.Native.RefinedSeriesGroup : object {
    private RefinedSeriesGroupKey groupKey;
    private List`1<RefinedSeries> refinedSeries;
    private HashSet`1<RefinedSeries> hiddenRefinedSeries;
    private AxisScaleTypeMap scaleMap;
    private SeriesGroupArgumentIntervalsContainer argumentIntervalsContainer;
    internal bool IsEmpty { get; }
    internal ICollection`1<RefinedSeries> RefinedSeries { get; }
    public AxisScaleTypeMap ScaleMap { get; }
    public RefinedSeriesGroupKey GroupKey { get; }
    public bool ShouldUpdateInternalArguments { get; }
    internal RefinedSeriesGroup(RefinedSeriesGroupKey groupKey);
    internal bool get_IsEmpty();
    internal ICollection`1<RefinedSeries> get_RefinedSeries();
    public AxisScaleTypeMap get_ScaleMap();
    public RefinedSeriesGroupKey get_GroupKey();
    public bool get_ShouldUpdateInternalArguments();
    private void BindScaleMapToAxis();
    private bool ShouldRecreateScaleMap(RefinedSeries mainSeries);
    private bool ShouldRecalculateScaleMap();
    private void RecalculateScaleMap();
    private double GetMinAbsValueFromAxisElements(IAxisElementContainer elementContainer);
    private double CheckMin(double min, double value);
    private Nullable`1<double> GetNumericalMeasureUnit();
    private DateTimeMeasureUnitNative GetDateTimeMeasureUnit();
    private TimeSpanMeasureUnitNative GetTimeSpanMeasureUnit();
    private int GetDateTimeMeasureUnitMultiplier();
    private int GetTimeSpanMeasureUnitMultiplier();
    private bool NeedUpdateContinuesAxisY();
    private AxisNumericalMap CreateNumericalMap();
    private AxisDateTimeMap CreateDateTimeMap();
    private AxisTimeSpanMap CreateTimeSpanMap();
    private AxisScaleTypeMap CreateScaleMap(RefinedSeries series);
    private RefinedSeries GetMainSeriesFromGroup(ICollection`1<RefinedSeries> seriesList);
    private RefinedSeries FindMainSeries();
    private MinMaxValues GetMinMaxValues(IAxisData axisData);
    private MinMaxValues GetMinMaxValuesFromAxisElements(IAxisElementContainer elementContainer, IScaleMap map);
    private MinMaxValues CheckAxisValueContainer(MinMaxValues minMaxValues, IAxisValueContainer valueContainer, IScaleMap map);
    protected AxisScaleTypeMap CreateScaleMap(Scale scaleType);
    protected internal abstract virtual ActualScaleTypeCore GetScaleType(RefinedSeries series);
    protected abstract virtual AxisQualitativeMap CreateQualitativeMap();
    protected virtual AxisScaleTypeMap CreateDefaultScaleMap();
    internal abstract virtual MinMaxValues GetMinMaxRefined();
    internal abstract virtual MinMaxValues GetMinMaxValuesFromSeries();
    internal abstract virtual MinMaxValues GetMinMaxValuesFromSeries(IMinMaxValues rangeForFiltering, ICollection`1<RefinedSeries> seriesForFiltering);
    internal abstract virtual double GetMinAbsValue();
    internal virtual void UpdateSideMarginsEnable();
    internal virtual void UpdateAxisData();
    internal void RemoveAllSeries();
    internal void AddSeries(RefinedSeries series, bool visible);
    internal void RemoveSeries(RefinedSeries series);
    internal void UpdateTransformation();
    internal void UpdateScaleBreaks();
    internal bool UpdateScaleMap(bool forceCreate, bool shouldRecalculateArgumentScale);
    internal void ScaleMapInvalidate();
    internal void InvalidateArgumentIntervals();
}
public class DevExpress.Charts.Native.RefinedSeriesGroupByArgument : RefinedSeriesGroup {
    private ISeriesBase seriesTemplate;
    internal RefinedSeriesGroupByArgument(RefinedSeriesGroupKey groupKey, ISeriesBase seriesTemplate);
    public static AxisQualitativeMap ProcessAxis(AxisQualitativeMap result, IAxisData axisElementContainer);
    private bool HasFullStackedSeries(ICollection`1<RefinedSeries> refinedSeries);
    private bool IsFullStackedSeries(ISeriesView view);
    private bool CalcSideMarginsEnable();
    private bool IsAutoMode(SideMarginMode mode);
    private MinMaxValues GetMinMaxByFilteredPoints(IMinMaxValues rangeForFiltering, ICollection`1<RefinedSeries> seriesList);
    private MinMaxValues FindFirstPoint(RefinedSeries series, MinMaxValues filter, int start, int increment);
    private MinMaxValues Filter(int i, RefinedSeries series, MinMaxValues filter);
    private void ProcessValueOptions(IWaterfallValueOptions valueOptions, AxisQualitativeMap qualitativeMap);
    protected virtual void ProcessPoints(RefinedSeries series, AxisQualitativeMap qualitativeMap);
    protected internal virtual ActualScaleTypeCore GetScaleType(RefinedSeries series);
    protected virtual AxisQualitativeMap CreateQualitativeMap();
    protected virtual AxisScaleTypeMap CreateDefaultScaleMap();
    internal virtual MinMaxValues GetMinMaxRefined();
    internal virtual MinMaxValues GetMinMaxValuesFromSeries();
    internal virtual MinMaxValues GetMinMaxValuesFromSeries(IMinMaxValues rangeForFiltering, ICollection`1<RefinedSeries> seriesForFiltering);
    internal virtual double GetMinAbsValue();
    internal virtual void UpdateSideMarginsEnable();
    internal virtual void UpdateAxisData();
    internal void CalculateFilteredIndexes(bool allowResamplerUpdates);
}
public class DevExpress.Charts.Native.RefinedSeriesGroupByArgument2 : RefinedSeriesGroupByArgument {
    internal RefinedSeriesGroupByArgument2(RefinedSeriesGroupKey groupKey);
    internal virtual MinMaxValues GetMinMaxRefined();
    internal virtual MinMaxValues GetMinMaxValuesFromSeries(IMinMaxValues rangeForFiltering, ICollection`1<RefinedSeries> seriesForFiltering);
    protected internal virtual ActualScaleTypeCore GetScaleType(RefinedSeries series);
    protected virtual void ProcessPoints(RefinedSeries series, AxisQualitativeMap qualitativeMap);
}
public class DevExpress.Charts.Native.RefinedSeriesGroupByValue : RefinedSeriesGroup {
    private IMinMaxValuesCalculator minMaxCalculator;
    private List`1<IAffectsAxisRange> indicators;
    internal RefinedSeriesGroupByValue(RefinedSeriesGroupKey groupKey, IMinMaxValuesCalculator minMaxCalculator);
    protected internal virtual ActualScaleTypeCore GetScaleType(RefinedSeries series);
    protected virtual AxisQualitativeMap CreateQualitativeMap();
    internal virtual MinMaxValues GetMinMaxRefined();
    internal virtual MinMaxValues GetMinMaxValuesFromSeries();
    internal virtual MinMaxValues GetMinMaxValuesFromSeries(IMinMaxValues rangeForFiltering, ICollection`1<RefinedSeries> seriesForFiltering);
    internal virtual double GetMinAbsValue();
    internal void AddIndicator(IAffectsAxisRange indicator);
    internal void ClearIndicators();
}
public class DevExpress.Charts.Native.RefinedSeriesGroupController : object {
    private Dictionary`2<RefinedSeriesGroupKey, RefinedSeriesGroup> refinedSeriesGroups;
    private RefinedSeriesRepository refinedSeriesRepository;
    internal Dictionary`2<RefinedSeriesGroupKey, RefinedSeriesGroup> RefinedSeriesGroups { get; }
    public RefinedSeriesGroupController(RefinedSeriesRepository refinedSeriesRepository);
    internal Dictionary`2<RefinedSeriesGroupKey, RefinedSeriesGroup> get_RefinedSeriesGroups();
    private RefinedSeriesGroup CreateGroup(RefinedSeriesGroupKey groupKey, IMinMaxValuesCalculator minMaxCalculator, AxisGroup axisGroup);
    private RefinedSeriesGroup GetGroup(RefinedSeriesGroupKey groupKey, IMinMaxValuesCalculator minMaxCalculator, AxisGroup axisGroup);
    private void RemoveFromSeriesGroup(RefinedSeriesGroup seriesGroup, RefinedSeries series);
    private RefinedSeriesGroup CreateFakeGroup(IAxisData axisData, IMinMaxValuesCalculator minMaxCalculator);
    internal void RemoveFromSeriesGroups(RefinedSeries series);
    internal void RemoveAllSeries();
    internal RefinedSeriesGroup FindRefinedSeriesGroup(IAxisData axis);
    internal RefinedSeriesGroup GetValueGroup(RefinedSeries series, IMinMaxValuesCalculator minMaxCalculator, AxisGroup axisGroup);
    internal RefinedSeriesGroup GetArgumentGroup(RefinedSeries series, AxisGroup axisGroup);
    internal List`1<RefinedSeries> RemoveSeriesGroup(IAxisData axis);
    internal RefinedSeriesGroup InsertGroup(IAxisData axis, IMinMaxValuesCalculator calculator);
    internal void RemoveGroup(IAxisData axis);
    internal void ClearGroup();
    internal void CalculateFilteredIndexes();
    internal void UpdateAxisData(IEnumerable`1<IAxisData> axes, IMinMaxValuesCalculator minMaxCalculator);
    internal void ClearSeparatePaneIndicators();
}
public class DevExpress.Charts.Native.RefinedSeriesGroupKey : object {
    private IAxisData axisData;
    public IAxisData AxisData { get; }
    public bool IsSeriesGroupKey { get; }
    public RefinedSeriesGroupKey(RefinedSeries series, AxisGroup axisGroup);
    public RefinedSeriesGroupKey(IAxisData axisData);
    public static bool op_Equality(RefinedSeriesGroupKey a, RefinedSeriesGroupKey b);
    public static bool op_Inequality(RefinedSeriesGroupKey a, RefinedSeriesGroupKey b);
    public IAxisData get_AxisData();
    public bool get_IsSeriesGroupKey();
    private IAxisData GetAxisByGroup(IXYSeriesView view, AxisGroup axisGroup);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(RefinedSeriesGroupKey key);
}
public class DevExpress.Charts.Native.RefinedSeriesIncompatibilityCalculator : SeriesIncompatibilityCalculatorBase`2<IXYSeriesView, IAxisData> {
    private ISeriesView baseView;
    private ISeries baseSeries;
    public bool CanCalculate { get; }
    public RefinedSeriesIncompatibilityCalculator(SeriesIncompatibilityStatistics statistics);
    public bool get_CanCalculate();
    protected virtual IXYSeriesView GetView(ISeries series);
    protected virtual IAxisData GetAxisXKey(IXYSeriesView view);
    protected virtual IAxisData GetAxisYKey(IXYSeriesView view);
    protected virtual bool CheckIncompatibleViewType(ISeries series, bool is3DView, CompatibleViewType diagramClass);
    public void Initialize(ISeries baseSeries, ISeriesView baseView);
    public bool IsVisibleAndCompatible(RefinedSeries refinedSeries);
}
public class DevExpress.Charts.Native.RefinedSeriesPointsUpdateInfo : object {
    private ChartCollectionOperation operation;
    private RefinedSeries refinedSeries;
    private RefinedPoint[] affectedPoints;
    private SeriesActionType updateType;
    public ChartCollectionOperation Operation { get; }
    public RefinedSeries RefinedSeries { get; }
    public RefinedPoint[] AffectedPoints { get; }
    public SeriesActionType UpdateType { get; }
    public RefinedSeriesPointsUpdateInfo(ChartCollectionOperation operation, RefinedSeries refinedSeries, RefinedPoint[] affectedPoints);
    public ChartCollectionOperation get_Operation();
    public RefinedSeries get_RefinedSeries();
    public RefinedPoint[] get_AffectedPoints();
    public SeriesActionType get_UpdateType();
    public void AddActionType(SeriesActionType updateType);
}
public class DevExpress.Charts.Native.RefinedSeriesRepository : object {
    private List`1<RefinedSeries> refinedSeries;
    private List`1<RefinedSeries> activeRefinedSeries;
    private List`1<RefinedSeries> seriesForLegend;
    private RefinedSeriesGroupController groupController;
    private InteractionManager interactionManager;
    private IChartDataContainer dataContainer;
    private IRefinedSeriesFactory refinedSeriesFactory;
    internal RefinedSeriesGroupController GroupController { get; }
    internal IList`1<RefinedSeries> ActiveRefinedSeries { get; }
    internal IList`1<RefinedSeries> RefinedSeries { get; }
    internal IList`1<RefinedSeries> SeriesForLegend { get; }
    internal InteractionManager InteractionManager { get; }
    internal ISeriesBase SeriesTemplate { get; }
    public bool IsContainsProcessedSeries { get; }
    public bool IsContainsProcessedPoints { get; }
    public bool IsContainsProcessedNotEmptyPoints { get; }
    private bool DevExpress.Charts.Native.IRefinedSeriesContainer.IsContainsProcessedPoints { get; }
    private bool DevExpress.Charts.Native.IRefinedSeriesContainer.IsDesignMode { get; }
    public RefinedSeriesRepository(IChartDataContainer dataContainer, IRefinedSeriesFactory factory);
    internal RefinedSeriesGroupController get_GroupController();
    internal IList`1<RefinedSeries> get_ActiveRefinedSeries();
    internal IList`1<RefinedSeries> get_RefinedSeries();
    internal IList`1<RefinedSeries> get_SeriesForLegend();
    internal InteractionManager get_InteractionManager();
    internal ISeriesBase get_SeriesTemplate();
    public bool get_IsContainsProcessedSeries();
    public bool get_IsContainsProcessedPoints();
    public bool get_IsContainsProcessedNotEmptyPoints();
    private RefinedSeries CreateRefinedSeries(ISeries series, IRefinedSeriesContainer seriesContainer);
    internal void AddToActive(RefinedSeries series, bool isVisibleAndCompatible, bool shouldBeDrawn);
    internal void RemoveSeriesGroup(IAxisData axis);
    internal void RemoveSeries(RefinedSeries series);
    internal RefinedSeries InsertSeries(int index, ISeries series);
    internal void InsertSeries(int index, IEnumerable`1<ISeries> seriesList);
    internal void CleanRefinedSeries();
    internal void SwapRefinedSeries(int newIndex, int oldIndex);
    internal void MoveRefinedSeries(int newIndex, int oldIndex);
    internal void ClearRefinedSeries();
    internal void ClearActiveRefinedSeries();
    internal RefinedSeries FindRefinedSeries(Func`2<RefinedSeries, bool> predicate);
    internal RefinedSeries FindRefinedSeries(ISeriesBase series);
    internal void RemoveFromSeriesGroups(RefinedSeries series);
    private sealed virtual override bool DevExpress.Charts.Native.IRefinedSeriesContainer.get_IsContainsProcessedPoints();
    private sealed virtual override bool DevExpress.Charts.Native.IRefinedSeriesContainer.get_IsDesignMode();
    private sealed virtual override MinMaxValues DevExpress.Charts.Native.IRefinedSeriesContainer.GetValuesRange(RefinedSeries refinedSeries);
}
public class DevExpress.Charts.Native.RefinedSeriesUpdateInfo : object {
    private ChartCollectionOperation operation;
    private IList`1<RefinedSeries> refinedSeries;
    public ChartCollectionOperation Operation { get; }
    public IList`1<RefinedSeries> RefinedSeries { get; }
    public RefinedSeriesUpdateInfo(ChartCollectionOperation operation, IList`1<RefinedSeries> refinedSeries);
    public ChartCollectionOperation get_Operation();
    public IList`1<RefinedSeries> get_RefinedSeries();
}
public abstract class DevExpress.Charts.Native.RegressionCalculator : object {
    protected Tuple`2<double, double> CalculateKAndB(IRefinedSeries series, double minArgument, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.RegressionLineCalculator : RegressionCalculator {
    public Tuple`2<GRealPoint2D, GRealPoint2D> Calculate(IRefinedSeries series, double x1, double x2, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.RelativeStrengthIndexCalculator : object {
    private static int DesignTimePointsCount;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount, ValueLevelInternal valueLevel);
    private double CalcNextEma(double value, double preEma, double smoothingFactor);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointCount, ValueLevelInternal valueLevel);
}
public class DevExpress.Charts.Native.ReplaceSeriesPointUpdateInfo : LightUpdateInfoBase {
    private ISeries series;
    private IDataPoint seriesPoint;
    private int index;
    public ISeries Series { get; }
    public IDataPoint SeriesPoint { get; }
    public int Index { get; }
    public ReplaceSeriesPointUpdateInfo(object sender, ISeries series, IDataPoint seriesPoint, int index);
    public ISeries get_Series();
    public IDataPoint get_SeriesPoint();
    public int get_Index();
}
internal class DevExpress.Charts.Native.ReplaceSeriesPointUpdateProcessor : LightUpdateProcessorBase`1<ReplaceSeriesPointUpdateInfo> {
    protected virtual IList`1<IUpdateAction> TypedProcess(ReplaceSeriesPointUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.ResamplerData : object {
    [CompilerGeneratedAttribute]
private int <EndIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IntervalData> <Offsets>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IComparable[]> <ResampledIntervalValues>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ViewportWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private IMinMaxValues <VisibleRange>k__BackingField;
    [CompilerGeneratedAttribute]
private IMinMaxValues <WholeRange>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ValuesDimension>k__BackingField;
    public int EndIndex { get; public set; }
    public IList`1<IntervalData> Offsets { get; public set; }
    public List`1<IComparable[]> ResampledIntervalValues { get; public set; }
    public int StartIndex { get; public set; }
    public int ViewportWidth { get; public set; }
    public IMinMaxValues VisibleRange { get; public set; }
    public IMinMaxValues WholeRange { get; public set; }
    public int ValuesDimension { get; public set; }
    [CompilerGeneratedAttribute]
public int get_EndIndex();
    [CompilerGeneratedAttribute]
public void set_EndIndex(int value);
    [CompilerGeneratedAttribute]
public IList`1<IntervalData> get_Offsets();
    [CompilerGeneratedAttribute]
public void set_Offsets(IList`1<IntervalData> value);
    [CompilerGeneratedAttribute]
public List`1<IComparable[]> get_ResampledIntervalValues();
    [CompilerGeneratedAttribute]
public void set_ResampledIntervalValues(List`1<IComparable[]> value);
    [CompilerGeneratedAttribute]
public int get_StartIndex();
    [CompilerGeneratedAttribute]
public void set_StartIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ViewportWidth();
    [CompilerGeneratedAttribute]
public void set_ViewportWidth(int value);
    [CompilerGeneratedAttribute]
public IMinMaxValues get_VisibleRange();
    [CompilerGeneratedAttribute]
public void set_VisibleRange(IMinMaxValues value);
    [CompilerGeneratedAttribute]
public IMinMaxValues get_WholeRange();
    [CompilerGeneratedAttribute]
public void set_WholeRange(IMinMaxValues value);
    [CompilerGeneratedAttribute]
public int get_ValuesDimension();
    [CompilerGeneratedAttribute]
public void set_ValuesDimension(int value);
}
public class DevExpress.Charts.Native.ResamplingSeriesBindingProcedure : SimpleSeriesBindingProcedure {
    private int endVisibleIndex;
    private ResamplerData previousPoint;
    private int previousPos;
    private ResamplerData resamplerData;
    private int startVisibleIndex;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumAllowedPointCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IComparable, double> <NativeToRefinedCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<double, IComparable> <RefinedToNativeCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ViewportWidth>k__BackingField;
    public Nullable`1<int> MaximumAllowedPointCount { get; public set; }
    public int MaxOutputPointsCount { get; }
    public Func`2<IComparable, double> NativeToRefinedCallback { get; public set; }
    public Func`2<double, IComparable> RefinedToNativeCallback { get; public set; }
    public ResamplerData ResamplerData { get; }
    public int ViewportWidth { get; public set; }
    public ResamplingSeriesBindingProcedure(SeriesDataAdapterSnapshot sanpshot, ResamplerData data, Func`2<IComparable, double> argumentRefineCallback, Func`2<double, IComparable> refinedToNativeCallback);
    private IntervalManager InvalidateIntervalManager(ResamplerData resampledPointData, IEnumerable`1<DataSourceUpdateInfoBase`1<IBindingProvider>> updates);
    private static bool IsEdgePos(int startVisibleIndex, int endVisibleIndex, int pos);
    private bool TryGetMinMaxInfo(ResamplerData rdata, int pos, IComparable[]& currentValues, Int32& newPos);
    private IntervalManager UpdateIntervalManager(ResamplerData resampledPointData, DataBrowser listBrowser, int resamplingValuesCount);
    private void UpdateResampledDataFromIntervalManager(IntervalManager intervalManager);
    protected virtual RangeIndexes DataReadStarted(RangeIndexes range, int itemsCount);
    public static IComparable Compare(IComparable a, IComparable b, bool getMin);
    public virtual List`1<IDataPoint> CreateBindingPoints();
    public bool ProcessUpdates(IEnumerable`1<DataSourceUpdateInfoBase`1<IBindingProvider>> updates);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumAllowedPointCount();
    [CompilerGeneratedAttribute]
public void set_MaximumAllowedPointCount(Nullable`1<int> value);
    public int get_MaxOutputPointsCount();
    [CompilerGeneratedAttribute]
public Func`2<IComparable, double> get_NativeToRefinedCallback();
    [CompilerGeneratedAttribute]
public void set_NativeToRefinedCallback(Func`2<IComparable, double> value);
    [CompilerGeneratedAttribute]
public Func`2<double, IComparable> get_RefinedToNativeCallback();
    [CompilerGeneratedAttribute]
public void set_RefinedToNativeCallback(Func`2<double, IComparable> value);
    public ResamplerData get_ResamplerData();
    [CompilerGeneratedAttribute]
public int get_ViewportWidth();
    [CompilerGeneratedAttribute]
public void set_ViewportWidth(int value);
    private IComparable[] GetValues(RowDataReader reader);
    private int GetResamplingValuesCount();
    private void UpdateValues(IComparable[]& prevValues, IComparable[] dataSourceValues);
    private void UpdateValuesFromCache(IComparable[]& prevValues, IComparable[] cacheValues);
    private void AddPoints(IComparable argument, IComparable[] values);
    public void EnsureViewport(int viewport);
}
public static class DevExpress.Charts.Native.ResamplingUtils : object {
    public static int MinimalStep;
    public static int MinimalStepForNonIntervalResampler;
}
public class DevExpress.Charts.Native.ResolveOverlappingByColumn : SimpleDiagramResolveOverlapping {
    public void ArrangeLabels(IList`1<IPieLabelLayout> labels, GRealRect2D bounds, int resolveOverlappingMinIndent);
    public void ArrangeGroup(List`1<IPieLabelLayout> labels, GRealRect2D bounds, int resolveOverlappingMinIndent);
    private void GroupLabelsByColumns(IList`1<IPieLabelLayout> labels, List`1<IPieLabelLayout> left, List`1<IPieLabelLayout> right);
    private bool Arrange(LabelInfo labelInfo, bool bottomPriority);
    private bool IsBottomPriority(LabelInfo label, IList`1<double> focuses);
    private List`1<LabelInfo> GetLabelsForArrangeByColumn(IList`1<IPieLabelLayout> labels, GRealRect2D bounds, int resolveOverlappingMinIndent);
    private List`1<double> CalcFocuses(GRealRect2D bounds);
    private double CalcWholeOverlap(IList`1<LabelInfo> labels, GRealRect2D bounds);
    private void ArrangeOverlapping(IList`1<LabelInfo> labels, double wholeOverlap);
    private void SetLabelItemPrevAndNext(LabelInfo label, LabelInfo prev, LabelInfo next);
    private void ArrangeNonOverlapping(IList`1<LabelInfo> labels, IList`1<double> focuses);
    private void PushToBottom(LabelInfo labelInfo, double val);
    private double CalculateTopMargin(LabelInfo labelInfo);
    private double CalculateBottomMargin(LabelInfo labelInfo);
    private void PushToTop(LabelInfo labelInfo, double val);
    private void PushNextToBottom(LabelInfo labelInfo, double val);
    private void PushPrevToTop(LabelInfo labelInfo, double val);
    private void BottomArrange(LabelInfo labelInfo);
    private void TopArrange(LabelInfo labelInfo);
}
public class DevExpress.Charts.Native.ResolveOverlappingByEllipse : SimpleDiagramResolveOverlapping {
    private List`1<LabelInfo> list;
    private List`1<LabelInfo> sortedList;
    private GRealPoint2D center;
    public void ArrangeLabels(IList`1<IPieLabelLayout> labels, GRealEllipse ellipse, int resolveOverlappingMinIndent, PointsSweepDirection direction, GRealRect2D diagramBounds);
    private List`1<LabelInfo> GetLabelsInfoForArrangeByEllipse(IList`1<IPieLabelLayout> labels, GRealEllipse ellipse, int resolveOverlappingMinIndent);
    private List`1<LabelInfoGroup> CalcGroups(List`1<LabelInfo> labelsInfo);
    private void ArrangeByEllipseInternal(List`1<LabelInfo> labelsInfo, PointsSweepDirection direction, GRealRect2D diagramBounds);
    private bool Arrange(LabelInfo labelInfo, PointsSweepDirection direction, GRealRect2D diagramBounds);
    private void Push(LabelInfo labelInfo, PointsSweepDirection direction, GRealRect2D diagramBounds, bool forward);
    private void CorrectCenterByDiagramBounds(LabelInfo labelInfo, GRealPoint2D center, GRealRect2D diagramBounds, PointsSweepDirection direction);
    private bool NextLabelIsNearest(LabelInfo labelInfo);
    private GRealPoint2D CalcCenter(LabelInfo labelInfo, bool fromPrev, PointsSweepDirection direction);
    private GRealPoint2D FindPoint(IList`1<GRealPoint2D> points, GRealRect2D bounds, GRealPoint2D center, bool forward, PointsSweepDirection direction);
    private bool IsAngleInRange(double angle, double angle1, double angle2);
    private double CalcAngle(GRealPoint2D p1, GRealPoint2D p2);
    private bool IsPositionValid(LabelInfo labelInfo, bool fromPrev);
    private bool IsCorrectedPositionValid(LabelInfo labelInfo, Nullable`1<bool> fromPrev);
    private bool IsPositionValidByBounds(LabelInfo labelInfo);
    private bool IsPositionValid(LabelInfo labelInfo);
    private LabelInfo GetNextByRefAngle(LabelInfo labelInfo);
    private LabelInfo GetPrevByRefAngle(LabelInfo labelInfo);
    private LabelInfo GetArrangedPrev(LabelInfo labelInfo);
    private LabelInfo GetArrangedNext(LabelInfo labelInfo);
}
public enum DevExpress.Charts.Native.ResolveOverlappingModeCore : Enum {
    public int value__;
    public static ResolveOverlappingModeCore None;
    public static ResolveOverlappingModeCore Default;
    public static ResolveOverlappingModeCore HideOverlapped;
    public static ResolveOverlappingModeCore JustifyAroundPoint;
    public static ResolveOverlappingModeCore JustifyAllAroundPoint;
}
internal class DevExpress.Charts.Native.RotationMatrix : object {
    private double m00;
    private double m01;
    private double m10;
    private double m11;
    private double GetRadianAngle(double degreeAngle);
    public void Rotate(double angle);
    public GRealPoint2D TransformPoint(GRealPoint2D point);
}
public class DevExpress.Charts.Native.Row : object {
    private DXRectangle bounds;
    private List`1<Cell> items;
    public DXRectangle Bounds { get; }
    public List`1<Cell> Items { get; }
    public Row(DXRectangle bounds);
    public Row(DXRectangle bounds, List`1<Cell> items);
    public DXRectangle get_Bounds();
    public List`1<Cell> get_Items();
    public sealed virtual int CompareTo(object obj);
    public void SeparateByVertical(int separator, int columnIndex);
    public Cell FindCell(int x, Int32& columnIndex);
}
public class DevExpress.Charts.Native.RowDataReader : object {
    private List`1<IDataMemberContainer> dataMemberContainers;
    private Dictionary`2<string, IDataMemberContainer> additionalContainers;
    [CompilerGeneratedAttribute]
private bool <IsEmpty>k__BackingField;
    public bool IsEmpty { get; private set; }
    public List`1<IDataMemberContainer> DataMemberContainers { get; }
    public Dictionary`2<string, IDataMemberContainer> AdditionalContainers { get; }
    public RowDataReader(List`1<IDataMemberContainer> dataMemberContainers, Dictionary`2<string, IDataMemberContainer> additionalContainers);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEmpty();
    [CompilerGeneratedAttribute]
private void set_IsEmpty(bool value);
    public sealed virtual List`1<IDataMemberContainer> get_DataMemberContainers();
    public sealed virtual Dictionary`2<string, IDataMemberContainer> get_AdditionalContainers();
    public bool Read();
    public bool CreateBrowsers(BindingEnvironment environment);
}
public class DevExpress.Charts.Native.Rows : object {
    private DXRectangle bounds;
    private List`1<Row> rows;
    public int Count { get; }
    public int ColumnsCount { get; }
    public Rows(DXRectangle bounds);
    public int get_Count();
    public int get_ColumnsCount();
    private List`1<Cell> FindIntersectionCells(DXRectangle rect);
    private Cell FindCell(int x, int y, Int32& rowIndex, Int32& columnIndex);
    private Row FindRow(int y, Int32& rowIndex);
    public void AddRectangle(DXRectangle rect);
    public void DeleteRectangle(DXRectangle rect);
    public Cell GetCell(int rowIndex, int columnIndex);
    public Cell FindNearCell(int x, int y, Int32& rowIndex, Int32& columnIndex);
    public bool IsEmptyRegion(DXRectangle rect);
    public void SeparateByHorizontal(int separator);
    public void SeparateByVertical(int separator);
}
public enum DevExpress.Charts.Native.Scale : Enum {
    public int value__;
    public static Scale Qualitative;
    public static Scale Numerical;
    public static Scale DateTime;
    public static Scale TimeSpan;
    public static Scale Auto;
}
public enum DevExpress.Charts.Native.ScaleBreakStyleCore : Enum {
    public int value__;
    public static ScaleBreakStyleCore Straight;
    public static ScaleBreakStyleCore Ragged;
    public static ScaleBreakStyleCore Waved;
}
public abstract class DevExpress.Charts.Native.ScaleCountersCalculatorBase : object {
    private ISeries series;
    private Dictionary`2<Scale, int> scaleCounters;
    private bool noArgumentScaleType;
    protected AxisGroup AxisGroup { get; }
    protected Scale UserScaleType { get; }
    protected ISeries Series { get; }
    public bool NoArgumentScaleType { get; }
    public Dictionary`2<Scale, int> ScaleCounters { get; }
    protected ScaleCountersCalculatorBase(ISeries series);
    protected abstract virtual AxisGroup get_AxisGroup();
    protected abstract virtual Scale get_UserScaleType();
    protected ISeries get_Series();
    public bool get_NoArgumentScaleType();
    public Dictionary`2<Scale, int> get_ScaleCounters();
    private void ResetScaleCounters();
    private Scale DetectScaleWithCounters(Dictionary`2<Scale, int> counter, Scale initialScale);
    protected bool CountScaleCounter(Scale scale, int value);
    protected abstract virtual bool CountScaleCounter(RefinedPoint point, int value);
    public void UpdateScaleCounters(RefinedPointCollectionBase points);
    public void UpdateScaleCounters(RefinedPointCollectionBase points, RefinedSeriesPointsUpdateInfo pointsUpdateInfo);
    public void UpdateScaleCounters(RefinedPointCollectionBase points, ICollection`1<RefinedSeriesPointsUpdateInfo> updates);
    public void DetectScale();
}
public class DevExpress.Charts.Native.ScaleCountersCalculatorX : ScaleCountersCalculatorBase {
    protected AxisGroup AxisGroup { get; }
    protected Scale UserScaleType { get; }
    public ScaleCountersCalculatorX(ISeries series);
    protected virtual AxisGroup get_AxisGroup();
    protected virtual Scale get_UserScaleType();
    protected virtual bool CountScaleCounter(RefinedPoint point, int value);
}
public class DevExpress.Charts.Native.ScaleCountersCalculatorY : ScaleCountersCalculatorBase {
    protected AxisGroup AxisGroup { get; }
    protected Scale UserScaleType { get; }
    public ScaleCountersCalculatorY(ISeries series);
    protected virtual AxisGroup get_AxisGroup();
    protected virtual Scale get_UserScaleType();
    protected virtual bool CountScaleCounter(RefinedPoint point, int value);
}
internal class DevExpress.Charts.Native.ScaleDiapasonCalculator : object {
    private static void Calculate(IAutoScaleBreaksContainer scaleBreaksContainer, IList`1<double> initialValues, Transformation transform);
    private static IEnumerable`1<double> CalculateInitialValuesCore(IAutoScaleBreaksContainer scaleBreaksContainer, ISeries series, RefinedPoint point);
    internal static List`1<double> CalculateInitialValues(IAutoScaleBreaksContainer scaleBreaksContainer, IAxisData axis, IList`1<IRefinedSeries> refinedSeries);
    internal static bool IsCompatibleWithAxis(IAxisData axis, IAxisValueContainer container);
    public static IList`1<IScaleDiapason> CalculateScaleDiapasons(IAxisData axis, IAutoScaleBreaksContainer autoScaleBreaksContainer);
    public static void UpdateAutomaticScaleBreaks(IAutoScaleBreaksContainer scaleBreaksContainer, IAxisData axis, List`1<IRefinedSeries> refinedSeries);
}
public enum DevExpress.Charts.Native.ScaleModeNative : Enum {
    public int value__;
    public static ScaleModeNative Automatic;
    public static ScaleModeNative Manual;
    public static ScaleModeNative Continuous;
    public static ScaleModeNative Interval;
}
public class DevExpress.Charts.Native.ScaleOptionsInfo : ValueType {
    private ScaleModeNative scaleMode;
    private object measureUnit;
    private int measureUnitMultiplier;
    private AggregationIntervalsInfo aggregationIntervalsInfo;
    public ScaleOptionsInfo(ScaleModeNative scaleMode, object measureUnit, int measureUnitMultiplier);
    public ScaleOptionsInfo(ScaleModeNative scaleMode, object measureUnit, int measureUnitMultiplier, AggregationIntervalsInfo aggregationIntervalsInfo);
    public static bool op_Equality(ScaleOptionsInfo a, ScaleOptionsInfo b);
    public static bool op_Inequality(ScaleOptionsInfo a, ScaleOptionsInfo b);
    public sealed virtual bool Equals(ScaleOptionsInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.ScatterLineViewportIntersectionHolder : LineViewportIntersectionHolder {
    public ScatterLineViewportIntersectionHolder(IXYSeriesView view, int pointsCount);
}
public enum DevExpress.Charts.Native.ScrollingOrientation : Enum {
    public int value__;
    public static ScrollingOrientation None;
    public static ScrollingOrientation AxisXScroll;
    public static ScrollingOrientation AxisYScroll;
}
public enum DevExpress.Charts.Native.SegmentKind : Enum {
    public int value__;
    public static SegmentKind None;
    public static SegmentKind Left;
    public static SegmentKind LeftBottom;
    public static SegmentKind Bottom;
    public static SegmentKind RightBottom;
    public static SegmentKind Right;
    public static SegmentKind RightTop;
    public static SegmentKind Top;
    public static SegmentKind LeftTop;
}
internal static class DevExpress.Charts.Native.SegmentKindHelper : object {
    public static SegmentKind GetKindForLineSegment(int index);
    public static SegmentKind GetKindForArcSegment(int index);
}
public class DevExpress.Charts.Native.SelectionUpdateInfo : LightUpdateInfoBase {
    public SelectionUpdateInfo(object sender);
}
internal class DevExpress.Charts.Native.SelectionUpdateProcessor : LightUpdateProcessorBase`1<SelectionUpdateInfo> {
    protected virtual IList`1<IUpdateAction> TypedProcess(SelectionUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.SeparatorInfo : object {
    [CompilerGeneratedAttribute]
private DXRectangle <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVerticalRelation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Row>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Item1Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Item2Index>k__BackingField;
    public DXRectangle Bounds { get; internal set; }
    public bool IsVerticalRelation { get; private set; }
    public int Row { get; private set; }
    public int Column { get; private set; }
    public int Item1Index { get; private set; }
    public int Item2Index { get; private set; }
    public SeparatorInfo(DXRectangle bounds, int item1Index, int item2Index, bool isVerticalRelation);
    [CompilerGeneratedAttribute]
public DXRectangle get_Bounds();
    [CompilerGeneratedAttribute]
internal void set_Bounds(DXRectangle value);
    [CompilerGeneratedAttribute]
public bool get_IsVerticalRelation();
    [CompilerGeneratedAttribute]
private void set_IsVerticalRelation(bool value);
    [CompilerGeneratedAttribute]
public int get_Row();
    [CompilerGeneratedAttribute]
private void set_Row(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    [CompilerGeneratedAttribute]
public int get_Item1Index();
    [CompilerGeneratedAttribute]
private void set_Item1Index(int value);
    [CompilerGeneratedAttribute]
public int get_Item2Index();
    [CompilerGeneratedAttribute]
private void set_Item2Index(int value);
    internal void SetRowColumn(int row, int column);
}
public class DevExpress.Charts.Native.SerializableSeriesPointDataContainer : SeriesPointDataContainer {
    [CompilerGeneratedAttribute]
private string <QualitativeArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime[] <DateTimeValues>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan[] <TimeSpanValues>k__BackingField;
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    public int Dimension { get; }
    public string QualitativeArgument { get; public set; }
    public Double[] Values { get; public set; }
    public DateTime[] DateTimeValues { get; public set; }
    public TimeSpan[] TimeSpanValues { get; public set; }
    public SerializableSeriesPointDataContainer(SeriesPointDataContainer dataContainer);
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual int get_Dimension();
    [CompilerGeneratedAttribute]
public virtual string get_QualitativeArgument();
    [CompilerGeneratedAttribute]
public virtual void set_QualitativeArgument(string value);
    [CompilerGeneratedAttribute]
public virtual Double[] get_Values();
    [CompilerGeneratedAttribute]
public virtual void set_Values(Double[] value);
    [CompilerGeneratedAttribute]
public virtual DateTime[] get_DateTimeValues();
    [CompilerGeneratedAttribute]
public virtual void set_DateTimeValues(DateTime[] value);
    [CompilerGeneratedAttribute]
public virtual TimeSpan[] get_TimeSpanValues();
    [CompilerGeneratedAttribute]
public virtual void set_TimeSpanValues(TimeSpan[] value);
    public virtual SeriesPointDataContainer SetDimension(int dimension);
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
[FlagsAttribute]
public enum DevExpress.Charts.Native.SeriesActionType : Enum {
    public int value__;
    public static SeriesActionType Empty;
    public static SeriesActionType UpdateInteraction;
    public static SeriesActionType UpdateAutoScale;
    public static SeriesActionType RemoveRefinedSeriesFromGroup;
    public static SeriesActionType UpdateRefinedSeriesData;
    public static SeriesActionType UpdateSeriesPointKey;
    public static SeriesActionType UpdateSeriesPointMode;
    public static SeriesActionType UpdatePointsFilter;
    public static SeriesActionType UpdatePointsValuesOnly;
}
public abstract class DevExpress.Charts.Native.SeriesBindingProcedure : BindingProcedure {
    private int dataItemsCount;
    private SeriesDataAdapterSnapshot seriesDataAdapterSnapshot;
    [CompilerGeneratedAttribute]
private List`1<IDataPoint> <Points>k__BackingField;
    protected SeriesDataAdapterSnapshot DataAdapter { get; }
    protected List`1<IDataPoint> Points { get; }
    public bool IsContinuousData { get; }
    protected SeriesBindingProcedure(SeriesDataAdapterSnapshot seriesDataAdapterSnapshot);
    protected SeriesDataAdapterSnapshot get_DataAdapter();
    [CompilerGeneratedAttribute]
protected List`1<IDataPoint> get_Points();
    public bool get_IsContinuousData();
    public virtual List`1<IDataPoint> CreateBindingPoints();
    protected abstract virtual void OnDataReadFinished();
    protected abstract virtual void OnDataRowRead(object dataRow, RowDataReader dataReader, int position);
    protected virtual RangeIndexes DataReadStarted(RangeIndexes range, int itemsCount);
    protected virtual Dictionary`2<string, IDataMemberContainer> CreateAdditionalDataMemberContainers();
}
public abstract class DevExpress.Charts.Native.SeriesBindingProcessorBase : BindingProcessorBase {
    [CompilerGeneratedAttribute]
private BoundPointsList <BoundPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private ISeriesBindingProvider <SeriesBindingProvider>k__BackingField;
    protected BoundPointsList BoundPoints { get; }
    protected ISeriesBindingProvider SeriesBindingProvider { get; }
    protected ISeries Series { get; }
    protected SeriesBindingProcessorBase(ISeriesBindingProvider seriesBindingProvider, BoundPointsList boundPoints);
    [CompilerGeneratedAttribute]
protected BoundPointsList get_BoundPoints();
    [CompilerGeneratedAttribute]
protected ISeriesBindingProvider get_SeriesBindingProvider();
    protected ISeries get_Series();
    private bool ProcessInsert(int startIndex, int count);
    private bool ProcessItemChanged(int startIndex, int count);
    private bool ProcessRemove(int startIndex, int count);
    protected abstract virtual bool ResetSeriesBinding();
    protected abstract virtual IDataPoint GetBoundPoint(int index);
    protected Tuple`3<bool, bool, bool> ProcessUpdateCore(DataSourceUpdateInfoBase`1<IBindingProvider> update);
    protected Tuple`2<bool, bool> ProcessUpdatesCore(DataSourceUpdateInfoCollection updates, bool seriesCountChanged, bool isContinuousData);
}
internal class DevExpress.Charts.Native.SeriesCollectionAction : object {
    private ISeries series;
    private CollectionActionType updateType;
    private int index;
    private int oldIndex;
    public int Index { get; public set; }
    public int OldIndex { get; public set; }
    public ISeries Series { get; }
    public CollectionActionType UpdateType { get; }
    private ISeriesBase DevExpress.Charts.Native.ISeriesUpdateAction.Series { get; }
    public SeriesCollectionAction(CollectionActionType updateType);
    public SeriesCollectionAction(ISeries series, CollectionActionType updateType);
    public SeriesCollectionAction(int index, ISeries series, CollectionActionType updateType);
    public SeriesCollectionAction(int oldIndex, int newIndex, CollectionActionType updateType);
    public int get_Index();
    public void set_Index(int value);
    public int get_OldIndex();
    public void set_OldIndex(int value);
    public ISeries get_Series();
    public CollectionActionType get_UpdateType();
    private sealed virtual override ISeriesBase DevExpress.Charts.Native.ISeriesUpdateAction.get_Series();
}
public class DevExpress.Charts.Native.SeriesCollectionBatchUpdateInfo : CollectionUpdateInfo`1<ICollection`1<ISeries>> {
    public SeriesCollectionBatchUpdateInfo(object sender, ChartCollectionOperation operation, ICollection`1<ISeries> oldItem, int oldIndex, ICollection`1<ISeries> newItem, int newIndex);
}
internal class DevExpress.Charts.Native.SeriesCollectionBatchUpdateProcessor : CollectionUpdateProcessor`1<SeriesCollectionBatchUpdateInfo> {
    protected CommonActionType AdditionalUpdates { get; }
    protected virtual CommonActionType get_AdditionalUpdates();
    protected virtual IList`1<IUpdateAction> TypedProcess(SeriesCollectionBatchUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.SeriesCollectionUpdateInfo : CollectionUpdateInfo`1<ISeries> {
    public SeriesCollectionUpdateInfo(object sender, ChartCollectionOperation operation, ISeries oldItem, int oldIndex, ISeries newItem, int newIndex);
}
internal class DevExpress.Charts.Native.SeriesCollectionUpdateProcessor : CollectionUpdateProcessor`1<SeriesCollectionUpdateInfo> {
    protected CommonActionType AdditionalUpdates { get; }
    protected virtual CommonActionType get_AdditionalUpdates();
    protected virtual IList`1<IUpdateAction> TypedProcess(SeriesCollectionUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.SeriesComparerByActiveIndex : Comparer`1<RefinedSeries> {
    public virtual int Compare(RefinedSeries series1, RefinedSeries series2);
}
public abstract class DevExpress.Charts.Native.SeriesContainer : object {
    private ISeriesView view;
    private List`1<RefinedSeries> series;
    public ISeriesView SeriesView { get; }
    public List`1<RefinedSeries> Series { get; }
    public bool IsEmpty { get; }
    public IList`1<IPointInteraction> PointInteractions { get; }
    protected SeriesContainer(ISeriesView view);
    public ISeriesView get_SeriesView();
    public List`1<RefinedSeries> get_Series();
    public sealed virtual bool get_IsEmpty();
    public abstract virtual IList`1<IPointInteraction> get_PointInteractions();
    protected virtual void SuspendUpdate();
    protected virtual void ResumeUpdate();
    protected abstract virtual void InsertRefinedPoints(int seriesIndex, RefinedSeries refinedSeries);
    protected abstract virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries refinedSeries, bool removeAll);
    protected abstract virtual void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected abstract virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected abstract virtual void ResetRefinedSeries(RefinedSeries refinedSeries);
    internal void UpdatePoints(RefinedSeriesPointsUpdateInfo update);
    internal virtual void ApplySeriesViewData();
    public bool Contains(RefinedSeries refinedSeries);
    public abstract virtual void Recalculate();
}
public class DevExpress.Charts.Native.SeriesController : object {
    private SeriesIncompatibilityStatistics incompatibilityStatistics;
    private IChartDataContainer dataContainer;
    private RefinedSeriesRepository seriesRepository;
    private IDiagramProvider diagramProvider;
    private SeriesControllerTransaction transaction;
    internal IDiagramProvider DiagramProvider { get; }
    internal IDiagram Diagram { get; }
    internal Nullable`1<CompatibleViewType> CompatibleViewFormDiagram { get; }
    internal IChartDataContainer DataContainer { get; }
    internal Dictionary`2<RefinedSeriesGroupKey, RefinedSeriesGroup> RefinedSeriesGroups { get; }
    internal RefinedSeriesRepository SeriesRepository { get; }
    public IList`1<RefinedSeries> RefinedSeries { get; }
    public IList`1<RefinedSeries> ActiveRefinedSeries { get; }
    public IList`1<RefinedSeries> SeriesForLegend { get; }
    public InteractionManager InteractionManager { get; }
    public IEnumerable`1<RefinedSeriesGroup> RefinedSeriesGroupList { get; }
    public SeriesIncompatibilityStatistics SeriesIncompatibilityStatistics { get; }
    public bool IsContainsProcessedSeries { get; }
    public bool IsContainsProcessedPoints { get; }
    public bool IsContainsProcessedNotEmptyPoints { get; }
    public bool IsTransactionOpen { get; }
    public SeriesController(IChartDataContainer dataContainer, IDiagramProvider diagramProvider, IRefinedSeriesFactory factory);
    internal IDiagramProvider get_DiagramProvider();
    internal IDiagram get_Diagram();
    internal Nullable`1<CompatibleViewType> get_CompatibleViewFormDiagram();
    internal IChartDataContainer get_DataContainer();
    internal Dictionary`2<RefinedSeriesGroupKey, RefinedSeriesGroup> get_RefinedSeriesGroups();
    internal RefinedSeriesRepository get_SeriesRepository();
    public IList`1<RefinedSeries> get_RefinedSeries();
    public IList`1<RefinedSeries> get_ActiveRefinedSeries();
    public IList`1<RefinedSeries> get_SeriesForLegend();
    public InteractionManager get_InteractionManager();
    public IEnumerable`1<RefinedSeriesGroup> get_RefinedSeriesGroupList();
    public SeriesIncompatibilityStatistics get_SeriesIncompatibilityStatistics();
    public bool get_IsContainsProcessedSeries();
    public bool get_IsContainsProcessedPoints();
    public bool get_IsContainsProcessedNotEmptyPoints();
    public bool get_IsTransactionOpen();
    public bool ShouldForceUpdate();
    public void OpenTransaction();
    public void ProcessUpdate(ChartUpdateInfoBase updateInfo, bool loading);
    public SeriesControllerChanges CommitTransaction(bool loading);
    public IList`1<ISeries> GetSeriesByAxis(IAxisData axis);
    public IList`1<RefinedSeries> GetRefinedSeriesByAxis(IAxisData axis);
    public IMinMaxValues GetAxisRange(IAxisData axis);
}
[FlagsAttribute]
public enum DevExpress.Charts.Native.SeriesControllerChanges : Enum {
    public int value__;
    public static SeriesControllerChanges NoChanges;
    public static SeriesControllerChanges RefinedDataUpdated;
    public static SeriesControllerChanges WholeArgumentRangeUpdated;
    public static SeriesControllerChanges VisualArgumentRangeUpdated;
    public static SeriesControllerChanges ShouldUpdateMeasureUnits;
    public static SeriesControllerChanges ShouldResetSelectedItems;
    public static SeriesControllerChanges ValueRangeChanged;
    public static SeriesControllerChanges ShouldAnimateChart;
}
public class DevExpress.Charts.Native.SeriesDataAdapterPropertyUpdateInfo : PropertyUpdateInfo {
    private ISeries series;
    public ISeries Series { get; }
    public SeriesDataAdapterPropertyUpdateInfo(object sender, string propertyName, ISeries series);
    public ISeries get_Series();
}
public class DevExpress.Charts.Native.SeriesDataAdapterSnapshot : object {
    [CompilerGeneratedAttribute]
private string <ArgumentDataMember>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArgumentDataMember2>k__BackingField;
    [CompilerGeneratedAttribute]
private Scale <ArgumentScaleType>k__BackingField;
    [CompilerGeneratedAttribute]
private Scale <ArgumentScaleType2>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ICalculatedField> <CalculatedFields>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColorDataMember>k__BackingField;
    [CompilerGeneratedAttribute]
private CriteriaOperator <Criteria>k__BackingField;
    [CompilerGeneratedAttribute]
private DataContextBase <DataContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DataMember>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DataSource>k__BackingField;
    [CompilerGeneratedAttribute]
private SeriesFilterHelper <FilterHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDataSourceIndicator> <Indicators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessMissingArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <SeriesValueDataMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolTipHintDataMember>k__BackingField;
    [CompilerGeneratedAttribute]
private ISeries <Series>k__BackingField;
    [CompilerGeneratedAttribute]
private ISeriesView <SeriesView>k__BackingField;
    [CompilerGeneratedAttribute]
private Scale <ValueScaleType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessMissingValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTwoArgumentsSeries>k__BackingField;
    public string ArgumentDataMember { get; }
    public string ArgumentDataMember2 { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ArgumentScaleType2 { get; }
    public IEnumerable`1<ICalculatedField> CalculatedFields { get; }
    public string ColorDataMember { get; }
    public CriteriaOperator Criteria { get; }
    public DataContextBase DataContext { get; }
    public string DataMember { get; }
    public object DataSource { get; }
    public SeriesFilterHelper FilterHelper { get; }
    public IList`1<IDataSourceIndicator> Indicators { get; }
    public bool ProcessMissingArguments { get; }
    public IList`1<string> SeriesValueDataMembers { get; }
    public string ToolTipHintDataMember { get; }
    public ISeries Series { get; }
    public ISeriesView SeriesView { get; }
    public Scale ValueScaleType { get; }
    public bool ProcessMissingValues { get; }
    public bool IsTwoArgumentsSeries { get; }
    public SeriesDataAdapterSnapshot(ISeries series);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ArgumentDataMember();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ArgumentDataMember2();
    [CompilerGeneratedAttribute]
public sealed virtual Scale get_ArgumentScaleType();
    [CompilerGeneratedAttribute]
public sealed virtual Scale get_ArgumentScaleType2();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ICalculatedField> get_CalculatedFields();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColorDataMember();
    [CompilerGeneratedAttribute]
public sealed virtual CriteriaOperator get_Criteria();
    [CompilerGeneratedAttribute]
public sealed virtual DataContextBase get_DataContext();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DataMember();
    [CompilerGeneratedAttribute]
public sealed virtual object get_DataSource();
    [CompilerGeneratedAttribute]
public sealed virtual SeriesFilterHelper get_FilterHelper();
    [CompilerGeneratedAttribute]
public IList`1<IDataSourceIndicator> get_Indicators();
    [CompilerGeneratedAttribute]
public bool get_ProcessMissingArguments();
    [CompilerGeneratedAttribute]
public IList`1<string> get_SeriesValueDataMembers();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ToolTipHintDataMember();
    [CompilerGeneratedAttribute]
public ISeries get_Series();
    [CompilerGeneratedAttribute]
public ISeriesView get_SeriesView();
    [CompilerGeneratedAttribute]
public sealed virtual Scale get_ValueScaleType();
    [CompilerGeneratedAttribute]
public bool get_ProcessMissingValues();
    [CompilerGeneratedAttribute]
public bool get_IsTwoArgumentsSeries();
    public sealed virtual IList`1<string> GetSeriesValueDataMembers();
}
public class DevExpress.Charts.Native.SeriesFilterHelper : ControlFilterHelper {
    private ISeriesDataAdapter dataAdapter;
    private PropertyDescriptorCollection filteringUIDataProperties;
    public PropertyDescriptorCollection FilteringUIDataProperties { get; }
    public bool Enabled { get; }
    public SeriesFilterHelper(ISeriesDataAdapter dataAdapter);
    private static bool IsUniqueProperty(List`1<PropertyDescriptor> parentProperties, PropertyDescriptor property);
    private static CriteriaOperator GetOperatorWithoutProperty(CriteriaOperator criteria, string propertyPath);
    public static bool IsSameProperty(PropertyDescriptor parentProperty, PropertyDescriptor property);
    public PropertyDescriptorCollection get_FilteringUIDataProperties();
    public bool get_Enabled();
    private sealed virtual override PropertyDescriptorCollection DevExpress.Data.Filtering.IControlFilterColumnsProvider.GetColumnDescriptors();
    private List`1<PropertyDescriptor> ConstructComplexProperties(List`1<PropertyDescriptor> parentProperties, BindingEnvironment environment, string dataMember);
    protected virtual CriteriaOperator GetFilterCriteria();
    protected virtual IControlFilterColumnsProvider GetFilterColumnsProvider();
    public void OnUpdateCriteria();
    public bool EnsureFilteringUIDataProperties();
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.SeriesFilterHelper/<GetValues>d__18")]
public IEnumerable`1<object> GetValues(string propertyPath);
    public PropertyDescriptorCollection GetDataProperties();
    public ChartBoundPropertyCollection GetBoundProperties();
}
public class DevExpress.Charts.Native.SeriesGeometry : object {
    private StackedGeometry stackedGeometry;
    private ISeries series;
    private IList`1<IGeometryStrip> geometry;
    public IList`1<IGeometryStrip> Geometry { get; }
    public SeriesGeometry(StackedGeometry stackedGeometry, ISeries series);
    public IList`1<IGeometryStrip> get_Geometry();
    private LineStrip CreateConstantStrip(IGeometryStripCreator stripCreator, double constant, IList`1<double> arguments);
    public void SetGeometry(IList`1<IGeometryStrip> geometry, IList`1<double> arguments);
}
public class DevExpress.Charts.Native.SeriesGroupArgumentIntervalsContainer : object {
    private RefinedSeriesGroup owner;
    private List`1<DoubleLimits> argumentsWithoutGaps;
    private bool isCalculated;
    private DateTimeMeasureUnitNative currentMeasureUnit;
    private int currentMeasureUnitMultiplier;
    private bool shouldUpdateDependentData;
    public bool ShouldUpdateDependentData { get; }
    public SeriesGroupArgumentIntervalsContainer(RefinedSeriesGroup group);
    public bool get_ShouldUpdateDependentData();
    private void Recalculate(DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    private bool GetDateTimeSkipRangesWithoutPoints();
    public bool NeedRecreate(DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public bool NeedRecalculate();
    public List`1<DoubleLimits> GetArgumentsWithoutGaps(DateTimeMeasureUnitNative measureUnit, int measureUnitMultiplier);
    public void Invalidate();
}
public abstract class DevExpress.Charts.Native.SeriesGroupsInteractionContainer : SeriesInteractionContainer {
    private SeriesGroupsManager groupsManager;
    public double Max { get; }
    public double Min { get; }
    private int DevExpress.Charts.Native.IPointInteraction.Count { get; }
    private double DevExpress.Charts.Native.IPointInteraction.ArgumentX { get; }
    private double DevExpress.Charts.Native.IPointInteraction.ArgumentY { get; }
    protected SeriesGroupsInteractionContainer(ISeriesView view);
    public virtual double get_Max();
    public virtual double get_Min();
    private sealed virtual override int DevExpress.Charts.Native.IPointInteraction.get_Count();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.get_ArgumentX();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.get_ArgumentY();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMinValue(ISeriesView seriesView);
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMaxValue(ISeriesView seriesView);
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMinAbsValue(ISeriesView seriesView);
    protected int GetSeriesGroupIndex(RefinedSeries series);
    protected abstract virtual void RecalculateCore(int groupsCount);
    protected virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries refinedSeries, bool removeAll);
    protected virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    public virtual void AddSeries(RefinedSeries refinedSeries);
    public virtual void RemoveSeries(RefinedSeries refinedSeries);
    public virtual void Recalculate();
    public virtual double GetAbsMinValue();
}
public class DevExpress.Charts.Native.SeriesGroupsManager : object {
    private Dictionary`2<RefinedSeries, int> groups;
    private List`1<RefinedSeries> series;
    private int groupsCount;
    public int GroupsCount { get; }
    public SeriesGroupsManager(List`1<RefinedSeries> series);
    public int get_GroupsCount();
    private int GetGroupIndex(object groupKey);
    public void UpdateGroups();
    public int GetGroupIndexBySeries(RefinedSeries series);
}
public abstract class DevExpress.Charts.Native.SeriesIncompatibilityCalculatorBase`2 : object {
    private SeriesIncompatibilityStatistics statistics;
    private Dictionary`2<AXISKEY, MasterSeriesInfo<VIEW, AXISKEY>> masterSeriesForAxisXDictionary;
    private Dictionary`2<AXISKEY, MasterSeriesInfo<VIEW, AXISKEY>> masterSeriesForAxisYDictionary;
    protected SeriesIncompatibilityCalculatorBase`2(SeriesIncompatibilityStatistics statistics);
    protected abstract virtual VIEW GetView(ISeries series);
    protected abstract virtual AXISKEY GetAxisXKey(VIEW view);
    protected abstract virtual AXISKEY GetAxisYKey(VIEW view);
    protected abstract virtual bool CheckIncompatibleViewType(ISeries series, bool is3DView, CompatibleViewType diagramClass);
    public bool IsVisibleAndCompatible(RefinedSeries refinedSeries, bool is3DView, CompatibleViewType diagramClass, ISeries baseSeries);
    public bool IsVisible(ISeries series);
    public bool IsCompatible(RefinedSeries refinedSeries, bool is3DView, CompatibleViewType diagramClass, ISeries baseSeries);
    public Scale GetAxisXMasterScaleType(RefinedSeries refinedSeries);
    public void AddTemplateView(VIEW view, Scale argumentScaleType, Scale valueScaleType);
}
public class DevExpress.Charts.Native.SeriesIncompatibilityInfo : Dictionary`2<SeriesIncompatibilityType, ISeries> {
    public void AddIncompatibility(SeriesIncompatibilityType type, ISeries masterSeries);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.SeriesIncompatibilityStatistics : object {
    private Dictionary`2<ISeries, SeriesIncompatibilityInfo> dictionary;
    public SeriesIncompatibilityInfo Item { get; }
    public SeriesIncompatibilityInfo get_Item(ISeries series);
    public bool IsSeriesIncompatible(ISeries series);
    public void Add(ISeries series, SeriesIncompatibilityType type, ISeries masterSeries);
    public void Clear();
}
public enum DevExpress.Charts.Native.SeriesIncompatibilityType : Enum {
    public int value__;
    public static SeriesIncompatibilityType ByViewType;
    public static SeriesIncompatibilityType ByArgumentScaleType;
    public static SeriesIncompatibilityType ByValueScaleType;
    public static SeriesIncompatibilityType Invisible;
}
public abstract class DevExpress.Charts.Native.SeriesInteractionContainer : SeriesContainer {
    private SeriesComparerByActiveIndex seriesComparer;
    [CompilerGeneratedAttribute]
private bool <LockRecalculate>k__BackingField;
    protected bool LockRecalculate { get; protected set; }
    public double Max { get; }
    public double Min { get; }
    protected SeriesInteractionContainer(ISeriesView view);
    [CompilerGeneratedAttribute]
protected bool get_LockRecalculate();
    [CompilerGeneratedAttribute]
protected void set_LockRecalculate(bool value);
    public abstract virtual double get_Max();
    public abstract virtual double get_Min();
    protected virtual void ResetRefinedSeries(RefinedSeries refinedSeries);
    public abstract virtual double GetAbsMinValue();
    public virtual void AddSeries(RefinedSeries refinedSeries);
    public virtual void RemoveSeries(RefinedSeries refinedSeries);
    public int GetSeriesIndex(RefinedSeries refinedSeries);
    public void SwapSeries(RefinedSeries series1, RefinedSeries series2);
    public virtual void EnsureInteractions();
}
public class DevExpress.Charts.Native.SeriesPatternDataProvider : PatternDataProvider {
    private string patternConstant;
    private ISeries Series { get; }
    public SeriesPatternDataProvider(string patternConstant);
    private ISeries get_Series();
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public abstract class DevExpress.Charts.Native.SeriesPointArgumentContainerBase : object {
    private ISeriesPoint seriesPoint;
    private string argument;
    private Nullable`1<double> numericalArgument;
    private Nullable`1<DateTime> dateTimeArgument;
    private Nullable`1<TimeSpan> timeSpanArgument;
    private Scale argumentScaleType;
    protected ISeriesBase Series { get; }
    protected Scale SeriesArgumentScaleType { get; }
    protected object UserArgumentInternal { get; }
    public string Argument { get; public set; }
    public double NumericalArgument { get; public set; }
    public DateTime DateTimeArgument { get; public set; }
    public TimeSpan TimeSpanArgument { get; public set; }
    public string ActualArgument { get; }
    public Scale ArgumentScaleType { get; }
    private Scale DevExpress.Charts.Native.ISeriesPointArgument.ArgumentScaleType { get; }
    private object DevExpress.Charts.Native.ISeriesPointArgument.UserArgument { get; }
    private string DevExpress.Charts.Native.ISeriesPointArgument.QualitativeArgument { get; }
    private double DevExpress.Charts.Native.ISeriesPointArgument.NumericalArgument { get; }
    private DateTime DevExpress.Charts.Native.ISeriesPointArgument.DateTimeArgument { get; }
    private TimeSpan DevExpress.Charts.Native.ISeriesPointArgument.TimeSpanArgument { get; }
    public SeriesPointArgumentContainerBase(ISeriesPoint seriesPoint);
    public SeriesPointArgumentContainerBase(ISeriesPoint seriesPoint, double argument);
    public SeriesPointArgumentContainerBase(ISeriesPoint seriesPoint, DateTime argument);
    public SeriesPointArgumentContainerBase(ISeriesPoint seriesPoint, TimeSpan argument);
    public SeriesPointArgumentContainerBase(ISeriesPoint seriesPoint, string argument);
    public SeriesPointArgumentContainerBase(ISeriesPoint seriesPoint, object argument);
    protected ISeriesBase get_Series();
    protected abstract virtual Scale get_SeriesArgumentScaleType();
    protected object get_UserArgumentInternal();
    public string get_Argument();
    public void set_Argument(string value);
    public double get_NumericalArgument();
    public void set_NumericalArgument(double value);
    public DateTime get_DateTimeArgument();
    public void set_DateTimeArgument(DateTime value);
    public TimeSpan get_TimeSpanArgument();
    public void set_TimeSpanArgument(TimeSpan value);
    public string get_ActualArgument();
    public Scale get_ArgumentScaleType();
    private sealed virtual override Scale DevExpress.Charts.Native.ISeriesPointArgument.get_ArgumentScaleType();
    private sealed virtual override object DevExpress.Charts.Native.ISeriesPointArgument.get_UserArgument();
    private sealed virtual override string DevExpress.Charts.Native.ISeriesPointArgument.get_QualitativeArgument();
    private sealed virtual override double DevExpress.Charts.Native.ISeriesPointArgument.get_NumericalArgument();
    private sealed virtual override DateTime DevExpress.Charts.Native.ISeriesPointArgument.get_DateTimeArgument();
    private sealed virtual override TimeSpan DevExpress.Charts.Native.ISeriesPointArgument.get_TimeSpanArgument();
    private void ClearArguments();
    private void SetArgument(object argument);
    private void SetNumericalArgument(double value);
    private void SetDateTimeArgument(DateTime value);
    private void SetTimeSpanArgument(TimeSpan value);
    private void SetQualitativeArgument(string argument);
}
public class DevExpress.Charts.Native.SeriesPointArgumentXContainer : SeriesPointArgumentContainerBase {
    protected Scale SeriesArgumentScaleType { get; }
    public SeriesPointArgumentXContainer(ISeriesPoint seriesPoint);
    public SeriesPointArgumentXContainer(ISeriesPoint seriesPoint, double argument);
    public SeriesPointArgumentXContainer(ISeriesPoint seriesPoint, DateTime argument);
    public SeriesPointArgumentXContainer(ISeriesPoint seriesPoint, string argument);
    public SeriesPointArgumentXContainer(ISeriesPoint seriesPoint, object argument);
    protected virtual Scale get_SeriesArgumentScaleType();
}
public class DevExpress.Charts.Native.SeriesPointArgumentYContainer : SeriesPointArgumentContainerBase {
    protected Scale SeriesArgumentScaleType { get; }
    public SeriesPointArgumentYContainer(ISeriesPoint seriesPoint);
    public SeriesPointArgumentYContainer(ISeriesPoint seriesPoint, double argument);
    public SeriesPointArgumentYContainer(ISeriesPoint seriesPoint, DateTime argument);
    public SeriesPointArgumentYContainer(ISeriesPoint seriesPoint, string argument);
    public SeriesPointArgumentYContainer(ISeriesPoint seriesPoint, object argument);
    protected virtual Scale get_SeriesArgumentScaleType();
}
public class DevExpress.Charts.Native.SeriesPointCollectionBatchUpdateInfo : CollectionUpdateInfo`1<ICollection`1<IDataPoint>> {
    private ISeries series;
    public ISeries Series { get; }
    public SeriesPointCollectionBatchUpdateInfo(object sender, ChartCollectionOperation operation, ISeries series, ICollection`1<IDataPoint> oldItem, int oldIndex, ICollection`1<IDataPoint> newItem, int newIndex);
    public ISeries get_Series();
}
internal class DevExpress.Charts.Native.SeriesPointCollectionBatchUpdateProcessor : CollectionUpdateProcessor`1<SeriesPointCollectionBatchUpdateInfo> {
    private bool hasInsertUpdates;
    private bool hasRemoveUpdates;
    protected CommonActionType AdditionalUpdates { get; }
    private bool DevExpress.Charts.Native.ICollectionUpdateProcessor.HasInsertUpdates { get; }
    private bool DevExpress.Charts.Native.ICollectionUpdateProcessor.HasRemoveUpdates { get; }
    protected virtual CommonActionType get_AdditionalUpdates();
    private sealed virtual override bool DevExpress.Charts.Native.ICollectionUpdateProcessor.get_HasInsertUpdates();
    private sealed virtual override bool DevExpress.Charts.Native.ICollectionUpdateProcessor.get_HasRemoveUpdates();
    internal IList`1<SeriesPointsCollectionAction> GenerateAction(SeriesPointCollectionBatchUpdateInfo updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(SeriesPointCollectionBatchUpdateInfo updateInfo);
}
internal class DevExpress.Charts.Native.SeriesPointCollectionReplacePointAction : SeriesPointsCollectionActionBase {
    private int index;
    private IDataPoint seriesPoint;
    public int Index { get; }
    public IDataPoint SeriesPoint { get; }
    public SeriesPointCollectionReplacePointAction(ISeries series, int index, IDataPoint seriesPoint);
    public int get_Index();
    public IDataPoint get_SeriesPoint();
}
public class DevExpress.Charts.Native.SeriesPointCollectionUpdateInfo : CollectionUpdateInfo`1<IDataPoint> {
    private ISeries series;
    public ISeries Series { get; }
    public SeriesPointCollectionUpdateInfo(object sender, ChartCollectionOperation operation, ISeries series, IDataPoint oldItem, int oldIndex, IDataPoint newItem, int newIndex);
    public ISeries get_Series();
}
internal class DevExpress.Charts.Native.SeriesPointCollectionUpdateProcessor : CollectionUpdateProcessor`1<SeriesPointCollectionUpdateInfo> {
    private bool hasInsertUpdates;
    private bool hasRemoveUpdates;
    protected CommonActionType AdditionalUpdates { get; }
    private bool DevExpress.Charts.Native.ICollectionUpdateProcessor.HasInsertUpdates { get; }
    private bool DevExpress.Charts.Native.ICollectionUpdateProcessor.HasRemoveUpdates { get; }
    protected virtual CommonActionType get_AdditionalUpdates();
    private sealed virtual override bool DevExpress.Charts.Native.ICollectionUpdateProcessor.get_HasInsertUpdates();
    private sealed virtual override bool DevExpress.Charts.Native.ICollectionUpdateProcessor.get_HasRemoveUpdates();
    internal IList`1<SeriesPointsCollectionAction> GenerateAction(SeriesPointCollectionUpdateInfo updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(SeriesPointCollectionUpdateInfo updateInfo);
}
public abstract class DevExpress.Charts.Native.SeriesPointDataContainer : object {
    private static List`1<Double[]> EmptyValues;
    private static List`1<DateTime[]> EmptyDateTimeValues;
    private static List`1<TimeSpan[]> EmptyTimeSpanValues;
    public static string DefaultQualitative;
    public static DateTime DefaultDateTime;
    public static TimeSpan DefaultTimeSpan;
    public static int MustHaveValuesCount;
    public static int DefaultDimension;
    public static int MaxDimension;
    public static double DefaultNumerical;
    public static Scale DefaultArgumentScaleType;
    public static Scale DefaultValueScaleType;
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    public int Dimension { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public Double[] Values { get; public set; }
    public DateTime[] DateTimeValues { get; public set; }
    public TimeSpan[] TimeSpanValues { get; public set; }
    public string QualitativeArgument { get; public set; }
    public double NumericalArgument { get; public set; }
    public DateTime DateTimeArgument { get; public set; }
    public TimeSpan TimeSpanArgument { get; public set; }
    public bool ArgumentIsParsed { get; }
    public bool RecreateIfScaleTypeSet { get; }
    private static SeriesPointDataContainer();
    private static bool IsEmptyValues(Double[] values);
    private static SeriesPointDataContainer InitializeArgument(SeriesPointDataContainer dataContainer, string argument, DateTime dateTimeArgument);
    private static SeriesPointDataContainer InitializeArgument(SeriesPointDataContainer dataContainer, string argument, double numericArgument);
    private static SeriesPointDataContainer InitializeArgument(SeriesPointDataContainer dataContainer, string argument, TimeSpan timeSpanArgument);
    private static T[] UpdateDimension(T[] values, T defaultValue, int dimension);
    private static bool TryParseDouble(string argument, bool useInvariant, Double& result);
    private static bool TryParseDateTime(string argument, bool useInvariant, DateTime& result);
    private static bool TryParseTimeSpan(string argument, bool useInvariant, TimeSpan& result);
    private static bool IsWrongContainerDimension(int containerDimension, int valuesCount);
    protected static Double[] UpdateDimension(Double[] values, int dimension);
    protected static DateTime[] UpdateDimension(DateTime[] values, int dimension);
    protected static TimeSpan[] UpdateDimension(TimeSpan[] values, int dimension);
    protected static T[] GetValues(int dimension, List`1<IDataMemberContainer> containers, int valuesOffset, T boxPlotMissingValue);
    public static SeriesPointDataContainer InitializeArgument(SeriesPointDataContainer dataContainer, object argument, Scale seriesScaleType, bool parse);
    public static SeriesPointDataContainer InitializeArgument(SeriesPointDataContainer dataContainer, string argument, Scale seriesScaleType);
    public static SeriesPointDataContainer InitializeArgument(SeriesPointDataContainer dataContainer, DateTime argument);
    public static SeriesPointDataContainer InitializeArgument(SeriesPointDataContainer dataContainer, double argument);
    public static SeriesPointDataContainer InitializeArgument(SeriesPointDataContainer dataContainer, TimeSpan argument);
    public static SeriesPointDataContainer InitializeValues(SeriesPointDataContainer dataContainer, Double[] values, bool shouldBeNonEmpty);
    public static SeriesPointDataContainer InitializeValues(SeriesPointDataContainer dataContainer, DateTime[] values);
    public static SeriesPointDataContainer InitializeValues(SeriesPointDataContainer dataContainer, TimeSpan[] values);
    public static SeriesPointDataContainer InitializeValues(SeriesPointDataContainer dataContainer, Scale valueScaleType);
    public static SeriesPointDataContainer Create(Scale argumentScaleType, Scale valueScaleType, int dimension);
    public static SeriesPointDataContainer CreateFromObject(object argument, bool parse, int dimension);
    public static SeriesPointDataContainer CreateFromObject(object argument, ISeriesPointValues values, bool parse);
    public static SeriesPointDataContainer CreateFromObject(object argument, Double[] values, bool parse);
    public static SeriesPointDataContainer CreateFromObject(object argument, DateTime[] values, bool parse);
    public static SeriesPointDataContainer CreateFromObject(object argument, TimeSpan[] values, bool parse);
    public static SeriesPointDataContainer CreateFromObject(object argument, Object[] values, bool parse, int dimension);
    public static SeriesPointDataContainer Create(string argument, int dimension, bool useInvariant);
    public static SeriesPointDataContainer Create(string argument, Double[] values, bool useInvariant);
    public static SeriesPointDataContainer Create(string argument, DateTime[] values, bool useInvariant);
    public static SeriesPointDataContainer Create(string argument, TimeSpan[] values, bool useInvariant);
    public static SeriesPointDataContainer Create(double argument, Double[] values);
    public static SeriesPointDataContainer Create(DateTime argument, Double[] values);
    public static SeriesPointDataContainer Create(TimeSpan argument, Double[] values);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool get_IsValidArgument();
    public abstract virtual int get_Dimension();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual Double[] get_Values();
    public virtual void set_Values(Double[] value);
    public virtual DateTime[] get_DateTimeValues();
    public virtual void set_DateTimeValues(DateTime[] value);
    public virtual TimeSpan[] get_TimeSpanValues();
    public virtual void set_TimeSpanValues(TimeSpan[] value);
    public virtual string get_QualitativeArgument();
    public virtual void set_QualitativeArgument(string value);
    public virtual double get_NumericalArgument();
    public virtual void set_NumericalArgument(double value);
    public virtual DateTime get_DateTimeArgument();
    public virtual void set_DateTimeArgument(DateTime value);
    public virtual TimeSpan get_TimeSpanArgument();
    public virtual void set_TimeSpanArgument(TimeSpan value);
    public virtual bool get_ArgumentIsParsed();
    public virtual bool get_RecreateIfScaleTypeSet();
    public abstract virtual SeriesPointDataContainer SetDimension(int dimension);
    public abstract virtual SeriesPointDataContainer Clone();
    public abstract virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
    public virtual SeriesPointDataContainer FallbackToMultivalue();
}
public enum DevExpress.Charts.Native.SeriesPointKeyNative : Enum {
    public int value__;
    public static SeriesPointKeyNative Argument;
    public static SeriesPointKeyNative Value_1;
    public static SeriesPointKeyNative Value_2;
    public static SeriesPointKeyNative Value_3;
    public static SeriesPointKeyNative Value_4;
    public static SeriesPointKeyNative Value_5;
    public static SeriesPointKeyNative Value_6;
}
internal class DevExpress.Charts.Native.SeriesPointPropertiesUpdateProcessor : TypedUpdateProcessor`1<PropertyUpdateInfo`2<ISeries, IDataPoint>> {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo`2<ISeries, IDataPoint> updateInfo);
}
internal class DevExpress.Charts.Native.SeriesPointsCollectionAction : SeriesPointsCollectionActionBase {
    private int newIndex;
    private int oldIndex;
    private ICollection`1<IDataPoint> newItem;
    private ICollection`1<IDataPoint> oldItem;
    private CollectionActionType updateType;
    public int NewIndex { get; }
    public int OldIndex { get; }
    public ICollection`1<IDataPoint> NewItem { get; }
    public ICollection`1<IDataPoint> OldItem { get; }
    public CollectionActionType UpdateType { get; }
    public SeriesPointsCollectionAction(ISeries series, CollectionActionType updateType);
    public SeriesPointsCollectionAction(ISeries series, int newIndex, int oldIndex, CollectionActionType updateType);
    public SeriesPointsCollectionAction(ISeries series, int newIndex, int oldIndex, ICollection`1<IDataPoint> newItem, ICollection`1<IDataPoint> oldItem, CollectionActionType updateType);
    public static SeriesPointsCollectionAction CreateInsertInfo(ISeries series, ICollection`1<IDataPoint> item, int index);
    public static SeriesPointsCollectionAction CreateRemoveInfo(ISeries series, ICollection`1<IDataPoint> item, int index);
    public static SeriesPointsCollectionAction CreateCleanInfo(ISeries series);
    public int get_NewIndex();
    public int get_OldIndex();
    public ICollection`1<IDataPoint> get_NewItem();
    public ICollection`1<IDataPoint> get_OldItem();
    public CollectionActionType get_UpdateType();
}
internal class DevExpress.Charts.Native.SeriesPointsCollectionActionBase : object {
    private ISeries series;
    public ISeries Series { get; }
    private ISeriesBase DevExpress.Charts.Native.ISeriesUpdateAction.Series { get; }
    public SeriesPointsCollectionActionBase(ISeries series);
    public ISeries get_Series();
    private sealed virtual override ISeriesBase DevExpress.Charts.Native.ISeriesUpdateAction.get_Series();
}
public class DevExpress.Charts.Native.SeriesPointSettingsComparer : RefinedPointComparerBase {
    private bool isAscending;
    private SeriesPointKeyNative sortingPointKey;
    private ISeriesBase series;
    public SeriesPointSettingsComparer(bool isAscending, SeriesPointKeyNative sortingKey, ISeries series);
    private Scale GetScale();
    public virtual int Compare(RefinedPoint pointInArray, RefinedPoint newPoint);
    private double GetValue(RefinedPoint refinedPoint);
    private string GetQualitativeValue(RefinedPoint refinedPoint);
    private DateTime GetDateTimeValue(RefinedPoint refinedPoint);
    private TimeSpan GetTimeSpanValue(RefinedPoint refinedPoint);
}
public abstract class DevExpress.Charts.Native.SeriesPointValuesContainer : object {
    private Double[] numericValues;
    protected Scale ScaleType { get; }
    public Double[] NumericalValues { get; }
    public DateTime[] DateTimeValues { get; }
    public TimeSpan[] TimeSpanValues { get; }
    private Scale DevExpress.Charts.Native.ISeriesPointValues.ValueScaleType { get; }
    private int DevExpress.Charts.Native.ISeriesPointValues.Dimension { get; }
    protected SeriesPointValuesContainer(Double[] values);
    protected abstract virtual Scale get_ScaleType();
    public sealed virtual Double[] get_NumericalValues();
    public virtual DateTime[] get_DateTimeValues();
    public virtual TimeSpan[] get_TimeSpanValues();
    private sealed virtual override Scale DevExpress.Charts.Native.ISeriesPointValues.get_ValueScaleType();
    private sealed virtual override int DevExpress.Charts.Native.ISeriesPointValues.get_Dimension();
}
public abstract class DevExpress.Charts.Native.SeriesPointValuesContainer`1 : SeriesPointValuesContainer {
    [CompilerGeneratedAttribute]
private T[] <TypedValues>k__BackingField;
    protected T[] TypedValues { get; private set; }
    protected SeriesPointValuesContainer`1(T[] typedValues, Double[] numericValues);
    [CompilerGeneratedAttribute]
protected T[] get_TypedValues();
    [CompilerGeneratedAttribute]
private void set_TypedValues(T[] value);
}
internal class DevExpress.Charts.Native.SeriesPropertiesUpdateProcessor : TypedUpdateProcessor`2<PropertyUpdateInfo, ISeriesBase> {
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo updateInfo, ISeriesBase sender);
}
internal class DevExpress.Charts.Native.SideBySideBarPropertiesUpdateProcessor : TypedUpdateProcessor`1<PropertyUpdateInfo> {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.SideBySideGroup : SideBySideGroupBase {
    private Dictionary`2<RefinedPoint, RefinedSeries> points;
    public bool IsEmpty { get; }
    public SideBySideGroup(RefinedSeries series);
    public virtual bool get_IsEmpty();
    public void AddPoint(RefinedSeries series, RefinedPoint point);
    public void RemovePoint(RefinedPoint point);
    public virtual void UpdateInteractionKeys(int index, SideBySideInteractionBase interaction);
    public virtual void RemoveSeries(RefinedSeries series);
}
public abstract class DevExpress.Charts.Native.SideBySideGroupBase : object {
    private object groupKey;
    private List`1<RefinedSeries> seriesList;
    [CompilerGeneratedAttribute]
private double <BarWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BarDistance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FixedOffset>k__BackingField;
    public object GroupKey { get; }
    public double BarWidth { get; public set; }
    public double BarDistance { get; public set; }
    public int FixedOffset { get; public set; }
    public bool IsEmpty { get; }
    public List`1<RefinedSeries> SeriesList { get; }
    protected SideBySideGroupBase(RefinedSeries series);
    public object get_GroupKey();
    [CompilerGeneratedAttribute]
public double get_BarWidth();
    [CompilerGeneratedAttribute]
public void set_BarWidth(double value);
    [CompilerGeneratedAttribute]
public double get_BarDistance();
    [CompilerGeneratedAttribute]
public void set_BarDistance(double value);
    [CompilerGeneratedAttribute]
public int get_FixedOffset();
    [CompilerGeneratedAttribute]
public void set_FixedOffset(int value);
    public virtual bool get_IsEmpty();
    public List`1<RefinedSeries> get_SeriesList();
    public void AddSeries(RefinedSeries series);
    public virtual void RemoveSeries(RefinedSeries series);
    public abstract virtual void UpdateInteractionKeys(int index, SideBySideInteractionBase interaction);
}
public abstract class DevExpress.Charts.Native.SideBySideInteractionBase : object {
    private List`1<SideBySideGroupBase> groups;
    private List`1<RefinedSeries> series;
    private bool shouldRecalculate;
    private bool equalBarWidth;
    protected List`1<SideBySideGroupBase> Groups { get; }
    protected double Argument { get; }
    public bool IsEmpty { get; }
    public List`1<RefinedSeries> Series { get; }
    private int DevExpress.Charts.Native.IPointInteraction.Count { get; }
    private double DevExpress.Charts.Native.IPointInteraction.ArgumentX { get; }
    private double DevExpress.Charts.Native.IPointInteraction.ArgumentY { get; }
    private bool DevExpress.Charts.Native.IPointInteraction.IsEmpty { get; }
    protected SideBySideInteractionBase(bool equalBarWidth);
    protected List`1<SideBySideGroupBase> get_Groups();
    protected virtual double get_Argument();
    public bool get_IsEmpty();
    public List`1<RefinedSeries> get_Series();
    private sealed virtual override int DevExpress.Charts.Native.IPointInteraction.get_Count();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.get_ArgumentX();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.get_ArgumentY();
    private sealed virtual override bool DevExpress.Charts.Native.IPointInteraction.get_IsEmpty();
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMinValue(ISeriesView seriesView);
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMaxValue(ISeriesView seriesView);
    private sealed virtual override double DevExpress.Charts.Native.IPointInteraction.GetMinAbsValue(ISeriesView seriesView);
    private SideBySideGroupBase FindSideBySideStackedGroup(RefinedSeries series);
    private void Recalculate();
    private void UpdateInteractionKeys();
    protected int GetGroupIndex(RefinedSeries series);
    protected abstract virtual SideBySideGroupBase CreateGroup(RefinedSeries series);
    protected virtual void OnInsertPoint(int groupIndex, RefinedSeries series, RefinedPoint point);
    public void Invalidate();
    public void AddSeries(RefinedSeries series);
    public void InsertPoint(RefinedSeries series, RefinedPoint point);
    public virtual void RemoveSeries(RefinedSeries series);
    public virtual void RemovePoint(RefinedSeries series, RefinedPoint point);
    public double GetBarWidth(int index);
    public double GetBarDistance(int index);
    public int GetFixedOffset(int index);
}
public class DevExpress.Charts.Native.SideBySideInteractionContainer : SeriesInteractionContainer {
    private PointInteractionCollection sortedInteractionsByArgument;
    private bool EqualBarWidth { get; }
    private ISideBySideBarSeriesView SideBySideBarSeriesView { get; }
    public double Max { get; }
    public double Min { get; }
    public IList`1<IPointInteraction> PointInteractions { get; }
    public SideBySideInteractionContainer(ISeriesView view);
    private bool get_EqualBarWidth();
    private ISideBySideBarSeriesView get_SideBySideBarSeriesView();
    public virtual double get_Max();
    public virtual double get_Min();
    public virtual IList`1<IPointInteraction> get_PointInteractions();
    private void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint refinedPoint, bool changeInteractionLayout);
    private void InsertRefinedPoints(RefinedSeries refinedSeries, bool changeInteractionLayout);
    protected virtual void InsertRefinedPoints(int seriesIndex, RefinedSeries refinedSeries);
    protected virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries refinedSeries, bool removeAll);
    protected virtual void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint refinedPoint);
    protected virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    public virtual void Recalculate();
    public virtual double GetAbsMinValue();
}
public class DevExpress.Charts.Native.SideBySidePointInteraction : SideBySideInteractionBase {
    private double argument;
    protected double Argument { get; }
    public SideBySidePointInteraction(double argument, bool equalBarWidth);
    protected virtual double get_Argument();
    protected virtual SideBySideGroupBase CreateGroup(RefinedSeries series);
    protected virtual void OnInsertPoint(int groupIndex, RefinedSeries series, RefinedPoint point);
    public virtual void RemovePoint(RefinedSeries series, RefinedPoint point);
}
public class DevExpress.Charts.Native.SideBySideSeriesGroup : SideBySideGroupBase {
    public SideBySideSeriesGroup(RefinedSeries series);
    public virtual void UpdateInteractionKeys(int index, SideBySideInteractionBase interaction);
}
public class DevExpress.Charts.Native.SideBySideSeriesInteraction : SideBySideInteractionBase {
    protected virtual SideBySideGroupBase CreateGroup(RefinedSeries series);
}
public class DevExpress.Charts.Native.SideMarginCalculator : SideMarginCalculatorBase {
    private bool autoCorrectMin;
    private bool autoCorrectMax;
    private IAutoScaleBreaksContainer autoScaleBreaksContainer;
    protected bool AutoCorrectMin { get; }
    protected bool AutoCorrectMax { get; }
    public SideMarginCalculator(IAxisData axis, IAutoScaleBreaksContainer autoScaleBreaksContainer, bool autoCorrectMin, bool autoCorrectMax);
    protected virtual bool get_AutoCorrectMin();
    protected virtual bool get_AutoCorrectMax();
    private double GetBarWidthCorrection(IRefinedSeries series);
    private double GetSideMargin(IMinMaxValues range, IEnumerable`1<IRefinedSeries> refinedSeries);
    private double GetSideMarginByView(IMinMaxValues viewRange, IEnumerable`1<IRefinedSeries> refinedSeries);
    private double GetSideMarginByRange(IMinMaxValues values);
    private double GetSideMarginByRangeList(IMinMaxValues range, IList`1<IMinMaxValues> rangeLimitsList);
    private IMinMaxValues GetViewRange(IMinMaxValues range, IList`1<IMinMaxValues> rangeLimitsList);
    protected virtual bool ValidateInternalValues(IMinMaxValues internalValues);
    protected virtual double CalculateSideMarginCore(IMinMaxValues range, IEnumerable`1<IRefinedSeries> refinedSeries);
    private IList`1<IMinMaxValues> CalculateIntervals(IMinMaxValues range);
    protected virtual double CalcOverflowedSideMargin(IMinMaxValues internalValues, double sideMargin);
    protected virtual bool IsOverflow(IMinMaxValues internalValues, double sideMargin);
}
public abstract class DevExpress.Charts.Native.SideMarginCalculatorBase : object {
    internal static double DefaultSideMarginValue;
    protected static int ArgumentSideFactor;
    protected static int ValueSideFactor;
    private IAxisData axis;
    protected IAxisData Axis { get; }
    protected ActualScaleTypeCore ScaleType { get; }
    protected bool ShowZeroLevel { get; }
    protected bool AutoCorrectMin { get; }
    protected bool AutoCorrectMax { get; }
    protected SideMarginCalculatorBase(IAxisData axis);
    protected IAxisData get_Axis();
    protected ActualScaleTypeCore get_ScaleType();
    protected bool get_ShowZeroLevel();
    protected abstract virtual bool get_AutoCorrectMin();
    protected abstract virtual bool get_AutoCorrectMax();
    private double GetZeroLevel(IMinMaxValues internalValues);
    protected double GetAxisSideMargin(IMinMaxValues range, int scaleFactor, bool isNotZero);
    protected double CalcSideMarginForBubble(IMinMaxValues range, IRefinedSeries series);
    protected virtual IMinMaxValues CorrectInternalValues(IMinMaxValues internalValues);
    protected abstract virtual bool ValidateInternalValues(IMinMaxValues correctedValues);
    protected abstract virtual double CalculateSideMarginCore(IMinMaxValues correctedValues, IEnumerable`1<IRefinedSeries> refinedSeries);
    protected abstract virtual bool IsOverflow(IMinMaxValues correctedValues, double sideMargin);
    protected abstract virtual double CalcOverflowedSideMargin(IMinMaxValues correctedValues, double sideMargin);
    public double CalcSideMargin(IMinMaxValues internalValues, IEnumerable`1<IRefinedSeries> refinedSeries);
}
public class DevExpress.Charts.Native.SideMarginLogarithmicCalculator : SideMarginCalculatorBase {
    protected ITransformation Transformation { get; }
    protected bool AutoCorrectMin { get; }
    protected bool AutoCorrectMax { get; }
    public SideMarginLogarithmicCalculator(IAxisData axis);
    protected ITransformation get_Transformation();
    protected virtual bool get_AutoCorrectMin();
    protected virtual bool get_AutoCorrectMax();
    private IMinMaxValues TransformRange(IMinMaxValues range);
    private double GetSideMarginByViews(IMinMaxValues range, IEnumerable`1<IRefinedSeries> refinedSeries);
    protected virtual IMinMaxValues CorrectInternalValues(IMinMaxValues internalValues);
    protected virtual bool ValidateInternalValues(IMinMaxValues internalValues);
    protected virtual double CalculateSideMarginCore(IMinMaxValues internalValues, IEnumerable`1<IRefinedSeries> refinedSeries);
    protected virtual bool IsOverflow(IMinMaxValues internalValues, double sideMargin);
    protected virtual double CalcOverflowedSideMargin(IMinMaxValues internalValues, double sideMargin);
}
public enum DevExpress.Charts.Native.SideMarginMode : Enum {
    public int value__;
    public static SideMarginMode Auto;
    public static SideMarginMode Disable;
    public static SideMarginMode Enable;
    public static SideMarginMode UserDisable;
    public static SideMarginMode UserEnable;
}
public enum DevExpress.Charts.Native.SideMarginSizeUnitNative : Enum {
    public int value__;
    public static SideMarginSizeUnitNative AxisUnit;
    public static SideMarginSizeUnitNative AxisRangePercentage;
}
public class DevExpress.Charts.Native.SimpleChartBindingProcedure : ChartBindingProcedure {
    private bool allowCachedUpdates;
    private SeriesPointDataContainer templateContainer;
    public SimpleChartBindingProcedure(string seriesDataMember, ISeriesFactory seriesTemplate, bool allowCachedUpdates);
    private void AddPoint(ISeries series, object dataRow, RowDataReader dataReader);
    private ISeries GetSeries(IList`1<ISeries> autocreatedSeries, object tag);
    protected virtual List`1<IDataMemberContainer> CreateDataMemberContainers();
    protected virtual void OnRowWasRead(ISeries series, object dataRow, RowDataReader dataReader);
    protected virtual void OnDataWereRead();
    public ISeries AddBoundPoint(IList`1<ISeries> autocreatedSeries, int index);
}
public static class DevExpress.Charts.Native.SimpleDiagramAutoLayoutHelper : object {
    public static int MaxDimension;
    public static int MinDimension;
    public static int CalculateDimension(int width, int height, int seriesCount);
    public static int CalculateDimension(int width, int height, int seriesCount, int maxDimension, int minDimension);
}
public class DevExpress.Charts.Native.SimpleDiagramLayout : object {
    private DXRectangle bounds;
    private TransformRectangle transformRectangle;
    private List`1<DXRectangle> domainBounds;
    private SimpleDiagramLayout(DXRectangle bounds, int dimension, int domainCount, TransformRectangle transformRectangle);
    private static DXRectangle PassRectangle(DXRectangle rect);
    private static DXRectangle RotateRectangle(DXRectangle rect);
    public static List`1<DXRectangle> Calculate(ISimpleDiagram diagram, DXRectangle bounds, int domainCount);
    private void FillRow(int count, int position, int height);
    private void Calculate(int dimension, int domainCount);
}
public enum DevExpress.Charts.Native.SimpleDiagramLayoutDirection : Enum {
    public int value__;
    public static SimpleDiagramLayoutDirection Horizontal;
    public static SimpleDiagramLayoutDirection Vertical;
}
public abstract class DevExpress.Charts.Native.SimpleDiagramResolveOverlapping : object {
    public static void ArrangeByEllipse(IList`1<IPieLabelLayout> labels, GRealEllipse ellipse, int resolveOverlappingMinIndent, PointsSweepDirection direction, GRealRect2D diagramBounds);
    public static void ArrangeByColumn(IList`1<IPieLabelLayout> labels, GRealRect2D bounds, int resolveOverlappingMinIndent);
}
public class DevExpress.Charts.Native.SimpleGridPointsCalculator : GridPointsCalculatorBase {
    public SimpleGridPointsCalculator(GridClusterPointsFactory factory);
    protected virtual IList`1<RefinedPoint> CreateClusterPoints();
    protected internal virtual bool CanProcessPoints(int pointsCount, int gridNodesCount);
}
public class DevExpress.Charts.Native.SimpleMovingAverageCalculator : MovingAverageCalculator {
    [CompilerGeneratedAttribute]
private bool <IgnoreEmptyValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StartFromFirstPoint>k__BackingField;
    internal bool IgnoreEmptyValues { get; internal set; }
    internal bool StartFromFirstPoint { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_IgnoreEmptyValues();
    [CompilerGeneratedAttribute]
internal void set_IgnoreEmptyValues(bool value);
    [CompilerGeneratedAttribute]
internal bool get_StartFromFirstPoint();
    [CompilerGeneratedAttribute]
internal void set_StartFromFirstPoint(bool value);
    public virtual void UpdateMovingAverageData(IList`1<RefinedPoint> refinedPoints, int startUpdateIndex, int pointsCount, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.SimplePointInteraction : BasePointInteraction {
    private RefinedPointsValueComparer comparer;
    private List`1<RefinedPoint> points;
    private double positiveValuesSum;
    private double negativeValuesSum;
    public double MinValue { get; }
    public double MaxValue { get; }
    public double PositiveValuesSum { get; }
    public double NegativeValuesSum { get; }
    public int Count { get; }
    public double get_MinValue();
    public double get_MaxValue();
    public double get_PositiveValuesSum();
    public double get_NegativeValuesSum();
    public virtual int get_Count();
    public void AddPoint(RefinedPoint point);
    public void RemovePoint(RefinedPoint point);
    public void Clear();
    public virtual double GetMinValue(ISeriesView seriesView);
    public virtual double GetMaxValue(ISeriesView seriesView);
    public virtual double GetMinAbsValue(ISeriesView seriesView);
}
public class DevExpress.Charts.Native.SimplePointPatternDataProvider : PatternDataProvider {
    private string patternConstant;
    private ISeriesPointEnsurer seriesPointEnsurer;
    protected RefinedPoint RefinedPoint { get; }
    public SimplePointPatternDataProvider(string patternConstant, ISeriesPointEnsurer seriesPointEnsurer);
    protected RefinedPoint get_RefinedPoint();
    private ISeriesPoint GetSeriesPoint();
    private object GetArgument();
    private object GetValue();
    private object GetValueFormRefinedPoint();
    protected virtual object GetPercentValue();
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public class DevExpress.Charts.Native.SimpleSeriesBindingProcedure : SeriesBindingProcedure {
    private SeriesPointDataContainer templateContainer;
    public SimpleSeriesBindingProcedure(SeriesDataAdapterSnapshot dataAdapter);
    private IDataPoint GetPoint(object dataRow, RowDataReader dataReader);
    protected virtual void OnDataRowRead(object dataRow, RowDataReader dataReader, int position);
    protected virtual void OnDataReadFinished();
    protected virtual List`1<IDataMemberContainer> CreateDataMemberContainers();
    public IDataPoint CreateBindingPoint(int index);
}
public class DevExpress.Charts.Native.SimpleSeriesContainer : SingleSeriesContainer {
    private SimplePointInteraction interaction;
    internal SimplePointInteraction Interaction { get; }
    public IList`1<IPointInteraction> PointInteractions { get; }
    public SimpleSeriesContainer(ISeriesView view);
    internal SimplePointInteraction get_Interaction();
    public virtual IList`1<IPointInteraction> get_PointInteractions();
    protected virtual void InsertRefinedPoints(int seriesIndex, RefinedSeries refinedSeries);
    protected virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries refinedSeries, bool removeAll);
    protected virtual void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
}
public abstract class DevExpress.Charts.Native.SimpleStandardDeviationCalculator : object {
    protected abstract virtual double GetValue(RefinedPoint point);
    public bool Calculate(IList`1<RefinedSeries> seriesList, Double& standardDeviation, Double& average, Int32& pointsCount);
}
public class DevExpress.Charts.Native.SingleIntervalMappingCore : AxisMappingCore {
    private IntervalLayout intervalLayout;
    public SingleIntervalMappingCore(IAxisData axis, double length);
    protected virtual IntervalLayout GetIntervalLayout(double value, bool exactLayout);
    protected virtual IntervalLayout GetIntervalLayoutByCoordinate(double coordinate);
}
public abstract class DevExpress.Charts.Native.SingleSeriesContainer : SeriesContainer {
    protected SingleSeriesContainer(ISeriesView view);
    protected virtual void ResetRefinedSeries(RefinedSeries refinedSeries);
    public void SetRefinedSeries(RefinedSeries refinedSeries);
    public virtual void Recalculate();
}
internal class DevExpress.Charts.Native.SlaveSeriesExecutor : object {
    private SeriesController seriesController;
    public SlaveSeriesExecutor(SeriesController seriesController);
    public sealed virtual SeriesControllerChanges Execute(IExecutorContext context);
}
public class DevExpress.Charts.Native.SortedArgumentRefinedPointCollection : SortedRefinedPointCollectionBase {
    public int MinPointIndex { get; }
    public int MaxPointIndex { get; }
    private int System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Count { get; }
    private bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.IsReadOnly { get; }
    private IPointInteraction System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.Item { get; private set; }
    public SortedArgumentRefinedPointCollection(int capacity, RefinedPointsArgumentComparer comparer);
    public int get_MinPointIndex();
    public int get_MaxPointIndex();
    private sealed virtual override int System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.get_IsReadOnly();
    private sealed virtual override IPointInteraction System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.set_Item(int index, IPointInteraction value);
    private sealed virtual override int System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.IndexOf(IPointInteraction item);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.Insert(int index, IPointInteraction item);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Charts.Native.IPointInteraction>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Add(IPointInteraction item);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Contains(IPointInteraction item);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.CopyTo(IPointInteraction[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<DevExpress.Charts.Native.IPointInteraction>.Remove(IPointInteraction item);
    private sealed virtual override IEnumerator`1<IPointInteraction> System.Collections.Generic.IEnumerable<DevExpress.Charts.Native.IPointInteraction>.GetEnumerator();
    public int GetIndexByArgument(double argument, bool fromRight, Boolean& pointIsFound);
    public void InsertRangeWithoutTesting(IList`1<RefinedPoint> newPoints);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.SortedCollection`1 : object {
    private Comparer`1<T> comparer;
    private List`1<T> innerList;
    protected List`1<T> InnerList { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public SortedCollection`1(Comparer`1<T> comparer);
    protected List`1<T> get_InnerList();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int get_Count();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int BinarySearch(T item);
    public int IndexOf(T item);
    public void RemoveAt(int index);
    public void Add(T item);
    public void Insert(int index, T interaction);
    public void Clear();
    public void Sort();
    public bool Contains(T item);
    public bool Remove(T item);
}
public class DevExpress.Charts.Native.SortedRefinedPointCollection : SortedRefinedPointCollectionBase {
    public SortedRefinedPointCollection(int capacity, SeriesPointSettingsComparer comparer);
    public void SetComparer(RefinedPointComparerBase comparer);
}
public abstract class DevExpress.Charts.Native.SortedRefinedPointCollectionBase : RefinedPointCollectionBase {
    [CompilerGeneratedAttribute]
private RefinedPointComparerBase <Comparer>k__BackingField;
    protected RefinedPointComparerBase Comparer { get; protected set; }
    protected SortedRefinedPointCollectionBase(int capacity, RefinedPointComparerBase comparer);
    [CompilerGeneratedAttribute]
protected RefinedPointComparerBase get_Comparer();
    [CompilerGeneratedAttribute]
protected void set_Comparer(RefinedPointComparerBase value);
    public int BinarySearch(RefinedPoint item);
    public int BinarySearch(RefinedPoint item, Comparer`1<RefinedPoint> comparer);
    public void Sort();
    public void Initialize(RefinedPointCollectionBase pointsCollection, bool shouldSort);
    public void Update(RefinedPoint oldItem, RefinedPoint newItem);
    public virtual int IndexOf(RefinedPoint item);
    public virtual bool Contains(RefinedPoint item);
    public virtual void Add(RefinedPoint item);
    public virtual void AddRange(IList`1<RefinedPoint> collection, bool shouldSort);
}
public static class DevExpress.Charts.Native.SortingUtils : object {
    public static int CompareDoubles(double number1, double number2);
}
public enum DevExpress.Charts.Native.SortMode : Enum {
    public int value__;
    public static SortMode None;
    public static SortMode Ascending;
    public static SortMode Descending;
}
public enum DevExpress.Charts.Native.SplineAlgorithmCore : Enum {
    public int value__;
    public static SplineAlgorithmCore StrictMinMax;
    public static SplineAlgorithmCore Cardinal;
}
public class DevExpress.Charts.Native.SplineAreaGeometryStripCreator : SplineGeometryStripCreator {
    protected bool NeedCompleteFillingBottomStrip { get; }
    public SplineAreaGeometryStripCreator(SplineAlgorithmCore splineAlgorithm, double lineTension, ITransformation transformationX, ITransformation transformationY, IBezierStripSplitter stripSplitter, bool hasStripMaxCapacityLimit);
    protected virtual bool get_NeedCompleteFillingBottomStrip();
    protected virtual void FillBottomStripDrawingPoints(Dictionary`2<int, GRealPoint2D> currentPointByIndex, BezierStrip currentBottomStrip, Boolean& needSplit, List`1<GRealPoint2D> drawingPoints, BezierStrip bottomStrip);
    protected internal virtual IGeometryStrip CreateStrip();
    internal virtual void CompleteFillingStrip(IList`1<RefinedPoint> points, List`1<IGeometryStrip> strips, IGeometryStrip currentStrip);
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
}
public class DevExpress.Charts.Native.SplineGeometryStripCreator : LineGeometryStripCreator {
    private static int FilterPointsAddition;
    public static int GDIErrorLimit;
    private SplineAlgorithmCore splineAlgorithm;
    private double lineTension;
    private ITransformation transformationX;
    private ITransformation transformationY;
    private bool hasStripMaxCapacityLimit;
    private IBezierStripSplitter stripSplitter;
    protected IBezierStripSplitter StripSplitter { get; }
    protected SplineAlgorithmCore SplineAlgorithm { get; }
    protected double LineTension { get; }
    protected ITransformation TransformationX { get; }
    protected ITransformation TransformationY { get; }
    protected internal int StripMaxCapacity { get; }
    protected internal bool HasStripMaxCapacityLimit { get; }
    public SplineGeometryStripCreator(SplineAlgorithmCore splineAlgorithm, double lineTension, ITransformation transformationX, ITransformation transformationY, IBezierStripSplitter stripSplitter, bool shouldAddEmptyStrip, bool hasStripMaxCapacityLimit);
    protected IBezierStripSplitter get_StripSplitter();
    protected SplineAlgorithmCore get_SplineAlgorithm();
    protected double get_LineTension();
    protected ITransformation get_TransformationX();
    protected ITransformation get_TransformationY();
    protected internal virtual int get_StripMaxCapacity();
    protected internal virtual bool get_HasStripMaxCapacityLimit();
    protected internal virtual int GetMaxVisiblePointIndex(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
    protected internal virtual int GetMinVisiblePointIndex(IRefinedSeries refinedSeries);
    protected internal virtual IGeometryStrip CreateStrip();
    internal virtual void CompleteFillingStrip(IList`1<RefinedPoint> points, List`1<IGeometryStrip> strips, IGeometryStrip currentStrip);
    internal virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.SplineStackedAreaGeometryStripCreator : SplineAreaGeometryStripCreator {
    private List`1<IList`1<IGeometryStrip>> stripsCache;
    private StackedInteractionContainer interactionContainer;
    protected bool NeedCompleteFillingBottomStrip { get; }
    public SplineStackedAreaGeometryStripCreator(SplineAlgorithmCore splineAlgorithm, double lineTension, ITransformation transformationX, ITransformation transformationY, IBezierStripSplitter stripSplitter, bool hasStripMaxCapacityLimit);
    private static bool IsSameVertical(GRealPoint2D point1, GRealPoint2D point2);
    private static bool ShouldSplitByVertical(LineStrip lineStrip, GRealPoint2D newPoint);
    protected virtual bool get_NeedCompleteFillingBottomStrip();
    protected virtual void FillBottomStripDrawingPoints(Dictionary`2<int, GRealPoint2D> currentPointByIndex, BezierStrip currentBottomStrip, Boolean& needSplit, List`1<GRealPoint2D> drawingPoints, BezierStrip bottomStrip);
    internal void Calculate(StackedInteractionContainer interactionContainer);
    internal IList`1<IGeometryStrip> GetStrips(RefinedSeries series);
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
}
public class DevExpress.Charts.Native.SplineViewportIntersectionHolder : LineViewportIntersectionHolder {
    private SplineAlgorithmCore SplineAlgorithm { get; }
    private double LineTension { get; }
    public SplineViewportIntersectionHolder(IXYSeriesView view);
    private SplineAlgorithmCore get_SplineAlgorithm();
    private double get_LineTension();
    private Func`3<double, bool, double> CalcIntersectionBezier(BezierSplitCalculator calculator);
    private List`1<GRealPoint2D> GetPointsForBezier(IList`1<RefinedPoint> points, int firstIndex);
    private BezierSplitCalculator CreateCalculator(double x, List`1<GRealPoint2D> gPoints);
    protected virtual bool CollectViewportIntersectionCore(List`1<GRealPoint2D> pointsOfIntersection, IList`1<RefinedPoint> points, bool isLeftIntersection, int i, double y, double x);
}
public static class DevExpress.Charts.Native.SplitHelper : object {
    public static double CalcPointByRangeAnchorValue(double x1, double y1, double x2, double y2, double value);
}
public class DevExpress.Charts.Native.StackedAreaGeometrySplittedStripCreator : AreaGeometrySplittedStripCreator {
    public StackedAreaGeometrySplittedStripCreator(IStripSplitter stripSplitter);
    protected virtual double GetActualValue(RefinedPoint refinedPoint);
    protected virtual double GetPointMinValue(RefinedPoint refinedPoint);
}
public class DevExpress.Charts.Native.StackedAreaGeometryStripCreator : AreaGeometryStripCreator {
    protected virtual double GetActualValue(RefinedPoint refinedPoint);
    protected virtual double GetPointMinValue(RefinedPoint refinedPoint);
}
public class DevExpress.Charts.Native.StackedGeometry : object {
    private LineStrip borderStrip;
    public LineStrip BorderStrip { get; public set; }
    public LineStrip get_BorderStrip();
    public void set_BorderStrip(LineStrip value);
    public void UpdateBottomSegment(RangeStrip strip);
    public void ModifyBorderStrip(RangeStrip strip);
}
public class DevExpress.Charts.Native.StackedInteractionContainer : SeriesInteractionContainer {
    private PointInteractionCollection sortedInteractionsByArgument;
    private PointInteractionCollection sortedInteractionsByMinValue;
    private PointInteractionCollection sortedInteractionsByMaxValue;
    private PointInteractionCollection sortedInteractionsByMinAbsValue;
    private bool isContinuousView;
    private bool shouldResort;
    private bool shouldUpdateSupplyInteractions;
    protected bool ShouldUpdateOnChangePoint { get; }
    internal bool IsContinuousView { get; }
    internal PointInteractionCollection SortedInteractionsByArgument { get; }
    internal PointInteractionCollection SortedInteractionsByMinValue { get; }
    internal PointInteractionCollection SortedInteractionsByMaxValue { get; }
    public double Max { get; }
    public double Min { get; }
    public IList`1<IPointInteraction> PointInteractions { get; }
    public StackedInteractionContainer(ISeriesView view, bool isContinuousView);
    protected virtual bool get_ShouldUpdateOnChangePoint();
    internal bool get_IsContinuousView();
    internal PointInteractionCollection get_SortedInteractionsByArgument();
    internal PointInteractionCollection get_SortedInteractionsByMinValue();
    internal PointInteractionCollection get_SortedInteractionsByMaxValue();
    public virtual double get_Max();
    public virtual double get_Min();
    public virtual IList`1<IPointInteraction> get_PointInteractions();
    private void Resort();
    private void AddNewPointInteraction(int seriesIndex, RefinedPoint point);
    private void InsertRefinedPoint(int seriesIndex, RefinedPoint point);
    private void UpdateSupplyPointsAndInteractions();
    private void ClearSupplyPoints();
    private void AddSupplyInteractions();
    private void AddSupplyPoints();
    private int FindInteractionIndexByArgument(int startInteractionIndex, double exceptedArgument);
    private bool AddSupplyInteraction(int index, StackedPointInteraction interaction, StackedPointInteraction supplyValues);
    private bool IsEqualInteractions(StackedPointInteraction interaction1, StackedPointInteraction interaction2);
    protected virtual double CalculateSupplyValue(double currentArgument, double anotherArgumentPrev, double anotherValuePrev, double anotherArgumentNext, double anotherValueNext);
    protected virtual StackedPointInteraction CreatePointInteraction(int seriesIndex, RefinedPoint point);
    protected virtual void Invalidate();
    protected virtual void InsertRefinedPoints(int seriesIndex, RefinedSeries refinedSeries);
    protected virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries refinedSeries, bool removeAll);
    protected virtual void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    public virtual void Recalculate();
    public virtual double GetAbsMinValue();
    public IList`1<RefinedPoint> GetStackedPointsForDrawing(RefinedSeries refinedSeries);
    public bool ShouldCreateTotalLabel(int seriesIndex, RefinedPoint refinedPoint);
}
public class DevExpress.Charts.Native.StackedLineGeometrySplittedStripCreator : LineGeometrySplittedStripCreator {
    public StackedLineGeometrySplittedStripCreator(IStripSplitter stripSplitter, bool shouldAddEmptyStrip);
    protected virtual double GetActualValue(RefinedPoint refinedPoint);
}
public class DevExpress.Charts.Native.StackedLineGeometryStripCreator : LineGeometryStripCreator {
    public StackedLineGeometryStripCreator(bool shouldAddEmptyStrip);
    protected virtual double GetActualValue(RefinedPoint refinedPoint);
}
public class DevExpress.Charts.Native.StackedLineViewportIntersectionHolder : LineViewportIntersectionHolder {
    public StackedLineViewportIntersectionHolder(IXYSeriesView view);
    protected virtual double GetPointValue(RefinedPoint point);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.StackedPointInteraction : BasePointInteraction {
    private List`1<RefinedSeries> series;
    private List`1<Stack`1<RefinedPoint>> points;
    private List`1<double> startValues;
    private double argument;
    private double minValue;
    private double maxValue;
    private double positiveSum;
    private double negativeSum;
    private double minAbsValue;
    private bool shouldRecalculate;
    private bool isSupplyInteraction;
    private bool allSeriesNonPositive;
    protected ISeriesView SeriesView { get; }
    protected internal double PositiveSum { get; }
    protected internal double NegativeSum { get; }
    public double MinValue { get; }
    public double MaxValue { get; }
    public double MinAbsValue { get; }
    public bool HasEmptyPoints { get; }
    public bool IsSupplyInteraction { get; public set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public double Argument { get; }
    public RefinedPoint Item { get; public set; }
    internal List`1<RefinedPoint> Points { get; }
    public StackedPointInteraction(List`1<RefinedSeries> series, int seriesIndex, RefinedPoint point);
    protected ISeriesView get_SeriesView();
    protected internal double get_PositiveSum();
    protected internal double get_NegativeSum();
    public virtual double get_MinValue();
    public virtual double get_MaxValue();
    public virtual double get_MinAbsValue();
    public bool get_HasEmptyPoints();
    public bool get_IsSupplyInteraction();
    public void set_IsSupplyInteraction(bool value);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual double get_Argument();
    public RefinedPoint get_Item(int index);
    public void set_Item(int index, RefinedPoint value);
    internal List`1<RefinedPoint> get_Points();
    private bool CalculateAllSeriesNonPositive();
    private void Recalculate();
    private bool IsSeriesFirstWithPoint(int seriesIndex);
    protected double GetSeriesPointValue(RefinedPoint point);
    protected void Invalidate();
    protected virtual void InsertInPointsCollection(int index, RefinedPoint point);
    protected virtual double GetAnchorValue();
    protected virtual double GetPointValue(int pointIndex);
    public void InsertSeries(RefinedSeries series, int seriesIndex, RefinedPoint point);
    public void RemoveSeries(int seriesIndex);
    public void InsertPoint(int seriesIndex, RefinedPoint point);
    public void RemovePoint(int seriesIndex);
    public virtual double GetMinValue(ISeriesView seriesView);
    public virtual double GetMaxValue(ISeriesView seriesView);
    public virtual double GetMinAbsValue(ISeriesView seriesView);
    public virtual double GetStackedPointMinValue(int pointIndex);
    public virtual double GetStackedPointMaxValue(int pointIndex);
    public bool IsTopPoint(int seriesIndex);
}
public class DevExpress.Charts.Native.StackedSplineViewportIntersectionHolder : SplineViewportIntersectionHolder {
    public StackedSplineViewportIntersectionHolder(IXYSeriesView view);
    protected virtual double GetPointValue(RefinedPoint point);
}
public class DevExpress.Charts.Native.StackedStepAreaGeometrySplittedStripCreator : StepAreaGeometrySplittedStripCreator {
    public StackedStepAreaGeometrySplittedStripCreator(IStripSplitter stripSplitter, bool invertedStep);
    protected virtual double GetActualValue(RefinedPoint refinedPoint);
    protected virtual double GetPointMinValue(RefinedPoint refinedPoint);
}
public class DevExpress.Charts.Native.StackedStepAreaGeometryStripCreator : StepAreaGeometryStripCreator {
    public StackedStepAreaGeometryStripCreator(bool invertedStep);
    protected virtual double GetActualValue(RefinedPoint refinedPoint);
    protected virtual double GetPointMinValue(RefinedPoint refinedPoint);
    protected virtual void AddBottomStrip(RefinedPoint refinedPoint, RangeStrip rangeStrip);
}
public class DevExpress.Charts.Native.StackedStepInteractionContainer : StackedInteractionContainer {
    public StackedStepInteractionContainer(ISeriesView view);
    public StackedStepInteractionContainer(ISeriesView view, bool isContinuousView);
    protected virtual double CalculateSupplyValue(double currentArgument, double anotherArgumentPrev, double anotherValuePrev, double anotherArgumentNext, double anotherValueNext);
}
public class DevExpress.Charts.Native.StackedStepLineViewportIntersectionHolder : StepLineViewportIntersectionHolder {
    public StackedStepLineViewportIntersectionHolder(IXYSeriesView view);
    protected virtual double GetPointValue(RefinedPoint point);
}
public class DevExpress.Charts.Native.StandardDeviationCalculator : object {
    private static int DesignTimePointsCount;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointCount, ValueLevelInternal valueLevel);
    private double CalculateNextSma(double value, double preSma, int actualPointsCount, double firstInPeriodValue);
    private double CalculateStandardDeviation(IList`1<RefinedPoint> refinedPoints, int actualPointsCount, ValueLevelInternal valueLevel, double sma, int currentRefinedPointIndex);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointCount, ValueLevelInternal valueLevel);
}
public class DevExpress.Charts.Native.StandardDeviationErrorBarsCalculator : ErrorBarsCalculator {
    private double CalculateStandardDeviation(IList`1<RefinedPoint> refinedPoints, Double& arithmeticMean);
    public void Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, double multiplier);
}
public class DevExpress.Charts.Native.StandardErrorBarsCalculator : ErrorBarsCalculator {
    private double CalculateStandardError(IList`1<RefinedPoint> refinedPoints);
    public void Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
}
public abstract class DevExpress.Charts.Native.Step : object {
    private DXRectangle allocationRect;
    private RectanglesLayout layout;
    private double centerX;
    private double centerY;
    private List`1<TestPosition> primaryTestPositions;
    private List`1<TestPosition> testPositions;
    private bool isEnd;
    private int position;
    private double maxDistance;
    protected DXRectangle AllocationRect { get; }
    protected int Increment { get; }
    protected RectanglesLayout Layout { get; }
    public bool IsEnd { get; }
    public int Position { get; }
    public List`1<TestPosition> TestPositions { get; }
    protected Step(int position, DXRectangle rect, RectanglesLayout layout);
    protected DXRectangle get_AllocationRect();
    protected abstract virtual int get_Increment();
    protected RectanglesLayout get_Layout();
    public bool get_IsEnd();
    public int get_Position();
    public List`1<TestPosition> get_TestPositions();
    protected void AddPrimaryTestPosition(DXPoint position);
    protected void AddSecondaryTestPosition(DXPoint position);
    protected double CalcDistanceToAllocationRect(DXPoint position);
    protected bool IsUpdateEnd(double distance);
    protected abstract virtual void UpdatePrimaryTestPositions();
    protected abstract virtual void UpdateSecondaryTestPositions();
    protected abstract virtual bool IsEndPosition(int position);
    public bool IsTestingEnd();
    public void Update();
    public void Next();
}
public class DevExpress.Charts.Native.StepAreaGeometrySplittedPointStripCreator : StepAreaGeometrySplittedStripCreator {
    protected bool ShouldColorNewStrip { get; }
    public StepAreaGeometrySplittedPointStripCreator(IStripSplitter stripSplitter, bool invertedStep);
    protected virtual bool get_ShouldColorNewStrip();
    protected virtual RangeStrip ProcessNotInverted(List`1<IGeometryStrip> strips, RangeStrip rangeStrip, double pointArgument, GRealPoint2D lastTopPoint, GRealPoint2D lastBottomPoint, GeometryStripStyle stripStyle);
}
public class DevExpress.Charts.Native.StepAreaGeometrySplittedStripCreator : StepAreaGeometryStripCreator {
    private IStripSplitter stripSplitter;
    protected bool ShouldColorNewStrip { get; }
    public StepAreaGeometrySplittedStripCreator(IStripSplitter stripSplitter, bool invertedStep);
    protected virtual bool get_ShouldColorNewStrip();
    protected virtual IGeometryStrip ProcessIntervalsStrip(IGeometryStrip strip, List`1<IGeometryStrip> strips, IList`1<RefinedPoint> points, int index, List`1<ColoredStripInfo> coloredStripInfos);
    protected virtual RangeStrip ProcessNotInverted(List`1<IGeometryStrip> strips, RangeStrip rangeStrip, double pointArgument, GRealPoint2D lastTopPoint, GRealPoint2D lastBottomPoint, GeometryStripStyle stripStyle);
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
    internal virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.StepAreaGeometryStripCreator : AreaGeometryStripCreator {
    private bool invertedStep;
    protected internal bool Closed { get; }
    protected internal bool ShouldAddEmptyStrip { get; }
    protected bool InvertedStep { get; }
    public StepAreaGeometryStripCreator(bool invertedStep);
    protected internal virtual bool get_Closed();
    protected internal virtual bool get_ShouldAddEmptyStrip();
    protected bool get_InvertedStep();
    protected internal virtual IGeometryStrip CreateStrip();
    protected virtual IGeometryStrip AddStripElementCore(IList`1<RefinedPoint> points, int index, IGeometryStrip strip);
    protected virtual void AddBottomStrip(RefinedPoint refinedPoint, RangeStrip rangeStrip);
}
public class DevExpress.Charts.Native.StepLineGeometrySplittedPointStripCreator : StepLineGeometrySplittedStripCreator {
    public StepLineGeometrySplittedPointStripCreator(IStripSplitter stripSplitter, bool invertedStep, bool shouldAddEmptyStrip);
    private void AddStripPoints(LineStrip lineStrip, RefinedPoint point, GRealPoint2D lastPoint, ColoredStripInfo item);
    protected virtual IGeometryStrip ProcessIntervalsStrip(IGeometryStrip strip, List`1<IGeometryStrip> strips, IList`1<RefinedPoint> points, int index, List`1<ColoredStripInfo> coloredStripInfos);
}
public class DevExpress.Charts.Native.StepLineGeometrySplittedStripCreator : StepLineGeometryStripCreator {
    private IStripSplitter stripSplitter;
    public StepLineGeometrySplittedStripCreator(IStripSplitter stripSplitter, bool invertedStep, bool shouldAddEmptyStrip);
    private LineStrip RecreateStrip(LineStrip lineStrip, List`1<IGeometryStrip> strips, GeometryStripStyle style, GRealPoint2D prevPoint);
    internal virtual IGeometryStrip AddStripElement(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, List`1<IGeometryStrip> strips);
    protected virtual IGeometryStrip ProcessIntervalsStrip(IGeometryStrip strip, List`1<IGeometryStrip> strips, IList`1<RefinedPoint> points, int index, List`1<ColoredStripInfo> coloredStripInfos);
    internal virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.StepLineGeometryStripCreator : LineGeometryStripCreator {
    private bool invertedStep;
    protected bool InvertedStep { get; }
    public StepLineGeometryStripCreator(bool invertedStep, bool shouldAddEmptyStrip);
    protected bool get_InvertedStep();
    protected virtual IGeometryStrip AddStripElementCore(IList`1<RefinedPoint> points, int index, IGeometryStrip strip);
}
public class DevExpress.Charts.Native.StepLineViewportIntersectionHolder : LineViewportIntersectionHolder {
    private bool InvertedStep { get; }
    public StepLineViewportIntersectionHolder(IXYSeriesView view);
    private bool get_InvertedStep();
    protected virtual bool CollectViewportIntersectionCore(List`1<GRealPoint2D> pointsOfIntersection, IList`1<RefinedPoint> points, bool isLeftIntersection, int i, double y, double x);
}
public class DevExpress.Charts.Native.StepToBottom : VerticalStep {
    protected int Increment { get; }
    public StepToBottom(int position, int startColumnIndex, DXRectangle rect, RectanglesLayout layout);
    protected virtual int get_Increment();
    protected virtual DXPoint CalcNearPosition(Cell cell);
    protected virtual void CalcFarPositions(Cell cell, DXPoint& point1, DXPoint& point2);
    protected virtual bool IsEndPosition(int position);
}
public class DevExpress.Charts.Native.StepToLeft : HorizontalStep {
    protected int Increment { get; }
    public StepToLeft(int position, int startRowIndex, DXRectangle rect, RectanglesLayout layout);
    protected virtual int get_Increment();
    protected virtual DXPoint CalcNearPosition(Cell cell);
    protected virtual void CalcFarPositions(Cell cell, DXPoint& point1, DXPoint& point2);
    protected virtual bool IsEndPosition(int position);
}
public class DevExpress.Charts.Native.StepToRight : HorizontalStep {
    protected int Increment { get; }
    public StepToRight(int position, int startRowIndex, DXRectangle rect, RectanglesLayout layout);
    protected virtual int get_Increment();
    protected virtual DXPoint CalcNearPosition(Cell cell);
    protected virtual void CalcFarPositions(Cell cell, DXPoint& point1, DXPoint& point2);
    protected virtual bool IsEndPosition(int position);
}
public class DevExpress.Charts.Native.StepToTop : VerticalStep {
    protected int Increment { get; }
    public StepToTop(int position, int startColumnIndex, DXRectangle rect, RectanglesLayout layout);
    protected virtual int get_Increment();
    protected virtual DXPoint CalcNearPosition(Cell cell);
    protected virtual void CalcFarPositions(Cell cell, DXPoint& point1, DXPoint& point2);
    protected virtual bool IsEndPosition(int position);
}
public class DevExpress.Charts.Native.StrictPointsCalculator : GridPointsCalculatorBase {
    private static int StartAroundLength;
    private Boolean[] usedClustersRows;
    private Boolean[] usedClustersColumns;
    private int unusedRowsInClusters;
    private int unusedColumnsInClusters;
    public int GridSizeX { get; }
    public int GridSizeY { get; }
    public StrictPointsCalculator(GridClusterPointsFactory factory);
    public int get_GridSizeX();
    public int get_GridSizeY();
    private double GetAroundValuesAverage(int indexX, int indexY);
    private RefinedPoint CalculateAveragePoint(int indexX, int indexY);
    protected virtual RefinedPointsGridCluster[0...,0...] CreateEmptyClusters(int countX, int countY);
    protected virtual void ProcessPointForCluster(int indexX, int indexY, RefinedPoint point);
    protected virtual IList`1<RefinedPoint> CreateClusterPoints();
    protected internal virtual bool CanProcessPoints(int pointsCount, int gridNodesCount);
}
public class DevExpress.Charts.Native.StripPointSplitter : StripSplitter {
    private IPointSegmentColorizer segmentColorizer;
    public StripPointSplitter(IPointSegmentColorizer segmentColorizer);
    protected virtual Nullable`1<int> GetColor(IList`1<RefinedPoint> points, int index, Func`2<RefinedPoint, double> getActualValue);
}
public class DevExpress.Charts.Native.StripRange : object {
    private GRealPoint2D top;
    private GRealPoint2D bottom;
    public GRealPoint2D Top { get; }
    public GRealPoint2D Bottom { get; }
    public StripRange(GRealPoint2D top, GRealPoint2D bottom);
    public GRealPoint2D get_Top();
    public GRealPoint2D get_Bottom();
}
public class DevExpress.Charts.Native.StripRangeSplitter : StripSplitter {
    private IRangeSegmentColorizer rangeSegmentColorizer;
    private IList`1<double> RangeStops { get; }
    public StripRangeSplitter(IRangeSegmentColorizer rangeSegmentColorizer);
    private IList`1<double> get_RangeStops();
    protected virtual Nullable`1<int> GetColor(IList`1<RefinedPoint> points, int index, Func`2<RefinedPoint, double> getActualValue);
    public virtual List`1<ColoredStripInfo> SplitStrip(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, Func`2<RefinedPoint, double> getActualValue);
    private void AddSplitStripInfo(List`1<ColoredStripInfo> result, double pointArgument, double pointValue, double prevPointArgument, double prevPointValue, double y, Nullable`1<int> color);
}
public class DevExpress.Charts.Native.StripSplitter : object {
    public bool NeedContinueFirstStrip { get; }
    public virtual bool get_NeedContinueFirstStrip();
    protected virtual Nullable`1<int> GetColor(IList`1<RefinedPoint> points, int index, Func`2<RefinedPoint, double> getActualValue);
    public virtual List`1<ColoredStripInfo> SplitStrip(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, Func`2<RefinedPoint, double> getActualValue);
    public virtual bool CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.StripSplitterContainer : object {
    private IEnumerable`1<IStripSplitter> splitters;
    private bool DevExpress.Charts.Native.IStripSplitter.NeedContinueFirstStrip { get; }
    public StripSplitterContainer(IStripSplitter[] splitters);
    private sealed virtual override bool DevExpress.Charts.Native.IStripSplitter.get_NeedContinueFirstStrip();
    private sealed virtual override List`1<ColoredStripInfo> DevExpress.Charts.Native.IStripSplitter.SplitStrip(IList`1<RefinedPoint> points, int index, IGeometryStrip strip, Func`2<RefinedPoint, double> getActualValue);
    private sealed virtual override bool DevExpress.Charts.Native.IStripSplitter.CanProcessPoint(RefinedPoint point);
}
public class DevExpress.Charts.Native.StripTrendSplitter : StripSplitter {
    private ITrendSegmentColorizer segmentColorizer;
    public bool NeedContinueFirstStrip { get; }
    public StripTrendSplitter(ITrendSegmentColorizer segmentColorizer);
    public virtual bool get_NeedContinueFirstStrip();
    protected virtual Nullable`1<int> GetColor(IList`1<RefinedPoint> points, int index, Func`2<RefinedPoint, double> getActualValue);
}
public class DevExpress.Charts.Native.SumAggregationCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.SumAggregationSingleValueCalculator : object {
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public static class DevExpress.Charts.Native.SummaryBindingHelper : object {
    public static void AddToolTipHint(BoundDataItem boundItem, ISeriesDataAdapter dataAdapter, RowDataReader dataReader);
    public static void AddColor(BoundDataItem boundItem, ISeriesDataAdapter dataAdapter, RowDataReader dataReader);
    public static double AlignNumericArgumentByMeasureUnit(double argument, double measureUnit);
    public static object GetDateTimeSummaryArgument(object initialArgument, IXYSeriesView view, IDateTimeSummaryOptions dateTimeOptions);
    public static object GetTimeSpanSummaryArgument(object initialArgument, IXYSeriesView view, ITimeSpanSummaryOptions timeSpanOptions);
    public static object GetSummaryArgument(object initialArgument, ISeriesBase series, ISummaryBindingProvider summaryBindingProvider);
    public static object GetSummaryArgument(object initialArgument, ISeriesView seriesView, Scale argumentScaleType, ISummaryBindingProvider summaryBindingProvider);
    public static DataSourceValuesCore GetSummaryValues(ISummaryBindingProvider summaryBindingProvider, List`1<IDataMemberContainer> dataMemberContainers, object dataRow);
    public static String[] GetSummaryDataMembers(ISummaryBindingProvider summaryBindingProvider, string dataMember);
}
public class DevExpress.Charts.Native.SummaryChartBindingProcedure : SummaryChartBindingProcedureBase {
    private Dictionary`2<ISeries, BoundData> boundData;
    public SummaryChartBindingProcedure(string seriesDataMember, ISeriesFactory seriesTemplate, ISummaryBindingProvider summaryBindingProvider);
    protected virtual void SummarizeRow(ISeries series, object argument, DataSourceValuesCore values, RowDataReader dataReader);
    protected virtual void OnDataWereRead();
}
public abstract class DevExpress.Charts.Native.SummaryChartBindingProcedureBase : ChartBindingProcedure {
    private ISummaryBindingProvider summaryBindingProvider;
    private String[] summaryDataMembers;
    protected SummaryChartBindingProcedureBase(string seriesDataMember, ISeriesFactory seriesTemplate, ISummaryBindingProvider summaryBindingProvider);
    protected void AddPoints(ISeries series, BoundDataItem boundItem);
    protected abstract virtual void SummarizeRow(ISeries series, object argument, DataSourceValuesCore values, RowDataReader dataReader);
    protected virtual void OnRowWasRead(ISeries series, object dataRow, RowDataReader dataReader);
    protected virtual List`1<IDataMemberContainer> CreateDataMemberContainers();
}
public class DevExpress.Charts.Native.SummaryFunctionParserCore : object {
    private string incorrectSummaryFunctionMessage;
    private string functionString;
    private String[] arguments;
    [CompilerGeneratedAttribute]
private string <FunctionName>k__BackingField;
    public string FunctionName { get; protected set; }
    public String[] Arguments { get; }
    public SummaryFunctionParserCore(string functionString, string incorrectMessage);
    public SummaryFunctionParserCore(ISummaryBindingProvider provider);
    private static bool IsStartIdentifierCharacter(char c);
    private static bool IsIdentifierCharacter(char c);
    protected static bool CheckIdentifier(string identifier);
    [CompilerGeneratedAttribute]
public string get_FunctionName();
    [CompilerGeneratedAttribute]
protected void set_FunctionName(string value);
    public String[] get_Arguments();
    private void ThrowException();
    private void Parse();
    private String[] SplitArguments(string argumentsString);
    protected void ResizeArguments(int length);
}
public static class DevExpress.Charts.Native.SummaryFunctionsCalculatorCore : object {
    private static Nullable`1<T> CalcValue(string functionArgument, DataSourceValuesCore[] values, Func`2<string, T> convertFunc, Func`3<T, T, bool> compareFunc, Int32& resultIndex);
    public static object CalcMin(ISeries series, String[] functionArguments, DataSourceValuesCore[] values, Int32& minIndex);
    public static object CalcMax(ISeries series, String[] functionArguments, DataSourceValuesCore[] values, Int32& maxIndex);
    public static double CalcSum(String[] functionArguments, DataSourceValuesCore[] values);
    public static TimeSpan CalcTimeSpanSum(String[] functionArguments, DataSourceValuesCore[] values);
    public static double CalcAverage(String[] functionArguments, DataSourceValuesCore[] values);
    public static TimeSpan CalcTimeSpanAverage(String[] functionArguments, DataSourceValuesCore[] values);
    public static int CalcCount(DataSourceValuesCore[] values);
}
public class DevExpress.Charts.Native.SummarySeriesBindingProcedure : SummarySeriesBindingProcedureBase {
    private BoundData boundData;
    public SummarySeriesBindingProcedure(SeriesDataAdapterSnapshot seriesDataAdapterSnapshot, ISummaryBindingProvider summaryBindingProvider);
    protected virtual void SummarizeRow(object argument, DataSourceValuesCore values, RowDataReader dataReader);
    protected virtual void OnDataReadFinished();
}
public abstract class DevExpress.Charts.Native.SummarySeriesBindingProcedureBase : SimpleSeriesBindingProcedure {
    private ISummaryBindingProvider summaryBindingProvider;
    private String[] summaryDataMembers;
    protected SummarySeriesBindingProcedureBase(SeriesDataAdapterSnapshot seriesDataAdapterSnapshot, ISummaryBindingProvider summaryBindingProvider);
    protected void AddPoints(BoundDataItem boundItem);
    protected abstract virtual void SummarizeRow(object argument, DataSourceValuesCore values, RowDataReader dataReader);
    protected virtual void OnDataRowRead(object dataRow, RowDataReader dataReader, int position);
    protected virtual List`1<IDataMemberContainer> CreateDataMemberContainers();
}
public class DevExpress.Charts.Native.SummarySeriesSortedBindingProcedure : SummarySeriesBindingProcedureBase {
    private BoundDataItem boundItem;
    public SummarySeriesSortedBindingProcedure(SeriesDataAdapterSnapshot seriesDataAdapterSnapshot, ISummaryBindingProvider summaryBindingProvider);
    protected virtual void SummarizeRow(object argument, DataSourceValuesCore values, RowDataReader dataReader);
    protected virtual void OnDataReadFinished();
}
public enum DevExpress.Charts.Native.SurfaceDataSourceMode : Enum {
    public int value__;
    public static SurfaceDataSourceMode Triangulation;
    public static SurfaceDataSourceMode Grid;
    public static SurfaceDataSourceMode Matrix;
}
public class DevExpress.Charts.Native.TestPosition : ValueType {
    private double distance;
    private DXPoint position;
    private bool check;
    public double Distance { get; }
    public DXPoint Position { get; }
    public bool Check { get; public set; }
    public TestPosition(DXPoint position, double distance);
    public static int CompareByDistance(TestPosition x, TestPosition y);
    public double get_Distance();
    public DXPoint get_Position();
    public bool get_Check();
    public void set_Check(bool value);
}
public enum DevExpress.Charts.Native.TextRotation : Enum {
    public int value__;
    public static TextRotation LeftTop;
    public static TextRotation CenterTop;
    public static TextRotation RightTop;
    public static TextRotation LeftCenter;
    public static TextRotation CenterCenter;
    public static TextRotation RightCenter;
    public static TextRotation LeftBottom;
    public static TextRotation CenterBottom;
    public static TextRotation RightBottom;
}
public class DevExpress.Charts.Native.TimeCore : ValueType {
    private static int FakeYear;
    private static int FakeMonth;
    private static int FakeDay;
    public static TimeCore DayBegin;
    public static TimeCore DayEnd;
    private int hour;
    private int minute;
    private int second;
    public int Hour { get; }
    public int Minute { get; }
    public int Second { get; }
    public TimeCore(int hour, int minute, int second);
    public TimeCore(DateTime date);
    private static TimeCore();
    public static bool op_GreaterThan(TimeCore t1, TimeCore t2);
    public static bool op_LessThan(TimeCore t1, TimeCore t2);
    public static bool op_LessThanOrEqual(TimeCore t1, TimeCore t2);
    public static bool op_GreaterThanOrEqual(TimeCore t1, TimeCore t2);
    public static bool op_Equality(TimeCore t1, TimeCore t2);
    public static bool op_Inequality(TimeCore t1, TimeCore t2);
    public static TimeSpan op_Subtraction(TimeCore t1, TimeCore t2);
    public static TimeSpan op_Explicit(TimeCore t);
    public int get_Hour();
    public int get_Minute();
    public int get_Second();
    public virtual string ToString();
    public sealed virtual bool Equals(TimeCore other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public int FloorToMeasureUnits(DateTimeMeasureUnitNative mu);
    public int CeilToMeasureUnits(DateTimeMeasureUnitNative mu);
}
public class DevExpress.Charts.Native.TimeIntervalCore : object {
    private TimeCore begin;
    private TimeCore end;
    public TimeCore Begin { get; }
    public TimeCore End { get; }
    public TimeIntervalCore(TimeCore begin, TimeCore end);
    public static bool op_Equality(TimeIntervalCore ti1, TimeIntervalCore ti2);
    public static bool op_Inequality(TimeIntervalCore ti1, TimeIntervalCore ti2);
    public TimeCore get_Begin();
    public TimeCore get_End();
    public virtual string ToString();
    public bool Contains(TimeCore time);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.TimeIntervalInMeasureUnits : ValueType {
    private int begin;
    private int end;
    public int Begin { get; }
    public int End { get; }
    public int Length { get; }
    public TimeIntervalInMeasureUnits(int begin, int end);
    public int get_Begin();
    public int get_End();
    public int get_Length();
    public bool Contains(int timeInMeasureUnits);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.TimeIntervalSetCore : object {
    private static TimeIntervalSetCore wholeDay;
    private List`1<TimeIntervalCore> sortedNotIntersectedIntervals;
    private bool isWholeDay;
    public static TimeIntervalSetCore WholeDay { get; }
    public TimeIntervalCore Item { get; }
    public int Count { get; }
    private TimeIntervalSetCore(List`1<TimeIntervalCore> notIntersectedIntervals);
    public TimeIntervalSetCore(ITimeIntervalCollection intervals);
    private static TimeIntervalSetCore();
    public static TimeIntervalSetCore get_WholeDay();
    public static bool op_Equality(TimeIntervalSetCore tis1, TimeIntervalSetCore tis2);
    public static bool op_Inequality(TimeIntervalSetCore tis1, TimeIntervalSetCore tis2);
    public TimeIntervalCore get_Item(int i);
    public int get_Count();
    private List`1<TimeIntervalCore> HandleIntersections(List`1<TimeIntervalCore> sortedByBeginTimeIntervals);
    private bool IsIntersected(TimeIntervalCore beginEarlier, TimeIntervalCore beginLater);
    private bool CalcIsWholeDay();
    public bool Contains(TimeCore time);
    public TimeIntervalSetCore Invert();
    public List`1<TimeIntervalInMeasureUnits> NarrowToMeasureUnits(DateTimeMeasureUnitNative measureUnit);
    public List`1<TimeIntervalInMeasureUnits> ExpandToMeasureUnits(DateTimeMeasureUnitNative measureUnit);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool IsWholeDay();
}
public class DevExpress.Charts.Native.TimeSpanAggregatedSeriesArgumentContainer : AggregatedSeriesArgumentContainer`1<TimeSpan> {
    protected Scale Scale { get; }
    protected TimeSpan TimeSpanArgument { get; }
    protected string QualitativeArgument { get; }
    public TimeSpanAggregatedSeriesArgumentContainer(object argument);
    protected virtual Scale get_Scale();
    protected virtual TimeSpan get_TimeSpanArgument();
    protected virtual string get_QualitativeArgument();
    protected virtual TimeSpan Convert(object value);
}
public class DevExpress.Charts.Native.TimeSpanArgumentSimpleStandardDeviationCalculator : SimpleStandardDeviationCalculator {
    private AxisTimeSpanMap map;
    public TimeSpanArgumentSimpleStandardDeviationCalculator(AxisTimeSpanMap map);
    protected virtual double GetValue(RefinedPoint point);
}
internal class DevExpress.Charts.Native.TimeSpanAxisAggregationInterval : AxisAggregationInterval {
    private object nativeMin;
    private object nativeMax;
    public object NativeMin { get; }
    public object NativeMax { get; }
    public TimeSpanAxisAggregationInterval(double min, double max, bool includeMin, bool includeMax, bool isUnderflow, bool isOverflow);
    public virtual object get_NativeMin();
    public virtual object get_NativeMax();
}
public class DevExpress.Charts.Native.TimeSpanAxisAggregationIntervalsCalculator : MeasureUnitAxisAggregationIntervalsCalculator`1<TimeSpanMeasureUnitNative> {
    protected virtual double RoundValue(IAxisData axis, double value);
    protected virtual double RoundUpValue(IAxisData axis, double value);
    protected virtual SimpleStandardDeviationCalculator CreateAutoHistogramCalculator(IAxisData axis);
    public virtual bool UpdateIntervals(IAxisData axis, IList`1<RefinedSeries> refinedSeries);
}
internal class DevExpress.Charts.Native.TimeSpanAxisIntervalsContainer : AxisIntervalsContainer {
    private static double Precision;
    public TimeSpanAxisIntervalsContainer(AggregationIntervalsInfo info);
    protected virtual double GetNextRefinedValue(double value);
    protected virtual double GetPrevRefinedValue(double value);
    protected virtual object GetNextNativeValue(object value);
    protected virtual object GetPrevNativeValue(object value);
    protected virtual AxisAggregationInterval CreateInterval(double min, double max, bool useUnderflow);
    protected virtual AxisAggregationInterval CreateOverflowInterval(double min, double max);
    protected virtual AxisAggregationInterval CreateUnderflowInterval(double min, double max, bool useUnderflow);
}
public class DevExpress.Charts.Native.TimeSpanAxisRangeUpdateStrategy : NumericalAxisRangeUpdateStrategy {
    public TimeSpanAxisRangeUpdateStrategy(IAxisData axis, MinMaxValues minMaxInternal, MinMaxValues minMaxRefined, ICollection`1<RefinedSeries> refinedSeries, bool scaleMapWasChanged);
    protected virtual InternalRange ApplySideMargins(MinMaxValues internalValues, MinMaxValues sideMargins, bool autoCorrectionMin, bool autoCorrectionMax);
}
public abstract class DevExpress.Charts.Native.TimeSpanDateTimeSeriesPointDataContainer : SeriesPointDataContainer {
    private TimeSpan argument;
    protected TimeSpan Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public TimeSpan TimeSpanArgument { get; public set; }
    public string QualitativeArgument { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected TimeSpanDateTimeSeriesPointDataContainer(TimeSpan argument);
    public static TimeSpanDateTimeSeriesPointDataContainer CreateContainer(TimeSpan argument, DateTime[] values);
    public static TimeSpanDateTimeSeriesPointDataContainer CreateContainer(TimeSpan argument, int dimension);
    protected TimeSpan get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual TimeSpan get_TimeSpanArgument();
    public virtual void set_TimeSpanArgument(TimeSpan value);
    public virtual string get_QualitativeArgument();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public enum DevExpress.Charts.Native.TimeSpanGridAlignmentNative : Enum {
    public int value__;
    public static TimeSpanGridAlignmentNative Millisecond;
    public static TimeSpanGridAlignmentNative Second;
    public static TimeSpanGridAlignmentNative Minute;
    public static TimeSpanGridAlignmentNative Hour;
    public static TimeSpanGridAlignmentNative Day;
}
public abstract class DevExpress.Charts.Native.TimeSpanLabelFormatterBase : object {
    protected TimeSpanGridAlignmentNative GridAlignment { get; }
    protected abstract virtual TimeSpanGridAlignmentNative get_GridAlignment();
    private sealed virtual override object System.IFormatProvider.GetFormat(Type formatType);
    private sealed virtual override string System.ICustomFormatter.Format(string format, object arg, IFormatProvider formatProvider);
}
public enum DevExpress.Charts.Native.TimeSpanMeasureUnitNative : Enum {
    public int value__;
    public static TimeSpanMeasureUnitNative Millisecond;
    public static TimeSpanMeasureUnitNative Second;
    public static TimeSpanMeasureUnitNative Minute;
    public static TimeSpanMeasureUnitNative Hour;
    public static TimeSpanMeasureUnitNative Day;
}
public class DevExpress.Charts.Native.TimeSpanMeasureUnitsCalculatorCore : MeasureUnitsCalculatorBase`2<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative> {
    private double previousThreshold;
    private ITimeSpanScaleOptions TimeSpanScaleOptions { get; }
    protected bool UseMinMeasureUnit { get; }
    protected IScaleOptionsBase`1<TimeSpanMeasureUnitNative> ScaleOptions { get; }
    public TimeSpanMeasureUnitsCalculatorCore(IAxisData axis);
    private ITimeSpanScaleOptions get_TimeSpanScaleOptions();
    protected virtual bool get_UseMinMeasureUnit();
    protected virtual IScaleOptionsBase`1<TimeSpanMeasureUnitNative> get_ScaleOptions();
    private GridAlignment<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative> AlignToRange(GridAlignment<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative> selectedAlignment, TimeSpan min, TimeSpan max);
    private GridAlignment<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative> CalculateGridAlignment(double pixelsPerUnit, TimeSpan min, TimeSpan max);
    protected virtual UnitSelector`2<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative> CreateUnitSelector();
    protected virtual void UpdateAutomaticGrid(double pixelsPerUnit, IMinMaxValues visualRange);
    protected virtual bool UpdateAutomaticUnits(TimeSpanMeasureUnitNative measureUnit, int pixelsPerUnit);
}
public abstract class DevExpress.Charts.Native.TimeSpanNumericSeriesPointDataContainer : SeriesPointDataContainer {
    private TimeSpan argument;
    protected TimeSpan Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public TimeSpan TimeSpanArgument { get; public set; }
    public string QualitativeArgument { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected TimeSpanNumericSeriesPointDataContainer(TimeSpan argument);
    public static TimeSpanNumericSeriesPointDataContainer CreateContainer(TimeSpan argument, int dimension);
    public static TimeSpanNumericSeriesPointDataContainer CreateContainer(TimeSpan argument, Double[] values);
    protected TimeSpan get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual TimeSpan get_TimeSpanArgument();
    public virtual void set_TimeSpanArgument(TimeSpan value);
    public virtual string get_QualitativeArgument();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.TimeSpanRangeControlClientGridMapping : DateTimeRangeControlClientGridMapping {
    protected virtual double RoundValue(RangeControlGridUnit unit, double value, double offset, bool ceil);
}
public class DevExpress.Charts.Native.TimeSpanSeriesPointDataContainer : SeriesPointDataContainer {
    private TimeSpan argument;
    private int dimension;
    public Scale ArgumentScaleType { get; }
    public TimeSpan TimeSpanArgument { get; public set; }
    public string QualitativeArgument { get; }
    public int Dimension { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    public TimeSpanSeriesPointDataContainer(TimeSpan argument, int dimension);
    public static SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, int dimension);
    public virtual Scale get_ArgumentScaleType();
    public virtual TimeSpan get_TimeSpanArgument();
    public virtual void set_TimeSpanArgument(TimeSpan value);
    public virtual string get_QualitativeArgument();
    public virtual int get_Dimension();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer SetDimension(int dimension);
    public virtual SeriesPointDataContainer Clone();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.TimeSpanSeriesPointValuesContainer : SeriesPointValuesContainer`1<TimeSpan> {
    protected Scale ScaleType { get; }
    public TimeSpan[] TimeSpanValues { get; }
    public TimeSpanSeriesPointValuesContainer(TimeSpan[] values, Double[] userValues);
    protected virtual Scale get_ScaleType();
    public virtual TimeSpan[] get_TimeSpanValues();
}
public abstract class DevExpress.Charts.Native.TimeSpanTimeSpanSeriesPointDataContainer : SeriesPointDataContainer {
    private TimeSpan argument;
    protected TimeSpan Argument { get; }
    public Scale ArgumentScaleType { get; }
    public Scale ValueScaleType { get; }
    public TimeSpan TimeSpanArgument { get; public set; }
    public string QualitativeArgument { get; }
    public bool IsEmpty { get; }
    public bool IsValidArgument { get; }
    protected TimeSpanTimeSpanSeriesPointDataContainer(TimeSpan argument);
    public static TimeSpanTimeSpanSeriesPointDataContainer CreateContainer(TimeSpan argument, TimeSpan[] values);
    public static TimeSpanTimeSpanSeriesPointDataContainer CreateContainer(TimeSpan argument, int dimension);
    protected TimeSpan get_Argument();
    public virtual Scale get_ArgumentScaleType();
    public virtual Scale get_ValueScaleType();
    public virtual TimeSpan get_TimeSpanArgument();
    public virtual void set_TimeSpanArgument(TimeSpan value);
    public virtual string get_QualitativeArgument();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsValidArgument();
    public virtual SeriesPointDataContainer Create(List`1<IDataMemberContainer> containers, bool isEmpty);
}
public class DevExpress.Charts.Native.TimeSpanUnitSelector : DateTimeUnitSelectorBase`2<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative> {
    private static double sizeMillisecond;
    private static double sizeSecond;
    private static double sizeMinute;
    private static double sizeHour;
    private static double sizeDay;
    public static double DefaultGridSpacing;
    public static TimeSpanMeasureUnitNative DefaultMeasureUnit { get; }
    public static TimeSpanGridAlignmentNative DefaultGridAlignment { get; }
    public static TimeSpanMeasureUnitNative get_DefaultMeasureUnit();
    public static TimeSpanGridAlignmentNative get_DefaultGridAlignment();
    private static TimeSpanGridAlignmentNative GetPreviousAlignment(TimeSpanGridAlignmentNative alignment);
    public static double GetMeasureUnitValue(TimeSpanGridAlignmentNative alignment);
    public static double GetMeasureUnitValue(TimeSpanMeasureUnitNative measureUnit);
    public static GridAlignment<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative> GetPreviousGridAlignment(GridAlignment<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative> gridAlignment);
    protected virtual List`1<MeasureItem<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative>> FillMeasureSteps();
    protected virtual List`1<AlignmentItem<TimeSpanMeasureUnitNative, TimeSpanGridAlignmentNative>> FillAlignmentSteps();
}
public class DevExpress.Charts.Native.ToolTipBoxPlotValueToStringConverter : ToolTipPointDataToStringConverter {
    protected string DefaultValuePattern { get; }
    protected string GroupedPointValuePattern { get; }
    protected string DefaultCrosshairLegendPattern { get; }
    public ToolTipBoxPlotValueToStringConverter(ISeries series);
    protected virtual string get_DefaultValuePattern();
    protected virtual string get_GroupedPointValuePattern();
    protected virtual string get_DefaultCrosshairLegendPattern();
}
public class DevExpress.Charts.Native.ToolTipBubbleValueToStringConverter : ToolTipValueToStringConverter {
    protected string DefaultValuePattern { get; }
    protected string GroupedPointValuePattern { get; }
    protected string DefaultLegendNumericFormat { get; }
    public ToolTipBubbleValueToStringConverter(ISeries series);
    protected virtual string get_DefaultValuePattern();
    protected virtual string get_GroupedPointValuePattern();
    protected virtual string get_DefaultLegendNumericFormat();
}
public class DevExpress.Charts.Native.ToolTipFinancialValueToStringConverter : ToolTipPointDataToStringConverter {
    protected string DefaultValuePattern { get; }
    protected string GroupedPointValuePattern { get; }
    protected string DefaultCrosshairLegendPattern { get; }
    public ToolTipFinancialValueToStringConverter(ISeries series);
    public ToolTipFinancialValueToStringConverter(ISeries series, bool showOpen, bool showClose);
    protected virtual string get_DefaultValuePattern();
    protected virtual string get_GroupedPointValuePattern();
    protected virtual string get_DefaultCrosshairLegendPattern();
}
public class DevExpress.Charts.Native.ToolTipFullStackedValueToStringConverter : ToolTipPercentValueToStringConverter {
    public ToolTipFullStackedValueToStringConverter(ISeries series);
    public ToolTipFullStackedValueToStringConverter(ISeries series, bool showStackedGroup);
}
public static class DevExpress.Charts.Native.ToolTipPatternUtils : object {
    public static String[] BaseViewPointPatterns;
    [ObsoleteAttribute]
public static String[] PercentViewPointPatterns;
    [ObsoleteAttribute]
public static String[] StackedGroupViewPointPatterns;
    [ObsoleteAttribute]
public static String[] FullStackedGroupViewPointPatterns;
    public static String[] BubbleViewPointPatterns;
    public static String[] RangeViewPointPatterns;
    public static String[] DateTimeRangeViewPointPatterns;
    public static String[] FinancialViewPointPatterns;
    public static String[] BoxPlotViewPointPatterns;
    public static String[] BaseViewSeriesPatterns;
    public static String[] StackedGroupViewSeriesPatterns;
    public static String[] StackedSeriesPointPatterns;
    public static String[] WaterfallSeriesPointPatterns;
    public static String[] FullStackedSeriesPointPatterns;
    public static String[] SideBySideStackedPointPatterns;
    public static String[] SideBySideFullStackedPointPatterns;
    public static String[] PieFunnelDonutPointPatterns;
    public static String[] NestedDonutPointPatterns;
    private static ToolTipPatternUtils();
}
public abstract class DevExpress.Charts.Native.ToolTipPercentValueToStringConverter : ToolTipValueToStringConverter {
    protected string DefaultValuePattern { get; }
    protected string GroupedPointValuePattern { get; }
    protected string DefaultLegendNumericFormat { get; }
    protected ToolTipPercentValueToStringConverter(ISeries series);
    protected ToolTipPercentValueToStringConverter(ISeries series, bool showStackedGroup);
    protected virtual string get_DefaultValuePattern();
    protected virtual string get_GroupedPointValuePattern();
    protected virtual string get_DefaultLegendNumericFormat();
}
public abstract class DevExpress.Charts.Native.ToolTipPointDataToStringConverter : object {
    private static string defaultStackedGroupPattern;
    private string defaultPointPattern;
    private string defaultLegendPattern;
    private ISeries series;
    private bool showOpen;
    private bool showClose;
    private bool allowArgument;
    private bool allowValue;
    private object hint;
    protected string DefaultValuePattern { get; }
    protected string DefaultArgumentPattern { get; }
    protected string GroupedPointValuePattern { get; }
    protected string DefaultNumericFormat { get; }
    protected string DefaultLegendNumericFormat { get; }
    protected string DefaultCrosshairLegendPattern { get; }
    protected ISeries Series { get; }
    protected bool ShowOpen { get; }
    protected bool ShowClose { get; }
    protected bool IsTextInLegend { get; }
    public object Hint { get; public set; }
    public string ActualPointPattern { get; }
    public string DefaultPointPattern { get; }
    protected ToolTipPointDataToStringConverter(ISeries series, bool showOpen, bool showClose, bool showStackedGroup, bool allowArgument, bool allowValue);
    protected ToolTipPointDataToStringConverter(ISeries series, bool showOpen, bool showClose, bool showStackedGroup);
    protected ToolTipPointDataToStringConverter(ISeries series);
    protected ToolTipPointDataToStringConverter(ISeries series, bool showStackedGroup);
    protected abstract virtual string get_DefaultValuePattern();
    protected virtual string get_DefaultArgumentPattern();
    protected virtual string get_GroupedPointValuePattern();
    protected virtual string get_DefaultNumericFormat();
    protected virtual string get_DefaultLegendNumericFormat();
    protected virtual string get_DefaultCrosshairLegendPattern();
    protected ISeries get_Series();
    protected bool get_ShowOpen();
    protected bool get_ShowClose();
    protected bool get_IsTextInLegend();
    public object get_Hint();
    public void set_Hint(object value);
    public string get_ActualPointPattern();
    public string get_DefaultPointPattern();
    private string GetDefaultArgumentFormat();
    protected string GetDefaultFormat(Scale scaleType);
    protected DateTimeMeasureUnitNative GetActualMeasureUnit(IDateTimeScaleOptions scaleOptions);
    protected string GetFormatString(DateTimeMeasureUnitNative dateTimeMeasureUnitNative);
    protected string GetDefaultValueFormat();
    public string GetGroupedPointPattern(bool allowArgument, bool allowValue);
}
public class DevExpress.Charts.Native.ToolTipRangeValueToStringConverter : ToolTipPointDataToStringConverter {
    protected string DefaultValuePattern { get; }
    protected string GroupedPointValuePattern { get; }
    protected string DefaultLegendNumericFormat { get; }
    public ToolTipRangeValueToStringConverter(ISeries series);
    protected virtual string get_DefaultValuePattern();
    protected virtual string get_GroupedPointValuePattern();
    protected virtual string get_DefaultLegendNumericFormat();
}
public class DevExpress.Charts.Native.ToolTipSimpleDiagramValueToStringConverter : ToolTipPercentValueToStringConverter {
    public ToolTipSimpleDiagramValueToStringConverter(ISeries series);
}
public class DevExpress.Charts.Native.ToolTipValueToStringConverter : ToolTipPointDataToStringConverter {
    protected string DefaultValuePattern { get; }
    protected string GroupedPointValuePattern { get; }
    protected ToolTipValueToStringConverter(ISeries series, bool allowArgument, bool allowValue);
    public ToolTipValueToStringConverter(ISeries series);
    public ToolTipValueToStringConverter(ISeries series, bool showStackedGroup);
    protected virtual string get_DefaultValuePattern();
    protected virtual string get_GroupedPointValuePattern();
}
public class DevExpress.Charts.Native.ToolTipXYZToStringConverter : ToolTipValueToStringConverter {
    protected string DefaultArgumentPattern { get; }
    protected string DefaultNumericFormat { get; }
    public ToolTipXYZToStringConverter(ISeries series);
    protected virtual string get_DefaultArgumentPattern();
    protected virtual string get_DefaultNumericFormat();
    private string GetDefaultArgumentXFormat();
    private string GetDefaultArgumentYFormat();
    private string GetDefaultArgumentFormat(IAxisData axisData, Scale scale);
}
public class DevExpress.Charts.Native.TopNFilterBehavior : ValueThresholdFilterBehavior {
    private int CalculateMinPointIndex(IList`1<RefinedPoint> points);
    protected virtual IList`1<RefinedPoint> FilterPoints(IList`1<RefinedPoint> initialPoints, double valueThreshold);
}
public abstract class DevExpress.Charts.Native.Transformation : object {
    public bool IsIdentity { get; }
    public abstract virtual bool get_IsIdentity();
    public abstract virtual double TransformForward(double value);
    public abstract virtual double TransformBackward(double value);
    public virtual void Reset();
    public virtual void Update(Double[] values);
    public virtual void CompleteUpdate();
    public void Update(IAxisValueContainer container);
}
public class DevExpress.Charts.Native.TrendLineCalculator : FinancialIndicatorCalculator {
    public GRealLine2D Calculate(IRefinedSeries seriesInfo, AxisScaleTypeMap axisXScaleTypeMap, CultureInfo cultureInfo, object argument1, ValueLevelInternal valueLevel1, object argument2, ValueLevelInternal valueLevel2, bool extrapolateToInfinity, double axisXMaxValue, bool extrapolateToNegativeInfinity, double axisXMinValue, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.TriangularMovingAverageCalculator : MovingAverageCalculator {
    public virtual void UpdateMovingAverageData(IList`1<RefinedPoint> refinedPoints, int startUpdateIndex, int pointsCount, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.TripleExponentialMovingAverageCalculator : MovingAverageCalculator {
    public virtual void UpdateMovingAverageData(IList`1<RefinedPoint> refinedPoints, int startUpdateIndex, int pointsCount, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.TripleExponentialMovingAverageTrixCalculator : object {
    private static int DesignTimePointsCount;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    private double CalcTrix(double tma, double tmaPre);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int smoothingPointCount, ValueLevelInternal valueLevel);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int smoothingPointCount, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public static class DevExpress.Charts.Native.TypeConversion : object {
    public static object ConvertToCompatibleValue(object value, Type type);
}
internal abstract class DevExpress.Charts.Native.TypedUpdateProcessor`1 : object {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual bool ShouldForceUpdate();
    protected abstract virtual IList`1<IUpdateAction> TypedProcess(T updateInfo);
    protected virtual IList`1<IUpdateAction> Process(ChartUpdateInfoBase updateInfo);
    private sealed virtual override IList`1<IUpdateAction> DevExpress.Charts.Native.IUpdateProcessor.Process(ChartUpdateInfoBase updateInfo);
    private sealed virtual override bool DevExpress.Charts.Native.IUpdateProcessor.CanProcess(ChartUpdateInfoBase updateInfo);
    private sealed virtual override bool DevExpress.Charts.Native.IUpdateProcessor.ShouldForceUpdate();
}
internal abstract class DevExpress.Charts.Native.TypedUpdateProcessor`2 : TypedUpdateProcessor`1<T> {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected abstract virtual IList`1<IUpdateAction> TypedProcess(T updateInfo, S sender);
    protected virtual IList`1<IUpdateAction> TypedProcess(T updateInfo);
}
public class DevExpress.Charts.Native.TypicalPriceCalculator : object {
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    public bool Calculated { get; private set; }
    public static bool IsCompatible(ISeriesView view);
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    private bool IsParameterCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
}
public class DevExpress.Charts.Native.UnitContainer`2 : object {
    internal static double UnitChangeFactor;
    private List`1<MeasureItem<TMeasureUnit, TGridAlignment>> measureItems;
    private List`1<AlignmentItem<TMeasureUnit, TGridAlignment>> alignmentItems;
    public int MeasureUnitCount { get; }
    public int AlignmentUnitCount { get; }
    public int get_MeasureUnitCount();
    public int get_AlignmentUnitCount();
    private T SelectUnit(IList`1<T> list, double value, double previousValue);
    private T SelectUnit(double value, double previousValue);
    private T GetUnitAt(int index);
    public MeasureItem<TMeasureUnit, TGridAlignment> SelectMeasureUnit(double value, double previousValue);
    public AlignmentItem<TMeasureUnit, TGridAlignment> SelectAlignmentUnit(double value, double previousValue);
    public MeasureItem<TMeasureUnit, TGridAlignment> GetMeasureUnitAt(int index);
    public AlignmentItem<TMeasureUnit, TGridAlignment> GetAlignmentUnitAt(int index);
    public void UpdateActiveUnits(IEnumerable`1<MeasureItem<TMeasureUnit, TGridAlignment>> measureItems, IEnumerable`1<AlignmentItem<TMeasureUnit, TGridAlignment>> alignmentItems);
}
public class DevExpress.Charts.Native.UnitItemData : object {
    [CompilerGeneratedAttribute]
private MinMaxValues <ValueRange>k__BackingField;
    [CompilerGeneratedAttribute]
private HeatmapRangeStopCore <Value1>k__BackingField;
    [CompilerGeneratedAttribute]
private HeatmapRangeStopCore <Value2>k__BackingField;
    public MinMaxValues ValueRange { get; }
    public HeatmapRangeStopCore Value1 { get; }
    public HeatmapRangeStopCore Value2 { get; }
    public UnitItemData(MinMaxValues valueRange, HeatmapRangeStopCore value1, HeatmapRangeStopCore value2);
    [CompilerGeneratedAttribute]
public MinMaxValues get_ValueRange();
    [CompilerGeneratedAttribute]
public HeatmapRangeStopCore get_Value1();
    [CompilerGeneratedAttribute]
public HeatmapRangeStopCore get_Value2();
}
public class DevExpress.Charts.Native.UnitRangeLegendItemDataProvider : PatternDataProvider {
    private string patternConstants;
    public UnitRangeLegendItemDataProvider(string patternConstants);
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public abstract class DevExpress.Charts.Native.UnitSelector`2 : object {
    private UnitContainer<TMeasureUnit, TGridAlignment> activeUnitContainer;
    protected UnitContainer<TMeasureUnit, TGridAlignment> ActiveUnitContainer { get; }
    public static double CalculateSpacing(double value, double threshold);
    protected UnitContainer<TMeasureUnit, TGridAlignment> get_ActiveUnitContainer();
    internal IList`1<TMeasureUnit> SelectActiveMeasureUnits();
    public TMeasureUnit SelectMeasureUnit(double value, double previousValue);
    public virtual GridAlignment<TMeasureUnit, TGridAlignment> SelectAlignment(double value, double previousValue);
    public abstract virtual void UpdateActiveUnits(double min, double max);
}
internal class DevExpress.Charts.Native.UpdateAxisAction : UpdateAxisActionBase {
    private AxisActionType updateType;
    public AxisActionType UpdateType { get; }
    public UpdateAxisAction(IAxisData axis, AxisActionType updateType);
    public AxisActionType get_UpdateType();
    public void AddActionType(AxisActionType updateType);
}
internal abstract class DevExpress.Charts.Native.UpdateAxisActionBase : object {
    private IAxisData axis;
    public IAxisData Axis { get; }
    public UpdateAxisActionBase(IAxisData axis);
    public IAxisData get_Axis();
}
internal class DevExpress.Charts.Native.UpdateGroupAction : UpdateAxisActionBase {
    private CollectionActionType updateType;
    public CollectionActionType UpdateType { get; }
    public UpdateGroupAction(IAxisData axis, CollectionActionType updateType);
    public CollectionActionType get_UpdateType();
}
internal class DevExpress.Charts.Native.UpdateRangeExecutor : object {
    private SeriesController seriesController;
    public UpdateRangeExecutor(SeriesController seriesController);
    private List`1<IAxisData> GetAxesForReset(IEnumerable`1<RefinedSeriesGroup> groupsWithChangedScaleMap);
    private void UpdateDiagramAxes(IXYDiagram diagram, bool shouldDeserializeRange);
    private void UpdateAxes(IEnumerable`1<IAxisData> axes);
    private void DeserializeAxesRange(IEnumerable`1<IAxisData> axes);
    private void UpdateRange(VisualRangeUpdateMode updateMode, List`1<IAxisData> axesForReset);
    private MinMaxValues CopyValueAxisWholeRange(IXYDiagram diagram);
    public sealed virtual SeriesControllerChanges Execute(IExecutorContext context);
}
internal class DevExpress.Charts.Native.UpdateRefinedSeriesDataExecutor : object {
    private HashSet`1<RefinedSeries> updatedSeriesData;
    private void UpdateSeriesData(IEnumerable`1<RefinedSeries> refinedSeries, bool shouldUpdateInternalArguments);
    private void UpdateSeriesPointsValues(IEnumerable`1<RefinedSeries> refinedSeries);
    public sealed virtual SeriesControllerChanges Execute(IExecutorContext context);
}
internal class DevExpress.Charts.Native.UpdateSeriesAction : object {
    private ISeriesBase series;
    private SeriesActionType updateType;
    public ISeriesBase Series { get; }
    public SeriesActionType UpdateType { get; }
    private ISeriesBase DevExpress.Charts.Native.ISeriesUpdateAction.Series { get; }
    public UpdateSeriesAction(ISeriesBase series, SeriesActionType updateType);
    public ISeriesBase get_Series();
    public SeriesActionType get_UpdateType();
    private sealed virtual override ISeriesBase DevExpress.Charts.Native.ISeriesUpdateAction.get_Series();
    public void AddActionType(SeriesActionType actionType);
}
internal class DevExpress.Charts.Native.UpdateSeriesPointAction : object {
    private ISeries series;
    private IDataPoint seriesPoint;
    public ISeries Series { get; }
    public IDataPoint SeriesPoint { get; }
    private ISeriesBase DevExpress.Charts.Native.ISeriesUpdateAction.Series { get; }
    public UpdateSeriesPointAction(ISeries series, IDataPoint seriesPoint);
    public ISeries get_Series();
    public IDataPoint get_SeriesPoint();
    private sealed virtual override ISeriesBase DevExpress.Charts.Native.ISeriesUpdateAction.get_Series();
}
internal class DevExpress.Charts.Native.UseCheckBoxesPropertyUpdateProcessor : TypedUpdateProcessor`1<PropertyUpdateInfo> {
    protected virtual bool CanProcess(ChartUpdateInfoBase updateInfo);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.UserAggregateFunctionCalculator : object {
    private AxisScaleTypeMap axisXScaleTypeMap;
    private ICustomAggregateFunction userCalculator;
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanKeepSinglePoint { get; }
    private bool DevExpress.Charts.Native.IAggregationCalculator.CanSupportErrorBars { get; }
    public UserAggregateFunctionCalculator(AxisScaleTypeMap axisXScaleTypeMap, ICustomAggregateFunction userCalculator);
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanKeepSinglePoint();
    private sealed virtual override bool DevExpress.Charts.Native.IAggregationCalculator.get_CanSupportErrorBars();
    private sealed virtual override Double[] DevExpress.Charts.Native.IAggregationCalculator.Calculate(IList`1<RefinedPoint> points, int index, int count, CorePointState& state);
}
public class DevExpress.Charts.Native.ValueDateTimeDataMemberContainer : ComparableDataMemberContainer`1<DateTime> {
    protected DateTime DefaultValue { get; }
    public ValueDateTimeDataMemberContainer(string dataMember, bool supportEmptyValue);
    protected virtual DateTime get_DefaultValue();
    protected virtual bool IsCompatibleType(Type type);
    protected virtual bool IsEmptyValue(DateTime value);
    protected virtual DateTime ConvertValue(object value);
    protected virtual DateTime ParseValue(object value);
}
public class DevExpress.Charts.Native.ValueLegendItemDataProvider : PatternDataProvider {
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public enum DevExpress.Charts.Native.ValueLevelInternal : Enum {
    public int value__;
    public static ValueLevelInternal Value;
    public static ValueLevelInternal Value_1;
    public static ValueLevelInternal Value_2;
    public static ValueLevelInternal Low;
    public static ValueLevelInternal High;
    public static ValueLevelInternal Open;
    public static ValueLevelInternal Close;
    public static ValueLevelInternal Weight;
    public static ValueLevelInternal BoxPlotMin;
    public static ValueLevelInternal BoxPlotQuartile_1;
    public static ValueLevelInternal BoxPlotMedian;
    public static ValueLevelInternal BoxPlotQuartile_3;
    public static ValueLevelInternal BoxPlotMax;
    public static ValueLevelInternal BoxPlotMean;
}
public class DevExpress.Charts.Native.ValueNumericDataMemberContainer : ComparableDataMemberContainer`1<double> {
    protected double DefaultValue { get; }
    public ValueNumericDataMemberContainer(string dataMember, bool supportEmptyValue);
    protected virtual double get_DefaultValue();
    protected virtual bool IsCompatibleType(Type type);
    protected virtual bool IsEmptyValue(double value);
    protected virtual double ConvertValue(object value);
    protected virtual double ParseValue(object value);
}
public class DevExpress.Charts.Native.ValueRangeLegendItemDataProvider : PatternDataProvider {
    private string patternConstants;
    public ValueRangeLegendItemDataProvider(string patternConstants);
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public class DevExpress.Charts.Native.ValuesSourcePatternDataProvider : PatternDataProvider {
    private string patternConstant;
    public ValuesSourcePatternDataProvider(string patternConstant);
    private static bool IsCorrectDurationSource(IPatternValuesSource valuesSource);
    private object GetValueFromValuesSource();
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public abstract class DevExpress.Charts.Native.ValueThresholdFilterBehavior : object {
    private IList`1<RefinedPoint> othersPoints;
    private IList`1<RefinedPoint> filteredPoints;
    private string otherArgument;
    private bool showOthers;
    public IList`1<RefinedPoint> FilteredPoints { get; }
    public IList`1<RefinedPoint> OthersPoints { get; }
    public IList`1<RefinedPoint> get_FilteredPoints();
    public IList`1<RefinedPoint> get_OthersPoints();
    public void Calculate(IList`1<RefinedPoint> initialPoints, double valueThreshold, string otherArgument, bool showOthers);
    protected abstract virtual IList`1<RefinedPoint> FilterPoints(IList`1<RefinedPoint> initialPoints, double valueThreshold);
    protected double GetValue(RefinedPoint point);
    protected void AddToOthersPoints(RefinedPoint point);
    protected bool IsRefinedPointArgumentOthers(RefinedPoint point);
}
public class DevExpress.Charts.Native.ValueTimeSpanDataMemberContainer : ComparableDataMemberContainer`1<TimeSpan> {
    protected TimeSpan DefaultValue { get; }
    public ValueTimeSpanDataMemberContainer(string dataMember, bool supportEmptyValue);
    protected virtual TimeSpan get_DefaultValue();
    protected virtual bool IsCompatibleType(Type type);
    protected virtual bool IsEmptyValue(TimeSpan value);
    protected virtual TimeSpan ConvertValue(object value);
    protected virtual TimeSpan ParseValue(object value);
}
public class DevExpress.Charts.Native.ValueToStringConverter : object {
    private INumericOptions numericOptions;
    private IDateTimeOptions dateTimeOptions;
    protected INumericOptions NumericOptions { get; }
    public ValueToStringConverter(INumericOptions numericOptions, IDateTimeOptions dateTimeOptions);
    protected INumericOptions get_NumericOptions();
    protected string GetValueText(object value);
    protected virtual object GetValue(Object[] values);
    public virtual string ConvertTo(Object[] values);
}
public class DevExpress.Charts.Native.VerticalLayoutCalculatorHelper : LayoutCalculatorHelper {
    public virtual int GetStartValue(DXRectangle bounds);
    public virtual int GetEndValue(DXRectangle bounds);
    public virtual int GetLength(DXRectangle bounds);
    public virtual int GetLeft(DXRectangle bounds);
    public virtual int GetRight(DXRectangle bounds);
    public virtual DXRectangle CreateNewBounds(DXRectangle oldBounds, int start, int length);
    public virtual int GetFixedSize(GridLayoutItem item);
    public virtual bool IsFixed(GridLayoutItem item);
    public virtual IList`1<ILinearLayoutItem> GetPrimaryDefinitionCollection(IGridLayoutOptions options);
    public virtual IList`1<ILinearLayoutItem> GetPrimaryDefinitionCollection(IList`1<ILinearLayoutItem> rowDefinitions, IList`1<ILinearLayoutItem> columnDefinitions);
    public virtual IList`1<ILinearLayoutItem> GetSecondaryDefinitionCollection(IGridLayoutOptions options);
    public virtual int GetPrimaryGridIndex(IGridLayoutItem options);
    public virtual int GetSecondaryGridIndex(IGridLayoutItem options);
    public virtual int GetPrimaryGridSpan(IGridLayoutItem options);
    public virtual int GetSecondaryGridSpan(IGridLayoutItem options);
    public virtual int GetVerticalValue(int primaryValue, int secondaryValue);
    public virtual int GetHorizontalValue(int primaryValue, int secondaryValue);
}
public abstract class DevExpress.Charts.Native.VerticalStep : Step {
    private int startColumnIndex;
    protected int StartColumnIndex { get; }
    protected VerticalStep(int position, int startColumnIndex, DXRectangle rect, RectanglesLayout layout);
    protected int get_StartColumnIndex();
    protected abstract virtual DXPoint CalcNearPosition(Cell cell);
    protected abstract virtual void CalcFarPositions(Cell cell, DXPoint& point1, DXPoint& point2);
    protected virtual void UpdatePrimaryTestPositions();
    protected virtual void UpdateSecondaryTestPositions();
}
public abstract class DevExpress.Charts.Native.ViewportIntersectionHolder : object {
    private List`1<GRealPoint2D> viewportIntersectionsLeft;
    private List`1<GRealPoint2D> viewportIntersectionsRight;
    [CompilerGeneratedAttribute]
private IXYSeriesView <View>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<int, int, bool> <ContinueCycle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Step>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinViewportIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxViewportIndex>k__BackingField;
    protected IXYSeriesView View { get; }
    protected IAxisRangeData RangeX { get; }
    protected IAxisRangeData RangeY { get; }
    protected Func`3<int, int, bool> ContinueCycle { get; private set; }
    protected int Step { get; private set; }
    protected int MinViewportIndex { get; protected set; }
    protected int MaxViewportIndex { get; protected set; }
    protected List`1<GRealPoint2D> ViewportIntersectionsLeft { get; }
    protected List`1<GRealPoint2D> ViewportIntersectionsRight { get; }
    public ViewportIntersectionHolder(IXYSeriesView view);
    [CompilerGeneratedAttribute]
protected IXYSeriesView get_View();
    protected IAxisRangeData get_RangeX();
    protected IAxisRangeData get_RangeY();
    [CompilerGeneratedAttribute]
protected Func`3<int, int, bool> get_ContinueCycle();
    [CompilerGeneratedAttribute]
private void set_ContinueCycle(Func`3<int, int, bool> value);
    [CompilerGeneratedAttribute]
protected int get_Step();
    [CompilerGeneratedAttribute]
private void set_Step(int value);
    [CompilerGeneratedAttribute]
protected int get_MinViewportIndex();
    [CompilerGeneratedAttribute]
protected void set_MinViewportIndex(int value);
    [CompilerGeneratedAttribute]
protected int get_MaxViewportIndex();
    [CompilerGeneratedAttribute]
protected void set_MaxViewportIndex(int value);
    protected List`1<GRealPoint2D> get_ViewportIntersectionsLeft();
    protected List`1<GRealPoint2D> get_ViewportIntersectionsRight();
    private bool IsIntersectionInViewport(List`1<GRealPoint2D> pointsOfIntersection, IAxisRangeData range, double intersectionCoord, double rangeCoord, bool isXIntersection);
    private double CalculateIntersection(double x, double y, double x1, double y1, double limit, bool isYIntersection);
    private double CalculateIntersection(double coord11, double coord12, double coord21, double coord22, double coord);
    protected bool CollectViewportIntersectionByCoordinates(List`1<GRealPoint2D> pointsOfIntersection, double x, double y, double x1, double y1);
    protected bool CollectViewportIntersectionByCoordinates(List`1<GRealPoint2D> pointsOfIntersection, double x, double y, double x1, double y1, Func`3<double, bool, double> calculateIntersection);
    protected virtual int CollectViewportIntersection(List`1<GRealPoint2D> pointsOfIntersection, IList`1<RefinedPoint> points, int firstIndex, int lastIndex, bool isLeftIntersection, Action`1<int> setIndex);
    protected virtual double GetPointValue(RefinedPoint point);
    protected virtual void AddPoints(RefinedPoint point, List`1<GRealPoint2D> pointsOfIntersection, double y, double x);
    protected virtual bool CollectViewportIntersectionCore(List`1<GRealPoint2D> pointsOfIntersection, IList`1<RefinedPoint> points, bool isLeftIntersection, int i, double y, double x);
    protected virtual bool IsArgumentInRange(MinMaxValues pointRangeX);
    protected virtual bool IsValueInRange(RefinedPoint point, double y);
    protected virtual Func`3<int, int, bool> CreateContinueCycle(bool isLeftIntersection);
    public int CalculateEdgePointIndexInViewport(IList`1<RefinedPoint> points, int minVisiblePointIndex, int maxVisiblePointIndex, bool isLeftIntersection);
    public GRealPoint2D GetEdgePoint(double pointArgument, double pointValue, bool isValue1);
    public GRealPoint2D GetEdgePointOnDiagram(double pointArgument, double pointValue, bool isValue1);
    public List`1<GRealPoint2D> GetViewportEdgePoints(int index, bool isLeft);
    public virtual List`1<GRealPoint2D> CorrectValuesByViewport(double pointArgument, double zeroValue, double pointValue, bool alwaysOnDiagramEdge);
    [CompilerGeneratedAttribute]
private void <CalculateEdgePointIndexInViewport>b__42_0(int index);
    [CompilerGeneratedAttribute]
private void <CalculateEdgePointIndexInViewport>b__42_1(int index);
}
public class DevExpress.Charts.Native.VisibilityCalculator : object {
    private GRealSize2D minimumSize;
    private VisibilityLayerKeyComparer visibilityLayerKeyComparer;
    public VisibilityCalculator(GRealSize2D minimumSize);
    private static bool IsValidSize(double newSize, double size, double minimumSize);
    internal static GRealSize2D DecreaseSizeByWidth(GRealSize2D initialSize, GRealSize2D size);
    internal static GRealSize2D DecreaseSizeByHeight(GRealSize2D initialSize, GRealSize2D size);
    internal static GRealSize2D DecreaseSizeByWidthAndHeight(GRealSize2D initialSize, GRealSize2D size);
    internal static GRealSize2D DecreaseSizeProportional(GRealSize2D initialSize, GRealSize2D size);
    private void ApplyVisibility(Dictionary`2<ISupportVisibilityControlElement, bool> elementsVisibility);
    private void SetVisibility(List`1<Boolean[]> visibility, int index, bool value);
    private bool IsValidSize(GRealSize2D initialLayoutSize, GRealSize2D layoutSize, GRealSize2D newLayoutSize);
    private Boolean[] CreateVisibilityMask(int count);
    private List`1<ISupportVisibilityControlElement> GetChangedElements(Dictionary`2<ISupportVisibilityControlElement, bool> elementsVisibility);
    private SortedList`2<VisibilityLayerKey, List`1<ISupportVisibilityControlElement>> GetLayers(List`1<ISupportVisibilityControlElement> elements);
    private GRealSize2D CalculateVisibility(GRealSize2D layoutSize, List`1<ISupportVisibilityControlElement> elements, List`1<Boolean[]> visibility);
    private GRealSize2D DecreaseLayoutSize(GRealSize2D layoutSize, GRealRect2D elementBounds, VisibilityElementOrientation elementOrientation);
    public List`1<ISupportVisibilityControlElement> CalculateLayout(List`1<ISupportVisibilityControlElement> chartElements, List`1<VisibilityLayoutRegion> regions);
    private void StoreVisibility(Dictionary`2<object, bool> startVisibility, List`1<ISupportVisibilityControlElement> list);
    private void StoreVisibility(Dictionary`2<ISupportVisibilityControlElement, bool> visibilityElements, List`1<ISupportVisibilityControlElement> list, Boolean[] visibility);
}
public enum DevExpress.Charts.Native.VisibilityElementOrientation : Enum {
    public int value__;
    public static VisibilityElementOrientation Horizontal;
    public static VisibilityElementOrientation Vertical;
    public static VisibilityElementOrientation Corner;
    public static VisibilityElementOrientation Inside;
}
public class DevExpress.Charts.Native.VisibilityLayoutRegion : object {
    private List`1<ISupportVisibilityControlElement> elements;
    private List`1<ISupportVisibilityControlElement> elementsToRemove;
    private GRealSize2D size;
    public List`1<ISupportVisibilityControlElement> Elements { get; }
    public List`1<ISupportVisibilityControlElement> ElementsToRemove { get; }
    public GRealSize2D Size { get; }
    public VisibilityLayoutRegion(GRealSize2D size, List`1<ISupportVisibilityControlElement> elements);
    public VisibilityLayoutRegion(GRealSize2D size, List`1<ISupportVisibilityControlElement> elements, List`1<ISupportVisibilityControlElement> elementsToRemove);
    public List`1<ISupportVisibilityControlElement> get_Elements();
    public List`1<ISupportVisibilityControlElement> get_ElementsToRemove();
    public GRealSize2D get_Size();
}
public enum DevExpress.Charts.Native.VisualRangeUpdateMode : Enum {
    public int value__;
    public static VisualRangeUpdateMode Default;
    public static VisualRangeUpdateMode ProportionalFromWholeRange;
}
public class DevExpress.Charts.Native.WaterfallAbsolutePointInteraction : WaterfallPointInteraction {
    public WaterfallAbsolutePointInteraction(List`1<RefinedSeries> series, int seriesIndex, RefinedPoint point);
    protected virtual double GetPointValue(int pointIndex);
    protected virtual double CalcPrevInteractionValue(WaterfallPointInteraction prevInteraction, int index);
    public virtual double GetRelativeValue(int pointIndex);
    public virtual double GetAbsoluteValue(int pointIndex);
}
public class DevExpress.Charts.Native.WaterfallFilter : PointsFilter {
    private IPointProcessorProvider processorProvider;
    private WaterfallFilterBehavior filterBehavior;
    private List`1<RefinedPoint> cache;
    private IWaterfallSeriesView WaterfallSeriesView { get; }
    public WaterfallFilter(RefinedSeries refinedSeries, IPointProcessorProvider pointsProcessor);
    private IWaterfallSeriesView get_WaterfallSeriesView();
    protected virtual IList`1<RefinedPoint> Recalculate(IList`1<RefinedPoint> initialPoints);
    protected virtual IList`1<RefinedPoint> GetCachedPoints();
    public virtual void ClearCache();
    public virtual bool Update();
    public virtual PointsFilterUpdateInfo Update(PointsFilterUpdateInfo updateInfo);
}
public class DevExpress.Charts.Native.WaterfallFilterBehavior : object {
    [CompilerGeneratedAttribute]
private RefinedSeries <RefinedSeries>k__BackingField;
    [CompilerGeneratedAttribute]
private IWaterfallSeriesView <WaterfallSeriesView>k__BackingField;
    protected RefinedSeries RefinedSeries { get; private set; }
    protected IWaterfallSeriesView WaterfallSeriesView { get; private set; }
    public WaterfallFilterBehavior(RefinedSeries refinedSeries);
    [CompilerGeneratedAttribute]
protected RefinedSeries get_RefinedSeries();
    [CompilerGeneratedAttribute]
private void set_RefinedSeries(RefinedSeries value);
    [CompilerGeneratedAttribute]
protected IWaterfallSeriesView get_WaterfallSeriesView();
    [CompilerGeneratedAttribute]
private void set_WaterfallSeriesView(IWaterfallSeriesView value);
    private void AddSubtotalPoint(string argument, Func`2<List`1<RefinedPoint>, double> calcVale, int index, WaterfallPointTypeCore pointType, List`1<RefinedPoint> cache, IPointProcessor pointProcessor);
    public virtual void ApplySubtotals(IList`1<RefinedPoint> initialPoints, IWaterfallValueOptions valueOptions, List`1<RefinedPoint> cache, IPointProcessor pointProcessor);
}
public class DevExpress.Charts.Native.WaterfallInteractionContainer : StackedInteractionContainer {
    private List`1<RefinedPoint> subTotalPoints;
    private bool needUpdatePrevInteractions;
    protected bool ShouldUpdateOnChangePoint { get; }
    public WaterfallInteractionContainer(ISeriesView view);
    protected virtual bool get_ShouldUpdateOnChangePoint();
    private void UpdateSubtotalPoints();
    protected virtual void Invalidate();
    protected virtual StackedPointInteraction CreatePointInteraction(int seriesIndex, RefinedPoint point);
    public virtual void EnsureInteractions();
}
public abstract class DevExpress.Charts.Native.WaterfallPointInteraction : StackedPointInteraction {
    [CompilerGeneratedAttribute]
private bool <HasOnlyEmptyPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSubtotal>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <PrevInteractionValues>k__BackingField;
    private double AnchorValue { get; }
    public bool HasOnlyEmptyPoints { get; private set; }
    public bool IsSubtotal { get; }
    public Double[] PrevInteractionValues { get; public set; }
    public bool ShouldConsiderValue { get; }
    public WaterfallPointInteraction(List`1<RefinedSeries> series, int seriesIndex, RefinedPoint point);
    private double get_AnchorValue();
    [CompilerGeneratedAttribute]
public bool get_HasOnlyEmptyPoints();
    [CompilerGeneratedAttribute]
private void set_HasOnlyEmptyPoints(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSubtotal();
    [CompilerGeneratedAttribute]
public Double[] get_PrevInteractionValues();
    [CompilerGeneratedAttribute]
public void set_PrevInteractionValues(Double[] value);
    public virtual bool get_ShouldConsiderValue();
    private int FindFirstExistPontIndex();
    protected abstract virtual double CalcPrevInteractionValue(WaterfallPointInteraction prevInteraction, int index);
    protected virtual double GetAnchorValue();
    protected virtual double GetPointValue(int pointIndex);
    protected virtual void InsertInPointsCollection(int index, RefinedPoint point);
    protected void UpdatePrevValuesCore(WaterfallPointInteraction prevInteraction);
    public double GetTotalValue();
    public virtual void UpdatePrevValues(WaterfallPointInteraction prevInteraction);
    public double GetPointAnchorValue(int pointIndex);
    public abstract virtual double GetRelativeValue(int pointIndex);
    public abstract virtual double GetAbsoluteValue(int pointIndex);
}
public class DevExpress.Charts.Native.WaterfallPointPatternDataProvider : PointPatternDataProvider {
    public WaterfallPointPatternDataProvider(string patternConstant, AxisScaleTypeMap axisScaleTypeMap);
    protected virtual object GetValueFormSeriesPoint();
    protected virtual object GetValueFromRefinedPoint();
}
public enum DevExpress.Charts.Native.WaterfallPointTypeCore : Enum {
    public int value__;
    public static WaterfallPointTypeCore Start;
    public static WaterfallPointTypeCore Subtotal;
    public static WaterfallPointTypeCore Total;
}
public class DevExpress.Charts.Native.WaterfallRelativePointInteraction : WaterfallPointInteraction {
    public WaterfallRelativePointInteraction(List`1<RefinedSeries> series, int seriesIndex, RefinedPoint point);
    protected virtual double CalcPrevInteractionValue(WaterfallPointInteraction prevInteraction, int index);
    public virtual double GetRelativeValue(int pointIndex);
    public virtual double GetAbsoluteValue(int pointIndex);
}
public class DevExpress.Charts.Native.WaterfallXCelPointInteraction : WaterfallRelativePointInteraction {
    public bool ShouldConsiderValue { get; }
    public WaterfallXCelPointInteraction(List`1<RefinedSeries> series, int seriesIndex, RefinedPoint point);
    public virtual bool get_ShouldConsiderValue();
    public virtual void UpdatePrevValues(WaterfallPointInteraction prevInteraction);
}
public class DevExpress.Charts.Native.WavedEdgeGeometry : EdgeGeometry {
    private static int stepCountByWave;
    private static int minStepLength;
    private static int minWaveLength;
    private static double angleStep;
    public static int CrosswiseStep;
    public WavedEdgeGeometry(bool shouldCutEdge);
    protected virtual IList`1<GRealPoint2D> CreateGraphicsPath(double startX, double startY, double length, bool vertical);
}
[FlagsAttribute]
public enum DevExpress.Charts.Native.WeekdayCore : Enum {
    public int value__;
    public static WeekdayCore None;
    public static WeekdayCore Sunday;
    public static WeekdayCore Monday;
    public static WeekdayCore Tuesday;
    public static WeekdayCore Wednesday;
    public static WeekdayCore Thursday;
    public static WeekdayCore Friday;
    public static WeekdayCore Saturday;
}
public class DevExpress.Charts.Native.WeightedCloseCalculator : object {
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    public bool Calculated { get; private set; }
    public static bool IsCompatible(ISeriesView view);
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    private bool IsParameterCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points);
}
public class DevExpress.Charts.Native.WeightedMovingAverageCalculator : MovingAverageCalculator {
    public virtual void UpdateMovingAverageData(IList`1<RefinedPoint> refinedPoints, int startUpdateIndex, int pointsCount, ValueLevelInternal valueLevel, IIndicatorValueProvider valueProvider);
}
public class DevExpress.Charts.Native.WilliamsRCalculator : object {
    private static int DesignTimePointsCount;
    private static double MeanValue;
    [CompilerGeneratedAttribute]
private bool <Calculated>k__BackingField;
    [CompilerGeneratedAttribute]
private MinMaxValues <YRange>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<GRealPoint2D> <IndicatorPoints>k__BackingField;
    public bool Calculated { get; private set; }
    public MinMaxValues YRange { get; private set; }
    public List`1<GRealPoint2D> IndicatorPoints { get; private set; }
    public static bool IsCompatible(ISeriesView view);
    [CompilerGeneratedAttribute]
public bool get_Calculated();
    [CompilerGeneratedAttribute]
private void set_Calculated(bool value);
    [CompilerGeneratedAttribute]
public MinMaxValues get_YRange();
    [CompilerGeneratedAttribute]
private void set_YRange(MinMaxValues value);
    [CompilerGeneratedAttribute]
public List`1<GRealPoint2D> get_IndicatorPoints();
    [CompilerGeneratedAttribute]
private void set_IndicatorPoints(List`1<GRealPoint2D> value);
    private void FindMinMax(IList`1<RefinedPoint> refinedPoints, int currentIndex, int usingPointsCount, Double& maxHigh, Double& minLow);
    private void FindMinMax(Double[] highValues, Double[] lowValues, Double& maxHigh, Double& minLow);
    private bool IsParametersCorrect(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointsCount);
    public LineStrip Calculate(IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointCount);
    public void UpdateIndicatorData(int startUpdateIndex, IRefinedSeries refinedSeries, IList`1<RefinedPoint> points, int pointCount);
}
public class DevExpress.Charts.Native.WorkPeriodsPointsFilter : PointsFilter {
    private List`1<DateTime> holidays;
    private List`1<DateTime> exactWorkdays;
    private WeekdayCore workdays;
    private SortedArgumentRefinedPointCollection filteredPoints;
    private WorkTimeRuleSetCore workTimeRuleSet;
    public WorkPeriodsPointsFilter(RefinedSeries refinedSeries);
    private static int GetPointIndex(SortedArgumentRefinedPointCollection points, double argument, bool isFirst);
    private static int GetInitialPointIndex(PointsFilterUpdateInfo updateInfo, double argument);
    private bool IsEnabled(IAxisData axisData);
    private bool IsHoliday(DateTime dateTime);
    private bool InExcludedTimeInterval(DateTime dateTime);
    private IWorkdaysOptions GetWorkdaysOptions(IAxisData axisData);
    private IWorkTimeRuleCollection GetWorkTimeRules(IAxisData axisData);
    private SortedArgumentRefinedPointCollection FilterPoints(SortedArgumentRefinedPointCollection initialPoints);
    protected virtual IList`1<RefinedPoint> Recalculate(IList`1<RefinedPoint> initialPoints);
    protected virtual IList`1<RefinedPoint> GetCachedPoints();
    public virtual bool Update();
    public virtual PointsFilterUpdateInfo Update(PointsFilterUpdateInfo updateInfo);
    public virtual void ClearCache();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Charts.Native.WorkTimeRuleSetCore : object {
    private TimeIntervalSetCore genericRestIntervals;
    private SortedList`2<DayOfWeek, TimeIntervalSetCore> byDayOfWeekRestIntervalSets;
    private SortedList`2<DateTime, TimeIntervalSetCore> byDateRestIntervalSets;
    private bool workTimeOnly;
    private bool wholeTimeExcluded;
    private WeekdayCore genericIntervalsNotAppliedTo;
    public bool WholeTimeExcluded { get; }
    public bool Enabled { get; }
    public TimeIntervalSetCore Item { get; }
    public TimeIntervalSetCore Item { get; }
    public bool HasCustomDate { get; }
    public IEnumerable`1<KeyValuePair`2<DateTime, TimeIntervalSetCore>> SortedByDateRestIntervalsForCustomDates { get; }
    public WorkTimeRuleSetCore(IWorkTimeRuleCollection workTimeRules, IWorkdaysOptions workdaysOptions);
    public static bool op_Equality(WorkTimeRuleSetCore wtrs1, WorkTimeRuleSetCore wtrs2);
    public static bool op_Inequality(WorkTimeRuleSetCore wtrs1, WorkTimeRuleSetCore wtrs2);
    public bool get_WholeTimeExcluded();
    public bool get_Enabled();
    public TimeIntervalSetCore get_Item(DayOfWeek day);
    public TimeIntervalSetCore get_Item(DateTime dateTime);
    public bool get_HasCustomDate();
    [IteratorStateMachineAttribute("DevExpress.Charts.Native.WorkTimeRuleSetCore/<get_SortedByDateRestIntervalsForCustomDates>d__20")]
public IEnumerable`1<KeyValuePair`2<DateTime, TimeIntervalSetCore>> get_SortedByDateRestIntervalsForCustomDates();
    private void SetRule(IWorkTimeRule rule);
    private bool IsEmpty(IWorkTimeRule rule);
    private bool CollectionEquals(SortedList`2<TKey, TimeIntervalSetCore> timeIntervalSets1, SortedList`2<TKey, TimeIntervalSetCore> timeIntervalSets2);
    private bool IsWholeTimeExcluded();
    public bool CustomDateExists(DateTime dateTime);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Charts.Native.XCelWaterfallFilterBehavior : WaterfallFilterBehavior {
    public XCelWaterfallFilterBehavior(RefinedSeries refinedSeries);
    public virtual void ApplySubtotals(IList`1<RefinedPoint> initialPoints, IWaterfallValueOptions valueOptions, List`1<RefinedPoint> cache, IPointProcessor pointProcessor);
}
public static class DevExpress.Charts.Native.XtraSerializingUtils : object {
    private static string typeNamePropertyName;
    public static object GetKnownContentPropertyInstance(XtraPropertyInfo propertyInfo, Assembly sourceAssembly, string typeNamespace);
    public static object GetKnownContentPropertyInstance(XtraItemEventArgs e, Assembly sourceAssembly, string typeNamespace);
}
public class DevExpress.Charts.Native.XYDiagramPaneArea : object {
    private RaggedEdgeGeometry raggedGeometry;
    private WavedEdgeGeometry wavedGeometry;
    private PaneAreaSide leftSide;
    private PaneAreaSide topSide;
    private PaneAreaSide rightSide;
    private PaneAreaSide bottomSide;
    private GRealRect2D bounds;
    private IList`1<GRealPoint2D> leftPath;
    private IList`1<GRealPoint2D> topPath;
    private IList`1<GRealPoint2D> rightPath;
    private IList`1<GRealPoint2D> bottomPath;
    private IList`1<GRealPoint2D> border;
    public PaneAreaSide LeftSide { get; }
    public PaneAreaSide TopSide { get; }
    public PaneAreaSide RightSide { get; }
    public PaneAreaSide BottomSide { get; }
    public IList`1<GRealPoint2D> LeftPath { get; }
    public IList`1<GRealPoint2D> TopPath { get; }
    public IList`1<GRealPoint2D> RightPath { get; }
    public IList`1<GRealPoint2D> BottomPath { get; }
    public GRealRect2D Bounds { get; }
    public IList`1<GRealPoint2D> Border { get; }
    public XYDiagramPaneArea(RaggedEdgeGeometry raggedGeometry, WavedEdgeGeometry wavedGeometry, GRealRect2D bounds);
    public XYDiagramPaneArea(RaggedEdgeGeometry raggedGeometry, WavedEdgeGeometry wavedGeometry, GRealRect2D bounds, PaneAreaSide leftSide, PaneAreaSide topSide, PaneAreaSide rightSide, PaneAreaSide bottomSide);
    private static PaneAreaSide GetIntersectedSide(double intersectedBound, double bound1, double bound2, PaneAreaSide side1, PaneAreaSide side2);
    public static XYDiagramPaneArea Intersect(XYDiagramPaneArea paneArea1, XYDiagramPaneArea paneArea2);
    public PaneAreaSide get_LeftSide();
    public PaneAreaSide get_TopSide();
    public PaneAreaSide get_RightSide();
    public PaneAreaSide get_BottomSide();
    public IList`1<GRealPoint2D> get_LeftPath();
    public IList`1<GRealPoint2D> get_TopPath();
    public IList`1<GRealPoint2D> get_RightPath();
    public IList`1<GRealPoint2D> get_BottomPath();
    public GRealRect2D get_Bounds();
    public IList`1<GRealPoint2D> get_Border();
    public void Complete();
    private EdgeGeometry GetEdgeGeometryByScaleBreakStyle(IScaleBreakOptions options);
    private IList`1<GRealPoint2D> CreateBorder();
}
public class DevExpress.Charts.Native.XYDiagramPaneAreaGenerator : object {
    private RaggedEdgeGeometry raggedGeometry;
    private WavedEdgeGeometry wavedGeometry;
    private IScaleBreakOptions scaleBreakOptions;
    private IAxisData axis;
    private IList`1<GRealRect2D> intervalsBounds;
    private XYDiagramPaneAreaGenerator(RaggedEdgeGeometry raggedGeometry, WavedEdgeGeometry wavedGeometry, IScaleBreakOptions scaleBreakOptions, IAxisData axis, IList`1<GRealRect2D> intervalsBounds);
    public static List`1<XYDiagramPaneArea> GenerateAreas(RaggedEdgeGeometry raggedGeometry, WavedEdgeGeometry wavedGeometry, IAxisData axis, IScaleBreakOptions scaleBreakOptions, IList`1<GRealRect2D> intervalsBounds);
    public static DirectionCore CalculateAxisDirection(IAxisData axis);
    private List`1<XYDiagramPaneArea> GenerateAreas();
    private void GenerateAreasLeftToRight(List`1<XYDiagramPaneArea> paneAreas);
    private void GenerateAreasRightToLeft(List`1<XYDiagramPaneArea> paneAreas);
    private void GenerateAreasTopToBottom(List`1<XYDiagramPaneArea> paneAreas);
    private void GenerateAreasBottomToTop(List`1<XYDiagramPaneArea> paneAreas);
    private static bool IsFirstInterval(int intervalIndex);
    private bool IsLastInterval(int intervalIndex);
    private PaneAreaSide CreateInnerSide();
    private XYDiagramPaneArea CreateVerticalArea(GRealRect2D bounds);
    private XYDiagramPaneArea CreateHorizontalArea(GRealRect2D bounds);
    private XYDiagramPaneArea CreateLeftArea(GRealRect2D bounds);
    private XYDiagramPaneArea CreateRightArea(GRealRect2D bounds);
    private XYDiagramPaneArea CreateTopArea(GRealRect2D bounds);
    private XYDiagramPaneArea CreateBottomArea(GRealRect2D bounds);
}
public class DevExpress.Charts.Native.XYDiagramResolveOverlappingAlgorithm : object {
    private List`1<IXYDiagramLabelLayout> actualLabels;
    private RectanglesLayoutAlgorithm layoutAlgorithm;
    private XYDiagramResolveOverlappingAlgorithm(IEnumerable`1<IXYDiagramLabelLayout> labels, DXRectangle bounds, int overlappingIndent);
    private static bool OldContains(DXPoint point, DXRectangle rect);
    private static bool IsVisible(IXYDiagramLabelLayout label, DXPoint point);
    public static void Process(IEnumerable`1<IXYDiagramLabelLayout> labels, DXRectangle bounds, int overlappingIndent);
    private void Process();
    private void Arrange(IXYDiagramLabelLayout label);
}
public class DevExpress.Charts.Native.XYSeriesContainer : SingleSeriesContainer {
    private double min;
    private double max;
    private double absMin;
    private bool needRecalculate;
    private bool needRecalculateAbsMin;
    private RefinedSeries actualSeries;
    private int suspendUpdateCounter;
    private IList`1<RefinedPoint> Interactions { get; }
    protected RefinedSeries ActualSeries { get; protected set; }
    public double Max { get; }
    public double Min { get; }
    public IList`1<IPointInteraction> PointInteractions { get; }
    public XYSeriesContainer(ISeriesView view);
    private IList`1<RefinedPoint> get_Interactions();
    protected RefinedSeries get_ActualSeries();
    protected void set_ActualSeries(RefinedSeries value);
    public sealed virtual double get_Max();
    public sealed virtual double get_Min();
    public virtual IList`1<IPointInteraction> get_PointInteractions();
    private void Calculate();
    private void CalculateAbsMin();
    protected virtual void InsertRefinedPoints(int seriesIndex, RefinedSeries series);
    protected virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries series, bool removeAll);
    protected virtual void SuspendUpdate();
    protected virtual void ResumeUpdate();
    protected virtual void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    public sealed virtual double GetAbsMinValue();
}
internal class DevExpress.Charts.Native.XYSeriesViewPropertyUpdateProcessor : TypedUpdateProcessor`2<PropertyUpdateInfo`1<IAxisData>, ISeriesView> {
    private bool IsQualitativeScaleType(IAxisData axis);
    protected virtual IList`1<IUpdateAction> TypedProcess(PropertyUpdateInfo`1<IAxisData> updateInfo, ISeriesView sender);
}
public class DevExpress.Charts.Native.XYWPointInteraction : BasePointInteraction {
    private RefinedPointsWeightComparer weightComparer;
    private RefinedPointsValueComparer valueComparer;
    private List`1<RefinedPoint> pointsByWeights;
    private List`1<RefinedPoint> pointsByValues;
    private IXYWSeriesView view;
    private bool isUpdateLocked;
    public double MinWeight { get; }
    public double MaxWeight { get; }
    public int Count { get; }
    public XYWPointInteraction(IXYWSeriesView view);
    public double get_MinWeight();
    public double get_MaxWeight();
    public virtual int get_Count();
    public void AddPoint(RefinedPoint point);
    public void RemovePoint(RefinedPoint point);
    public void Clear();
    public double GetXYWPointSize(IXYWPoint point);
    public virtual double GetMinValue(ISeriesView seriesView);
    public virtual double GetMaxValue(ISeriesView seriesView);
    public virtual double GetMinAbsValue(ISeriesView seriesView);
    public void Lock();
    public void Unlock();
}
public class DevExpress.Charts.Native.XYWRefinedPointFinder : RefinedPointFinder {
    protected IXYWSeriesView SeriesView { get; }
    public XYWRefinedPointFinder(RefinedSeries refinedSeries);
    protected IXYWSeriesView get_SeriesView();
    protected virtual bool AddEqualArgPoint(RefinedPoint point, int indexInCollection, double nearestPointArgument, double argument, List`1<PointArgumentDistance> result, double markerWidth);
    protected virtual bool IsValueInPointRange(double value, RefinedPoint point, double xRange, double yRange);
    protected virtual double CalculateDistance(PointArgumentDistance argumentDistance, double value, double xRange, double yRange);
}
public class DevExpress.Charts.Native.XYWSeriesContainer : SingleSeriesContainer {
    private XYWPointInteraction interaction;
    public double Max { get; }
    public double Min { get; }
    public IList`1<IPointInteraction> PointInteractions { get; }
    public XYWSeriesContainer(ISeriesView view);
    public sealed virtual double get_Max();
    public sealed virtual double get_Min();
    public virtual IList`1<IPointInteraction> get_PointInteractions();
    protected virtual void InsertRefinedPoints(int seriesIndex, RefinedSeries refinedSeries);
    protected virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries refinedSeries, bool removeAll);
    protected virtual void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    public sealed virtual double GetAbsMinValue();
}
public class DevExpress.Charts.Native.XYZBarSeriesContainer : XYSeriesContainer {
    private IXYZBarSeriesView barView;
    private ArgumentCollectionContainer sortedArgumentsX;
    private ArgumentCollectionContainer sortedArgumentsY;
    public XYZBarSeriesContainer(IXYZBarSeriesView barView, ISeriesView view);
    protected virtual void InsertRefinedPoints(int seriesIndex, RefinedSeries series);
    protected virtual void RemoveRefinedPoints(int seriesIndex, RefinedSeries series, bool removeAll);
    protected virtual void InsertRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    protected virtual void RemoveRefinedPoint(RefinedSeries refinedSeries, RefinedPoint point);
    internal virtual void ApplySeriesViewData();
}
public class DevExpress.Charts.Native.XYZPatternDataProvider : PointPatternDataProvider {
    private string patternConstant;
    private XYZPointProjections PointProjections { get; }
    public XYZPatternDataProvider(string patternConstant, AxisScaleTypeMap axisScaleTypeMap);
    private XYZPointProjections get_PointProjections();
    private object GetValueFormPointProjections();
    protected virtual bool TryGetValue(Object& value);
    public virtual bool CheckContext(object value);
}
public class DevExpress.Charts.Native.XYZPointProjections : object {
    private PointProjectionOnAxis axesXValue;
    private PointProjectionOnAxis axesYValue;
    private PointProjectionOnAxis axesZValue;
    public PointProjectionOnAxis AxesXValue { get; }
    public PointProjectionOnAxis AxesYValue { get; }
    public PointProjectionOnAxis AxesZValue { get; }
    public PointProjectionOnAxis get_AxesXValue();
    public PointProjectionOnAxis get_AxesYValue();
    public PointProjectionOnAxis get_AxesZValue();
    private PointProjectionOnAxis CreatePointProjection(IAxisData axis, double internalValue);
    public void AddAxisXValue(IAxisData axis, double internalArgument);
    public void AddAxisZValue(IAxisData axis, double internalArgument);
    public void AddAxisYValue(IAxisData axis, double internalValue);
}
public enum DevExpress.Charts.Native.ZoomingKind : Enum {
    public int value__;
    public static ZoomingKind None;
    public static ZoomingKind MouseWheel;
    public static ZoomingKind Keyboard;
    public static ZoomingKind ZoomIn;
    public static ZoomingKind ZoomOut;
    public static ZoomingKind SetRange;
    public static ZoomingKind ZoomPosition;
    public static ZoomingKind Gesture;
}
public class DevExpress.Charts.Native.ZoomItem : object {
    private PaneAxesManager paneAxesManager;
    private RangesSnapshot rangeSnapshot;
    internal PaneAxesManager PaneAxesManager { get; }
    public ZoomItem(IAxisData axisX, IAxisData axisY, PaneAxesManager paneAxesData);
    internal PaneAxesManager get_PaneAxesManager();
    public void RestoreCachedValues();
}
public class DevExpress.Charts.Native.ZoomStack : object {
    private Stack`1<ZoomItem> stack;
    private ZoomingKind lastZoomingKind;
    public bool IsEmpty { get; }
    public bool get_IsEmpty();
    public void Push(IAxisData axisX, IAxisData axisY, PaneAxesManager paneAxesManager, ZoomingKind zoomingKind);
    public void Pop();
    public void Clear();
}
public interface DevExpress.Charts.Sankey.ISankeyLinkLayoutItem {
    public ISankeyNodeLayoutItem Source { get; }
    public ISankeyNodeLayoutItem Target { get; }
    public double Weight { get; }
    public abstract virtual ISankeyNodeLayoutItem get_Source();
    public abstract virtual ISankeyNodeLayoutItem get_Target();
    public abstract virtual double get_Weight();
}
public interface DevExpress.Charts.Sankey.ISankeyNodeLayoutItem {
    public int LevelIndex { get; public set; }
    public DXRectangle Bounds { get; public set; }
    public double TargetWeight { get; }
    public double SourceWeight { get; }
    public double TotalWeight { get; }
    public object Tag { get; }
    public ReadOnlyCollection`1<ISankeyLinkLayoutItem> OutputLinks { get; }
    public ReadOnlyCollection`1<ISankeyLinkLayoutItem> InputLinks { get; }
    public abstract virtual int get_LevelIndex();
    public abstract virtual void set_LevelIndex(int value);
    public abstract virtual DXRectangle get_Bounds();
    public abstract virtual void set_Bounds(DXRectangle value);
    public abstract virtual double get_TargetWeight();
    public abstract virtual double get_SourceWeight();
    public abstract virtual double get_TotalWeight();
    public abstract virtual object get_Tag();
    public abstract virtual ReadOnlyCollection`1<ISankeyLinkLayoutItem> get_OutputLinks();
    public abstract virtual ReadOnlyCollection`1<ISankeyLinkLayoutItem> get_InputLinks();
}
public class DevExpress.Charts.Sankey.Native.DefaultLayoutCalculator : object {
    public bool Calculate(DXRectangle bounds, ICollection`1<SankeyNodeLayoutInfo> nodes, ISankeyLayoutAlgorithm layoutAlgorithm);
}
public interface DevExpress.Charts.Sankey.Native.INodesCreator`1 {
    public abstract virtual T GetNode(SankeyNodeLayoutInfo info);
}
public interface DevExpress.Charts.Sankey.Native.ISankeyAlignmentCalculator {
    public abstract virtual void CorrectNodeAlignment(List`1<SankeyLayoutLevel> levels, DXRectangle bounds);
}
public interface DevExpress.Charts.Sankey.Native.ISankeyDataSourceProvider {
    public object DataSource { get; }
    public string SourceDataMember { get; }
    public string TargetDataMember { get; }
    public string WeightDataMember { get; }
    public abstract virtual object get_DataSource();
    public abstract virtual string get_SourceDataMember();
    public abstract virtual string get_TargetDataMember();
    public abstract virtual string get_WeightDataMember();
}
public interface DevExpress.Charts.Sankey.Native.ISankeyLayoutAlgorithm {
    public abstract virtual void CalculateNodeBounds(IEnumerable`1<ISankeyNodeLayoutItem> nodes, DXRectangle bounds);
}
public interface DevExpress.Charts.Sankey.Native.ISankeyLayoutOptionsProvider`1 {
    public ISankeyViewOptionsProvider ViewOptions { get; }
    public IComparer`1<T> NodeComparer { get; }
    public ISankeyLayoutAlgorithm LayoutAlgorithm { get; }
    public abstract virtual ISankeyViewOptionsProvider get_ViewOptions();
    public abstract virtual IComparer`1<T> get_NodeComparer();
    public abstract virtual ISankeyLayoutAlgorithm get_LayoutAlgorithm();
}
public interface DevExpress.Charts.Sankey.Native.ISankeyLinearLayoutAlgorithm {
    public bool ResolveOverlapping { get; public set; }
    public Comparison`1<SankeyNodeLayoutInfo> NodeComparison { get; public set; }
    public ISankeyViewOptionsProvider ViewOptions { get; public set; }
    public List`1<SankeyLayoutLevel> Levels { get; }
    public SankeyNodeAlignmentCore NodeAlignment { get; public set; }
    public abstract virtual bool get_ResolveOverlapping();
    public abstract virtual void set_ResolveOverlapping(bool value);
    public abstract virtual Comparison`1<SankeyNodeLayoutInfo> get_NodeComparison();
    public abstract virtual void set_NodeComparison(Comparison`1<SankeyNodeLayoutInfo> value);
    public abstract virtual ISankeyViewOptionsProvider get_ViewOptions();
    public abstract virtual void set_ViewOptions(ISankeyViewOptionsProvider value);
    public abstract virtual List`1<SankeyLayoutLevel> get_Levels();
    public abstract virtual SankeyNodeAlignmentCore get_NodeAlignment();
    public abstract virtual void set_NodeAlignment(SankeyNodeAlignmentCore value);
    public abstract virtual bool CalculateNodeBoundsInternal(IEnumerable`1<ISankeyNodeLayoutItem> nodes, DXRectangle bounds);
}
public interface DevExpress.Charts.Sankey.Native.ISankeyLink {
    public object Source { get; }
    public object Target { get; }
    public double Weight { get; }
    public abstract virtual object get_Source();
    public abstract virtual object get_Target();
    public abstract virtual double get_Weight();
}
public interface DevExpress.Charts.Sankey.Native.ISankeyViewOptionsProvider {
    public int NodeWidth { get; }
    public int VerticalNodeIndent { get; }
    public bool AutoVerticalNodeIndent { get; }
    public abstract virtual int get_NodeWidth();
    public abstract virtual int get_VerticalNodeIndent();
    public abstract virtual bool get_AutoVerticalNodeIndent();
}
public static class DevExpress.Charts.Sankey.Native.LabelLayoutCalculator : object {
    public static DXRectangle CalculateBounds(SankeyLabelAlignmentCore alignment, GRealSize2D textBounds, DXRectangle nodeBounds, int padding, bool isLastNode, bool isVerticalText);
}
public class DevExpress.Charts.Sankey.Native.LinearLayoutCalculator`1 : object {
    private ISankeyLinearLayoutAlgorithm linearLayoutAlgorithm;
    public LinearLayoutCalculator`1(ISankeyLinearLayoutAlgorithm layoutAlgorithm);
    private void InitLinearLayoutAlgorithm(INodesCreator`1<T> nodesCreator, ISankeyLayoutOptionsProvider`1<T> layoutOptions);
    public bool Calculate(DXRectangle bounds, ICollection`1<SankeyNodeLayoutInfo> nodes, INodesCreator`1<T> nodesCreator, ISankeyLayoutOptionsProvider`1<T> layoutOptions);
}
public class DevExpress.Charts.Sankey.Native.LinkPointsCalculator : object {
    private SankeyLinkLayoutInfo info;
    private DXRectangle sBounds;
    private DXRectangle tBounds;
    private int additionalPointXOffset;
    public GRealPoint2D FirstTop { get; }
    public GRealPoint2D SecondTop { get; }
    public GRealPoint2D ThirdTop { get; }
    public GRealPoint2D FourthTop { get; }
    public GRealPoint2D FirstBottom { get; }
    public GRealPoint2D SecondBottom { get; }
    public GRealPoint2D ThirdBottom { get; }
    public GRealPoint2D FourthBottom { get; }
    public LinkPointsCalculator(SankeyLinkLayoutInfo info);
    public GRealPoint2D get_FirstTop();
    public GRealPoint2D get_SecondTop();
    public GRealPoint2D get_ThirdTop();
    public GRealPoint2D get_FourthTop();
    public GRealPoint2D get_FirstBottom();
    public GRealPoint2D get_SecondBottom();
    public GRealPoint2D get_ThirdBottom();
    public GRealPoint2D get_FourthBottom();
}
public class DevExpress.Charts.Sankey.Native.NativeLink : object {
    private object source;
    private object target;
    private double weight;
    private object tag;
    public object Source { get; }
    public object Target { get; }
    public double Weight { get; }
    public object Tag { get; }
    public NativeLink(object source, object target, object tag);
    public NativeLink(object source, object target, double weight, object tag);
    public sealed virtual object get_Source();
    public sealed virtual object get_Target();
    public sealed virtual double get_Weight();
    public object get_Tag();
}
public class DevExpress.Charts.Sankey.Native.SankeyAggregatedLink : object {
    private List`1<ISankeyLink> links;
    private double totalWeight;
    [CompilerGeneratedAttribute]
private object <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Target>k__BackingField;
    public object Source { get; }
    public object Target { get; }
    public IEnumerable`1<ISankeyLink> Links { get; }
    private object DevExpress.Charts.Sankey.Native.ISankeyLink.Source { get; }
    private object DevExpress.Charts.Sankey.Native.ISankeyLink.Target { get; }
    private double DevExpress.Charts.Sankey.Native.ISankeyLink.Weight { get; }
    public SankeyAggregatedLink(object source, object target);
    [CompilerGeneratedAttribute]
public object get_Source();
    [CompilerGeneratedAttribute]
public object get_Target();
    public IEnumerable`1<ISankeyLink> get_Links();
    private sealed virtual override object DevExpress.Charts.Sankey.Native.ISankeyLink.get_Source();
    private sealed virtual override object DevExpress.Charts.Sankey.Native.ISankeyLink.get_Target();
    private sealed virtual override double DevExpress.Charts.Sankey.Native.ISankeyLink.get_Weight();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Tuple<System.Object,System.Object>>.Equals(Tuple`2<object, object> x, Tuple`2<object, object> y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Tuple<System.Object,System.Object>>.GetHashCode(Tuple`2<object, object> obj);
    public void AddLink(ISankeyLink link);
    public void EndUpdate(SumCalculator calculator);
}
public static class DevExpress.Charts.Sankey.Native.SankeyAlignmentToCalculatorConverter : object {
    public static ISankeyAlignmentCalculator Convert(SankeyNodeAlignmentCore nodeAlignment);
}
public class DevExpress.Charts.Sankey.Native.SankeyBindingProcedure : BindingProcedure {
    private ISankeyDataSourceProvider dataProvider;
    public SankeyBindingProcedure(ISankeyDataSourceProvider dataProvider);
    private object GetValue(IDataMemberContainer container);
    private bool TryGetWeightDataMember(RowDataReader dataReader, Double& value);
    private ISankeyLink CreateLink(object source, object target, object tag);
    private ISankeyLink CreateLink(object source, object target, double weight, object tag);
    protected virtual List`1<IDataMemberContainer> CreateDataMemberContainers();
    protected virtual Dictionary`2<string, IDataMemberContainer> CreateAdditionalDataMemberContainers();
    public ICollection`1<ISankeyLink> Process();
}
public class DevExpress.Charts.Sankey.Native.SankeyBottomAlignmentCalculator : object {
    public sealed virtual void CorrectNodeAlignment(List`1<SankeyLayoutLevel> levels, DXRectangle bounds);
}
public class DevExpress.Charts.Sankey.Native.SankeyCenterAlignmentCalculator : object {
    public sealed virtual void CorrectNodeAlignment(List`1<SankeyLayoutLevel> levels, DXRectangle bounds);
}
public class DevExpress.Charts.Sankey.Native.SankeyDataAggregator : object {
    private Dictionary`2<Tuple`2<object, object>, ISankeyLink> links;
    private SumCalculator calculator;
    public ICollection`1<ISankeyLink> GetLinks(IEnumerable`1<ISankeyLink> platformLinks);
    public void Reset();
}
public static class DevExpress.Charts.Sankey.Native.SankeyDefaultTextConstructor : object {
    public static Tuple`2<string, string> GetToolTipText(SankeyNodeLayoutInfo info);
    public static Tuple`2<string, string> GetToolTipText(SankeyLinkLayoutInfo info);
}
public static class DevExpress.Charts.Sankey.Native.SankeyFakeDataGenerator : object {
    public static List`1<ISankeyLink> GenerateFakeData();
}
public enum DevExpress.Charts.Sankey.Native.SankeyLabelAlignmentCore : Enum {
    public int value__;
    public static SankeyLabelAlignmentCore OutsideAuto;
    public static SankeyLabelAlignmentCore Inside;
}
public class DevExpress.Charts.Sankey.Native.SankeyLayoutAlgorithmCore : object {
    private int nodeWidth;
    private int verticalNodeIndent;
    private int distanceBetweenLevels;
    private DXRectangle bounds;
    private ISankeyAlignmentCalculator alignmentCalculator;
    private SankeyNodeAlignmentCore nodeAlignment;
    [CompilerGeneratedAttribute]
private List`1<SankeyLayoutLevel> <Levels>k__BackingField;
    [CompilerGeneratedAttribute]
private Comparison`1<SankeyNodeLayoutInfo> <NodeComparison>k__BackingField;
    [CompilerGeneratedAttribute]
private ISankeyViewOptionsProvider <ViewOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolveOverlapping>k__BackingField;
    public List`1<SankeyLayoutLevel> Levels { get; public set; }
    public Comparison`1<SankeyNodeLayoutInfo> NodeComparison { get; public set; }
    public ISankeyViewOptionsProvider ViewOptions { get; public set; }
    public SankeyNodeAlignmentCore NodeAlignment { get; public set; }
    public bool ResolveOverlapping { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual List`1<SankeyLayoutLevel> get_Levels();
    [CompilerGeneratedAttribute]
public void set_Levels(List`1<SankeyLayoutLevel> value);
    [CompilerGeneratedAttribute]
public sealed virtual Comparison`1<SankeyNodeLayoutInfo> get_NodeComparison();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NodeComparison(Comparison`1<SankeyNodeLayoutInfo> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISankeyViewOptionsProvider get_ViewOptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ViewOptions(ISankeyViewOptionsProvider value);
    public sealed virtual SankeyNodeAlignmentCore get_NodeAlignment();
    public sealed virtual void set_NodeAlignment(SankeyNodeAlignmentCore value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ResolveOverlapping();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResolveOverlapping(bool value);
    private double CalculateSizePerWeight();
    private void CalculateLayoutProperties();
    private void CreateLevels(IEnumerable`1<ISankeyNodeLayoutItem> nodes);
    private int AssignLevelIndexes(IEnumerable`1<ISankeyNodeLayoutItem> nodes);
    private void GroupNodesIntoLevels(IEnumerable`1<ISankeyNodeLayoutItem> nodes);
    private void MoveTargetlessNodesToLastLevel(IEnumerable`1<ISankeyNodeLayoutItem> nodes, int maxLeveIndex);
    private bool TryCalculateNodeBounds(double sizePerWeight);
    public sealed virtual void CalculateNodeBounds(IEnumerable`1<ISankeyNodeLayoutItem> nodes, DXRectangle controlBounds);
    public virtual bool CalculateNodeBoundsInternal(IEnumerable`1<ISankeyNodeLayoutItem> nodes, DXRectangle controlBounds);
}
public class DevExpress.Charts.Sankey.Native.SankeyLayoutCalculatorChooser`1 : object {
    public static bool CalculateNodes(DXRectangle bounds, ICollection`1<SankeyNodeLayoutInfo> nodes, INodesCreator`1<T> nodesCreator, ISankeyLayoutOptionsProvider`1<T> layoutOptions);
}
public class DevExpress.Charts.Sankey.Native.SankeyLayoutLevel : List`1<SankeyNodeLayoutInfo> {
    private static int MinHoleHeightValue;
    private DXRectangle layoutBounds;
    private List`1<DXRectangle> breaks;
    private List`1<SankeyLevelHole> holes;
    public List`1<SankeyLevelHole> Holes { get; }
    public bool ShouldResolveOverlapping { get; }
    public SankeyLayoutLevel(DXRectangle layoutBounds);
    public List`1<SankeyLevelHole> get_Holes();
    public bool get_ShouldResolveOverlapping();
    private bool GetShouldResolveOverlapping();
    private void UniteIntersectedBreaks();
    private void CreateHoles();
    public void AddBreak(int startCoord, int endCoord);
}
public class DevExpress.Charts.Sankey.Native.SankeyLinkLayoutInfo : object {
    private double sourceYOffsetCoordinate;
    private double targetYOffsetCoordinate;
    private List`1<object> tags;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ISankeyLink> <Links>k__BackingField;
    [CompilerGeneratedAttribute]
private SankeyNodeLayoutInfo <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private SankeyNodeLayoutInfo <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Weight>k__BackingField;
    public IEnumerable`1<ISankeyLink> Links { get; }
    public List`1<object> Tags { get; }
    public SankeyNodeLayoutInfo Source { get; public set; }
    public SankeyNodeLayoutInfo Target { get; public set; }
    public double Weight { get; }
    public double SourceYOffsetCoordinate { get; internal set; }
    public double TargetYOffsetCoordinate { get; internal set; }
    public double Width { get; }
    private ISankeyNodeLayoutItem DevExpress.Charts.Sankey.ISankeyLinkLayoutItem.Source { get; }
    private ISankeyNodeLayoutItem DevExpress.Charts.Sankey.ISankeyLinkLayoutItem.Target { get; }
    private double DevExpress.Charts.Sankey.ISankeyLinkLayoutItem.Weight { get; }
    public SankeyLinkLayoutInfo(SankeyNodeLayoutInfo source, SankeyNodeLayoutInfo target, ISankeyLink link);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ISankeyLink> get_Links();
    public List`1<object> get_Tags();
    [CompilerGeneratedAttribute]
public SankeyNodeLayoutInfo get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(SankeyNodeLayoutInfo value);
    [CompilerGeneratedAttribute]
public SankeyNodeLayoutInfo get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(SankeyNodeLayoutInfo value);
    [CompilerGeneratedAttribute]
public double get_Weight();
    public double get_SourceYOffsetCoordinate();
    internal void set_SourceYOffsetCoordinate(double value);
    public double get_TargetYOffsetCoordinate();
    internal void set_TargetYOffsetCoordinate(double value);
    public double get_Width();
    private sealed virtual override ISankeyNodeLayoutItem DevExpress.Charts.Sankey.ISankeyLinkLayoutItem.get_Source();
    private sealed virtual override ISankeyNodeLayoutItem DevExpress.Charts.Sankey.ISankeyLinkLayoutItem.get_Target();
    private sealed virtual override double DevExpress.Charts.Sankey.ISankeyLinkLayoutItem.get_Weight();
}
public enum DevExpress.Charts.Sankey.Native.SankeyNodeAlignmentCore : Enum {
    public int value__;
    public static SankeyNodeAlignmentCore Far;
    public static SankeyNodeAlignmentCore Center;
    public static SankeyNodeAlignmentCore Near;
}
public class DevExpress.Charts.Sankey.Native.SankeyNodeCreator : object {
    private static void SwapTargetNode(SankeyNodeLayoutInfo targetNode, SankeyNodeLayoutInfo newTargetNode);
    private static List`1<SankeyNodeLayoutInfo> CreateNodes(ICollection`1<ISankeyLink> links);
    public static List`1<SankeyNodeLayoutInfo> GetNodes(ICollection`1<ISankeyLink> links);
}
public class DevExpress.Charts.Sankey.Native.SankeyNodeLayoutInfo : object {
    private object tag;
    private List`1<SankeyLinkLayoutInfo> targetLinks;
    private List`1<SankeyLinkLayoutInfo> sourceLinks;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LevelIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TargetWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SourceWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private DXRectangle <Bounds>k__BackingField;
    public List`1<SankeyLinkLayoutInfo> TargetLinks { get; public set; }
    public List`1<SankeyLinkLayoutInfo> SourceLinks { get; public set; }
    public int Index { get; }
    public int LevelIndex { get; internal set; }
    public double TargetWeight { get; private set; }
    public double SourceWeight { get; private set; }
    public double TotalWeight { get; }
    public DXRectangle Bounds { get; internal set; }
    public bool IsLast { get; }
    public object Tag { get; }
    private int DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.LevelIndex { get; private set; }
    private DXRectangle DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.Bounds { get; private set; }
    private double DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.TargetWeight { get; }
    private double DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.SourceWeight { get; }
    private double DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.TotalWeight { get; }
    private object DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.Tag { get; }
    private ReadOnlyCollection`1<ISankeyLinkLayoutItem> DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.OutputLinks { get; }
    private ReadOnlyCollection`1<ISankeyLinkLayoutItem> DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.InputLinks { get; }
    public SankeyNodeLayoutInfo(int index, object tag);
    public List`1<SankeyLinkLayoutInfo> get_TargetLinks();
    public void set_TargetLinks(List`1<SankeyLinkLayoutInfo> value);
    public List`1<SankeyLinkLayoutInfo> get_SourceLinks();
    public void set_SourceLinks(List`1<SankeyLinkLayoutInfo> value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public int get_LevelIndex();
    [CompilerGeneratedAttribute]
internal void set_LevelIndex(int value);
    [CompilerGeneratedAttribute]
public double get_TargetWeight();
    [CompilerGeneratedAttribute]
private void set_TargetWeight(double value);
    [CompilerGeneratedAttribute]
public double get_SourceWeight();
    [CompilerGeneratedAttribute]
private void set_SourceWeight(double value);
    public double get_TotalWeight();
    [CompilerGeneratedAttribute]
public DXRectangle get_Bounds();
    [CompilerGeneratedAttribute]
internal void set_Bounds(DXRectangle value);
    public bool get_IsLast();
    public object get_Tag();
    private sealed virtual override int DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.get_LevelIndex();
    private sealed virtual override void DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.set_LevelIndex(int value);
    private sealed virtual override DXRectangle DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.get_Bounds();
    private sealed virtual override void DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.set_Bounds(DXRectangle value);
    private sealed virtual override double DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.get_TargetWeight();
    private sealed virtual override double DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.get_SourceWeight();
    private sealed virtual override double DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.get_TotalWeight();
    private sealed virtual override object DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.get_Tag();
    private sealed virtual override ReadOnlyCollection`1<ISankeyLinkLayoutItem> DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.get_OutputLinks();
    private sealed virtual override ReadOnlyCollection`1<ISankeyLinkLayoutItem> DevExpress.Charts.Sankey.ISankeyNodeLayoutItem.get_InputLinks();
    internal bool TryFindParent(SankeyNodeLayoutInfo targetNode);
    internal void SpreadLevelIndexToChildren(int startingIndex);
    internal void AddTargetLink(SankeyLinkLayoutInfo link);
    internal void AddSourceLink(SankeyLinkLayoutInfo link);
    internal void RemoveSourceLink(SankeyLinkLayoutInfo buffLink);
    internal void InitLinkCoordinates();
    internal void SortTargetAndSourceLinks();
    internal void SortTargetAndSourceLinksRecursive();
}
public static class DevExpress.Charts.Sankey.Native.SankeyOverlappingResolver : object {
    private static int MinimalSpaceBetweenNodes;
    private static bool FillHolesWithNodes(List`1<SankeyLevelHole> holes, List`1<SankeyNodeLayoutInfo> nodes);
    private static void AddBreaksToNextLevels(List`1<SankeyLayoutLevel> levels, SankeyLayoutLevel level);
    public static void ResolveOverlapping(ICollection`1<SankeyNodeLayoutInfo> nodes, List`1<SankeyLayoutLevel> levels);
}
