public class DevExpress.CodeParser.Abort : FlowBreak {
    public LanguageElementType ElementType { get; }
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual LanguageElement GetFlowParent();
    public virtual LanguageElement FindTarget();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AccessDeclaration : CodeElement {
    private Expression _Declaration;
    private MemberVisibility _Visibility;
    public LanguageElementType ElementType { get; }
    public Expression Declaration { get; public set; }
    public MemberVisibility Visibility { get; public set; }
    public AccessDeclaration(Expression declaration);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Declaration();
    public void set_Declaration(Expression value);
    public MemberVisibility get_Visibility();
    public void set_Visibility(MemberVisibility value);
}
public abstract class DevExpress.CodeParser.Accessor : ParentingStatement {
    private BaseVariable _ImplicitVariable;
    private TextRange _NameRange;
    private bool __IsNewContext;
    private MemberVisibility _Visibility;
    private AccessSpecifiersFlags _Specifiers;
    private AccessSpecifiers _AccessSpecifiers;
    private bool _GenerateCodeBlock;
    private bool _HasEndingSemicolon;
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public BaseVariable ImplicitVariable { get; public set; }
    public bool HasImplicitVariable { get; }
    public SourceRange NameRange { get; public set; }
    public bool CanContainCode { get; }
    public bool IsNewContext { get; }
    public MemberVisibility Visibility { get; public set; }
    public SourceRange VisibilityRange { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsOverride { get; public set; }
    public bool IsReadOnly { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsExtern { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsNew { get; public set; }
    public bool IsVolatile { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsUnsafe { get; public set; }
    public bool IsWithEvents { get; public set; }
    public bool IsWriteOnly { get; public set; }
    public bool IsDefault { get; public set; }
    public bool IsOverloads { get; public set; }
    public bool IsAuto { get; public set; }
    public bool IsRegister { get; public set; }
    public bool IsMutable { get; public set; }
    public bool IsInline { get; public set; }
    public bool IsExplicit { get; public set; }
    public bool IsFriend { get; public set; }
    public bool IsTypeDef { get; public set; }
    public bool HasAccessSpecifiers { get; }
    public SourceRange OverrideRange { get; public set; }
    public SourceRange AbstractRange { get; public set; }
    public SourceRange VirtualRange { get; public set; }
    public string PathSegment { get; }
    public bool HasEndingSemicolon { get; public set; }
    public bool GenerateCodeBlock { get; public set; }
    protected virtual int get_ThisMaintenanceComplexity();
    private ITypeReferenceExpression GetTypeRef();
    protected virtual string GetAccessorName();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual void SetHistory(int index, DocumentHistorySlice history, bool isRecursive);
    public virtual void ClearHistory();
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual bool RangeIsClean(SourceRange sourceRange);
    [EditorBrowsableAttribute("1")]
public void SetSpecifiers(AccessSpecifiersFlags specifiers);
    [EditorBrowsableAttribute("1")]
public bool SpecifierIsSet(AccessSpecifiersFlags flag);
    [EditorBrowsableAttribute("1")]
public void SetSpecifierValue(AccessSpecifiersFlags flag, bool value);
    public sealed virtual bool Is(string fullTypeName);
    public sealed virtual bool Is(ITypeElement type);
    public sealed virtual bool Is(Type type);
    public sealed virtual bool Is(ISourceTreeResolver resolver, string fullTypeName);
    public BaseVariable get_ImplicitVariable();
    public void set_ImplicitVariable(BaseVariable value);
    public sealed virtual bool get_HasImplicitVariable();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public virtual bool get_CanContainCode();
    public virtual bool get_IsNewContext();
    public MemberVisibility get_Visibility();
    public void set_Visibility(MemberVisibility value);
    public SourceRange get_VisibilityRange();
    public void set_VisibilityRange(SourceRange value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsOverride();
    public void set_IsOverride(bool value);
    public sealed virtual bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public sealed virtual bool get_IsExtern();
    public void set_IsExtern(bool value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public bool get_IsNew();
    public void set_IsNew(bool value);
    public bool get_IsVolatile();
    public void set_IsVolatile(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsUnsafe();
    public void set_IsUnsafe(bool value);
    public bool get_IsWithEvents();
    public void set_IsWithEvents(bool value);
    public bool get_IsWriteOnly();
    public void set_IsWriteOnly(bool value);
    public bool get_IsDefault();
    public void set_IsDefault(bool value);
    public bool get_IsOverloads();
    public void set_IsOverloads(bool value);
    public bool get_IsAuto();
    public void set_IsAuto(bool value);
    public bool get_IsRegister();
    public void set_IsRegister(bool value);
    public bool get_IsMutable();
    public void set_IsMutable(bool value);
    public bool get_IsInline();
    public void set_IsInline(bool value);
    public bool get_IsExplicit();
    public void set_IsExplicit(bool value);
    public bool get_IsFriend();
    public void set_IsFriend(bool value);
    public bool get_IsTypeDef();
    public void set_IsTypeDef(bool value);
    public bool get_HasAccessSpecifiers();
    private void EnsureAccessSpecifiers();
    public SourceRange get_OverrideRange();
    public void set_OverrideRange(SourceRange value);
    public SourceRange get_AbstractRange();
    public void set_AbstractRange(SourceRange value);
    public SourceRange get_VirtualRange();
    public void set_VirtualRange(SourceRange value);
    public virtual string get_PathSegment();
    public bool get_HasEndingSemicolon();
    public void set_HasEndingSemicolon(bool value);
    public bool get_GenerateCodeBlock();
    public void set_GenerateCodeBlock(bool value);
    private AttributeSection CreateAttributeSection(IAttributeElement attribute);
    private sealed virtual override void DevExpress.CodeParser.IHasAttributesModifier.AddAttribute(IAttributeElement attribute);
    private sealed virtual override void DevExpress.CodeParser.IHasAttributesModifier.RemoveAttribute(IAttributeElement attribute);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsAbstract(bool isAbstract);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsExtern(bool isExtern);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsOverride(bool isOverride);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsReadOnly(bool isReadOnly);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsSealed(bool isSealed);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsStatic(bool isStatic);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsVirtual(bool isVirtual);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetVisibility(MemberVisibility visibility);
}
public abstract class DevExpress.CodeParser.AccessSpecifiedElement : DelimiterCapableBlock {
    private bool _IsDefaultVisibility;
    private MemberVisibility _Visibility;
    private MemberVisibility[] _ValidVisiblities;
    private AccessSpecifiers _AccessSpecifiers;
    private WeakReference _GenericTemplate;
    private string _StorageClassSpecifier;
    private Expression _NameQualifier;
    private GenericModifier _GenericModifier;
    private TextRange _NameRange;
    [EditorBrowsableAttribute("1")]
protected MemberVisibility[] BaseValidVisibilities { get; }
    public SourceRange NameRange { get; public set; }
    public bool DeclaresIdentifier { get; }
    public AccessSpecifiers AccessSpecifiers { get; public set; }
    public bool AccessibleByDescendants { get; }
    public bool HasInternalAccess { get; }
    public bool HasProtectedAccess { get; }
    public bool HasAccessSpecifiers { get; }
    public MemberVisibility[] ValidVisibilities { get; public set; }
    [DescriptionAttribute("The visibility of this member (e.g., private, protected, internal, public, local, etc.).")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public MemberVisibility Visibility { get; public set; }
    [DescriptionAttribute("True if the visibility of this member can not be changed (e.g., illegal, param, or local).")]
[CategoryAttribute("Access")]
public bool VisibilityIsFixed { get; }
    [CategoryAttribute("Access")]
public SourceRange VisibilityRange { get; }
    [CategoryAttribute("Access")]
public SourceRange VirtualOverrideAbstractRange { get; }
    [CategoryAttribute("Access")]
public SourceRange IteratorRange { get; }
    [CategoryAttribute("Access")]
public SourceRange VirtualRange { get; }
    [CategoryAttribute("Access")]
public SourceRange OverrideRange { get; }
    [CategoryAttribute("Access")]
public SourceRange AbstractRange { get; }
    [CategoryAttribute("Access")]
public SourceRange StaticRange { get; }
    [CategoryAttribute("Access")]
public SourceRange UnsafeRange { get; }
    [CategoryAttribute("Access")]
public SourceRange NewRange { get; }
    [CategoryAttribute("Access")]
public SourceRange SealedRange { get; }
    [CategoryAttribute("Access")]
public SourceRange ReadOnlyRange { get; }
    [CategoryAttribute("Access")]
public SourceRange WriteOnlyRange { get; }
    [CategoryAttribute("Access")]
public SourceRange DefaultRange { get; }
    [CategoryAttribute("Access")]
public SourceRange OverloadsRange { get; }
    [CategoryAttribute("Access")]
public SourceRange ExternRange { get; }
    [CategoryAttribute("Access")]
public SourceRange VolatileRange { get; }
    [CategoryAttribute("Access")]
public SourceRange AutoRange { get; }
    [CategoryAttribute("Access")]
public SourceRange RegisterRange { get; }
    [CategoryAttribute("Access")]
public SourceRange MutableRange { get; }
    [CategoryAttribute("Access")]
public SourceRange InlineRange { get; }
    [CategoryAttribute("Access")]
public SourceRange ExplicitRange { get; }
    [CategoryAttribute("Access")]
public SourceRange FriendRange { get; }
    [CategoryAttribute("Access")]
public SourceRange TypeDefRange { get; }
    [CategoryAttribute("Access")]
public SourceRange PartialRange { get; }
    [CategoryAttribute("Access")]
public SourceRange WithEventsRange { get; }
    public GenericModifier GenericModifier { get; }
    public bool IsActivatedGeneric { get; }
    public AccessSpecifiedElement GenericTemplate { get; public set; }
    [DescriptionAttribute("True if the visibility for this member is derived from its parent's default visibility. False if a visibility keyword was specified (e.g., "public", "protected", "private", etc.) in the declaration of this member.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("True")]
public bool IsDefaultVisibility { get; public set; }
    [DescriptionAttribute("True if this is an abstract member.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsAbstract { get; public set; }
    [DescriptionAttribute("True if this is an iterator member.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsIterator { get; public set; }
    public bool IsGeneric { get; }
    [DescriptionAttribute("True if this member overrides an ancestor member.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsOverride { get; public set; }
    [DescriptionAttribute("True if this is a read-only member.")]
[CategoryAttribute("Modifiers")]
public bool IsReadOnly { get; public set; }
    [DescriptionAttribute("True if this is a write-only member. (This construct is supported in VB).")]
[CategoryAttribute("Modifiers")]
[DefaultValueAttribute("False")]
public bool IsWriteOnly { get; public set; }
    [DescriptionAttribute("True if this is a Default member (this construct is supported in VB).")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsDefault { get; public set; }
    [DescriptionAttribute("True if this is a static member.")]
[CategoryAttribute("Modifiers")]
[DefaultValueAttribute("False")]
public bool IsStatic { get; public set; }
    [DescriptionAttribute("True if this is member is externally defined.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsExtern { get; public set; }
    [DescriptionAttribute("True if this member is virtual.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsVirtual { get; public set; }
    [DescriptionAttribute("True if this member can be modified in the running program by an external asynchronous source, such as the operating system, the hardware, or a concurrently executing thread.")]
[CategoryAttribute("Modifiers")]
[DefaultValueAttribute("False")]
public bool IsVolatile { get; public set; }
    public bool IsConst { get; public set; }
    public bool IsConstVolatile { get; public set; }
    [DescriptionAttribute("True if this member explicitly hides an inherited member.")]
[CategoryAttribute("Modifiers")]
[DefaultValueAttribute("False")]
public bool IsNew { get; public set; }
    [DescriptionAttribute("True if this is a sealed member.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsSealed { get; public set; }
    [DescriptionAttribute("True if this is an unsafe member.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsUnsafe { get; public set; }
    [DescriptionAttribute("True if this member refers to an instance of a class that can raise events (this construct is supported in VB).")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsWithEvents { get; public set; }
    [DescriptionAttribute("True if this member has Overloads modifier (this construct is supported in VB).")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsOverloads { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsAuto { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsRegister { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsMutable { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsInline { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsExplicit { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsFriend { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsTypeDef { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsPartial { get; public set; }
    [DescriptionAttribute("Returns true if this member is explicitly declared interface member.")]
[CategoryAttribute("Details")]
public bool IsExplicitInterfaceMember { get; public set; }
    public string PathSegment { get; }
    public Expression NameQualifier { get; public set; }
    public IEnumerable AllVariables { get; }
    public IEnumerable AllStatements { get; }
    public IEnumerable AllFlowBreaks { get; }
    protected bool HasOuterRangeChildren { get; }
    private ITypeParameterCollection DevExpress.CodeParser.IGenericElement.TypeParameters { get; }
    private IGenericElement DevExpress.CodeParser.IGenericElement.GenericTemplate { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsDefaultVisibility { get; }
    private IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.Attributes { get; }
    private IExpression DevExpress.CodeParser.IMemberElement.NameQualifier { get; }
    private string DevExpress.CodeParser.IMemberElement.Signature { get; }
    private IExpressionCollection DevExpress.CodeParser.IMemberElement.Implements { get; }
    public string StorageClassSpecifier { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsPureVirtual { get; public set; }
    private bool IsProtectedOrInternal(MemberVisibility visibility);
    private bool CanSetProtectedInternalVisibility(MemberVisibility visibility);
    protected void EnsureAccessSpecifiers();
    [EditorBrowsableAttribute("1")]
public void SetSealedRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetReadOnlyRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetVolatileRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetNewRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetVisibility(MemberVisibility visibility, Token token);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetVisibility(MemberVisibility visibility);
    [EditorBrowsableAttribute("1")]
public void SetExternRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetStaticRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetVirtualOverrideAbstractRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetVirtualRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetOverrideRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetAbstractRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetUnsafeRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetWithEventsRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetWriteOnlyRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetDefaultRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetOverloadsRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetAutoRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetRegisterRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetMutableRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetInlineRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetExplicitRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetFriendRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetTypeDefRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetPartialRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetPartialRange(Token token);
    [EditorBrowsableAttribute("1")]
public virtual void SetAccessSpecifiers(AccessSpecifiers specifiers);
    public virtual void SetHistory(int index, DocumentHistorySlice history, bool isRecursive);
    public virtual void ClearHistory();
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected internal virtual bool GetCanBeDocumented();
    public virtual void SetParent(LanguageElement parent);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    protected virtual IExpressionCollection GetImplementExpressions();
    public void SetNameRange(SourceRange nameRange);
    public virtual int GetVisibilityImageIndex();
    public bool SupportsVisibility(MemberVisibility aMemberVisibility);
    public void SetGenericModifier(GenericModifier modifier);
    public LanguageElementCollection GetUnusedDeclarations();
    public virtual bool IsVisibleFrom(LanguageElement viewer);
    protected MemberVisibility[] get_BaseValidVisibilities();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public virtual bool get_DeclaresIdentifier();
    public AccessSpecifiers get_AccessSpecifiers();
    public void set_AccessSpecifiers(AccessSpecifiers value);
    public bool get_AccessibleByDescendants();
    public bool get_HasInternalAccess();
    public bool get_HasProtectedAccess();
    public bool get_HasAccessSpecifiers();
    public virtual MemberVisibility[] get_ValidVisibilities();
    public virtual void set_ValidVisibilities(MemberVisibility[] value);
    public virtual MemberVisibility get_Visibility();
    public virtual void set_Visibility(MemberVisibility value);
    public virtual bool get_VisibilityIsFixed();
    public SourceRange get_VisibilityRange();
    public SourceRange get_VirtualOverrideAbstractRange();
    public SourceRange get_IteratorRange();
    public SourceRange get_VirtualRange();
    public SourceRange get_OverrideRange();
    public SourceRange get_AbstractRange();
    public SourceRange get_StaticRange();
    public SourceRange get_UnsafeRange();
    public SourceRange get_NewRange();
    public SourceRange get_SealedRange();
    public SourceRange get_ReadOnlyRange();
    public SourceRange get_WriteOnlyRange();
    public SourceRange get_DefaultRange();
    public SourceRange get_OverloadsRange();
    public SourceRange get_ExternRange();
    public SourceRange get_VolatileRange();
    public SourceRange get_AutoRange();
    public SourceRange get_RegisterRange();
    public SourceRange get_MutableRange();
    public SourceRange get_InlineRange();
    public SourceRange get_ExplicitRange();
    public SourceRange get_FriendRange();
    public SourceRange get_TypeDefRange();
    public SourceRange get_PartialRange();
    public SourceRange get_WithEventsRange();
    public GenericModifier get_GenericModifier();
    public sealed virtual bool get_IsActivatedGeneric();
    public AccessSpecifiedElement get_GenericTemplate();
    public void set_GenericTemplate(AccessSpecifiedElement value);
    public virtual bool get_IsDefaultVisibility();
    public virtual void set_IsDefaultVisibility(bool value);
    public sealed virtual bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual bool get_IsIterator();
    public void set_IsIterator(bool value);
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsOverride();
    public void set_IsOverride(bool value);
    public virtual bool get_IsReadOnly();
    public virtual void set_IsReadOnly(bool value);
    public bool get_IsWriteOnly();
    public void set_IsWriteOnly(bool value);
    public bool get_IsDefault();
    public void set_IsDefault(bool value);
    public virtual bool get_IsStatic();
    public virtual void set_IsStatic(bool value);
    public sealed virtual bool get_IsExtern();
    public void set_IsExtern(bool value);
    public sealed virtual bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public virtual bool get_IsVolatile();
    public virtual void set_IsVolatile(bool value);
    public virtual bool get_IsConst();
    public virtual void set_IsConst(bool value);
    public virtual bool get_IsConstVolatile();
    public virtual void set_IsConstVolatile(bool value);
    public void ResetCVFlags();
    public virtual bool get_IsNew();
    public virtual void set_IsNew(bool value);
    public sealed virtual bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsUnsafe();
    public void set_IsUnsafe(bool value);
    public virtual bool get_IsWithEvents();
    public virtual void set_IsWithEvents(bool value);
    public bool get_IsOverloads();
    public void set_IsOverloads(bool value);
    public bool get_IsAuto();
    public void set_IsAuto(bool value);
    public bool get_IsRegister();
    public void set_IsRegister(bool value);
    public bool get_IsMutable();
    public void set_IsMutable(bool value);
    public bool get_IsInline();
    public void set_IsInline(bool value);
    public bool get_IsExplicit();
    public void set_IsExplicit(bool value);
    public bool get_IsFriend();
    public void set_IsFriend(bool value);
    public sealed virtual bool get_IsTypeDef();
    public void set_IsTypeDef(bool value);
    public sealed virtual bool get_IsPartial();
    public void set_IsPartial(bool value);
    public virtual bool get_IsExplicitInterfaceMember();
    public virtual void set_IsExplicitInterfaceMember(bool value);
    public virtual string get_PathSegment();
    public Expression get_NameQualifier();
    public void set_NameQualifier(Expression value);
    public virtual IEnumerable get_AllVariables();
    public virtual IEnumerable get_AllStatements();
    public virtual IEnumerable get_AllFlowBreaks();
    protected virtual bool get_HasOuterRangeChildren();
    private sealed virtual override ITypeParameterCollection DevExpress.CodeParser.IGenericElement.get_TypeParameters();
    private sealed virtual override IGenericElement DevExpress.CodeParser.IGenericElement.get_GenericTemplate();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsDefaultVisibility();
    public sealed virtual string GetOverrideCode();
    public sealed virtual string GetOverrideCode(bool callBase);
    public sealed virtual string GetOverrideCode(bool callBase, string codeBefore, string codeAfter);
    private sealed virtual override IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.get_Attributes();
    private sealed virtual override IExpression DevExpress.CodeParser.IMemberElement.get_NameQualifier();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMemberElement.get_Implements();
    public string get_StorageClassSpecifier();
    public void set_StorageClassSpecifier(string value);
    public bool get_IsPureVirtual();
    public void set_IsPureVirtual(bool value);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsAbstract(bool isAbstract);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsStatic(bool isStatic);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsOverride(bool isOverride);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsExtern(bool isExtern);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsVirtual(bool isVirtual);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsReadOnly(bool isReadOnly);
    private sealed virtual override void DevExpress.CodeParser.IMemberElementModifier.SetIsSealed(bool isSealed);
    private AttributeSection CreateAttributeSection(IAttributeElement attribute);
    private sealed virtual override void DevExpress.CodeParser.IHasAttributesModifier.AddAttribute(IAttributeElement attribute);
    private sealed virtual override void DevExpress.CodeParser.IHasAttributesModifier.RemoveAttribute(IAttributeElement attribute);
    private void CreateGenericModifierIfNeeded();
    private sealed virtual override void DevExpress.CodeParser.IGenericElementModifier.AddTypeParameter(ITypeParameter typeParameter);
    private sealed virtual override void DevExpress.CodeParser.IGenericElementModifier.InsertTypeParameter(int index, ITypeParameter typeParameter);
    private sealed virtual override void DevExpress.CodeParser.IGenericElementModifier.RemoveTypeParameter(ITypeParameter typeParameter);
}
public class DevExpress.CodeParser.AccessSpecifiers : object {
    private DocumentHistorySlice _History;
    private TextRangeWrapper _VisibilityRange;
    private TextRangeWrapper _VirtualOverrideAbstractRange;
    private TextRangeWrapper _VirtualRange;
    private TextRangeWrapper _OverrideRange;
    private TextRangeWrapper _AbstractRange;
    private TextRangeWrapper _StaticRange;
    private TextRangeWrapper _UnsafeRange;
    private TextRangeWrapper _NewRange;
    private TextRangeWrapper _SealedRange;
    private TextRangeWrapper _ReadOnlyRange;
    private TextRangeWrapper _ExternRange;
    private TextRangeWrapper _VolatileRange;
    private TextRangeWrapper _WithEventsRange;
    private TextRangeWrapper _WriteOnlyRange;
    private TextRangeWrapper _DefaultRange;
    private TextRangeWrapper _OverloadsRange;
    private TextRangeWrapper _PartialRange;
    private TextRangeWrapper _AsynchronousRange;
    private TextRangeWrapper _IteratorRange;
    private TextRangeWrapper _AutoRange;
    private TextRangeWrapper _RegisterRange;
    private TextRangeWrapper _MutableRange;
    private TextRangeWrapper _InlineRange;
    private TextRangeWrapper _ExplicitRange;
    private TextRangeWrapper _FriendRange;
    private TextRangeWrapper _TypeDefRange;
    private AccessSpecifiersFlags _Specifiers;
    public bool IsAbstract { get; public set; }
    public bool IsOverride { get; public set; }
    public bool IsReadOnly { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsExtern { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsNew { get; public set; }
    public bool IsVolatile { get; public set; }
    public bool IsConst { get; public set; }
    public bool IsConstVolatile { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsUnsafe { get; public set; }
    public bool IsWithEvents { get; public set; }
    public bool IsWriteOnly { get; public set; }
    public bool IsDefault { get; public set; }
    public bool IsOverloads { get; public set; }
    public bool IsAuto { get; public set; }
    public bool IsRegister { get; public set; }
    public bool IsMutable { get; public set; }
    public bool IsInline { get; public set; }
    public bool IsExplicit { get; public set; }
    public bool IsFriend { get; public set; }
    public bool IsTypeDef { get; public set; }
    public bool IsPartial { get; public set; }
    public bool IsPureVirtual { get; public set; }
    public bool IsAsynchronous { get; public set; }
    public bool IsIterator { get; public set; }
    [EditorBrowsableAttribute("1")]
public AccessSpecifiersFlags Specifiers { get; }
    public SourceRange VisibilityRange { get; }
    public SourceRange VirtualOverrideAbstractRange { get; }
    public SourceRange VirtualRange { get; }
    public SourceRange OverrideRange { get; }
    public SourceRange AbstractRange { get; }
    public SourceRange StaticRange { get; }
    public SourceRange UnsafeRange { get; }
    public SourceRange NewRange { get; }
    public SourceRange SealedRange { get; }
    public SourceRange ReadOnlyRange { get; }
    public SourceRange ExternRange { get; }
    public SourceRange VolatileRange { get; }
    public SourceRange WithEventsRange { get; }
    public SourceRange WriteOnlyRange { get; }
    public SourceRange DefaultRange { get; }
    public SourceRange OverloadsRange { get; }
    public SourceRange PartialRange { get; }
    public SourceRange AsynchronousRange { get; }
    public SourceRange IteratorRange { get; }
    public SourceRange AutoRange { get; }
    public SourceRange RegisterRange { get; }
    public SourceRange MutableRange { get; }
    public SourceRange InlineRange { get; }
    public SourceRange ExplicitRange { get; }
    public SourceRange FriendRange { get; }
    public SourceRange TypeDefRange { get; }
    private void Set(TextRangeWrapper& range, Token token);
    private void Set(TextRangeWrapper& range, SourceRange sourceRange);
    private void SetEnd(TextRangeWrapper& range, SourcePoint point);
    private void SetEnd(TextRangeWrapper& range, Token token);
    private SourceRange Get(TextRangeWrapper range);
    [EditorBrowsableAttribute("1")]
public void SetHistory(DocumentHistorySlice history);
    [EditorBrowsableAttribute("1")]
public void ClearHistory();
    [EditorBrowsableAttribute("1")]
public void SetSealedRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetVisibilityRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetVisibilityRangeEnd(Token token);
    [EditorBrowsableAttribute("1")]
public void SetReadOnlyRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetVolatileRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetNewRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetExternRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetStaticRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetVirtualOverrideAbstractRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetVirtualRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetOverrideRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetAbstractRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetUnsafeRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetWithEventsRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetWriteOnlyRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetDefaultRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetOverloadsRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetSealedRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetVisibilityRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetVisibilityRangeEnd(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetReadOnlyRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetVolatileRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetNewRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetExternRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetStaticRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetVirtualOverrideAbstractRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetVirtualRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetOverrideRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetAbstractRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetUnsafeRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetWithEventsRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetWriteOnlyRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetDefaultRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetOverloadsRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetPartialRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetPartialRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetAsynchronousRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetIteratorRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetAsynchronousRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetIteratorRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetAutoRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetAutoRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetRegisterRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetRegisterRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetMutableRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetMutableRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetInlineRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetInlineRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetExplicitRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetExplicitRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetFriendRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetFriendRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetTypeDefRange(Token token);
    [EditorBrowsableAttribute("1")]
public void SetTypeDefRange(SourceRange range);
    private sealed virtual override object System.ICloneable.Clone();
    public AccessSpecifiers Clone();
    protected void UpdateRanges();
    public bool SpecifierIsSet(AccessSpecifiersFlags flag);
    public void SetSpecifierValue(AccessSpecifiersFlags flag, bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsOverride();
    public void set_IsOverride(bool value);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsExtern();
    public void set_IsExtern(bool value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public bool get_IsNew();
    public void set_IsNew(bool value);
    public bool get_IsVolatile();
    public void set_IsVolatile(bool value);
    public bool get_IsConst();
    public void set_IsConst(bool value);
    public bool get_IsConstVolatile();
    public void set_IsConstVolatile(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsUnsafe();
    public void set_IsUnsafe(bool value);
    public bool get_IsWithEvents();
    public void set_IsWithEvents(bool value);
    public bool get_IsWriteOnly();
    public void set_IsWriteOnly(bool value);
    public bool get_IsDefault();
    public void set_IsDefault(bool value);
    public bool get_IsOverloads();
    public void set_IsOverloads(bool value);
    public bool get_IsAuto();
    public void set_IsAuto(bool value);
    public bool get_IsRegister();
    public void set_IsRegister(bool value);
    public bool get_IsMutable();
    public void set_IsMutable(bool value);
    public bool get_IsInline();
    public void set_IsInline(bool value);
    public bool get_IsExplicit();
    public void set_IsExplicit(bool value);
    public bool get_IsFriend();
    public void set_IsFriend(bool value);
    public bool get_IsTypeDef();
    public void set_IsTypeDef(bool value);
    public bool get_IsPartial();
    public void set_IsPartial(bool value);
    public bool get_IsPureVirtual();
    public void set_IsPureVirtual(bool value);
    public bool get_IsAsynchronous();
    public void set_IsAsynchronous(bool value);
    public bool get_IsIterator();
    public void set_IsIterator(bool value);
    public AccessSpecifiersFlags get_Specifiers();
    public void ResetCVFlags();
    public SourceRange get_VisibilityRange();
    public SourceRange get_VirtualOverrideAbstractRange();
    public SourceRange get_VirtualRange();
    public SourceRange get_OverrideRange();
    public SourceRange get_AbstractRange();
    public SourceRange get_StaticRange();
    public SourceRange get_UnsafeRange();
    public SourceRange get_NewRange();
    public SourceRange get_SealedRange();
    public SourceRange get_ReadOnlyRange();
    public SourceRange get_ExternRange();
    public SourceRange get_VolatileRange();
    public SourceRange get_WithEventsRange();
    public SourceRange get_WriteOnlyRange();
    public SourceRange get_DefaultRange();
    public SourceRange get_OverloadsRange();
    public SourceRange get_PartialRange();
    public SourceRange get_AsynchronousRange();
    public SourceRange get_IteratorRange();
    public SourceRange get_AutoRange();
    public SourceRange get_RegisterRange();
    public SourceRange get_MutableRange();
    public SourceRange get_InlineRange();
    public SourceRange get_ExplicitRange();
    public SourceRange get_FriendRange();
    public SourceRange get_TypeDefRange();
}
[FlagsAttribute]
public enum DevExpress.CodeParser.AccessSpecifiersFlags : Enum {
    public int value__;
    public static AccessSpecifiersFlags None;
    public static AccessSpecifiersFlags Abstract;
    public static AccessSpecifiersFlags Override;
    public static AccessSpecifiersFlags ReadOnly;
    public static AccessSpecifiersFlags Static;
    public static AccessSpecifiersFlags Extern;
    public static AccessSpecifiersFlags Virtual;
    public static AccessSpecifiersFlags New;
    public static AccessSpecifiersFlags Volatile;
    public static AccessSpecifiersFlags Sealed;
    public static AccessSpecifiersFlags Unsafe;
    public static AccessSpecifiersFlags WithEvents;
    public static AccessSpecifiersFlags WriteOnly;
    public static AccessSpecifiersFlags Default;
    public static AccessSpecifiersFlags Overloads;
    public static AccessSpecifiersFlags Auto;
    public static AccessSpecifiersFlags Register;
    public static AccessSpecifiersFlags VTable;
    public static AccessSpecifiersFlags Inline;
    public static AccessSpecifiersFlags Explicit;
    public static AccessSpecifiersFlags Friend;
    public static AccessSpecifiersFlags TypeDef;
    public static AccessSpecifiersFlags Mutable;
    public static AccessSpecifiersFlags Const;
    public static AccessSpecifiersFlags ConstVolatile;
    public static AccessSpecifiersFlags Partial;
    public static AccessSpecifiersFlags PureVirtual;
    public static AccessSpecifiersFlags Async;
    public static AccessSpecifiersFlags Iterator;
}
[EditorBrowsableAttribute("1")]
public enum DevExpress.CodeParser.ActiveHtmlTagPart : Enum {
    public int value__;
    public static ActiveHtmlTagPart Property;
    public static ActiveHtmlTagPart Qualifier;
    public static ActiveHtmlTagPart None;
}
public class DevExpress.CodeParser.AddHandler : HandlerStatement {
    public LanguageElementType ElementType { get; }
    public AddHandler(Expression expression, Expression address);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AddressOfExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _Exp;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public string Operator { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IAddressOfExpression.Expression { get; }
    public AddressOfExpression(Expression expression);
    public AddressOfExpression(Token token, Expression expression);
    private void SetOperator(Token token);
    private void SetExpression(Expression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public string get_Operator();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IAddressOfExpression.get_Expression();
}
public class DevExpress.CodeParser.AggregateElementReferenceExpression : ElementReferenceExpression {
    public LanguageElementType ElementType { get; }
    public AggregateElementReferenceExpression(ElementReferenceExpression elmentReferenceExpression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AggregateExpression : FromExpression {
    private ExpressionCollection _QueryOperators;
    private LanguageElementCollection _IntoElements;
    public LanguageElementCollection IntoElements { get; }
    public ExpressionCollection QueryOperators { get; }
    public LanguageElementType ElementType { get; }
    public void AddIntoElements(IEnumerable`1<LanguageElement> elements);
    public sealed virtual void AddIntoElement(LanguageElement element);
    public void AddQueryOperators(IEnumerable`1<Expression> queryOperators);
    public void AddQueryOperator(Expression exp);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public sealed virtual LanguageElementCollection get_IntoElements();
    public ExpressionCollection get_QueryOperators();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AggregateMethodCallExpression : MethodCallExpression {
    public LanguageElementType ElementType { get; }
    public AggregateMethodCallExpression(MethodCallExpression methodCallExpression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AliasDeclaration : CodeElement {
    private string _AliasName;
    private IExpression _Expression;
    public LanguageElementType ElementType { get; }
    public string AliasName { get; }
    public string Name { get; public set; }
    public IExpression Expression { get; }
    public AliasDeclaration(string name, IExpression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_AliasName();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public sealed virtual IExpression get_Expression();
}
public class DevExpress.CodeParser.AncestorTypeReference : TypeReferenceExpression {
    private AncestorVisibilityType _AncestorVisibility;
    private bool _IsVirtual;
    public LanguageElementType ElementType { get; }
    public AncestorVisibilityType AncestorVisibility { get; public set; }
    public bool IsVirtual { get; public set; }
    public AncestorTypeReference(string type);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public AncestorVisibilityType get_AncestorVisibility();
    public void set_AncestorVisibility(AncestorVisibilityType value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
}
public enum DevExpress.CodeParser.AncestorVisibilityType : Enum {
    public int value__;
    public static AncestorVisibilityType Default;
    public static AncestorVisibilityType Public;
    public static AncestorVisibilityType Private;
    public static AncestorVisibilityType Protected;
    public static AncestorVisibilityType Internal;
    public static AncestorVisibilityType PublicProtected;
    public static AncestorVisibilityType ProtectedPublic;
    public static AncestorVisibilityType ProtectedPrivate;
    public static AncestorVisibilityType PrivateProtected;
}
public class DevExpress.CodeParser.AnonymousConstructorExpression : AnonymousMethodExpression {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AnonymousMethodExpression : Expression {
    private LanguageElementCollection _Parameters;
    private SourceRange _NameRange;
    private SourceRange _ParamOpenRange;
    private SourceRange _ParamCloseRange;
    private SourceRange _BlockStart;
    private SourceRange _BlockEnd;
    private bool _IsAsynchronous;
    private bool _ParameterListOmitted;
    public LanguageElementType ElementType { get; }
    public bool IsNewContext { get; }
    public bool CanContainCode { get; }
    public LanguageElementCollection Parameters { get; }
    public int ParameterCount { get; }
    public SourceRange NameRange { get; public set; }
    public SourceRange ParamOpenRange { get; public set; }
    public SourceRange ParamCloseRange { get; public set; }
    public SourceRange BlockStart { get; public set; }
    public SourceRange BlockEnd { get; public set; }
    private IParameterElementCollection DevExpress.CodeParser.IWithParameters.Parameters { get; }
    private SourceRange DevExpress.CodeParser.IHasBlock.BlockStart { get; }
    private SourceRange DevExpress.CodeParser.IHasBlock.BlockEnd { get; }
    [DescriptionAttribute("True if this anonimous method expression has async modifier.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsAsynchronous { get; public set; }
    public bool ParameterListOmitted { get; public set; }
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.AddParameter(IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.RemoveParameter(IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.InsertParameter(int index, IParameterElement parameter);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public sealed virtual void SetBlockStart(SourceRange blockStart);
    public sealed virtual void SetBlockEnd(SourceRange blockEnd);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual string ToString();
    public void AddParameters(LanguageElementCollection parameters);
    public void AddParameter(Param param);
    public void RemoveParameter(Param param);
    public void InsertParameter(int index, Param parameter);
    public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    private TypeReferenceExpression GetMethodType();
    public Method CreateMethod(string methodName);
    public Method CreateMethod(string methodName, TypeReferenceExpression methodType, LanguageElementCollection parameters);
    public virtual int GetCyclomaticComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_IsNewContext();
    public virtual bool get_CanContainCode();
    public sealed virtual LanguageElementCollection get_Parameters();
    public sealed virtual int get_ParameterCount();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public SourceRange get_ParamOpenRange();
    public void set_ParamOpenRange(SourceRange value);
    public SourceRange get_ParamCloseRange();
    public void set_ParamCloseRange(SourceRange value);
    public SourceRange get_BlockStart();
    public void set_BlockStart(SourceRange value);
    public SourceRange get_BlockEnd();
    public void set_BlockEnd(SourceRange value);
    private sealed virtual override IParameterElementCollection DevExpress.CodeParser.IWithParameters.get_Parameters();
    private sealed virtual override SourceRange DevExpress.CodeParser.IHasBlock.get_BlockStart();
    private sealed virtual override SourceRange DevExpress.CodeParser.IHasBlock.get_BlockEnd();
    public sealed virtual bool get_IsAsynchronous();
    public void set_IsAsynchronous(bool value);
    public virtual bool get_ParameterListOmitted();
    public virtual void set_ParameterListOmitted(bool value);
}
public enum DevExpress.CodeParser.ArgumentDirection : Enum {
    public byte value__;
    public static ArgumentDirection In;
    public static ArgumentDirection Out;
    public static ArgumentDirection Ref;
    public static ArgumentDirection ParamArray;
    public static ArgumentDirection ArgList;
}
public class DevExpress.CodeParser.ArgumentDirectionExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _Exp;
    private ArgumentDirection _Direction;
    private TextRange _NameRange;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; }
    public ArgumentDirection Direction { get; public set; }
    public Expression Expression { get; public set; }
    private ArgumentDirection DevExpress.CodeParser.IArgumentDirectionExpression.Direction { get; }
    private IExpression DevExpress.CodeParser.IArgumentDirectionExpression.Expression { get; }
    public ArgumentDirectionExpression(Token token, Expression expression);
    public ArgumentDirectionExpression(ArgumentDirection direction, Expression expression);
    private void SetDirectionToken(Token token);
    private void SetDirection(ArgumentDirection direction);
    private void SetExpression(Expression expression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    protected void SetNameRange(SourceRange value);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    public ArgumentDirection get_Direction();
    public void set_Direction(ArgumentDirection value);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override ArgumentDirection DevExpress.CodeParser.IArgumentDirectionExpression.get_Direction();
    private sealed virtual override IExpression DevExpress.CodeParser.IArgumentDirectionExpression.get_Expression();
}
public class DevExpress.CodeParser.ArrayCreateExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private TypeReferenceExpression _BaseType;
    private ExpressionCollection _Dimensions;
    private ArrayInitializerExpression _Initializer;
    private bool _HasNOGCModifier;
    private bool _IsStackAlloc;
    private ArrayKindModifier _ArrayKind;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public TypeReferenceExpression BaseType { get; public set; }
    public ExpressionCollection Dimensions { get; public set; }
    public ArrayInitializerExpression Initializer { get; public set; }
    public SourceRange NameRange { get; }
    public bool HasNOGCModifier { get; public set; }
    public ArrayKindModifier ArrayKind { get; public set; }
    public bool IsStackAlloc { get; public set; }
    private ITypeReferenceExpression DevExpress.CodeParser.IArrayCreateExpression.BaseType { get; }
    private IExpressionCollection DevExpress.CodeParser.IArrayCreateExpression.Dimensions { get; }
    private IArrayInitializerExpression DevExpress.CodeParser.IArrayCreateExpression.Initializer { get; }
    public ArrayCreateExpression(TypeReferenceExpression type);
    public ArrayCreateExpression(TypeReferenceExpression type, ExpressionCollection dimensions);
    public ArrayCreateExpression(TypeReferenceExpression type, ExpressionCollection dimensions, ArrayInitializerExpression initializer);
    private bool CompareDimensions(ArrayCreateExpression expression);
    private bool CompareInitializer(ArrayCreateExpression expression);
    private void SetBaseType(TypeReferenceExpression baseType);
    private void SetInitializer(ArrayInitializerExpression initializer);
    private void SetDimensions(ExpressionCollection dimensions);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddDimension(Expression dimension);
    public void AddDimensions(IEnumerable`1<Expression> dimensions);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public TypeReferenceExpression get_BaseType();
    public void set_BaseType(TypeReferenceExpression value);
    public ExpressionCollection get_Dimensions();
    public void set_Dimensions(ExpressionCollection value);
    public ArrayInitializerExpression get_Initializer();
    public void set_Initializer(ArrayInitializerExpression value);
    public virtual SourceRange get_NameRange();
    public bool get_HasNOGCModifier();
    public void set_HasNOGCModifier(bool value);
    public ArrayKindModifier get_ArrayKind();
    public void set_ArrayKind(ArrayKindModifier value);
    public bool get_IsStackAlloc();
    public void set_IsStackAlloc(bool value);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.IArrayCreateExpression.get_BaseType();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IArrayCreateExpression.get_Dimensions();
    private sealed virtual override IArrayInitializerExpression DevExpress.CodeParser.IArrayCreateExpression.get_Initializer();
}
public class DevExpress.CodeParser.ArrayInitializerExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private ExpressionCollection _Initializers;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public ExpressionCollection Initializers { get; public set; }
    private IExpressionCollection DevExpress.CodeParser.IArrayInitializerExpression.Initializers { get; }
    public ArrayInitializerExpression(ExpressionCollection initializers);
    private void SetInitializers(ExpressionCollection initializers);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddInitializer(Expression initializer);
    public void AddInitializers(IEnumerable`1<Expression> initializers);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public ExpressionCollection get_Initializers();
    public void set_Initializers(ExpressionCollection value);
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IArrayInitializerExpression.get_Initializers();
}
public enum DevExpress.CodeParser.ArrayKindModifier : Enum {
    public int value__;
    public static ArrayKindModifier None;
    public static ArrayKindModifier GC;
    public static ArrayKindModifier NoGC;
}
public class DevExpress.CodeParser.ArrayNameModifier : LanguageElement {
    private int _Rank;
    private SourceRange _NameRange;
    private ExpressionCollection _SizeInitializers;
    public LanguageElementType ElementType { get; }
    public int Rank { get; public set; }
    public ExpressionCollection SizeInitializers { get; }
    public SourceRange NameRange { get; public set; }
    private IExpressionCollection DevExpress.CodeParser.IArrayNameModifier.SizeInitializers { get; }
    public ArrayNameModifier(int rank, ExpressionCollection sizeInitializers);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    public int get_Rank();
    public void set_Rank(int value);
    public ExpressionCollection get_SizeInitializers();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IArrayNameModifier.get_SizeInitializers();
}
public enum DevExpress.CodeParser.ArrayStorageClassQualifier : Enum {
    public int value__;
    public static ArrayStorageClassQualifier None;
    public static ArrayStorageClassQualifier Mutable;
    public static ArrayStorageClassQualifier Auto;
    public static ArrayStorageClassQualifier Register;
    public static ArrayStorageClassQualifier Static;
    public static ArrayStorageClassQualifier Const;
    public static ArrayStorageClassQualifier Volatile;
    public static ArrayStorageClassQualifier Extern;
}
public class DevExpress.CodeParser.AspCodeEmbedding : HtmlElement {
    private string _Code;
    private string _CodeToParse;
    private Token _CodeEmbeddingToken;
    private SourceRange _CodeRange;
    private bool _IsRazorEmbedding;
    internal Token CodeEmbeddingToken { get; internal set; }
    internal string CodeToParse { get; internal set; }
    public LanguageElementType ElementType { get; }
    public string Code { get; public set; }
    public SourceRange CodeRange { get; public set; }
    public bool IsRazorEmbedding { get; public set; }
    public bool IsFunctionsEmbedding { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual BaseElement Clone(ElementCloneOptions options);
    internal Token get_CodeEmbeddingToken();
    internal void set_CodeEmbeddingToken(Token value);
    internal string get_CodeToParse();
    internal void set_CodeToParse(string value);
    public virtual LanguageElementType get_ElementType();
    public virtual int GetImageIndex();
    public string get_Code();
    public void set_Code(string value);
    public SourceRange get_CodeRange();
    public void set_CodeRange(SourceRange value);
    public bool get_IsRazorEmbedding();
    public void set_IsRazorEmbedding(bool value);
    public virtual bool get_IsFunctionsEmbedding();
}
public class DevExpress.CodeParser.AspDirective : HtmlElement {
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AspElementBuilder : ElementBuilder {
    public virtual HtmlElement BuildHtmlElement(string name, bool isEmptyTag, bool hasCloseTag);
    public virtual HtmlText BuildHtmlText(string name);
    public virtual HtmlAttribute BuildHtmlAttribute(string name, string value, QuoteType quoteType, Expression exp);
    public virtual HtmlScriptDefinition BuildHtmlScriptDefinition(string scriptText, DotNetLanguageType languageType);
    public virtual HtmlStyleDefinition BuildHtmlStyleDefinition(string styleText, DotNetLanguageType languageType);
    public virtual AspDirective BuildAspDirective(string name);
    public virtual AspCodeEmbedding BuildAspCodeEmbedding(string code);
    public virtual BaseXmlNode BuildBaseXmlNode(string name);
    public virtual XmlDecl BuildXmlDecl(string version, string encording, string standAlone);
    public virtual NewExternalIDSystemLink BuildNewExternalIDSystemLink(string systemURI);
    public virtual NewExternalIDPublicLink BuildNewExternalIDPublicLink(string systemURI, string publicID);
    public virtual XmlDocTypeDecl BuildXmlDocTypeDecl(string name);
    public virtual XmlElementDecl BuildXmlElementDecl(string name);
    public virtual XmlEmptyContentSpec BuildXmlEmptyContentSpec();
    public virtual XmlAnyContentSpec BuildXmlAnyContentSpec();
    public virtual XmlMixedContentSpec BuildXmlMixedContentSpec();
    public virtual XmlName BaseXmlName(string name);
    public virtual XmlNameReference BuildXmlNameReference(string name);
    public virtual XmlNamedContentParticle BuildXmlNamedContentParticle();
    public virtual XmlChoiceContentParticle BuildXmlChoiceContentParticle(RepeatCount repeatCount);
    public virtual XmlSequenceContentParticle BuildXmlSequenceContentParticle(RepeatCount repeatCount);
    public virtual XmlChildrenContentSpec BuildXmlChildrenContentSpec();
    public virtual XmlChildrenContentSpec BuildXmlChildrenContentSpec(XmlContentParticle source);
    public virtual XmlNotationDecl BuildXmlNotationDecl(string name, NewExternalIDLink notationLink);
    public virtual XmlAttributeListDeclaration BuildXmlAttributeListDeclaration(string name);
    public virtual XmlAttribute BuildXmlAttribute(string name, string value);
    public virtual XmlAttributeDeclaration BuildXmlAttributeDeclaration(string name, AttributeType attributeType, DefaultAttributeValueType defaultAttributeValueType, string defaultAttributeValue);
    public virtual XmlEntityDecl BuildXmlEntityDecl(string name, bool isParameterEntity, string immediateValue, NewExternalIDLink externalLinkValue, string nDataValue);
    public virtual XmlProcessingInstruction BuildXmlProcessingInstruction(string name, string instructionText);
    public virtual XmlCharReference BuildXmlCharReference(string name);
    public virtual XmlReference BuildXmlReference(string name);
    public virtual XmlCharacterData BuildXmlCharacterData(string name);
    public virtual CssStyleSheet BuildCssStyleSheet();
    public virtual CssStyleRule BuildCssStyleRule();
    public virtual CssPropertyDeclaration BuildCssPropertyDeclaration(string name, bool isEqual, bool isImport);
    public virtual CssSelector BuildCssSelector(string name, CssSelectorType selectorType, CssSelector ancestor);
    public virtual CssAttributeSelector BuildCssAttributeSelector(string name, string value, AttributeSelectorEqualityType equalityType);
    public virtual CssAttributeSelector BuildCssAttributeSelector(string name, string value, AttributeSelectorEqualityType equalityType, bool isStringValue);
    public virtual CssPseudoSelector BuildCssPseudoSelector(string name);
    public virtual CssPseudoFunctionSelector BuildCssPseudoFunctionSelector(string name, string param);
    public virtual CssIdentifierReference BuildCssIdentifierReference(string name, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssFunctionReference BuildCssFunctionReference(string name, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssStringLiteral BuildCssStringLiteral(string name, string value, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssURIReference BuildCssURIReference(string name, string URI, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssColorReference BuildCssColorReference(string name, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssNumberLiteral BuildCssNumberLiteral(string name, object value, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssLengthLiteral BuildCssLengthLiteral(string name, object value, CssMeasureUnit unit, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssPercentLiteral BuildCssPercentLiteral(string name, object value, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssTimeLiteral BuildCssTimeLiteral(string name, object value, CssMeasureUnit unit, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssAngleLiteral BuildCssAngleLiteral(string name, object value, CssMeasureUnit unit, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssFrequencyLiteral BuildCssFrequencyLiteral(string name, object value, CssMeasureUnit unit, ExpressionDelimiter delimiter, PrecedingSign precedingSign);
    public virtual CssCharsetDeclaration BuildCssCharsetDeclaration(string charset);
    public virtual CssImportDirective BuildCssImportDirective(string source);
    public virtual CssMediaDirective BuildCssMediaDirective();
    public virtual CssPageStyle BuildCssPageStyle(string name);
    public virtual CssCommentTag BuildCssCommentTag(CommentTagKind kind);
    public virtual XmlElement BuildXmlElement(string name);
    public HtmlAttribute AddHtmlAttribute(HtmlElement parent, string attributeName, string attributeValue, QuoteType attributeQuoteType, Expression attributeExp);
    public XmlAttributeDeclaration AddXmlAttribute(XmlAttributeListDeclaration parent, string attributeName, AttributeType attributeType, DefaultAttributeValueType defaultAttributeValueType, string defaultAttributeValue);
    public XmlAttribute AddXmlAttribute(XmlElement parent, string attributeName, string attributeValue);
    public CssAttributeSelector AddXmlAttribute(XmlElement parent, string attributeName, string attributeValue, AttributeSelectorEqualityType attributeEqualityType, bool isStringAttributeValue);
    public CssAttributeSelector AddXmlAttribute(XmlElement parent, string attributeName, string attributeValue, AttributeSelectorEqualityType attributeEqualityType);
    public XmlElement AddXmlElement(LanguageElement parent, string xmlElementName);
    public HtmlElement AddHtmlElement(LanguageElement parent, string htmlElementName, bool isEmptyHtmlTag, bool hasCloseHtmlTag);
    public Comment AddHtmlComment(string commentText);
}
public class DevExpress.CodeParser.AspImportDirective : AspDirective {
    public LanguageElementType ElementType { get; }
    public string Namespace { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Namespace();
    public void set_Namespace(string value);
}
public class DevExpress.CodeParser.AssemblerStatement : Statement {
    private AssemblerStatementType _StatementType;
    private string _AssemblerCode;
    public string AssemblerCode { get; public set; }
    public AssemblerStatementType StatementType { get; public set; }
    public LanguageElementType ElementType { get; }
    public AssemblerStatement(string assemblerCode);
    public AssemblerStatement(string assemblerCode, AssemblerStatementType statementType);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public string get_AssemblerCode();
    public void set_AssemblerCode(string value);
    public AssemblerStatementType get_StatementType();
    public void set_StatementType(AssemblerStatementType value);
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public enum DevExpress.CodeParser.AssemblerStatementType : Enum {
    public int value__;
    public static AssemblerStatementType OldSyntaxAsmSingle;
    public static AssemblerStatementType OldSyntaxAsmDouble;
    public static AssemblerStatementType NewSyntaxAsm;
}
public class DevExpress.CodeParser.Assignment : Statement {
    private static int INT_MaintainanceComplexity;
    private Expression _LeftSide;
    private SourceTextRange _Operator;
    private AssignmentOperatorType _AssignmentOperatorType;
    private Expression _Expression;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    [DescriptionAttribute("Left side of the assignment statement.")]
[CategoryAttribute("Details")]
public Expression LeftSide { get; public set; }
    [DescriptionAttribute("Gets assignment operator.")]
[CategoryAttribute("Details")]
public SourceTextRange Operator { get; public set; }
    public AssignmentOperatorType AssignmentOperator { get; public set; }
    [ObsoleteAttribute("Use AssignmentOperator instead.")]
[EditorBrowsableAttribute("1")]
public AssignmentOperatorType AssignmentOperatorType { get; public set; }
    [DescriptionAttribute("Right side of the assignment statement.")]
[CategoryAttribute("Details")]
public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IAssignmentStatement.LeftSide { get; }
    private IExpression DevExpress.CodeParser.IAssignmentStatement.Expression { get; }
    private AssignmentOperatorType DevExpress.CodeParser.IAssignmentStatement.AssignmentOperator { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public void SetLeftSide(Expression left);
    [EditorBrowsableAttribute("1")]
public void SetExpression(Expression exp);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public static Assignment FromAssignmentExpression(AssignmentExpression expression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_LeftSide();
    public void set_LeftSide(Expression value);
    public SourceTextRange get_Operator();
    public void set_Operator(SourceTextRange value);
    public AssignmentOperatorType get_AssignmentOperator();
    public void set_AssignmentOperator(AssignmentOperatorType value);
    public AssignmentOperatorType get_AssignmentOperatorType();
    public void set_AssignmentOperatorType(AssignmentOperatorType value);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IAssignmentStatement.get_LeftSide();
    private sealed virtual override IExpression DevExpress.CodeParser.IAssignmentStatement.get_Expression();
    private sealed virtual override AssignmentOperatorType DevExpress.CodeParser.IAssignmentStatement.get_AssignmentOperator();
}
public class DevExpress.CodeParser.AssignmentExpression : BinaryOperatorExpression {
    private static int INT_MaintainanceComplexity;
    private AssignmentOperatorType _AssignmentOperatorType;
    protected int ThisMaintenanceComplexity { get; }
    public bool CanBeStatement { get; }
    public AssignmentOperatorType AssignmentOperator { get; public set; }
    [ObsoleteAttribute("Use AssignmentOperator instead.")]
[EditorBrowsableAttribute("1")]
public AssignmentOperatorType AssignmentOperatorType { get; public set; }
    public LanguageElementType ElementType { get; }
    private AssignmentOperatorType DevExpress.CodeParser.IAssignmentExpression.AssignmentOperatorType { get; }
    public AssignmentExpression(Expression left, string operatorText, Expression right);
    public AssignmentExpression(Expression left, Token token, Expression right);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual bool get_CanBeStatement();
    public AssignmentOperatorType get_AssignmentOperator();
    public void set_AssignmentOperator(AssignmentOperatorType value);
    public AssignmentOperatorType get_AssignmentOperatorType();
    public void set_AssignmentOperatorType(AssignmentOperatorType value);
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override AssignmentOperatorType DevExpress.CodeParser.IAssignmentExpression.get_AssignmentOperatorType();
}
public enum DevExpress.CodeParser.AssignmentOperatorType : Enum {
    public byte value__;
    public static AssignmentOperatorType None;
    public static AssignmentOperatorType Assignment;
    public static AssignmentOperatorType PlusEquals;
    public static AssignmentOperatorType MinusEquals;
    public static AssignmentOperatorType StarEquals;
    public static AssignmentOperatorType SlashEquals;
    public static AssignmentOperatorType BackSlashEquals;
    public static AssignmentOperatorType PercentEquals;
    public static AssignmentOperatorType BitAndEquals;
    public static AssignmentOperatorType BitOrEquals;
    public static AssignmentOperatorType XorEquals;
    public static AssignmentOperatorType ShiftLeftEquals;
    public static AssignmentOperatorType ShiftRightEquals;
    public static AssignmentOperatorType UnsignedShiftRightEquals;
}
public class DevExpress.CodeParser.AssociativeContainerExpression : Expression {
    private ExpressionCollection _Expressions;
    public ExpressionCollection Expressions { get; }
    public AssociativeContainerExpression(ExpressionCollection expressions);
    private void SetAssociativeRange();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public void AttachToSourceTree();
    public void DetachFromSourceTree();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public ExpressionCollection get_Expressions();
}
public class DevExpress.CodeParser.AtgCode : BaseAtgElement {
    private SourceRange _BlockStart;
    private SourceRange _BlockEnd;
    public SourceRange BlockStart { get; public set; }
    public SourceRange BlockEnd { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void UpdateRanges();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public SourceRange get_BlockStart();
    public void set_BlockStart(SourceRange value);
    public SourceRange get_BlockEnd();
    public void set_BlockEnd(SourceRange value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgCodeGenSetting : BaseAtgElement {
    private string _Value;
    public string Value { get; public set; }
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public string get_Value();
    public void set_Value(string value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgComplexFactor : AtgFactor {
    private ComplexFactorType _ComplexType;
    private AtgExpression _NestedExpression;
    private SourceRange _BlockStart;
    private SourceRange _BlockEnd;
    public SourceRange BlockStart { get; public set; }
    public SourceRange BlockEnd { get; public set; }
    public ComplexFactorType ComplexType { get; public set; }
    public AtgExpression NestedExpression { get; public set; }
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public SourceRange get_BlockStart();
    public void set_BlockStart(SourceRange value);
    public SourceRange get_BlockEnd();
    public void set_BlockEnd(SourceRange value);
    public ComplexFactorType get_ComplexType();
    public void set_ComplexType(ComplexFactorType value);
    public AtgExpression get_NestedExpression();
    public void set_NestedExpression(AtgExpression value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgExpression : BaseAtgElement {
    private AtgTerminalCollection _Terminals;
    public AtgTerminalCollection Terminals { get; }
    public int TerminalsCount { get; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public void AddTerminal(AtgTerminal terminal);
    public AtgTerminalCollection get_Terminals();
    public int get_TerminalsCount();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgFactor : NamedAtgElement {
    private bool _IsWeak;
    private bool _IsSync;
    private ExpressionCollection _Parameters;
    public ExpressionCollection Parameters { get; }
    public int ParametersCount { get; }
    public bool IsWeak { get; public set; }
    public bool IsSync { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddParameter(Expression parameter);
    public virtual string ToString();
    public ExpressionCollection get_Parameters();
    public int get_ParametersCount();
    public bool get_IsWeak();
    public void set_IsWeak(bool value);
    public bool get_IsSync();
    public void set_IsSync(bool value);
    public virtual LanguageElementType get_ElementType();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.AtgFactorCollection : NodeList {
    public AtgFactor Item { get; public set; }
    protected int Add(AtgFactor element);
    protected void AddRange(AtgFactorCollection collection);
    protected int IndexOf(AtgFactor element);
    protected void Insert(int index, AtgFactor element);
    protected void Remove(AtgFactor element);
    protected AtgFactor Find(AtgFactor element);
    protected bool Contains(AtgFactor element);
    protected virtual NodeList CreateInstance();
    public virtual string ToString();
    public AtgFactor get_Item(int index);
    public void set_Item(int index, AtgFactor value);
}
public class DevExpress.CodeParser.AtgFrame : BaseAtgElement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgParserDeclaration : BaseAtgElement {
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public class DevExpress.CodeParser.AtgParserRule : NamedAtgElement {
    private LanguageElementCollection _Parameters;
    public LanguageElementCollection Parameters { get; }
    public int ParametersCount { get; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public void AddParameter(LanguageElement parameter);
    public LanguageElementCollection get_Parameters();
    public int get_ParametersCount();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgProductions : BaseAtgElement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgResolver : BaseAtgElement {
    private Expression _Condition;
    public Expression Condition { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgTerminal : BaseAtgElement {
    private AtgResolver _Resolver;
    private AtgFactorCollection _Factors;
    public AtgResolver Resolver { get; public set; }
    public AtgFactorCollection Factors { get; }
    public int FactorsCount { get; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public AtgResolver get_Resolver();
    public void set_Resolver(AtgResolver value);
    public void AddFactor(AtgFactor factor);
    public AtgFactorCollection get_Factors();
    public int get_FactorsCount();
    public virtual LanguageElementType get_ElementType();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.AtgTerminalCollection : NodeList {
    public AtgTerminal Item { get; public set; }
    protected int Add(AtgTerminal element);
    protected void AddRange(AtgTerminalCollection collection);
    protected int IndexOf(AtgTerminal element);
    protected void Insert(int index, AtgTerminal element);
    protected void Remove(AtgTerminal element);
    protected AtgTerminal Find(AtgTerminal element);
    protected bool Contains(AtgTerminal element);
    protected virtual NodeList CreateInstance();
    public AtgTerminal get_Item(int index);
    public void set_Item(int index, AtgTerminal value);
}
public class DevExpress.CodeParser.AtgTokenAlias : NamedAtgElement {
    private string _AliasName;
    private SourceRange _AliasRange;
    public string AliasName { get; public set; }
    public SourceRange AliasRange { get; public set; }
    public LanguageElementType ElementType { get; }
    protected void SetAliasRange(SourceRange value);
    protected virtual void UpdateRanges();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void SetAlias(Token aliasToken);
    public virtual string ToString();
    public string get_AliasName();
    public void set_AliasName(string value);
    public SourceRange get_AliasRange();
    public void set_AliasRange(SourceRange value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgTokenDeclaration : NamedAtgElement {
    private bool _IsKeyword;
    public bool IsKeyword { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public bool get_IsKeyword();
    public void set_IsKeyword(bool value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgTokenNameSection : BaseAtgElement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AtgTokensSection : BaseAtgElement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.Attribute : SupportElement {
    private static int INT_MaintainanceComplexity;
    private TextRange _NameRange;
    private TextRange _ParensRange;
    private Expression _Qualifier;
    private ExpressionCollection _Arguments;
    private AttributeTargetType _TargetType;
    protected int ThisMaintenanceComplexity { get; }
    public Expression Qualifier { get; public set; }
    [EditorBrowsableAttribute("1")]
public Expression Source { get; public set; }
    public int ArgumentCount { get; }
    public ExpressionCollection Arguments { get; public set; }
    public AttributeTargetType TargetType { get; public set; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; public set; }
    public SourceRange ParensRange { get; public set; }
    private bool DevExpress.CodeParser.IAttributeElement.HasTargetNode { get; }
    private IExpressionCollection DevExpress.CodeParser.IAttributeElement.Arguments { get; }
    private IExpression DevExpress.CodeParser.IAttributeElement.Qualifier { get; }
    private IExpression DevExpress.CodeParser.IWithSource.Source { get; }
    private IExpressionCollection DevExpress.CodeParser.IWithArguments.Args { get; }
    private void SetQualifier(Expression qualifier);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddArgument(Expression argument);
    public void RemoveArgument(Expression argument);
    public void InsertArgument(int index, Expression argument);
    public static AttributeTargetType GetTargetTypeFromName(string name);
    protected virtual int get_ThisMaintenanceComplexity();
    public sealed virtual Expression get_Qualifier();
    public sealed virtual void set_Qualifier(Expression value);
    public sealed virtual Expression get_Source();
    public sealed virtual void set_Source(Expression value);
    public int get_ArgumentCount();
    public ExpressionCollection get_Arguments();
    public void set_Arguments(ExpressionCollection value);
    public sealed virtual AttributeTargetType get_TargetType();
    public void set_TargetType(AttributeTargetType value);
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public sealed virtual SourceRange get_ParensRange();
    public void set_ParensRange(SourceRange value);
    private sealed virtual override bool DevExpress.CodeParser.IAttributeElement.get_HasTargetNode();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IAttributeElement.get_Arguments();
    private sealed virtual override IExpression DevExpress.CodeParser.IAttributeElement.get_Qualifier();
    private sealed virtual override IExpression DevExpress.CodeParser.IWithSource.get_Source();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IWithArguments.get_Args();
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.AddArgument(IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.InsertArgument(int index, IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.RemoveArgument(IExpression argument);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.AttributeCollection : LanguageElementCollectionBase {
    public Attribute Item { get; public set; }
    public int Add(Attribute aAttribute);
    public int IndexOf(Attribute aAttribute);
    public void Insert(int index, Attribute aAttribute);
    public void Remove(Attribute aAttribute);
    public Attribute Find(Attribute aAttribute);
    public bool Contains(Attribute aAttribute);
    public Attribute get_Item(int index);
    public void set_Item(int index, Attribute value);
}
public class DevExpress.CodeParser.AttributeSection : SupportElement {
    private NodeList _AttributeCollection;
    private IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.Attributes { get; }
    public NodeList AttributeCollection { get; }
    public LanguageElementType ElementType { get; }
    private bool DevExpress.CodeParser.IAttributeSectionElement.HasTargetNode { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual void SetTarget(LanguageElement targetNode);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddAttribute(Attribute attribute);
    public void RemoveAttribute(Attribute attribute);
    private sealed virtual override IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.get_Attributes();
    public NodeList get_AttributeCollection();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override bool DevExpress.CodeParser.IAttributeSectionElement.get_HasTargetNode();
    private sealed virtual override void DevExpress.CodeParser.IHasAttributesModifier.AddAttribute(IAttributeElement attribute);
    private sealed virtual override void DevExpress.CodeParser.IHasAttributesModifier.RemoveAttribute(IAttributeElement attribute);
}
public enum DevExpress.CodeParser.AttributeSelectorEqualityType : Enum {
    public byte value__;
    public static AttributeSelectorEqualityType None;
    public static AttributeSelectorEqualityType ExactMatch;
    public static AttributeSelectorEqualityType SpaceSeparatedMatch;
    public static AttributeSelectorEqualityType HyphenSeparatedMatch;
    public static AttributeSelectorEqualityType BeginsWith;
    public static AttributeSelectorEqualityType EndsWith;
    public static AttributeSelectorEqualityType Contains;
}
public enum DevExpress.CodeParser.AttributeTargetType : Enum {
    public byte value__;
    public static AttributeTargetType None;
    public static AttributeTargetType Assembly;
    public static AttributeTargetType Field;
    public static AttributeTargetType Event;
    public static AttributeTargetType Method;
    public static AttributeTargetType Module;
    public static AttributeTargetType Param;
    public static AttributeTargetType Property;
    public static AttributeTargetType Return;
    public static AttributeTargetType Type;
    public static AttributeTargetType Class;
    public static AttributeTargetType Constructor;
    public static AttributeTargetType Delegate;
    public static AttributeTargetType Enum;
    public static AttributeTargetType Interface;
    public static AttributeTargetType Struct;
}
public enum DevExpress.CodeParser.AttributeType : Enum {
    public int value__;
    public static AttributeType Default;
    public static AttributeType Id;
    public static AttributeType CData;
    public static AttributeType IdRef;
    public static AttributeType IdRefs;
    public static AttributeType Entity;
    public static AttributeType Entities;
    public static AttributeType NmToken;
    public static AttributeType NmTokens;
    public static AttributeType Enumeration;
    public static AttributeType Notation;
}
public class DevExpress.CodeParser.AttributeVariableInitializer : BinaryOperatorExpression {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public AttributeVariableInitializer(Expression left, Token token, Expression right);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.AwaitExpression : Expression {
    private Expression _SourceExpression;
    public Expression SourceExpression { get; public set; }
    public LanguageElementType ElementType { get; }
    private IExpression DevExpress.CodeParser.IAwaitExpression.SourceExpression { get; }
    public AwaitExpression(Expression source);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual string ToString();
    public virtual void CleanUpOwnedReferences();
    public Expression get_SourceExpression();
    public void set_SourceExpression(Expression value);
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IExpression DevExpress.CodeParser.IAwaitExpression.get_SourceExpression();
}
public enum DevExpress.CodeParser.BackoutMode : Enum {
    public byte value__;
    public static BackoutMode NormalStatement;
    public static BackoutMode ElseStatement;
    public static BackoutMode CurlyBrace;
}
public class DevExpress.CodeParser.Base.TokenType : object {
    public static int UnknownToken;
    public static int Identifier;
    public static int Keyword;
    public static int Literal;
    public static int Operator;
    public static int Separator;
    public static int Eof;
    public static int Abstract;
    public static int Add;
    public static int AngleBracketClose;
    public static int AngleBracketOpen;
    public static int As;
    public static int Base;
    public static int Bool;
    public static int BracketClose;
    public static int BracketOpen;
    public static int Break;
    public static int Byte;
    public static int Case;
    public static int Catch;
    public static int Char;
    public static int Checked;
    public static int Class;
    public static int Colon;
    public static int Comma;
    public static int Const;
    public static int Continue;
    public static int CurlyBraceOpen;
    public static int CurlyBraceClose;
    public static int Decimal;
    public static int Default;
    public static int DefineDirective;
    public static int Delegate;
    public static int Do;
    public static int Dot;
    public static int Double;
    public static int ElifDirective;
    public static int Else;
    public static int ElseDirective;
    public static int EndifDirective;
    public static int EndRegion;
    public static int Enum;
    public static int EqualsSymbol;
    public static int ErrorDirective;
    public static int Event;
    public static int Explicit;
    public static int Extern;
    public static int False;
    public static int Finally;
    public static int Fixed;
    public static int Float;
    public static int For;
    public static int Foreach;
    public static int Get;
    public static int Goto;
    public static int If;
    public static int IfDirective;
    public static int Implicit;
    public static int In;
    public static int Int;
    public static int Interface;
    public static int Internal;
    public static int Is;
    public static int Label;
    public static int LineDirective;
    public static int Lock;
    public static int Long;
    public static int Namespace;
    public static int New;
    public static int Null;
    public static int Object;
    public static int Override;
    public static int Out;
    public static int ParenOpen;
    public static int ParenClose;
    public static int Params;
    public static int Private;
    public static int Protected;
    public static int Public;
    public static int Readonly;
    public static int Region;
    public static int Ref;
    public static int Rem;
    public static int Remove;
    public static int Return;
    public static int Sbyte;
    public static int Sealed;
    public static int SemiColon;
    public static int Set;
    public static int Short;
    public static int Sizeof;
    public static int Stackalloc;
    public static int Static;
    public static int String;
    public static int Struct;
    public static int Switch;
    public static int This;
    public static int Throw;
    public static int True;
    public static int Try;
    public static int Typeof;
    public static int Virtual;
    public static int Uint;
    public static int Ulong;
    public static int Unchecked;
    public static int UndefDirective;
    public static int Unsafe;
    public static int Ushort;
    public static int NamespaceReference;
    public static int Void;
    public static int Volatile;
    public static int WarningDirective;
    public static int While;
    public static int Asterisk;
    public static int Tilde;
    public static int Plus;
    public static int Minus;
    public static int Slash;
    public static int PercentSymbol;
    public static int XorSymbol;
    public static int ExclamationSymbol;
    public static int LessThan;
    public static int GreaterThan;
    public static int QuestionSymbol;
    public static int PlusPlus;
    public static int MinusMinus;
    public static int ShiftLeft;
    public static int ShiftRight;
    public static int DoubleEquals;
    public static int LessOrEqual;
    public static int GreaterOrEqual;
    public static int CharacterLiteral;
    public static int StringLiteral;
    public static int IntegerLiteral;
    public static int FloatingPointLiteral;
    public static int BitAnd;
    public static int BitOr;
    public static int AndAnd;
    public static int OrOr;
    public static int NotEquals;
    public static int PlusEqual;
    public static int MinusEqual;
    public static int MulEqual;
    public static int DivEqual;
    public static int ModEqual;
    public static int AndEqual;
    public static int OrEqual;
    public static int XorEqual;
    public static int ShiftLeftEqual;
    public static int ShiftRightEqual;
    public static int Arrow;
    public static int Comment;
    public static int SingleLineComment;
    public static int XmlComment;
    public static int SingleLineXmlComment;
    public static int MethodBody;
    public static int Module;
    public static int Partial;
    public static int Where;
    public static int Yield;
    public static int NullCoalescing;
    public static int AliasQualifier;
    public static int LineTerminator;
    public static int CBool;
    public static int CByte;
    public static int CChar;
    public static int CDate;
    public static int CDbl;
    public static int CDec;
    public static int Cint;
    public static int Clng;
    public static int Cobj;
    public static int Cshort;
    public static int Csng;
    public static int Cstr;
    public static int AspBlockStart;
    public static int AspBlockEnd;
    public static int AspCommentStatement;
    public static int DescendantStartIndex;
    protected static int GetTokenType(Type type, string name);
    protected static string GetTokenName(Type type, int token);
    public static int GetTokenType(string name);
    public static string GetTokenName(int type);
}
public abstract class DevExpress.CodeParser.BaseAtgElement : LanguageElement {
    public LanguageElementType ElementType { get; }
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.BaseCssElement : CodeElement {
    private SourceRange _NameRange;
    public SourceRange NameRange { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
}
public abstract class DevExpress.CodeParser.BaseElement : object {
    protected internal NodeList InnerNodes { get; }
    protected internal int InnerNodeCount { get; }
    protected internal NodeList InnerDetailNodes { get; }
    protected internal int InnerDetailNodeCount { get; }
    [DescriptionAttribute("The language elements parented by this element.")]
[CategoryAttribute("Family")]
public NodeList Nodes { get; }
    [DescriptionAttribute("The number of child language elements parented by this element.")]
[CategoryAttribute("Family")]
public int NodeCount { get; }
    [DescriptionAttribute("The detail language elements associated with this element.")]
[CategoryAttribute("Family")]
public NodeList DetailNodes { get; }
    [DescriptionAttribute("The number of detail language elements parented by this element.")]
[CategoryAttribute("Family")]
public int DetailNodeCount { get; }
    [DescriptionAttribute("The name of this language element.")]
[CategoryAttribute("Description")]
public string Name { get; public set; }
    private sealed virtual override object System.ICloneable.Clone();
    private SourceRange GetRangeFromNodes(NodeList nodes);
    [EditorBrowsableAttribute("2")]
protected void CleanUpOwnedReferencesForNodes(NodeList nodeList);
    [EditorBrowsableAttribute("2")]
protected virtual NodeList CreateNodeList();
    [EditorBrowsableAttribute("2")]
protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public SourceRange GetDetailNodeRange();
    [EditorBrowsableAttribute("1")]
public SourceRange GetNodeRange();
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    protected internal abstract virtual NodeList get_InnerNodes();
    protected internal int get_InnerNodeCount();
    protected internal abstract virtual NodeList get_InnerDetailNodes();
    protected internal int get_InnerDetailNodeCount();
    public abstract virtual NodeList get_Nodes();
    public int get_NodeCount();
    public abstract virtual NodeList get_DetailNodes();
    public int get_DetailNodeCount();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public class DevExpress.CodeParser.BaseReferenceExpression : Expression {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; }
    public BaseReferenceExpression(string name, SourceRange range);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
}
public class DevExpress.CodeParser.BaseVariable : Member {
    private static int INT_MaintainanceComplexity;
    private string _FullTypeName;
    private LanguageElementCollection _ArrayNameModifiers;
    private NullableTypeModifier _NullableModifier;
    private bool _IsImplicit;
    private bool _IsReturnedValue;
    private bool _IsLiteral;
    private bool _IsInitOnly;
    private SourceRange _OperatorRange;
    protected int ThisMaintenanceComplexity { get; }
    public ArrayList References { get; }
    public string FullTypeName { get; }
    public bool IsField { get; }
    public bool IsLocal { get; }
    public bool IsImplicit { get; public set; }
    public bool IsFixedSizeBuffer { get; }
    public bool IsReturnedValue { get; public set; }
    public MemberVisibility[] ValidVisibilities { get; }
    public LanguageElementType ElementType { get; }
    public LanguageElementCollection ArrayNameModifiers { get; }
    public bool HasArrayNameModifiers { get; }
    [DescriptionAttribute("Returns true if this variable declares bit field.")]
[CategoryAttribute("Family")]
public bool IsBitField { get; }
    [DescriptionAttribute("Gets or sets fixed size variable expression.")]
[CategoryAttribute("Family")]
public Expression BitFieldSize { get; }
    [EditorBrowsableAttribute("1")]
public IEnumerable AllVariables { get; }
    [EditorBrowsableAttribute("1")]
public IEnumerable AllStatements { get; }
    [EditorBrowsableAttribute("1")]
public IEnumerable AllFlowBreaks { get; }
    public bool IsLiteral { get; public set; }
    public bool IsInitOnly { get; public set; }
    public SourceRange OperatorRange { get; public set; }
    public bool HasIterationExpression { get; }
    public IExpression IterationExpression { get; }
    public bool IsObjectCreationInit { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsAspxTag { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsRunAtServer { get; public set; }
    public NullableTypeModifier NullableModifier { get; public set; }
    private bool DevExpress.CodeParser.IVariableDeclarationStatement.IsConst { get; }
    private IExpression DevExpress.CodeParser.IVariableDeclarationStatement.Expression { get; }
    private bool DevExpress.CodeParser.IVariableDeclarationStatement.IsBitField { get; }
    private IExpression DevExpress.CodeParser.IVariableDeclarationStatement.BitFieldSize { get; }
    private ICollection DevExpress.CodeParser.IHasArrayNameModifier.Modifiers { get; }
    private bool DevExpress.CodeParser.IBaseVariable.IsParameter { get; }
    private IExpression DevExpress.CodeParser.IBaseVariable.NameQualifier { get; }
    [IteratorStateMachineAttribute("DevExpress.CodeParser.BaseVariable/<GetBlockChildren>d__10")]
public sealed virtual IEnumerable`1<IElement> GetBlockChildren();
    private Expression GetIterationExpression();
    private LanguageElement GetParentAspxFieldOrHtmlAttribute();
    protected virtual ArrayList FindAllReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    public virtual MemberVisibility[] GetValidVisibilities();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public bool HasUsedReferences();
    public void AddArrayNameModifier(ArrayNameModifier modifier);
    public void AddArrayNameModifiers(IEnumerable`1<ArrayNameModifier> modifiers);
    protected void SetFullTypeName(string value);
    protected virtual int get_ThisMaintenanceComplexity();
    public ArrayList get_References();
    public string get_FullTypeName();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsLocal();
    public sealed virtual bool get_IsImplicit();
    public void set_IsImplicit(bool value);
    public virtual bool get_IsFixedSizeBuffer();
    public sealed virtual bool get_IsReturnedValue();
    public void set_IsReturnedValue(bool value);
    public virtual MemberVisibility[] get_ValidVisibilities();
    public virtual LanguageElementType get_ElementType();
    public LanguageElementCollection get_ArrayNameModifiers();
    public bool get_HasArrayNameModifiers();
    public virtual bool get_IsBitField();
    public virtual Expression get_BitFieldSize();
    public virtual IEnumerable get_AllVariables();
    public virtual IEnumerable get_AllStatements();
    public virtual IEnumerable get_AllFlowBreaks();
    public bool get_IsLiteral();
    public void set_IsLiteral(bool value);
    public bool get_IsInitOnly();
    public void set_IsInitOnly(bool value);
    public SourceRange get_OperatorRange();
    public void set_OperatorRange(SourceRange value);
    public sealed virtual bool get_HasIterationExpression();
    public sealed virtual IExpression get_IterationExpression();
    public virtual bool get_IsObjectCreationInit();
    public virtual void set_IsObjectCreationInit(bool value);
    public virtual bool get_IsAspxTag();
    public virtual void set_IsAspxTag(bool value);
    public virtual bool get_IsRunAtServer();
    public virtual void set_IsRunAtServer(bool value);
    public NullableTypeModifier get_NullableModifier();
    public void set_NullableModifier(NullableTypeModifier value);
    private sealed virtual override bool DevExpress.CodeParser.IVariableDeclarationStatement.get_IsConst();
    private sealed virtual override IExpression DevExpress.CodeParser.IVariableDeclarationStatement.get_Expression();
    private sealed virtual override bool DevExpress.CodeParser.IVariableDeclarationStatement.get_IsBitField();
    private sealed virtual override IExpression DevExpress.CodeParser.IVariableDeclarationStatement.get_BitFieldSize();
    private sealed virtual override ICollection DevExpress.CodeParser.IHasArrayNameModifier.get_Modifiers();
    private sealed virtual override bool DevExpress.CodeParser.IBaseVariable.get_IsParameter();
    private sealed virtual override IExpression DevExpress.CodeParser.IBaseVariable.get_NameQualifier();
}
public class DevExpress.CodeParser.BaseXmlNode : XmlNode {
    public XmlNodeType XmlNodeType { get; }
    public LanguageElementType ElementType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.BinaryOperatorExpression : OperatorExpression {
    private static int INT_MaintainanceComplexity;
    private BinaryOperatorType _Operator;
    private Expression _LeftSide;
    private Expression _RightSide;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression LeftSide { get; public set; }
    public BinaryOperatorType BinaryOperator { get; public set; }
    [ObsoleteAttribute("Use BinaryOperator instead.")]
[EditorBrowsableAttribute("1")]
public BinaryOperatorType Operator { get; public set; }
    public Expression RightSide { get; public set; }
    private IExpression DevExpress.CodeParser.IBinaryOperatorExpression.LeftSide { get; }
    private IExpression DevExpress.CodeParser.IBinaryOperatorExpression.RightSide { get; }
    public BinaryOperatorExpression(Expression left, Token token, Expression right);
    public BinaryOperatorExpression(Expression left, Expression right);
    public BinaryOperatorExpression(Expression left, string operatorText, Expression right);
    public BinaryOperatorExpression(Expression left, BinaryOperatorType operatorType, Expression right);
    protected void SetLeftSide(Expression left);
    protected void SetRightSide(Expression right);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual string GetDetailNodeDescription(int index);
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public static OperatorType GetOverloadableOperatorType(BinaryOperatorType binary);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_LeftSide();
    public void set_LeftSide(Expression value);
    public sealed virtual BinaryOperatorType get_BinaryOperator();
    public void set_BinaryOperator(BinaryOperatorType value);
    public BinaryOperatorType get_Operator();
    public void set_Operator(BinaryOperatorType value);
    public Expression get_RightSide();
    public void set_RightSide(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IBinaryOperatorExpression.get_LeftSide();
    private sealed virtual override IExpression DevExpress.CodeParser.IBinaryOperatorExpression.get_RightSide();
}
public enum DevExpress.CodeParser.BinaryOperatorType : Enum {
    public byte value__;
    public static BinaryOperatorType None;
    public static BinaryOperatorType Add;
    public static BinaryOperatorType Assign;
    public static BinaryOperatorType BitwiseAnd;
    public static BinaryOperatorType BitwiseOr;
    public static BinaryOperatorType BooleanAnd;
    public static BinaryOperatorType BooleanOr;
    public static BinaryOperatorType ExclusiveOr;
    public static BinaryOperatorType Divide;
    public static BinaryOperatorType GreaterThan;
    public static BinaryOperatorType GreaterThanOrEqual;
    public static BinaryOperatorType IdentityEquality;
    public static BinaryOperatorType IdentityInequality;
    public static BinaryOperatorType LessThan;
    public static BinaryOperatorType LessThanOrEqual;
    public static BinaryOperatorType Modulus;
    public static BinaryOperatorType Multiply;
    public static BinaryOperatorType Subtract;
    public static BinaryOperatorType ShiftLeft;
    public static BinaryOperatorType ShiftRight;
    public static BinaryOperatorType UnsignedShiftRight;
    public static BinaryOperatorType ValueEquality;
    public static BinaryOperatorType Like;
    public static BinaryOperatorType IntegerDivision;
    public static BinaryOperatorType Exponentiation;
    public static BinaryOperatorType StrictEquality;
    public static BinaryOperatorType StrictInequality;
    public static BinaryOperatorType In;
    public static BinaryOperatorType Concatenation;
    public static BinaryOperatorType PipeLeft;
    public static BinaryOperatorType PipeRight;
    public static BinaryOperatorType ComposeLeft;
    public static BinaryOperatorType ComposeRight;
    public static BinaryOperatorType Append;
    public static BinaryOperatorType Cons;
}
public class DevExpress.CodeParser.BitFieldConst : Const {
    private Expression _Size;
    public LanguageElementType ElementType { get; }
    public Expression Size { get; }
    public bool IsBitField { get; }
    public Expression BitFieldSize { get; }
    public BitFieldConst(string type, string name, Expression size);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Size();
    public virtual bool get_IsBitField();
    public virtual Expression get_BitFieldSize();
}
public class DevExpress.CodeParser.BitFieldVariable : Variable {
    private Expression _Size;
    public LanguageElementType ElementType { get; }
    public Expression Size { get; }
    public bool IsBitField { get; }
    public Expression BitFieldSize { get; }
    public BitFieldVariable(string type, string name, Expression size);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Size();
    public virtual bool get_IsBitField();
    public virtual Expression get_BitFieldSize();
}
public class DevExpress.CodeParser.BitFieldVolatile : Volatile {
    private Expression _Size;
    public LanguageElementType ElementType { get; }
    public Expression Size { get; }
    public bool IsBitField { get; }
    public Expression BitFieldSize { get; }
    public BitFieldVolatile(string type, string name, Expression size);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Size();
    public virtual bool get_IsBitField();
    public virtual Expression get_BitFieldSize();
}
public class DevExpress.CodeParser.Block : Statement {
    private bool _ForceDelimiters;
    public LanguageElementType ElementType { get; }
    public bool IsNewContext { get; }
    public bool ForceDelimiters { get; public set; }
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_IsNewContext();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public bool get_ForceDelimiters();
    public void set_ForceDelimiters(bool value);
}
[FlagsAttribute]
public enum DevExpress.CodeParser.BlockElements : Enum {
    public int value__;
    public static BlockElements None;
    public static BlockElements Attributes;
    public static BlockElements XmlDocComments;
    public static BlockElements SupportComments;
    public static BlockElements Region;
    public static BlockElements LeadingWhiteSpace;
    public static BlockElements TrailingWhiteSpace;
    public static BlockElements LeadingEmptyLines;
    public static BlockElements TrailingEmptyLines;
    public static BlockElements WithoutUnsuitableRegions;
    public static BlockElements AllSupportElements;
    public static BlockElements AllLeadingWhiteSpaces;
    public static BlockElements AllTrailingWhiteSpaces;
    public static BlockElements AllWhiteSpaces;
    public static BlockElements All;
}
public enum DevExpress.CodeParser.BraceHolder : Enum {
    public int value__;
    public static BraceHolder Unknown;
    public static BraceHolder Type;
    public static BraceHolder ArrayInitializer;
    public static BraceHolder AnonymousMethod;
    public static BraceHolder Method;
    public static BraceHolder ControlFlow;
}
public enum DevExpress.CodeParser.BracesOnNewLineOptions : Enum {
    public int value__;
    public static BracesOnNewLineOptions LeaveOnPrevious;
    public static BracesOnNewLineOptions PlaceOnNewLine;
}
public class DevExpress.CodeParser.Break : FlowBreak {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElement FindTarget();
}
public enum DevExpress.CodeParser.CallingConventionSpecifier : Enum {
    public int value__;
    public static CallingConventionSpecifier Default;
    public static CallingConventionSpecifier StdCall;
    public static CallingConventionSpecifier Cdecl;
    public static CallingConventionSpecifier FastCall;
    public static CallingConventionSpecifier ClrCall;
    public static CallingConventionSpecifier ThisCall;
    public static CallingConventionSpecifier Pascal;
    public static CallingConventionSpecifier Fortran;
    public static CallingConventionSpecifier SysCall;
    public static CallingConventionSpecifier Far;
    public static CallingConventionSpecifier Export;
    public static CallingConventionSpecifier Inline;
    public static CallingConventionSpecifier ForceInline;
}
public class DevExpress.CodeParser.CallStatement : Statement {
    private Expression _CalledExpression;
    public Expression CalledExpression { get; public set; }
    public LanguageElementType ElementType { get; }
    private IExpression DevExpress.CodeParser.ICallStatement.CalledExpression { get; }
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    public virtual string ToString();
    public Expression get_CalledExpression();
    public void set_CalledExpression(Expression value);
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IExpression DevExpress.CodeParser.ICallStatement.get_CalledExpression();
}
public class DevExpress.CodeParser.Case : ConditionalParentingStatement {
    private static int INT_MaintainanceComplexity;
    private bool _IsDefault;
    private Expression _Expression;
    private CaseClausesList _CaseClauses;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public bool IsDefault { get; public set; }
    public Expression Expression { get; public set; }
    public CaseClausesList CaseClauses { get; }
    private IExpression DevExpress.CodeParser.ICaseStatement.Expression { get; }
    private ICaseClausesList DevExpress.CodeParser.ICaseStatement.CaseClauses { get; }
    protected void SetExpression(Expression expression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public void SetEndPoint();
    public virtual int GetImageIndex();
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public sealed virtual bool get_IsDefault();
    public void set_IsDefault(bool value);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public CaseClausesList get_CaseClauses();
    public void AddCaseClause(CaseClause caseClause);
    public void AddCaseClauses(CaseClausesList clauses);
    private sealed virtual override IExpression DevExpress.CodeParser.ICaseStatement.get_Expression();
    private sealed virtual override ICaseClausesList DevExpress.CodeParser.ICaseStatement.get_CaseClauses();
}
public class DevExpress.CodeParser.CaseClause : LanguageElement {
    private static int INT_MaintainanceComplexity;
    private Expression _StartExpression;
    private Expression _EndExpression;
    private string _ComparisonOperator;
    private bool _IsComparison;
    private bool _IsFromToClause;
    protected int ThisMaintenanceComplexity { get; }
    public Expression StartExpression { get; public set; }
    public Expression EndExpression { get; public set; }
    public bool IsComparisonClause { get; public set; }
    public bool IsRangeCheckClause { get; public set; }
    public string ComparisonOperator { get; public set; }
    public LanguageElementType ElementType { get; }
    private IExpression DevExpress.CodeParser.ICaseClauseStatement.StartExpression { get; }
    private IExpression DevExpress.CodeParser.ICaseClauseStatement.EndExpression { get; }
    public bool HasDelimitedBlock { get; }
    public CaseClause(Expression startExpression, Expression endExpression);
    [IteratorStateMachineAttribute("DevExpress.CodeParser.CaseClause/<GetBlockChildren>d__8")]
public sealed virtual IEnumerable`1<IElement> GetBlockChildren();
    protected void SetStartExpression(Expression expression);
    protected void SetEndExpression(Expression expression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public Expression get_StartExpression();
    public void set_StartExpression(Expression value);
    public Expression get_EndExpression();
    public void set_EndExpression(Expression value);
    public bool get_IsComparisonClause();
    public void set_IsComparisonClause(bool value);
    public bool get_IsRangeCheckClause();
    public void set_IsRangeCheckClause(bool value);
    public string get_ComparisonOperator();
    public void set_ComparisonOperator(string value);
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IExpression DevExpress.CodeParser.ICaseClauseStatement.get_StartExpression();
    private sealed virtual override IExpression DevExpress.CodeParser.ICaseClauseStatement.get_EndExpression();
    public sealed virtual bool get_HasDelimitedBlock();
}
public class DevExpress.CodeParser.CaseClausesList : LanguageElement {
    private NodeList _Clauses;
    public NodeList Clauses { get; }
    public LanguageElementType ElementType { get; }
    private ICaseClauseCollection DevExpress.CodeParser.ICaseClausesList.Clauses { get; }
    public CaseClausesList(NodeList clauses);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public NodeList get_Clauses();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override ICaseClauseCollection DevExpress.CodeParser.ICaseClausesList.get_Clauses();
}
public class DevExpress.CodeParser.CastTargetExpression : TypeCastExpression {
    private Token _CastToken;
    private string _CastKeyword;
    private string _CastTypeName;
    public LanguageElementType ElementType { get; }
    public Token CastToken { get; }
    public string CastTypeName { get; public set; }
    public string CastKeyword { get; public set; }
    public CastTargetExpression(string castTypeName, string castKeyword, SourceRange castRange, Expression target);
    public CastTargetExpression(Token castToken, Expression target);
    public CastTargetExpression(TypeReferenceExpression type, Expression target);
    protected string GetTypeFromCastToken(Token token);
    protected string GetTypeCastKeyword(Token token);
    protected TypeReferenceExpression GetTypeReference(Token token);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Token get_CastToken();
    public string get_CastTypeName();
    public void set_CastTypeName(string value);
    public string get_CastKeyword();
    public void set_CastKeyword(string value);
}
public class DevExpress.CodeParser.Catch : ConditionalParentingStatement {
    private static int INT_MaintainanceComplexity;
    public string CatchesException;
    private LanguageElement _Exception;
    private LanguageElement _Condition;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public bool CompletesPrevious { get; }
    public LanguageElement Exception { get; public set; }
    public LanguageElement Condition { get; public set; }
    private IElement DevExpress.CodeParser.ICatchStatement.ExceptionVariable { get; }
    private IElement DevExpress.CodeParser.ICatchStatement.Condition { get; }
    public Catch(LanguageElement exception, LanguageElement condition);
    protected void SetException(LanguageElement expression);
    protected void SetCondition(LanguageElement expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public Finally GetFinally();
    public LanguageElement GetFinallyTarget();
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_CompletesPrevious();
    public LanguageElement get_Exception();
    public void set_Exception(LanguageElement value);
    public LanguageElement get_Condition();
    public void set_Condition(LanguageElement value);
    private sealed virtual override IElement DevExpress.CodeParser.ICatchStatement.get_ExceptionVariable();
    private sealed virtual override IElement DevExpress.CodeParser.ICatchStatement.get_Condition();
}
public class DevExpress.CodeParser.CategorizedToken : Token {
    private TokenCategory _Category;
    private TokenLanguage _Language;
    private bool _WasCheckedCategorizedToken;
    public bool WasCheckedCategorizedToken { get; public set; }
    public TokenCategory Category { get; public set; }
    public TokenLanguage Language { get; public set; }
    public CategorizedToken(TokenLanguage language);
    public CategorizedToken(int startPosition, int endPosition, int line, int column, int endLine, int endColumn, int tokenType, string value);
    public CategorizedToken(int startPosition, int endPosition, int line, int column, int endLine, int endColumn, int tokenType, string value, TokenCategory category);
    public CategorizedToken(int line, int column, int endLine, int endColumn, int tokenType, string value);
    public bool get_WasCheckedCategorizedToken();
    public void set_WasCheckedCategorizedToken(bool value);
    protected virtual void CloneDataFrom(Token source, ElementCloneOptions options);
    public string GetTokenCategory();
    public virtual Token Clone(ElementCloneOptions options);
    public TokenCategory get_Category();
    public void set_Category(TokenCategory value);
    public TokenLanguage get_Language();
    public void set_Language(TokenLanguage value);
}
public abstract class DevExpress.CodeParser.CExpressionCodeGenBase : ExpressionCodeGenBase {
    public CExpressionCodeGenBase(CodeGen codeGen);
    protected virtual string GetBinaryOperatorText(BinaryOperatorType operatorType);
    protected virtual bool GenerateMacroExpression(Expression expression);
    protected virtual void GenerateTypeReferenceExpressionName(TypeReferenceExpression expression);
    protected virtual void GenerateDateTimeMinValue();
    protected virtual void GenerateUnaryOperator(UnaryOperatorExpression expression, string op);
    protected virtual void GenerateTypedElementReferenceExpression(TypedElementReferenceExpression expression);
    protected virtual void GenerateExpressionTypeArgument(ExpressionTypeArgument expression);
    protected virtual void GenerateTypeOfIsExpression(TypeOfIsExpression expression);
    protected virtual void GenerateAttributeVariableInitializer(AttributeVariableInitializer expression);
    protected virtual void GenerateIsNot(IsNot expression);
    protected virtual void GenerateConditionalExpression(ConditionalExpression expression);
    protected virtual void GenerateThisReferenceExpression(ThisReferenceExpression expression);
    protected virtual void GenerateMyClassExpression(MyClassExpression expression);
    protected virtual void GenerateTypeReferenceExpression(TypeReferenceExpression expression);
    protected virtual void GenerateIndexerExpression(IndexerExpression expression);
    protected virtual void GenerateLogicalInversion(LogicalInversion expression);
    protected virtual void GenerateAddressOfExpression(AddressOfExpression expression);
    protected virtual void GenerateAssignmentExpression(AssignmentExpression expression);
    protected virtual void GenerateTypeCastExpression(TypeCastExpression expression);
    protected virtual void GenerateArrayInitializerExpression(ArrayInitializerExpression expression);
    protected virtual void GenerateUnaryIncrement(UnaryIncrement expression);
    protected virtual void GenerateUnaryDecrement(UnaryDecrement expression);
    protected virtual void GenerateArrayCreateExpression(ArrayCreateExpression expression);
    protected virtual void GenerateObjectCreationExpression(ObjectCreationExpression expression);
    protected virtual void GenerateAnonymousMethodExpression(AnonymousMethodExpression expression);
    protected virtual void GenerateDateTime(object value);
    protected virtual void GenerateSizeOfExpression(SizeOfExpression expression);
    protected virtual void GenerateFunctionPointerTypeReference(FunctionPointerTypeReference expression);
    public static void GenerateAssignmentOperatorText(CodeWriter codeWriter, AssignmentOperatorType op);
}
public class DevExpress.CodeParser.CharProvider : object {
    private static char EOL;
    private TextReader _Reader;
    private CharListItem _CharsQueueHead;
    private CharListItem _PeekCharPosition;
    private string _Str;
    public bool HasPeekedChars { get; }
    public CharProvider(TextReader reader);
    protected char ReadChar();
    public char Get();
    public void Seek(int position);
    public char Peek();
    public void ResetPeek();
    public void Close();
    public bool get_HasPeekedChars();
}
internal class DevExpress.CodeParser.CharReader : TextReader {
    private string _Str;
    private int _Position;
    public int Length { get; }
    public int Position { get; public set; }
    public CharReader(string s);
    public int get_Length();
    public int get_Position();
    public void set_Position(int value);
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    public virtual string ReadToEnd();
}
public class DevExpress.CodeParser.CharUtils : object {
    private static SymbolType ResolveSymbol(char ch);
    public static char Translate(char c);
    public static bool IsNewLine(char ch);
    public static bool IsNewLine(string s);
    public static bool IsWhiteSpace(char ch);
    public static bool IsLetter(char ch);
    public static bool IsDigit(char ch);
    public static bool IsLetterOrDigit(char ch);
}
public class DevExpress.CodeParser.Checked : ParentingStatement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.CheckedExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _Exp;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.ICheckedExpression.Expression { get; }
    public CheckedExpression(Expression expression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    private void SetExpression(Expression expression);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.ICheckedExpression.get_Expression();
}
public class DevExpress.CodeParser.CheckedIndent : FormattingElement {
    private int _SpaceCount;
    public int SpaceCount { get; }
    public CheckedIndent(int tabCount, int spaceCount);
    public int get_SpaceCount();
}
public class DevExpress.CodeParser.ChildrenEnumerator : object {
    private IElementFilter _Filter;
    private bool _IsInStart;
    private LanguageElement _StartNode;
    private LanguageElement _CurrentNode;
    public object Current { get; }
    public ChildrenEnumerator(LanguageElement start);
    public ChildrenEnumerator(LanguageElement start, IElementFilter filter);
    private bool ApplyFilter(LanguageElement node);
    private LanguageElement GetNextNode(LanguageElement node);
    private LanguageElement GetFirstChild(LanguageElement node);
    private LanguageElement GetStartNode(LanguageElement node);
    private bool GetNextFilteredNode(LanguageElement& node);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
}
public class DevExpress.CodeParser.Class : TypeDeclaration {
    private string _AncestorName;
    private StringCollection _Implements;
    public LanguageElementType ElementType { get; }
    public bool IsNewContext { get; }
    [EditorBrowsableAttribute("1")]
[DescriptionAttribute("Gets the name of the ancestor class.")]
[CategoryAttribute("Family")]
public string AncestorName { get; public set; }
    [EditorBrowsableAttribute("1")]
[DescriptionAttribute("Gets names of the implemented interfaces.")]
[CategoryAttribute("Family")]
public StringCollection Implements { get; }
    public Class(string name);
    public bool AncestorDeclaresMember(LanguageElement member);
    public bool DeclaresMember(LanguageElement member);
    public virtual LanguageElement GetMostComplexMember();
    public virtual double GetAverageCyclomaticComplexity();
    public virtual int GetImageIndex();
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual MemberVisibility[] GetValidVisibilities();
    public virtual bool RangeIsClean(SourceRange sourceRange);
    public virtual string GetTypeName();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_IsNewContext();
    [EditorBrowsableAttribute("1")]
public Class GetAncestor();
    [EditorBrowsableAttribute("1")]
public LanguageElementList GetImplements();
    public string get_AncestorName();
    public void set_AncestorName(string value);
    public StringCollection get_Implements();
}
public class DevExpress.CodeParser.ClassTemplateParameter : TemplateParameter {
    public LanguageElementType ElementType { get; }
    private TypeParameterDirection DevExpress.CodeParser.ITypeParameter.Direction { get; }
    public ClassTemplateParameter(string name, Expression defaultValue);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override TypeParameterDirection DevExpress.CodeParser.ITypeParameter.get_Direction();
}
public class DevExpress.CodeParser.ClassTypeParameter : CppTypeParameter {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ClassTypeParameterConstraint : TypeParameterConstraint {
    public LanguageElementType ElementType { get; }
    public ClassTypeParameterConstraint(string name, SourceRange range);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.CodeDomGeneratorHelper : object {
    private static string STR_WrapperName;
    private static string STR_CurrentClassField;
    private static string STR_OutputField;
    private static string STR_OptionsField;
    private static string STR_GenerateMethod;
    private static string STR_GenerateProperty;
    private static string STR_GenerateEvent;
    private static string STR_GenerateField;
    private static string STR_GenerateConstructor;
    private static string STR_GenerateEntryPointMethod;
    private static string STR_GenerateTypeConstructor;
    private static string STR_GenerateAttributes;
    private CodeDomProvider _CodeProvider;
    private CodeGeneratorOptions _Options;
    public CodeDomProvider CodeProvider { get; public set; }
    public CodeGeneratorOptions Options { get; public set; }
    private CodeGenerator CodeGenerator { get; }
    private object CodeGeneratorAsObject { get; }
    private ICodeGenerator ICodeGenerator { get; }
    public CodeDomGeneratorHelper(CodeDomProvider provider, CodeGeneratorOptions options);
    private Object[] GetCodeGenMethodParameters(CodeGenParameterUsage usage, CodeObject target, CodeTypeDeclaration wrapper, Object[] parameters);
    private void SetCodeGenContext(CodeTypeDeclaration type, CodeGenerationContext context);
    private CodeTypeDeclaration GetCodeTypeWrapper(CodeObject target, CodeGenerationContext context);
    private void GetGeneratorTypeAndObject(Type& type, Object& generator);
    private void InvokeMethod(Type type, object target, string method, Object[] args);
    private void SetFieldValue(Type type, object target, string field, object value);
    private void PrepareGenerator(Type type, object generator, CodeTypeDeclaration wrapper, TextWriter output);
    private void GenerateField(CodeObject target, TextWriter output, bool isEnum);
    private void GenerateCode(string methodName, TextWriter output, Object[] parameters);
    private void GenerateCode(string methodName, CodeObject target, TextWriter output);
    private void GenerateCode(string methodName, CodeObject target, CodeGenerationContext context, TextWriter output);
    private void GenerateCode(string methodName, CodeObject target, TextWriter output, CodeGenerationContext context, CodeGenParameterUsage usage, Object[] parameters);
    public string GenerateCode(CodeCompileUnit unit);
    public void GenerateCode(CodeCompileUnit unit, TextWriter output);
    public string GenerateCode(CodeNamespace space);
    public void GenerateCode(CodeNamespace space, TextWriter output);
    public string GenerateCode(CodeTypeDeclaration type);
    public void GenerateCode(CodeTypeDeclaration type, TextWriter output);
    public string GenerateCode(CodeMemberEvent e);
    public void GenerateCode(CodeMemberEvent e, TextWriter output);
    public string GenerateCode(CodeMemberField field);
    public void GenerateCode(CodeMemberField field, TextWriter output);
    public string GenerateCode(CodeMemberField field, bool isEnum);
    public void GenerateCode(CodeMemberField field, bool isEnum, TextWriter output);
    public string GenerateCode(CodeMemberMethod method);
    public string GenerateCode(CodeMemberMethod method, CodeGenerationContext context);
    public void GenerateCode(CodeMemberMethod method, TextWriter output);
    public void GenerateCode(CodeMemberMethod method, CodeGenerationContext context, TextWriter output);
    public string GenerateCode(CodeConstructor constructor);
    public void GenerateCode(CodeConstructor constructor, TextWriter output);
    public string GenerateCode(CodeTypeConstructor constructor);
    public void GenerateCode(CodeTypeConstructor constructor, TextWriter output);
    public string GenerateCode(CodeEntryPointMethod method);
    public void GenerateCode(CodeEntryPointMethod method, TextWriter output);
    public string GenerateCode(CodeMemberProperty property);
    public string GenerateCode(CodeMemberProperty property, CodeGenerationContext context);
    public void GenerateCode(CodeMemberProperty property, TextWriter output);
    public void GenerateCode(CodeMemberProperty property, CodeGenerationContext context, TextWriter output);
    public string GenerateCode(CodeStatement statement);
    public void GenerateCode(CodeStatement statement, TextWriter output);
    public string GenerateCode(CodeExpression expression);
    public void GenerateCode(CodeExpression expression, TextWriter output);
    public string GenerateCode(CodeAttributeDeclarationCollection attributes);
    public void GenerateCode(CodeAttributeDeclarationCollection attributes, TextWriter output);
    public CodeDomProvider get_CodeProvider();
    public void set_CodeProvider(CodeDomProvider value);
    public CodeGeneratorOptions get_Options();
    public void set_Options(CodeGeneratorOptions value);
    private CodeGenerator get_CodeGenerator();
    private object get_CodeGeneratorAsObject();
    private ICodeGenerator get_ICodeGenerator();
}
public abstract class DevExpress.CodeParser.CodeElement : LanguageElement {
    private SupportElements _SupportElements;
    private SupportElements SupportElements { get; }
    public IEnumerable AllExpressions { get; }
    [DescriptionAttribute("Gets an ArrayList of Attributes for this element.")]
[CategoryAttribute("SupportElements")]
public NodeList Attributes { get; }
    [DescriptionAttribute("The number of Attributes associated with this element.")]
[CategoryAttribute("SupportElements")]
public int AttributeCount { get; }
    [DescriptionAttribute("Gets an ArrayList of AttributeSections for this element.")]
[CategoryAttribute("SupportElements")]
public NodeList AttributeSections { get; }
    [DescriptionAttribute("The number of AttributeSections associated with this element.")]
[CategoryAttribute("SupportElements")]
public int AttributeSectionsCount { get; }
    [DescriptionAttribute("A create-on-demand collection of comments bound to this element.")]
[CategoryAttribute("SupportElements")]
public CommentCollection Comments { get; }
    [DescriptionAttribute("The number of comments bound to this element.")]
[CategoryAttribute("SupportElements")]
public int CommentCount { get; }
    [DescriptionAttribute("Gets xml doc comment associated with this element.")]
[CategoryAttribute("SupportElements")]
public XmlDocComment DocComment { get; }
    public LanguageElement FirstNode { get; }
    public LanguageElement LastNode { get; }
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    [EditorBrowsableAttribute("1")]
public void TransferCommentsTo(CodeElement element);
    [EditorBrowsableAttribute("1")]
public void TransferXmlDocCommentTo(CodeElement element);
    [EditorBrowsableAttribute("1")]
public void SetDocComment(XmlDocComment value);
    [EditorBrowsableAttribute("1")]
public int SkipStartSupportElement(LanguageElement start, SupportElement support);
    [EditorBrowsableAttribute("1")]
public int SkipEndSupportElement(LanguageElement start, SupportElement support);
    [EditorBrowsableAttribute("1")]
public void SetAttributes(LanguageElementCollection attributes);
    [EditorBrowsableAttribute("1")]
protected void SetAttributes(NodeList attributes);
    [EditorBrowsableAttribute("1")]
public void InsertSupportElement(SupportElement element, NodeList& nodeList, Int32& index);
    public void AddAttributeSection(AttributeSection section);
    private void GetSupportElementNodeListAndIndex(SupportElement element, NodeList& nodeList, Int32& index);
    private void AddSupportElemetIfOwningListIsNull(SupportElement element);
    private void CollectAttributes(NodeList sections);
    private void AddAttributes(AttributeSection section);
    private void AddAttributeSections(NodeList sections);
    private void SetAttributeSections(NodeList sections);
    private LanguageElement GetElementToInsertBefore(NodeList nodes, SupportElement support);
    private void RestoreSupportElementLinks(NodeList nodeList, NodeList sourceNodeList);
    private void RestoreSupportElementLinks(CodeElement source);
    private void GetSupportNodes(LanguageElement& topSupportElement, LanguageElement& bottomSupportElement);
    private SupportElements get_SupportElements();
    [EditorBrowsableAttribute("2")]
protected LanguageElement GetLanguageElementLink(LanguageElement source);
    [EditorBrowsableAttribute("2")]
protected SupportElement GetSupportElementLink(SupportElement source);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    [EditorBrowsableAttribute("2")]
public void AddSupportElement(SupportElement element);
    [EditorBrowsableAttribute("1")]
public void AddComment(Comment comment);
    public void AddComment(Comment comment, bool useSorting);
    [EditorBrowsableAttribute("1")]
public void RemoveComment(Comment element);
    public void AddCommentNode(Comment comment);
    public Attribute FindAttribute(string name);
    public IEnumerable get_AllExpressions();
    public NodeList get_Attributes();
    public int get_AttributeCount();
    public NodeList get_AttributeSections();
    public int get_AttributeSectionsCount();
    public CommentCollection get_Comments();
    public int get_CommentCount();
    public XmlDocComment get_DocComment();
    public LanguageElement get_FirstNode();
    public LanguageElement get_LastNode();
}
public abstract class DevExpress.CodeParser.CodeGen : CodeGenObject {
    private LanguageElement _FirstElement;
    private CodeGenOptions _Options;
    private DirectiveCodeGenBase _DirectiveGen;
    private ExpressionCodeGenBase _ExpressionGen;
    private MemberCodeGenBase _MemberGen;
    private StatementCodeGenBase _StatementGen;
    private SupportElementCodeGenBase _SupportElementGen;
    private TypeDeclarationCodeGenBase _TypeDeclarationGen;
    private XmlCodeGenBase _XmlGen;
    private NamespaceReferenceGenBase _NamespaceReferenceGen;
    private NamespaceGenBase _NamespaceGen;
    private SnippetCodeGenBase _SnippetGen;
    private TemplateCodeGenBase _TemplateGen;
    private TemplateParameterCodeGenBase _TemplateParameterGen;
    private SourceFileCodeGenBase _SourceFileGen;
    private HtmlXmlCodeGenBase _HtmlXmlCodeGen;
    private GeneratingElements _Contexts;
    private FormattingTokenGen _TokenGen;
    private bool _GenCommentsFromToken;
    private List`1<LanguageElement> _GeneratedElements;
    internal FormattingTokenGen TokenGen { get; }
    internal FormattingTable FormattingTable { get; }
    internal GeneratingElements Contexts { get; }
    public LanguageElement Context { get; }
    public TemplateParameterCodeGenBase TemplateParameterGen { get; }
    public SourceFileCodeGenBase SourceFileGen { get; }
    public TemplateCodeGenBase TemplateGen { get; }
    public DirectiveCodeGenBase DirectiveGen { get; }
    public ExpressionCodeGenBase ExpressionGen { get; }
    public MemberCodeGenBase MemberGen { get; }
    public SupportElementCodeGenBase SupportElementGen { get; }
    public StatementCodeGenBase StatementGen { get; }
    public TypeDeclarationCodeGenBase TypeDeclarationGen { get; }
    public XmlCodeGenBase XmlGen { get; }
    public NamespaceReferenceGenBase NamespaceReferenceGen { get; }
    public NamespaceGenBase NamespaceGen { get; }
    public SnippetCodeGenBase SnippetGen { get; }
    public CodeGenOptions Options { get; }
    [EditorBrowsableAttribute("1")]
public bool GenCommentsFromToken { get; public set; }
    public HtmlXmlCodeGenBase HtmlXmlCodeGen { get; }
    public bool GeneratingInSupportElement { get; public set; }
    public CodeGen(CodeGenOptions options);
    private bool PrevContextHasAttributeSection(AttributeSection section);
    private bool IsSecondaryAncestorTypeReference(LanguageElement context, TypeDeclaration type);
    private bool IsAncestorTypeReference(LanguageElement context, TypeDeclaration type);
    private bool IsHandlesExpression(LanguageElement context, Member parent);
    private bool IsImplementsExpression(LanguageElement context, Member member);
    private bool IsFirst(Variable var);
    private bool IsLast(Variable var);
    private bool IsNotFirst(Variable var);
    private string GetTokenText(FormattingTokenType type, LanguageElement fromElement);
    protected Expression[] GetBinaryList(BinaryOperatorExpression oper);
    protected virtual bool NeedIndenting(LanguageElement element, bool pushed);
    private Expression[] GetBinaryList(LanguageElement element);
    protected void Alignment(LanguageElement context, bool pushed);
    protected void AddDecreaseAlignment();
    protected bool IsFirst(NodeList coll, LanguageElement element);
    protected bool IsLast(NodeList coll, LanguageElement element);
    protected bool IsNotFirst(NodeList coll, LanguageElement element);
    protected virtual bool IsFirst(LanguageElement context);
    protected virtual bool IsLast(LanguageElement context);
    protected virtual bool IsNotFirst(LanguageElement element);
    protected virtual bool NeedWrapWithoutFirst(LanguageElement context);
    protected virtual bool NeedWrapFirst(LanguageElement context);
    protected virtual bool NeedAlignment(LanguageElement context, bool pushed);
    protected virtual bool IsFirstTypeAncestor(LanguageElement context, TypeDeclaration type);
    protected virtual void AddWrappingNewLine();
    protected virtual void InitializeCodeGenObjects();
    protected virtual void ContextPushed();
    protected virtual void ContextPoped(LanguageElement oldContext);
    protected virtual SourceFileCodeGenBase CreateSourceFileGen();
    protected virtual bool NeedGenerateSideComment(LanguageElement element);
    protected virtual void GenerateElementList(LanguageElement element);
    protected virtual bool IsSpecificElement(LanguageElement element);
    protected virtual void GenerateSpecificElement(LanguageElement element);
    protected abstract virtual DirectiveCodeGenBase CreateDirectiveGen();
    protected abstract virtual ExpressionCodeGenBase CreateExpressionGen();
    protected abstract virtual MemberCodeGenBase CreateMemberGen();
    protected abstract virtual StatementCodeGenBase CreateStatementGen();
    protected abstract virtual SupportElementCodeGenBase CreateSupportElementGen();
    protected abstract virtual TypeDeclarationCodeGenBase CreateTypeDeclarationGen();
    protected abstract virtual XmlCodeGenBase CreateXmlGen();
    protected abstract virtual NamespaceReferenceGenBase CreateNamespaceReferenceGen();
    protected abstract virtual NamespaceGenBase CreateNamespaceGen();
    protected abstract virtual SnippetCodeGenBase CreateSnippetGen();
    protected abstract virtual TemplateCodeGenBase CreateTemplateGen();
    protected abstract virtual TemplateParameterCodeGenBase CreateTemplateParameterGen();
    protected abstract virtual HtmlXmlCodeGenBase CreateHtmlXmlGen();
    internal void AddIncreaseAlignment();
    internal bool ElementWasGenerated(LanguageElement element);
    internal void AddGeneratedElement(LanguageElement element);
    internal void RemoveGeneratedElement(LanguageElement element);
    internal LanguageElement GetPrevContext();
    internal void GenerateElementInternal(LanguageElementCodeGenBase codeGen, LanguageElement element);
    internal bool TokenArgsContainsElement(object element);
    internal TokenGenArgs GetArgs();
    internal void RestoreSavedArgs(TokenGenArgs args);
    internal FormattingTokenGen get_TokenGen();
    internal virtual FormattingTable get_FormattingTable();
    internal GeneratingElements get_Contexts();
    public virtual void GenerateElement(LanguageElement element);
    public virtual bool IsSkipped(LanguageElement element);
    public string GetTokenText(FormattingTokenType type);
    public string GetTokenText(FormattingTokenType type, int contextIndex);
    public void GenerateContextBackComment();
    public void GenerateElementForeComment(LanguageElement element);
    public void GenerateElementBackComment(LanguageElement element);
    public void Write(FormattingTokenType type);
    public void Write(FormattingTokenType type, int index);
    public void IncreaseIndent();
    public void DecreaseIndent();
    public void AddIncreaseIndent();
    public void AddDecreaseIndent();
    public void AddClearIndent();
    public void AddRestoreIndent();
    public void AddNewLineIfNeeded();
    public void AddNewLine(int countConsecutive);
    public void AddWSIfNeeded();
    [EditorBrowsableAttribute("1")]
public void PushContext(LanguageElement element);
    [EditorBrowsableAttribute("1")]
public LanguageElement PopContext();
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual void WriteWS();
    public virtual void WriteTab();
    public virtual void WriteEOL();
    public virtual void WriteText(GenTextArgs args);
    [EditorBrowsableAttribute("1")]
public string GenerateStatements(ICollection elements);
    public abstract virtual void GenerateMemberVisibilitySpecifier(MemberVisibilitySpecifier specifier);
    public LanguageElement get_Context();
    public TemplateParameterCodeGenBase get_TemplateParameterGen();
    public SourceFileCodeGenBase get_SourceFileGen();
    public TemplateCodeGenBase get_TemplateGen();
    public DirectiveCodeGenBase get_DirectiveGen();
    public ExpressionCodeGenBase get_ExpressionGen();
    public MemberCodeGenBase get_MemberGen();
    public SupportElementCodeGenBase get_SupportElementGen();
    public StatementCodeGenBase get_StatementGen();
    public TypeDeclarationCodeGenBase get_TypeDeclarationGen();
    public XmlCodeGenBase get_XmlGen();
    public NamespaceReferenceGenBase get_NamespaceReferenceGen();
    public NamespaceGenBase get_NamespaceGen();
    public SnippetCodeGenBase get_SnippetGen();
    public virtual CodeGenOptions get_Options();
    public void set_GenCommentsFromToken(bool value);
    public bool get_GenCommentsFromToken();
    public HtmlXmlCodeGenBase get_HtmlXmlCodeGen();
    public bool get_GeneratingInSupportElement();
    public void set_GeneratingInSupportElement(bool value);
}
public enum DevExpress.CodeParser.CodeGenerationContext : Enum {
    public int value__;
    public static CodeGenerationContext Class;
    public static CodeGenerationContext Struct;
    public static CodeGenerationContext Enum;
    public static CodeGenerationContext Interface;
}
public static class DevExpress.CodeParser.CodeGenFactory : object {
    public static CodeGen CreateCodeGenForFileExtension(string extension);
    public static CodeGen CreateCodeGen(string language);
    public static CodeGen CreateCodeGen(ParserLanguageID languageID);
    private static CodeGen FindCodeGenerator(ParserLanguageID languageID);
}
public abstract class DevExpress.CodeParser.CodeGenObject : object {
    private CodeWriter _Code;
    private Stack`1<CodeWriter> _CodeStack;
    private Hashtable _SkipElements;
    private bool _SaveFormat;
    protected CodeGen CodeGen { get; }
    public CodeGenOptions Options { get; }
    protected string LineContinuation { get; }
    public CodeWriter Code { get; public set; }
    public bool SaveFormat { get; public set; }
    protected void PushCodeWriter();
    protected void PopCodeWriter();
    protected void SetCodeWriter(CodeWriter code);
    public virtual void ClearSkippedElements();
    public virtual void AddSkipped(LanguageElement element);
    public virtual bool IsSkipped(LanguageElement element);
    protected internal virtual void CalculateIndent(LanguageElement element);
    protected internal virtual void ResetIndent();
    public abstract virtual void GenerateElement(LanguageElement languageElement);
    public virtual void GenerateCode(TextWriter writer, LanguageElement languageElement);
    public virtual void GenerateCode(TextWriter writer, LanguageElement languageElement, int precedingWhiteSpaceCount);
    public virtual string GenerateCode(LanguageElement languageElement);
    public virtual string GenerateCode(LanguageElement languageElement, bool calculateIndent);
    public virtual string GenerateCode(LanguageElement languageElement, int precedingWhiteSpaceCount);
    public virtual string GenerateCode(LanguageElement languageElement, int precedingWhiteSpaceCount, bool calculateIndent);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    protected virtual CodeGen get_CodeGen();
    public abstract virtual CodeGenOptions get_Options();
    protected virtual string get_LineContinuation();
    public CodeWriter get_Code();
    public void set_Code(CodeWriter value);
    public bool get_SaveFormat();
    public void set_SaveFormat(bool value);
}
public class DevExpress.CodeParser.CodeGenOptions : object {
    private string _IndentString;
    private IBraceSettings _BraceSettings;
    private IndentionFormattingOptions _Indention;
    private BlankLinesFormattingOptions _BlankLines;
    private GeneralFormattingOptions _General;
    private LineBreaksFormattingOptions _LineBreaks;
    private OtherLanguageSpecificFormattingOptions _OtherLanguageSpecific;
    private SortingOrderingFormattingOptions _SortingOrdering;
    private SpacingFormattingOptions _Spacing;
    private WrappingAlignmentFormattingOptions _WrappingAlignment;
    private ParserLanguageID _Language;
    private bool _SaveFormat;
    private bool _InsertSpaces;
    private int _TabSize;
    public static CodeGenOptions Default { get; }
    public string IndentString { get; public set; }
    public IBraceSettings BraceSettings { get; }
    public IndentionFormattingOptions Indention { get; }
    public BlankLinesFormattingOptions BlankLines { get; }
    public GeneralFormattingOptions General { get; }
    public LineBreaksFormattingOptions LineBreaks { get; }
    public OtherLanguageSpecificFormattingOptions OtherLanguageSpecific { get; }
    public SortingOrderingFormattingOptions SortingOrdering { get; }
    public SpacingFormattingOptions Spacing { get; }
    public WrappingAlignmentFormattingOptions WrappingAlignment { get; }
    public bool SaveFormat { get; public set; }
    public bool InsertSpaces { get; internal set; }
    public int TabSize { get; }
    public CodeGenOptions(ParserLanguageID language);
    public CodeGenOptions(IBraceSettings settings, ParserLanguageID language);
    private void InitializeLanguageOptions(ParserLanguageID language);
    private void SetIndentString(ITabSettings settings);
    private void LoadDefaultFormattingSettings(ParserLanguageID language);
    [EditorBrowsableAttribute("1")]
public void LoadFormattingSettings(FormattingRuleCollection rules);
    public static CodeGenOptions get_Default();
    public string get_IndentString();
    public void set_IndentString(string value);
    public IBraceSettings get_BraceSettings();
    public IndentionFormattingOptions get_Indention();
    public BlankLinesFormattingOptions get_BlankLines();
    public GeneralFormattingOptions get_General();
    public LineBreaksFormattingOptions get_LineBreaks();
    public OtherLanguageSpecificFormattingOptions get_OtherLanguageSpecific();
    public SortingOrderingFormattingOptions get_SortingOrdering();
    public SpacingFormattingOptions get_Spacing();
    public WrappingAlignmentFormattingOptions get_WrappingAlignment();
    public bool get_SaveFormat();
    public void set_SaveFormat(bool value);
    public bool get_InsertSpaces();
    internal void set_InsertSpaces(bool value);
    public int get_TabSize();
}
public class DevExpress.CodeParser.CodeGenStyle : object {
    private Hashtable _ElementStyles;
    public void RegisterElementStyle(ElementCodeGenStyle style);
    public void RegisterElementStyles(ElementCodeGenStyleCollection styles);
    public ElementCodeGenStyle GetElementStyle(LanguageElementType type);
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AddLineFeedAtEndOfFile : OtherLanguageSpecificBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AdjustCodeStyleOnAutoformat : GeneralBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterAttributeTargetColon : AttributesSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterColon : DelimitersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterColonForAncestorsListInTypeDeclaration : DelimitersSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterComma : DelimitersSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterDot : DelimitersSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterFileOptionsSection : BlankLinesBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterGlobalAttributes : BlankLinesBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterImportedNamespaceSection : BlankLinesBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterMultilineMembers : BlankLinesBaseRule {
    public string Name { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterNamespaces : BlankLinesBaseRule {
    public string Name { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.AfterProcessingInstructions : BlankLinesBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.AfterSemicolon : DelimitersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterSemicolonInForStatement : DelimitersSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterSingleLineMemebers : BlankLinesBaseRule {
    public string Name { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterTypeCastParentheses : ParenthesesSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterTypeDeclarations : BlankLinesBaseRule {
    public string Name { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AfterTypeParameterConstraintColon : TypeParametersSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.AlignBase : WrappingAlignmentBaseRule {
    private string _WrapRuleName;
    private string _WrapFirstRuleName;
    public AlignBase(string wrapRuleName, string wrapFirstRuleName);
    protected virtual void ValueChanged(object oldValue);
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstAncestorsListItem : AlignBase {
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstArrayObjectAndCollectionInitializer : AlignBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstBinaryExpressionItem : ExpressionsWrappingAlignmentBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    protected virtual void ValueChanged(object oldValue);
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstFormalParameter : AlignBase {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstImplementsHandlesSectionItem : AlignBase {
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstInvocationArgument : AlignBase {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstLogicalExpressionItem : ExpressionsWrappingAlignmentBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    protected virtual void ValueChanged(object oldValue);
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstMemberInAnonymousType : AlignBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstMultiVariableDeclarationItem : AlignBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstQueryExpressionItem : AlignBase {
    public string Name { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstTypeParameter : AlignBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AlignWithFirstTypeParameterConstraint : AlignBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.AroundColonStatement : DelimitersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AroundEqualsInNamespaceAliasDeclaration : SpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AroundLambdaExpressionOperator : OperatorsSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AroundOneCharOperators : OperatorsSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AroundRegionDirectives : BlankLinesBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AroundTernaryColonOperator : OperatorsSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AroundTernaryQuestionOperator : OperatorsSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AroundTwoCharOperators : OperatorsSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.AroundUnsafeOperators : OperatorsSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.ArraySpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.AttributesLineBreaksBaseRule : LineBreaksBaseRule {
    public string SubCategory { get; }
    public object DefaultValue { get; }
    public virtual string get_SubCategory();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.AttributesSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
public abstract class DevExpress.CodeParser.CodeStyle.Formatting.BaseFormattingRule : object {
    private object _Value;
    private FormattingRuleCollection _ParentCollection;
    protected static ParserLanguageID CSharpAndBasic;
    public FormattingCategory Category { get; }
    public string Name { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public bool Enabled { get; }
    public bool BoolValue { get; }
    public int IntValue { get; }
    public string StringValue { get; }
    public object Value { get; public set; }
    public object DefaultValue { get; }
    public int DefaultIntValue { get; }
    public FormattingOption EditOption { get; }
    public FormattingRuleCollection ParentCollection { get; internal set; }
    private T GetValue();
    private T GetDefaultValue();
    private T GetValue(object obj);
    protected virtual void ValueChanged(object oldValue);
    [EditorBrowsableAttribute("1")]
public virtual object GetDefaultValue(LanguageElement element);
    public bool IsLanguageSupport(ParserLanguageID languageID);
    public abstract virtual FormattingCategory get_Category();
    public abstract virtual string get_Name();
    public abstract virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public bool get_Enabled();
    public bool get_BoolValue();
    public int get_IntValue();
    public string get_StringValue();
    public object get_Value();
    public void set_Value(object value);
    public virtual object get_DefaultValue();
    public int get_DefaultIntValue();
    public virtual FormattingOption get_EditOption();
    public FormattingRuleCollection get_ParentCollection();
    internal void set_ParentCollection(FormattingRuleCollection value);
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeArrayRankBrackets : ArraySpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeArrayRankParentheses : ArraySpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeAttributeTargetColon : AttributesSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeCatchParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeCheckedUncheckedParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeColon : DelimitersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeColonForAncestorsListInTypeDeclaration : DelimitersSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeColonInCaseStatement : DelimitersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeColonInLabels : DelimitersSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeComma : DelimitersSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeDefaultParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeDot : DelimitersSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeFixedParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeForForeachParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeIfParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeNullableTypeOperator : OperatorsSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeOpenCurlyBraceOnTheSameLine : SpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeOpeningBraceInAccessor : PropertiesSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeOpeningBraceInDeclaration : PropertiesSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeOpeningParenthesisOfAMethodCallWithArguments : MethodCallSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeOpeningParenthesisOfAMethodCallWithoutArguments : MethodCallSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeOpeningParenthesisOfAMethodWithoutParameters : MethodSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeOpeningParenthesisOfAMethodWithParameters : MethodSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeOpenSquareBracket : SquareBracketSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeSemicolon : DelimitersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeSemicolonInForStatement : DelimitersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeSwitchParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeTypeArgumentAngles : TypeArgumentsSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeTypeArgumentParenthesis : TypeArgumentsSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeTypeofSizeofParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeTypeParameterAngles : TypeParametersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeTypeParameterConstraintColon : TypeParametersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeTypeParameterParenthesis : TypeParametersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeUnsafePointerDeclarationOperator : OperatorsSpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeUsingLockParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.BeforeWhileParentheses : ParenthesesBeforeSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.BlankLinesBaseRule : BaseFormattingRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
public class DevExpress.CodeParser.CodeStyle.Formatting.BlankLinesFormattingOptions : FormattingOptions {
    private bool _AfterFileOptionsSection;
    private bool _AfterImportedNamespacesSection;
    private bool _AfterNamespaces;
    private bool _AfterTypeDeclarations;
    private bool _AfterSingleLineMembers;
    private bool _AfterMultiLineMembers;
    private bool _AroundRegionDirectives;
    private bool _InsideRegionDirectives;
    private bool _AfterGlobalAttributes;
    private bool _BetweenDifferentImportedNamespacesGroups;
    private bool _AfterProcessingInstructions;
    private bool _MaximumBlankLinesBetweenTags;
    public bool AfterFileOptionsSection { get; }
    public bool AfterImportedNamespacesSection { get; }
    public bool AfterNamespaces { get; }
    public bool AfterTypeDeclarations { get; }
    public bool AfterSingleLineMembers { get; }
    public bool AfterMultiLineMembers { get; }
    public bool AroundRegionDirectives { get; }
    public bool InsideRegionDirectives { get; }
    public bool AfterGlobalAttributes { get; }
    public bool BetweenDifferentImportedNamespacesGroups { get; }
    public bool AfterProcessingInstructions { get; }
    public bool MaximumBlankLinesBetweenTags { get; }
    public virtual void Load(FormattingRuleCollection rules);
    public virtual void LoadDefault(ParserLanguageID language);
    public bool get_AfterFileOptionsSection();
    public bool get_AfterImportedNamespacesSection();
    public bool get_AfterNamespaces();
    public bool get_AfterTypeDeclarations();
    public bool get_AfterSingleLineMembers();
    public bool get_AfterMultiLineMembers();
    public bool get_AroundRegionDirectives();
    public bool get_InsideRegionDirectives();
    public bool get_AfterGlobalAttributes();
    public bool get_BetweenDifferentImportedNamespacesGroups();
    public bool get_AfterProcessingInstructions();
    public bool get_MaximumBlankLinesBetweenTags();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.CloseBraceLineBreaksBaseRule : LineBreaksBaseRule {
    public string SubCategory { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_SubCategory();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal static class DevExpress.CodeParser.CodeStyle.Formatting.CurlyBraceHelper : object {
    private static int GetNodeCount(LanguageElement element);
    private static int GetNodeCount(NodeList nodes);
    private static bool IsSimpleElement(LanguageElement element, CodeGenOptions options);
    public static void AddTokensBeforeOpen(FormattingElements tokens, CodeGen codeGen);
    public static void AddTokensAfterOpen(FormattingElements tokens, CodeGen codeGen);
    public static void AddTokensBeforeClose(FormattingElements tokens, CodeGen codeGen);
    public static void AddTokensAfterClose(FormattingElements tokens, CodeGen codeGen);
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.DelimitersSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.ExpressionsWrappingAlignmentBaseRule : WrappingAlignmentBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
}
public enum DevExpress.CodeParser.CodeStyle.Formatting.FormattingCategory : Enum {
    public int value__;
    public static FormattingCategory General;
    public static FormattingCategory BlankLines;
    public static FormattingCategory LineBreaks;
    public static FormattingCategory Indentation;
    public static FormattingCategory Spacing;
    public static FormattingCategory WrappingAndAlignment;
    public static FormattingCategory SortingAndOrdering;
    public static FormattingCategory OtherAndLanguageSpecific;
}
public enum DevExpress.CodeParser.CodeStyle.Formatting.FormattingOption : Enum {
    public int value__;
    public static FormattingOption Boolean;
    public static FormattingOption Integer;
    public static FormattingOption Editable;
}
public abstract class DevExpress.CodeParser.CodeStyle.Formatting.FormattingOptions : object {
    protected bool GetOptionByName(string name, FormattingRuleCollection rules);
    public abstract virtual void Load(FormattingRuleCollection rules);
    public abstract virtual void LoadDefault(ParserLanguageID language);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.CodeStyle.Formatting.FormattingRuleCollection : object {
    private Dictionary`2<string, BaseFormattingRule> _Rules;
    public BaseFormattingRule Item { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private void Sort();
    public void Add(BaseFormattingRule rule);
    public void Add(BaseFormattingRule rule, object value);
    public bool Enabled(string name);
    public object GetDefaultValue(string name);
    public BaseFormattingRule Find(string name);
    [EditorBrowsableAttribute("1")]
public static FormattingRuleCollection GetRulesByLanguage(ParserLanguageID languageId);
    public BaseFormattingRule get_Item(string name);
    public int get_Count();
    public bool get_IsReadOnly();
    private sealed virtual override IEnumerator`1<BaseFormattingRule> System.Collections.Generic.IEnumerable<DevExpress.CodeParser.CodeStyle.Formatting.BaseFormattingRule>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int Compare(BaseFormattingRule x, BaseFormattingRule y);
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.GeneralBaseRule : BaseFormattingRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
public class DevExpress.CodeParser.CodeStyle.Formatting.GeneralFormattingOptions : FormattingOptions {
    private bool _AdjustCodeStyleOnAutoformat;
    private bool _KeepExistingLineBreaks;
    private bool _KeepExistingWhiteSpace;
    private bool _KeepExpressionsIndent;
    public bool AdjustCodeStyleOnAutoformat { get; }
    public bool KeepExistingLineBreaks { get; }
    public bool KeepExistingWhiteSpace { get; }
    public bool KeepExpressionsIndent { get; }
    public virtual void Load(FormattingRuleCollection rules);
    public virtual void LoadDefault(ParserLanguageID language);
    public bool get_AdjustCodeStyleOnAutoformat();
    public bool get_KeepExistingLineBreaks();
    public bool get_KeepExistingWhiteSpace();
    public bool get_KeepExpressionsIndent();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.CodeStyle.Formatting.IFormattingService {
    public FormattingRuleCollection Item { get; }
    public abstract virtual FormattingRuleCollection GetRules(ParserLanguageID languageId);
    public abstract virtual void SetDefaults(ParserLanguageID languageId);
    public abstract virtual bool Enabled(ParserLanguageID languageId, string optionName);
    public abstract virtual int GetIntValue(ParserLanguageID languageId, string optionName);
    public abstract virtual string GetStringValue(ParserLanguageID languageId, string optionName);
    [EditorBrowsableAttribute("1")]
public abstract virtual void Save(ParserLanguageID languageId);
    public abstract virtual FormattingRuleCollection get_Item(ParserLanguageID languageId);
    public abstract virtual bool Format(SourceFile file, SourceRange range);
    [EditorBrowsableAttribute("1")]
public abstract virtual void FormatRange(SourceFile file, SourceRange range);
    public abstract virtual IRuleChanger GetRuleChanger(ParserLanguageID language);
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.IndentAnonymousMethodContents : IndentationBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.IndentArrayObjectAndCollectionInitializerContents : IndentationBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    protected virtual void ValueChanged(object oldValue);
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.IndentationBaseRule : BaseFormattingRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.IndentCaseStatementContents : IndentationBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.IndentCaseStatementFromSwitchStatement : IndentationBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.IndentCodeBlockContents : IndentationBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.IndentComments : IndentationBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
public class DevExpress.CodeParser.CodeStyle.Formatting.IndentionFormattingOptions : FormattingOptions {
    private bool _OpenAndCloseBraces;
    private bool _CodeBlockContents;
    private bool _AnonymousMethodContents;
    private bool _ArrayObjectAndCollectionInitializerContents;
    private bool _CaseStatementFromSwitchStatement;
    private bool _CaseStatementContents;
    private bool _IndentLabels;
    private bool _IndentComment;
    private bool _IndentNestedUsingStatements;
    public bool OpenAndCloseBraces { get; }
    public bool CodeBlockContents { get; }
    public bool AnonymousMethodContents { get; }
    public bool ArrayObjectAndCollectionInitializerContents { get; }
    public bool CaseStatementFromSwitchStatement { get; }
    public bool CaseStatementContents { get; }
    public bool IndentLabels { get; }
    public bool IndentComment { get; }
    public bool IndentNestedUsingStatements { get; }
    public virtual void Load(FormattingRuleCollection rules);
    public virtual void LoadDefault(ParserLanguageID language);
    public bool get_OpenAndCloseBraces();
    public bool get_CodeBlockContents();
    public bool get_AnonymousMethodContents();
    public bool get_ArrayObjectAndCollectionInitializerContents();
    public bool get_CaseStatementFromSwitchStatement();
    public bool get_CaseStatementContents();
    public bool get_IndentLabels();
    public bool get_IndentComment();
    public bool get_IndentNestedUsingStatements();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.IndentLabels : IndentationBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.IndentNestedUsingStatements : IndentationBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.IndentOpenAndCloseBraces : IndentationBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.InsideRegionDirectives : BlankLinesBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object GetDefaultValue(LanguageElement element);
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
public interface DevExpress.CodeParser.CodeStyle.Formatting.IRuleChanger {
    public abstract virtual bool AddRuleValue(string ruleName, object newValue);
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.KeepExistingLineBreaks : GeneralBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.KeepExistingWhiteSpace : GeneralBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.KeepExpressionsIndent : GeneralBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.LineBreaksBaseRule : BaseFormattingRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
public class DevExpress.CodeParser.CodeStyle.Formatting.LineBreaksFormattingOptions : FormattingOptions {
    private bool _PlaceTypeAttributeOnSeparateLine;
    private bool _PlaceMethodAttributeOnSeparateLine;
    private bool _PlacePropertyAttributeOnSeparateLine;
    private bool _PlaceEventAttributeOnSeparateLine;
    private bool _PlaceFieldConstantAttributeOnSeparateLine;
    private bool _PlaceEnumElementAttributeOnSeparateLine;
    private bool _PlaceMultipleAttributesOnTheirOwnLine;
    private bool _PlaceOpenBraceOnNewLineForNamespaces;
    private bool _PlaceOpenBraceOnNewLineForTypeDeclarations;
    private bool _PlaceOpenBraceOnNewLineForMethods;
    private bool _PlaceOpenBraceOnNewLineForAnonymousMethods;
    private bool _PlaceOpenBraceOnNewLineForCodeBlocks;
    private bool _PlaceOpenBraceOnNewLineForAnonymousTypes;
    private bool _PlaceOpenBraceOnNewLineForArrayObjectAndCollInitializers;
    private bool _PlaceOpenBraceOnNewLineForLambdaExpressions;
    private bool _PlaceOpenBraceOnNewLineForProperties;
    private bool _PlaceOpenBraceOnNewLineForBlocksUnderCaseStatement;
    private bool _PlaceCloseBraceOnNewLineForNamespaces;
    private bool _PlaceCloseBraceOnNewLineForTypeDeclarations;
    private bool _PlaceCloseBraceOnNewLineForMethods;
    private bool _PlaceCloseBraceOnNewLineForAnonymousMethods;
    private bool _PlaceCloseBraceOnNewLineForCodeBlocks;
    private bool _PlaceCloseBraceOnNewLineForAnonymousTypes;
    private bool _PlaceCloseBraceOnNewLineForArrayObjectAndCollInitializers;
    private bool _PlaceCloseBraceOnNewLineForLambdaExpressions;
    private bool _PlaceCloseBraceOnNewLineForProperties;
    private bool _PlaceCloseBraceOnNewLineForBlocksUnderCaseStatement;
    private bool _PlaceSimpleEmbeddedStatementOnSingleLine;
    private bool _PlaceElseStatementOnNewLine;
    private bool _PlaceWhileStatementOnNewLine;
    private bool _PlaceCatchStatementOnNewLine;
    private bool _PlaceFinallyStatementOnNewLine;
    private bool _PlaceIfStatementFollowedByElseOnNewLine;
    private bool _PlaceAbstractInterfaceMemberOnSingleLine;
    private bool _PlaceAutoImplementedPropertyOnSingleLine;
    private bool _PlaceSimpleMemberOnSingleLine;
    private bool _PlaceSimpleAccessorOnSingleLine;
    private bool _PlaceSimpleAnonymousMethodOnSingleLine;
    private bool _PlaceConstructorInitializerOnSameLine;
    public bool PlaceTypeAttributeOnSeparateLine { get; }
    public bool PlaceMethodAttributeOnSeparateLine { get; }
    public bool PlacePropertyAttributeOnSeparateLine { get; }
    public bool PlaceEventAttributeOnSeparateLine { get; }
    public bool PlaceFieldConstantAttributeOnSeparateLine { get; }
    public bool PlaceEnumElementAttributeOnSeparateLine { get; }
    public bool PlaceMultipleAttributesOnTheirOwnLine { get; }
    public bool PlaceOpenBraceOnNewLineForNamespaces { get; }
    public bool PlaceOpenBraceOnNewLineForTypeDeclarations { get; }
    public bool PlaceOpenBraceOnNewLineForMethods { get; }
    public bool PlaceOpenBraceOnNewLineForAnonymousMethods { get; }
    public bool PlaceOpenBraceOnNewLineForCodeBlocks { get; }
    public bool PlaceOpenBraceOnNewLineForAnonymousTypes { get; }
    public bool PlaceOpenBraceOnNewLineForArrayObjectAndCollInitializers { get; }
    public bool PlaceOpenBraceOnNewLineForLambdaExpressions { get; }
    public bool PlaceOpenBraceOnNewLineForProperties { get; }
    public bool PlaceOpenBraceOnNewLineForBlocksUnderCaseStatement { get; }
    public bool PlaceSimpleEmbeddedStatementOnSingleLine { get; }
    public bool PlaceElseStatementOnNewLine { get; }
    public bool PlaceWhileStatementOnNewLine { get; }
    public bool PlaceCatchStatementOnNewLine { get; }
    public bool PlaceFinallyStatementOnNewLine { get; }
    public bool PlaceIfStatementFollowedByElseOnNewLine { get; }
    public bool PlaceAbstractInterfaceMemberOnSingleLine { get; }
    public bool PlaceAutoImplementedPropertyOnSingleLine { get; }
    public bool PlaceSimpleMemberOnSingleLine { get; }
    public bool PlaceSimpleAccessorOnSingleLine { get; }
    public bool PlaceSimpleAnonymousMethodOnSingleLine { get; }
    public bool PlaceConstructorInitializerOnSameLine { get; }
    public bool PlaceCloseBraceOnNewLineForNamespaces { get; }
    public bool PlaceCloseBraceOnNewLineForTypeDeclarations { get; }
    public bool PlaceCloseBraceOnNewLineForMethods { get; }
    public bool PlaceCloseBraceOnNewLineForAnonymousMethods { get; }
    public bool PlaceCloseBraceOnNewLineForCodeBlocks { get; }
    public bool PlaceCloseBraceOnNewLineForAnonymousTypes { get; }
    public bool PlaceCloseBraceOnNewLineForArrayObjectAndCollInitializers { get; }
    public bool PlaceCloseBraceOnNewLineForLambdaExpressions { get; }
    public bool PlaceCloseBraceOnNewLineForProperties { get; }
    public bool PlaceCloseBraceOnNewLineForBlocksUnderCaseStatement { get; }
    public virtual void Load(FormattingRuleCollection rules);
    public virtual void LoadDefault(ParserLanguageID language);
    public bool get_PlaceTypeAttributeOnSeparateLine();
    public bool get_PlaceMethodAttributeOnSeparateLine();
    public bool get_PlacePropertyAttributeOnSeparateLine();
    public bool get_PlaceEventAttributeOnSeparateLine();
    public bool get_PlaceFieldConstantAttributeOnSeparateLine();
    public bool get_PlaceEnumElementAttributeOnSeparateLine();
    public bool get_PlaceMultipleAttributesOnTheirOwnLine();
    public bool get_PlaceOpenBraceOnNewLineForNamespaces();
    public bool get_PlaceOpenBraceOnNewLineForTypeDeclarations();
    public bool get_PlaceOpenBraceOnNewLineForMethods();
    public bool get_PlaceOpenBraceOnNewLineForAnonymousMethods();
    public bool get_PlaceOpenBraceOnNewLineForCodeBlocks();
    public bool get_PlaceOpenBraceOnNewLineForAnonymousTypes();
    public bool get_PlaceOpenBraceOnNewLineForArrayObjectAndCollInitializers();
    public bool get_PlaceOpenBraceOnNewLineForLambdaExpressions();
    public bool get_PlaceOpenBraceOnNewLineForProperties();
    public bool get_PlaceOpenBraceOnNewLineForBlocksUnderCaseStatement();
    public bool get_PlaceSimpleEmbeddedStatementOnSingleLine();
    public bool get_PlaceElseStatementOnNewLine();
    public bool get_PlaceWhileStatementOnNewLine();
    public bool get_PlaceCatchStatementOnNewLine();
    public bool get_PlaceFinallyStatementOnNewLine();
    public bool get_PlaceIfStatementFollowedByElseOnNewLine();
    public bool get_PlaceAbstractInterfaceMemberOnSingleLine();
    public bool get_PlaceAutoImplementedPropertyOnSingleLine();
    public bool get_PlaceSimpleMemberOnSingleLine();
    public bool get_PlaceSimpleAccessorOnSingleLine();
    public bool get_PlaceSimpleAnonymousMethodOnSingleLine();
    public bool get_PlaceConstructorInitializerOnSameLine();
    public bool get_PlaceCloseBraceOnNewLineForNamespaces();
    public bool get_PlaceCloseBraceOnNewLineForTypeDeclarations();
    public bool get_PlaceCloseBraceOnNewLineForMethods();
    public bool get_PlaceCloseBraceOnNewLineForAnonymousMethods();
    public bool get_PlaceCloseBraceOnNewLineForCodeBlocks();
    public bool get_PlaceCloseBraceOnNewLineForAnonymousTypes();
    public bool get_PlaceCloseBraceOnNewLineForArrayObjectAndCollInitializers();
    public bool get_PlaceCloseBraceOnNewLineForLambdaExpressions();
    public bool get_PlaceCloseBraceOnNewLineForProperties();
    public bool get_PlaceCloseBraceOnNewLineForBlocksUnderCaseStatement();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.MembersLineBreaksBaseRule : LineBreaksBaseRule {
    public string SubCategory { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_SubCategory();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.MethodCallSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.MethodSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.OpenBraceLineBreaksBaseRule : LineBreaksBaseRule {
    public string SubCategory { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_SubCategory();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.OperatorsSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.OtherBaseRule : BaseFormattingRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.OtherLanguageSpecificBaseRule : OtherBaseRule {
    public string SubCategory { get; }
    public virtual string get_SubCategory();
}
public class DevExpress.CodeParser.CodeStyle.Formatting.OtherLanguageSpecificFormattingOptions : FormattingOptions {
    private bool _AddLineFeedAtEndOfFile;
    public bool AddLineFeedAtEndOfFile { get; }
    public virtual void Load(FormattingRuleCollection rules);
    public virtual void LoadDefault(ParserLanguageID language);
    public bool get_AddLineFeedAtEndOfFile();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.ParenthesesBeforeSpacingBaseRule : ParenthesesSpacingBaseRule {
    public string SubCategory { get; }
    public object DefaultValue { get; }
    public virtual string get_SubCategory();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.ParenthesesSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.ParenthesesWithinSpacingBaseRule : ParenthesesSpacingBaseRule {
    public string SubCategory { get; }
    public object DefaultValue { get; }
    public virtual string get_SubCategory();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceAbstractInterfaceMemberOnSingleLine : MembersLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceAutoImplementedPropertyOnSingleLine : MembersLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCatchStatementOnNewLine : StatementsLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForAnonymousMethods : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForAnonymousTypes : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForArrayObjectAndCollectionInitializers : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForBlockUnderCaseStatement : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForCodeBlocks : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForLambdaExpressions : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForMethods : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForNamespaces : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForProperties : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceCloseBraceOnNewLineForTypeDeclarations : CloseBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceConstructorInitializerOnSameLine : MembersLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceElseStatementOnNewLine : StatementsLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceEnumElementAttributeOnSeparateLine : AttributesLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceEventAttributeOnSeparateLine : AttributesLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceFieldConstantAttributeOnSeparateLine : AttributesLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceFinallyStatementOnNewLine : StatementsLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceIfStatementFollowedByElseOnNewLine : StatementsLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceMethodAttributeOnSeparateLine : AttributesLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceMultipleAttributesOnTheirOwnLine : AttributesLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForAnonymousMethods : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForAnonymousTypes : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForArrayObjectAndCollectionInitializers : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForBlocksUnderCaseStatement : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForCodeBlocks : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForLambdaExpressions : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForMethods : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForNamespaces : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForProperties : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceOpenBraceOnNewLineForTypeDeclarations : OpenBraceLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlacePropertyAttributeOnSeparateLine : AttributesLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceSimpleAccessorOnSingleLine : MembersLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceSimpleAnonymousMethodOnSingleLine : MembersLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceSimpleEmbeddedStatementOnSingleLine : StatementsLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceSimpleMemberOnSingleLine : MembersLineBreaksBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceTypeAttributeOnSeparateLine : AttributesLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.PlaceWhileStatementOnNewLine : StatementsLineBreaksBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.PropertiesSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.RightMarginColumnSize : WrappingAlignmentBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public FormattingOption EditOption { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
    public virtual FormattingOption get_EditOption();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
public static class DevExpress.CodeParser.CodeStyle.Formatting.Rules : object {
}
public class DevExpress.CodeParser.CodeStyle.Formatting.SortingOrderingFormattingOptions : FormattingOptions {
    private bool _ArrangeModifiersInExistingCode;
    private bool _ModifiersOrder;
    private bool _SortUsingStatements;
    private bool _GroupUsingStatements;
    public bool ArrangeModifiersInExistingCode { get; }
    public bool ModifiersOrder { get; }
    public bool SortUsingStatements { get; }
    public bool GroupUsingStatements { get; }
    public virtual void Load(FormattingRuleCollection rules);
    public virtual void LoadDefault(ParserLanguageID language);
    public bool get_ArrangeModifiersInExistingCode();
    public bool get_ModifiersOrder();
    public bool get_SortUsingStatements();
    public bool get_GroupUsingStatements();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.SpacingBaseRule : BaseFormattingRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
public class DevExpress.CodeParser.CodeStyle.Formatting.SpacingFormattingOptions : FormattingOptions {
    private bool _BeforeOpeningParenthesisOfAMethodWithParameters;
    private bool _BeforeOpeningParenthesisOfAMethodWithoutParameters;
    private bool _WithinMethodDeclarationParentheses;
    private bool _WithinEmptyMethodDeclarationParentheses;
    private bool _BeforeOpeningParenthesisOfAMethodCallWithArguments;
    private bool _BeforeOpeningParenthesisOfAMethodCallWithoutArguments;
    private bool _WithinArgumentsListParentheses;
    private bool _WithinEmptyArgumentsListParentheses;
    private bool _BeforeTypeParameterAngles;
    private bool _WithinTypeParameterAngles;
    private bool _BeforeTypeArgumentAngles;
    private bool _WithinTypeArgumentAngles;
    private bool _BeforeTypeParameterConstraintColon;
    private bool _AfterTypeParameterConstraintColon;
    private bool _BeforeTypeParameterParenthesis;
    private bool _WithinTypeParameterParenthesis;
    private bool _BeforeTypeArgumentParenthesis;
    private bool _WithinTypeArgumentParenthesis;
    private bool _AroundOneCharOperators;
    private bool _AroundTwoCharOperators;
    private bool _AroundUnsafeOperators;
    private bool _AroundTernaryQuestionOperator;
    private bool _AroundTernaryColonOperator;
    private bool _AroundLambdaExpressionOperator;
    private bool _BeforeUnsafePointerDeclarationOperator;
    private bool _BeforeNullableTypeOperator;
    private bool _BeforeOpenSquareBracket;
    private bool _WithinSquareBrackets;
    private bool _WithinEmptySquareBrackets;
    private bool _WithinExpressionParentheses;
    private bool _WithinTypeCastParentheses;
    private bool _AfterTypeCastParentheses;
    private bool _WithinSingleLineAccessor;
    private bool _WithinSingleLineMethod;
    private bool _WithinSingleLineAnonymousMethod;
    private bool _AroundEqualsInNamespaceAliasDeclaration;
    private bool _BeforeOpenCurlyBraceOnTheSameLine;
    private bool _BeforeComma;
    private bool _AfterComma;
    private bool _BeforeDot;
    private bool _AfterDot;
    private bool _BeforeColon;
    private bool _AfterColon;
    private bool _AroundColonStatement;
    private bool _BeforeColonInLabels;
    private bool _AfterColonForAncestorsListInTypeDeclaration;
    private bool _BeforeColonForAncestorsListInTypeDeclaration;
    private bool _AfterSemicolonInForStatement;
    private bool _BeforeSemicolonInForStatement;
    private bool _BeforeSemicolon;
    private bool _AfterSemicolon;
    private bool _BeforeColonInCaseStatement;
    private bool _WithinAttributeBrackets;
    private bool _BeforeAttributeTargetColon;
    private bool _AfterAttributeTargetColon;
    private bool _BeforeArrayRankBrackets;
    private bool _WithinArrayRankBrackets;
    private bool _WithinArrayRankEmptyBrackets;
    private bool _BeforeArrayRankParentheses;
    private bool _WithinArrayRankParentheses;
    private bool _WithinArrayRankEmptyParentheses;
    private bool _BeforeIfParentheses;
    private bool _BeforeForForeachParentheses;
    private bool _BeforeWhileParentheses;
    private bool _BeforeSwitchParentheses;
    private bool _BeforeCatchParentheses;
    private bool _BeforeUsingLockParentheses;
    private bool _BeforeTypeofSizeofParentheses;
    private bool _BeforeFixedParentheses;
    private bool _BeforeCheckedUncheckedParentheses;
    private bool _BeforeDefaultParentheses;
    private bool _WithinIfParentheses;
    private bool _WithinForForeachParentheses;
    private bool _WithinWhileParentheses;
    private bool _WithinSwitchParentheses;
    private bool _WithinCatchParentheses;
    private bool _WithinUsingLockParentheses;
    private bool _WithinTypeofSizeofParentheses;
    private bool _WithinFixedParentheses;
    private bool _WithinCheckedUncheckedParentheses;
    private bool _WithinDefaultParentheses;
    private bool _WithinArrayInitializerBraces;
    private bool _BeforeOpeningBraceInProperty;
    private bool _WithinBracesInPropertyDeclaration;
    private bool _WithinBracesInPropertyAccessors;
    private bool _BeforeOpeningBraceInAccessor;
    public bool BeforeOpeningParenthesisOfAMethodWithParameters { get; }
    public bool BeforeOpeningParenthesisOfAMethodWithoutParameters { get; }
    public bool WithinMethodDeclarationParentheses { get; }
    public bool WithinEmptyMethodDeclarationParentheses { get; }
    public bool BeforeOpeningParenthesisOfAMethodCallWithArguments { get; }
    public bool BeforeOpeningParenthesisOfAMethodCallWithoutArguments { get; }
    public bool WithinArgumentsListParentheses { get; }
    public bool WithinEmptyArgumentsListParentheses { get; }
    public bool BeforeTypeParameterAngles { get; }
    public bool WithinTypeParameterAngles { get; }
    public bool BeforeTypeArgumentAngles { get; }
    public bool WithinTypeArgumentAngles { get; }
    public bool BeforeTypeParameterConstraintColon { get; }
    public bool AfterTypeParameterConstraintColon { get; }
    public bool BeforeTypeParameterParenthesis { get; }
    public bool WithinTypeParameterParenthesis { get; }
    public bool BeforeTypeArgumentParenthesis { get; }
    public bool WithinTypeArgumentParenthesis { get; }
    public bool AroundOneCharOperators { get; }
    public bool AroundTwoCharOperators { get; }
    public bool AroundUnsafeOperators { get; }
    public bool AroundTernaryQuestionOperator { get; }
    public bool AroundTernaryColonOperator { get; }
    public bool AroundLambdaExpressionOperator { get; }
    public bool BeforeUnsafePointerDeclarationOperator { get; }
    public bool BeforeNullableTypeOperator { get; }
    public bool BeforeOpenSquareBracket { get; }
    public bool WithinSquareBrackets { get; }
    public bool WithinEmptySquareBrackets { get; }
    public bool WithinExpressionParentheses { get; }
    public bool WithinTypeCastParentheses { get; }
    public bool AfterTypeCastParentheses { get; }
    public bool WithinSingleLineAccessor { get; }
    public bool WithinSingleLineMethod { get; }
    public bool WithinSingleLineAnonymousMethod { get; }
    public bool AroundEqualsInNamespaceAliasDeclaration { get; }
    public bool BeforeOpenCurlyBraceOnTheSameLine { get; }
    public bool BeforeComma { get; }
    public bool AfterComma { get; }
    public bool BeforeDot { get; }
    public bool AfterDot { get; }
    public bool BeforeColon { get; }
    public bool AfterColon { get; }
    public bool AroundColonStatement { get; }
    public bool BeforeColonInLabels { get; }
    public bool AfterColonForAncestorsListInTypeDeclaration { get; }
    public bool BeforeColonForAncestorsListInTypeDeclaration { get; }
    public bool AfterSemicolonInForStatement { get; }
    public bool BeforeSemicolonInForStatement { get; }
    public bool BeforeSemicolon { get; }
    public bool AfterSemicolon { get; }
    public bool BeforeColonInCaseStatement { get; }
    public bool WithinAttributeBrackets { get; }
    public bool BeforeAttributeTargetColon { get; }
    public bool AfterAttributeTargetColon { get; }
    public bool BeforeArrayRankBrackets { get; }
    public bool WithinArrayRankBrackets { get; }
    public bool WithinArrayRankEmptyBrackets { get; }
    public bool BeforeArrayRankParentheses { get; }
    public bool WithinArrayRankParentheses { get; }
    public bool WithinArrayRankEmptyParentheses { get; }
    public bool WithinArrayInitializerBraces { get; }
    public bool BeforeIfParentheses { get; }
    public bool BeforeForForeachParentheses { get; }
    public bool BeforeWhileParentheses { get; }
    public bool BeforeSwitchParentheses { get; }
    public bool BeforeCatchParentheses { get; }
    public bool BeforeUsingLockParentheses { get; }
    public bool BeforeTypeofSizeofParentheses { get; }
    public bool BeforeFixedParentheses { get; }
    public bool BeforeCheckedUncheckedParentheses { get; }
    public bool BeforeDefaultParentheses { get; }
    public bool WithinIfParentheses { get; }
    public bool WithinForForeachParentheses { get; }
    public bool WithinWhileParentheses { get; }
    public bool WithinSwitchParentheses { get; }
    public bool WithinCatchParentheses { get; }
    public bool WithinUsingLockParentheses { get; }
    public bool WithinTypeofSizeofParentheses { get; }
    public bool WithinFixedParentheses { get; }
    public bool WithinCheckedUncheckedParentheses { get; }
    public bool WithinDefaultParentheses { get; }
    public bool BeforeOpeningBraceInProperty { get; }
    public bool WithinBracesInPropertyDeclaration { get; }
    public bool WithinBracesInPropertyAccessors { get; }
    public bool BeforeOpeningBraceInAccessor { get; }
    public virtual void Load(FormattingRuleCollection rules);
    public virtual void LoadDefault(ParserLanguageID language);
    public bool get_BeforeOpeningParenthesisOfAMethodWithParameters();
    public bool get_BeforeOpeningParenthesisOfAMethodWithoutParameters();
    public bool get_WithinMethodDeclarationParentheses();
    public bool get_WithinEmptyMethodDeclarationParentheses();
    public bool get_BeforeOpeningParenthesisOfAMethodCallWithArguments();
    public bool get_BeforeOpeningParenthesisOfAMethodCallWithoutArguments();
    public bool get_WithinArgumentsListParentheses();
    public bool get_WithinEmptyArgumentsListParentheses();
    public bool get_BeforeTypeParameterAngles();
    public bool get_WithinTypeParameterAngles();
    public bool get_BeforeTypeArgumentAngles();
    public bool get_WithinTypeArgumentAngles();
    public bool get_BeforeTypeParameterConstraintColon();
    public bool get_AfterTypeParameterConstraintColon();
    public bool get_BeforeTypeParameterParenthesis();
    public bool get_WithinTypeParameterParenthesis();
    public bool get_BeforeTypeArgumentParenthesis();
    public bool get_WithinTypeArgumentParenthesis();
    public bool get_AroundOneCharOperators();
    public bool get_AroundTwoCharOperators();
    public bool get_AroundUnsafeOperators();
    public bool get_AroundTernaryQuestionOperator();
    public bool get_AroundTernaryColonOperator();
    public bool get_AroundLambdaExpressionOperator();
    public bool get_BeforeUnsafePointerDeclarationOperator();
    public bool get_BeforeNullableTypeOperator();
    public bool get_BeforeOpenSquareBracket();
    public bool get_WithinSquareBrackets();
    public bool get_WithinEmptySquareBrackets();
    public bool get_WithinExpressionParentheses();
    public bool get_WithinTypeCastParentheses();
    public bool get_AfterTypeCastParentheses();
    public bool get_WithinSingleLineAccessor();
    public bool get_WithinSingleLineMethod();
    public bool get_WithinSingleLineAnonymousMethod();
    public bool get_AroundEqualsInNamespaceAliasDeclaration();
    public bool get_BeforeOpenCurlyBraceOnTheSameLine();
    public bool get_BeforeComma();
    public bool get_AfterComma();
    public bool get_BeforeDot();
    public bool get_AfterDot();
    public bool get_BeforeColon();
    public bool get_AfterColon();
    public bool get_AroundColonStatement();
    public bool get_BeforeColonInLabels();
    public bool get_AfterColonForAncestorsListInTypeDeclaration();
    public bool get_BeforeColonForAncestorsListInTypeDeclaration();
    public bool get_AfterSemicolonInForStatement();
    public bool get_BeforeSemicolonInForStatement();
    public bool get_BeforeSemicolon();
    public bool get_AfterSemicolon();
    public bool get_BeforeColonInCaseStatement();
    public bool get_WithinAttributeBrackets();
    public bool get_BeforeAttributeTargetColon();
    public bool get_AfterAttributeTargetColon();
    public bool get_BeforeArrayRankBrackets();
    public bool get_WithinArrayRankBrackets();
    public bool get_WithinArrayRankEmptyBrackets();
    public bool get_BeforeArrayRankParentheses();
    public bool get_WithinArrayRankParentheses();
    public bool get_WithinArrayRankEmptyParentheses();
    public bool get_WithinArrayInitializerBraces();
    public bool get_BeforeIfParentheses();
    public bool get_BeforeForForeachParentheses();
    public bool get_BeforeWhileParentheses();
    public bool get_BeforeSwitchParentheses();
    public bool get_BeforeCatchParentheses();
    public bool get_BeforeUsingLockParentheses();
    public bool get_BeforeTypeofSizeofParentheses();
    public bool get_BeforeFixedParentheses();
    public bool get_BeforeCheckedUncheckedParentheses();
    public bool get_BeforeDefaultParentheses();
    public bool get_WithinIfParentheses();
    public bool get_WithinForForeachParentheses();
    public bool get_WithinWhileParentheses();
    public bool get_WithinSwitchParentheses();
    public bool get_WithinCatchParentheses();
    public bool get_WithinUsingLockParentheses();
    public bool get_WithinTypeofSizeofParentheses();
    public bool get_WithinFixedParentheses();
    public bool get_WithinCheckedUncheckedParentheses();
    public bool get_WithinDefaultParentheses();
    public bool get_BeforeOpeningBraceInProperty();
    public bool get_WithinBracesInPropertyDeclaration();
    public bool get_WithinBracesInPropertyAccessors();
    public bool get_BeforeOpeningBraceInAccessor();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.SquareBracketSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.StatementsLineBreaksBaseRule : LineBreaksBaseRule {
    public string SubCategory { get; }
    public object DefaultValue { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_SubCategory();
    public virtual object get_DefaultValue();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.TypeArgumentsSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.TypeParametersSpacingBaseRule : SpacingBaseRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinArgumentsListParentheses : MethodCallSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinArrayInitializerBraces : ArraySpacingBaseRule {
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinArrayRankBrackets : ArraySpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinArrayRankEmptyBrackets : ArraySpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinArrayRankEmptyParentheses : ArraySpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinArrayRankParentheses : ArraySpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinAttributeBrackets : AttributesSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.WithinBracesInAccessor : PropertiesSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinBracesInDeclaration : PropertiesSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinCatchParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinCheckedUncheckedParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinDefaultParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinEmptyArgumentsListParentheses : MethodCallSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinEmptyMethodDeclarationParentheses : MethodSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.WithinEmptySquareBrackets : SquareBracketSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinExpressionParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinFixedParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinForForeachParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinIfParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinMethodDeclarationParentheses : MethodSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinSingleLineAccessor : SpacingBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinSingleLineAnonymousMethod : SpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinSingleLineMethod : SpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinSquareBrackets : SquareBracketSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinSwitchParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinTypeArgumentAngles : TypeArgumentsSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinTypeArgumentParenthesis : TypeArgumentsSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinTypeCastParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinTypeofSizeofParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinTypeParameterAngles : TypeParametersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinTypeParameterParenthesis : TypeParametersSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinUsingLockParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WithinWhileParentheses : ParenthesesWithinSpacingBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapAncestorsListInTypeDeclaration : WrapBase {
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapArrayObjectAndCollectionInitializers : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.WrapBase : WrappingAlignmentBaseRule {
    private string _AlignRuleName;
    private string _WrapRuleName;
    public WrapBase(string alignRuleName, string wrapRuleName);
    protected virtual void ValueChanged(object oldValue);
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapBeforeCloseBraceInDeclaration : WrappingAlignmentBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapBeforeCloseBraceInInvocation : WrappingAlignmentBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapBeforeColonForAncestorsList : WrappingAlignmentBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapBeforeOpenBraceInDeclaration : WrappingAlignmentBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapBeforeOpenBraceInInvocation : WrappingAlignmentBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapBeforeOperatorInBinaryExpression : ExpressionsWrappingAlignmentBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapBeforeOperatorInLogicalExpression : ExpressionsWrappingAlignmentBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapBinaryOperatorExpression : ExpressionsWrappingAlignmentBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    protected virtual void ValueChanged(object oldValue);
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFirstAncestorsListItem : WrapBase {
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFirstArrayObjectAndCollectionInitializer : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFirstFormalParameter : WrapBase {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFirstImplementsHandlesSectionItem : WrapBase {
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFirstInvocationArgument : WrapBase {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFirstMemberInAnonymousType : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFirstMultiVariableDeclaration : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFirstTypeParameter : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFirstTypeParameterConstraint : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapFormalParameters : WrapBase {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapForStatementHeader : WrappingAlignmentBaseRule {
    public string Name { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapImplementsHandlesSectionItems : WrapBase {
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapInvocationArguments : WrapBase {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapLogicalOperatorExpression : ExpressionsWrappingAlignmentBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public virtual string get_Name();
    protected virtual void ValueChanged(object oldValue);
    public virtual string get_SubCategory();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapLongLines : WrappingAlignmentBaseRule {
    public string Name { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapMembersInAnonymousType : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapMultiVariableDeclaration : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
internal abstract class DevExpress.CodeParser.CodeStyle.Formatting.WrappingAlignmentBaseRule : BaseFormattingRule {
    public FormattingCategory Category { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public object DefaultValue { get; }
    public virtual FormattingCategory get_Category();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
    public virtual object get_DefaultValue();
}
public class DevExpress.CodeParser.CodeStyle.Formatting.WrappingAlignmentFormattingOptions : FormattingOptions {
    private bool _WrapLongLines;
    private int _MaxLineLength;
    private bool _RightMarginColumnSize;
    private bool _WrapFormalParameters;
    private bool _WrapFirstFormalParameter;
    private bool _AlignWithFirstFormalParameter;
    private bool _WrapBeforeOpenBraceInDeclaration;
    private bool _WrapBeforeCloseBraceInDeclaration;
    private bool _WrapInvocationArguments;
    private bool _WrapFirstInvocationArgument;
    private bool _AlignWithFirstInvocationArgument;
    private bool _WrapBeforeOpenBraceInInvocation;
    private bool _WrapBeforeCloseBraceInInvocation;
    private bool _WrapTernaryExpression;
    private bool _WrapLogicalOperatorExpression;
    private bool _WrapBinaryOperatorExpression;
    private bool _WrapBeforeOperatorInLogicalExpression;
    private bool _WrapBeforeOperatorInBinaryExpression;
    private bool _AlignWithFirstBinaryExpressionItem;
    private bool _AlignWithFirstLogicalExpressionItem;
    private bool _WrapQueryExpression;
    private bool _AlignWithFirstQueryExpressionItem;
    private bool _WrapTypeParameters;
    private bool _WrapFirstTypeParameter;
    private bool _AlignWithFirstTypeParameterConstraint;
    private bool _WrapTypeParameterConstraints;
    private bool _WrapFirstTypeParameterConstraint;
    private bool _AlignWithFirstTypeParameter;
    private bool _WrapImplementsHandlesSectionItems;
    private bool _WrapFirstImplementsHandlesSectionItem;
    private bool _AlignWithFirstImplementsHandlesSectionItem;
    private bool _WrapArrayObjectAndCollectionInitializers;
    private bool _WrapFirstArrayObjectAndCollectionInitializer;
    private bool _AlignWithFirstArrayObjectOrCollectionInitializerItem;
    private bool _WrapMembersInAnonymousType;
    private bool _WrapFirstMemberInAnonymousType;
    private bool _AlignWithFirstMemberInAnonymousType;
    private bool _WrapFirstMultiVariableDeclaration;
    private bool _WrapMultiVariableDeclaration;
    private bool _AlignWithFirstMultiVariableDeclarationItem;
    private bool _WrapForStatementHeader;
    private bool _WrapAncestorsListInTypeDeclaration;
    private bool _WrapFirstAncestorsListItem;
    private bool _AlignWithFirstAncestorsListItem;
    private bool _WrapBeforeColonForAncestorsList;
    public bool WrapLongLines { get; }
    public int MaxLineLength { get; }
    public bool RightMarginColumnSize { get; }
    public bool WrapFormalParameters { get; }
    public bool WrapFirstFormalParameter { get; }
    public bool AlignWithFirstFormalParameter { get; }
    public bool WrapBeforeOpenBraceInDeclaration { get; }
    public bool WrapBeforeCloseBraceInDeclaration { get; }
    public bool WrapInvocationArguments { get; }
    public bool WrapFirstInvocationArgument { get; }
    public bool AlignWithFirstInvocationArgument { get; }
    public bool WrapBeforeCloseBraceInInvocation { get; }
    public bool WrapBeforeOpenBraceInInvocation { get; }
    public bool WrapTernaryExpression { get; }
    public bool WrapLogicalOperatorExpression { get; }
    public bool WrapBinaryOperatorExpression { get; }
    public bool WrapBeforeOperatorInLogicalExpression { get; }
    public bool WrapBeforeOperatorInBinaryExpression { get; }
    public bool AlignWithFirstBinaryExpressionItem { get; }
    public bool AlignWithFirstLogicalExpressionItem { get; }
    public bool WrapQueryExpression { get; }
    public bool AlignWithFirstQueryExpressionItem { get; }
    public bool WrapTypeParameters { get; }
    public bool WrapFirstTypeParameter { get; }
    public bool WrapTypeParameterConstraints { get; }
    public bool WrapFirstTypeParameterConstraint { get; }
    public bool AlignWithFirstTypeParameter { get; }
    public bool AlignWithFirstTypeParameterConstraint { get; }
    public bool WrapImplementsHandlesSectionItems { get; }
    public bool WrapFirstImplementsHandlesSectionItem { get; }
    public bool AlignWithFirstImplementsHandlesSectionItem { get; }
    public bool WrapArrayObjectAndCollectionInitializers { get; }
    public bool WrapFirstArrayObjectAndCollectionInitializer { get; }
    public bool AlignWithFirstArrayObjectOrCollectionInitializerItem { get; }
    public bool WrapMembersInAnonymousType { get; }
    public bool WrapFirstMemberInAnonymousType { get; }
    public bool AlignWithFirstMemberInAnonymousType { get; }
    public bool WrapFirstMultiVariableDeclaration { get; }
    public bool WrapMultiVariableDeclaration { get; }
    public bool AlignWithFirstMultiVariableDeclarationItem { get; }
    public bool WrapForStatementHeader { get; }
    public bool WrapAncestorsListInTypeDeclaration { get; }
    public bool WrapFirstAncestorsListItem { get; }
    public bool AlignWithFirstAncestorsListItem { get; }
    public bool WrapBeforeColonForAncestorsList { get; }
    public virtual void Load(FormattingRuleCollection rules);
    public virtual void LoadDefault(ParserLanguageID language);
    public bool get_WrapLongLines();
    public int get_MaxLineLength();
    public bool get_RightMarginColumnSize();
    public bool get_WrapFormalParameters();
    public bool get_WrapFirstFormalParameter();
    public bool get_AlignWithFirstFormalParameter();
    public bool get_WrapBeforeOpenBraceInDeclaration();
    public bool get_WrapBeforeCloseBraceInDeclaration();
    public bool get_WrapInvocationArguments();
    public bool get_WrapFirstInvocationArgument();
    public bool get_AlignWithFirstInvocationArgument();
    public bool get_WrapBeforeCloseBraceInInvocation();
    public bool get_WrapBeforeOpenBraceInInvocation();
    public bool get_WrapTernaryExpression();
    public bool get_WrapLogicalOperatorExpression();
    public bool get_WrapBinaryOperatorExpression();
    public bool get_WrapBeforeOperatorInLogicalExpression();
    public bool get_WrapBeforeOperatorInBinaryExpression();
    public bool get_AlignWithFirstBinaryExpressionItem();
    public bool get_AlignWithFirstLogicalExpressionItem();
    public bool get_WrapQueryExpression();
    public bool get_AlignWithFirstQueryExpressionItem();
    public bool get_WrapTypeParameters();
    public bool get_WrapFirstTypeParameter();
    public bool get_WrapTypeParameterConstraints();
    public bool get_WrapFirstTypeParameterConstraint();
    public bool get_AlignWithFirstTypeParameter();
    public bool get_AlignWithFirstTypeParameterConstraint();
    public bool get_WrapImplementsHandlesSectionItems();
    public bool get_WrapFirstImplementsHandlesSectionItem();
    public bool get_AlignWithFirstImplementsHandlesSectionItem();
    public bool get_WrapArrayObjectAndCollectionInitializers();
    public bool get_WrapFirstArrayObjectAndCollectionInitializer();
    public bool get_AlignWithFirstArrayObjectOrCollectionInitializerItem();
    public bool get_WrapMembersInAnonymousType();
    public bool get_WrapFirstMemberInAnonymousType();
    public bool get_AlignWithFirstMemberInAnonymousType();
    public bool get_WrapFirstMultiVariableDeclaration();
    public bool get_WrapMultiVariableDeclaration();
    public bool get_AlignWithFirstMultiVariableDeclarationItem();
    public bool get_WrapForStatementHeader();
    public bool get_WrapAncestorsListInTypeDeclaration();
    public bool get_WrapFirstAncestorsListItem();
    public bool get_AlignWithFirstAncestorsListItem();
    public bool get_WrapBeforeColonForAncestorsList();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapQueryExpression : WrapBase {
    public string Name { get; }
    public object DefaultValue { get; }
    public string SubCategory { get; }
    public ParserLanguageID SupportedLanguage { get; }
    public virtual string get_Name();
    public virtual object get_DefaultValue();
    public virtual string get_SubCategory();
    public virtual ParserLanguageID get_SupportedLanguage();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapTernaryExpression : ExpressionsWrappingAlignmentBaseRule {
    public string Name { get; }
    public virtual string get_Name();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapTypeParameterConstraints : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public object DefaultValue { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
    public virtual object get_DefaultValue();
}
internal class DevExpress.CodeParser.CodeStyle.Formatting.WrapTypeParameters : WrapBase {
    public string SubCategory { get; }
    public string Name { get; }
    public virtual string get_SubCategory();
    public virtual string get_Name();
}
public class DevExpress.CodeParser.CodeWriter : object {
    private CodeGenOptions _Options;
    private TextWriter _Writer;
    private int _IndentLevel;
    private int _PrecedingWhiteSpaceCount;
    private string _IndentString;
    private string _LastLine;
    private string _LineContinuation;
    public bool WriteWithoutIndentStringOneTime;
    private int _LineTerminatorCount;
    private Stack`1<string> _Alignment;
    private Stack`1<int> _IndentLevelStack;
    private string Alignment { get; }
    protected internal string IndentString { get; protected internal set; }
    public int IndentLevel { get; public set; }
    public string Code { get; }
    public CodeGenOptions Options { get; }
    public bool IsAtWhitespace { get; }
    public int PrecedingWhiteSpaceCount { get; public set; }
    public int LineTerminatorCount { get; public set; }
    public string LastLine { get; }
    public string LastLineInSpaces { get; }
    public string LastLineInSpacesWithoutIndent { get; }
    public CodeWriter(TextWriter writer, CodeGenOptions options, string lineContinuation);
    public CodeWriter(TextWriter writer, CodeGenOptions options);
    public void IncreaseAlignment();
    public void DecreaseAlignment();
    private string get_Alignment();
    private string GetIndentString(int level);
    private string GetPrecedingString();
    private String[] SplitLines(string s);
    private String[] SplitLines(string s, bool split);
    private void WriteInternal(string s);
    public void Indent();
    public void IncreaseIndent();
    public void DecreaseIndent();
    public void WriteLines(String[] lines, bool finishWithCR);
    public void Write(string s);
    public void Write(string s, bool split);
    public void Write(string format, Object[] arg);
    public void WriteClearFormat(string s);
    public void WriteLine(string s);
    public void WriteLine(string s, bool split);
    public void WriteLine(string format, Object[] arg);
    public void WriteLine();
    public void WriteOpenBrace(LanguageElement element);
    public void ClearIndent();
    public void RestoreIndent();
    protected internal string get_IndentString();
    protected internal void set_IndentString(string value);
    public int get_IndentLevel();
    public void set_IndentLevel(int value);
    public string get_Code();
    public CodeGenOptions get_Options();
    public bool get_IsAtWhitespace();
    public int get_PrecedingWhiteSpaceCount();
    public void set_PrecedingWhiteSpaceCount(int value);
    public int get_LineTerminatorCount();
    public void set_LineTerminatorCount(int value);
    public string get_LastLine();
    public string get_LastLineInSpaces();
    public string get_LastLineInSpacesWithoutIndent();
}
public enum DevExpress.CodeParser.CollectionType : Enum {
    public int value__;
    public static CollectionType Unknown;
    public static CollectionType IElementCollection;
    public static CollectionType AttributeElementCollection;
    public static CollectionType CaseClauseCollection;
    public static CollectionType CaseStatementCollection;
    public static CollectionType ExpressionCollection;
    public static CollectionType HtmlAttributeCollection;
    public static CollectionType JoinExpressionCollection;
    public static CollectionType MemberElementCollection;
    public static CollectionType NamespaceElementCollection;
    public static CollectionType ParameterElementCollection;
    public static CollectionType ProjectElementCollection;
    public static CollectionType QueryIdentCollection;
    public static CollectionType SourceFileCollection;
    public static CollectionType TypeElementCollection;
    public static CollectionType TypeParameterCollection;
    public static CollectionType TypeParameterConstraintCollection;
    public static CollectionType TypeReferenceExpressionCollection;
    public static CollectionType VariableDeclarationStatementCollection;
    public static CollectionType XmlAttributeDeclarationCollection;
    public static CollectionType XmlContentParticleCollection;
    public static CollectionType TextRangeCollection;
    public static CollectionType LiteElementCollection;
    public static CollectionType CssSelectorCollection;
    public static CollectionType CssExpressionCollection;
    public static CollectionType CssPropertyDeclarationCollection;
    public static CollectionType CssElementCollection;
    public static CollectionType CssTermCollection;
}
public class DevExpress.CodeParser.Comment : SupportElement {
    private static int INT_MaintainanceComplexity;
    private int _TextStartOffset;
    private CommentType _CommentType;
    private bool _IsUnfinished;
    private int _StartPos;
    private int _EndPos;
    protected int ThisMaintenanceComplexity { get; }
    public int StartPos { get; public set; }
    public int EndPos { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsUnfinished { get; public set; }
    public int TextStartOffset { get; }
    public CommentType CommentType { get; public set; }
    public Comment NextConnectedComment { get; }
    public Comment PreviousConnectedComment { get; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public void GetFirstAndLastConnectedComments(Comment& first, Comment& last);
    [EditorBrowsableAttribute("1")]
public void SetCommentType(CommentType aCommentType);
    [EditorBrowsableAttribute("1")]
public void SetTextStartOffset(int aTextStartOffset);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public int get_StartPos();
    public void set_StartPos(int value);
    public int get_EndPos();
    public void set_EndPos(int value);
    public bool get_IsUnfinished();
    public void set_IsUnfinished(bool value);
    public int get_TextStartOffset();
    public CommentType get_CommentType();
    public void set_CommentType(CommentType value);
    public Comment get_NextConnectedComment();
    public Comment get_PreviousConnectedComment();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.CommentBuilder : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; private set; }
    public CommentBuilder(string language);
    public string GetComment(string label);
    public string GetComment(string label, string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(string value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.CommentCollection : LanguageElementCollection {
    public Comment Item { get; public set; }
    public Comment LastComment { get; }
    protected virtual NodeList CreateInstance();
    public int Add(Comment aComment);
    public void AddRange(CommentCollection collection);
    public int IndexOf(Comment aComment);
    public void Insert(int index, Comment aComment);
    public void Remove(Comment aComment);
    public Comment Find(Comment aComment);
    public Comment FindFirst(string name);
    public Comment FindLast(string name);
    public bool Contains(Comment aComment);
    public Comment get_Item(int index);
    public void set_Item(int index, Comment value);
    public Comment get_LastComment();
}
public enum DevExpress.CodeParser.CommentTagKind : Enum {
    public byte value__;
    public static CommentTagKind Open;
    public static CommentTagKind Close;
}
public enum DevExpress.CodeParser.CommentType : Enum {
    public byte value__;
    public static CommentType SingleLine;
    public static CommentType MultiLine;
}
public class DevExpress.CodeParser.CompilerDirective : PreprocessorDirective {
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual int GetImageIndex();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.CompilerDirectiveCollection : NodeList {
    public CompilerDirective Item { get; }
    public void Add(CompilerDirective directive);
    public void Remove(CompilerDirective directive);
    public CompilerDirective Find(string directive);
    protected virtual NodeList CreateInstance();
    public CompilerDirective get_Item(int aIndex);
}
public class DevExpress.CodeParser.ComplexAndFilter : ElementFilterBase {
    private IElementFilter[] _Filters;
    public ComplexAndFilter(IElementFilter[] filters);
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
}
public class DevExpress.CodeParser.ComplexConstructorInitializer : ConstructorInitializer {
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ComplexExpression : Expression {
    private ExpressionCollection _Expressions;
    public LanguageElementType ElementType { get; }
    public ExpressionCollection Expressions { get; public set; }
    private IExpressionCollection DevExpress.CodeParser.IComplexExpression.Expressions { get; }
    private void SetExpressions(ExpressionCollection expressions);
    public virtual string ToString();
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddExpression(Expression expression);
    public void AddExpressions(IEnumerable`1<Expression> expressions);
    public virtual LanguageElementType get_ElementType();
    public ExpressionCollection get_Expressions();
    public void set_Expressions(ExpressionCollection value);
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IComplexExpression.get_Expressions();
}
public enum DevExpress.CodeParser.ComplexFactorType : Enum {
    public int value__;
    public static ComplexFactorType Error;
    public static ComplexFactorType Parens;
    public static ComplexFactorType Brackets;
    public static ComplexFactorType Braces;
}
public class DevExpress.CodeParser.ComplexGenericModifier : GenericModifier {
    private LanguageElementCollection _GenericModifiers;
    public LanguageElementType ElementType { get; }
    public LanguageElementCollection GenericModifiers { get; }
    public int GenericModifiersCount { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public LanguageElementCollection get_GenericModifiers();
    public int get_GenericModifiersCount();
}
public class DevExpress.CodeParser.ComplexOrFilter : ElementFilterBase {
    private IElementFilter[] _Filters;
    public ComplexOrFilter(IElementFilter[] filters);
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
}
public class DevExpress.CodeParser.ConditionalExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _Condition;
    private Expression _TrueExpression;
    private Expression _FalseExpression;
    private bool _IsNeededResultsCasting;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Condition { get; public set; }
    public Expression TrueExpression { get; public set; }
    public Expression FalseExpression { get; public set; }
    private IExpression DevExpress.CodeParser.IConditionalExpression.Condition { get; }
    private IExpression DevExpress.CodeParser.IConditionalExpression.TrueExpression { get; }
    private IExpression DevExpress.CodeParser.IConditionalExpression.FalseExpression { get; }
    [EditorBrowsableAttribute("1")]
public bool IsNeededResultsCasting { get; public set; }
    public ConditionalExpression(Expression condition, Expression trueExpression, Expression falseExpression);
    protected void SetCondition(Expression condition);
    protected void SetTrueExpression(Expression trueExpression);
    protected void SetFalseExpression(Expression falseExpression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual int GetCyclomaticComplexity();
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public Expression get_TrueExpression();
    public void set_TrueExpression(Expression value);
    public Expression get_FalseExpression();
    public void set_FalseExpression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IConditionalExpression.get_Condition();
    private sealed virtual override IExpression DevExpress.CodeParser.IConditionalExpression.get_TrueExpression();
    private sealed virtual override IExpression DevExpress.CodeParser.IConditionalExpression.get_FalseExpression();
    public bool get_IsNeededResultsCasting();
    public void set_IsNeededResultsCasting(bool value);
}
public class DevExpress.CodeParser.ConditionalParentingStatement : ParentingStatement {
    public virtual int GetCyclomaticComplexity();
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public class DevExpress.CodeParser.ConditionalParentToSingleStatement : ParentToSingleStatement {
    public virtual int GetCyclomaticComplexity();
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public class DevExpress.CodeParser.ConditionalTypeCast : BinaryOperatorExpression {
    private static int INT_MaintainanceComplexity;
    private bool _IsIfOperator;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public bool IsIfOperator { get; public set; }
    public ConditionalTypeCast(Expression left, Token token, Expression right);
    public ConditionalTypeCast(Expression left, Expression right);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual bool IsIdenticalTo(Expression expression);
    public sealed virtual bool get_IsIfOperator();
    public sealed virtual void set_IsIfOperator(bool value);
}
public class DevExpress.CodeParser.Const : InitializedValue {
    public LanguageElementType ElementType { get; }
    public Expression Value { get; public set; }
    public bool IsConst { get; }
    public Const(string name);
    public Const(string type, string name);
    public Const(string type, string name, Expression expr);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Value();
    public void set_Value(Expression value);
    public virtual bool get_IsConst();
}
public class DevExpress.CodeParser.ConstCastExpression : CppTypeCastExpression {
    public LanguageElementType ElementType { get; }
    protected virtual string GetString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ConstDirective : CompilerDirective {
    private string _Expression;
    public string Expression { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public string get_Expression();
    public void set_Expression(string value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ConstructorFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
}
public class DevExpress.CodeParser.ConstructorInitializer : CodeElement {
    private InitializerTarget _Target;
    private ExpressionCollection _Arguments;
    private SourceRange _ParensRange;
    private SourceRange _NameRange;
    public bool IsBase { get; }
    public bool IsThis { get; }
    public ExpressionCollection Arguments { get; public set; }
    public InitializerTarget Target { get; public set; }
    public LanguageElementType ElementType { get; }
    private InitializerTarget DevExpress.CodeParser.IConstructorInitializerElement.Target { get; }
    private IExpressionCollection DevExpress.CodeParser.IConstructorInitializerElement.Arguments { get; }
    private IExpression DevExpress.CodeParser.IConstructorInitializerElement.Expression { get; }
    public int ArgumentsCount { get; }
    public SourceRange ParensRange { get; public set; }
    public SourceRange NameRange { get; public set; }
    public virtual int GetImageIndex();
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected void SetIsBase(bool value);
    protected void SetIsThis(bool value);
    protected void SetArguments(ExpressionCollection arguments);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public bool get_IsBase();
    public bool get_IsThis();
    public sealed virtual ExpressionCollection get_Arguments();
    public void set_Arguments(ExpressionCollection value);
    public InitializerTarget get_Target();
    public void set_Target(InitializerTarget value);
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override InitializerTarget DevExpress.CodeParser.IConstructorInitializerElement.get_Target();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IConstructorInitializerElement.get_Arguments();
    private sealed virtual override IExpression DevExpress.CodeParser.IConstructorInitializerElement.get_Expression();
    public sealed virtual void AddArgument(Expression arg);
    public sealed virtual int get_ArgumentsCount();
    public sealed virtual SourceRange get_ParensRange();
    public void set_ParensRange(SourceRange value);
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
}
public class DevExpress.CodeParser.ConstStaticMembersOrTypesFilter : ElementFilterBase {
    private bool _NonPrivate;
    private NonPrivateMemberFilter _NonPrivateFilter;
    unknown bool NonPrivate {public set; }
    public ConstStaticMembersOrTypesFilter(bool nonPrivate);
    public virtual bool Apply(IElement element);
    public void set_NonPrivate(bool value);
}
public class DevExpress.CodeParser.ConstVolatile : Const {
    public LanguageElementType ElementType { get; }
    public ConstVolatile(string name);
    public ConstVolatile(string type, string name);
    public ConstVolatile(string type, string name, Expression expr);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ContentPlaceHolder : ServerControlElement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.Continue : FlowBreak {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual LanguageElement FindTarget();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ControlDirective : AspDirective {
    public LanguageElementType ElementType { get; }
    public string Inherits { get; public set; }
    public string CodeFile { get; public set; }
    public string CodeBehind { get; public set; }
    public string Src { get; public set; }
    public string Language { get; public set; }
    public string AutoEventWireUp { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Inherits();
    public void set_Inherits(string value);
    public string get_CodeFile();
    public void set_CodeFile(string value);
    public string get_CodeBehind();
    public void set_CodeBehind(string value);
    public string get_Src();
    public void set_Src(string value);
    public string get_Language();
    public void set_Language(string value);
    public string get_AutoEventWireUp();
    public void set_AutoEventWireUp(string value);
}
public class DevExpress.CodeParser.CppAttributeSection : AttributeSection {
    private AttributeTargetType _TargetType;
    public AttributeTargetType TargetType { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public AttributeTargetType get_TargetType();
    public void set_TargetType(AttributeTargetType value);
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.CppMethodReferenceExpression : MethodReferenceExpression {
    public CppMethodReferenceExpression(Expression source, string name, SourceRange namerange);
    protected abstract virtual string GetNameWithQualifier();
    public virtual string ToString();
}
public class DevExpress.CodeParser.CppQualifiedElementReference : QualifiedElementReference {
    public LanguageElementType ElementType { get; }
    public CppQualifiedElementReference(Expression source, string name, SourceRange namerange);
    protected virtual string GetNameWithQualifier();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.CppTypeCastExpression : TypeCastExpression {
    protected abstract virtual string GetString();
    public virtual string ToString();
}
public abstract class DevExpress.CodeParser.CppTypeParameter : TypeParameter {
    private SourceRange _NameRange;
    public SourceRange NameRange { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
}
public class DevExpress.CodeParser.CPrimitiveExpression : PrimitiveExpression {
    public bool CanHasEscapeSequence { get; }
    public CPrimitiveExpression(string value);
    public CPrimitiveExpression(string value, SourceRange range);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool get_CanHasEscapeSequence();
}
public class DevExpress.CodeParser.CSharp.CodeGenHelper : object {
    private static string STR_Public;
    private static string STR_Private;
    private static string STR_Protected;
    private static string STR_Internal;
    private static string STR_ProtectedInternal;
    private static bool HasTypeParameterConstraints(TypeParameterCollection typeParams);
    public static void GenerateAccessSpecifiers(LanguageElementCodeGenBase leGen);
    public static void GenerateVisibility(LanguageElementCodeGenBase leGen);
    public static void GenerateVisibility(LanguageElementCodeGenBase leGen, MemberVisibility visibility);
    public static bool HasTypeParameterConstraints(GenericModifier modifier);
    public static bool HasTypeParameterConstraints(TypeParameter param);
    public static void GenerateExpressionListForMethodCall(ExpressionCollection expressions, string delimiter, CodeGen codeGen);
    public static string GetVisibility(MemberVisibility visibility);
}
public class DevExpress.CodeParser.CSharp.CSharp10KeyWords : object {
    private static StringCollection _KeyWords;
    public static StringCollection Collection { get; }
    private static CSharp10KeyWords();
    public static StringCollection get_Collection();
    public static bool Contains(string word);
}
public class DevExpress.CodeParser.CSharp.CSharp10Tokens : CSharpTokensBase {
    private static CSharpTokensBase _Instance;
    public static CSharpTokensBase Instance { get; }
    protected virtual StringCollection CreateKeywords();
    public static CSharpTokensBase get_Instance();
}
public class DevExpress.CodeParser.CSharp.CSharp20KeyWords : object {
    private static StringCollection _KeyWords;
    public static StringCollection Collection { get; }
    private static CSharp20KeyWords();
    public static StringCollection get_Collection();
    public static bool Contains(string word);
}
public class DevExpress.CodeParser.CSharp.CSharp20Tokens : CSharpTokensBase {
    private static CSharpTokensBase _Instance;
    public static CSharpTokensBase Instance { get; }
    protected virtual StringCollection CreateKeywords();
    public static CSharpTokensBase get_Instance();
}
public class DevExpress.CodeParser.CSharp.CSharp30ExpressionParser : ExpressionParserBase {
    public CSharp30ExpressionParser(ParserBase parser);
    private CSharp30Parser GetParser();
    private void UseLikeExpressionParser(Action`1<CSharp30Parser> action);
    public virtual Expression Parse(ISourceReader reader);
    public virtual TypeReferenceExpression ParseTypeReferenceExpression(ISourceReader reader);
}
public class DevExpress.CodeParser.CSharp.CSharp30Parser : FormattingParserBase {
    private static string STR_Cs;
    private static int INT_MaxNestingLevel;
    private ArrayList ccs;
    private bool IsAsyncContext;
    private bool _WorkAsCSharp30Parser;
    private CommentCollection _Comments;
    private Stack _Regions;
    private bool _PreviousTokenWasComment;
    private bool _ShouldWorkAsExpressionParser;
    private LanguageElement _UnclosedMemberContext;
    private int _StatementNestingLevel;
    private int _FirstTokenStartPosition;
    private ISourceReader _Reader;
    private bool _ParsingPostponedTokens;
    private Hashtable _PrimitiveToFullTypes;
    private QueryExpression _ActiveSqlExpression;
    private CSharpPreprocessor _Preprocessor;
    private bool _ParsingRazor;
    private RazorParsingMode _RazorParsingMode;
    private static int maxTerminals;
    protected static BitArray unaryOp;
    protected static BitArray typeKW;
    protected static BitArray unaryHead;
    protected static BitArray assnStartOp;
    protected static BitArray castFollower;
    protected static BitArray typArgLstFol;
    protected static BitArray keyword;
    protected static BitArray assgnOps;
    protected bool ShouldSkipMethodBody { get; }
    protected Stack Regions { get; }
    public string Language { get; }
    public CommentCollection Comments { get; }
    public bool ShouldWorkAsExpressionParser { get; public set; }
    public bool WorkAsCSharp30Parser { get; public set; }
    protected ISourceReader Reader { get; protected set; }
    protected bool ParsingPostponedTokens { get; protected set; }
    protected Hashtable PrimitiveToFullTypes { get; protected set; }
    protected QueryExpression ActiveSqlExpression { get; protected set; }
    protected CSharpPreprocessor Preprocessor { get; protected set; }
    private static CSharp30Parser();
    protected virtual void HandlePragmas();
    private void Parser();
    private void ExternAliasDirective();
    private void UsingDirective();
    private void GlobalAttributes();
    private void NamespaceMemberDeclaration();
    private void ElementReferenceName(ElementReferenceExpression& refExpr);
    private void NamespaceMemberDeclarations();
    private void NamespaceMemberDeclarationEnd(LanguageElement namespaceOrType, bool addToList);
    private void AccessorDeclarations();
    private void ClassMemberSeq();
    private void StatementSeq();
    private void AttributeSections(LanguageElementCollection& attributes);
    private void ModifierList(AccessSpecifiers& accessSpecifiers, MemberVisibility& visibility);
    private void ClassMemberDeclaration(AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void Statement();
    private void TypeDeclaration(AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void TypeParameterList(GenericModifier& genericModifier);
    private void ClassBase(TypeDeclaration typeDecl);
    private void TypeParameterConstraintsClause(GenericModifier genericModifier);
    private void ClassBody(TypeDeclaration classDecl);
    private void StructBody(TypeDeclaration structDecl);
    private void IntegralType(TypeReferenceExpression& type);
    private void EnumBody(TypeDeclaration enumDecl);
    private void Type(TypeReferenceExpression& type, bool ignoreTypeCastChecks);
    private void FormalParameterList(LanguageElementCollection& parameters, Hashtable& parameterAttributes);
    private void ClassType(TypeReferenceExpression& type);
    private void TypeName(TypeReferenceExpression& refExpr);
    private void StructMemberDeclaration(AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void EnumMembers();
    private void EnumMemberDeclaration();
    private void BlockCore(bool isMethodBlock);
    private void FixedBufferFieldDecl(TypeReferenceExpression typeRef, AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes, SourceRange startRange);
    private void Expression(Expression& expression);
    private void FieldDecl(TypeReferenceExpression typeRef, AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void VariableInitializer(Expression& expression);
    private void FixedFieldDecl(TypeReferenceExpression typeRef);
    private void ForFieldDecl(TypeReferenceExpression typeRef);
    private void UsingFieldDecl(TypeReferenceExpression typeRef);
    private void ImplicitForFieldDecl();
    private void ImplicitUsingFieldDecl();
    private void ConstantDefinition(AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void ConstructorDeclaration(AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void ArgumentCollection(ExpressionCollection& arguments);
    private void OverloadableOperator(TypeReferenceExpression typeRef, AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void OverloadableOp(String& name, SourceRange& nameRange, OperatorType& operatorType);
    private void MethodDeclaration(TypeReferenceExpression typeRef, ElementReferenceExpression memberName, AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void PropertyDeclaration(TypeReferenceExpression type, ElementReferenceExpression name, AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void AccessorDeclarationsSeq();
    private void IndexerDeclaration(TypeReferenceExpression type, ElementReferenceExpression qualifier, AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void CastOperator(AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void EventDeclaration(AccessSpecifiers accessSpecifiers, MemberVisibility visibility, LanguageElementCollection attributes);
    private void MemberName(ElementReferenceExpression& refExpr);
    private void EventAccessorDeclarationsSeq();
    private void ImplicitLocalVariableDeclaration();
    private void ImplicitFixedFieldDecl();
    private void LocalVariableDeclaration();
    private void ForVariableDeclaration();
    private void UsingVariableDeclaration();
    private void Argument(Expression& expression, bool supportsNamedArgument);
    private void ArrayInitializer(ArrayInitializerExpression& initializer);
    private void ParameterDeclaration(Param& parameter, LanguageElementCollection& attributes);
    private void Name();
    private void EventAccessorDeclarations();
    private void Attributes(AttributeSection& attrSection);
    private void Attribute(Attribute& attributeDef);
    private void Keyword();
    private void AttributeArguments(Attribute attributeDef);
    private void ModifierListCore(AccessSpecifiers& accessSpecifiers, MemberVisibility& visibility, Boolean& wasProtectedInternal, Boolean& wasInternalProtected);
    private void SimpleType(TypeReferenceExpression& type, bool ignoreTypeCastChecks);
    private void PrimitiveLanguageType(TypeReferenceExpression& type);
    private void TypeArgumentList(ReferenceExpressionBase reference, TypeReferenceExpressionCollection& typeArguments);
    private void PointerOrArray(TypeReferenceExpression& type);
    private void ResolvedType(TypeReferenceExpression& type);
    private void Pointer(TypeReferenceExpression& type);
    private void RazorHtmlCode(LanguageElementCollection& result);
    private void EmbeddedStatement();
    private void StatementExpression();
    private void SwitchSection();
    private void ForInitializer();
    private void ForIterator();
    private void TryCatchFinallyBlock();
    private void ResourceAcquisition();
    private void CatchClauses();
    private void FinallyBlock();
    private void SwitchLabel();
    private void AssignmentOperator(Token& operatorToken, AssignmentOperatorType& assignmentOperator);
    private void LambdaExpression(Expression& result);
    private void SqlExpression(Expression& sqlExpression);
    private void Unary(Expression& expression);
    private void NullCoalescingExpr(Expression& expression, Expression leftPart);
    private void FromClause();
    private void QueryBody();
    private void QueryIdent(QueryIdent& ident);
    private void InExpression(InExpression& inExpression);
    private void JoinClause();
    private void EqualsExpression(EqualsExpression& expression);
    private void FromLetWhereClause();
    private void SelectOrGroupClause();
    private void QueryContinuation();
    private void LetClause();
    private void OrderByClause();
    private void WhereClause();
    private void Orderings(OrderByExpression orderBy);
    private void Ordering(OrderingExpression& ordering);
    private void LambdaParameterList(LambdaExpression lambdaExpression);
    private void LambdaExpressionBody(Expression parentLambdaExpression);
    private void LambdaParameter(Param& parameter);
    private void OrExpr(Expression& expression, Expression leftPart);
    private void AndExpr(Expression& expression, Expression leftPart);
    private void BitOrExpr(Expression& expression, Expression leftPart);
    private void BitXorExpr(Expression& expression, Expression leftPart);
    private void BitAndExpr(Expression& expression, Expression leftPart);
    private void EqlExpr(Expression& expression, Expression leftPart);
    private void RelExpr(Expression& expression, Expression leftPart);
    private void ShiftExpr(Expression& expression, Expression leftPart);
    private void AddExpr(Expression& expression, Expression leftPart);
    private void MulExpr(Expression& expression, Expression leftPart);
    private void Primary(Expression& expression, UnaryOperatorType typeOperator);
    private void Literal(Expression& expression, UnaryOperatorType typeOperator);
    private void AnonymousMethodExpression(Expression& expression, bool isAsync);
    private void AwaitExpression(Expression& result);
    private void ObjectCreationExpression(Expression& expression);
    private void TypeOfSizeOfDefaultExpression(Expression& expression);
    private void CheckedUncheckedExpression(Expression& expression);
    private void RefValueArguments(ExpressionCollection& arguments);
    private void ObjectInitializer(Expression& expression);
    private void MemberInitializerList(ObjectInitializerExpression objectInitializer);
    private void MemberInitializerExpression(Expression& expression);
    private void MemberInitializer(Expression& result);
    private void InitializerValue(Expression& expression);
    private void TypeArgDirection(TypeParameterDirection& typeArgumentDirection);
    private void Parse();
    private void SetLastFormattingType(FormattingTokenType type);
    protected virtual Boolean[0...,0...] CreateSetArray();
    private void CallAppropriateParseRule(LanguageElement context);
    protected virtual LanguageElement DoParse(ParserContext parserContext, ISourceReader reader);
    public LanguageElement Parse(ISourceReader reader);
    public Expression ParseExpression(ISourceReader reader);
    public LanguageElementCollection ParseFormalParameters(ISourceReader reader);
    public ExpressionCollection ParseMethodCallParameters(ISourceReader reader);
    private GeneratedScannerBase CreateScanner(ISourceReader s, ScannerExtension extension);
    private GeneratedScannerBase CreateScanner(ISourceReader s);
    public LanguageElementCollection ParseStatements(ISourceReader reader);
    public TypeReferenceExpression ParseTypeReferenceExpression(ISourceReader reader);
    protected LanguageElementCollection ParseRazorExpression();
    private ISourceReader GetRazorReader();
    private void SetHasEndingSemicolonIfNeeded(LanguageElement namespaceOrType);
    protected void ParseRazorHtmlEmbedding(LanguageElementCollection& htmlParseResult);
    private bool IsNamespaceReference(Token token);
    private bool IsAwaitExpression();
    private bool IsAsyncModifier();
    private bool IsAsyncDelegate();
    public sealed virtual LanguageElementCollection ParseRazorCode(ISourceReader reader, Int32& scannerPositionDelta);
    public sealed virtual LanguageElement ParseRazorHelper(ISourceReader reader, Int32& scannerPositionDelta);
    private LanguageElement ParseRazorHelper();
    public sealed virtual LanguageElementCollection ParseRazorFunctions(ISourceReader reader, Int32& scannerPositionDelta);
    private LanguageElementCollection ParseRazorFunctions();
    protected bool IsRazorInlineExpression();
    protected bool IsRazorHtmlCode();
    protected LanguageElementCollection ParseRazorStatement();
    protected LanguageElementCollection ParseNamespaceReference();
    protected bool IsValidRazorStatementStart(Token token);
    protected Token CreatePostponedToken(Token left, Token right);
    protected void CorrectFormattingTokenType(Token token);
    private void ParseMemberEnd(LanguageElementType elementType);
    private void ParseMethodEnd();
    protected void SkipMethodBody();
    protected void SkipTo(int tokenType);
    protected bool IsAccessorDeclaration();
    protected virtual TokenCategory GetTokenCategory(CategorizedToken token);
    protected JoinExpressionBase ConvertToJoinIntoExpression(JoinExpressionBase joinBase, QueryIdent intoName);
    protected QueryIdent CreateQueryIdent(Token nameToken, SourceRange operatorRange, Expression initializer);
    protected virtual void CleanUpParser();
    private bool TokenIsComment(int tokenType);
    private SourceFile GetFileNode();
    private SourceRange CalculateRegionNameRange(int startLine, int tokenOffset, string regionName, string tokenValue);
    private bool TokenIsSupportElement(int tokenType);
    private bool IsConditionalExpressionCore();
    protected bool IsConditionalExpressionStart();
    protected void AddToSqlExpression(Expression expression);
    protected void SetAttributesForParameters(LanguageElementCollection parameters, Hashtable parameterAttributes);
    protected void AddImplicitParamToAccessor(Member member, Accessor accessor);
    public virtual SourceFile GetSourceFile(string fileName);
    private FormattingElements CutElementsFromEOL(FormattingElements elements);
    private string ProcessDirective(PreprocessorDirective directive, FormattingToken formattingToken, SourceFile sourceFile, bool canHaveComment, FormattingElements& elementsAfter);
    private PreprocessorDirective ProcessSupportElement(FormattingToken token, FormattingElements& elementsAfter);
    protected void PreparePreprocessor();
    private bool IsDirectiveForPreprocessing(Token token);
    private void SetLineProperties(LineDirective line, string text);
    private void GetLineInfo(string lineIndicatorStr, Int32& lineNumber, String& fileName);
    private SourceFile GetSourceFileFromContext();
    protected void AddTextString(Token stringToken);
    private bool TokenIsAspToken(int type);
    private string GetDocumentText(SourceRange range);
    private void CloseNestedMethodContext(Token token);
    private void ProcessAspToken(Token token);
    private Token TokenStep(bool isPeek);
    private Token PreprocessToken(bool isPeek, Token startToken, FormattingParsingElement lastElement);
    protected virtual void Get();
    protected Token Peek();
    private bool IsSingleLineXmlComment(Comment comment);
    internal virtual void AddCommentNode(Token lCommentToken, FormattingParsingElement lastElement);
    private bool ShouldConcatComments(SourceRange previousCommentRange, SourceRange newCommentRange);
    public void Error(string text);
    public void AddConditionalCompilationSymbols(String[] symbols);
    protected void SetAttributes(CodeElement target, LanguageElementCollection attributes);
    protected void SetAccessSpecifiers(AccessSpecifiedElement element, AccessSpecifiers accessSpecifiers, MemberVisibility visibility);
    protected void SetAccessSpecifiers(AccessSpecifiedElement element, AccessSpecifiers accessSpecifiers, MemberVisibility visibility, bool setRange);
    protected void AddAccessSpecifiersRange(LanguageElement element, AccessSpecifiers accessSpecifiers);
    protected void SetMethodParensRanges(Method target, SourceRange parenOpenRange, SourceRange parenCloseRange);
    protected void SetParensRanges(MemberWithParameters target, SourceRange parenOpenRange, SourceRange parenCloseRange);
    protected void SetContextEndIfNeeded();
    protected void SetIndexRanges(Property target, SourceRange indexOpenRange, SourceRange indexCloseRange);
    protected void SetParameters(MemberWithParameters target, LanguageElementCollection parameters);
    protected Event CreateEvent(TypeReferenceExpression type, ElementReferenceExpression name);
    protected Event CreateEvent(TypeReferenceExpression type, string name, SourceRange nameRange);
    protected Property CreateIndexer(TypeReferenceExpression type, string name, SourceRange nameRange);
    protected Property CreateProperty(TypeReferenceExpression type, ElementReferenceExpression name);
    protected Method CreateMethod(TypeReferenceExpression type, ElementReferenceExpression name);
    protected Method CreateCastOperator(TypeReferenceExpression type, bool isExplicit);
    protected Method CreateConstructor(string name, SourceRange nameRange);
    protected Method CreateDestructor(string name, SourceRange nameRange);
    protected EnumElement CreateEnumElement(string name, Expression expression, SourceRange nameRange, SourceRange startRange, SourceRange endRange);
    protected Method CreateClassOperator(string name, SourceRange nameRange, TypeReferenceExpression typeRef, OperatorType operatorType);
    protected bool IsConstructor();
    private void SetBinaryOperationFields(BinaryOperatorExpression expression, Token operatorToken, Expression leftPart, Expression rightPart);
    protected TypeCheck GetTypeCheck(Expression leftPart, Expression rightPart, Token operatorToken);
    protected ConditionalTypeCast GetConditionalTypeCast(Expression leftPart, Expression rightPart, Token operatorToken);
    protected BinaryOperatorExpression GetBinaryOperatorExpression(Expression leftPart, Expression rightPart, BinaryOperatorType operatorType, Token operatorToken);
    protected RelationalOperation GetRelationalOperation(Expression leftPart, Expression rightPart, RelationalOperator operatorType, Token operatorToken);
    protected AssignmentExpression GetAssignmentExpression(Expression leftPart, Expression rightPart, AssignmentOperatorType assignmentOperator, Token operatorToken);
    protected LogicalOperation GetLogicalOperation(Expression leftPart, Expression rightPart, LogicalOperator operatorType, Token operatorToken);
    protected NullCoalescingExpression GetNullCoalescingExpression(Expression leftPart, Expression rightPart, Token operatorToken);
    protected MethodReferenceExpression ToMethodReference(ElementReferenceExpression source);
    protected void CopyFieldValuesFromElementReference(ReferenceExpressionBase target, ReferenceExpressionBase source);
    protected void CopyFieldValuesFromExpression(Expression target, Expression source);
    protected Param CreateParameter(Token nameToken, TypeReferenceExpression typeRef, ArgumentDirection direction, SourceRange paramRange);
    protected Param CreateExtensionMethodParameter(Token nameToken, TypeReferenceExpression typeRef, ArgumentDirection direction, SourceRange paramRange);
    protected bool IsMemberInit();
    protected void InitializeTypeDeclaration(TypeDeclaration typeDecl, SourceRange startRange, AccessSpecifiers accessSpecifiers, MemberVisibility visibility);
    protected bool IsSqlExpression();
    private bool SkipLambdaParamList(Token& currentToken);
    private bool IsYieldStatement();
    private bool IsPartialModifier(Token token);
    private bool IsLambda();
    private bool IsAssignOperatorToken(int token);
    private bool IsLambdaWithImplicitParams();
    protected bool IsImplicitLambdaParameter();
    private void SetParameterValues(Param parameter, Token nameToken, TypeReferenceExpression typeRef, ArgumentDirection direction, SourceRange paramRange);
    private string GetFullType(string shortName);
    protected void AttachToQualifiedElementReference(Expression source, QualifiedElementReference elRef);
    protected void AttachToPointerElementReference(Expression source, QualifiedElementReference elRef);
    protected Const CreateConstant(string constName, TypeReferenceExpression typeRef, Expression constValue, SourceRange nameRange, SourceRange startRange, bool shouldAddTypeRef, SourceRange operatorRange);
    private void SetVariableProperties(Variable variable, TypeReferenceExpression typeRef, SourceRange nameRange, bool shouldAddTypeRef, SourceRange operatorRange);
    protected Variable CreateVariable(string name, TypeReferenceExpression typeRef, Expression initializer, SourceRange nameRange, SourceRange startRange, bool shouldAddTypeRef, SourceRange operatorRange);
    protected ImplicitVariable CreateImplicitVariable(string name, Expression initializer, SourceRange nameRange, SourceRange startRange, bool shouldAddTypeRef, SourceRange operatorRange, SourceRange varKeywordRange);
    protected ImplicitVariable CreateImplicitVariable(string name, SourceRange nameRange, SourceRange startRange, bool shouldAddTypeRef);
    protected TypeParameter GetTypeParameter(GenericModifier modifier, string paramName);
    protected void SetTypeArguments(ReferenceExpressionBase expression, TypeReferenceExpressionCollection typeRefColl);
    protected int EndOf(string symbol, int start, bool whitespaces);
    protected string RemPPDirective(string symbol);
    protected void AddCCS(string symbol);
    protected void RemCCS(string symbol);
    protected bool IsCCS(string symbol);
    private void ParseTypeEnd();
    private void SetUnclosedMemberContext();
    private void CloseMemberContextIfNeeded(LanguageElement newContext);
    protected virtual void OpenContext(LanguageElement newContext);
    private void CloseMemberContext(Token token);
    private string GetAccessorName(string prefix);
    private static BitArray NewSet(Int32[] values);
    protected bool IsAssignment();
    protected bool NotFinalComma();
    protected bool IsQualident(Token& pt, String& qualident);
    protected bool IsGeneric();
    protected bool IsTypeArgumentList(Token& pt);
    private Token MoveToQuestionToken(Token questionToken);
    protected void CloseContextAndSetRange(LanguageElement element);
    private bool SkipQualifier(Token& pt);
    protected bool IsType(Token& pt);
    protected bool IsLocalVarDecl();
    protected bool IsDims();
    protected bool IsLBRACK();
    protected bool IsPointerOrDims();
    protected bool SkipPointerOrDims(Token& pt);
    protected bool IsAttrTargSpec();
    protected bool IsFieldDecl();
    protected bool IsTypeCast();
    protected bool IsSimpleTypeCast();
    protected bool GuessTypeCast();
    private bool IsAdressOfOperation(int tokenType);
    private bool IsImplicitVariable();
    private bool IsUnsafeContext();
    private bool IsUnsafeMethod();
    private bool IsUnsafeStatement();
    protected bool IsGlobalAttrTarget();
    protected bool IsExternAliasDirective();
    protected bool IsLtNoWs();
    protected bool IsNoSwitchLabelOrRBrace();
    private bool IsSqlKeyword(string name);
    protected bool QueryIdentHasType();
    protected bool IsPartOfMemberName();
    public virtual ExpressionParserBase CreateExpressionParser();
    public virtual bool SupportsFileExtension(string ext);
    public virtual IExpressionInverter CreateExpressionInverter();
    public static SourceRange GetRange(LanguageElement a, LanguageElement b);
    public static SourceRange GetRange(LanguageElement a, SourceRange b);
    public static SourceRange GetRange(LanguageElement a, Token b);
    public static SourceRange GetRange(Token a, Token b);
    public static SourceRange GetRange(Token a, SourceRange b);
    public static SourceRange GetRange(Token a, LanguageElement b);
    public static SourceRange GetRange(SourceRange a, SourceRange b);
    public static SourceRange GetRange(SourceRange a, Token b);
    public static SourceRange GetRange(SourceRange a, LanguageElement b);
    protected bool get_ShouldSkipMethodBody();
    protected Stack get_Regions();
    public virtual string get_Language();
    public virtual CommentCollection get_Comments();
    public bool get_ShouldWorkAsExpressionParser();
    public void set_ShouldWorkAsExpressionParser(bool value);
    public bool get_WorkAsCSharp30Parser();
    public void set_WorkAsCSharp30Parser(bool value);
    public virtual bool IsQueryExpressionStart(string lineText);
    protected virtual bool IsIdent(Token token);
    private void FirstGet();
    protected ISourceReader get_Reader();
    protected void set_Reader(ISourceReader value);
    protected bool get_ParsingPostponedTokens();
    protected void set_ParsingPostponedTokens(bool value);
    protected Hashtable get_PrimitiveToFullTypes();
    protected void set_PrimitiveToFullTypes(Hashtable value);
    protected QueryExpression get_ActiveSqlExpression();
    protected void set_ActiveSqlExpression(QueryExpression value);
    protected CSharpPreprocessor get_Preprocessor();
    protected void set_Preprocessor(CSharpPreprocessor value);
}
public class DevExpress.CodeParser.CSharp.CSharpCodeGen : CodeGen {
    private LanguageElement _FirstElement;
    internal FormattingTable FormattingTable { get; }
    public bool ContextIsFirstElement { get; }
    public CSharpCodeGen(CodeGenOptions options);
    private void AddCharOperatorsToFormattingElements(FormattingTokenType tokenType, FormattingElements result);
    private void CSharpContextPoped(LanguageElement oldContext);
    protected virtual HtmlXmlCodeGenBase CreateHtmlXmlGen();
    protected virtual TemplateParameterCodeGenBase CreateTemplateParameterGen();
    protected virtual TemplateCodeGenBase CreateTemplateGen();
    protected virtual DirectiveCodeGenBase CreateDirectiveGen();
    protected virtual ExpressionCodeGenBase CreateExpressionGen();
    protected virtual MemberCodeGenBase CreateMemberGen();
    protected virtual StatementCodeGenBase CreateStatementGen();
    protected virtual SupportElementCodeGenBase CreateSupportElementGen();
    protected virtual TypeDeclarationCodeGenBase CreateTypeDeclarationGen();
    protected virtual XmlCodeGenBase CreateXmlGen();
    protected virtual NamespaceReferenceGenBase CreateNamespaceReferenceGen();
    protected virtual NamespaceGenBase CreateNamespaceGen();
    protected virtual SnippetCodeGenBase CreateSnippetGen();
    protected virtual SourceFileCodeGenBase CreateSourceFileGen();
    protected virtual void ContextPushed();
    protected virtual bool NeedGenerateSideComment(LanguageElement element);
    protected virtual void ContextPoped(LanguageElement oldContext);
    private bool DecreaseIndentInElseStatement(Else elseSt);
    protected internal virtual void CalculateIndent(LanguageElement element);
    protected internal virtual void ResetIndent();
    internal virtual FormattingTable get_FormattingTable();
    public virtual void GenerateMemberVisibilitySpecifier(MemberVisibilitySpecifier specifier);
    public virtual void GenerateElement(LanguageElement element);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public bool get_ContextIsFirstElement();
}
public class DevExpress.CodeParser.CSharp.CSharpDirectiveCodeGen : DirectiveCodeGenBase {
    public CSharpDirectiveCodeGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    public virtual bool GenerateElementTail(LanguageElement element);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    protected virtual void GenerateDefineDirective(DefineDirective directive);
    protected virtual void GenerateIfDirective(IfDirective directive);
    protected virtual void GenerateElifDirective(ElifDirective directive);
    protected virtual void GenerateElseDirective(ElseDirective directive);
    protected virtual void GenerateEndIfDirective(EndIfDirective directive);
    protected virtual void GenerateUndefDirective(UndefDirective directive);
    protected virtual void GenerateErrorDirective(ErrorDirective directive);
    protected virtual void GenerateWarningDirective(WarningDirective directive);
    protected virtual void GeneratePragmaDirective(PragmaDirective directive);
    protected virtual void GenerateLineDirective(LineDirective directive);
    protected virtual void GenerateRegion(RegionDirective directive);
    protected virtual void GenerateEndRegion(EndRegionDirective directive);
    protected virtual void GenerateIfDefDirective(IfDefDirective directive);
    protected virtual void GenerateIfnDefDirective(IfnDefDirective directive);
    protected virtual void GenerateIncludeDirective(IncludeDirective directive);
    protected virtual void GenerateImportDirective(ImportDirective directive);
}
public class DevExpress.CodeParser.CSharp.CSharpErrors : ParserErrorsBase {
    protected virtual string GetSyntaxErrorText(int n);
}
public class DevExpress.CodeParser.CSharp.CSharpExpressionCodeGen : TokenCExpressionCodeGenBase {
    public CSharpExpressionCodeGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    protected virtual void GenerateAddressOfExpression(AddressOfExpression expression);
    protected virtual void GenerateManagedArrayCreateExpression(ManagedArrayCreateExpression expression);
    protected virtual void GenerateDeleteArrayExpression(DeleteArrayExpression expression);
    protected virtual void GenerateComplexExpression(ComplexExpression expression);
    protected virtual void GenerateDeleteExpression(DeleteExpression expression);
    protected virtual void GenerateElaboratedTypeReference(ElaboratedTypeReference expression);
    protected virtual void GenerateManagedObjectCreationExpression(ManagedObjectCreationExpression expression);
    protected virtual void GenerateParametizedArrayCreateExpression(ParametrizedArrayCreateExpression expression);
    protected virtual void GenerateParametizedObjectCreationExpression(ParametrizedObjectCreationExpression expression);
    protected virtual void GenerateQualifiedNestedReference(QualifiedNestedReference expression);
    protected virtual void GenerateQualifiedNestedTypeReference(QualifiedNestedTypeReference expression);
    protected virtual void GenerateQualifiedTypeReferenceExpression(QualifiedTypeReferenceExpression expression);
    protected virtual void GenerateQualifiedMethodReference(QualifiedMethodReference expression);
    protected virtual void GeneratePointerMethodReference(PointerMethodReference expression);
    protected virtual void GenerateCppQualifiedElementReference(CppQualifiedElementReference expression);
    protected virtual void GenerateAttributeVariableInitializer(AttributeVariableInitializer expression);
    protected virtual void GenerateMarkupExtensionExpression(MarkupExtensionExpression expression);
    protected virtual void GenerateGenericTypeArguments(TypeReferenceExpressionCollection arguments);
    private void GenerateJoinExpressionBase(JoinExpressionBase expression);
    protected virtual void GenerateArrayCreateExpression(ArrayCreateExpression expression);
    private void GenerateArrayCreateWithDimensionsAndBaseArrayType(ArrayCreateExpression expression, TypeReferenceExpression baseType);
    protected virtual void GenerateObjectCreationExpression(ObjectCreationExpression expression);
    protected virtual void GenerateMethodCallExpression(MethodCallExpression expression);
    protected virtual void GenerateArgumentDirection(ArgumentDirection direction);
    protected virtual void GenerateArgumentDirectionExpression(ArgumentDirectionExpression expression);
    protected virtual void GenerateBaseReferenceExpression(BaseReferenceExpression expression);
    protected virtual void GenerateCheckedExpression(CheckedExpression expression);
    protected virtual void GenerateBooleanLiteral(bool value);
    protected virtual bool IsEscapedString(string value);
    protected virtual void GenerateStringLiteral(string value);
    protected virtual bool GenerateSpecificExpression(Expression expression);
    private void GenerateAwaitExpression(AwaitExpression awaitExpression);
    private string ReplaceEscapeChars(string value);
    private string ReplaceChar(char c);
    protected virtual void GenerateCharLiteral(char value);
    protected virtual void GenerateNullLiteral();
    protected virtual void GenerateNumberLiteral(string name, object value, PrimitiveType type);
    protected virtual void GenerateTypeOfExpression(TypeOfExpression expression);
    protected virtual void GenerateTypeReferenceExpression(TypeReferenceExpression expression);
    protected virtual void GenerateUncheckedExpression(UncheckedExpression expression);
    protected virtual void GenerateTypeOfIsExpression(TypeOfIsExpression expression);
    protected virtual void GenerateTypeCheck(TypeCheck expression);
    protected virtual void GenerateConditionalTypeCast(ConditionalTypeCast expression);
    protected virtual void GenerateDefaultValueExpression(DefaultValueExpression expression);
    protected virtual void GenerateNullCoalescingExpression(NullCoalescingExpression expression);
    protected virtual void GenerateQualifiedAliasExpression(QualifiedAliasExpression expression);
    protected virtual void GenerateReferenceExpressionBase(ReferenceExpressionBase expression, string delimiter);
    protected virtual void GeneratePointerElementReference(PointerElementReference expression);
    protected virtual void GenerateMemberInitializerExpression(MemberInitializerExpression expression);
    protected virtual void GenerateObjectInitializerExpression(ObjectInitializerExpression expression);
    protected virtual void GenerateLambdaExpression(LambdaExpression expression);
    protected virtual void GenerateFromExpression(FromExpression expression);
    protected virtual void GenerateJoinExpression(JoinExpression expression);
    protected virtual void GenerateJoinIntoExpression(JoinIntoExpression expression);
    protected virtual void GenerateEqualsExpression(EqualsExpression expression);
    protected virtual void GenerateQueryExpression(QueryExpression expression);
    protected virtual void GenerateLetExpression(LetExpression expression);
    protected virtual void GenerateWhereExpression(WhereExpression expression);
    protected virtual void GenerateOrderingExpression(OrderingExpression expression);
    protected virtual void GenerateOrderByExpression(OrderByExpression expression);
    protected virtual void GenerateSelectExpression(SelectExpression expression);
    protected virtual void GenerateGroupByExpression(GroupByExpression expression);
    protected virtual void GenerateIntoExpression(IntoExpression expression);
    protected virtual void GenerateInExpression(InExpression expression);
    protected virtual void GenerateDistinctExpression(DistinctExpression expression);
    protected virtual void GenerateExpressionList(ExpressionCollectionBase expressions);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public class DevExpress.CodeParser.CSharp.CSharpExpressionInverter : ExpressionInverterBase {
    protected virtual Expression InvertIsExpression(Is expression);
    protected virtual Expression InvertIsNotExpression(IsNot expression);
}
internal class DevExpress.CodeParser.CSharp.CSharpLanguageUtils : LanguageUtils {
    public virtual Tokenizer CreateTokenizer();
    public virtual ParserBase CreateParser(ParserVersion version, EmbededLanguageKind languageKind, DotNetLanguageType embededLanguage);
    public virtual CodeGen CreateCodeGen();
    public virtual ElementBuilder CreateElementBuilder();
}
public class DevExpress.CodeParser.CSharp.CSharpMemberCodeGen : MemberCodeGenBase {
    public CSharpMemberCodeGen(CodeGen codeGen);
    private bool CanGenerateMethodVisibility(Method method);
    private bool CanGenerateVarType(Variable var);
    private string RemoveTags(string str);
    private void GenerateArgumentDirection(ArgumentDirection ad);
    private void GenerateBaseVariable(Variable var);
    private void GenerateMemberType(Member member);
    private void GenerateMethodName();
    private void GenerateOverloadOperatorSignature(Method method);
    private void GenerateMethodParameters(Method method);
    private void GenetateVarTail(Variable var);
    protected virtual void GenerateInitializedVolatile(InitializedVolatile var);
    protected virtual void GenerateConstVolatile(ConstVolatile member);
    protected virtual void GenerateVolatile(Volatile member);
    protected virtual void GenerateMethodPrototype(MethodPrototype member);
    protected virtual void GenerateMethod(Method method);
    protected virtual void GenerateEvent(Event member);
    protected virtual void GenerateProperty(Property property);
    protected virtual void GenerateDelegate(DelegateDefinition member);
    protected virtual void GenerateConst(Const var);
    protected virtual void GenerateVariable(Variable var);
    protected virtual void GenerateInitializedVariable(InitializedVariable var);
    protected virtual void GenerateParameter(Param param);
    protected virtual void GenerateEnumElement(EnumElement element);
    protected virtual void GenerateImplicitVariable(ImplicitVariable member);
    protected virtual void GenerateExtensionMethodParam(ExtensionMethodParam member);
    protected virtual void GenerateLambdaImplicitlyTypedParam(LambdaImplicitlyTypedParam member);
    protected virtual void GenerateQueryIdent(QueryIdent member);
    protected virtual void GenerateMultiVars(Variable var);
    public virtual void GenerateGenericModifier(GenericModifier generic);
    public virtual void GenerateTypeParameter(TypeParameter parameter);
    public virtual void GenerateTypeParameterConstraint(TypeParameterConstraint constraint);
    public virtual void GenerateTypeParameterCollection(TypeParameterCollection collection);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    public virtual bool IsMemberGenElement(LanguageElement element);
    public virtual bool GenerateElementTail(LanguageElement element);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
}
public class DevExpress.CodeParser.CSharp.CSharpNamespaceGen : NamespaceGenBase {
    public CSharpNamespaceGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    protected virtual void GenerateNamespace(Namespace element);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
}
public class DevExpress.CodeParser.CSharp.CSharpNamespaceReferenceGen : NamespaceReferenceGenBase {
    public CSharpNamespaceReferenceGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    protected virtual void GenerateExternAlias(ExternAlias element);
    protected virtual void GenerateNamespaceReference(NamespaceReference element);
}
public class DevExpress.CodeParser.CSharp.CSharpOperatorHelper : object {
    private static OperatorType GetUnaryOperatorType(string name);
    private static OperatorType GetBinaryOperatorType(string name);
    private static OperatorType GetUnaryOperatorTypeByMethodName(string methodName);
    private static OperatorType GetBinaryOperatorTypeByMethodName(string methodName);
    public static string GetBinaryOperatorText(OperatorType type);
    private static string GetUnaryOperatorName(OperatorType type);
    private static string GetBinaryOperatorName(OperatorType type);
    public static OperatorType GetOperatorType(string value, int parameterCount);
    public static OperatorType GetOperatorTypeByMethodName(string methodName);
    public static OperatorType GetOperatorTypeByMethodName(string methodName, int parameterCount);
    public static string GetOperatorName(OperatorType type, int parameterCount);
    public static FormattingTokenType GetOperatorToken(OperatorType type);
    public static BinaryOperatorExpression GetBinaryOperator(Expression left, OperatorType type, Expression right);
}
public class DevExpress.CodeParser.CSharp.CSharpPrimitiveTypeUtils : object {
    private static string STR_0X;
    private static string STR_0x;
    private static string STR_L;
    private static string STR_U;
    private static string STR_Lu;
    private static string STR_Ul;
    private static string STR_F;
    private static string STR_D;
    private static string STR_M;
    private static bool IsHexLiteral(string value);
    private static bool ConvertToDecimal(string value, Decimal& result);
    private static PrimitiveType GetIntegerTypeFromValue(string value);
    private static string GetIntegerLiteralSuffix(string value);
    private static string GetFloatingPointLiteralSuffix(string value);
    private static bool GetIntegerLiteralValue(string value, Decimal& intValue);
    private static bool GetFloatingPointLiteralValue(string value, Decimal& realValue);
    private static PrimitiveType NarrowIntegerLiteralType(string value);
    private static PrimitiveType NarrowIntegerLiteralType(string suffix, decimal intValue);
    private static bool EndsWith(string str, string strEnd);
    private static PrimitiveType NarrowFloatingPointLiteralType(string value);
    private static string RemoveQuotes(string s);
    private static string RemoveCharQuotes(string s);
    private static int GetEscapeSequenceIndex(string s, int startIndex);
    private static string ReplaceEscapes(string s);
    public static PrimitiveType ToPrimitiveType(Token token);
    public static PrimitiveType ToPrimitiveType(Token token, UnaryOperatorType typeOperator);
    public static PrimitiveType ToPrimitiveType(int tokenType, string value);
    public static PrimitiveType ToPrimitiveType(int tokenType, string value, UnaryOperatorType typeOperator);
    public static object ToPrimitiveValue(Token token);
    public static object ToPrimitiveValue(int tokenType, string value);
    public static string GetTypeSuffix(object value, PrimitiveType type);
    private static string GetTypeSuffix(object value);
}
public class DevExpress.CodeParser.CSharp.CSharpPunctuators : object {
    private static Hashtable _Punctuators;
    public static ICollection TokenTypes { get; }
    private static CSharpPunctuators();
    public static ICollection get_TokenTypes();
    public static string GetPunctuator(int token);
    public static bool IsPunctuator(int token);
}
public class DevExpress.CodeParser.CSharp.CSharpScanner : CSharpScannerBase {
    private static int charSetSize;
    private static int UnicodeLetterIndex;
    private static int noSym;
    private Int16[] start;
    public CSharpScanner(ISourceReader s);
    public CSharpScanner(ISourceReader s, ScannerExtension extension);
    protected virtual int GetUnicodeLetterIndex();
    protected virtual int GetNextState(int input);
    protected virtual void InitializeIgnoreTable();
    protected virtual void NextChCasing();
    protected virtual void AddCh();
    private void CheckLiteral();
    protected virtual void NextTokenComments();
    protected virtual void NextTokenScan(int state);
}
public abstract class DevExpress.CodeParser.CSharp.CSharpScannerBase : GeneratedScannerBase {
    private ScannerExtension _ScannerExtension;
    private bool _InPreprocess;
    protected ScannerExtension ScannerExtension { get; protected set; }
    public bool InPreprocess { get; public set; }
    protected ScannerExtension get_ScannerExtension();
    protected void set_ScannerExtension(ScannerExtension value);
    protected virtual Token CreateToken();
    protected virtual bool NextTokenStart();
    private void ChangeTokenType(Token token);
    private void CheckForInvalidComments(Token& token);
    private TokenCollection GetExtensionTokens(Token scannerToken);
    private void InsertExtensionTokens(Token& start, TokenCollection extensionTokens);
    public virtual Token Scan();
    public virtual Token Peek();
    protected virtual void NextTokenEnd();
    protected virtual void SkipIgnoredChars();
    protected virtual void SetInPreprocess();
    protected virtual void ResetInPreprocess();
    public bool IsNextChar(char c);
    public bool IsEof();
    public string SkipToEOL();
    private void SkipWs();
    private bool IsLineTerminator(StringBuilder sb);
    public void set_InPreprocess(bool value);
    public bool get_InPreprocess();
    protected virtual bool IsEOLChar(char ch);
    protected virtual bool IsCRChar(char ch);
    protected virtual FormattingElements GetNextFormattingTokenElements();
}
public class DevExpress.CodeParser.CSharp.CSharpSnippetCodeGen : TokenCSnippetCodeGen {
    public CSharpSnippetCodeGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
}
public class DevExpress.CodeParser.CSharp.CSharpSourceFile : SourceFile {
    public CSharpSourceFile(string fileName);
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual int GetImageIndex();
}
public class DevExpress.CodeParser.CSharp.CSharpStatementCodeGen : TokenCStatementCodeGenBase {
    public CSharpStatementCodeGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    public virtual bool GenerateElementTail(LanguageElement statement);
    private void GenerateEventAccessorStatement(EventAccessor statement, FormattingTokenType keyword);
    private void GeneratePropertyAccessorStatement(PropertyAccessor statement, FormattingTokenType keyword);
    protected virtual void GenerateThrowStatement(Throw statement);
    protected virtual void GenerateCheckedStatement(Checked statement);
    protected virtual void GenerateUncheckedStatement(Unchecked statement);
    protected virtual void GenerateFixedStatement(Fixed statement);
    protected virtual void GenerateLockStatement(Lock statement);
    protected virtual void GenerateEventAddStatement(EventAdd statement);
    protected virtual void GenerateEventRemoveStatement(EventRemove statement);
    protected virtual void GeneratePropertyAccessorGetStatement(Get statement);
    protected virtual void GeneratePropertyAccessorSetStatement(Set statement);
    protected virtual void GenerateStatementStatement(Statement statement);
    protected virtual void GenerateWithStatement(With statement);
    protected virtual void GenerateEventRaiseStatement(EventRaise statement);
    protected virtual void GenerateRaiseEventStatement(RaiseEvent statement);
    protected virtual void GenerateYieldBreakStatement(YieldBreak statement);
    protected virtual void GenerateYieldReturnStatement(YieldReturn statement);
    protected virtual void GenerateConstructorInitializer(ConstructorInitializer initializer);
    protected virtual void GenerateMethodCallStatement(MethodCall statement);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
}
public class DevExpress.CodeParser.CSharp.CSharpSupportElementCodeGen : TokenSupportElementCodeGenBase {
    public CSharpSupportElementCodeGen(CodeGen codeGen);
    protected virtual void GenerateCppAttribute(CppAttributeSection element);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    protected virtual bool HasSameLineRange(Comment com, SupportElementPosition possiblePosition);
    protected virtual void GenerateElementComment(CodeElement codeElement, SupportElementPosition position);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public abstract class DevExpress.CodeParser.CSharp.CSharpTokensBase : LanguageTokensBase {
    private Hashtable _Keywords;
    private Hashtable _Punctuators;
    private Hashtable _Directives;
    private String[] tokens;
    private Hashtable _PrimitiveToFullTypes;
    private Hashtable _FullToPrimitiveTypes;
    private void AddToken(int token, string name);
    private void PopulateTokenTable();
    private void LoadKeyWords();
    private int GetTokenType(string code);
    private void LoadPunctuator(int type);
    private void LoadPunctuators();
    private void AddDirective(string name, int token);
    private void LoadDirectives();
    private void LoadTypeConversionTables();
    public bool IsUnaryOperator(Token token);
    public bool IsHexDigit(char ch);
    public bool IsRealTypeSuffix(char ch);
    public bool IsIdentifier(int tokenType);
    public virtual bool IsIdentifier(string word);
    public bool IsIdentifier(Token token);
    public virtual bool IsKeyword(string word);
    public bool IsPunctuator(string s);
    public bool IsPunctuator(char ch);
    public bool IsPunctuator(Token token);
    public virtual bool IsDirective(int type);
    public virtual bool IsComment(int type);
    public virtual bool IsXmlDocComment(int type);
    public virtual bool IsNumber(int type);
    public virtual bool IsStringLiteral(int type);
    private int shortToToken(string word);
    public virtual int ToTokenType(string token);
    public int GetKeywordToken(string word);
    public int GetDirectiveToken(string word);
    public int ToTokenType(Token token);
    public virtual bool IsStandardType(string word);
    public bool IsStandardType(int word);
    public bool IsBooleanLiteral(int tokenType);
    public bool IsBooleanLiteral(string word);
    public bool IsNullLiteral(int tokenType);
    public bool IsNullLiteral(string word);
    public string GetFullTypeName(string simpleName);
    public string GetSimpleTypeName(string fullName);
    public string GetTokenString(int tokenType);
}
public class DevExpress.CodeParser.CSharp.CSharpTokensCategoryHelper : object {
    public sealed virtual TokenCategory GetUncategorizedTokenCategory(Token token);
    public sealed virtual TokenCollection GetTokens(string code);
    public sealed virtual string GetTokenCategory(Token token);
    public sealed virtual string GetTokenCategory(Token token, ParserVersion version);
}
public class DevExpress.CodeParser.CSharp.CSharpTokensHelper : object {
    public static TokenCategory GetUncategorizedTokenCategory(Token token);
    public static TokenCollection GetTokens(string code);
    public static string GetTokenCategory(Token token, ParserVersion version);
    public static string GetTokenCategory(Token token);
}
public class DevExpress.CodeParser.CSharp.CSharpTypeDeclarationCodeGen : TypeDeclarationCodeGenBase {
    public CSharpTypeDeclarationCodeGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    private FormattingTokenType GetDeclarationType(TypeDeclaration type);
    private void GenerateUnderlyingType(Enumeration enumeration);
    private void GenerateAncestorTypes(TypeDeclaration type);
    private void GenerateType(TypeDeclaration type);
    private void GenerateType(TypeDeclaration type, FormattingTokenType delimiter);
    protected virtual void GenerateModuleDeclaration(Module type);
    protected virtual void GenerateClassDeclaration(Class type);
    protected virtual void GenerateStructDeclaration(Struct type);
    protected virtual void GenerateInterfaceDeclaration(Interface type);
    protected virtual void GenerateEnumDeclaration(Enumeration type);
    protected virtual void GenerateUnionDeclaration(Union type);
    protected virtual void GenerateManagedClassDeclaration(ManagedClass type);
    protected virtual void GenerateManagedStructDeclaration(ManagedStruct type);
    protected virtual void GenerateInterfaceClassDeclaration(InterfaceClass type);
    protected virtual void GenerateInterfaceStructDeclaration(InterfaceStruct type);
    protected virtual void GenerateValueClassDeclaration(ValueClass type);
    protected virtual void GenerateValueStructDeclaration(ValueStruct type);
    protected virtual void GenerateMembers(NodeList nodeList);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
}
public class DevExpress.CodeParser.CSharp.CSharpXmlCodeGen : XmlCodeGenBase {
    private static string STR_Prefix;
    private bool _LastXMLTextIsEmpty;
    public CSharpXmlCodeGen(CodeGen codeGen);
    protected virtual void GenerateXmlPrefix();
    public virtual void GenerateElement(LanguageElement element);
    private void GenerateXmlReference(XmlReference xmlReference);
    protected virtual void GenerateXmlDocComment(XmlDocComment xmlComment);
    protected virtual void GenerateXmlDocElement(XmlElement xmlDocElement);
    private bool NeedGenerateStartPrefixForOpenTag(XmlElement xmlDocElement);
    protected virtual void GenerateXmlElementOpenTag(XmlElement xmlDocElement);
    private bool NeedGenerateStartPrefixForCloseTag(XmlElement element);
    protected virtual void GenerateXmlElementCloseTag(XmlElement xmlDocElement);
    private void GenerateXmlDocAttribute(XmlAttribute element);
    private bool ContainsValuableText(XmlText xmlDocText);
    private void GenerateXmlCharacterData(XmlCharacterData xmlCharacterData);
    private void WriteXmlString(string str, LanguageElement element);
    protected virtual void GenerateXmlDocText(XmlText xmlDocText);
    internal virtual bool IsXmlGenElement(LanguageElement element);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public class DevExpress.CodeParser.CSharp.Preprocessor.CSharpPreprocessor : PreprocessorBase {
    public CSharpPreprocessor(CSharpScanner scanner, SourceFile rootNode);
    public CSharpPreprocessor(CSharpScanner scanner, FormattingParserBase parser, SourceFile rootNode);
    protected virtual void Get();
    private void PreprocessorRoot();
    private void PpDeclaration();
    private void PpConditional();
    private void IdnetifierOrKeyword();
    private void PpIfSection();
    private void PpElIfSection();
    private void PpElseSection();
    private void PpEndIf();
    private void PpExpression(Boolean& result);
    private void CoditionDirectiveTail(bool willSkip);
    private void PpOrExpression(Boolean& result);
    private void PpAndExpression(Boolean& result);
    private void PpEqualityExpression(Boolean& result);
    private void PpUnaryExpression(Boolean& result);
    private void PpPrimaryExpression(Boolean& result);
    private void Keyword();
    private void ExprInParens(Boolean& result);
    protected virtual void StartRule();
    protected virtual Boolean[0...,0...] CreateSetArray();
}
public enum DevExpress.CodeParser.CSharp.Preprocessor.PreprocessMode : Enum {
    public int value__;
    public static PreprocessMode None;
    public static PreprocessMode SimplePreprocessing;
    public static PreprocessMode SmartPreprocessing;
}
public abstract class DevExpress.CodeParser.CSharp.Preprocessor.PreprocessorBase : object {
    private Stack _IfConditions;
    private FormattingParserBase _Parser;
    private static int minErrDist;
    protected static bool T;
    protected static bool x;
    protected int errDist;
    protected Token tToken;
    protected Token la;
    protected ParserErrorsBase errors;
    protected Boolean[0...,0...] set;
    protected int maxTokens;
    private SourceFile _SourceFile;
    private bool _AddFormattingTokens;
    private CSharpScanner _Scanner;
    private Dictionary`2<string, string> _Defines;
    private Dictionary`2<string, object> _OnlyThisFileDefines;
    private PreprocessMode _PreprocessMode;
    public FormattingParsingElement ActiveParsingElement;
    private List`1<object> _PreprocessorTokens;
    public bool AddFormattingTokens { get; public set; }
    protected FormattingParserBase Parser { get; protected set; }
    protected CSharpScanner Scanner { get; protected set; }
    protected PreprocessMode PreprocessMode { get; protected set; }
    protected List`1<object> PreprocessorTokens { get; }
    protected SourceFile SourceFile { get; protected set; }
    protected Stack IfConditions { get; }
    public bool ConditionWasTrue { get; }
    public PreprocessorBase(CSharpScanner scanner, SourceFile rootNode);
    protected abstract virtual void StartRule();
    protected abstract virtual Boolean[0...,0...] CreateSetArray();
    protected abstract virtual void Get();
    public bool get_AddFormattingTokens();
    public void set_AddFormattingTokens(bool value);
    protected FormattingParserBase get_Parser();
    protected void set_Parser(FormattingParserBase value);
    protected CSharpScanner get_Scanner();
    protected void set_Scanner(CSharpScanner value);
    protected PreprocessMode get_PreprocessMode();
    protected void set_PreprocessMode(PreprocessMode value);
    private void AddDefineCall(string name);
    private void AddProjectDefines(SourceFile sourceFile);
    protected string GetDirectiveExpression(Token startToken, Token endToken);
    protected List`1<object> get_PreprocessorTokens();
    protected void ProcessFormattingToken();
    protected bool ProcessLineTerminator(FormattingToken token);
    protected void AddLineTerminatorToFormattingTokens();
    protected void ProcessSingleLineComment(FormattingToken token);
    private void AddToActiveParsingElement(IFormattingElement element);
    private void AddToActiveParsingElement(FormattingElements elements);
    private string GetTokenValue(FormattingToken token);
    internal string GetFEText(FormattingElements fes);
    protected void DefineMacro(string name);
    protected void AddTokenToCategoryCollectionIfNeeded();
    protected void UndefMacro(string name);
    protected void Expect(int n);
    protected void SynErr(int n);
    protected bool StartOf(int s);
    public Token Preprocess(Token laToken);
    protected SourceFile get_SourceFile();
    protected void set_SourceFile(SourceFile value);
    private bool IsEOF(StringBuilder bufferString);
    private bool IsNextChar(char ch, StringBuilder bufferString);
    private FormattingElements CutPPFormElements(FormattingToken token);
    protected void ProcessNonNewLineToken(FormattingToken t);
    private void IfWaitEndIf();
    protected void SkipToEolIfNeeded();
    protected void ProcessIFDirectiveCondition(bool condition);
    protected bool WillSkipInIf(bool result);
    protected bool WillSkip(bool result);
    private void ProcessDirectiveConditionCore(bool condition);
    protected void ProcessDirectiveCondition(bool condition);
    protected string GetNextToken();
    protected bool IsDefineMacro(string name);
    protected Stack get_IfConditions();
    public bool get_ConditionWasTrue();
    protected void AddPreprocessorDirective(PreprocessorDirective directive);
    protected void SetDirectiveRange(LanguageElement directive, SourceRange range);
    protected void TurnOnScannerPreprocessMode();
    protected void TurnOffScannerPreprocessMode();
    protected string SkipToEOL();
    public void CleanUp();
    private void ProcessNonEndLineToken(FormattingToken t);
    protected void ProcessEndIf();
}
public class DevExpress.CodeParser.CSharp.Preprocessor.PreprocessorErrors : ParserErrorsBase {
    protected virtual string GetSyntaxErrorText(int n);
}
public class DevExpress.CodeParser.CSharp.Preprocessor.Tokens : object {
    public static int LINE;
    public static int SBYTE;
    public static int LINETERMINATOR;
    public static int EQ;
    public static int SCOLON;
    public static int REGION;
    public static int ENDREG;
    public static int STRUCT;
    public static int BASE;
    public static int CASE;
    public static int RAZORCOMMENT;
    public static int RBRACE;
    public static int FINALLY;
    public static int NEW;
    public static int LBRACE;
    public static int ARGLIST;
    public static int GTEQ;
    public static int ELIF;
    public static int USINGKW;
    public static int MINUSASSGN;
    public static int LOCK;
    public static int ENDIF;
    public static int RBRACK;
    public static int TYPEOF;
    public static int EXPLICIT;
    public static int IN;
    public static int IDENT;
    public static int LONG;
    public static int REF;
    public static int COMMA;
    public static int STRINGCON;
    public static int LBRACK;
    public static int FLOAT;
    public static int UNSAFE;
    public static int REFVALUE;
    public static int PRAGMADIR;
    public static int IFCLAUSE;
    public static int OUT;
    public static int DO;
    public static int ULONG;
    public static int CHARCON;
    public static int WHILE;
    public static int DEC;
    public static int PLUSASSGN;
    public static int MODASSGN;
    public static int TRY;
    public static int ORASSGN;
    public static int DBLQUEST;
    public static int LAMBDA;
    public static int THIS;
    public static int SWITCH;
    public static int EXTERN;
    public static int CONST;
    public static int DELEGATE;
    public static int MINUS;
    public static int WARNING;
    public static int TRUE;
    public static int CHAR;
    public static int TILDE;
    public static int VOID;
    public static int TIMESASSGN;
    public static int EVENT;
    public static int DEFINE;
    public static int BREAK;
    public static int UNDEF;
    public static int DBLAND;
    public static int PRIVATE;
    public static int ATCOLON;
    public static int BYTE;
    public static int READONLY;
    public static int DOUBLE;
    public static int RETURN;
    public static int TIMES;
    public static int SEALED;
    public static int LOWOREQ;
    public static int LTLT;
    public static int UNCHECKED;
    public static int OR;
    public static int MULTILINECOMMENT;
    public static int DEFAULT;
    public static int DBLCOLON;
    public static int SINGLELINECOMMENT;
    public static int XOR;
    public static int NAMESPACE;
    public static int CONTINUE;
    public static int SIZEOF;
    public static int ANDASSGN;
    public static int THROW;
    public static int CATCH;
    public static int LT;
    public static int ENUM;
    public static int FOR;
    public static int AT;
    public static int PROTECTED;
    public static int AND;
    public static int COLON;
    public static int LSHASSGN;
    public static int OPERATOR;
    public static int INTCON;
    public static int GT;
    public static int ERROR;
    public static int SHORT;
    public static int DIV;
    public static int MOD;
    public static int IMPLICIT;
    public static int ABSTRACT;
    public static int CLASS;
    public static int UINT;
    public static int FALSE;
    public static int STACKALLOC;
    public static int INTERFACE;
    public static int ASSGN;
    public static int INT;
    public static int CHECKED;
    public static int ELSE;
    public static int USHORT;
    public static int XORASSGN;
    public static int GOTO;
    public static int POINT;
    public static int REALCON;
    public static int NOT;
    public static int NEQ;
    public static int PLUS;
    public static int DOT;
    public static int FIXED;
    public static int NULL;
    public static int AS;
    public static int VOLATILE;
    public static int DIVASSGN;
    public static int INC;
    public static int ELSEDIR;
    public static int QUESTION;
    public static int BOOL;
    public static int RPAR;
    public static int OVERRIDE;
    public static int EOF;
    public static int STATIC;
    public static int LPAR;
    public static int IFDIR;
    public static int VIRTUAL;
    public static int FOREACH;
    public static int IS;
    public static int DECIMAL;
    public static int PUBLIC;
    public static int DBLOR;
    public static int INTERNAL;
    public static int PARAMS;
    public static int MaxTokens;
    public static Int32[] Keywords;
    private static Tokens();
}
public enum DevExpress.CodeParser.CSharp.RazorParsingMode : Enum {
    public int value__;
    public static RazorParsingMode None;
    public static RazorParsingMode Statement;
    public static RazorParsingMode Expression;
    public static RazorParsingMode Helper;
    public static RazorParsingMode Functions;
}
public class DevExpress.CodeParser.CSharp.Tokens : object {
    public static int LINE;
    public static int SBYTE;
    public static int LINETERMINATOR;
    public static int EQ;
    public static int SCOLON;
    public static int REGION;
    public static int ENDREG;
    public static int STRUCT;
    public static int BASE;
    public static int CASE;
    public static int RAZORCOMMENT;
    public static int RBRACE;
    public static int FINALLY;
    public static int NEW;
    public static int LBRACE;
    public static int SHARPCOCODIRECTIVE;
    public static int ARGLIST;
    public static int GTEQ;
    public static int ELIF;
    public static int USINGKW;
    public static int MINUSASSGN;
    public static int LOCK;
    public static int ENDIF;
    public static int RBRACK;
    public static int TYPEOF;
    public static int EXPLICIT;
    public static int IN;
    public static int IDENT;
    public static int LONG;
    public static int REF;
    public static int COMMA;
    public static int STRINGCON;
    public static int LBRACK;
    public static int FLOAT;
    public static int UNSAFE;
    public static int REFVALUE;
    public static int PRAGMADIR;
    public static int IFCLAUSE;
    public static int OUT;
    public static int DO;
    public static int ULONG;
    public static int CHARCON;
    public static int WHILE;
    public static int DEC;
    public static int PLUSASSGN;
    public static int MODASSGN;
    public static int TRY;
    public static int ORASSGN;
    public static int DBLQUEST;
    public static int LAMBDA;
    public static int THIS;
    public static int SWITCH;
    public static int EXTERN;
    public static int CONST;
    public static int DELEGATE;
    public static int MINUS;
    public static int WARNING;
    public static int TRUE;
    public static int CHAR;
    public static int TILDE;
    public static int VOID;
    public static int TIMESASSGN;
    public static int EVENT;
    public static int DEFINE;
    public static int BREAK;
    public static int MULTILINEXML;
    public static int UNDEF;
    public static int DBLAND;
    public static int PRIVATE;
    public static int ATCOLON;
    public static int BYTE;
    public static int READONLY;
    public static int DOUBLE;
    public static int RETURN;
    public static int TIMES;
    public static int SEALED;
    public static int LOWOREQ;
    public static int LTLT;
    public static int UNCHECKED;
    public static int OR;
    public static int MULTILINECOMMENT;
    public static int DEFAULT;
    public static int DBLCOLON;
    public static int SINGLELINECOMMENT;
    public static int XOR;
    public static int NAMESPACE;
    public static int CONTINUE;
    public static int RSHASSGN;
    public static int SIZEOF;
    public static int ANDASSGN;
    public static int ASPBLOCKEND;
    public static int THROW;
    public static int CATCH;
    public static int LT;
    public static int ENUM;
    public static int FOR;
    public static int AT;
    public static int PROTECTED;
    public static int AND;
    public static int COLON;
    public static int LSHASSGN;
    public static int OPERATOR;
    public static int INTCON;
    public static int GT;
    public static int ERROR;
    public static int SINGLELINEXML;
    public static int SHORT;
    public static int DIV;
    public static int ASPBLOCKSTART;
    public static int MOD;
    public static int IMPLICIT;
    public static int ABSTRACT;
    public static int CLASS;
    public static int UINT;
    public static int FALSE;
    public static int STACKALLOC;
    public static int GTGT;
    public static int INTERFACE;
    public static int POINTERTOMEMBER;
    public static int ASSGN;
    public static int INT;
    public static int CHECKED;
    public static int ELSE;
    public static int USHORT;
    public static int XORASSGN;
    public static int GOTO;
    public static int POINT;
    public static int REALCON;
    public static int NOT;
    public static int NEQ;
    public static int ASPCOMMENT;
    public static int PLUS;
    public static int DOT;
    public static int FIXED;
    public static int NULL;
    public static int AS;
    public static int VOLATILE;
    public static int DIVASSGN;
    public static int INC;
    public static int ELSEDIR;
    public static int QUESTION;
    public static int BOOL;
    public static int RPAR;
    public static int OVERRIDE;
    public static int EOF;
    public static int STATIC;
    public static int LPAR;
    public static int IFDIR;
    public static int VIRTUAL;
    public static int FOREACH;
    public static int IS;
    public static int DECIMAL;
    public static int PUBLIC;
    public static int DBLOR;
    public static int INTERNAL;
    public static int PARAMS;
    public static int MaxTokens;
    public static Int32[] Keywords;
    private static Tokens();
}
public class DevExpress.CodeParser.CSharp.TokenType : TokenType {
    public static int Using;
}
internal class DevExpress.CodeParser.CSharpFormattingTable : FormattingTable {
    private static FormattingTable _Instance;
    public static FormattingTable Instance { get; }
    protected virtual void FillFormattingTokenTypeCorrespondanceTable();
    public static FormattingTable get_Instance();
}
public class DevExpress.CodeParser.CSnippetCodeGen : SnippetCodeGenBase {
    public CSnippetCodeGen(CodeGen codeGen);
    protected virtual void GenerateSnippetCodeElement(SnippetCodeElement snippet);
    protected virtual void GenerateSnippetCodeMember(SnippetCodeMember snippet);
    protected virtual void GenerateSnippetCodeStatement(SnippetCodeStatement snippet);
    protected virtual void GenerateSnippetCodeStatementBlock(SnippetCodeStatementBlock snippet);
    protected virtual void GenerateSnippetExpression(SnippetExpression snippet);
}
internal class DevExpress.CodeParser.Css.CssLanguageUtils : LanguageUtils {
    public virtual Tokenizer CreateTokenizer();
    public virtual ParserBase CreateParser(ParserVersion version, EmbededLanguageKind languageKind, DotNetLanguageType embededLanguage);
    public virtual CodeGen CreateCodeGen();
    public virtual ElementBuilder CreateElementBuilder();
}
public class DevExpress.CodeParser.Css.CssParser : XmlLanguageParserBase {
    private CommentCollection _Comments;
    private static Boolean[0...,0...] _CssSet;
    public CommentCollection Comments { get; }
    protected virtual void HandlePragmas();
    private void Parser();
    private void HtmlCommentTags();
    private void Import();
    private void FontFace();
    private void Media();
    private void Page();
    private void RuleSet();
    private void IdentifierList(StringCollection stringCollection);
    private void MediaQueryList(CssMediaQueryCollection& result);
    private void MediaQuery(CssMediaQuery& result);
    private void MediaExpr(CssMediaExpression& result);
    private void Term(CssTerm& result);
    private void Declaration(CssPropertyDeclaration& propertyDecl);
    private void Combinator(CssSelectorType& combinatorType);
    private void Selector(CssSelector& selector);
    private void SimpleSelector(CssSelector& selector);
    private void ElementName();
    private void Class(CssSelector& selector);
    private void Attrib(CssAttributeSelector& attrSelector);
    private void Pseudo(CssPseudoSelector& pseudoSelector);
    private void Expr(CssTermCollection& terms);
    private void Function(CssFunctionReference& functionReference);
    private void Parse();
    protected virtual Boolean[0...,0...] CreateSetArray();
    private CssPseudoClassType GetPseudoClassType(string name);
    private object GetValueFromString(string strValue, int suffixPos);
    private void ConnectSelectors(CssSelector parent, CssSelector child);
    private void GetMeasuredLiteralValue(string strValue, Object& decValue, CssMeasureUnit& unit);
    private bool IsSpecialNameWithoutAt(string name);
    private bool IsSpecialName(string name);
    private void AddCommentNode(Token commentToken);
    private void SetCategoryIfNeeded(TokenCategory category);
    protected virtual void Get();
    protected virtual TokenCategory GetTokenCategory(CategorizedToken token);
    protected virtual LanguageElement DoParse(ParserContext parserContext, ISourceReader reader);
    public LanguageElement Parse(ISourceReader reader);
    public ArrayList ParseAttributeStyleDefinition(ISourceReader reader);
    protected virtual void CleanUpParser();
    public virtual CommentCollection get_Comments();
}
public class DevExpress.CodeParser.Css.CssParserErrors : ParserErrorsBase {
    protected virtual string GetSyntaxErrorText(int n);
}
public class DevExpress.CodeParser.Css.CssScanner : GeneratedScannerBase {
    private static int charSetSize;
    private static int UnicodeLetterIndex;
    private static int noSym;
    private Int16[] start;
    private char valCh;
    public CssScanner(ISourceReader s);
    protected virtual void InitializeIgnoreTable();
    protected virtual void NextChCasing();
    protected virtual void AddCh();
    private void CheckLiteral();
    protected virtual void NextTokenComments();
    protected virtual void NextTokenScan(int state);
    protected virtual int GetUnicodeLetterIndex();
    protected virtual int GetNextState(int input);
    protected virtual Token CreateToken();
    protected virtual void NextTokenAfterScan();
    private void ReadURIText();
}
public class DevExpress.CodeParser.Css.CssTokensCategoryHelper : object {
    public sealed virtual TokenCategory GetUncategorizedTokenCategory(Token token);
    public sealed virtual TokenCollection GetTokens(string code);
    public sealed virtual string GetTokenCategory(Token token);
    public sealed virtual string GetTokenCategory(Token token, ParserVersion version);
}
public class DevExpress.CodeParser.Css.Tokens : object {
    public static int TIME;
    public static int AT;
    public static int EOF;
    public static int BEGINSWITH;
    public static int EMS;
    public static int IDENT;
    public static int CDO;
    public static int LENGTH;
    public static int GREATER;
    public static int PLUS;
    public static int FUNCTION;
    public static int MULTILINECOMMENT;
    public static int ANGLE;
    public static int PERCENTAGE;
    public static int PARENOPEN;
    public static int AND;
    public static int IMPORTANTSYM;
    public static int NUMBER;
    public static int STRING;
    public static int STAR;
    public static int SINGLELINECOMMENT;
    public static int COLON;
    public static int EQUALSIGN;
    public static int SEMICOLON;
    public static int CURLYOPEN;
    public static int PARENCLOSE;
    public static int EXS;
    public static int COMMA;
    public static int SLASH;
    public static int CONTAINS;
    public static int HASH;
    public static int TILDE;
    public static int FREQ;
    public static int CURLYCLOSE;
    public static int INCLUDES;
    public static int ONLY;
    public static int BRACKETCLOSE;
    public static int MINUS;
    public static int DOT;
    public static int BRACKETOPEN;
    public static int URI;
    public static int DASHMATCH;
    public static int NOT;
    public static int ENDSWITH;
    public static int CDC;
    public static int MaxTokens;
    public static Int32[] Keywords;
    private static Tokens();
}
public class DevExpress.CodeParser.CssAngleLiteral : CssMeasuredNumber {
    public LanguageElementType ElementType { get; }
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public class DevExpress.CodeParser.CssAttributeSelector : CssSelector {
    private bool _IsStringValue;
    private string _Value;
    private AttributeSelectorEqualityType _EqualityType;
    public CssSelectorType SelectorType { get; }
    public string Value { get; public set; }
    public AttributeSelectorEqualityType EqualityType { get; public set; }
    public bool IsStringValue { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual CssSelectorType get_SelectorType();
    public sealed virtual string get_Value();
    public void set_Value(string value);
    public sealed virtual AttributeSelectorEqualityType get_EqualityType();
    public void set_EqualityType(AttributeSelectorEqualityType value);
    public sealed virtual bool get_IsStringValue();
    public void set_IsStringValue(bool value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.CssCharsetDeclaration : BaseCssElement {
    private string _Charset;
    public LanguageElementType ElementType { get; }
    public string Charset { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_Charset();
    public void set_Charset(string value);
}
public class DevExpress.CodeParser.CssColorReference : CssTerm {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.CssCommentTag : BaseCssElement {
    private CommentTagKind _Kind;
    public LanguageElementType ElementType { get; }
    public CommentTagKind Kind { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual CommentTagKind get_Kind();
    public void set_Kind(CommentTagKind value);
}
public class DevExpress.CodeParser.CssExpression : BaseCssElement {
    private CssTerm _PrimitiveValue;
    private ExpressionDelimiter _Delimiter;
    public LanguageElementType ElementType { get; }
    public CssTerm PrimitiveValue { get; public set; }
    public ExpressionDelimiter Delimiter { get; public set; }
    private ICssTerm DevExpress.CodeParser.ICssExpression.PrimitiveValue { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void SetPrimitiveValue(CssTerm value);
    public virtual LanguageElementType get_ElementType();
    public CssTerm get_PrimitiveValue();
    public void set_PrimitiveValue(CssTerm value);
    public sealed virtual ExpressionDelimiter get_Delimiter();
    public void set_Delimiter(ExpressionDelimiter value);
    private sealed virtual override ICssTerm DevExpress.CodeParser.ICssExpression.get_PrimitiveValue();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.CssExpressionCollection : NodeList {
    public CssExpression Item { get; public set; }
    private ICssExpression DevExpress.CodeParser.ICssExpressionCollection.Item { get; }
    protected virtual NodeList CreateInstance();
    public CssExpression get_Item(int index);
    public void set_Item(int index, CssExpression value);
    private sealed virtual override int DevExpress.CodeParser.ICssExpressionCollection.IndexOf(ICssExpression e);
    private sealed virtual override ICssExpression DevExpress.CodeParser.ICssExpressionCollection.get_Item(int index);
}
public class DevExpress.CodeParser.CssFrequencyLiteral : CssMeasuredNumber {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.CssFunctionReference : CssTerm {
    private CssTermCollection _Parameters;
    public LanguageElementType ElementType { get; }
    public CssTermCollection Parameters { get; }
    public int ParametersCount { get; }
    private ICssTermCollection DevExpress.CodeParser.ICssFunctionReference.Parameters { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public CssTermCollection get_Parameters();
    public int get_ParametersCount();
    private sealed virtual override ICssTermCollection DevExpress.CodeParser.ICssFunctionReference.get_Parameters();
}
public class DevExpress.CodeParser.CssIdentifierReference : CssTerm {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.CssImportDirective : BaseCssElement {
    private string _Source;
    private StringCollection _SupportedMediaTypes;
    private CssMediaQueryCollection _Queries;
    public LanguageElementType ElementType { get; }
    public string Source { get; public set; }
    public StringCollection SupportedMediaTypes { get; }
    public int SupportedMediaTypesCount { get; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddQuery(CssMediaQuery query);
    internal void SetQueries(CssMediaQueryCollection queries);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_Source();
    public void set_Source(string value);
    public sealed virtual StringCollection get_SupportedMediaTypes();
    public int get_SupportedMediaTypesCount();
}
public class DevExpress.CodeParser.CssLengthLiteral : CssMeasuredNumber {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.CssMeasuredNumber : CssNumberLiteral {
    private CssMeasureUnit _Unit;
    public CssMeasureUnit Unit { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual CssMeasureUnit get_Unit();
    public virtual void set_Unit(CssMeasureUnit value);
}
public enum DevExpress.CodeParser.CssMeasureUnit : Enum {
    public byte value__;
    public static CssMeasureUnit None;
    public static CssMeasureUnit Em;
    public static CssMeasureUnit Ex;
    public static CssMeasureUnit Px;
    public static CssMeasureUnit In;
    public static CssMeasureUnit Xm;
    public static CssMeasureUnit Mm;
    public static CssMeasureUnit Pt;
    public static CssMeasureUnit Pc;
    public static CssMeasureUnit Cm;
    public static CssMeasureUnit Percent;
    public static CssMeasureUnit Hz;
    public static CssMeasureUnit kHz;
    public static CssMeasureUnit Deg;
    public static CssMeasureUnit Rad;
    public static CssMeasureUnit Grad;
    public static CssMeasureUnit Ms;
    public static CssMeasureUnit S;
}
public class DevExpress.CodeParser.CssMediaDirective : BaseCssElement {
    private StringCollection _MediaTypes;
    private CssMediaQueryCollection _Queries;
    public LanguageElementType ElementType { get; }
    public StringCollection MediaTypes { get; }
    public int MediaTypesCount { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddQuery(CssMediaQuery query);
    internal void SetQueries(CssMediaQueryCollection queries);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual StringCollection get_MediaTypes();
    public int get_MediaTypesCount();
}
public class DevExpress.CodeParser.CssMediaExpression : BaseCssElement {
    private CssTerm _Expression;
    [CompilerGeneratedAttribute]
private string <MediaFeature>k__BackingField;
    public string MediaFeature { get; public set; }
    public CssTerm Expression { get; public set; }
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MediaFeature();
    [CompilerGeneratedAttribute]
public void set_MediaFeature(string value);
    public sealed virtual CssTerm get_Expression();
    public void set_Expression(CssTerm value);
    public virtual LanguageElementType get_ElementType();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.CssMediaExpressionCollection : NodeList {
    public CssMediaExpression Item { get; public set; }
    private ICssMediaExpression DevExpress.CodeParser.ICssMediaExpressionCollection.Item { get; }
    protected virtual NodeList CreateInstance();
    public CssMediaExpression get_Item(int index);
    public void set_Item(int index, CssMediaExpression value);
    private sealed virtual override int DevExpress.CodeParser.ICssMediaExpressionCollection.IndexOf(ICssMediaExpression e);
    private sealed virtual override ICssMediaExpression DevExpress.CodeParser.ICssMediaExpressionCollection.get_Item(int index);
}
public class DevExpress.CodeParser.CssMediaQuery : BaseCssElement {
    private CssMediaExpressionCollection _Expressions;
    [CompilerGeneratedAttribute]
private string <MediaType>k__BackingField;
    [CompilerGeneratedAttribute]
private CssMediaQueryPrefix <Prefix>k__BackingField;
    public string MediaType { get; public set; }
    public CssMediaQueryPrefix Prefix { get; public set; }
    public CssMediaExpressionCollection Expressions { get; }
    public LanguageElementType ElementType { get; }
    public void AddExpression(CssMediaExpression expression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [CompilerGeneratedAttribute]
public string get_MediaType();
    [CompilerGeneratedAttribute]
public void set_MediaType(string value);
    [CompilerGeneratedAttribute]
public CssMediaQueryPrefix get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(CssMediaQueryPrefix value);
    public CssMediaExpressionCollection get_Expressions();
    public virtual LanguageElementType get_ElementType();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.CssMediaQueryCollection : NodeList {
    public CssMediaQuery Item { get; public set; }
    private ICssMediaQuery DevExpress.CodeParser.ICssMediaQueryCollection.Item { get; }
    protected virtual NodeList CreateInstance();
    public CssMediaQuery get_Item(int index);
    public void set_Item(int index, CssMediaQuery value);
    private sealed virtual override int DevExpress.CodeParser.ICssMediaQueryCollection.IndexOf(ICssMediaQuery e);
    private sealed virtual override ICssMediaQuery DevExpress.CodeParser.ICssMediaQueryCollection.get_Item(int index);
}
public enum DevExpress.CodeParser.CssMediaQueryPrefix : Enum {
    public byte value__;
    public static CssMediaQueryPrefix None;
    public static CssMediaQueryPrefix Not;
    public static CssMediaQueryPrefix Only;
}
public class DevExpress.CodeParser.CssNumberLiteral : CssTerm {
    private object _Value;
    public LanguageElementType ElementType { get; }
    public object Value { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    public virtual object get_Value();
    public virtual void set_Value(object value);
}
public class DevExpress.CodeParser.CssPageStyle : BaseCssElement {
    private CssPropertyDeclarationCollection _Properties;
    public LanguageElementType ElementType { get; }
    public CssPropertyDeclarationCollection Properties { get; }
    public int PropertiesCount { get; }
    private ICssPropertyDeclarationCollection DevExpress.CodeParser.ICssPageStyle.Properties { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public CssPropertyDeclarationCollection get_Properties();
    public int get_PropertiesCount();
    private sealed virtual override ICssPropertyDeclarationCollection DevExpress.CodeParser.ICssPageStyle.get_Properties();
}
public class DevExpress.CodeParser.CssPercentLiteral : CssMeasuredNumber {
    public LanguageElementType ElementType { get; }
    public CssMeasureUnit Unit { get; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual CssMeasureUnit get_Unit();
}
public class DevExpress.CodeParser.CssPropertyDeclaration : BaseCssElement {
    private bool _IsEqual;
    private bool _IsImportant;
    private CssTermCollection _Values;
    public bool IsEqual { get; public set; }
    public LanguageElementType ElementType { get; }
    public CssTermCollection Values { get; }
    public int ValuesCount { get; }
    public bool IsImportant { get; public set; }
    private ICssTermCollection DevExpress.CodeParser.ICssPropertyDeclaration.Values { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public void AddValue(CssTerm cssTerm);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public sealed virtual bool get_IsEqual();
    public void set_IsEqual(bool value);
    public virtual LanguageElementType get_ElementType();
    public CssTermCollection get_Values();
    public int get_ValuesCount();
    public sealed virtual bool get_IsImportant();
    public void set_IsImportant(bool value);
    private sealed virtual override ICssTermCollection DevExpress.CodeParser.ICssPropertyDeclaration.get_Values();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.CssPropertyDeclarationCollection : NodeList {
    public CssPropertyDeclaration Item { get; public set; }
    private ICssPropertyDeclaration DevExpress.CodeParser.ICssPropertyDeclarationCollection.Item { get; }
    protected virtual NodeList CreateInstance();
    public CssPropertyDeclaration get_Item(int index);
    public void set_Item(int index, CssPropertyDeclaration value);
    private sealed virtual override int DevExpress.CodeParser.ICssPropertyDeclarationCollection.IndexOf(ICssPropertyDeclaration e);
    private sealed virtual override ICssPropertyDeclaration DevExpress.CodeParser.ICssPropertyDeclarationCollection.get_Item(int index);
}
public enum DevExpress.CodeParser.CssPseudoClassType : Enum {
    public byte value__;
    public static CssPseudoClassType Unknown;
    public static CssPseudoClassType Negation;
    public static CssPseudoClassType MatchesAny;
    public static CssPseudoClassType Dir;
    public static CssPseudoClassType Lang;
    public static CssPseudoClassType Hyperlink;
    public static CssPseudoClassType NotVisitedLink;
    public static CssPseudoClassType VisitedLink;
    public static CssPseudoClassType LocalLink;
    public static CssPseudoClassType Target;
    public static CssPseudoClassType Scope;
    public static CssPseudoClassType Current;
    public static CssPseudoClassType Past;
    public static CssPseudoClassType Future;
    public static CssPseudoClassType Active;
    public static CssPseudoClassType Hover;
    public static CssPseudoClassType Focus;
    public static CssPseudoClassType Enabled;
    public static CssPseudoClassType Disabled;
    public static CssPseudoClassType SelectedOption;
    public static CssPseudoClassType IndeterminateValue;
    public static CssPseudoClassType DefaultOption;
    public static CssPseudoClassType InRange;
    public static CssPseudoClassType OutOfRange;
    public static CssPseudoClassType Required;
    public static CssPseudoClassType Optional;
    public static CssPseudoClassType ReadOnly;
    public static CssPseudoClassType ReadWrite;
    public static CssPseudoClassType Root;
    public static CssPseudoClassType Empty;
    public static CssPseudoClassType FirstChild;
    public static CssPseudoClassType NthChild;
    public static CssPseudoClassType LastChild;
    public static CssPseudoClassType NthLastChild;
    public static CssPseudoClassType OnlyChild;
    public static CssPseudoClassType FirstOfType;
    public static CssPseudoClassType NthOfType;
    public static CssPseudoClassType LastOfType;
    public static CssPseudoClassType NthLastOfType;
    public static CssPseudoClassType OnlyOfType;
    public static CssPseudoClassType NthMatch;
    public static CssPseudoClassType Column;
    public static CssPseudoClassType NthColumn;
    public static CssPseudoClassType NthLastColumn;
}
public class DevExpress.CodeParser.CssPseudoFunctionSelector : CssPseudoSelector {
    private string _Param;
    public CssSelectorType SelectorType { get; }
    public string Param { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual CssSelectorType get_SelectorType();
    public sealed virtual string get_Param();
    public void set_Param(string value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.CssPseudoSelector : CssSelector {
    [CompilerGeneratedAttribute]
private CssPseudoClassType <PseudoClassType>k__BackingField;
    public CssSelectorType SelectorType { get; }
    public LanguageElementType ElementType { get; }
    public CssPseudoClassType PseudoClassType { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual CssSelectorType get_SelectorType();
    public virtual LanguageElementType get_ElementType();
    [CompilerGeneratedAttribute]
public CssPseudoClassType get_PseudoClassType();
    [CompilerGeneratedAttribute]
public void set_PseudoClassType(CssPseudoClassType value);
}
public class DevExpress.CodeParser.CssSelector : BaseCssElement {
    private CssSelector _ChildSelector;
    private CssSelectorType _SelectorType;
    public LanguageElementType ElementType { get; }
    public CssSelectorType SelectorType { get; public set; }
    public CssSelector Ancestor { get; }
    public CssSelector ChildSelector { get; public set; }
    private ICssSelector DevExpress.CodeParser.ICssSelector.Ancestor { get; }
    private ICssSelector DevExpress.CodeParser.ICssSelector.ChildSelector { get; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual CssSelectorType get_SelectorType();
    public virtual void set_SelectorType(CssSelectorType value);
    public CssSelector get_Ancestor();
    public CssSelector get_ChildSelector();
    public void set_ChildSelector(CssSelector value);
    private sealed virtual override ICssSelector DevExpress.CodeParser.ICssSelector.get_Ancestor();
    private sealed virtual override ICssSelector DevExpress.CodeParser.ICssSelector.get_ChildSelector();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.CssSelectorCollection : NodeList {
    public CssSelector Item { get; public set; }
    private ICssSelector DevExpress.CodeParser.ICssSelectorCollection.Item { get; }
    protected virtual NodeList CreateInstance();
    public CssSelector get_Item(int index);
    public void set_Item(int index, CssSelector value);
    private sealed virtual override int DevExpress.CodeParser.ICssSelectorCollection.IndexOf(ICssSelector e);
    private sealed virtual override ICssSelector DevExpress.CodeParser.ICssSelectorCollection.get_Item(int index);
}
public enum DevExpress.CodeParser.CssSelectorType : Enum {
    public byte value__;
    public static CssSelectorType Name;
    public static CssSelectorType Class;
    public static CssSelectorType Hash;
    public static CssSelectorType Attrib;
    public static CssSelectorType PseudoId;
    public static CssSelectorType PseudoFunction;
    public static CssSelectorType CombinedSibling;
    public static CssSelectorType CombinedChild;
    public static CssSelectorType CombinedGeneralSibling;
    public static CssSelectorType Unknown;
}
public class DevExpress.CodeParser.CssStringLiteral : CssTerm {
    private string _Value;
    public LanguageElementType ElementType { get; }
    public string Value { get; public set; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_Value();
    public void set_Value(string value);
}
public class DevExpress.CodeParser.CssStyleRule : CssPageStyle {
    private CssSelectorCollection _Selectors;
    private TextRangeWrapper _BlockStart;
    private TextRangeWrapper _BlockEnd;
    public LanguageElementType ElementType { get; }
    public CssSelectorCollection Selectors { get; }
    public int SelectorCount { get; }
    private ICssSelectorCollection DevExpress.CodeParser.ICssStyleRule.Selectors { get; }
    public DelimiterBlockType BlockType { get; }
    public bool HasDelimitedBlock { get; }
    public SourceRange BlockStart { get; }
    public SourceRange BlockEnd { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddSelector(CssSelector selector);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    public CssSelectorCollection get_Selectors();
    public int get_SelectorCount();
    private sealed virtual override ICssSelectorCollection DevExpress.CodeParser.ICssStyleRule.get_Selectors();
    public sealed virtual DelimiterBlockType get_BlockType();
    public sealed virtual bool get_HasDelimitedBlock();
    public sealed virtual SourceRange get_BlockStart();
    public sealed virtual SourceRange get_BlockEnd();
    public sealed virtual void SetBlockStart(SourceRange blockStart);
    public sealed virtual void SetBlockEnd(SourceRange blockEnd);
}
public class DevExpress.CodeParser.CssStyleSheet : BaseCssElement {
    public LanguageElementType ElementType { get; }
    private ICssElementCollection DevExpress.CodeParser.ICssStyleSheet.CssElements { get; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override ICssElementCollection DevExpress.CodeParser.ICssStyleSheet.get_CssElements();
}
public abstract class DevExpress.CodeParser.CssTerm : BaseCssElement {
    private ExpressionDelimiter _Delimiter;
    private PrecedingSign _Sign;
    public ExpressionDelimiter Delimiter { get; public set; }
    public PrecedingSign Sign { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public sealed virtual ExpressionDelimiter get_Delimiter();
    public void set_Delimiter(ExpressionDelimiter value);
    public sealed virtual PrecedingSign get_Sign();
    public void set_Sign(PrecedingSign value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.CssTermCollection : NodeList {
    public CssTerm Item { get; public set; }
    private ICssTerm DevExpress.CodeParser.ICssTermCollection.Item { get; }
    protected virtual NodeList CreateInstance();
    public CssTerm get_Item(int index);
    public void set_Item(int index, CssTerm value);
    private sealed virtual override int DevExpress.CodeParser.ICssTermCollection.IndexOf(ICssTerm e);
    private sealed virtual override ICssTerm DevExpress.CodeParser.ICssTermCollection.get_Item(int index);
}
public class DevExpress.CodeParser.CssTimeLiteral : CssMeasuredNumber {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.CssURIReference : CssTerm {
    private string _URI;
    public LanguageElementType ElementType { get; }
    public string URI { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_URI();
    public void set_URI(string value);
}
public abstract class DevExpress.CodeParser.CStatementCodeGenBase : StatementCodeGenBase {
    public CStatementCodeGenBase(CodeGen codeGen);
    private bool HasChildVariables(Statement statement);
    private void GenerateInitializers(LanguageElementList initializers);
    protected bool IsIfStatementWithElseAndNestedIf(Statement statement);
    protected bool NeedToAddBraces(Statement statement, CurlyBraceOption option);
    protected void GenerateBlockStatementContents(Statement statement);
    protected void GenerateBlockStatementContents(Statement statement, CurlyBraceOption option);
    protected void GenerateBlockStatementContents(Statement statement, CurlyBraceOption option, bool increaseIndent);
    protected void GenerateBlockStatementContents(Statement statement, CurlyBraceOption option, bool increaseIndent, bool needWriteLine);
    protected void GenerateParentingStatement(ParentingStatement statement, string keyword, string delimiter);
    protected void GenerateParentingStatement(ParentingStatement statement, string keyword, string delimiter, CurlyBraceOption option, bool increaseIndent);
    protected void GenerateParentingStatement(ParentingStatement statement, string keyword, string delimiter, CurlyBraceOption option);
    protected virtual void GenerateLabelStatement(Label statement);
    protected virtual void GenerateOptionStatement(OptionStatement statement);
    protected virtual bool GenerateStatement(Statement statement);
    protected virtual void GenerateAbortStatement(Abort statement);
    protected virtual void GenerateGotoStatement(Goto statement);
    protected virtual void GenerateBreakStatement(Break statement);
    protected virtual void GenerateContinueStatement(Continue statement);
    protected virtual void GenerateStatementStatement(Statement statement);
    protected virtual void GenerateMethodCallStatement(MethodCall statement);
    protected virtual void GenerateAssignmentStatement(Assignment statement);
    protected virtual void GenerateSwitchStatement(Switch statement);
    protected virtual void GenerateCaseStatement(Case statement);
    protected virtual void GenerateTryStatement(Try statement);
    protected virtual void GenerateCatchStatement(Catch statement);
    protected virtual void GenerateFinallyStatement(Finally statement);
    protected virtual void GenerateUsingStatement(UsingStatement statement);
    protected virtual void GenerateDoStatement(Do statement);
    protected virtual void GenerateForStatement(For statement);
    protected virtual void GenerateForEachStatement(ForEach statement);
    protected virtual void GenerateWhileStatement(While statement);
    protected virtual void GenerateIfStatement(If statement);
    protected virtual void GenerateElseIfStatement(ElseIf statement);
    protected virtual void GenerateElseStatement(Else statement);
    protected virtual void GenerateEmptyStatement(EmptyStatement statement);
    protected virtual void GenerateBlockStatement(Block statement);
    protected virtual void GenerateReturnStatement(Return statement);
}
public abstract class DevExpress.CodeParser.CSupportElementCodeGen : SupportElementCodeGenBase {
    public CSupportElementCodeGen(CodeGen codeGen);
    protected virtual void GenerateAttributeTargetType(CodeWriter code, AttributeTargetType target);
    protected virtual void GenerateAttributeQualifier(Attribute attr, string delimiter);
    protected virtual void GenerateAttribute(Attribute attr);
    protected virtual void GenerateAttribute(AttributeSection section);
    protected virtual void GenerateComment(Comment comment);
}
public class DevExpress.CodeParser.CTypeExpression : TypeCastExpression {
    public LanguageElementType ElementType { get; }
    public CTypeExpression(TypeReferenceExpression type, Expression target);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public enum DevExpress.CodeParser.CurlyBraceOption : Enum {
    public byte value__;
    public static CurlyBraceOption None;
    public static CurlyBraceOption Always;
    public static CurlyBraceOption MoreThanOneNode;
}
public class DevExpress.CodeParser.DeadCode : FormattingText {
    public DeadCode(string text);
    public virtual object Clone();
}
public class DevExpress.CodeParser.DeclarationTester : object {
    private static bool IsMethodReference(IElement element);
    private static bool IsElementReference(ILocalDeclaration declaration, IElement element);
    private static bool IsSizeOfExpresion(IElement element);
    private static bool IsHtmlReference(IElement element);
    private static bool IsKeywordReference(IElement declaration, IElement element);
    public static bool IsSuitableForLocalReference(ILocalDeclaration declaration, IElement element);
    private static bool IsArgumentNameSpecifier(IElement element);
    public static bool IsSuitableForFieldReference(IElement element);
    public static bool IsSuitableForTypeDefReference(IElement element);
    public static bool IsElementReference(IElement element);
    public static bool IsTypeReference(IElement element);
    public static bool IsReference(IElement element);
    public static bool IsConstructor(IElement element);
    public static bool IsDestructor(IElement element);
    public static bool DeclarationIsValid(IElement element);
}
public enum DevExpress.CodeParser.DefaultAttributeValueType : Enum {
    public int value__;
    public static DefaultAttributeValueType None;
    public static DefaultAttributeValueType Required;
    public static DefaultAttributeValueType Implied;
    public static DefaultAttributeValueType Fixed;
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.DefaultBraceSettings : object {
    private Hashtable _BraceSettings;
    public BracesOnNewLineOptions Item { get; }
    private void LoadDefaultSettings();
    private void AddBraceSetting(BracesOnNewLineOptions setting, BraceHolder holder);
    private BraceHolder TranslateLanguageElement(LanguageElement element);
    private BracesOnNewLineOptions GetSettingForLanguageElement(LanguageElement element);
    protected void SetBraceOptionForElement(BraceHolder holder, BracesOnNewLineOptions option);
    public sealed virtual BracesOnNewLineOptions get_Item(LanguageElement element);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ElementFilters instead.")]
public class DevExpress.CodeParser.DefaultElementFilters : object {
    public static TypeDeclarationFilter Type { get; }
    public static NamespaceFilter Namespace { get; }
    public static TypeOrNamespaceFilter TypeOrNamespace { get; }
    public static NonPrivateMemberFilter NonPrivateMember { get; }
    public static MemberFilter Member { get; }
    public static MethodFilter Method { get; }
    public static PropertyFilter Property { get; }
    public static EventFilter Event { get; }
    public static ConstructorFilter Constructor { get; }
    public static bool IsType(IElement element);
    public static bool IsNamespace(IElement element);
    public static bool IsTypeOrNamespace(IElement element);
    public static bool IsNonPrivateMember(IElement element);
    public static bool IsMember(IElement element);
    public static bool IsMethod(IElement element);
    public static bool IsProperty(IElement element);
    public static bool IsEvent(IElement element);
    public static bool IsConstructor(IElement element);
    public static TypeDeclarationFilter get_Type();
    public static NamespaceFilter get_Namespace();
    public static TypeOrNamespaceFilter get_TypeOrNamespace();
    public static NonPrivateMemberFilter get_NonPrivateMember();
    public static MemberFilter get_Member();
    public static MethodFilter get_Method();
    public static PropertyFilter get_Property();
    public static EventFilter get_Event();
    public static ConstructorFilter get_Constructor();
}
public class DevExpress.CodeParser.DefaultTabSettings : TabSettings {
}
public class DevExpress.CodeParser.DefaultValueExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private TypeReferenceExpression _TypeReference;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public TypeReferenceExpression TypeReference { get; public set; }
    private ITypeReferenceExpression DevExpress.CodeParser.IDefaultValueExpression.TypeReference { get; }
    public DefaultValueExpression(TypeReferenceExpression type);
    public DefaultValueExpression(TypeReferenceExpression type, SourceRange range);
    protected void SetTypeReference(TypeReferenceExpression type);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual void CleanUpOwnedReferences();
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public TypeReferenceExpression get_TypeReference();
    public void set_TypeReference(TypeReferenceExpression value);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.IDefaultValueExpression.get_TypeReference();
}
public class DevExpress.CodeParser.DefineBase : object {
    private string _ConstantDefinition;
    private NodeList _TokenList;
    private string _Path;
    private SourcePoint _DefinitionStartPoint;
    private SourceRange _NameRange;
    public SourcePoint DefinitionStartPoint { get; public set; }
    public SourceRange NameRange { get; public set; }
    public string Path { get; public set; }
    public NodeList TokenList { get; public set; }
    public string ConstantDefinition { get; public set; }
    public DefineBase(string definition);
    public SourcePoint get_DefinitionStartPoint();
    public void set_DefinitionStartPoint(SourcePoint value);
    public SourceRange get_NameRange();
    public void set_NameRange(SourceRange value);
    public string get_Path();
    public void set_Path(string value);
    public NodeList get_TokenList();
    public void set_TokenList(NodeList value);
    public string get_ConstantDefinition();
    public void set_ConstantDefinition(string value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.DefineBaseCollection : NodeList {
    public DefineBase Item { get; public set; }
    protected int Add(DefineBase element);
    protected void AddRange(DefineBaseCollection collection);
    protected int IndexOf(DefineBase element);
    protected void Insert(int index, DefineBase element);
    protected void Remove(DefineBase element);
    protected DefineBase Find(DefineBase element);
    protected bool Contains(DefineBase element);
    protected virtual NodeList CreateInstance();
    public DefineBase get_Item(int index);
    public void set_Item(int index, DefineBase value);
}
public class DevExpress.CodeParser.DefineConst : DefineBase {
    public DefineConst(string definition);
}
public class DevExpress.CodeParser.DefineDirective : CompilerDirective {
    private string _Value;
    private string _Expression;
    private ParamsStringCollection _Params;
    private SourceRange _NameRange;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("DefineNameRange is obsolete. Use NameRange instead.")]
public SourceRange DefineNameRange { get; public set; }
    [EditorBrowsableAttribute("1")]
public string Value { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Symbol is obsolete. Use Value instead.")]
public string Symbol { get; public set; }
    public string Expression { get; public set; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; public set; }
    public ParamsStringCollection Params { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public SourceRange get_DefineNameRange();
    public void set_DefineNameRange(SourceRange value);
    public string get_Value();
    public void set_Value(string value);
    public string get_Symbol();
    public void set_Symbol(string value);
    public string get_Expression();
    public void set_Expression(string value);
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public ParamsStringCollection get_Params();
    public void set_Params(ParamsStringCollection value);
}
public class DevExpress.CodeParser.DefineMacro : DefineBase {
    private ParamsStringCollection _Params;
    public ParamsStringCollection Params { get; public set; }
    public DefineMacro(string definition, ParamsStringCollection paramList);
    public ParamsStringCollection get_Params();
    public void set_Params(ParamsStringCollection value);
}
public class DevExpress.CodeParser.DelegateDefinition : MemberWithParameters {
    private IElementCollection _DelegateMethods;
    public LanguageElementType ElementType { get; }
    public IElementCollection DelegateMethods { get; }
    [EditorBrowsableAttribute("1")]
public bool IsTypeDeclaration { get; }
    private bool DevExpress.CodeParser.ITypeElement.IsTypeParameter { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeElement.PrimaryAncestor { get; }
    private ITypeReferenceExpressionCollection DevExpress.CodeParser.ITypeElement.SecondaryAncestors { get; }
    private IMemberElementCollection DevExpress.CodeParser.ITypeElement.Members { get; }
    public DelegateDefinition(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual MemberVisibility GetDefaultVisibility();
    public sealed virtual ITypeElement[] GetAllDescendants();
    public sealed virtual ITypeElement[] GetAllDescendants(IElement scope);
    public sealed virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver);
    public sealed virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver, IElement scope);
    public sealed virtual ITypeElement GetBaseType();
    public sealed virtual ITypeElement GetBaseType(ISourceTreeResolver resolver);
    public sealed virtual ITypeElement[] GetBaseTypes();
    public sealed virtual ITypeElement[] GetBaseTypes(ISourceTreeResolver resolver);
    public sealed virtual ITypeElement[] GetDescendants();
    public sealed virtual ITypeElement[] GetDescendants(IElement scope);
    public sealed virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver);
    public sealed virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver, IElement scope);
    public virtual bool Is(string fullTypeName);
    public virtual bool Is(ITypeElement type);
    public virtual bool Is(Type type);
    public virtual bool Is(ISourceTreeResolver resolver, string fullTypeName);
    public sealed virtual bool Is(ISourceTreeResolver resolver, ITypeElement type);
    public sealed virtual bool Is(ISourceTreeResolver resolver, Type type);
    public sealed virtual bool DescendsFrom(string fullTypeName);
    public sealed virtual bool DescendsFrom(ITypeElement type);
    public sealed virtual bool DescendsFrom(Type type);
    public sealed virtual bool DescendsFrom(ISourceTreeResolver resolver, string fullTypeName);
    public sealed virtual bool DescendsFrom(ISourceTreeResolver resolver, ITypeElement type);
    public sealed virtual bool DescendsFrom(ISourceTreeResolver resolver, Type type);
    private TypeReferenceExpression CreateTypeReference(string name);
    private void AddDelegateParameters(LanguageElement parent, LanguageElementCollection parameters);
    private void AddParameter(LanguageElement parent, LanguageElementCollection parameters, string type, string name);
    private MethodPrototype GetMethodPrototype(TypeReferenceExpression returnType, string name, MethodTypeEnum methodType);
    private MethodPrototype GetInvokeMethod();
    private MethodPrototype GetBeginInvokeMethod();
    private MethodPrototype GetEndInvokeMethod();
    private void AddOutAndRefParameters(MethodPrototype result, LanguageElementCollection parameters);
    private IElementCollection GetDelegateMethods();
    public virtual LanguageElementType get_ElementType();
    public sealed virtual IElementCollection get_DelegateMethods();
    public virtual bool get_IsTypeDeclaration();
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.get_IsTypeParameter();
    private sealed virtual override IMemberElement DevExpress.CodeParser.ITypeElement.FindMember(string name);
    private sealed virtual override IMemberElement DevExpress.CodeParser.ITypeElement.FindMember(string name, bool searchInAncestors);
    private sealed virtual override IMemberElement DevExpress.CodeParser.ITypeElement.FindMember(string name, IElementFilter filter, bool searchInAncestors);
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.FindMembers(string name);
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.FindMembers(ISourceTreeResolver resolver, string name);
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.FindMembers(string name, bool searchInAncestors);
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.FindMembers(string name, IElementFilter filter, bool searchInAncestors);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeElement.get_PrimaryAncestor();
    private sealed virtual override ITypeReferenceExpressionCollection DevExpress.CodeParser.ITypeElement.get_SecondaryAncestors();
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.get_Members();
    private sealed virtual override void DevExpress.CodeParser.ITypeElementModifier.AddMember(IMemberElement member);
    private sealed virtual override void DevExpress.CodeParser.ITypeElementModifier.RemoveMember(IMemberElement member);
    private sealed virtual override void DevExpress.CodeParser.ITypeElementModifier.AddSecondaryAncestor(ITypeReferenceExpression type);
    private sealed virtual override void DevExpress.CodeParser.ITypeElementModifier.SetPrimaryAncestor(ITypeReferenceExpression type);
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
}
public class DevExpress.CodeParser.DeleteArrayExpression : DeleteExpression {
    public LanguageElementType ElementType { get; }
    public DeleteArrayExpression(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.DeleteExpression : Expression {
    private Expression _Expression;
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IDeleteExpression.Expression { get; }
    public DeleteExpression(Expression expression);
    private void SetExpression(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IDeleteExpression.get_Expression();
}
public enum DevExpress.CodeParser.DelimiterBlockType : Enum {
    public byte value__;
    public static DelimiterBlockType None;
    public static DelimiterBlockType Brace;
    public static DelimiterBlockType Token;
    public static DelimiterBlockType Middle;
}
public abstract class DevExpress.CodeParser.DelimiterCapableBlock : CodeElement {
    private TextRangeWrapper _BlockStart;
    private TextRangeWrapper _BlockEnd;
    private DelimiterBlockType _BlockType;
    [DescriptionAttribute("Returns true if this node owns a delimited block of code. For example, in C#, a Method body is delimited by "{" and "}" characters.")]
[CategoryAttribute("Block Delimiters")]
public bool HasDelimitedBlock { get; }
    [DescriptionAttribute("The position of the start delimiter of a blocked pair. In C#, this will mark the position of the "{" for a node which owns such a block.")]
[CategoryAttribute("Block Delimiters")]
public SourceRange BlockStart { get; }
    [DescriptionAttribute("The position of the end delimiter of a blocked pair. In C#, this will mark the position of the "}" for a node which owns such a block.")]
[CategoryAttribute("Block Delimiters")]
public SourceRange BlockEnd { get; }
    [DescriptionAttribute("Gets the range of code inside this element.")]
[CategoryAttribute("Block Delimiters")]
public SourceRange BlockCodeRange { get; }
    [DescriptionAttribute("Gets the range of code iside this element, including region and compiler directives")]
[CategoryAttribute("Block Delimiters")]
public SourceRange ExtendedBlockCodeRange { get; }
    [DescriptionAttribute("Gets block range including block delimiters.")]
[CategoryAttribute("Block Delimiters")]
public SourceRange BlockRange { get; }
    [DescriptionAttribute("The type of this delimited block.")]
[CategoryAttribute("Block Delimiters")]
public DelimiterBlockType BlockType { get; }
    private SourceRange DevExpress.CodeParser.IHasBlock.BlockStart { get; }
    private SourceRange DevExpress.CodeParser.IHasBlock.BlockEnd { get; }
    private SourceRange GetBlockCodeRangeFromChildren();
    private SourceRange GetBlockCodeRangeForEmptyBlock();
    private SourceRange AdjustRangeToParens(SourceRange range);
    private SourceRange AdjustBlockCodeRangeToDetailNodes(SourceRange range);
    private SourceRange AdjustBlockCodeRangeToNodes(SourceRange range, IList nodes);
    private SourceRange AdjustBlockCodeRangeToRegions(SourceRange range);
    private SourceRange AdjustBlockCodeRangeToComplilerDirectives(SourceRange range);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ParsePostponedTokens();
    protected virtual void UpdateRanges();
    public virtual void PatchIt(SourceRange sRange, SourceRange eRange);
    public virtual void ParseOnDemandIfNeeded();
    public SourceRange GetBlockCodeRange(bool checkRegions);
    public SourceRange GetBlockCodeRange(bool checkRegions, bool checkDirectives);
    public virtual int GetCyclomaticComplexity();
    [EditorBrowsableAttribute("1")]
public void SetBlockType(DelimiterBlockType type);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetBlockStart(SourceRange range);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetBlockEnd(SourceRange range);
    public sealed virtual bool get_HasDelimitedBlock();
    public SourceRange get_BlockStart();
    public SourceRange get_BlockEnd();
    public SourceRange get_BlockCodeRange();
    public SourceRange get_ExtendedBlockCodeRange();
    public SourceRange get_BlockRange();
    public sealed virtual DelimiterBlockType get_BlockType();
    private sealed virtual override SourceRange DevExpress.CodeParser.IHasBlock.get_BlockStart();
    private sealed virtual override SourceRange DevExpress.CodeParser.IHasBlock.get_BlockEnd();
}
public class DevExpress.CodeParser.DestructorFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
}
public interface DevExpress.CodeParser.Diagnostics.ILogger {
    public abstract virtual void Send(string message);
    public abstract virtual void SendError(string message);
    public abstract virtual void SendErrorWithStackTrace(string message);
    public abstract virtual void SendWarning(string message);
    public abstract virtual void SendException(Exception value);
    public abstract virtual void SendException(string message, Exception value);
}
public class DevExpress.CodeParser.Diagnostics.Log : object {
    private static ILogger Logger { get; }
    private static ILogger get_Logger();
    public static void Send(string message);
    public static void SendError(string message);
    public static void SendErrorWithStackTrace(string message);
    public static void SendWarning(string message);
    public static void SendException(Exception value);
    public static void SendException(string message, Exception value);
}
public class DevExpress.CodeParser.Diagnostics.NullLogger : object {
    public sealed virtual void Send(string message);
    public sealed virtual void SendError(string message);
    public sealed virtual void SendErrorWithStackTrace(string message);
    public sealed virtual void SendWarning(string message);
    public sealed virtual void SendException(Exception value);
    public sealed virtual void SendException(string message, Exception value);
}
public class DevExpress.CodeParser.DirectCastExpression : TypeCastExpression {
    public LanguageElementType ElementType { get; }
    public DirectCastExpression(TypeReferenceExpression type, Expression target);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.DirectiveCodeGenBase : LanguageElementCodeGenBase {
    public DirectiveCodeGenBase(CodeGen codeGen);
    public virtual void GenerateElement(LanguageElement languageElement);
    private bool GenerateDirective(PreprocessorDirective directive);
    protected abstract virtual void GenerateDefineDirective(DefineDirective directive);
    protected abstract virtual void GenerateIfDirective(IfDirective directive);
    protected abstract virtual void GenerateElifDirective(ElifDirective directive);
    protected abstract virtual void GenerateElseDirective(ElseDirective directive);
    protected abstract virtual void GenerateEndIfDirective(EndIfDirective directive);
    protected abstract virtual void GenerateUndefDirective(UndefDirective directive);
    protected abstract virtual void GenerateErrorDirective(ErrorDirective directive);
    protected abstract virtual void GenerateWarningDirective(WarningDirective directive);
    protected abstract virtual void GenerateLineDirective(LineDirective directive);
    protected abstract virtual void GenerateRegion(RegionDirective directive);
    protected abstract virtual void GenerateEndRegion(EndRegionDirective directive);
    protected abstract virtual void GenerateIfDefDirective(IfDefDirective directive);
    protected abstract virtual void GenerateIfnDefDirective(IfnDefDirective directive);
    protected abstract virtual void GenerateIncludeDirective(IncludeDirective directive);
    protected abstract virtual void GenerateImportDirective(ImportDirective directive);
    protected virtual void GeneratePragmaDirective(PragmaDirective directive);
    internal void GenerateTopDirectives(SourceFile sourceFile);
    private void GenerateDirectives(NodeList directives, Nullable`1<SourceRange> stopRange);
}
public class DevExpress.CodeParser.DistinctExpression : QueryExpressionBase {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual LanguageElementType get_ElementType();
    public virtual string ToString();
}
public class DevExpress.CodeParser.Do : ConditionalParentToSingleStatement {
    private Expression _Expression;
    private DoConditionType _ConditionType;
    private bool _PreCondition;
    public LanguageElementType ElementType { get; }
    public bool PreCondition { get; public set; }
    public DoConditionType ConditionType { get; public set; }
    public Expression Condition { get; }
    private IExpression DevExpress.CodeParser.IDoStatement.Condition { get; }
    public Do(Expression condition);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    [EditorBrowsableAttribute("1")]
public void SetCondition(Expression expression);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public bool get_PreCondition();
    public void set_PreCondition(bool value);
    public DoConditionType get_ConditionType();
    public void set_ConditionType(DoConditionType value);
    public Expression get_Condition();
    private sealed virtual override IExpression DevExpress.CodeParser.IDoStatement.get_Condition();
}
public enum DevExpress.CodeParser.DoConditionType : Enum {
    public int value__;
    public static DoConditionType While;
    public static DoConditionType Until;
}
public abstract class DevExpress.CodeParser.DocumentElement : BaseElement {
    private TextRange _InternalRange;
    private DocumentHistorySlice _History;
    private NodeList _Nodes;
    private NodeList _DetailNodes;
    [EditorBrowsableAttribute("1")]
protected internal string InternalName;
    protected internal NodeList InnerNodes { get; }
    protected internal NodeList InnerDetailNodes { get; }
    [DescriptionAttribute("The line number where this language element starts.")]
[CategoryAttribute("Position")]
public int StartLine { get; }
    [DescriptionAttribute("The line number where this language element ends.")]
[CategoryAttribute("Position")]
public int EndLine { get; }
    [DescriptionAttribute("The column offset where this language element starts.")]
[CategoryAttribute("Position")]
public int StartOffset { get; }
    [DescriptionAttribute("The column offset where this language element ends.")]
[CategoryAttribute("Position")]
public int EndOffset { get; }
    [DescriptionAttribute("The name of this language element class.")]
[CategoryAttribute("Description")]
public string ClassName { get; }
    [DescriptionAttribute("The name of this language element.")]
[CategoryAttribute("Description")]
public string Name { get; public set; }
    [DescriptionAttribute("The language elements parented by this element.")]
[CategoryAttribute("Family")]
public NodeList Nodes { get; }
    [DescriptionAttribute("The detail language elements associated with this element.")]
[CategoryAttribute("Family")]
public NodeList DetailNodes { get; }
    [EditorBrowsableAttribute("1")]
public DocumentHistorySlice History { get; }
    [EditorBrowsableAttribute("1")]
public SourceRange InternalRange { get; }
    public SourceRange RecoveredRange { get; }
    [EditorBrowsableAttribute("1")]
public bool IsNewContext { get; }
    public SourceRange NameRange { get; public set; }
    private SourceRange GetRecoveredRange(TextRange original);
    private void CloneChildren(DocumentElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
protected virtual void CloneRegions(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
protected static void SetHistory(NodeList list, DocumentHistorySlice history);
    [EditorBrowsableAttribute("1")]
protected static void SetHistory(NodeList list, int index, DocumentHistorySlice history);
    [EditorBrowsableAttribute("1")]
protected virtual SourceRange GetTransformedRange(TextRange original);
    protected virtual void UpdateRanges();
    [EditorBrowsableAttribute("1")]
public virtual void ClearHistory();
    protected void SelectCode(IDXCoreTextView textView, int startLine, int startOffset, int endLine, int endOffset, bool ensureVisible);
    [EditorBrowsableAttribute("1")]
protected void SetInnerDetailNodes(NodeList value);
    [EditorBrowsableAttribute("1")]
protected void SetInnerNodes(NodeList value);
    [EditorBrowsableAttribute("1")]
protected internal void PrepareDetailNodeList();
    [EditorBrowsableAttribute("1")]
protected internal void PrepareNodeList();
    [EditorBrowsableAttribute("1")]
protected long GetTotalMemoryForNodeList(NodeList nodeList);
    [EditorBrowsableAttribute("1")]
protected long GetTotalMemoryForDetailNodes();
    [EditorBrowsableAttribute("1")]
protected long GetTotalMemoryForNodes();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public long GetTotalMemory();
    [EditorBrowsableAttribute("1")]
public long GetTotalMemory(bool forceFullCollection);
    [EditorBrowsableAttribute("1")]
public bool DetailNodesFollowChildNodes();
    [EditorBrowsableAttribute("1")]
public void SetHistory(DocumentHistorySlice history);
    [EditorBrowsableAttribute("1")]
public void SetHistory(DocumentHistorySlice history, bool isRecursive);
    [EditorBrowsableAttribute("1")]
public virtual void SetHistory(int nodeIndex, DocumentHistorySlice history, bool isRecursive);
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    public virtual void CleanUpOwnedReferences();
    [EditorBrowsableAttribute("1")]
public virtual void PrepareToParentNodes();
    [EditorBrowsableAttribute("2")]
public virtual int GetImageIndex();
    public void SelectCode(IDXCoreTextView textView);
    public void SelectCode(IDXCoreTextView textView, bool aEnsureVisible);
    public virtual bool Contains(int line, int offset);
    public bool Contains(SourcePoint point);
    public bool Contains(DocumentElement aElement);
    public bool Contains(SourceRange aRange);
    public bool ContainedIn(int startLine, int startOffset, int endLine, int endOffset);
    public bool ContainedIn(SourcePoint start, SourcePoint end);
    public bool ContainedIn(SourceRange aRange);
    public virtual string GetDetailNodeDescription(int index);
    public bool StartsAfter(int lineNumber, int columnOffset);
    public bool StartsAfter(DocumentElement documentElement);
    public bool StartsAfter(SourcePoint sourcePoint);
    public bool StartsBefore(int lineNumber, int columnOffset);
    public bool StartsBefore(DocumentElement documentElement);
    public bool StartsBefore(SourcePoint sourcePoint);
    public bool EndsAfter(int lineNumber, int columnOffset);
    public bool EndsAfter(DocumentElement documentElement);
    public bool EndsAfter(SourcePoint sourcePoint);
    public bool EndsBefore(int lineNumber, int columnOffset);
    public bool EndsBefore(DocumentElement documentElement);
    public bool EndsBefore(SourcePoint sourcePoint);
    [EditorBrowsableAttribute("1")]
public void SetEnd(int lineNumber, int characterOffset);
    [EditorBrowsableAttribute("1")]
public void SetEnd(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetEnd(SourcePoint point);
    [EditorBrowsableAttribute("1")]
public void SetEnd(Token token);
    [EditorBrowsableAttribute("1")]
public void SetEndOffset(int characterOffset);
    [EditorBrowsableAttribute("1")]
public void SetRange(int startLine, int startOffset, int endLine, int endOffset);
    [EditorBrowsableAttribute("1")]
public void SetRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetRange(SourcePoint startPoint, SourcePoint endPoint);
    [EditorBrowsableAttribute("1")]
public void SetStart(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetStart(SourcePoint point);
    [EditorBrowsableAttribute("1")]
public void SetStart(int lineNumber, int characterOffset);
    [EditorBrowsableAttribute("1")]
public void SetStart(Token token);
    protected internal virtual NodeList get_InnerNodes();
    protected internal virtual NodeList get_InnerDetailNodes();
    public int get_StartLine();
    public virtual int get_EndLine();
    public int get_StartOffset();
    public virtual int get_EndOffset();
    public string get_ClassName();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual NodeList get_Nodes();
    public virtual NodeList get_DetailNodes();
    public virtual DocumentHistorySlice get_History();
    public SourceRange get_InternalRange();
    public SourceRange get_RecoveredRange();
    public virtual bool get_IsNewContext();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.DocumentHistory : object {
    private ArrayList _Slices;
    [CompilerGeneratedAttribute]
private EventHandler BeforeClear;
    [CompilerGeneratedAttribute]
private EventHandler AfterClear;
    private int Count { get; }
    private DocumentHistorySlice Item { get; }
    public DocumentHistorySlice Current { get; }
    private int get_Count();
    private DocumentHistorySlice get_Item(int i);
    private void CreateCurrent();
    protected virtual void OnBeforeClear();
    protected virtual void OnAfterClear();
    public void Insert(TextRange range);
    public void Delete(TextRange range);
    public DocumentHistorySlice Branch();
    public void Clear();
    public SourceRange[] UpdateRanges(SourceRange[] ranges, int newLength);
    public SourceRange[] UpdateRanges(SourceRange[] ranges, Int32[] newLengths);
    public SourceRange[] UpdateRanges(SourceRange[] ranges, SourceRange[] newRanges);
    public DocumentHistorySlice get_Current();
    [CompilerGeneratedAttribute]
public void add_BeforeClear(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeClear(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_AfterClear(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AfterClear(EventHandler value);
}
public class DevExpress.CodeParser.DocumentHistorySlice : object {
    private ArrayList _RangeTransforms;
    private TextPointWrapper pointWrapper;
    private int Find(RangeTransform transform);
    private int FindTransformed(TextPoint point);
    private int FindOriginal(TextPoint point);
    private void AddTransform(RangeTransform transform);
    private void RemoveTransform(int i);
    private void GetLineOffset(Int32& line, Int32& offset);
    private RangeTransform FindContainingTransform(TextPoint point);
    private void RemoveTransforms(TextRange range);
    private void ShiftTrailingTransforms(TextRange range, bool shiftUp);
    private void TransformDeletedPoint(Int32& line, Int32& offset);
    private bool WasDeleted(TextPoint point);
    private TextRange TransformRangeWithRecover(TextPoint start, TextPoint end);
    public void Insert(TextRange range);
    public void Delete(TextRange range);
    public TextPoint TransformStart(TextPoint point);
    public TextPoint TransformEnd(TextPoint point);
    public TextRange Transform(TextRange range);
    public TextRange TransformWithRecover(TextRange range);
    public void GetPoint(Int32& line, Int32& offset);
    public int GetLine(int line, int offset);
    public int GetOffset(int line, int offset);
    private bool IsDeletion(RangeTransform start, RangeTransform end);
    private bool IsInsertion(RangeTransform start, RangeTransform end);
    private static TextRange GetEditOperationRange(RangeTransform prev, RangeTransform next);
    private TextRange GetInsertionRange(RangeTransform prev, RangeTransform next);
    private TextRange GetDeletionRange(RangeTransform prev, RangeTransform next);
    public TextRange[] GetDeletions();
    public TextRange[] GetInsertions();
}
public enum DevExpress.CodeParser.DotNetLanguageType : Enum {
    public int value__;
    public static DotNetLanguageType CSharp;
    public static DotNetLanguageType VisualBasic;
    public static DotNetLanguageType JavaScript;
    public static DotNetLanguageType FSharp;
    public static DotNetLanguageType ScriptLanguage;
    public static DotNetLanguageType VBScript;
    public static DotNetLanguageType Ruby;
    public static DotNetLanguageType Python;
    public static DotNetLanguageType Unknown;
}
public class DevExpress.CodeParser.DynamicCastExpression : CppTypeCastExpression {
    public LanguageElementType ElementType { get; }
    protected virtual string GetString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public enum DevExpress.CodeParser.ElaboratedKind : Enum {
    public int value__;
    public static ElaboratedKind Unknown;
    public static ElaboratedKind Class;
    public static ElaboratedKind Struct;
    public static ElaboratedKind Enum;
    public static ElaboratedKind Union;
    public static ElaboratedKind Type;
    public static ElaboratedKind RefClass;
    public static ElaboratedKind RefStruct;
    public static ElaboratedKind ValueClass;
    public static ElaboratedKind ValueStruct;
}
public class DevExpress.CodeParser.ElaboratedTypeReference : TypeReferenceExpression {
    private ElaboratedKind _ElaboratedKind;
    private InheritanceModel _InheritanceModel;
    private Expression _SourceExpression;
    public LanguageElementType ElementType { get; }
    public ElaboratedKind ElaboratedKind { get; public set; }
    public Expression SourceExpression { get; public set; }
    public InheritanceModel InheritanceModel { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsTypeDeclaration { get; }
    private ElaboratedKind DevExpress.CodeParser.IElaboratedTypeElement.ElaboratedKind { get; }
    private IExpression DevExpress.CodeParser.IElaboratedTypeElement.Expression { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeElement.PrimaryAncestor { get; }
    private ITypeReferenceExpressionCollection DevExpress.CodeParser.ITypeElement.SecondaryAncestors { get; }
    private IMemberElementCollection DevExpress.CodeParser.ITypeElement.Members { get; }
    private bool DevExpress.CodeParser.ITypeElement.IsTypeParameter { get; }
    private IExpression DevExpress.CodeParser.IMemberElement.NameQualifier { get; }
    private MemberVisibility DevExpress.CodeParser.IMemberElement.Visibility { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsDefaultVisibility { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsAbstract { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsVirtual { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsOverride { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsNew { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsPartial { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsReadOnly { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsStatic { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsSealed { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsExplicitInterfaceMember { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsExtern { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsIterator { get; }
    private string DevExpress.CodeParser.IMemberElement.Signature { get; }
    private IExpressionCollection DevExpress.CodeParser.IMemberElement.Implements { get; }
    private bool DevExpress.CodeParser.IMemberElement.HasDelimitedBlock { get; }
    private IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.Attributes { get; }
    private ITypeParameterCollection DevExpress.CodeParser.IGenericElement.TypeParameters { get; }
    private bool DevExpress.CodeParser.IGenericElement.IsGeneric { get; }
    private bool DevExpress.CodeParser.IGenericElement.IsActivatedGeneric { get; }
    private IGenericElement DevExpress.CodeParser.IGenericElement.GenericTemplate { get; }
    public ElaboratedTypeReference(string type);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    private void SetSourceExpression(Expression expr);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public ElaboratedKind get_ElaboratedKind();
    public void set_ElaboratedKind(ElaboratedKind value);
    public Expression get_SourceExpression();
    public void set_SourceExpression(Expression value);
    public InheritanceModel get_InheritanceModel();
    public void set_InheritanceModel(InheritanceModel value);
    public virtual bool get_IsTypeDeclaration();
    private sealed virtual override ElaboratedKind DevExpress.CodeParser.IElaboratedTypeElement.get_ElaboratedKind();
    private sealed virtual override IExpression DevExpress.CodeParser.IElaboratedTypeElement.get_Expression();
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeElement.get_PrimaryAncestor();
    private sealed virtual override ITypeReferenceExpressionCollection DevExpress.CodeParser.ITypeElement.get_SecondaryAncestors();
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.get_Members();
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.get_IsTypeParameter();
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetAllDescendants();
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetAllDescendants(IElement scope);
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetAllDescendants(ISourceTreeResolver resolver);
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetAllDescendants(ISourceTreeResolver resolver, IElement scope);
    private sealed virtual override ITypeElement DevExpress.CodeParser.ITypeElement.GetBaseType();
    private sealed virtual override ITypeElement DevExpress.CodeParser.ITypeElement.GetBaseType(ISourceTreeResolver resolver);
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetBaseTypes();
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetBaseTypes(ISourceTreeResolver resolver);
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetDescendants();
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetDescendants(IElement scope);
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetDescendants(ISourceTreeResolver resolver);
    private sealed virtual override ITypeElement[] DevExpress.CodeParser.ITypeElement.GetDescendants(ISourceTreeResolver resolver, IElement scope);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.Is(string fullTypeName);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.Is(ITypeElement parentElement);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.Is(Type type);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.Is(ISourceTreeResolver resolver, string fullTypeName);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.Is(ISourceTreeResolver resolver, ITypeElement parentElement);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.Is(ISourceTreeResolver resolver, Type type);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.DescendsFrom(string fullTypeName);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.DescendsFrom(ITypeElement parentElement);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.DescendsFrom(Type type);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.DescendsFrom(ISourceTreeResolver resolver, string fullTypeName);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.DescendsFrom(ISourceTreeResolver resolver, ITypeElement parentElement);
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.DescendsFrom(ISourceTreeResolver resolver, Type type);
    private sealed virtual override IMemberElement DevExpress.CodeParser.ITypeElement.FindMember(string name);
    private sealed virtual override IMemberElement DevExpress.CodeParser.ITypeElement.FindMember(string name, bool searchInAncestors);
    private sealed virtual override IMemberElement DevExpress.CodeParser.ITypeElement.FindMember(string name, IElementFilter filter, bool searchInAncestors);
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.FindMembers(string name);
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.FindMembers(ISourceTreeResolver resolver, string name);
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.FindMembers(string name, bool searchInAncestors);
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.FindMembers(string name, IElementFilter filter, bool searchInAncestors);
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.GetOverrideCode();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.GetOverrideCode(bool callBase);
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.GetOverrideCode(bool callBase, string codeBefore, string codeAfter);
    private sealed virtual override IExpression DevExpress.CodeParser.IMemberElement.get_NameQualifier();
    private sealed virtual override MemberVisibility DevExpress.CodeParser.IMemberElement.get_Visibility();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsDefaultVisibility();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsAbstract();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsVirtual();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsOverride();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsNew();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsPartial();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsReadOnly();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsStatic();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsSealed();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsExplicitInterfaceMember();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsExtern();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsIterator();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMemberElement.get_Implements();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_HasDelimitedBlock();
    private sealed virtual override IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.get_Attributes();
    private sealed virtual override ITypeParameterCollection DevExpress.CodeParser.IGenericElement.get_TypeParameters();
    private sealed virtual override bool DevExpress.CodeParser.IGenericElement.get_IsGeneric();
    private sealed virtual override bool DevExpress.CodeParser.IGenericElement.get_IsActivatedGeneric();
    private sealed virtual override IGenericElement DevExpress.CodeParser.IGenericElement.get_GenericTemplate();
}
public class DevExpress.CodeParser.ElementBuilder : object {
    private static string STR_SystemInt32;
    private LanguageElementCollection _TopLevelElements;
    private ElementList _RootElement;
    public NodeList TopLevelElements { get; }
    protected void AddTopElement(LanguageElement element);
    protected void InsertTopElement(int index, LanguageElement element);
    protected int GetIndexOfTopElement(LanguageElement element);
    protected string GetSimpleTypeName(string typeName);
    protected string GenerateElement(LanguageElement element);
    protected string GenerateElement(LanguageElement element, string languageID);
    protected string GenerateElement(LanguageElement element, int precedingWhiteSpaceCount);
    protected string GenerateElement(LanguageElement element, string languageID, int precedingWhiteSpaceCount);
    protected void SetMethodType(Method method, string type);
    protected virtual Param AddParam(MemberWithParameters parent, Param param);
    protected virtual Expression AddMethodArgument(MethodCall parent, Expression argument);
    protected virtual Expression AddSource(IHasQualifier parent, object source);
    protected virtual AttributeSection AddAttributeSection(CodeElement target, AttributeSection section);
    protected virtual Attribute AddAttribute(AttributeSection parent, Attribute attr);
    public virtual ConstructorInitializer AddConstructorInitializer(Method parent, ConstructorInitializer initializer);
    protected virtual Comment AddComment(CodeElement parent, Comment comment);
    public virtual Throw AddThrow(LanguageElement parent, Throw throw);
    protected virtual bool IsAnIdentifier(string text);
    protected virtual TypeReferenceExpression GetTypeReferenceExpression(object expression);
    protected virtual LanguageElementCollectionBase AddDetailNodes(LanguageElement parent, LanguageElementCollectionBase children);
    public virtual LanguageElement AddDetailNode(LanguageElement parent, LanguageElement child);
    public virtual LanguageElementCollectionBase AddNodes(LanguageElement parent, LanguageElementCollectionBase children);
    public virtual LanguageElement AddNode(LanguageElement parent, LanguageElement child);
    public virtual Expression GetExpression(object expression);
    public virtual ExpressionCollection GetSnippetExpressions(String[] values);
    public virtual ExpressionCollection GetSnippetExpressions(LanguageElementCollection elements);
    public virtual LanguageElement GetInitializer(object initializer);
    public void ClearTopLevelElements();
    public string GenerateCode(string languageID, int precedingWhiteSpaceCount);
    public string GenerateCode(string languageID);
    public string GenerateCode();
    public virtual DefineDirective AddDefineDirective(LanguageElement parent);
    public virtual DefineDirective BuildDefineDirective();
    public virtual UnaryOperatorExpression OpPointerDereference(object identifier);
    public virtual UnaryIncrement OpPlusPlus(object identifier);
    public virtual UnaryIncrement OpPlusPlus(object identifier, bool isPostIncrement);
    public virtual UnaryDecrement OpMinusMinus(object identifier);
    public virtual UnaryDecrement OpMinusMinus(object identifier, bool isPostDecrement);
    public virtual BinaryOperatorExpression Op(object leftSide, string operatorText, object rightSide);
    public virtual BinaryOperatorExpression Op(object leftSide, BinaryOperatorType op, object rightSide);
    public virtual RelationalOperation Op(object leftSide, RelationalOperator operatorType, object rightSide);
    public virtual BinaryOperatorExpression OpMinus(object leftSide, object rightSide);
    public virtual BinaryOperatorExpression OpPlus(object leftSide, object rightSide);
    public virtual BinaryOperatorExpression OpTimes(object leftSide, object rightSide);
    public virtual BinaryOperatorExpression OpDivide(object leftSide, object rightSide);
    public virtual BinaryOperatorExpression OpModulus(object leftSide, object rightSide);
    public virtual RelationalOperation OpEquals(object leftSide, object rightSide);
    public virtual RelationalOperation OpNotEquals(object leftSide, object rightSide);
    public virtual RelationalOperation OpGreaterOrEqual(object leftSide, object rightSide);
    public virtual RelationalOperation OpGreaterThan(object leftSide, object rightSide);
    public virtual RelationalOperation OpLessOrEqual(object leftSide, object rightSide);
    public virtual RelationalOperation OpLessThan(object leftSide, object rightSide);
    public virtual RelationalOperation OpLike(object leftSide, object rightSide);
    public virtual LogicalInversion AddLogicalInversion(LanguageElement parent);
    public virtual LogicalInversion AddLogicalInversion(LanguageElement parent, object expression);
    public virtual LogicalInversion BuildLogicalInversion();
    public virtual LogicalInversion BuildLogicalInversion(object expression);
    public virtual ElementReferenceExpression AddQualifiedElementReference(LanguageElement parent, object source, string name);
    public virtual ElementReferenceExpression AddMemberAccessReference(LanguageElement parent, object source, string name, MemberAccesOperatorType operatorType);
    public virtual ObjectCreationExpression AddObjectCreationExpression(LanguageElement parent, string typeName, String[] arguments);
    public virtual ObjectCreationExpression AddObjectCreationExpression(LanguageElement parent, string typeName, ExpressionCollection arguments);
    public virtual ObjectCreationExpression AddManagedObjectCreationExpression(LanguageElement parent, string typeName, String[] arguments);
    public virtual ObjectCreationExpression AddManagedObjectCreationExpression(LanguageElement parent, string typeName, ExpressionCollection arguments);
    public virtual AssignmentExpression AddAssignmentExpression(LanguageElement parent, object left, object right, AssignmentOperatorType operatorType);
    public virtual ParenthesizedExpression AddParenthesizedExpression(LanguageElement parent, object expression);
    public virtual ParenthesizedExpression BuildParenthesizedExpression(object expression);
    public virtual ObjectInitializerExpression AddObjectInitializerExpression(LanguageElement parent);
    public virtual ObjectInitializerExpression BuildObjectInitializerExpression();
    public MemberInitializerExpression AddMemberInitializerExpression(LanguageElement parent, string name, object value);
    public MemberInitializerExpression AddMemberInitializerExpression(LanguageElement parent);
    public MemberInitializerExpression BuildMemberInitializerExpression(string name, object value);
    public MemberInitializerExpression BuildMemberInitializerExpression();
    public MemberAccessExpression BuildMemberAccessExpression();
    public virtual ArrayInitializerExpression AddArrayInitializerExpression(LanguageElement parent);
    public virtual ArrayInitializerExpression AddArrayInitializerExpression(LanguageElement parent, String[] expressions);
    public virtual ArrayInitializerExpression AddArrayInitializerExpression(LanguageElement parent, ExpressionCollection expressions);
    public virtual ArrayInitializerExpression BuildArrayInitializerExpression();
    public virtual ArrayInitializerExpression BuildArrayInitializerExpression(String[] expressions);
    public virtual ArrayInitializerExpression BuildArrayInitializerExpression(ExpressionCollection expressions);
    public virtual ArrayCreateExpression AddArrayCreateExpression(LanguageElement parent);
    public virtual ArrayCreateExpression AddArrayCreateExpression(LanguageElement parent, TypeReferenceExpression type);
    public virtual ArrayCreateExpression AddArrayCreateExpression(LanguageElement parent, TypeReferenceExpression type, ExpressionCollection dimensions);
    public virtual ArrayCreateExpression AddArrayCreateExpression(LanguageElement parent, TypeReferenceExpression type, ExpressionCollection dimensions, ArrayInitializerExpression initializer);
    public virtual ArrayCreateExpression BuildArrayCreateExpression();
    public virtual ArrayCreateExpression BuildArrayCreateExpression(TypeReferenceExpression type);
    public virtual ArrayCreateExpression BuildArrayCreateExpression(TypeReferenceExpression type, ExpressionCollection dimensions);
    public virtual ArrayCreateExpression BuildArrayCreateExpression(TypeReferenceExpression type, ExpressionCollection dimensions, ArrayInitializerExpression initializer);
    public virtual TypeCastExpression AddTypeCast(LanguageElement parent, object type, object expression);
    public virtual TypeCheck AddTypeCheck(LanguageElement parent, object expression, object type);
    public virtual TypeCheck BuildTypeCheck(object expression, object type);
    public virtual ConditionalTypeCast AddConditionalTypeCast(LanguageElement parent, object expression, object type);
    public virtual ConditionalTypeCast BuildConditionalTypeCast(object expression, object type);
    public virtual TypeOfExpression AddTypeOfExpression(LanguageElement parent, TypeReferenceExpression type);
    public virtual TypeOfExpression AddTypeOfExpression(LanguageElement parent, Expression type);
    public virtual TypeOfExpression BuildTypeOfExpression(TypeReferenceExpression type);
    public virtual TypeOfExpression BuildTypeOfExpression(Expression type);
    public virtual SizeOfExpression AddSizeOfExpression(LanguageElement parent, TypeReferenceExpression type);
    public virtual SizeOfExpression AddSizeOfExpression(LanguageElement parent, Expression type);
    public virtual SizeOfExpression BuildSizeOfExpression(TypeReferenceExpression type);
    public virtual SizeOfExpression BuildSizeOfExpression(Expression type);
    public virtual DefaultValueExpression AddDefaultValueExpression(LanguageElement parent, TypeReferenceExpression type);
    public virtual DefaultValueExpression BuildDefaultValueExpression(TypeReferenceExpression type);
    public virtual AnonymousMethodExpression AddAnonymousMethodExpression(LanguageElement parent);
    public virtual AnonymousMethodExpression BuildAnonymousMethodExpression();
    public virtual LambdaExpression AddLambdaExpression(LanguageElement parent);
    public virtual LambdaExpression BuildLambdaExpression();
    public virtual LambdaImplicitlyTypedParam AddLambdaImplicitlyTypedParam(LanguageElement parent, string name);
    public virtual LambdaImplicitlyTypedParam BuildLambdaImplicitlyTypedParam(string name);
    public virtual IndexerExpression BuildIndexerExpression(Expression expression);
    public virtual IndexerExpression BuildIndexerExpression(Expression expression, String[] arguments);
    public virtual IndexerExpression BuildIndexerExpression(Expression expression, ExpressionCollection arguments);
    public virtual TypeParameter AddTypeParameter(LanguageElement parent, string name);
    public virtual TypeParameter BuildTypeParameter(string name);
    public virtual ClassTypeParameterConstraint AddClassTypeParameterConstraint(LanguageElement parent, string name, SourceRange range);
    public virtual ClassTypeParameterConstraint AddClassTypeParameterConstraint(LanguageElement parent);
    public virtual ClassTypeParameterConstraint BuildClassTypeParameterConstraint();
    public virtual ClassTypeParameterConstraint BuildClassTypeParameterConstraint(string name, SourceRange range);
    public virtual StructTypeParameterConstraint AddStructTypeParameterConstraint(LanguageElement parent);
    public virtual StructTypeParameterConstraint AddStructTypeParameterConstraint(LanguageElement parent, string name, SourceRange range);
    public virtual StructTypeParameterConstraint BuildStructTypeParameterConstraint();
    public virtual StructTypeParameterConstraint BuildStructTypeParameterConstraint(string name, SourceRange range);
    public virtual NewTypeParameterConstraint AddNewTypeParameterConstraint(LanguageElement parent);
    public virtual NewTypeParameterConstraint AddNewTypeParameterConstraint(LanguageElement parent, string name, SourceRange range);
    public virtual NewTypeParameterConstraint BuildNewTypeParameterConstraint();
    public virtual NewTypeParameterConstraint BuildNewTypeParameterConstraint(string name, SourceRange range);
    public virtual NamedTypeParameterConstraint AddNamedTypeParameterConstraint(LanguageElement parent, object expression);
    public virtual NamedTypeParameterConstraint BuildNamedTypeParameterConstraint(object expression);
    public virtual GenericModifier AddGenericModifier(LanguageElement parent, TypeParameterCollection types);
    public virtual GenericModifier AddGenericModifier(LanguageElement parent, String[] names);
    public virtual GenericModifier BuildGenericModifier(TypeParameterCollection types);
    public virtual GenericModifier BuildGenericModifier(String[] names);
    public virtual TypeParameterCollection BuildTypeParameterCollection();
    public virtual TypeParameterCollection BuildTypeParameterCollection(String[] names);
    public virtual ExpressionCollection BuildExpressionCollection();
    public virtual ExpressionCollection BuildExpressionCollection(String[] names);
    public virtual LanguageElementCollection BuildLanguageElementCollection();
    public virtual TypeReferenceExpressionCollection BuildTypeReferenceExpressionCollection();
    public virtual ElementList BuildElementList();
    public virtual ElementList BuildElementList(LanguageElementCollection list);
    public virtual ElementList BuildElementList(NodeList list);
    public virtual CaseClausesList BuildCaseClausesList();
    public virtual CommentCollection BuildCommentCollection();
    public NamespaceReference AddNamespaceReference(LanguageElement parent, string namespaceName);
    public NamespaceReference AddNamespaceReference(LanguageElement parent, string aliasName, string expression);
    public virtual Namespace AddNamespace(LanguageElement parent, string name);
    public virtual Namespace BuildNamespace(string name);
    public Class AddClass(LanguageElement parent, string className);
    public Struct AddStruct(LanguageElement parent, string structName);
    public Interface AddInterface(LanguageElement parent, string interfaceName);
    public Interface AddInterfaceClass(LanguageElement parent, string interfaceName);
    public Interface AddInterfaceStruct(LanguageElement parent, string interfaceName);
    public DelegateDefinition AddDelegateDefinition(LanguageElement parent, string delegateName);
    public DelegateDefinition AddDelegateDefinition(LanguageElement parent, string delegateName, LanguageElementCollection parameters);
    public DelegateDefinition AddDelegateDefinition(LanguageElement parent, string delegateName, string delegateType);
    public DelegateDefinition AddDelegateDefinition(LanguageElement parent, string delegateName, string delegateType, LanguageElementCollection parameters);
    public DelegateDefinition AddDelegateDefinition(LanguageElement parent, string delegateName, TypeReferenceExpression delegateType);
    public DelegateDefinition AddDelegateDefinition(LanguageElement parent, string delegateName, TypeReferenceExpression delegateType, LanguageElementCollection parameters);
    public virtual DelegateDefinition BuildDelegateDefinition(string delegateName, string delegateType);
    public virtual DelegateDefinition BuildDelegateDefinition(string delegateName, string delegateType, LanguageElementCollection parameters);
    public virtual DelegateDefinition BuildDelegateDefinition(string delegateName, TypeReferenceExpression delegateType);
    public virtual DelegateDefinition BuildDelegateDefinition(string delegateName, TypeReferenceExpression delegateType, LanguageElementCollection parameters);
    public virtual Enumeration AddEnumeration(LanguageElement parent);
    public virtual Enumeration AddEnumeration(LanguageElement parent, string name);
    public virtual Enumeration BuildEnumeration();
    public virtual Enumeration BuildEnumeration(string name);
    public Break AddBreak(LanguageElement parent);
    public Abort AddAbort(LanguageElement parent);
    public Continue AddContinue(LanguageElement parent);
    public Exit AddExit(LanguageElement parent);
    public virtual With AddWith(LanguageElement parent);
    public virtual With AddWith(LanguageElement parent, object expression);
    public virtual With AddWith(LanguageElement parent, object expression, LanguageElementCollection block);
    public virtual With BuildWith();
    public virtual With BuildWith(object expression);
    public virtual With BuildWith(object expression, LanguageElementCollection block);
    public Return AddReturn(LanguageElement parent);
    public Return AddReturn(LanguageElement parent, object expression);
    public virtual Abort BuildAbort();
    public virtual Break BuildBreak();
    public virtual Continue BuildContinue();
    public virtual Exit BuildExit();
    public virtual Return BuildReturn();
    public virtual Return BuildReturn(object expression);
    public NamespaceReference BuildNamespaceReference(string namespaceName);
    public NamespaceReference BuildNamespaceReference(string aliasName, string expression);
    public virtual Class BuildClass(string className);
    public virtual Struct BuildStruct(string structName);
    public virtual Interface BuildInterface(string interfaceName);
    public virtual Interface BuildInterfaceClass(string interfaceName);
    public virtual Interface BuildInterfaceStruct(string interfaceName);
    public virtual DelegateDefinition BuildDelegateDefinition(string delegateName);
    public virtual DelegateDefinition BuildDelegateDefinition(string delegateName, LanguageElementCollection parameters);
    public Assignment AddAssignment(LanguageElement parent, object identifier, object assignedValue, AssignmentOperatorType operatorType);
    public Assignment AddAssignment(LanguageElement parent, object identifier, object assignedValue);
    public AccessSpecifiers AddAccessSpecifiers(AccessSpecifiedElement parent, AccessSpecifiers accessSpecifiers);
    public AccessSpecifiers AddAccessSpecifiers(AccessSpecifiedElement parent, bool isVirtual, bool isOverride, bool isOverloads, bool isStatic);
    public Case AddCase(LanguageElement parent, object expression);
    public Case AddCase(LanguageElement parent);
    public Case AddCase(LanguageElement parent, bool isDefault);
    public virtual Case BuildCase();
    public virtual Case BuildCase(bool isDefault);
    public Catch AddCatch(LanguageElement parent, string exceptionType, string exceptionVariable);
    public Catch AddCatch(LanguageElement parent);
    public Do AddDo(LanguageElement parent, object condition);
    public Else AddElse(LanguageElement parent);
    public ElseIf AddElseIf(LanguageElement parent, object expression);
    public Finally AddFinally(LanguageElement parent);
    public ForEach AddForEach(LanguageElement parent, string elementType, string elementVariable, object collection);
    public For AddFor(LanguageElement parent, Expression endCondition);
    public For AddFor(LanguageElement parent, string iteratorVar, Expression endCondition);
    public InitializedVariable AddInitializedVariable(LanguageElement parent, string variableType, string variableName, object initialValue);
    public virtual InitializedVariable AddInitializedVariable(LanguageElement parent, TypeReferenceExpression variableType, string variableName, Expression value);
    public virtual Const AddConst(LanguageElement parent, string variableType, string variableName, object expression);
    public virtual Const BuildConst(string variableType, string variableName, object expression);
    public ImplicitVariable AddImplicitVariable(LanguageElement parent, string variableName, object initialValue);
    public If AddIf(LanguageElement parent, object expression);
    public LogicalOperation AddLogicalOperation(LanguageElement parent, object leftSide, LogicalOperator logicalOperator, object rightSide);
    public MethodCall AddMethodCall(LanguageElement parent, string name);
    public MethodCall AddMethodCall(LanguageElement parent, string name, ExpressionCollection arguments);
    public MethodCall AddMethodCall(LanguageElement parent, string name, String[] arguments, object qualifier);
    public MethodCall AddMethodCall(LanguageElement parent, object source);
    public MethodCall AddMethodCall(LanguageElement parent, string name, String[] arguments);
    public MethodCall AddMethodCall(LanguageElement parent, string name, ExpressionCollection arguments, object qualifier);
    public RelationalOperation AddLogicalOperation(LanguageElement parent, object leftSide, RelationalOperator relationalOperator, object rightSide);
    public ConditionalExpression AddConditionalExpression(LanguageElement parent, object condition, object trueExpression, object falseExpression);
    public ConditionalExpression BuildConditionalExpression(object condition, object trueExpression, object falseExpression);
    public Switch AddSelect(LanguageElement parent, object expression);
    public Switch AddSwitch(LanguageElement parent, object expression);
    public Try AddTry(LanguageElement parent);
    public MethodCall AddThisMethodCall(LanguageElement parent, string name, ExpressionCollection arguments);
    public Variable AddVariable(LanguageElement parent, string variableType, string variableName);
    public Variable AddVariable(LanguageElement parent, TypeReferenceExpression variableType, string variableName);
    public While AddWhile(LanguageElement parent, object condition);
    public LanguageElement AddStatement(LanguageElement parent, object statement);
    public virtual Statement AddWrapStatement(LanguageElement parent, object expression);
    public virtual Statement BuildWrapStatement(object expression);
    public virtual void AddBaseMethodCall(LanguageElement parent, string name, ExpressionCollection arguments);
    public virtual void AddBaseMethodCall(LanguageElement parent, string name, ExpressionCollection arguments, string codeBefore, string codeAfter);
    public virtual Block AddBlock(LanguageElement parent);
    public virtual Block BuildBlock();
    public virtual UnsafeStatement AddUnsafeStatement(LanguageElement parent);
    public virtual UnsafeStatement BuildUnsafeStatement();
    public virtual Fixed AddFixed(LanguageElement parent);
    public virtual Fixed AddFixed(LanguageElement parent, object initializer);
    public virtual Fixed BuildFixed();
    public virtual Fixed BuildFixed(object initializer);
    public virtual UsingStatement AddUsingStatement(LanguageElement parent);
    public virtual UsingStatement AddUsingStatement(LanguageElement parent, object initializer);
    public virtual UsingStatement BuildUsingStatement();
    public virtual UsingStatement BuildUsingStatement(object initializer);
    public virtual Checked AddChecked(LanguageElement parent);
    public virtual Checked BuildChecked();
    public virtual CheckedExpression AddCheckedExpression(LanguageElement parent, object expression);
    public virtual CheckedExpression BuildCheckedExpression(object expression);
    public virtual Unchecked AddUnchecked(LanguageElement parent);
    public virtual Unchecked BuildUnchecked();
    public virtual UncheckedExpression AddUncheckedExpression(LanguageElement parent, object expression);
    public virtual UncheckedExpression BuildUncheckedExpression(object expression);
    public virtual CTypeExpression BuildCTypeExpression(TypeReferenceExpression type, object expression);
    public virtual Is BuildIs(object left, object right);
    public virtual IsNot BuildIsNot(object left, object right);
    protected virtual CaseClause AddCaseClause(Case parent, CaseClause caseClause);
    public virtual CaseClause AddCaseClause(Case parent);
    public virtual CaseClause AddCaseClause(Case parent, object startExpression);
    public virtual CaseClause AddCaseClause(Case parent, object startExpression, object endExpression);
    public virtual CaseClause BuildCaseClause();
    public virtual CaseClause BuildCaseClause(object startExpression);
    public virtual CaseClause BuildCaseClause(object startExpression, object endExpression);
    [ObsoleteAttribute("Use AddInParam instead.")]
[EditorBrowsableAttribute("1")]
public Param AddInnerParam(Set parent, string paramType, string name);
    [ObsoleteAttribute("Use AddInParam instead.")]
[EditorBrowsableAttribute("1")]
public Param AddInnerParam(MemberWithParameters parent, string paramType, string name);
    public Param AddInParam(Set parent, string paramType, string name);
    public Param AddInParam(MemberWithParameters parent, string paramType, string name);
    public Param AddRefParam(MemberWithParameters parent, string paramType, string name);
    public Param AddOutParam(MemberWithParameters parent, string paramType, string name);
    public Param AddParamArray(MemberWithParameters parent, string paramType, string name);
    public virtual ExtensionMethodParam AddExtensionMethodParam(MemberWithParameters parent, string paramType, string paramName);
    public virtual ExtensionMethodParam BuildExtensionMethodParam(string paramType, string paramName);
    public virtual AttributeVariableInitializer AddAttributeVariableInitializer(MethodCall parent, object leftSide, object rightSide);
    public virtual AttributeVariableInitializer BuildAttributeVariableInitializer(object leftSide, object rightSide);
    public virtual Expression AddMethodArgument(MethodCall parent, object argument);
    public virtual ArgumentDirectionExpression BuildArgumentDirectionExpression();
    public virtual ArgumentDirectionExpression BuildArgumentDirectionExpression(ArgumentDirection direction, Expression expression);
    public Property AddProperty(LanguageElement parent, string memberType, string name);
    public Property AddProperty(LanguageElement parent, string memberType, string name, Get getter, Set setter);
    public Method AddMethod(LanguageElement parent, string memberType, string name);
    public Method AddConstructor(TypeDeclaration parent);
    public Method AddDestructor(TypeDeclaration parent);
    public ConstructorInitializer AddThisConstructorInitializer(Method parent, ExpressionCollection arguments);
    public ConstructorInitializer AddBaseConstructorInitializer(Method parent);
    public ConstructorInitializer AddBaseConstructorInitializer(Method parent, ExpressionCollection arguments);
    public ConstructorInitializer AddExpressionConstructorInitializer(Method parent, Expression expr, ExpressionCollection arguments);
    public Get AddGetter(Property parent);
    public Set AddSetter(Property parent);
    public virtual EnumElement AddEnumElement(LanguageElement parent);
    public virtual EnumElement AddEnumElement(LanguageElement parent, string name);
    public virtual EnumElement AddEnumElement(LanguageElement parent, string name, object valueExpression);
    public virtual EnumElement BuildEnumElement();
    public virtual EnumElement BuildEnumElement(string name);
    public virtual EnumElement BuildEnumElement(string name, object valueExpression);
    public virtual Event AddEvent(LanguageElement parent);
    public virtual Event AddEvent(LanguageElement parent, string name);
    public virtual Event AddEvent(LanguageElement parent, string eventName, string eventType);
    public virtual Event AddEvent(LanguageElement parent, string eventName, TypeReferenceExpression eventType);
    public virtual Event BuildEvent();
    public virtual Event BuildEvent(string name);
    public virtual Event BuildEvent(string eventName, string eventType);
    public virtual Event BuildEvent(string eventName, TypeReferenceExpression eventType);
    public virtual EventAdd AddEventAdd(LanguageElement parent);
    public virtual EventAdd BuildEventAdd();
    public virtual EventRemove AddEventRemove(LanguageElement parent);
    public virtual EventRemove BuildEventRemove();
    public virtual RaiseEvent AddRaiseEvent(LanguageElement parent);
    public virtual RaiseEvent AddRaiseEvent(LanguageElement parent, object expression);
    public virtual RaiseEvent BuildRaiseEvent();
    public virtual RaiseEvent BuildRaiseEvent(object expression);
    public virtual AddHandler AddAddHandler(LanguageElement parent);
    public virtual AddHandler AddAddHandler(LanguageElement parent, object expression, object address);
    public virtual AddHandler BuildAddHandler();
    public virtual AddHandler BuildAddHandler(object expression, object address);
    public virtual RemoveHandler AddRemoveHandler(LanguageElement parent);
    public virtual RemoveHandler AddRemoveHandler(LanguageElement parent, object expression, object address);
    public virtual RemoveHandler BuildRemoveHandler();
    public virtual RemoveHandler BuildRemoveHandler(object expression, object address);
    public AttributeSection AddAttributeSection(CodeElement target);
    public Attribute AddAttribute(AttributeSection parent, string name);
    public Attribute AddAttribute(AttributeSection parent, object qualifier, string name);
    public Expression AddArgument(Attribute parent, Expression arg);
    public SnippetCodeElement AddSnippetCodeElement(LanguageElement parent, string code);
    public virtual Comment AddComment(CodeElement parent, string text, CommentType commentType);
    public virtual XmlDocComment AddXmlDocComment(CodeElement parent, string text);
    public virtual XmlDocComment BuildXmlDocComment(string text);
    public virtual ElementReferenceExpression BuildQualifiedElementReference(object source, string name);
    public virtual ElementReferenceExpression BuildMemberAccessReference(object source, string name, MemberAccesOperatorType operatorType);
    public virtual TypeReferenceExpression BuildTypeReference(object source, string name);
    public virtual TypeReferenceExpression BuildTypeReference(string name);
    public virtual TypeReferenceExpression BuildTypeReference(string name, bool useSimpleTypeName);
    public virtual TypeReferenceExpression BuildTypeReference(TypeReferenceType type, TypeReferenceExpression baseType);
    public virtual TypeReferenceExpression BuildTypeReference(TypeReferenceExpression type, int rank);
    public virtual ElementReferenceExpression BuildElementReference(string identifier);
    public virtual MethodReferenceExpression BuildMethodReference(string name);
    public virtual MethodReferenceExpression BuildMethodReference(Expression source, string name);
    public virtual AddressOfExpression BuildAddressOfExpression();
    public virtual AddressOfExpression BuildAddressOfExpression(object expression);
    public virtual PrimitiveExpression BuildPrimitive(string primitiveValue);
    public virtual PrimitiveExpression BuildPrimitiveFromObject(object primitiveValue);
    public virtual SnippetExpression BuildSnippetExpression(string code);
    public virtual SnippetCodeStatement BuildSnippetStatement(string code);
    public virtual SnippetCodeStatement BuildSnippetStatement(string code, bool addStatementTerminator);
    public virtual SnippetCodeStatement BuildSnippetStatement(string code, bool addStatementTerminator, bool addBlock);
    public virtual BaseReferenceExpression BuildBaseReferenceExpression();
    public virtual ThisReferenceExpression BuildThisReferenceExpression();
    public virtual MyClassExpression BuildMyClassExpression();
    public virtual MethodCallExpression BuildMethodCallExpression(object source);
    public virtual MethodCallExpression BuildMethodCallExpression(object source, ExpressionCollection arguments);
    public virtual MethodCallExpression BuildMethodCallExpression(object source, String[] values);
    public virtual ObjectCreationExpression BuildObjectCreationExpression(string typeName, String[] arguments);
    public virtual ObjectCreationExpression BuildObjectCreationExpression(TypeReferenceExpression typeReference, String[] arguments);
    public virtual ObjectCreationExpression BuildObjectCreationExpression(string typeName, ExpressionCollection arguments);
    public virtual ObjectCreationExpression BuildObjectCreationExpression(TypeReferenceExpression typeReference, ExpressionCollection arguments);
    public virtual ObjectCreationExpression BuildManagedObjectCreationExpression(string typeName, String[] arguments);
    public virtual ObjectCreationExpression BuildManagedObjectCreationExpression(string typeName, ExpressionCollection arguments);
    public virtual AssignmentExpression BuildAssignmentExpression(object left, object right, AssignmentOperatorType operatorType);
    public virtual TypeCastExpression BuildTypeCast(object type, object expression);
    public virtual AccessSpecifiers BuildAccessSpecifiers(bool isVirtual, bool isOverride, bool isOverloads, bool isStatic);
    public virtual Assignment BuildAssignment(object identifier, object assignedValue, AssignmentOperatorType operatorType);
    public virtual Assignment BuildAssignment(object identifier, object assignedValue);
    public virtual AttributeSection BuildAttributeSection();
    public virtual Attribute BuildAttribute(string name);
    public virtual Attribute BuildAttribute(object qualifier, string name);
    public virtual Case BuildCase(object expression);
    public virtual Catch BuildCatch(string exceptionType, string exceptionVariable);
    public virtual Catch BuildCatch();
    public virtual Do BuildDo(object condition);
    public virtual Else BuildElse();
    public virtual ElseIf BuildElseIf(object expression);
    public virtual Finally BuildFinally();
    public virtual ForEach BuildForEach(string elementType, string elementVariable, object collection);
    public virtual For BuildFor(Expression endCondition);
    public virtual For BuildFor(string iteratorVar, Expression endCondition);
    public virtual If BuildIf(object expression);
    public virtual LogicalOperation BuildLogicalOperation(object leftSide, LogicalOperator logicalOperator, object rightSide);
    public virtual Method BuildMethod(string memberType, string name);
    public virtual Method BuildConstructor(string className);
    public virtual Method BuildDestructor(string className);
    public virtual ConstructorInitializer BuildThisConstructorInitializer(ExpressionCollection arguments);
    public virtual ConstructorInitializer BuildBaseConstructorInitializer();
    public virtual ConstructorInitializer BuildBaseConstructorInitializer(ExpressionCollection arguments);
    public virtual ConstructorInitializer BuildExpressionConstructorInitializer(Expression expr, ExpressionCollection arguments);
    public virtual ConstructorInitializer BuildConstructorInitializer(string name, ExpressionCollection arguments);
    public virtual MethodCall BuildMethodCall(string name);
    public virtual MethodCall BuildMethodCall(object source);
    public virtual MethodCall BuildMethodCall(string name, String[] arguments);
    public virtual MethodCall BuildMethodCall(string name, String[] arguments, object qualifier);
    public virtual MethodCall BuildMethodCall(string name, ExpressionCollection arguments);
    public virtual MethodCall BuildMethodCall(string name, ExpressionCollection arguments, object qualifier);
    public virtual MethodCall BuildBaseMethodCall(string name, ExpressionCollection arguments);
    public virtual MethodCall BuildThisMethodCall(string name, ExpressionCollection arguments);
    [ObsoleteAttribute("Use BuildInParam instead.")]
[EditorBrowsableAttribute("1")]
public virtual Param BuildInnerParam(string paramType, string name);
    public virtual Param BuildInParam(string paramType, string name);
    public virtual Param BuildRefParam(string paramType, string name);
    public virtual RelationalOperation BuildRelationalOperation(object leftSide, RelationalOperator relationalOperator, object rightSide);
    public virtual Param BuildOutParam(string paramType, string name);
    public virtual Param BuildParamArray(string paramType, string name);
    public virtual Param BuildParameter(string paramType, string name, ArgumentDirection direction);
    public virtual Property BuildProperty(string memberType, string name);
    public virtual Property BuildProperty(string memberType, string name, Get getter, Set setter);
    public virtual Get BuildGetter();
    public virtual Set BuildSetter();
    public Switch BuildSelect(object expression);
    public SnippetCodeElement BuildSnippetCodeElement(string code);
    public virtual Switch BuildSwitch(object expression);
    public virtual Try BuildTry();
    public virtual Throw BuildThrow(Expression expression);
    public virtual Throw BuildThrow(object expression);
    public virtual Comment BuildComment(string text, CommentType commentType);
    protected virtual Comment BuildComment(string text, int startPos, int endPos, CommentType commentType);
    protected virtual Comment BuildComment(string text, int startPos, int endPos, CommentType commentType, int textStartOffset);
    public virtual Variable BuildVariable(string variableType, string variableName);
    public virtual Variable BuildVariable(TypeReferenceExpression variableType, string variableName);
    public virtual InitializedVariable BuildInitializedVariable(string variableType, string variableName, object initialValue);
    public virtual InitializedVariable BuildInitializedVariable(TypeReferenceExpression variableType, string variableName, Expression value);
    public virtual ImplicitVariable BuildImplicitVariable(string variableName, object initialValue);
    public virtual ImplicitVariable BuildImplicitVariable(string variableName, Expression value);
    public virtual While BuildWhile(object condition);
    public virtual LanguageElement BuildStatement(object statement);
    public NodeList get_TopLevelElements();
}
public static class DevExpress.CodeParser.ElementBuilderFactory : object {
    private static ParserLanguageID FromString(string language);
    public static ElementBuilder CreateElementBuilder(ParserLanguageID languageID);
    public static ElementBuilder CreateElementBuilder(string language);
    public static ElementBuilder CreateElementBuilder();
}
public class DevExpress.CodeParser.ElementCloneOptions : object {
    private bool _CloneUpToMembers;
    private bool _KeepAccessSpecifierTemplate;
    private bool _PerformParseBeforeClone;
    private bool _CloneNodes;
    private bool _CloneRegions;
    private SourceFile _SourceFile;
    private int _CloneChildrenCount;
    private Dictionary`2<LanguageElement, LanguageElement> _ClonedElements;
    private ITypeReferenceExpression _TypeReferencePrototype;
    internal bool CloningChildren { get; }
    public static ElementCloneOptions Default { get; }
    public bool CloneNodes { get; public set; }
    public bool CloneRegions { get; public set; }
    public bool CloneUpToMembers { get; public set; }
    public bool KeepAccessSpecifierTemplate { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use KeepAccessSpecifierTemplate")]
public bool KeepAsseccSpecifierTemplate { get; public set; }
    public bool PerformParseBeforeClone { get; public set; }
    public ITypeReferenceExpression TypeReferencePrototype { get; public set; }
    public SourceFile SourceFile { get; public set; }
    internal void AddClonedElement(LanguageElement sourceElement, LanguageElement clonedElement);
    internal LanguageElement GetClonedElement(LanguageElement sourceElement);
    internal bool BeginChildrenCloning();
    internal bool EndChildrenCloning();
    public virtual bool NeedToCloneNodes(BaseElement element);
    public void ResetToDefaults();
    internal bool get_CloningChildren();
    public static ElementCloneOptions get_Default();
    public bool get_CloneNodes();
    public void set_CloneNodes(bool value);
    public bool get_CloneRegions();
    public void set_CloneRegions(bool value);
    public bool get_CloneUpToMembers();
    public void set_CloneUpToMembers(bool value);
    public bool get_KeepAccessSpecifierTemplate();
    public void set_KeepAccessSpecifierTemplate(bool value);
    public bool get_KeepAsseccSpecifierTemplate();
    public void set_KeepAsseccSpecifierTemplate(bool value);
    public bool get_PerformParseBeforeClone();
    public void set_PerformParseBeforeClone(bool value);
    public ITypeReferenceExpression get_TypeReferencePrototype();
    public void set_TypeReferencePrototype(ITypeReferenceExpression value);
    public SourceFile get_SourceFile();
    public void set_SourceFile(SourceFile value);
}
public abstract class DevExpress.CodeParser.ElementCodeGenStyle : object {
    public LanguageElementType ElementType { get; }
    public abstract virtual LanguageElementType get_ElementType();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.ElementCodeGenStyleCollection : CollectionBase {
    public ElementCodeGenStyle Item { get; public set; }
    public int Add(ElementCodeGenStyle style);
    public void AddRange(ElementCodeGenStyleCollection styles);
    public void Remove(ElementCodeGenStyle style);
    public void Insert(int index, ElementCodeGenStyle style);
    public int IndexOf(ElementCodeGenStyle style);
    public ElementCodeGenStyle get_Item(int index);
    public void set_Item(int index, ElementCodeGenStyle value);
}
public class DevExpress.CodeParser.ElementCollector : object {
    private static ElementCollectorFlags DirectChildren { get; }
    private static ElementCollectorFlags AllChildren { get; }
    private static ElementCollectorFlags AllChildrenWithScopeCheck { get; }
    private static ElementCollectorFlags get_DirectChildren();
    private static ElementCollectorFlags get_AllChildren();
    private static ElementCollectorFlags get_AllChildrenWithScopeCheck();
    private static bool IsDefined(ElementCollectorFlags flags, ElementCollectorFlags value);
    private static void Collect(IElementCollection collector, IElement scope, IElementFilter filter);
    public static IElementCollection Collect(IElement scope, IElementFilter filter);
    public static IElementCollection CollectDirectChildren(IElement scope, IElementFilter filter);
    public static IElementCollection CollectDirectChildren(IElementCollection scopeList, IElementFilter filter);
    public static IElementCollection CollectAllChildren(IElement scope, IElementFilter filter);
    public static IElementCollection CollectElements(IElementCollection list, IElementFilter filter);
    public static void CollectElements(IElementCollection list, IElementCollection nodes, IElementFilter filter, ElementCollectorFlags flags);
    public static void CollectElements(IElementCollection list, IElement scope, IElementFilter filter, ElementCollectorFlags flags);
    public static IElementCollection Filter(ICollection list, IElementFilter filter);
}
[FlagsAttribute]
public enum DevExpress.CodeParser.ElementCollectorFlags : Enum {
    public int value__;
    public static ElementCollectorFlags Recursive;
    public static ElementCollectorFlags CheckRootNode;
    public static ElementCollectorFlags IterateChildren;
}
public class DevExpress.CodeParser.ElementEnumerable : object {
    private LanguageElement _Scope;
    private IElementFilter _Filter;
    private bool _UseRecursion;
    private bool _SkipScope;
    public IElementFilter Filter { get; }
    public bool UseRecursion { get; }
    public bool SkipScope { get; public set; }
    public ElementEnumerable(LanguageElement scope);
    public ElementEnumerable(LanguageElement scope, bool useRecursion);
    public ElementEnumerable(LanguageElement scope, IElementFilter filter);
    public ElementEnumerable(LanguageElement scope, IElementFilter filter, bool useRecursion);
    public ElementEnumerable(LanguageElement scope, LanguageElementType filterType);
    public ElementEnumerable(LanguageElement scope, LanguageElementType filterType, bool useRecursion);
    public ElementEnumerable(LanguageElement scope, LanguageElementType[] filterTypes);
    public ElementEnumerable(LanguageElement scope, LanguageElementType[] filterTypes, bool useRecursion);
    public ElementEnumerable(LanguageElement scope, Type filterType);
    public ElementEnumerable(LanguageElement scope, Type filterType, bool useRecursion);
    public ElementEnumerable(LanguageElement scope, Type[] filterTypes);
    public ElementEnumerable(LanguageElement scope, Type[] filterTypes, bool useRecursion);
    private IElementFilter GetFilter(LanguageElementType filterType);
    private IElementFilter GetFilter(LanguageElementType[] filterTypes);
    private IElementFilter GetFilter(Type filterType);
    private IElementFilter GetFilter(Type[] filterTypes);
    public sealed virtual IEnumerator GetEnumerator();
    public IElementFilter get_Filter();
    public bool get_UseRecursion();
    public bool get_SkipScope();
    public void set_SkipScope(bool value);
}
public class DevExpress.CodeParser.ElementFactoryBase : object {
    public virtual Attribute NewAttribute();
    public virtual AttributeSection NewAttributeSection();
    public virtual MethodCall NewMethodCall();
    public virtual ConstructorInitializer NewConstructorInitializer();
    public virtual Param NewParam();
    public virtual CaseClause NewCaseClause();
    public virtual CaseClausesList NewCaseClausesList();
}
public abstract class DevExpress.CodeParser.ElementFilterBase : object {
    public abstract virtual bool Apply(IElement element);
    public virtual IElementCollection Apply(IElementCollection elements);
    public virtual bool SkipChildren(IElement element);
}
public class DevExpress.CodeParser.ElementFilters : object {
    public static TypeDeclarationFilter Type;
    public static NamespaceFilter Namespace;
    public static TypeOrNamespaceFilter TypeOrNamespace;
    public static NonPrivateMemberFilter NonPrivateMember;
    public static MemberFilter Member;
    public static MethodFilter Method;
    public static PropertyFilter Property;
    public static EventFilter Event;
    public static ConstructorFilter Constructor;
    public static DestructorFilter Destructor;
    public static FieldFilter Field;
    public static LocalFilter Local;
    public static PublicParameterLessMethodFilter PublicParameterLessMethod;
    private static ElementFilters();
    public static bool IsVoidTypeRef(ITypeReferenceExpression type);
    public static bool IsVoidType(ITypeElement type);
    public static bool IsType(IElement element);
    public static bool IsNamespace(IElement element);
    public static bool IsTypeOrNamespace(IElement element);
    public static bool IsNonPrivateMember(IElement element);
    public static bool IsMember(IElement element);
    public static bool IsExternMember(IElement element);
    public static bool IsMethod(IElement element);
    public static bool IsProperty(IElement element);
    public static bool IsEvent(IElement element);
    public static bool IsConstructor(IElement element);
    public static bool IsField(IElement element);
    public static bool IsLocal(IElement element);
    public static bool IsPublicParameterLessMethod(IElement element);
}
public class DevExpress.CodeParser.ElementList : LanguageElement {
    public LanguageElementType ElementType { get; }
    public ElementList(LanguageElementCollection list);
    public ElementList(NodeList list);
    public ElementList(NodeList list, bool setParent);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
internal class DevExpress.CodeParser.ElementLocation : object {
    private static bool IsEmptyDocText(LanguageElement element);
    private static int GetClearElementIndex(LanguageElement element);
    private static XmlNode CreateXmlNode(XmlDocument doc, string name, bool isDetailNode, int index, string signature);
    private static XmlNode CreateXmlNodeForFile(XmlDocument doc, SourceFile file);
    private static bool CanBeMoved(LanguageElement element);
    private static XmlNode GetXmlNodeForElement(XmlDocument doc, string nodeName, LanguageElement element);
    private static XmlNode CreateXmlNodeForCurrent(XmlDocument doc, PathPart part);
    private static void CollectParents(ArrayList parents, LanguageElement element);
    private static void BuildLocation(XmlDocument doc, LanguageElement element);
    private static bool IsTarget(XmlNode xmlNode);
    private static bool IsFile(XmlNode xmlNode);
    private static SourceFile LocateFile(IProjectElement proj, XmlNode xmlNode);
    private static LanguageElement FindElementByClearIndex(NodeList nodes, int index);
    private static bool CompareSignature(LanguageElement element, string signature);
    private static LanguageElement LocateElementBySignature(NodeList nodes, string signature);
    private static LanguageElement LocateElement(NodeList nodes, XmlNode xmlNode);
    private static bool IsElementNode(XmlNode xmlNode);
    private static LanguageElement LocateElement(LanguageElement context, XmlNode xmlNode);
    private static LanguageElement LocateElementForTarget(LanguageElement context, XmlNode xmlNode);
    private static LanguageElement RestoreElementRecursively(LanguageElement context, XmlNode xmlContext);
    private static LanguageElement RestoreElement(IProjectElement proj, XmlNode xmlContext);
    private static LanguageElement RestoreElement(SourceFile file, XmlNode xmlContext);
    public static string GetFileLocation(LanguageElement element);
}
public class DevExpress.CodeParser.ElementRangeFilter : ElementFilterBase {
    private SourceRange _Range;
    public ElementRangeFilter(SourceRange range);
    public virtual bool Apply(IElement element);
}
public class DevExpress.CodeParser.ElementRangeHelper : object {
    public static BlockElements DefaultBlockElements;
    private static bool IsOptionSet(BlockElements target, BlockElements option);
    private static bool CanIncludeNode(LanguageElement node, BlockElements blockElements);
    private static bool ContainsOtherCode(LanguageElement element, RegionDirective directive);
    private static bool CheckOtherCodeInRegions(RegionDirective nodeRegion, RegionDirective region, LanguageElement current);
    private static bool BreaksRegions(LanguageElement node, LanguageElement current, BlockElements blockElements);
    private static bool BreaksRegions(LanguageElement node, LanguageElement current, BlockElements blockElements, RegionDirective currentRegion, RegionDirective nodeRegion);
    private static LanguageElement ExpandToDeclarationListStart(LanguageElement node);
    private static LanguageElement ExpandToDeclarationListEnd(LanguageElement node);
    private static bool HasDirectivesBetweenNodes(LanguageElement start, LanguageElement end);
    private static LanguageElement ExpandStartNode(LanguageElement node, BlockElements blockElements, bool includeComplitingElements, LanguageElement& target);
    private static bool HasBadRegionBetweenNodes(LanguageElement currentElement, BlockElements blockElements);
    private static LanguageElement ExpandEndNode(LanguageElement node, BlockElements blockElements, bool includeComplitingElements, LanguageElement& target);
    private static SourceRange GetFullBlockRange(IDocument document, LanguageElement startNode, LanguageElement endNode, BlockElements blockElements);
    private static LanguageElement GetNext(LanguageElement startNode, LanguageElement target);
    private static LanguageElement GetPrevious(LanguageElement startNode, LanguageElement target);
    private static void IncludeRegion(BlockElements blockElements, LanguageElement region, LanguageElement previous, LanguageElement next, LanguageElement& node);
    private static bool IsAttachedToTarget(LanguageElement node, LanguageElement target);
    private static BlockElements ToBlockElements(LanguageElement node);
    public static void GetFullBlockNodes(LanguageElement element, LanguageElement& startNode, LanguageElement& endNode);
    public static void GetFullBlockNodes(LanguageElement element, BlockElements blockElements, LanguageElement& startNode, LanguageElement& endNode);
    [EditorBrowsableAttribute("1")]
public static void GetFullBlockNodes(LanguageElement element, BlockElements blockElements, bool includeComplitingElements, LanguageElement& startNode, LanguageElement& endNode);
    private static bool IsValidRegion(LanguageElement element, RegionDirective startRegion, BlockElements blockElements);
    private static bool MatchName(string elementName, string startRegionName);
    public static SourceRange GetFullBlockRange(LanguageElement element);
    public static SourceRange GetFullBlockRange(LanguageElement element, BlockElements blockElements);
}
public class DevExpress.CodeParser.ElementReferenceExpression : ReferenceExpressionBase {
    private static int INT_MaintainanceComplexity;
    private TextRange _NameRange;
    private bool _IsModified;
    private bool _IsKey;
    protected int ThisMaintenanceComplexity { get; }
    public bool NeedsInvertParens { get; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; public set; }
    [EditorBrowsableAttribute("1")]
public Expression Qualifier { get; public set; }
    public bool HasCleanReferences { get; }
    public bool IsModified { get; public set; }
    public bool IsKey { get; public set; }
    public bool IsUsed { get; }
    private bool DevExpress.CodeParser.IElementReferenceExpression.IsModified { get; }
    public ElementReferenceExpression(string name);
    public ElementReferenceExpression(string name, SourceRange range);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual bool get_NeedsInvertParens();
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public virtual Expression get_Qualifier();
    public virtual void set_Qualifier(Expression value);
    public virtual bool get_HasCleanReferences();
    public bool get_IsModified();
    public void set_IsModified(bool value);
    public bool get_IsKey();
    public void set_IsKey(bool value);
    public bool get_IsUsed();
    private sealed virtual override bool DevExpress.CodeParser.IElementReferenceExpression.get_IsModified();
}
public class DevExpress.CodeParser.ElementsGenerationRules : object {
    private bool _WrapFirst;
    private bool _WrapParams;
    private bool _AlignIfWrap;
    private bool _Indenting;
    private string _StringDelimiter;
    private FormattingTokenType _Delimiter;
    public bool WrapFirst { get; public set; }
    public bool WrapParams { get; public set; }
    public bool AlignIfWrap { get; public set; }
    public bool Indenting { get; public set; }
    public FormattingTokenType Delimiter { get; public set; }
    public string StringDelimiter { get; public set; }
    public bool HasStringDelimiter { get; }
    public bool get_WrapFirst();
    public void set_WrapFirst(bool value);
    public bool get_WrapParams();
    public void set_WrapParams(bool value);
    public bool get_AlignIfWrap();
    public void set_AlignIfWrap(bool value);
    public bool get_Indenting();
    public void set_Indenting(bool value);
    public FormattingTokenType get_Delimiter();
    public void set_Delimiter(FormattingTokenType value);
    public string get_StringDelimiter();
    public void set_StringDelimiter(string value);
    public bool get_HasStringDelimiter();
}
public class DevExpress.CodeParser.ElementTypeFilter : ElementFilterBase {
    private LanguageElementType[] _Types;
    private Type[] _ObjectTypes;
    public ElementTypeFilter(LanguageElementType type);
    public ElementTypeFilter(LanguageElementType[] types);
    public ElementTypeFilter(Type type);
    public ElementTypeFilter(Type[] types);
    private bool FilterByElementType(IElement element);
    private bool FilterByObjectType(IElement element);
    public virtual bool Apply(IElement element);
}
public class DevExpress.CodeParser.ElifDirective : CompilerDirective {
    private string _Expression;
    private bool _ExpressionValue;
    public LanguageElementType ElementType { get; }
    public string Expression { get; public set; }
    public bool ExpressionValue { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Expression();
    public void set_Expression(string value);
    public bool get_ExpressionValue();
    public void set_ExpressionValue(bool value);
}
public class DevExpress.CodeParser.Else : IfElse {
    private static int INT_MaintainanceComplexity;
    public LanguageElementType ElementType { get; }
    public bool AcceptsElse { get; }
    protected int ThisMaintenanceComplexity { get; }
    public bool CompletesPrevious { get; }
    public virtual int GetCyclomaticComplexity();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_AcceptsElse();
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual bool get_CompletesPrevious();
}
public class DevExpress.CodeParser.ElseDirective : CompilerDirective {
    private bool _IsSatisfied;
    public LanguageElementType ElementType { get; }
    public bool IsSatisfied { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public bool get_IsSatisfied();
    public void set_IsSatisfied(bool value);
}
public class DevExpress.CodeParser.ElseIf : If {
    public LanguageElementType ElementType { get; }
    public bool CompletesPrevious { get; }
    public ElseIf(Expression expression, LanguageElementCollection block);
    public ElseIf(Expression expression, LanguageElementCollection block, SourceRange range);
    private void SetContextBlockEnd(Token token);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_CompletesPrevious();
}
public abstract class DevExpress.CodeParser.EmbeddedCodeParserBase : TokenCategorizedParserBase {
    private DotNetLanguageType _InitialDefaultDotNetLanguage;
    public DotNetLanguageType InitialDefaultDotNetLanguage { get; public set; }
    public void set_InitialDefaultDotNetLanguage(DotNetLanguageType value);
    public DotNetLanguageType get_InitialDefaultDotNetLanguage();
}
public enum DevExpress.CodeParser.EmbededLanguageKind : Enum {
    public int value__;
    public static EmbededLanguageKind Unknown;
    public static EmbededLanguageKind Asp;
    public static EmbededLanguageKind Razor;
}
public class DevExpress.CodeParser.EmptyArgumentExpression : Expression {
    public LanguageElementType ElementType { get; }
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.EmptyArrayElementExpression : Expression {
    private int _EmptyElementsCount;
    public LanguageElementType ElementType { get; }
    public int EmptyElementsCount { get; public set; }
    public EmptyArrayElementExpression(int emptyElementsCount);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual LanguageElementType get_ElementType();
    public int get_EmptyElementsCount();
    public void set_EmptyElementsCount(int value);
}
[ObsoleteAttribute("Use EmptyCommaDelimiter instead.")]
public class DevExpress.CodeParser.EmptyCommaDelimeter : EmptyCommaDelimiter {
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public class DevExpress.CodeParser.EmptyCommaDelimiter : LanguageElement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
[DefaultMemberAttribute("Item")]
internal class DevExpress.CodeParser.EmptyIElementCollection : IElementCollection {
    public IElement Item { get; public set; }
    public virtual int Add(IElement element);
    public virtual void Insert(int index, IElement element);
    public virtual void Remove(IElement element);
    public IElement get_Item(int index);
    public void set_Item(int index, IElement value);
}
public class DevExpress.CodeParser.EmptyLiteElements : object {
    public static IElementCollection EmptyIElementCollection;
    public static LiteTypeElementCollection EmptyITypeElementCollection;
    public static LiteNamespaceElementCollection EmptyINamespaceElementCollection;
    public static LiteExpressionCollection EmptyIExpressionCollection;
    public static LiteTypeReferenceExpressionCollection EmptyITypeReferenceExpressionCollection;
    public static LiteMemberElementCollection EmptyIMemberElementCollection;
    public static LiteTypeParameterCollection EmptyITypeParameterCollection;
    public static LiteVariableDeclarationStatementCollection EmptyIVariableDeclarationStatementCollection;
    public static LiteCaseClauseCollection EmptyICaseClauseCollection;
    public static LiteCaseStatementCollection EmptyICaseStatementCollection;
    public static LiteParameterElementCollection EmptyIParameterElementCollection;
    public static LiteAttributeElementCollection EmptyIAttributeElementCollection;
    public static LiteTypeParameterConstraintCollection EmptyITypeParameterConstraintCollection;
    public static LiteSourceFileCollection EmptyISourceFileCollection;
    public static LiteProjectElementCollection EmptyIProjectElementCollection;
    public static LiteQueryIdentCollection EmptyIQueryIndentCollection;
    public static LiteJoinExpressionCollection EmptyIJoinExpressionCollection;
    public static LiteXmlAttributeDeclarationCollection EmptyIXmlAttributeDeclarationCollection;
    public static LiteHtmlAttributeCollection EmptyIHtmlAttributeCollection;
    public static LiteXmlContentParticleCollection EmptyIXmlContentParticleCollection;
    public static TextRangeCollection EmptyTextRangeCollection;
    public static Int32[] EmptyIntArray;
    private static EmptyLiteElements();
}
[DefaultMemberAttribute("Item")]
[EditorBrowsableAttribute("1")]
internal class DevExpress.CodeParser.EmptyNodeList : NodeList {
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    private void ThrowException();
    public virtual int Add(object value);
    public virtual void AddRange(ICollection range);
    public virtual void RemoveAt(int index);
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, IList value);
    public virtual void Remove(object value);
    public virtual void Replace(object oldObject, object newObject);
    public virtual bool get_IsReadOnly();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
}
public class DevExpress.CodeParser.EmptyParens : LanguageElement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.EmptyStatement : Statement {
    public LanguageElementType ElementType { get; }
    public bool CanContainCode { get; }
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_CanContainCode();
}
public class DevExpress.CodeParser.EmptyStructuralParserServices : object {
    public ISourceTreeResolver SourceTreeResolver { get; }
    public IFormattingService FormattingService { get; }
    public ISolutionElement ActiveSolution { get; }
    public sealed virtual ILogger GetLogger();
    public sealed virtual string GetXMLTagName();
    public sealed virtual ArrayList FindAllReferencesForBaseVariable(BaseVariable variable);
    public sealed virtual bool IsKeyword(string name);
    public sealed virtual bool IsKeyword(IReferenceExpression reference);
    public sealed virtual bool IsKeywordElement(IElement element);
    public sealed virtual Expression BuildQueryTranslation(QueryExpression queryExpression);
    public sealed virtual string GetEscapedString(string projectLanguage, string name, bool isVerbatim);
    public sealed virtual Expression Invert(Expression expression);
    public sealed virtual LanguageElementCollection GetUnusedDeclarations(IEnumerable allVariables);
    public sealed virtual IElement FindElementByFullName(IElementCollection iElementCollection, string fullName, bool caseSensitive);
    public sealed virtual ITypeElement[] GetAllDescendants(ITypeElement typeElement);
    public sealed virtual ITypeElement[] GetAllDescendants(ITypeElement typeElement, IElement scope);
    public sealed virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver, ITypeElement typeElement);
    public sealed virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver, ITypeElement typeElement, IElement scope);
    public sealed virtual ITypeElement[] GetDescendants(ITypeElement typeElement);
    public sealed virtual ITypeElement[] GetDescendants(ITypeElement typeElement, IElement scope);
    public sealed virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver, ITypeElement typeElement);
    public sealed virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver, ITypeElement typeElement, IElement scope);
    public sealed virtual string GetSignaturePart(IElement element);
    public sealed virtual string ReplaceAccessOperators(string fullName);
    public sealed virtual TypeReferenceExpression GetMethodType(AnonymousMethodExpression anonymousMethod);
    public sealed virtual string GetOverrideCode(IMemberElement member, bool callBase, string codeBefore, string codeAfter);
    public sealed virtual string GenerateElement(LanguageElement element);
    public sealed virtual string GenerateElement(LanguageElement element, int precedingWhiteSpaceCount);
    public sealed virtual string GenerateElement(LanguageElement element, string languageID, int precedingWhiteSpaceCount);
    public sealed virtual bool IsBuiltInType(string typeName);
    public sealed virtual string GetSimpleTypeName(string typeName);
    public sealed virtual string GetComment(string text, string languageID);
    public sealed virtual bool IdentifiersMatch(string first, string second);
    public sealed virtual string ExtractFirstIdentifier(String& remainingIdentifiers);
    public sealed virtual bool IsCollapsible(LanguageElement element);
    public sealed virtual SourceRange GetCollapsibleRange(LanguageElement element);
    public sealed virtual bool DescendsFrom(ITypeElement type, string fullTypeName);
    public sealed virtual bool DescendsFrom(ISourceTreeResolver resolver, ITypeElement type, string fullTypeName);
    public sealed virtual Expression Simplify(Expression expression);
    public sealed virtual Expression Simplify(Expression expression, bool considerMethodCalls);
    public sealed virtual IElement FindElementInSnapshotStructure(IElement declaration);
    public sealed virtual bool InMacroCall(LanguageElement element);
    public sealed virtual IElement GetDeclaration(IElement element);
    public sealed virtual IElement GetDeclaration(IElement element, bool restore);
    public sealed virtual IElementCollection FindAllReferences(IElement element);
    public sealed virtual IElementCollection FindAllReferences(IElement scope, IElement element);
    public sealed virtual IAssemblyModel GetAssemblyModel(LanguageElement element);
    public sealed virtual bool IsEventHandler(IMethodElement element);
    public sealed virtual bool IsMainProcedure(Method method);
    public sealed virtual bool IsSerializationConstructor(IMethodElement method);
    public sealed virtual bool IsInitializeComponent(IMethodElement method);
    public sealed virtual bool IsInteriorPtrPointer(TypeReferenceExpression type);
    public sealed virtual IElementFilter GetMemberSignatureFilter(Method method);
    public sealed virtual ITypeElement[] GetAllBaseTypes(ITypeElement element);
    public sealed virtual bool IsWebMethod(Method method);
    public sealed virtual bool CheckExtensionMethod(IMethodElement method);
    public sealed virtual bool CheckExtensionMethod(ISourceTreeResolver resolver, IMethodElement method);
    public sealed virtual bool HasDllImportAttribute(IMethodElement method);
    public sealed virtual bool DeclarationsMatch(ISourceTreeResolver resolver, IElement first, IElement second);
    public sealed virtual bool IsIdenticalTo(IElement first, IElement second);
    public sealed virtual ITypeReferenceExpression GetInnerType(TypeReferenceExpression typeReferenceExpression);
    public sealed virtual bool UsesTypeParameters(TypeReferenceExpression typeReferenceExpression, IGenericElement generic);
    public sealed virtual bool IsTypeParameter(TypeReferenceExpression typeReferenceExpression, IGenericElement generic);
    public sealed virtual IMemberElement FindMember(ITypeElement type, string name, IElementFilter filter, bool searchInAncestors);
    public sealed virtual IMemberElementCollection FindMembers(ITypeElement type, string name, IElementFilter filter, bool searchInAncestors);
    public sealed virtual IMemberElementCollection FindMembers(ISourceTreeResolver resolver, ITypeElement type, string name, IElementFilter filter, bool searchInAncestors);
    public sealed virtual SourceFileBuildAction GetBuildAction(SourceFile sourceFile);
    public sealed virtual ParserBase GetParserFromLanguageID(string language);
    public sealed virtual IBraceSettings LoadBraceSettings();
    public sealed virtual ITabSettings GetTabSettings(ParserLanguageID language);
    public sealed virtual ISourceTreeResolver get_SourceTreeResolver();
    public sealed virtual IFormattingService get_FormattingService();
    public sealed virtual ISolutionElement get_ActiveSolution();
}
public class DevExpress.CodeParser.EmptyVisibilityArray : object {
    public static MemberVisibility[] Value;
    private static EmptyVisibilityArray();
}
public class DevExpress.CodeParser.End : FlowBreak {
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    public virtual LanguageElement FindTarget();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.EndIfDirective : CompilerDirective {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.EndRegionDirective : PreprocessorDirective {
    private string _Comment;
    private string _Message;
    public bool CompletesPrevious { get; }
    public LanguageElementType ElementType { get; }
    public string Message { get; public set; }
    public string Comment { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool get_CompletesPrevious();
    public virtual LanguageElementType get_ElementType();
    public string get_Message();
    public void set_Message(string value);
    public string get_Comment();
    public void set_Comment(string value);
}
public class DevExpress.CodeParser.EnumElement : Member {
    private string _Value;
    private Expression _ValueExpression;
    private bool _HasComma;
    public bool HasComma { get; public set; }
    public string Value { get; }
    public Expression ValueExpression { get; }
    public bool VisibilityIsFixed { get; }
    public LanguageElementType ElementType { get; }
    private IExpression DevExpress.CodeParser.IEnumElement.ValueExpression { get; }
    public EnumElement(string name, int startLine, int startOffset);
    public EnumElement(string name);
    public EnumElement(string name, Expression valueExpression);
    private void SetValueExpression(Expression value);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public bool get_HasComma();
    public void set_HasComma(bool value);
    public string get_Value();
    public Expression get_ValueExpression();
    public virtual bool get_VisibilityIsFixed();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IExpression DevExpress.CodeParser.IEnumElement.get_ValueExpression();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
}
public class DevExpress.CodeParser.Enumeration : TypeDeclaration {
    private bool _IsEnumClass;
    private SourceRange _AsRange;
    private string _UnderlyingType;
    private SourceRange _UnderlyingTypeRange;
    public LanguageElementType ElementType { get; }
    public SourceRange AsRange { get; public set; }
    public string UnderlyingType { get; public set; }
    public SourceRange UnderlyingTypeRange { get; public set; }
    public bool IsEnumClass { get; public set; }
    public Enumeration(string name);
    protected virtual void SetDefaultUnderlyingType();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual int GetImageIndex();
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public SourceRange get_AsRange();
    public void set_AsRange(SourceRange value);
    public sealed virtual string get_UnderlyingType();
    public void set_UnderlyingType(string value);
    public SourceRange get_UnderlyingTypeRange();
    public void set_UnderlyingTypeRange(SourceRange value);
    public bool get_IsEnumClass();
    public void set_IsEnumClass(bool value);
}
public class DevExpress.CodeParser.EqualsExpression : BinaryOperatorExpression {
    public LanguageElementType ElementType { get; }
    public EqualsExpression(Expression left, Expression right);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual string ToString();
}
public class DevExpress.CodeParser.Erase : Statement {
    private ExpressionCollection _Expressions;
    public LanguageElementType ElementType { get; }
    public ExpressionCollection Expressions { get; }
    public Erase(ExpressionCollection expressions);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public ExpressionCollection get_Expressions();
}
public class DevExpress.CodeParser.Error : ValueType {
    private int _ErrorNum;
    private int _Col;
    private int _Line;
    public int ErrorNum { get; }
    public int Col { get; }
    public int Line { get; }
    public Error(int line, int col, int error);
    public int get_ErrorNum();
    public int get_Col();
    public int get_Line();
}
public class DevExpress.CodeParser.ErrorDirective : CompilerDirective {
    private string _Expression;
    public LanguageElementType ElementType { get; }
    public string Expression { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Expression();
    public void set_Expression(string value);
}
public class DevExpress.CodeParser.ErrorList : List`1<Error> {
}
public class DevExpress.CodeParser.Event : MemberWithParameters {
    private bool _IsInterfaceEvent;
    private Expression _Initializer;
    private bool _GenerateAccessors;
    public LanguageElementType ElementType { get; }
    public bool IsInterfaceEvent { get; public set; }
    [BrowsableAttribute("False")]
public bool GenerateAccessors { get; public set; }
    [DescriptionAttribute("Gets the Add accessor for this event, if declared.")]
[CategoryAttribute("Family")]
public EventAdd Adder { get; }
    [DescriptionAttribute("Gets the Remove accessor for this event, if declared.")]
[CategoryAttribute("Family")]
public EventRemove Remover { get; }
    [DescriptionAttribute("Gets the Raise accessor for this event, if declared.")]
[CategoryAttribute("Family")]
public EventRaise Raise { get; }
    public Expression Initializer { get; public set; }
    public IMethodElement AddMethod { get; public set; }
    public IMethodElement RemoveMethod { get; public set; }
    public IMethodElement RaiseMethod { get; public set; }
    private IExpression DevExpress.CodeParser.IEventElement.Initializer { get; }
    public IElementCollection ImplicitElements { get; }
    public Event(string name);
    private void SetInitializer(Expression initializer);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual MemberVisibility GetDefaultVisibility();
    public void ClearInitializer();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public bool get_IsInterfaceEvent();
    public void set_IsInterfaceEvent(bool value);
    public bool get_GenerateAccessors();
    public void set_GenerateAccessors(bool value);
    public EventAdd get_Adder();
    public EventRemove get_Remover();
    public EventRaise get_Raise();
    public Expression get_Initializer();
    public void set_Initializer(Expression value);
    public sealed virtual IMethodElement get_AddMethod();
    public void set_AddMethod(IMethodElement value);
    public sealed virtual IMethodElement get_RemoveMethod();
    public void set_RemoveMethod(IMethodElement value);
    public sealed virtual IMethodElement get_RaiseMethod();
    public void set_RaiseMethod(IMethodElement value);
    private sealed virtual override IExpression DevExpress.CodeParser.IEventElement.get_Initializer();
    public virtual IElementCollection get_ImplicitElements();
    private sealed virtual override void DevExpress.CodeParser.IEventElementModifier.SetAddMethod(IMethodElement method);
    private sealed virtual override void DevExpress.CodeParser.IEventElementModifier.SetRemoveMethod(IMethodElement method);
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
}
public abstract class DevExpress.CodeParser.EventAccessor : Accessor {
    private LanguageElementCollection _ParametersList;
    private LanguageElementCollection ParametersList { get; }
    public Event ParentEvent { get; }
    [DescriptionAttribute("The name of the event that contains this accessor.")]
[CategoryAttribute("Family")]
public string EventName { get; }
    public LanguageElementType ElementType { get; }
    public LanguageElementCollection Parameters { get; public set; }
    public int ParameterCount { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsAsynchronous { get; }
    private string DevExpress.CodeParser.IMethodElement.Lib { get; }
    private string DevExpress.CodeParser.IMethodElement.Alias { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsConstructor { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsSerializationConstructor { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsWebMethod { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsDestructor { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsTypeInitializer { get; }
    private MethodTypeEnum DevExpress.CodeParser.IMethodElement.MethodType { get; }
    private IBaseVariable DevExpress.CodeParser.IMethodElement.ImplicitVariable { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsMemberFunctionConst { get; }
    private IExpressionCollection DevExpress.CodeParser.IMethodElement.HandlesExpressions { get; }
    private IExpressionCollection DevExpress.CodeParser.IMethodElement.ImplementsExpressions { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsClassOperator { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsImplicitCast { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsExplicitCast { get; }
    private IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.Attributes { get; }
    private MemberVisibility DevExpress.CodeParser.IMemberElement.Visibility { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsDefaultVisibility { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsAbstract { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsIterator { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsVirtual { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsOverride { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsNew { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsPartial { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsStatic { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsSealed { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsExplicitInterfaceMember { get; }
    private IExpression DevExpress.CodeParser.IMemberElement.NameQualifier { get; }
    private string DevExpress.CodeParser.IMemberElement.Signature { get; }
    private IExpressionCollection DevExpress.CodeParser.IMemberElement.Implements { get; }
    private bool DevExpress.CodeParser.IGenericElement.IsGeneric { get; }
    private ITypeParameterCollection DevExpress.CodeParser.IGenericElement.TypeParameters { get; }
    private IGenericElement DevExpress.CodeParser.IGenericElement.GenericTemplate { get; }
    private bool DevExpress.CodeParser.IGenericElement.IsActivatedGeneric { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.IHasType.Type { get; }
    private IParameterElementCollection DevExpress.CodeParser.IWithParameters.Parameters { get; }
    private LanguageElementCollection get_ParametersList();
    protected virtual string GetAccessorName();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public void AddParameter(Param parameter);
    public void AddParameters(LanguageElementCollection parameters);
    public void RemoveParameter(Param parameter);
    public void RemoveParameters(LanguageElementCollection parameters);
    public void InsertParameter(int index, Param parameter);
    public Event get_ParentEvent();
    public string get_EventName();
    public virtual LanguageElementType get_ElementType();
    public sealed virtual LanguageElementCollection get_Parameters();
    public void set_Parameters(LanguageElementCollection value);
    public sealed virtual int get_ParameterCount();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsAsynchronous();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsExtensionMethod();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsExtensionMethod(ISourceTreeResolver resolver);
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsMainProcedure();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsInitializeComponent();
    private sealed virtual override string DevExpress.CodeParser.IMethodElement.get_Lib();
    private sealed virtual override string DevExpress.CodeParser.IMethodElement.get_Alias();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsConstructor();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsSerializationConstructor();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsWebMethod();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsDestructor();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsTypeInitializer();
    private sealed virtual override MethodTypeEnum DevExpress.CodeParser.IMethodElement.get_MethodType();
    private sealed virtual override IBaseVariable DevExpress.CodeParser.IMethodElement.get_ImplicitVariable();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsMemberFunctionConst();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMethodElement.get_HandlesExpressions();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMethodElement.get_ImplementsExpressions();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsClassOperator();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsImplicitCast();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsExplicitCast();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.GetOverrideCode();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.GetOverrideCode(bool callBase);
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.GetOverrideCode(bool callBase, string beforeCode, string afterCode);
    private sealed virtual override IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.get_Attributes();
    private sealed virtual override MemberVisibility DevExpress.CodeParser.IMemberElement.get_Visibility();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsDefaultVisibility();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsAbstract();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsIterator();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsVirtual();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsOverride();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsNew();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsPartial();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsStatic();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsSealed();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsExplicitInterfaceMember();
    private sealed virtual override IExpression DevExpress.CodeParser.IMemberElement.get_NameQualifier();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMemberElement.get_Implements();
    private sealed virtual override bool DevExpress.CodeParser.IGenericElement.get_IsGeneric();
    private sealed virtual override ITypeParameterCollection DevExpress.CodeParser.IGenericElement.get_TypeParameters();
    private sealed virtual override IGenericElement DevExpress.CodeParser.IGenericElement.get_GenericTemplate();
    private sealed virtual override bool DevExpress.CodeParser.IGenericElement.get_IsActivatedGeneric();
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.IHasType.get_Type();
    private sealed virtual override IParameterElementCollection DevExpress.CodeParser.IWithParameters.get_Parameters();
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.AddParameter(IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.RemoveParameter(IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.InsertParameter(int index, IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IGenericElementModifier.AddTypeParameter(ITypeParameter typeParameter);
    private sealed virtual override void DevExpress.CodeParser.IGenericElementModifier.InsertTypeParameter(int index, ITypeParameter typeParameter);
    private sealed virtual override void DevExpress.CodeParser.IGenericElementModifier.RemoveTypeParameter(ITypeParameter typeParameter);
    private sealed virtual override void DevExpress.CodeParser.IMethodElementModifier.SetIsClassOperator(bool isClassOperator);
    private sealed virtual override void DevExpress.CodeParser.IMethodElementModifier.SetIsExplicitCast(bool isExplicitCast);
    private sealed virtual override void DevExpress.CodeParser.IMethodElementModifier.SetIsImplicitCast(bool isImplicitCast);
}
public class DevExpress.CodeParser.EventAdd : EventAccessor {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.EventFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
}
public class DevExpress.CodeParser.EventRaise : EventAccessor {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.EventRemove : EventAccessor {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.Except : ParentingStatement {
    private Expression _ExceptionExpression;
    public Expression ExceptionExpression { get; public set; }
    public LanguageElementType ElementType { get; }
    public Except(Expression exceptionExpression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public Expression get_ExceptionExpression();
    public void set_ExceptionExpression(Expression value);
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public class DevExpress.CodeParser.Exit : Break {
    private ExitKind _ExitKind;
    public ExitKind ExitKind { get; public set; }
    public LanguageElementType ElementType { get; }
    public Exit(string exitKind, SourceRange range);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual ExitKind ResolveExitKind(string exitKind);
    public virtual string ToString();
    public virtual bool MatchesExitKind(LanguageElement target);
    public virtual LanguageElement FindTarget();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public ExitKind get_ExitKind();
    public void set_ExitKind(ExitKind value);
    public virtual LanguageElementType get_ElementType();
}
public enum DevExpress.CodeParser.ExitKind : Enum {
    public int value__;
    public static ExitKind Do;
    public static ExitKind For;
    public static ExitKind While;
    public static ExitKind Select;
    public static ExitKind Sub;
    public static ExitKind Function;
    public static ExitKind Property;
    public static ExitKind Try;
}
public abstract class DevExpress.CodeParser.Expression : CodeElement {
    private static object _NullValue;
    private object _TestValue;
    private bool _IsStatement;
    private string _MacroCall;
    public bool NeedsInvertParens { get; }
    public object TestValue { get; }
    public bool TestValueAsBool { get; }
    public bool HasTestValue { get; }
    public int Level { get; }
    public bool CanBeStatement { get; }
    public bool IsStatement { get; public set; }
    public bool IsIndirectlyModified { get; }
    public bool IsInsideModificationExpression { get; }
    public string ExpressionTypeName { get; }
    public LanguageElementType ElementType { get; }
    public string MacroCall { get; public set; }
    private static Expression();
    private void TransferNodesTo(NodeList nodes, LanguageElement element, bool toDetail);
    private void ClearTestValues(NodeList nodes);
    private bool ConvertToBool(object value);
    protected virtual object EvaluateExpression();
    public virtual int GetImageIndex();
    public Expression GetByLevel(int level);
    public LanguageElement GetStartElement();
    public LanguageElement GetEndElement();
    public virtual bool IsIdenticalTo(Expression expression);
    public Expression Invert();
    public virtual Expression Simplify();
    public virtual Expression Simplify(bool considerMethodCalls);
    public abstract virtual IElement Resolve(ISourceTreeResolver resolver);
    public Expression RemoveRedundantParens();
    [EditorBrowsableAttribute("1")]
public object Evaluate();
    [EditorBrowsableAttribute("1")]
public bool EvaluateAsBool();
    public virtual void TransferAllNodesTo(LanguageElement element);
    [EditorBrowsableAttribute("1")]
public void SetTestValue(object value);
    [EditorBrowsableAttribute("1")]
public void ClearTestValue();
    [EditorBrowsableAttribute("1")]
public void ClearTestValues();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual bool Is(string fullTypeName);
    public virtual bool Is(ITypeElement type);
    public virtual bool Is(Type type);
    public virtual bool Is(ISourceTreeResolver resolver, string fullTypeName);
    public virtual bool get_NeedsInvertParens();
    public object get_TestValue();
    public bool get_TestValueAsBool();
    public bool get_HasTestValue();
    public virtual int get_Level();
    public virtual bool get_CanBeStatement();
    public sealed virtual bool get_IsStatement();
    public void set_IsStatement(bool value);
    public bool get_IsIndirectlyModified();
    public bool get_IsInsideModificationExpression();
    public virtual string get_ExpressionTypeName();
    public virtual LanguageElementType get_ElementType();
    public virtual string get_MacroCall();
    public virtual void set_MacroCall(string value);
}
public abstract class DevExpress.CodeParser.ExpressionCodeGenBase : LanguageElementCodeGenBase {
    public ExpressionCodeGenBase(CodeGen codeGen);
    private List`1<ExpressionInfo> GetExpressionListFromBinaryExpression(BinaryOperatorExpression expression, LanguageElementType elementType);
    private void GetExpressionListFromBinaryExpression(BinaryOperatorExpression expression, List`1<ExpressionInfo> list, LanguageElementType elementType, BinaryOperatorType op);
    private string GetBinaryOperatorText(BinaryOperatorExpression expression);
    private void GenerateElementForeComment(LanguageElement element);
    private void GenerateElementBackComment(LanguageElement element);
    protected string GetStringValue(object value);
    protected abstract virtual bool IsEscapedString(string value);
    protected abstract virtual string GetBinaryOperatorText(BinaryOperatorType operatorType);
    protected abstract virtual void GenerateFunctionPointerTypeReference(FunctionPointerTypeReference expression);
    protected abstract virtual void GenerateTypedElementReferenceExpression(TypedElementReferenceExpression expression);
    protected abstract virtual void GenerateDistinctExpression(DistinctExpression expression);
    protected abstract virtual void GenerateInExpression(InExpression expression);
    protected abstract virtual void GenerateMemberInitializerExpression(MemberInitializerExpression expression);
    protected abstract virtual void GenerateObjectInitializerExpression(ObjectInitializerExpression expression);
    protected abstract virtual void GenerateLambdaExpression(LambdaExpression expression);
    protected abstract virtual void GenerateFromExpression(FromExpression expression);
    protected abstract virtual void GenerateJoinExpression(JoinExpression expression);
    protected abstract virtual void GenerateQueryExpression(QueryExpression expression);
    protected abstract virtual void GenerateLetExpression(LetExpression expression);
    protected abstract virtual void GenerateWhereExpression(WhereExpression expression);
    protected abstract virtual void GenerateOrderingExpression(OrderingExpression expression);
    protected abstract virtual void GenerateOrderByExpression(OrderByExpression expression);
    protected abstract virtual void GenerateSelectExpression(SelectExpression expression);
    protected abstract virtual void GenerateIntoExpression(IntoExpression expression);
    protected abstract virtual void GenerateEqualsExpression(EqualsExpression expression);
    protected abstract virtual void GenerateGroupByExpression(GroupByExpression expression);
    protected abstract virtual void GenerateJoinIntoExpression(JoinIntoExpression expression);
    protected abstract virtual void GenerateCppQualifiedElementReference(CppQualifiedElementReference expression);
    protected abstract virtual void GenerateExpressionTypeArgument(ExpressionTypeArgument expression);
    protected abstract virtual void GenerateGenericTypeArguments(TypeReferenceExpressionCollection arguments);
    protected abstract virtual void GenerateArgumentDirection(ArgumentDirection direction);
    protected abstract virtual void GenerateAddressOfExpression(AddressOfExpression expression);
    protected abstract virtual void GenerateArgumentDirectionExpression(ArgumentDirectionExpression expression);
    protected abstract virtual void GenerateArrayCreateExpression(ArrayCreateExpression expression);
    protected abstract virtual void GenerateArrayInitializerExpression(ArrayInitializerExpression expression);
    protected abstract virtual void GenerateAssignmentExpression(AssignmentExpression expression);
    protected abstract virtual void GenerateBaseReferenceExpression(BaseReferenceExpression expression);
    protected abstract virtual void GenerateCheckedExpression(CheckedExpression expression);
    protected abstract virtual void GenerateConditionalExpression(ConditionalExpression expression);
    protected abstract virtual void GenerateIndexerExpression(IndexerExpression expression);
    protected abstract virtual void GenerateObjectCreationExpression(ObjectCreationExpression expression);
    protected abstract virtual void GenerateBooleanLiteral(bool value);
    protected abstract virtual void GenerateStringLiteral(string value);
    protected abstract virtual void GenerateCharLiteral(char value);
    protected abstract virtual void GenerateNullLiteral();
    protected abstract virtual void GenerateNumberLiteral(string name, object value, PrimitiveType type);
    protected abstract virtual void GenerateDateTime(object value);
    protected abstract virtual void GenerateSizeOfExpression(SizeOfExpression expression);
    protected abstract virtual void GenerateThisReferenceExpression(ThisReferenceExpression expression);
    protected abstract virtual void GenerateMyClassExpression(MyClassExpression expression);
    protected abstract virtual void GenerateTypeCastExpression(TypeCastExpression expression);
    protected abstract virtual void GenerateTypeOfExpression(TypeOfExpression expression);
    protected abstract virtual void GenerateTypeOfIsExpression(TypeOfIsExpression expression);
    protected abstract virtual void GenerateTypeReferenceExpression(TypeReferenceExpression expression);
    protected abstract virtual void GenerateUncheckedExpression(UncheckedExpression expression);
    protected abstract virtual void GenerateLogicalInversion(LogicalInversion expression);
    protected abstract virtual void GenerateUnaryIncrement(UnaryIncrement expression);
    protected abstract virtual void GenerateUnaryDecrement(UnaryDecrement expression);
    protected abstract virtual void GenerateTypeCheck(TypeCheck expression);
    protected abstract virtual void GenerateConditionalTypeCast(ConditionalTypeCast expression);
    protected abstract virtual void GenerateIsNot(IsNot expression);
    protected abstract virtual void GenerateAnonymousMethodExpression(AnonymousMethodExpression expression);
    protected abstract virtual void GenerateDefaultValueExpression(DefaultValueExpression expression);
    protected abstract virtual void GenerateNullCoalescingExpression(NullCoalescingExpression expression);
    protected abstract virtual void GenerateQualifiedAliasExpression(QualifiedAliasExpression expression);
    protected abstract virtual void GenerateComplexExpression(ComplexExpression expression);
    protected abstract virtual void GenerateDeleteExpression(DeleteExpression expression);
    protected abstract virtual void GenerateDeleteArrayExpression(DeleteArrayExpression expression);
    protected abstract virtual void GenerateElaboratedTypeReference(ElaboratedTypeReference expression);
    protected abstract virtual void GenerateManagedObjectCreationExpression(ManagedObjectCreationExpression expression);
    protected abstract virtual void GenerateParametizedArrayCreateExpression(ParametrizedArrayCreateExpression expression);
    protected abstract virtual void GenerateParametizedObjectCreationExpression(ParametrizedObjectCreationExpression expression);
    protected abstract virtual void GeneratePointerElementReference(PointerElementReference expression);
    protected abstract virtual void GenerateQualifiedNestedReference(QualifiedNestedReference expression);
    protected abstract virtual void GenerateQualifiedNestedTypeReference(QualifiedNestedTypeReference expression);
    protected abstract virtual void GenerateQualifiedTypeReferenceExpression(QualifiedTypeReferenceExpression expression);
    protected abstract virtual void GenerateQualifiedMethodReference(QualifiedMethodReference expression);
    protected abstract virtual void GeneratePointerMethodReference(PointerMethodReference expression);
    protected abstract virtual void GenerateManagedArrayCreateExpression(ManagedArrayCreateExpression expression);
    protected abstract virtual bool GenerateMacroExpression(Expression expression);
    protected abstract virtual void GenerateAttributeVariableInitializer(AttributeVariableInitializer expression);
    protected virtual void GenerateMarkupExtensionExpression(MarkupExtensionExpression expression);
    protected virtual bool GenerateExpression(Expression expression);
    protected virtual bool GenerateExpressionCore(Expression expression);
    protected virtual bool GenerateSpecificExpression(Expression expressiom);
    protected virtual void GenerateExpressionList(ExpressionCollectionBase expressions);
    protected virtual void GenerateExpressionList(ExpressionCollectionBase expressions, string delimiter);
    protected virtual void GenerateExpressionList(ExpressionCollectionBase expressions, string delimiter, bool lineBreakAfterDelimiter);
    protected virtual void GenerateLogicalOperator(LogicalOperator logicalOperator);
    protected virtual void GenerateRelationalOperator(RelationalOperator relationalOperator);
    protected virtual void GenerateBinaryOperator(BinaryOperatorType op);
    protected virtual void GenerateBinaryOperator(BinaryOperatorExpression expression);
    protected virtual void GenerateBinaryOperatorExpression(BinaryOperatorExpression expression);
    protected virtual void GenerateSnippetExpression(SnippetExpression expression);
    protected virtual void GenerateReferenceExpressionBase(ReferenceExpressionBase expression);
    protected virtual void GenerateReferenceExpressionBase(ReferenceExpressionBase expression, string delimiter);
    protected virtual void GenerateReferenceExpressionBase(ReferenceExpressionBase expression, TokenList delimiters);
    protected virtual void GenerateReferenceExpressionBase(ReferenceExpressionBase expression, FormattingTokenType prevName, FormattingTokenType afterName, FormattingTokenType delimiter);
    protected virtual void GenerateReferenceExpressionBase(ReferenceExpressionBase expression, FormattingTokenType prevName, FormattingTokenType afterName, TokenList delimiters);
    protected virtual void GenerateElementReferenceExpression(ElementReferenceExpression expression);
    protected virtual void GenerateMethodCallExpression(MethodCallExpression expression);
    protected virtual void GenerateShortInitializeExpression(ShortInitializeExpression expression);
    protected virtual void GenerateMethodReferenceExpression(MethodReferenceExpression expression);
    protected virtual void GenerateParenthesizedExpression(ParenthesizedExpression expression);
    protected virtual void GenerateStringLiteralWithEscapeSequence(string value);
    protected virtual void GeneratePrimitiveExpression(PrimitiveExpression expression);
    protected virtual void GenerateUnaryOperatorExpression(UnaryOperatorExpression expression);
    protected virtual void GenerateLogicalOperation(LogicalOperation expression);
    protected virtual void GenerateRelationalOperation(RelationalOperation expression);
    public virtual void GenerateElement(LanguageElement languageElement);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.ExpressionCollection : ExpressionCollectionBase {
    public Expression Item { get; public set; }
    private IExpression DevExpress.CodeParser.IExpressionCollection.Item { get; }
    protected virtual NodeList CreateInstance();
    public int Add(Expression expression);
    public void AddRange(ExpressionCollection collection);
    public int IndexOf(Expression expression);
    public void Insert(int index, Expression expression);
    public void Remove(Expression expression);
    public Expression Find(Expression expression);
    public bool Contains(Expression expression);
    public Expression get_Item(int index);
    public void set_Item(int index, Expression value);
    private sealed virtual override int DevExpress.CodeParser.IExpressionCollection.IndexOf(IExpression e);
    private sealed virtual override IExpression DevExpress.CodeParser.IExpressionCollection.get_Item(int index);
    [IteratorStateMachineAttribute("DevExpress.CodeParser.ExpressionCollection/<System-Collections-Generic-IEnumerable<DevExpress-CodeParser-Expression>-GetEnumerator>d__14")]
private sealed virtual override IEnumerator`1<Expression> System.Collections.Generic.IEnumerable<DevExpress.CodeParser.Expression>.GetEnumerator();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerator <>n__0();
}
public class DevExpress.CodeParser.ExpressionCollectionBase : LanguageElementCollectionBase {
    public bool IsIdenticalTo(ExpressionCollectionBase collection);
    public void ReplaceExpression(Expression oldExpression, Expression newExpression);
    protected virtual NodeList CreateInstance();
}
public enum DevExpress.CodeParser.ExpressionDelimiter : Enum {
    public byte value__;
    public static ExpressionDelimiter None;
    public static ExpressionDelimiter Whitespace;
    public static ExpressionDelimiter Comma;
    public static ExpressionDelimiter Equals;
    public static ExpressionDelimiter Slash;
}
public class DevExpress.CodeParser.ExpressionFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public virtual IElementCollection Apply(IElementCollection elements);
}
public abstract class DevExpress.CodeParser.ExpressionInverterBase : object {
    protected virtual Expression InvertIsExpression(Is expression);
    protected virtual Expression InvertIsNotExpression(IsNot expression);
    protected virtual Expression InvertRelationalOperation(RelationalOperation expression);
    protected virtual Expression InvertExpression(Expression expression);
    public virtual Expression Invert(Expression expression);
    public static Expression DefaultInvert(Expression expression);
}
public abstract class DevExpress.CodeParser.ExpressionParserBase : LanguageElementParserBase {
    public ExpressionParserBase(ParserBase parser);
    public virtual Expression Parse(ISourceReader reader);
    public virtual TypeReferenceExpression ParseTypeReferenceExpression(string expression);
    public virtual TypeReferenceExpression ParseTypeReferenceExpression(ISourceReader reader);
}
public class DevExpress.CodeParser.ExpressionSignatureBuilder : object {
    private static char CHAR_LessThan;
    private static char CHAR_GreaterThan;
    private static string CHAR_Dot;
    private static void AppendGeneric(StringBuilder builder, IGenericExpression expr);
    private static void AppendTypeReferenceModifiers(StringBuilder builder, ITypeReferenceExpression expr);
    private static void AppendExpressionsSignature(StringBuilder builder, IExpressionCollection expressions);
    private static void AppendArgumentsSignature(StringBuilder builder, IMethodCallExpression methodCall);
    private static string BuildSignature(IExpression expr);
    [EditorBrowsableAttribute("1")]
public static string GetSignature(IExpression expr);
}
public class DevExpress.CodeParser.ExpressionTypeArgument : TypeReferenceExpression {
    private Expression _SourceExpression;
    public LanguageElementType ElementType { get; }
    public Expression SourceExpression { get; public set; }
    public ExpressionTypeArgument(Expression sourceExpression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    public Expression get_SourceExpression();
    public void set_SourceExpression(Expression value);
}
public class DevExpress.CodeParser.ExtensionMethodParam : Param {
    public LanguageElementType ElementType { get; }
    public ExtensionMethodParam(string type, string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ExternAlias : CodeElement {
    private TextRange _NameRange;
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; public set; }
    public ExternAlias(string name);
    public ExternAlias(string name, SourceRange range, SourceRange nameRange);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
}
public class DevExpress.CodeParser.ExternAliasDeclaration : CodeElement {
    private string _AliasName;
    private IAssemblyReference _Reference;
    private IElementCollection _References;
    public LanguageElementType ElementType { get; }
    public string Name { get; public set; }
    [ObsoleteAttribute("Use property References")]
public IAssemblyReference Reference { get; }
    public IElementCollection References { get; }
    [ObsoleteAttribute("Use constructor with collection references in the second parameter")]
public ExternAliasDeclaration(string name, IAssemblyReference reference);
    public ExternAliasDeclaration(string name, IElementCollection references);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public IAssemblyReference get_Reference();
    public IElementCollection get_References();
}
public class DevExpress.CodeParser.ExternDeclaration : DelimiterCapableBlock {
    private bool _HasBrackets;
    public LanguageElementType ElementType { get; }
    public bool HasBrackets { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual bool get_HasBrackets();
    public void set_HasBrackets(bool value);
}
public class DevExpress.CodeParser.FictiveAspComment : Statement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.FieldFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public virtual IElementCollection Apply(IElementCollection elements);
}
public class DevExpress.CodeParser.FileSourceRange : object {
    private SourceFile _File;
    private SourceRange _Range;
    private object _Data;
    public SourceFile File { get; }
    public SourceRange Range { get; public set; }
    public object Data { get; public set; }
    public FileSourceRange(SourceFile file, SourceRange range);
    public FileSourceRange(IElement element, SourceRange range);
    private static SourceFile GetSourceFile(IElement element);
    public SourceFile get_File();
    public SourceRange get_Range();
    public void set_Range(SourceRange value);
    public object get_Data();
    public void set_Data(object value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public bool BindToCode();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.FileSourceRangeCollection : CollectionBase {
    public SourceRange[] Ranges { get; }
    public Object[] Data { get; }
    public FileSourceRange Item { get; public set; }
    private SourceRange[] GetRanges();
    private Object[] GetData();
    private static FileSourceRangeCollection GetFileRanges(SourceFile file, SourceRange[] ranges);
    public int Add(FileSourceRange range);
    public void AddRange(FileSourceRangeCollection ranges);
    public void AddRange(ICollection ranges);
    public int IndexOf(FileSourceRange range);
    public void Insert(int index, FileSourceRange range);
    public void Remove(FileSourceRange range);
    public Hashtable GroupByFile();
    public FileSourceRangeCollection GetRangesFromData();
    public static FileSourceRangeCollection CreateInstance(SourceFile fileNode, SourceRange[] ranges);
    public SourceRange[] get_Ranges();
    public Object[] get_Data();
    public FileSourceRange get_Item(int index);
    public void set_Item(int index, FileSourceRange value);
}
public class DevExpress.CodeParser.FilteredSourceFile : object {
    private SourceFile _File;
    private Int32[] _Lines;
    public SourceFile File { get; }
    public Int32[] Lines { get; }
    public FilteredSourceFile(SourceFile file, Int32[] lines);
    public SourceFile get_File();
    public Int32[] get_Lines();
}
public class DevExpress.CodeParser.Finally : ParentingStatement {
    private static int INT_MaintainanceComplexity;
    public LanguageElementType ElementType { get; }
    public bool CompletesPrevious { get; }
    protected int ThisMaintenanceComplexity { get; }
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_CompletesPrevious();
    protected virtual int get_ThisMaintenanceComplexity();
}
public class DevExpress.CodeParser.FirstLevelReferenceFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
}
public class DevExpress.CodeParser.Fixed : ParentToSingleStatement {
    private static int INT_MaintainanceComplexity;
    private LanguageElementList _Initializers;
    public LanguageElementType ElementType { get; }
    protected int ThisMaintenanceComplexity { get; }
    private IVariableDeclarationStatementCollection DevExpress.CodeParser.IFixedStatement.Initializers { get; }
    public Fixed(LanguageElementCollection elements);
    public void AddInitializer(LanguageElement element);
    public void AddInitializers(LanguageElementCollection elements);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual LanguageElementType get_ElementType();
    protected virtual int get_ThisMaintenanceComplexity();
    private sealed virtual override IVariableDeclarationStatementCollection DevExpress.CodeParser.IFixedStatement.get_Initializers();
}
public class DevExpress.CodeParser.FloatNum : Number {
    protected decimal DecimalItem { get; protected set; }
    protected decimal get_DecimalItem();
    protected void set_DecimalItem(decimal value);
    protected FloatNum GetZeroNumber();
    protected FloatNum DoCalculate(Number param);
    public virtual Number Add(Number param);
    public virtual Number Sub(Number param);
    public virtual Number Mul(Number param);
    public virtual Number Div(Number param);
    public virtual Number ModDiv(Number param);
    public virtual Number MinusSign();
    public virtual Number PlusSign();
    public virtual Number Decrement();
    public virtual Number Increment();
    public virtual Number And(Number param);
    public virtual Number Or(Number param);
    public virtual Number Xor(Number param);
    public virtual Number LeftShift(Number param);
    public virtual Number RightShift(Number param);
    public virtual bool IsTrue();
    public virtual bool IsEqualTo(Number param);
    public virtual bool IsBelow(Number param);
    public virtual bool IsBelowOrEqual(Number param);
    public virtual bool IsGreater(Number param);
    public virtual bool IsGreaterOrEqual(Number param);
}
public class DevExpress.CodeParser.FlowBreak : Statement {
    public LanguageElementType ElementType { get; }
    protected LanguageElement FindReturnTarget();
    protected LanguageElement FindBreakTarget();
    protected LanguageElement FindBreakTarget(bool canBreakOutOfMember);
    public virtual int GetImageIndex();
    public virtual LanguageElement FindTarget();
    public virtual LanguageElement GetFlowParent();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.For : ConditionalParentToSingleStatement {
    private static int INT_MaintainanceComplexity;
    private Expression _Condition;
    private LanguageElementList _Initializers;
    private LanguageElementList _Incrementors;
    private Expression _ToExpression;
    private Expression _StepExpression;
    public LanguageElementType ElementType { get; }
    public LanguageElementList Initializers { get; }
    public LanguageElementList Incrementors { get; }
    public Expression Condition { get; public set; }
    public Expression ToExpression { get; public set; }
    public Expression StepExpression { get; public set; }
    public NodeList NextExpressionList { get; public set; }
    protected int ThisMaintenanceComplexity { get; }
    private IExpression DevExpress.CodeParser.IForStatement.Condition { get; }
    private IElementCollection DevExpress.CodeParser.IForStatement.Initializers { get; }
    private IExpressionCollection DevExpress.CodeParser.IForStatement.Incrementors { get; }
    private IExpression DevExpress.CodeParser.IForStatement.ToExpression { get; }
    private IExpression DevExpress.CodeParser.IForStatement.StepExpression { get; }
    private IExpressionCollection DevExpress.CodeParser.IForStatement.NextExpressions { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public void AddInitializer(LanguageElement element);
    public void AddInitializers(LanguageElementCollection elements);
    public void AddIncrementor(LanguageElement element);
    public void AddIncrementors(LanguageElementCollection elements);
    public virtual void AddNextExpression(LanguageElement element);
    public void AddNextExpressions(LanguageElementCollection elements);
    protected void SetCondition(Expression expression);
    protected void SetToExpression(Expression expression);
    protected void SetStepExpression(Expression expression);
    public virtual int GetImageIndex();
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public LanguageElementList get_Initializers();
    public LanguageElementList get_Incrementors();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    public Expression get_ToExpression();
    public void set_ToExpression(Expression value);
    public Expression get_StepExpression();
    public void set_StepExpression(Expression value);
    public virtual NodeList get_NextExpressionList();
    public virtual void set_NextExpressionList(NodeList value);
    protected virtual int get_ThisMaintenanceComplexity();
    private sealed virtual override IExpression DevExpress.CodeParser.IForStatement.get_Condition();
    private sealed virtual override IElementCollection DevExpress.CodeParser.IForStatement.get_Initializers();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IForStatement.get_Incrementors();
    private sealed virtual override IExpression DevExpress.CodeParser.IForStatement.get_ToExpression();
    private sealed virtual override IExpression DevExpress.CodeParser.IForStatement.get_StepExpression();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IForStatement.get_NextExpressions();
}
public class DevExpress.CodeParser.ForEach : ConditionalParentToSingleStatement {
    private static int INT_MaintainanceComplexity;
    private Expression _Expression;
    private BaseVariable _LoopVariable;
    public string FieldType;
    public string Field;
    public string Collection;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    public BaseVariable LoopVariable { get; }
    public Expression NextExpression { get; public set; }
    private IVariableDeclarationStatement DevExpress.CodeParser.IForEachStatement.LoopVariable { get; }
    private IExpression DevExpress.CodeParser.IForEachStatement.Expression { get; }
    private IExpression DevExpress.CodeParser.IForEachStatement.NextExpression { get; }
    public ForEach(BaseVariable loop, Expression expression, Expression nextExpression);
    internal void SetExpression(Expression value);
    internal void SetLoopVariable(BaseVariable value);
    protected virtual void SetNextExpression(Expression value);
    protected virtual void SetInitializer(LanguageElement value);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public BaseVariable get_LoopVariable();
    public virtual void set_NextExpression(Expression value);
    public virtual Expression get_NextExpression();
    private sealed virtual override IVariableDeclarationStatement DevExpress.CodeParser.IForEachStatement.get_LoopVariable();
    private sealed virtual override IExpression DevExpress.CodeParser.IForEachStatement.get_Expression();
    private sealed virtual override IExpression DevExpress.CodeParser.IForEachStatement.get_NextExpression();
}
public class DevExpress.CodeParser.FormattingElement : object {
    private int _CountConsecutive;
    private FormattingElementType _Type;
    public FormattingElementType Type { get; public set; }
    public int CountConsecutive { get; internal set; }
    public FormattingElement(FormattingElementType type);
    public FormattingElement(FormattingElementType type, int countConsecutive);
    public FormattingElementType get_Type();
    public void set_Type(FormattingElementType value);
    public int get_CountConsecutive();
    internal void set_CountConsecutive(int value);
    public bool IsEol();
    public bool IsWsOrTab();
    public bool IsIndent();
    public sealed virtual object Clone();
    public virtual string ToString();
}
public class DevExpress.CodeParser.FormattingElementCollection : List`1<FormattingElements> {
    public FormattingElementCollection CloneList(ElementCloneOptions options);
}
public class DevExpress.CodeParser.FormattingElements : List`1<IFormattingElement> {
    public FormattingElements(List`1<IFormattingElement> elements);
    public void AddDeadCode(string text);
    public void AddSourceFileStartText(string text);
    public FormattingElements CloneArray(ElementCloneOptions options);
    public FormattingElements GetElements(int index, int count);
    private IFormattingElement CloneElement(IFormattingElement element, ElementCloneOptions options);
    private bool IsLastElement(FormattingElementType type);
    internal void Add(FormattingElementType type, int countConsecutive);
    public void RemoveRange(FormattingElements list);
    public int GetEndEOLIndex(int index);
    public FormattingElement GetLastEOLElement(int index);
    public bool HasOnlyNewLine();
    public void RemoveFirstEOL();
    public void RemoveEOL(int index);
    public void AddWhiteSpace();
    public void AddWhiteSpace(int countConsecutive);
    public void AddIncreaseIndent();
    public void AddDecreaseIndent();
    public void AddIncreaseAlignment();
    public void AddDecreaseAlignment();
    public void AddClearIndent();
    public void AddRestoreIndent();
    public void AddNewLine();
    public void AddNewLine(int countConsecutive);
    public bool IsLastElementNewLine();
    public bool IsLastElementWhiteSpace();
    public bool IsLastElementIndent();
    public bool DeleteDirective(PreprocessorDirective searchElement);
    public void DeleteEmptyLines(bool attemptDeleteLastLine);
    internal void RemoveLastEolIfNeeded();
    internal void AddNewLineAfterIndex(int i);
    internal void AddFirstIfNeeded(FormattingElementType type);
}
internal class DevExpress.CodeParser.FormattingElementsWriter : object {
    public static void WriteSupportElement(CodeGen codeGen, IFormattingElement element);
    public static void WriteEOL(CodeGen codeGen);
    private static bool WriteComment(CodeGen codeGen, Comment comment);
    private static bool WriteFormattingText(CodeGen codeGen, FormattingText formattingText);
    private static bool WritePpDirective(CodeGen codeGen, PreprocessorDirective element);
    private static void WriteIndent(CodeGen codeGen, CheckedIndent indent);
    private static bool WriteFormattingElement(CodeGen codeGen, FormattingElement formatingElement);
    private static void WriteWS(CodeGen codeGen);
    private static void WriteTab(CodeGen codeGen);
    private static void WriteCR(CodeGen codeGen);
    private static void IncreaseIndent(CodeGen codeGen);
    private static void DecreaseIndent(CodeGen codeGen);
    private static void IncreaseAlignment(CodeGen codeGen);
    private static void DecreaseAlignment(CodeGen codeGen);
}
public enum DevExpress.CodeParser.FormattingElementType : Enum {
    public int value__;
    public static FormattingElementType WS;
    public static FormattingElementType Tab;
    public static FormattingElementType CR;
    public static FormattingElementType EOL;
    public static FormattingElementType IncreaseIndent;
    public static FormattingElementType DecreaseIndent;
    public static FormattingElementType IncreaseAlignment;
    public static FormattingElementType DecreaseAlignment;
    public static FormattingElementType ClearIndent;
    public static FormattingElementType RestoreIndent;
}
internal class DevExpress.CodeParser.FormattingHelper : object {
    public static bool IsFormattingChar(char ch);
    public static void AddTokenElement(FormattingElements list, char ch);
    public static bool CanProcessTextToken(GenTextArgs args);
    public static void ProcessTokenText(GenTextArgs args, FormattingElements& prevElementsInText, FormattingElements& nextElementsInText);
    private static void Sort(FormattingElements elements);
    private static FormattingElements MergeIndents(CodeGen codeGen, List`1<FormattingElement> indents);
    public static void MergeIndents(CodeGen codeGen, FormattingElements elements);
    public static bool KeepExpressionIndent(CodeGen codeGen);
    public static void CleanupElements(CodeGen codeGen, FormattingElements result);
}
public abstract class DevExpress.CodeParser.FormattingParserBase : TokenCategorizedParserBase {
    private bool _SaveFormat;
    private FormattingParsingElement _LastParsingElement;
    private FormattingParsingElementCollection _FormattingParsingElements;
    internal FormattingParsingElement LastFormattingParsingElement { get; }
    protected FormattingTable FormattingTable { get; }
    protected FormattingParsingElementCollection FormattingParsingElements { get; }
    protected FormattingParsingElement LastParsingElement { get; protected set; }
    public bool SaveFormat { get; public set; }
    private FormattingParsingElement AddFormattingParsingElement(FormattingToken token);
    private FormattingParsingElement AddFormattingParsingElement(SourceRange range, FormattingParsingElement element);
    internal void AddToParsingElement(FormattingParsingElement parsingElement, FormattingElements formattingElements);
    protected FormattingTokenType GetTokenType(FormattingToken token);
    protected FormattingTokenType GetFormattingTokenType(string tokenText);
    protected FormattingParsingElement ReplaceOrAddFormattingParsingElement(FormattingToken token, FormattingTokenType type);
    protected virtual void AfterParsingWithClearing(LanguageElement element);
    protected virtual void AfterParsing();
    protected virtual void AfterParsing(LanguageElementCollectionBase coll);
    protected virtual void AfterParsing(LanguageElement element);
    protected void ClearFormattingParsingElements();
    protected virtual void Get();
    protected virtual void PrepareForParse(ParserContext parserContext);
    protected virtual void CleanUpInternalData();
    protected virtual void CleanUpParser();
    protected virtual bool IsIdent(Token token);
    internal virtual void AddCommentNode(Token lCommentToken, FormattingParsingElement lastElement);
    public FormattingParsingElement AddFormattingElements(FormattingToken token);
    public void AddToParsingElement(FormattingParsingElement parsingElement, IFormattingElement formattingElement);
    internal FormattingParsingElement get_LastFormattingParsingElement();
    protected virtual FormattingTable get_FormattingTable();
    protected FormattingParsingElementCollection get_FormattingParsingElements();
    protected FormattingParsingElement get_LastParsingElement();
    protected void set_LastParsingElement(FormattingParsingElement value);
    public bool get_SaveFormat();
    public void set_SaveFormat(bool value);
}
public class DevExpress.CodeParser.FormattingParsingElement : object {
    private FormattingElements _FormattingElements;
    private FormattingTokenType _FormattingType;
    private int _StartLine;
    private int _StartOffset;
    private int _EndLine;
    private int _EndOffset;
    public FormattingElements FormattingElements { get; public set; }
    public FormattingTokenType FormattingType { get; public set; }
    public SourceRange Range { get; public set; }
    public FormattingParsingElement(FormattingTokenType type, FormattingElements formattingElements);
    public void AddFormattingElements(FormattingParsingElement formattingParsingElement);
    public void AddFormattingElements(FormattingElements formattingElements);
    public void AddFormattingElement(IFormattingElement formattingElement);
    public virtual string ToString();
    public sealed virtual int CompareTo(FormattingParsingElement other);
    internal bool Contains(FormattingParsingElement element);
    private bool Contains(int line, int offset);
    public FormattingElements get_FormattingElements();
    public void set_FormattingElements(FormattingElements value);
    public FormattingTokenType get_FormattingType();
    public void set_FormattingType(FormattingTokenType value);
    public SourceRange get_Range();
    public void set_Range(SourceRange value);
}
public class DevExpress.CodeParser.FormattingParsingElementCollection : object {
    private List`1<FormattingParsingElement> _Coll;
    public FormattingParsingElement LastElement { get; }
    private List`1<FormattingParsingElement> Coll { get; }
    public void Add(SourceRange range, FormattingParsingElement element);
    internal void ReplaceOrAdd(SourceRange range, FormattingParsingElement element);
    public FormattingParsingElement get_LastElement();
    public void Clear();
    private List`1<FormattingParsingElement> get_Coll();
    public LanguageElementTokens GetSourceFileTokens();
    public LanguageElementTokens GetTokens(SourceRange scopeRange);
}
public abstract class DevExpress.CodeParser.FormattingTable : object {
    private Dictionary`2<string, FormattingTokenType> _FormattingTokenTypeCorrespondanceTable;
    private Dictionary`2<FormattingTokenType, string> _FormattingTokenTypeCorrespondanceReversedTable;
    private Dictionary`2<FormattingTokenType, string> _OnlyGetValueTable;
    protected Dictionary`2<string, FormattingTokenType> FormattingTokenTypeCorrespondanceTable { get; }
    protected Dictionary`2<FormattingTokenType, string> FormattingTokenTypeCorrespondanceReversedTable { get; }
    protected Dictionary`2<FormattingTokenType, string> OnlyGetValueTable { get; }
    protected abstract virtual void FillFormattingTokenTypeCorrespondanceTable();
    protected void AddToOnlyGetValue(FormattingTokenType type, string text);
    protected void AddToken(FormattingTokenType type, string text);
    public virtual string Get(FormattingTokenType type);
    public virtual FormattingTokenType Get(string text);
    protected Dictionary`2<string, FormattingTokenType> get_FormattingTokenTypeCorrespondanceTable();
    protected Dictionary`2<FormattingTokenType, string> get_FormattingTokenTypeCorrespondanceReversedTable();
    protected Dictionary`2<FormattingTokenType, string> get_OnlyGetValueTable();
}
public abstract class DevExpress.CodeParser.FormattingText : object {
    private string _Text;
    public string Text { get; }
    public FormattingText(string text);
    public string get_Text();
    public abstract virtual object Clone();
}
public class DevExpress.CodeParser.FormattingToken : CategorizedToken {
    private bool _WasChecked;
    private FormattingElements _FormattingElements;
    public FormattingElements FormattingElements { get; public set; }
    public bool WasChecked { get; public set; }
    public FormattingToken(TokenLanguage language);
    public void SetFormattingElement(FormattingElements formattingElement);
    public void ResetFormattingElements();
    public void set_FormattingElements(FormattingElements value);
    public FormattingElements get_FormattingElements();
    public bool get_WasChecked();
    public void set_WasChecked(bool value);
}
public class DevExpress.CodeParser.FormattingTokenGen : object {
    private CodeGen _CodeGen;
    private TokenGenArgs _TokenGenArgs;
    private LanguageElementCodeGenBase _ElementCodeGen;
    private FormattingElements _FormattingElementsForSupportElement;
    private IFormattingElement _LastGeneratedFormattingElement;
    private bool _NeedIncreaseAlignment;
    private bool _GeneratingInSupportElement;
    private CodeGen CodeGen { get; }
    internal bool GeneratingInSupportElement { get; internal set; }
    internal TokenGenArgs TokenGenArgs { get; internal set; }
    internal FormattingElements FormattingElements { get; }
    public FormattingElements FormattingElementsForSupportElement { get; public set; }
    public LanguageElementCodeGenBase ElementCodeGen { get; public set; }
    public bool NeedIncreaseAlignment { get; public set; }
    public IFormattingElement LastGeneratedFormattingElement { get; }
    public FormattingTokenGen(CodeGen codeGen);
    public bool TokenArgsContainsElement(object element);
    private FormattingElements GetPrevFormattingElements(FormattingTokenType tokenType);
    private void ClearUserFormattingElements(FormattingElements formattingElements);
    private FormattingElements ProcessStartToken(FormattingTokenType tokenType, FormattingElements list);
    public void WritePrevFormattingElements(FormattingTokenType type, int index);
    public void WriteNextFormattingElements(FormattingTokenType type, int index);
    private void WrapLongTokenTextIfNeeded(GenTextArgs args, bool lastEOL);
    public void WriteTokenText(GenTextArgs args);
    private FormattingElements MergePrevTokenTextElements(FormattingElements prevArgsElements, FormattingElements prevTextElements);
    private FormattingElements MergeNextTokenTextElements(FormattingElements nextArgsElements, FormattingElements nextTextElements);
    private bool SkipFormattingElement(object element);
    protected FormattingElements GetFormattingElementsForRemovedElement(FormattingElements elements);
    private void WriteRemovedElement(GenTextArgs args);
    public void WriteCode(GenTextArgs args);
    private bool NeedCorrectUserElements(FormattingTokenType token, bool previous, LanguageElement context, CodeGenOptions options);
    private void CorrectUserElements(FormattingTokenType token, bool previous);
    private void CleanupElements(FormattingElements result);
    private FormattingElements MergeFormattingElements(FormattingElements elements, FormattingElements formattingElements);
    private FormattingElements GetUserFormattingElements(LanguageElement element, FormattingTokenType type, int index);
    public void WriteResiduaryFormattingElements();
    protected void WriteFormattingElements(FormattingElements elements);
    public void AddNewLine(int countConsecutive);
    public void AddNewLineIfNeeded();
    internal bool IsLastGeneratedEOL();
    public void AddWSIfNeeded();
    public void AddDecreaseIndent();
    public void AddIncreaseIndent();
    public void AddClearIndent();
    public void AddRestoreIndent();
    private CodeGen get_CodeGen();
    internal bool get_GeneratingInSupportElement();
    internal void set_GeneratingInSupportElement(bool value);
    internal TokenGenArgs get_TokenGenArgs();
    internal void set_TokenGenArgs(TokenGenArgs value);
    internal FormattingElements get_FormattingElements();
    private void PrepareElements(FormattingElements formattingElements, FormattingElements userElements);
    public FormattingElements get_FormattingElementsForSupportElement();
    public void set_FormattingElementsForSupportElement(FormattingElements value);
    public LanguageElementCodeGenBase get_ElementCodeGen();
    public void set_ElementCodeGen(LanguageElementCodeGenBase value);
    public bool get_NeedIncreaseAlignment();
    public void set_NeedIncreaseAlignment(bool value);
    public IFormattingElement get_LastGeneratedFormattingElement();
}
public enum DevExpress.CodeParser.FormattingTokenType : Enum {
    public short value__;
    public static FormattingTokenType None;
    public static FormattingTokenType SourceFileStart;
    public static FormattingTokenType WhiteSpace;
    public static FormattingTokenType NewLine;
    public static FormattingTokenType Fictive;
    public static FormattingTokenType Abstract;
    public static FormattingTokenType As;
    public static FormattingTokenType Async;
    public static FormattingTokenType Await;
    public static FormattingTokenType Base;
    public static FormattingTokenType BackSlashEqual;
    public static FormattingTokenType Bool;
    public static FormattingTokenType Break;
    public static FormattingTokenType Byte;
    public static FormattingTokenType Case;
    public static FormattingTokenType Catch;
    public static FormattingTokenType Char;
    public static FormattingTokenType Checked;
    public static FormattingTokenType Class;
    public static FormattingTokenType Const;
    public static FormattingTokenType Continue;
    public static FormattingTokenType Decimal;
    public static FormattingTokenType Default;
    public static FormattingTokenType Delegate;
    public static FormattingTokenType Do;
    public static FormattingTokenType DollarSign;
    public static FormattingTokenType Double;
    public static FormattingTokenType Else;
    public static FormattingTokenType Enum;
    public static FormattingTokenType Equals;
    public static FormattingTokenType Event;
    public static FormattingTokenType Explicit;
    public static FormattingTokenType Extern;
    public static FormattingTokenType False;
    public static FormattingTokenType Finally;
    public static FormattingTokenType Fixed;
    public static FormattingTokenType Float;
    public static FormattingTokenType For;
    public static FormattingTokenType Foreach;
    public static FormattingTokenType GreatThanGreatThanEqual;
    public static FormattingTokenType GreatThanGreatThanGreatThanEqual;
    public static FormattingTokenType If;
    public static FormattingTokenType Implicit;
    public static FormattingTokenType In;
    public static FormattingTokenType Int;
    public static FormattingTokenType Interface;
    public static FormattingTokenType Internal;
    public static FormattingTokenType Is;
    public static FormattingTokenType Lock;
    public static FormattingTokenType Long;
    public static FormattingTokenType Namespace;
    public static FormattingTokenType New;
    public static FormattingTokenType Null;
    public static FormattingTokenType Object;
    public static FormattingTokenType Operator;
    public static FormattingTokenType OrderBy;
    public static FormattingTokenType Out;
    public static FormattingTokenType Override;
    public static FormattingTokenType Params;
    public static FormattingTokenType Private;
    public static FormattingTokenType Protected;
    public static FormattingTokenType Public;
    public static FormattingTokenType ReadOnly;
    public static FormattingTokenType Ref;
    public static FormattingTokenType Return;
    public static FormattingTokenType Sbyte;
    public static FormattingTokenType Sealed;
    public static FormattingTokenType Short;
    public static FormattingTokenType Sizeof;
    public static FormattingTokenType Stackalloc;
    public static FormattingTokenType Static;
    public static FormattingTokenType Struct;
    public static FormattingTokenType Switch;
    public static FormattingTokenType This;
    public static FormattingTokenType Throw;
    public static FormattingTokenType True;
    public static FormattingTokenType Try;
    public static FormattingTokenType TypeOf;
    public static FormattingTokenType Uint;
    public static FormattingTokenType Ulong;
    public static FormattingTokenType Unchecked;
    public static FormattingTokenType Unsafe;
    public static FormattingTokenType Ushort;
    public static FormattingTokenType Using;
    public static FormattingTokenType Var;
    public static FormattingTokenType Virtual;
    public static FormattingTokenType Void;
    public static FormattingTokenType Volatile;
    public static FormattingTokenType While;
    public static FormattingTokenType Ampersand;
    public static FormattingTokenType AmpersandEqual;
    public static FormattingTokenType Equal;
    public static FormattingTokenType AtColon;
    public static FormattingTokenType At;
    public static FormattingTokenType Colon;
    public static FormattingTokenType Comma;
    public static FormattingTokenType MinusMinus;
    public static FormattingTokenType SlashEqual;
    public static FormattingTokenType Dot;
    public static FormattingTokenType ColonColon;
    public static FormattingTokenType EqualEqual;
    public static FormattingTokenType GreaterThen;
    public static FormattingTokenType GreaterThenEqual;
    public static FormattingTokenType PlusPlus;
    public static FormattingTokenType CurlyBraceOpen;
    public static FormattingTokenType BracketOpen;
    public static FormattingTokenType ParenOpen;
    public static FormattingTokenType LessThanLessThanEqual;
    public static FormattingTokenType LessThan;
    public static FormattingTokenType LessThanLessThan;
    public static FormattingTokenType Minus;
    public static FormattingTokenType MinusEqual;
    public static FormattingTokenType PercentEqual;
    public static FormattingTokenType ExclamationEqual;
    public static FormattingTokenType Exclamation;
    public static FormattingTokenType VerticalBarEqual;
    public static FormattingTokenType Plus;
    public static FormattingTokenType PlusEqual;
    public static FormattingTokenType Question;
    public static FormattingTokenType CurlyBraceClose;
    public static FormattingTokenType BracketClose;
    public static FormattingTokenType ParenClose;
    public static FormattingTokenType Semicolon;
    public static FormattingTokenType Tilde;
    public static FormattingTokenType Asterisk;
    public static FormattingTokenType AsteriskEqual;
    public static FormattingTokenType CaretEqual;
    public static FormattingTokenType MinusGreaterThenAsterisk;
    public static FormattingTokenType Partial;
    public static FormattingTokenType Yield;
    public static FormattingTokenType QuestionQuestion;
    public static FormattingTokenType VerticalBarVerticalBar;
    public static FormattingTokenType AmpersandAmpersand;
    public static FormattingTokenType VerticalBar;
    public static FormattingTokenType Caret;
    public static FormattingTokenType LessThanEqual;
    public static FormattingTokenType Slash;
    public static FormattingTokenType Percent;
    public static FormattingTokenType MinusGreaterThen;
    public static FormattingTokenType EqualGreaterThen;
    public static FormattingTokenType Ident;
    public static FormattingTokenType Overloads;
    public static FormattingTokenType By;
    public static FormattingTokenType From;
    public static FormattingTokenType Order;
    public static FormattingTokenType Select;
    public static FormattingTokenType On;
    public static FormattingTokenType Where;
    public static FormattingTokenType Join;
    public static FormattingTokenType Into;
    public static FormattingTokenType Group;
    public static FormattingTokenType Skip;
    public static FormattingTokenType Take;
    public static FormattingTokenType Ascending;
    public static FormattingTokenType Descending;
    public static FormattingTokenType Aggregate;
    public static FormattingTokenType Nothing;
    public static FormattingTokenType AddHandler;
    public static FormattingTokenType AddressOf;
    public static FormattingTokenType Alias;
    public static FormattingTokenType And;
    public static FormattingTokenType AndAlso;
    public static FormattingTokenType Boolean;
    public static FormattingTokenType ByRef;
    public static FormattingTokenType ByVal;
    public static FormattingTokenType Call;
    public static FormattingTokenType CBool;
    public static FormattingTokenType CByte;
    public static FormattingTokenType CChar;
    public static FormattingTokenType CDate;
    public static FormattingTokenType CDbl;
    public static FormattingTokenType CDec;
    public static FormattingTokenType CInt;
    public static FormattingTokenType CLng;
    public static FormattingTokenType CObj;
    public static FormattingTokenType CSByte;
    public static FormattingTokenType CShort;
    public static FormattingTokenType CSng;
    public static FormattingTokenType CStr;
    public static FormattingTokenType CType;
    public static FormattingTokenType CUInt;
    public static FormattingTokenType CULng;
    public static FormattingTokenType CUShort;
    public static FormattingTokenType BackSlash;
    public static FormattingTokenType LessThanGreaterThan;
    public static FormattingTokenType Date;
    public static FormattingTokenType Declare;
    public static FormattingTokenType Dim;
    public static FormattingTokenType DirectCast;
    public static FormattingTokenType Each;
    public static FormattingTokenType ElseIf;
    public static FormattingTokenType End;
    public static FormattingTokenType EndIf;
    public static FormattingTokenType Erase;
    public static FormattingTokenType Error;
    public static FormattingTokenType Exit;
    public static FormattingTokenType Friend;
    public static FormattingTokenType Function;
    public static FormattingTokenType Get;
    public static FormattingTokenType GetType;
    public static FormattingTokenType GetXmlNamespace;
    public static FormattingTokenType Global;
    public static FormattingTokenType GoSub;
    public static FormattingTokenType GoTo;
    public static FormattingTokenType Handles;
    public static FormattingTokenType Implements;
    public static FormattingTokenType Imports;
    public static FormattingTokenType Inherits;
    public static FormattingTokenType Integer;
    public static FormattingTokenType IsNot;
    public static FormattingTokenType Let;
    public static FormattingTokenType Lib;
    public static FormattingTokenType Like;
    public static FormattingTokenType Loop;
    public static FormattingTokenType Me;
    public static FormattingTokenType Mod;
    public static FormattingTokenType Module;
    public static FormattingTokenType MustInherit;
    public static FormattingTokenType MustOverride;
    public static FormattingTokenType MyBase;
    public static FormattingTokenType MyClass;
    public static FormattingTokenType Narrowing;
    public static FormattingTokenType Next;
    public static FormattingTokenType Not;
    public static FormattingTokenType NotInheritable;
    public static FormattingTokenType NotOverridable;
    public static FormattingTokenType Of;
    public static FormattingTokenType Option;
    public static FormattingTokenType Optional;
    public static FormattingTokenType Or;
    public static FormattingTokenType OrElse;
    public static FormattingTokenType Overridable;
    public static FormattingTokenType Overrides;
    public static FormattingTokenType ParamArray;
    public static FormattingTokenType Property;
    public static FormattingTokenType RaiseEvent;
    public static FormattingTokenType ReDim;
    public static FormattingTokenType REM;
    public static FormattingTokenType RemoveHandler;
    public static FormattingTokenType Resume;
    public static FormattingTokenType Set;
    public static FormattingTokenType Shadows;
    public static FormattingTokenType Shared;
    public static FormattingTokenType Single;
    public static FormattingTokenType Step;
    public static FormattingTokenType Stop;
    public static FormattingTokenType String;
    public static FormattingTokenType Structure;
    public static FormattingTokenType Sub;
    public static FormattingTokenType SyncLock;
    public static FormattingTokenType Then;
    public static FormattingTokenType To;
    public static FormattingTokenType TryCast;
    public static FormattingTokenType UInteger;
    public static FormattingTokenType Variant;
    public static FormattingTokenType Wend;
    public static FormattingTokenType When;
    public static FormattingTokenType Widening;
    public static FormattingTokenType With;
    public static FormattingTokenType WithEvents;
    public static FormattingTokenType WriteOnly;
    public static FormattingTokenType Xor;
    public static FormattingTokenType SByteToken;
    public static FormattingTokenType ULongToken;
    public static FormattingTokenType UShortToken;
    public static FormattingTokenType IfDirective;
    public static FormattingTokenType ElseDirective;
    public static FormattingTokenType ElifDirective;
    public static FormattingTokenType EndIfDirective;
    public static FormattingTokenType DefineDirective;
    public static FormattingTokenType UndefDirective;
    public static FormattingTokenType LineDirective;
    public static FormattingTokenType ErrorDirective;
    public static FormattingTokenType WarningDirective;
    public static FormattingTokenType RegionDirective;
    public static FormattingTokenType EndRegionDirective;
    public static FormattingTokenType PragmaDirective;
    public static FormattingTokenType Add;
    public static FormattingTokenType Remove;
    public static FormattingTokenType InstanceOf;
    public static FormattingTokenType Delete;
    public static FormattingTokenType Assembly;
    public static FormattingTokenType Constructor;
    public static FormattingTokenType Field;
    public static FormattingTokenType Method;
    public static FormattingTokenType Parameter;
    public static FormattingTokenType Param;
    public static FormattingTokenType ReturnValue;
    public static FormattingTokenType EqualEqualEqual;
    public static FormattingTokenType ExclamationEqualEqual;
    public static FormattingTokenType GreatThanGreatThanGreatThan;
    public static FormattingTokenType GreatThanGreatThan;
    public static FormattingTokenType DotDotDot;
    public static FormattingTokenType Key;
    public static FormattingTokenType WhitespaceUnderline;
    public static FormattingTokenType IIf;
    public static FormattingTokenType NumberSign;
    public static FormattingTokenType ColonEquals;
    public static FormattingTokenType Distinct;
    public static FormattingTokenType Infer;
    public static FormattingTokenType Strict;
    public static FormattingTokenType Compare;
    public static FormattingTokenType Binary;
    public static FormattingTokenType Text;
    public static FormattingTokenType Off;
    public static FormattingTokenType Preserve;
    public static FormattingTokenType Until;
    public static FormattingTokenType Finalize;
    public static FormattingTokenType Custom;
    public static FormattingTokenType PCDATA;
    public static FormattingTokenType Notation;
    public static FormattingTokenType System;
    public static FormattingTokenType NData;
    public static FormattingTokenType Entity;
    public static FormattingTokenType Page;
    public static FormattingTokenType XmlCommentClose;
    public static FormattingTokenType XmlCommentOpen;
    public static FormattingTokenType Grad;
    public static FormattingTokenType Rad;
    public static FormattingTokenType Deg;
    public static FormattingTokenType Khz;
    public static FormattingTokenType Hz;
    public static FormattingTokenType Px;
    public static FormattingTokenType Cm;
    public static FormattingTokenType Mm;
    public static FormattingTokenType Pt;
    public static FormattingTokenType Pc;
    public static FormattingTokenType Em;
    public static FormattingTokenType Ex;
    public static FormattingTokenType Ms;
    public static FormattingTokenType S;
    public static FormattingTokenType Important;
    public static FormattingTokenType TildeEqual;
    public static FormattingTokenType Doctype;
    public static FormattingTokenType ExclamationElement;
    public static FormattingTokenType Empty;
    public static FormattingTokenType LessThanQuestionXml;
    public static FormattingTokenType Version;
    public static FormattingTokenType Standalone;
    public static FormattingTokenType Encoding;
    public static FormattingTokenType AtList;
    public static FormattingTokenType CDATA;
    public static FormattingTokenType BracketOpenBracketOpenGreatThen;
    public static FormattingTokenType LineContinuation;
    public static FormattingTokenType IsTrue;
    public static FormattingTokenType IsFalse;
    public static FormattingTokenType SingleQuote;
}
public enum DevExpress.CodeParser.FrameworkVersion : Enum {
    public int value__;
    public static FrameworkVersion Unknown;
    public static FrameworkVersion Version10;
    public static FrameworkVersion Version11;
    public static FrameworkVersion Version20;
    public static FrameworkVersion Version30;
    public static FrameworkVersion Version35;
    public static FrameworkVersion Version40;
    public static FrameworkVersion Version45;
}
[EditorBrowsableAttribute("1")]
public class DevExpress.CodeParser.FriendAssemblies : object {
    private static string STR_NameSeparator;
    private ArrayList _FriendAssebliesNames;
    private IElementCollection _UnresolvedExpressions;
    public int Count { get; }
    public String[] FriendAssembliesNames { get; }
    public IElementCollection UnresolvedExpressions { get; }
    private void CorrectAssemblyName(String& friendAssembly);
    public void Add(string friendAssembly);
    public void AddUnresolved(IExpression friendAssemblyExpression);
    public int get_Count();
    public String[] get_FriendAssembliesNames();
    public IElementCollection get_UnresolvedExpressions();
}
public class DevExpress.CodeParser.FromExpression : QueryExpressionBase {
    private ExpressionCollection _InExpressions;
    public ExpressionCollection InExpressions { get; }
    public LanguageElementType ElementType { get; }
    private IExpressionCollection DevExpress.CodeParser.IFromExpression.InExpressions { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddInExpressions(IEnumerable`1<Expression> inExpressions);
    public void AddInExpressions(IEnumerable`1<InExpression> inExpressions);
    public void AddInExpression(InExpression exp);
    public virtual string ToString();
    public ExpressionCollection get_InExpressions();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IFromExpression.get_InExpressions();
}
public abstract class DevExpress.CodeParser.FullDirective : object {
    private List`1<FullDirective> _NestedFull;
    private FullDirective _ParentFull;
    private SourceRange _Range;
    public List`1<PreprocessorDirective> SimpleDirectives { get; }
    public PreprocessorDirective FirstSimple { get; }
    public PreprocessorDirective LastSimple { get; }
    public List`1<FullDirective> NestedFull { get; }
    public FullDirective ParentFull { get; public set; }
    public SourceRange Range { get; public set; }
    public int StartLine { get; }
    public int EndLine { get; }
    public FullDirectiveType FullType { get; }
    public FullDirective GoToNextFull();
    public abstract virtual List`1<PreprocessorDirective> get_SimpleDirectives();
    public abstract virtual PreprocessorDirective get_FirstSimple();
    public abstract virtual PreprocessorDirective get_LastSimple();
    public List`1<FullDirective> get_NestedFull();
    public FullDirective get_ParentFull();
    public void set_ParentFull(FullDirective value);
    public SourceRange get_Range();
    public void set_Range(SourceRange value);
    public int get_StartLine();
    public int get_EndLine();
    public abstract virtual FullDirectiveType get_FullType();
}
public class DevExpress.CodeParser.FullIfDirective : FullDirective {
    private IfDirective _IfDirective;
    private List`1<ElifDirective> _ElifDirectives;
    private ElseDirective _ElseDirective;
    private EndIfDirective _EndifDirective;
    public List`1<PreprocessorDirective> SimpleDirectives { get; }
    public PreprocessorDirective FirstSimple { get; }
    public PreprocessorDirective LastSimple { get; }
    public IfDirective IfDirective { get; public set; }
    public List`1<ElifDirective> ElifDirectives { get; }
    public ElseDirective ElseDirective { get; public set; }
    public EndIfDirective EndifDirective { get; public set; }
    public PreprocessorDirective SimpleIsSatisfied { get; }
    public PreprocessorDirective SimpleAfterSimpleIsSatisfied { get; }
    public FullDirectiveType FullType { get; }
    public virtual List`1<PreprocessorDirective> get_SimpleDirectives();
    public virtual PreprocessorDirective get_FirstSimple();
    public virtual PreprocessorDirective get_LastSimple();
    public IfDirective get_IfDirective();
    public void set_IfDirective(IfDirective value);
    public List`1<ElifDirective> get_ElifDirectives();
    public ElseDirective get_ElseDirective();
    public void set_ElseDirective(ElseDirective value);
    public EndIfDirective get_EndifDirective();
    public void set_EndifDirective(EndIfDirective value);
    public PreprocessorDirective get_SimpleIsSatisfied();
    public PreprocessorDirective get_SimpleAfterSimpleIsSatisfied();
    public virtual FullDirectiveType get_FullType();
}
public class DevExpress.CodeParser.FullRegionDirective : FullDirective {
    private RegionDirective _RegionDirective;
    private EndRegionDirective _EndRegionDirective;
    public List`1<PreprocessorDirective> SimpleDirectives { get; }
    public PreprocessorDirective FirstSimple { get; }
    public PreprocessorDirective LastSimple { get; }
    public RegionDirective RegionDirective { get; public set; }
    public EndRegionDirective EndRegionDirective { get; public set; }
    public FullDirectiveType FullType { get; }
    public virtual List`1<PreprocessorDirective> get_SimpleDirectives();
    public virtual PreprocessorDirective get_FirstSimple();
    public virtual PreprocessorDirective get_LastSimple();
    public RegionDirective get_RegionDirective();
    public void set_RegionDirective(RegionDirective value);
    public EndRegionDirective get_EndRegionDirective();
    public void set_EndRegionDirective(EndRegionDirective value);
    public virtual FullDirectiveType get_FullType();
}
public class DevExpress.CodeParser.FunctionPointerTypeReference : TypeReferenceExpression {
    private AccessSpecifiers _AccessSpecifiers;
    private TypeReferenceExpression _ReturnType;
    private LanguageElementCollection _Parameters;
    private CallingConventionSpecifier _CallingConvention;
    public AccessSpecifiers AccessSpecifiers { get; }
    public CallingConventionSpecifier CallingConvention { get; public set; }
    public LanguageElementType ElementType { get; }
    public LanguageElementCollection Parameters { get; public set; }
    public int ParametersCount { get; }
    public TypeReferenceExpression ReturnType { get; public set; }
    private IElementCollection DevExpress.CodeParser.IFunctionPointerTypeReference.Parameters { get; }
    private int DevExpress.CodeParser.IFunctionPointerTypeReference.ParametersCount { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.IFunctionPointerTypeReference.ReturnType { get; }
    public FunctionPointerTypeReference(TypeReferenceExpression returnType, LanguageElementCollection parameters, CallingConventionSpecifier callingConvention);
    private void SetReturnType(TypeReferenceExpression returnType);
    private void SetParameters(LanguageElementCollection parameters);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public void AddParameter(Param parameter);
    public void AddParameters(IEnumerable`1<Param> parameters);
    public AccessSpecifiers get_AccessSpecifiers();
    public CallingConventionSpecifier get_CallingConvention();
    public void set_CallingConvention(CallingConventionSpecifier value);
    public virtual LanguageElementType get_ElementType();
    public LanguageElementCollection get_Parameters();
    public void set_Parameters(LanguageElementCollection value);
    public int get_ParametersCount();
    public TypeReferenceExpression get_ReturnType();
    public void set_ReturnType(TypeReferenceExpression value);
    private sealed virtual override IElementCollection DevExpress.CodeParser.IFunctionPointerTypeReference.get_Parameters();
    private sealed virtual override int DevExpress.CodeParser.IFunctionPointerTypeReference.get_ParametersCount();
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.IFunctionPointerTypeReference.get_ReturnType();
}
public enum DevExpress.CodeParser.GCReferenceType : Enum {
    public int value__;
    public static GCReferenceType None;
    public static GCReferenceType GC;
    public static GCReferenceType NoGC;
    public static GCReferenceType Pin;
    public static GCReferenceType Box;
}
public class DevExpress.CodeParser.GenArgs : object {
    private bool _SaveFormat;
    private bool _GenCommentsFromToken;
    private bool _GeneratingInSupportElement;
    private bool _CalculateIndent;
    private string _LanguageId;
    public bool SaveFormat { get; public set; }
    public bool GenCommentsFromToken { get; public set; }
    public bool GeneratingInSupportElement { get; public set; }
    public string LanguageId { get; public set; }
    public bool CalculateIndent { get; public set; }
    public bool IsEmptyLanguage { get; }
    public GenArgs(bool genCommentsFromToken);
    public GenArgs(bool saveFormat, bool calculateIndent, string languageId);
    public bool get_SaveFormat();
    public void set_SaveFormat(bool value);
    public bool get_GenCommentsFromToken();
    public void set_GenCommentsFromToken(bool value);
    public bool get_GeneratingInSupportElement();
    public void set_GeneratingInSupportElement(bool value);
    public string get_LanguageId();
    public void set_LanguageId(string value);
    public bool get_CalculateIndent();
    public void set_CalculateIndent(bool value);
    public bool get_IsEmptyLanguage();
}
public abstract class DevExpress.CodeParser.GeneratedParserBase : ParserBase {
    private static int minErrDist;
    protected static bool T;
    protected static bool x;
    protected int errDist;
    protected Token tToken;
    protected Token la;
    protected GeneratedScannerBase scanner;
    protected Boolean[0...,0...] set;
    protected int maxTokens;
    private TextStringCollection _TextStrings;
    private LanguageElement _RootNode;
    public TextStringCollection TextStrings { get; }
    public LanguageElement RootNode { get; }
    public CommentCollection Comments { get; }
    protected abstract virtual Boolean[0...,0...] CreateSetArray();
    protected virtual void Get();
    protected void AddNamespaceToDeclaredList(Namespace declaredNamespace);
    protected virtual void CheckForErrors(LanguageElement rootNode);
    protected virtual void HandlePragmas();
    protected Token Peek();
    protected Token Peek(int pos);
    protected void ResetPeek();
    protected void Expect(int n);
    protected void ExpectWeak(int n, int follow);
    protected bool WeakSeparator(int n, int syFol, int repFol);
    protected void SynErr(int n);
    protected void SemErr(string msg);
    protected bool StartOf(int s);
    protected static SourceRange GetRange(object a, object b);
    protected static SourceRange GetRange(object a);
    protected static SourceRange GetRange(Object[] objs);
    protected virtual void BindComments();
    protected virtual void SetRootNode(LanguageElement newContext);
    protected void OpenContextWithoutAddNode(LanguageElement newContext);
    protected virtual void OpenContext(LanguageElement newContext);
    protected virtual void CloseContext();
    protected void ReadBlockStart(SourceRange range);
    protected void ReadBlockEnd(SourceRange range);
    protected virtual void AddNode(LanguageElement node);
    protected virtual void AddDetailNode(LanguageElement detailNode);
    protected virtual void SetContextEnd(SourcePoint end);
    protected virtual void CleanUpParser();
    protected virtual LanguageElement CallParsing(ParserContext parserContext, ISourceReader reader);
    protected Token ConcatTokens(Token left, Token right);
    protected Token ConcatTokens(Token left, Token right, int kind, string val);
    private string GetAssemblyName(Attribute attributeDef);
    private SourceFile GetFileNode();
    protected void ProcessAttribute(Attribute attribute);
    public virtual bool SupportsFileExtension(string ext);
    public virtual ExpressionParserBase CreateExpressionParser();
    public virtual IExpressionInverter CreateExpressionInverter();
    public virtual string GetFullTypeName(string simpleName);
    public TextStringCollection get_TextStrings();
    public LanguageElement get_RootNode();
    public virtual CommentCollection get_Comments();
}
public abstract class DevExpress.CodeParser.GeneratedScannerBase : object {
    private ISourceReader _SourceReader;
    private CharProvider _CharProvider;
    private bool _OwnReader;
    private bool _IsDisposed;
    private bool _SaveFormat;
    protected static char EOF;
    protected static char EOL;
    protected static int eofSym;
    protected char ch;
    protected int pos;
    protected int lineValue;
    protected int lineStart;
    protected int prevLineStart;
    protected int prevLine;
    protected BitArray ignore;
    protected Token t;
    protected Token pt;
    protected Token tokens;
    protected Char[] tval;
    protected int tlen;
    public ISourceReader SourceReader { get; }
    public CharProvider CharProvider { get; }
    public int Position { get; }
    public int Line { get; }
    public int Column { get; }
    public char CurrentChar { get; }
    public bool IsDisposed { get; }
    public bool SaveFormat { get; public set; }
    public int EndLineValue { get; }
    internal Token tToken { get; }
    private void CreateFormatingToken();
    private void SetFormatingElement(FormattingToken formatingToken, FormattingElements formatingElement);
    internal FormattingElements GetFormatingTokenElement();
    internal FormattingElement CreateFormatingTokenElement(char ch);
    protected void Initialize(ISourceReader s);
    protected void Initialize(ISourceReader s, bool ownReader);
    protected void IntializeReader(ISourceReader s);
    protected static SourceRange GetRange(object a, object b);
    protected static SourceRange GetRange(object a);
    protected static SourceRange GetRange(Object[] objs);
    protected void BackTrackScannerToToken();
    protected virtual void AddCh();
    protected virtual void NextCh();
    protected virtual Token CreateToken();
    protected virtual void InitializeIgnoreTable();
    protected virtual int GetUnicodeLetterIndex();
    protected virtual int GetNextState(int input);
    protected virtual void NextChCasing();
    protected virtual Token NextToken();
    protected virtual bool NextTokenStart();
    protected virtual void NextTokenComments();
    protected virtual void NextTokenScan(int state);
    protected virtual void NextTokenAfterScan();
    protected virtual void NextTokenEnd();
    protected virtual void SetInPreprocess();
    protected virtual void ResetInPreprocess();
    protected virtual void SkipIgnoredChars();
    protected virtual FormattingElements GetNextFormattingTokenElements();
    protected virtual bool NeedSaveFormat();
    protected virtual bool IsFormatChar(char ch);
    protected virtual bool IsWSChar(char ch);
    protected virtual bool IsTabChar(char ch);
    protected virtual bool IsEOLChar(char ch);
    protected virtual bool IsCRChar(char ch);
    public sealed virtual void Dispose();
    public virtual Token Scan();
    public Token Peek(int pos);
    public virtual Token Peek();
    public void ResetPeek();
    public void SyncPosition(int positionDelta);
    public void SyncPosition(int positionDelta, bool addChars);
    public void SetTokens(Token newTokens);
    public Token GetTokens();
    public Token GetPt();
    public void SetOnPeek(Token oldPt, Token newPt);
    public bool IsUnicodeLetter(char ch);
    public string FirstSkip();
    public bool IsEof(StringBuilder sb);
    public bool IsNextChar(char c, StringBuilder sb);
    public virtual ISourceReader get_SourceReader();
    public CharProvider get_CharProvider();
    public virtual int get_Position();
    public int get_Line();
    public int get_Column();
    public char get_CurrentChar();
    public bool get_IsDisposed();
    public void set_SaveFormat(bool value);
    public bool get_SaveFormat();
    public int get_EndLineValue();
    internal Token get_tToken();
}
public class DevExpress.CodeParser.GeneratingElements : List`1<LanguageElement> {
    public void Push(LanguageElement element);
    public LanguageElement Peek();
    public LanguageElement Pop();
}
public class DevExpress.CodeParser.GenericModifier : CodeElement {
    private TypeParameterCollection _TypeParameters;
    public TypeParameterCollection TypeParameters { get; }
    public LanguageElementType ElementType { get; }
    protected bool HasOuterRangeChildren { get; }
    public GenericModifier(TypeParameterCollection types);
    public GenericModifier(TypeParameterCollection types, SourceRange range);
    private void GetTypeParametersFromDetailNodes();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddTypeParameter(TypeParameter typeParameter);
    public void InsertTypeParameter(int index, TypeParameter typeParameter);
    public void RemoveTypeParameter(TypeParameter typeParameter);
    public virtual string ToString();
    public TypeParameterCollection get_TypeParameters();
    public virtual LanguageElementType get_ElementType();
    protected virtual bool get_HasOuterRangeChildren();
}
public class DevExpress.CodeParser.GenTextArgs : object {
    private FormattingTokenType _Type;
    private int _Index;
    private string _Text;
    private bool _SplitLines;
    private CodeGen _CodeGen;
    private int _ContextsIndex;
    public bool SplitLines { get; public set; }
    public int Index { get; public set; }
    public string Text { get; public set; }
    public FormattingTokenType Type { get; public set; }
    public int ContextsIndex { get; public set; }
    public bool IsEmpty { get; }
    public LanguageElement Context { get; }
    public GenTextArgs(CodeGen codeGen, string tokenText, bool split);
    public GenTextArgs(CodeGen codeGen, FormattingTokenType tokenType, int index);
    public GenTextArgs(CodeGen codeGen, FormattingTokenType tokenType, int index, string tokenText);
    public GenTextArgs(CodeGen codeGen, int contextsIndex, FormattingTokenType tokenType, int index, string tokenText);
    public bool get_SplitLines();
    public void set_SplitLines(bool value);
    public int get_Index();
    public void set_Index(int value);
    public string get_Text();
    public void set_Text(string value);
    public FormattingTokenType get_Type();
    public void set_Type(FormattingTokenType value);
    public int get_ContextsIndex();
    public void set_ContextsIndex(int value);
    public bool get_IsEmpty();
    private void SetTokenText(FormattingTokenType type);
    public LanguageElement get_Context();
}
public class DevExpress.CodeParser.Get : PropertyAccessor {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    [EditorBrowsableAttribute("1")]
protected ITypeReferenceExpression Type { get; }
    [EditorBrowsableAttribute("1")]
public MethodTypeEnum MethodType { get; }
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    protected virtual ITypeReferenceExpression get_Type();
    public virtual MethodTypeEnum get_MethodType();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.GetXmlNamespaceOperator : MethodCallExpression {
    public LanguageElementType ElementType { get; }
    public GetXmlNamespaceOperator(Expression source);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.GlobalStringStorage : object {
    private static object _InstanceLock;
    private static GlobalStringStorage _Instance;
    private Dictionary`2<string, string> _Strings;
    private int _UpdatesCount;
    private bool Updating { get; }
    public static GlobalStringStorage Instance { get; }
    private static GlobalStringStorage();
    private bool BeginUpdateInternal();
    private bool EndUpdateInternal();
    private bool get_Updating();
    public string InternString(string s);
    public bool IsInternedString(string s);
    public void ClearStrings();
    public static string Intern(string s);
    public static bool IsInterned(string s);
    public static void Clear();
    public static void BeginUpdate();
    public static void EndUpdate();
    public static GlobalStringStorage get_Instance();
}
public class DevExpress.CodeParser.Goto : FlowBreak {
    private static int INT_MaintainanceComplexity;
    private SourceRange _LabelRange;
    private bool _IsGotoCaseLabel;
    private bool _IsGotoCaseDefault;
    private string _Label;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public string Label { get; public set; }
    public bool IsGotoCaseLabel { get; public set; }
    public bool IsGotoCaseDefault { get; public set; }
    public SourceRange LabelRange { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual string ToString();
    public virtual int GetImageIndex();
    private LanguageElement FindCaseTarget();
    public virtual LanguageElement FindTarget();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public string get_Label();
    public void set_Label(string value);
    public bool get_IsGotoCaseLabel();
    public void set_IsGotoCaseLabel(bool value);
    public bool get_IsGotoCaseDefault();
    public void set_IsGotoCaseDefault(bool value);
    public SourceRange get_LabelRange();
    public void set_LabelRange(SourceRange value);
}
public class DevExpress.CodeParser.GroupByExpression : QueryExpressionBase {
    private LanguageElementCollection _GroupList;
    private LanguageElementCollection _ByList;
    private LanguageElementCollection _IntoElements;
    private IElementCollection DevExpress.CodeParser.IGroupByExpression.GroupList { get; }
    private IElementCollection DevExpress.CodeParser.IGroupByExpression.IntoElements { get; }
    private IElementCollection DevExpress.CodeParser.IGroupByExpression.ByList { get; }
    public LanguageElementCollection ByList { get; }
    public LanguageElementType ElementType { get; }
    public LanguageElementCollection GroupList { get; }
    public LanguageElementCollection IntoElements { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    private sealed virtual override IElementCollection DevExpress.CodeParser.IGroupByExpression.get_GroupList();
    private sealed virtual override IElementCollection DevExpress.CodeParser.IGroupByExpression.get_IntoElements();
    private sealed virtual override IElementCollection DevExpress.CodeParser.IGroupByExpression.get_ByList();
    public void AddIntoElements(IEnumerable`1<LanguageElement> elements);
    public sealed virtual void AddIntoElement(LanguageElement element);
    public void AddGroupElements(IEnumerable`1<LanguageElement> elements);
    public void AddGroupElement(LanguageElement element);
    public void AddByElements(IEnumerable`1<LanguageElement> elements);
    public void AddByElement(LanguageElement element);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public LanguageElementCollection get_ByList();
    public virtual LanguageElementType get_ElementType();
    public LanguageElementCollection get_GroupList();
    public sealed virtual LanguageElementCollection get_IntoElements();
}
public abstract class DevExpress.CodeParser.HandlerStatement : Statement {
    private Expression _Expression;
    private Expression _AddressExpression;
    public Expression Expression { get; public set; }
    public Expression AddressExpression { get; public set; }
    private IExpression DevExpress.CodeParser.IHandlerStatement.Expression { get; }
    private IExpression DevExpress.CodeParser.IHandlerStatement.AddressExpression { get; }
    public HandlerStatement(Expression expression, Expression address);
    protected void SetExpression(Expression expression);
    protected void SetAddressExpression(Expression address);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual void CleanUpOwnedReferences();
    public virtual int GetImageIndex();
    public virtual string ToString();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public Expression get_AddressExpression();
    public void set_AddressExpression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IHandlerStatement.get_Expression();
    private sealed virtual override IExpression DevExpress.CodeParser.IHandlerStatement.get_AddressExpression();
}
public static class DevExpress.CodeParser.HashtableUtils : object {
    public static Hashtable CreateHashtable(bool caseSensitive);
}
public class DevExpress.CodeParser.Html.AspHelper : object {
    public static bool IsWebHandlerFile(SourceFile file);
}
internal class DevExpress.CodeParser.Html.HtmlLanguageUtils : LanguageUtils {
    public virtual Tokenizer CreateTokenizer();
    public virtual ParserBase CreateParser(ParserVersion version, EmbededLanguageKind languageKind, DotNetLanguageType embededLanguage);
    public virtual CodeGen CreateCodeGen();
    public virtual ElementBuilder CreateElementBuilder();
}
public class DevExpress.CodeParser.Html.HtmlParser : XmlLanguageParserBase {
    private static int AspLanguageTokenBlock;
    private static int AspTokenBlockStart;
    private static int AspTokenBlockEnd;
    private static int AspCommentTokenBlock;
    private static int MaxElementNestingLevel;
    private static string STR_StartTag;
    private static string STR_EndTag;
    private ScriptLanguageType _DefaultScriptLanguage;
    private DotNetLanguageType _DefaultDotNetLanguage;
    private ParserBase _VbParser;
    private CSharp30Parser _CsExpressionParser;
    private int _FirstTokenStartPosition;
    protected int ElementNestingLevel;
    protected ExpressionCollection InlineExpressions;
    private static Hashtable _OptionalEndTagElements;
    protected static Hashtable EmptyElements;
    protected static Hashtable HtmlElementTypes;
    protected List`1<SourceRange> BlockRanges;
    protected List`1<SourceRange> FictiveCommentRanges;
    protected SourceRange FictiveCommentStart;
    protected SourceRange SourceFileStartRange;
    protected SourceRange SourceFileEndRange;
    protected bool InsideAttribute;
    protected bool AspEmbCodeIsName;
    protected int PosOffset;
    protected int TopLevelReturnCount;
    protected static Hashtable EventAttributeNames;
    protected bool WorkAsXAMLParser;
    protected bool IsRazor;
    private AspCodeEmbedding _StringEmbedding;
    protected HtmlScanner HtmlScanner { get; }
    public string Language { get; }
    public ScriptLanguageType DefaultScriptLanguage { get; public set; }
    public DotNetLanguageType DefaultDotNetLanguage { get; public set; }
    public HtmlParser(bool workAsXAMLParser);
    public HtmlParser(bool workAsXAMLParser, DotNetLanguageType codeEmbeddingDefaultLanguage);
    public HtmlParser(bool isRazorParser, bool workAsXAMLParser, DotNetLanguageType codeEmbeddingDefaultLanguage);
    protected virtual void HandlePragmas();
    private void Parser();
    private void ParserCore();
    private void Comment();
    private void Element();
    private void HtmlText();
    private void Prolog();
    private void Name();
    private void Misc();
    private void PI(XmlProcessingInstruction& processingInstruction, bool insideElementContent);
    private void DocTypeDecl();
    private void ExternalID(NewExternalIDLink& extID);
    private void IntSubset(XmlDocTypeDecl docTypeDecl);
    private void MarkupDecl(XmlDocTypeDecl docTypeDecl);
    private void DeclSep(XmlDocTypeDecl docTypeDecl);
    private void ElementDecl(XmlElementDecl& elementDecl);
    private void AttlistDecl(XmlAttributeListDeclaration& result);
    private void EntityDecl(XmlEntityDecl& entityDecl);
    private void NotationDecl(XmlNotationDecl& notationDecl);
    private void PEReference(XmlNameReference& nameRef);
    private void ContentSpec(XmlBaseContentSpec& contentSpec);
    private void Mixed(XmlMixedContentSpec& contentSpec);
    private void Children(XmlChildrenContentSpec& children);
    private void CpSequence(XmlContentParticle& choiceCP);
    private void Cp(XmlContentParticle& contentParticle);
    private void AttDef(XmlAttributeDeclaration& attrDecl);
    private void AttType(XmlAttributeDeclaration attrDecl);
    private void DefaultDecl(XmlAttributeDeclaration attrDecl);
    private void TokenizedType(XmlAttributeDeclaration attrDecl);
    private void Enumeration(XmlAttributeDeclaration attrDecl);
    private void QuotedLiteral(Token& stringToken);
    private void EntityDef(XmlEntityDecl entityDecl);
    private void Attribute(HtmlAttribute& attribute);
    private void CDSect();
    private void AspDirectiveDef();
    private void AspCodeEmbedding(AspCodeEmbedding& codeEmbedding);
    private void RazorEmbedding();
    private void ElementStart(HtmlElement& htmlElement, Boolean& shouldReturn);
    private void ElementEnd(HtmlElement htmlElement, Boolean& shouldReturn);
    private void Reference();
    private void RazorText();
    private void RazorModel();
    private void RazorInherits();
    private void RazorSection();
    private void RazorHelper();
    private void RazorFunctions();
    private void AttributeCore(HtmlAttribute& attribute);
    private void Parse();
    protected virtual Boolean[0...,0...] CreateSetArray();
    private void InitializeParser();
    protected void FillOptionalEndElementsTable();
    private void FillOptionalEndElementsForCOLGROUP();
    private void FillOptionalEndElementsForDD();
    private void FillOptionalEndElementsForDT();
    private void FillOptionalEndElementsForOPTION();
    private void FillOptionalEndElementsForP();
    private void FillOptionalEndElementsForTBODY();
    private void FillOptionalEndElementsForTFOOT();
    private void FillOptionalEndElementsForTHEAD();
    private void FillOptionalEndElementsForTR();
    private void FillOptionalEndElementsForTH();
    private void FillOptionalEndElementsForTD();
    private void FillOptionalEndElementsForLI();
    public LanguageElement Parse(ISourceReader reader);
    private void AddComment(Comment comment);
    private bool IsHttpPath(string path);
    private HtmlScanner CreateScanner(ISourceReader reader);
    private void SplitRazorDerectiveTokenIfNeeded();
    private ISourceReader GetRazorReader(int htmlScannerPosition, int startLine, int startColumn);
    private void ParseRazorText(string text, SourceRange textRange);
    public LanguageElementCollection ParseRazorTextLine(SourceStringReader reader);
    public LanguageElementCollection ParseSingleElement(ISourceReader reader, Int32& scannerPositionDelta);
    public void ParseRazorInlineExpressionInString(int pos, ISourceReader sourceReader);
    protected void ParseRazorFunctions();
    protected void ParseRazorHelper();
    protected void ParseRazorEmbedding();
    private LanguageElement ParseWebHandler(ParserContext parserContext, ISourceReader reader);
    protected virtual LanguageElement DoParse(ParserContext parserContext, ISourceReader reader);
    private void AddBlockElements(Hashtable validNestedElements);
    private void AddInlineElements(Hashtable validNestedElements);
    private void AddFlowElements(Hashtable validNestedElements);
    private void FillEventAttributeNames();
    private DotNetLanguageType GetDotNetLanguageFromString(string language);
    private void GetDefaultScriptFromVs(HtmlElement element);
    private void GetDefaultScriptFromHttpEq(HtmlElement element);
    private void SetDefaultScriptLanguage(string language);
    private void SetDefaultLanguage(string language);
    private int GetInlineCodeStart(string text);
    private CSharp30Parser GetCsParser();
    private TokenCategorizedParserBase GetParserByLanguageType(DotNetLanguageType languageType, bool aspxExpressionParser);
    private void ClearFictiveCommentStart();
    private void SetLastFictiveComment();
    private void AddFictiveCommentRange(SourceRange codeEmbeddingRange);
    private void CheckForInlineExpression(ArrayList codeEmbeddings);
    private int GetEqualityOrHashPos(string text);
    private string GetFictiveString(SourceRange rangeStart, SourceRange rangeEnd);
    private ArrayList GetAspCodeEmbeddingsFromAttributes(HtmlAttributeCollection attributes, SourceRange& codeBlockRange);
    private ArrayList GetAspCodeEmbeddingsFromAttribute(HtmlAttribute node, SourceRange& codeBlockRange, bool shouldAddBlock);
    private bool CanGetAspEmbCode(LanguageElement node);
    private ArrayList GetAspCodeEmbeddingsFromNode(ArrayList runAtServer, ArrayList nodes, LanguageElement node);
    private Expression ParseInlineExpression(string inlineCode, int startLine, int startOffset, Token codeEmbeddingToken);
    private void ReplaceEmbeddingToken(Token codeEmbeddingToken, TokenCollection embeddingTokens);
    private string GetCodeEmbeddingsText(ArrayList aspTokenBlocks, ArrayList aspCodeEmbeddings, ArrayList runAtServerNodes, ArrayList nodes, Int32& startLine, Int32& startOffset);
    private void SplitAspTokenBlocks(ArrayList aspTokenBlocks, ArrayList runAtServerNodes);
    private int FindAspTokenBlock(ArrayList aspTokenBlocks, SourcePoint point);
    private void SplitStartAspTokenBlock(ArrayList aspTokenBlocks, HtmlElement node);
    private void SplitEndAspTokenBlock(ArrayList aspTokenBlocks, HtmlElement node);
    private void SplitAspCommentBlocks(ArrayList aspTokenBlocks, ArrayList nodes);
    private ArrayList GetNodesInRange(ArrayList nodes, SourceRange range);
    private void SplitAspCommentBlock(ArrayList aspTokenBlocks, TokenBlock block, ArrayList nodes);
    private void InsertBlockNodes(LanguageElement rootNode, NodeList blockNodes, int insertAtIndex);
    private void InsertCodeBlocks(LanguageElement rootNode);
    private ParserBase CreateJavaScriptParser();
    private bool IsScriptBlockWithoutLanguageInformation(HtmlScriptDefinition script);
    private ParserBase GetClientSideParser(HtmlScriptDefinition script);
    private void SetClientSideScriptTypeByAttributeValue(string value, HtmlScriptDefinition script);
    private void ParseClientSideScript(HtmlScriptDefinition script);
    private string RemoveHtmlCommentEndIfNeeded(string scriptText);
    private LanguageElement GetRootNodeForScript(ParserBase parser, string scriptText, SourcePoint strtPoint);
    private void ParseEmbeddedCode(LanguageElement element, ParserBase parser, string scriptText, SourcePoint strtPoint);
    private bool IsScriptLanguage(DotNetLanguageType currentLanguage);
    private void ParseServerSideScript(HtmlScriptDefinition script);
    protected void ParseScript(HtmlScriptDefinition script);
    protected void ParseStyleDefinition(HtmlStyleDefinition styleTag);
    private string GetAttributeValue(AspDirective directive, string attributeName);
    private void SetCodeBehindFileName(SourceFile fileNode, AspDirective directive);
    private void SetAspPageBaseType(SourceFile rootFile, AspDirective directive);
    public string ExtractModelFromPageOrControlDirective(LanguageElement modelDirective);
    private void InsertFictiveCommentInProperPlace(LanguageElement root, SourceRange fictiveCommentRange);
    private LanguageElement CreateFictiveComment(SourceRange range);
    private void InsertInlineExpressionsStatements(LanguageElement root);
    private bool InsertInlineExpressionStatement(LanguageElement root, LanguageElement node);
    private void GetBlockNodes(NodeList blockNodes, LanguageElement rootNode, SourceRange currentBlockRange, Int32& insertAtIndex);
    private void SetServerSideScriptType(HtmlScriptDefinition script);
    private void SetClientSideScriptType(HtmlScriptDefinition script);
    private DotNetLanguageType GetScriptLanguage(ScriptLanguageType defaultScriptLanguage);
    private ParserBase GetClientSideParser(DotNetLanguageType codeLanguage);
    protected void AddToUsingList(SourceFile fileNode, AspImportDirective directive);
    protected void SetSourceFileProperties(SourceFile fileNode, AspDirective directive, DotNetLanguageType language);
    protected void SetMasterPageFile(SourceFile fileNode, string masterPageFile);
    protected void SplitAspDirectiveTagStartIfNeeded();
    protected void SplitInlineExpressionIfNeeded();
    protected bool ShouldCloseEmptyTag(string tagName);
    protected void MoveNodesInsideElement(LanguageElement newParentElement, LanguageElement activeContext);
    protected void ParseAttributeStyle(HtmlAttribute attribute);
    protected void SetupForAspDirectiveParsing(string aspDirectiveString, SourceRange aspDirectiveRange);
    protected void ParseWebHandlerDotNetCode(ParserContext parserContext, ISourceReader reader);
    protected void FillHtmlElementTypes();
    protected void FillEmptyElementsTable();
    protected bool ShouldPreventCycling();
    protected bool IsBadCloseTag(string closeTagElementName);
    private void SkipCloseTag();
    protected void SetCategoryIfNeeded(TokenCategory category);
    internal ISourceReader GetReaderForWebHandler(HtmlScannerBase scanner, ISourceReader baseReader);
    protected void ClearDefaultLanguages();
    protected bool IsWebHandlerOrWebService(HtmlElement element);
    protected DotNetLanguageType GetDefaultLanguage(HtmlElement element);
    protected string GetMasterPageFile(HtmlElement element);
    protected void GetDefaultScript(HtmlElement element);
    protected void SetScriptLanguageType(HtmlScriptDefinition script);
    private void CheckForRazorExpression(HtmlAttribute attribute);
    protected void CheckForInlineExpression(HtmlAttribute attribute);
    protected void PerformPostProcessing();
    private LanguageElementCollection NodeListToLanguageElementCollection(NodeList nodes);
    private LanguageElementCollection FilterRazorEmbeddingNodes(AspCodeEmbedding codeEmbedding, LanguageElementCollection nodes);
    private void InsertRazorEmbeddings(Method aspFictiveMethod, List`1<AspCodeEmbedding> razorEmbeddings);
    private void AddEmbeddingNodes(Method aspFictiveMethod, NodeList nodeList);
    private List`1<AspCodeEmbedding> GetRazorEmbeddings(ArrayList aspCodeEmbeddings);
    private void ReplaceAllEmbeddingTokens(ArrayList aspCodeEmbeddings, TokenCollection tokenCollection);
    private TokenCollection GetCodeEmbeddingsTokens(Token codeEmbeddingToken, TokenCollection savedTokens);
    private ParserContext GetAspEmbeddingsParserContext(Method aspFictiveMethod, ArrayList aspCodeEmbeddings, ArrayList runAtServerNodes, ArrayList nodes);
    private void InsertFictiveComments(LanguageElement root);
    protected bool ShouldCloseTopLevelTag(string currentTagName, string topLevelTagName);
    protected void HandleCodeEmbedding(HtmlElement htmlElement, AspCodeEmbedding codeEmbedding);
    protected void SetContextForHtmlElement(HtmlElement htmlElement, SourceRange lastTagRange, SourceRange tagOpenRange);
    protected void HandleTagClose(HtmlElement htmlElement, Boolean& shouldReturn);
    protected void HandleEndingTagClose(HtmlElement htmlElement, SourceRange tagCloseRange, Boolean& shouldReturn);
    protected void HanldeEmptyTagClose(HtmlElement htmlElement);
    protected void HandleTagCloseStart(HtmlElement htmlElement, SourceRange& tagCloseRange, Boolean& shouldReturn);
    protected void HandleClosingNameToken(HtmlElement htmlElement, SourceRange tagCloseRange, String& closeTagElementName);
    protected void TryToHandleScriptOrStyleSheets(HtmlElement htmlElement);
    protected HtmlElement CreateElement(string elementName, SourceRange elementNameRange, SourceRange openTagRange);
    protected void SetHtmlElementType(HtmlElement htmlElement, string name);
    protected virtual TokenCategory GetTokenCategory(CategorizedToken token);
    protected void CheckForEventHandlerScriptCode(HtmlAttribute attribute);
    private string GetIncludedFilePath(SourceFile fileNode, string includedFileName);
    protected void AddIncludedStyleSheetFilesItem(HtmlElement htmlLink);
    protected void AddIncludedScriptFilesItem(HtmlScriptDefinition htmlScript);
    protected HtmlScanner get_HtmlScanner();
    public virtual string get_Language();
    public ScriptLanguageType get_DefaultScriptLanguage();
    public void set_DefaultScriptLanguage(ScriptLanguageType value);
    public void set_DefaultDotNetLanguage(DotNetLanguageType value);
    public DotNetLanguageType get_DefaultDotNetLanguage();
}
public class DevExpress.CodeParser.Html.HtmlParserErrors : ParserErrorsBase {
    protected virtual string GetSyntaxErrorText(int n);
}
public class DevExpress.CodeParser.Html.HtmlScanner : HtmlScannerBase {
    private static int charSetSize;
    private static int UnicodeLetterIndex;
    private static int noSym;
    private Int16[] start;
    public HtmlScanner(ISourceReader s);
    public HtmlScanner(ISourceReader s, bool isRazor);
    protected virtual int GetUnicodeLetterIndex();
    protected virtual int GetNextState(int input);
    protected virtual void InitializeIgnoreTable();
    protected virtual void NextChCasing();
    protected virtual void AddCh();
    private void CheckLiteral();
    protected virtual void NextTokenComments();
    protected virtual void NextTokenScan(int state);
}
public abstract class DevExpress.CodeParser.Html.HtmlScannerBase : XmlScannerBase {
    private char _PreviousChar;
    private bool _ShouldCheckForAttribute;
    private static string STR_Model;
    private static string STR_Inherits;
    private static string STR_Helper;
    private static string STR_Functions;
    private static string STR_Section;
    private static string STR_CDATAStart;
    private static string STR_CDATAEnd;
    private static string STR_CodeEmbeddingStart;
    private static string STR_CodeEmbeddingEnd;
    protected int CDataTokenType { get; }
    protected int PICharsTokenType { get; }
    public int RazorStartCharToken { get; }
    public bool ShouldCheckForAttribute { get; public set; }
    protected virtual Token CreateToken();
    private void ReadRazorComment();
    private void ReadSectionName(Token sectionToken);
    private Token GetRazorStartToken();
    protected virtual void AddCh();
    private bool SkipString();
    private bool SkipCData();
    private void SkipChars(int count);
    private bool ArePeekChars(string chars);
    private bool SkipCodeEmbedding(bool isEmbeddingStart);
    public Token GetCodeEmbeddingText();
    protected virtual void NextTokenAfterScan();
    protected virtual bool NextTokenStart();
    private bool IsEmptyCloseTag();
    protected Token GetAttributeValue();
    protected virtual int get_CDataTokenType();
    protected virtual int get_PICharsTokenType();
    public int get_RazorStartCharToken();
    public Token ReadStringLiteral(int quoteTokenType, HtmlParser parser);
    public void GetAspDirectiveString(String& contentString, SourceRange& contentRange);
    public string ReadSingleLine(SourceRange& lineRange);
    public void GetElementContent(string elementName, String& contentString, SourceRange& contentRange);
    public bool get_ShouldCheckForAttribute();
    public void set_ShouldCheckForAttribute(bool value);
}
public class DevExpress.CodeParser.Html.HtmlTokensCategoryHelper : object {
    public sealed virtual TokenCategory GetUncategorizedTokenCategory(Token token);
    public sealed virtual TokenCollection GetTokens(string code);
    public TokenCollection GetTokens(string code, DotNetLanguageType codeEmbeddingLanguage);
    public sealed virtual string GetTokenCategory(Token token);
    public sealed virtual string GetTokenCategory(Token token, ParserVersion version);
}
public class DevExpress.CodeParser.Html.HtmlTokensHelper : object {
    private static void CalculatePositions(TokenCollection tokens, string code);
    public static TokenCollection GetTokens(string code);
    public static TokenCollection GetTokens(string code, LanguageKind languageKind);
    public static TokenCollection GetTokens(string code, LanguageKind languageKind, DotNetLanguageType codeEmbeddingDefaultLanguage);
    public static string GetTokenCategory(Token token);
}
public enum DevExpress.CodeParser.Html.LanguageKind : Enum {
    public int value__;
    public static LanguageKind Unknown;
    public static LanguageKind Xml;
    public static LanguageKind Html;
    public static LanguageKind Razor;
}
public enum DevExpress.CodeParser.Html.ScriptLanguageType : Enum {
    public int value__;
    public static ScriptLanguageType JavaScript;
    public static ScriptLanguageType VBScript;
    public static ScriptLanguageType Perl;
    public static ScriptLanguageType EcmaScript;
    public static ScriptLanguageType Unknown;
}
public class DevExpress.CodeParser.Html.Tokens : object {
    public static int NOTATION;
    public static int CDATATOKEN;
    public static int EMPTYTAGCLOSE;
    public static int NDATA;
    public static int TAGCLOSESTART;
    public static int CHARREF;
    public static int TAGCLOSE;
    public static int RAZORMODEL;
    public static int BRACKETOPEN;
    public static int NAME;
    public static int EMPTY;
    public static int BRACKETCLOSE;
    public static int DECL;
    public static int QUESTION;
    public static int DOCTYPE;
    public static int ASPSCRIPTTAGSTART;
    public static int PLUS;
    public static int PCDATA;
    public static int SEMICOLON;
    public static int IMPLIED;
    public static int TAGOPEN;
    public static int PARENOPEN;
    public static int FIXED;
    public static int ENTITY;
    public static int SINGLEQUOTE;
    public static int RAZORSTARTCHAR;
    public static int QUESTTAGOPEN;
    public static int COMMENT;
    public static int CDATAEND;
    public static int AMPERSAND;
    public static int STAR;
    public static int EQUALSTOKEN;
    public static int SYSTEM;
    public static int ID;
    public static int QUOTEDLITERAL;
    public static int UNQUOTEDATTRIBUTEVALUE;
    public static int RAZORINHERITS;
    public static int SERVERCOMMENT;
    public static int RAZORSTARTCHARCOLON;
    public static int PICHARS;
    public static int PERCENTSYMBOL;
    public static int IDREF;
    public static int BITWISEOR;
    public static int DOUBLEQUOTE;
    public static int RAZORSECTION;
    public static int ELEMENTDECL;
    public static int PARENCLOSE;
    public static int RAZORFUNCTIONS;
    public static int ANYCONTENT;
    public static int QUESTTAGCLOSE;
    public static int NMTOKEN;
    public static int PUBLIC;
    public static int ENTITIES;
    public static int IDREFS;
    public static int CDATA;
    public static int ASPSCRIPTTAGCLOSE;
    public static int NMTOKENS;
    public static int COMMA;
    public static int RAZORHELPER;
    public static int ASPDIRECTIVETAGSTART;
    public static int CDATASTART;
    public static int RAZORCOMMENT;
    public static int EOF;
    public static int REQUIRED;
    public static int ATTLISTDECL;
    public static int MaxTokens;
    public static Int32[] Keywords;
    private static Tokens();
}
internal class DevExpress.CodeParser.Html.XamlLanguageUtils : LanguageUtils {
    public virtual Tokenizer CreateTokenizer();
    public virtual ParserBase CreateParser(ParserVersion version, EmbededLanguageKind languageKind, DotNetLanguageType embededLanguage);
    public virtual CodeGen CreateCodeGen();
    public virtual ElementBuilder CreateElementBuilder();
}
public class DevExpress.CodeParser.Html.XmlTokensCategoryHelper : object {
    public sealed virtual TokenCategory GetUncategorizedTokenCategory(Token token);
    public sealed virtual TokenCollection GetTokens(string code);
    public sealed virtual string GetTokenCategory(Token token);
    public sealed virtual string GetTokenCategory(Token token, ParserVersion version);
}
public class DevExpress.CodeParser.HtmlAttribute : XmlAttribute {
    private bool _HasValue;
    private QuoteType _QuoteType;
    private Expression _InlineExpression;
    private CssPropertyDeclarationCollection _StyleProperties;
    private bool _ValueIsAspCodeEmbedding;
    private LanguageElementCollection _ScriptCode;
    private DotNetLanguageType _ScriptLanguage;
    public QuoteType AttributeQuoteType { get; public set; }
    public bool ValueIsAspCodeEmbedding { get; public set; }
    public bool HasValue { get; public set; }
    public LanguageElementType ElementType { get; }
    public Expression InlineExpression { get; public set; }
    public CssPropertyDeclarationCollection StyleProperties { get; public set; }
    public LanguageElementCollection ScriptCode { get; public set; }
    public DotNetLanguageType ScriptLanguage { get; public set; }
    private IExpression DevExpress.CodeParser.IHtmlAttribute.InlineExpression { get; }
    private DotNetLanguageType DevExpress.CodeParser.IHtmlAttribute.ScriptLanguage { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public QuoteType get_AttributeQuoteType();
    public void set_AttributeQuoteType(QuoteType value);
    public bool get_ValueIsAspCodeEmbedding();
    public void set_ValueIsAspCodeEmbedding(bool value);
    public bool get_HasValue();
    public void set_HasValue(bool value);
    public virtual LanguageElementType get_ElementType();
    public Expression get_InlineExpression();
    public void set_InlineExpression(Expression value);
    public CssPropertyDeclarationCollection get_StyleProperties();
    public void set_StyleProperties(CssPropertyDeclarationCollection value);
    public LanguageElementCollection get_ScriptCode();
    public void set_ScriptCode(LanguageElementCollection value);
    public DotNetLanguageType get_ScriptLanguage();
    public void set_ScriptLanguage(DotNetLanguageType value);
    private sealed virtual override IExpression DevExpress.CodeParser.IHtmlAttribute.get_InlineExpression();
    private sealed virtual override DotNetLanguageType DevExpress.CodeParser.IHtmlAttribute.get_ScriptLanguage();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.HtmlAttributeCollection : NodeList {
    public HtmlAttribute Item { get; public set; }
    public HtmlAttribute Item { get; public set; }
    private IHtmlAttribute DevExpress.CodeParser.IHtmlAttributeCollection.Item { get; }
    protected int Add(HtmlAttribute element);
    protected void AddRange(HtmlAttributeCollection collection);
    protected int IndexOf(HtmlAttribute element);
    protected void Insert(int index, HtmlAttribute element);
    protected void Remove(HtmlAttribute element);
    protected HtmlAttribute Find(HtmlAttribute element);
    protected bool Contains(HtmlAttribute element);
    protected virtual NodeList CreateInstance();
    public HtmlAttribute get_Item(int index);
    public void set_Item(int index, HtmlAttribute value);
    public HtmlAttribute get_Item(string name);
    public void set_Item(string name, HtmlAttribute value);
    private sealed virtual override IHtmlAttribute DevExpress.CodeParser.IHtmlAttributeCollection.get_Item(int index);
    private sealed virtual override int DevExpress.CodeParser.IHtmlAttributeCollection.IndexOf(IHtmlAttribute attribute);
}
public class DevExpress.CodeParser.HtmlElement : XmlElement {
    private HtmlElementType _HtmlElementType;
    private bool _IsEmptyTag;
    private SourceRange _InnerRange;
    private SourceRange _NameRange;
    private SourceRange _CloseTagNameRange;
    private HtmlAttributeCollection _Attributes;
    public LanguageElementType ElementType { get; }
    public bool IsEmptyTag { get; public set; }
    public HtmlElementType HtmlElementType { get; public set; }
    public SourceRange InnerRange { get; public set; }
    public HtmlAttributeCollection Attributes { get; }
    public SourceRange NameRange { get; public set; }
    public SourceRange CloseTagNameRange { get; public set; }
    [CategoryAttribute("Block Delimiters")]
public bool HasDelimitedBlock { get; }
    private IHtmlAttributeCollection DevExpress.CodeParser.IHtmlElement.Attributes { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    protected string GetAttributeValue(string name);
    protected void SetAttributeValue(string name, string value, QuoteType quoteType);
    protected void SetAttributeValue(string name, string value);
    public virtual int GetImageIndex();
    public HtmlElement FindHtmlElementByType(HtmlElementType type);
    public void AddAttribute(string name, string value);
    public void AddAttribute(string name, string value, QuoteType quoteType);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public bool get_IsEmptyTag();
    public void set_IsEmptyTag(bool value);
    public HtmlElementType get_HtmlElementType();
    public void set_HtmlElementType(HtmlElementType value);
    public SourceRange get_InnerRange();
    public void set_InnerRange(SourceRange value);
    public HtmlAttributeCollection get_Attributes();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public virtual SourceRange get_CloseTagNameRange();
    public virtual void set_CloseTagNameRange(SourceRange value);
    public virtual bool get_HasDelimitedBlock();
    private sealed virtual override IHtmlAttributeCollection DevExpress.CodeParser.IHtmlElement.get_Attributes();
}
public enum DevExpress.CodeParser.HtmlElementType : Enum {
    public int value__;
    public static HtmlElementType Unknown;
    public static HtmlElementType A;
    public static HtmlElementType Abbr;
    public static HtmlElementType Acronym;
    public static HtmlElementType Address;
    public static HtmlElementType Applet;
    public static HtmlElementType Area;
    public static HtmlElementType B;
    public static HtmlElementType Base;
    public static HtmlElementType Basefont;
    public static HtmlElementType Bdo;
    public static HtmlElementType Big;
    public static HtmlElementType Blockquote;
    public static HtmlElementType Body;
    public static HtmlElementType Br;
    public static HtmlElementType Button;
    public static HtmlElementType Caption;
    public static HtmlElementType Center;
    public static HtmlElementType Cite;
    public static HtmlElementType Code;
    public static HtmlElementType Col;
    public static HtmlElementType Colgroup;
    public static HtmlElementType Dd;
    public static HtmlElementType Del;
    public static HtmlElementType Dfn;
    public static HtmlElementType Dir;
    public static HtmlElementType Div;
    public static HtmlElementType Dl;
    public static HtmlElementType Dt;
    public static HtmlElementType Em;
    public static HtmlElementType Fieldset;
    public static HtmlElementType Font;
    public static HtmlElementType Form;
    public static HtmlElementType Frame;
    public static HtmlElementType Frameset;
    public static HtmlElementType H1;
    public static HtmlElementType H2;
    public static HtmlElementType H3;
    public static HtmlElementType H4;
    public static HtmlElementType H5;
    public static HtmlElementType H6;
    public static HtmlElementType Head;
    public static HtmlElementType Hr;
    public static HtmlElementType Html;
    public static HtmlElementType I;
    public static HtmlElementType Iframe;
    public static HtmlElementType Img;
    public static HtmlElementType Input;
    public static HtmlElementType Ins;
    public static HtmlElementType Isindex;
    public static HtmlElementType Kbd;
    public static HtmlElementType Label;
    public static HtmlElementType Legend;
    public static HtmlElementType Li;
    public static HtmlElementType Link;
    public static HtmlElementType Map;
    public static HtmlElementType Menu;
    public static HtmlElementType Meta;
    public static HtmlElementType Noframes;
    public static HtmlElementType Noscript;
    public static HtmlElementType Object;
    public static HtmlElementType Ol;
    public static HtmlElementType Optgroup;
    public static HtmlElementType Option;
    public static HtmlElementType P;
    public static HtmlElementType Param;
    public static HtmlElementType Pre;
    public static HtmlElementType Q;
    public static HtmlElementType S;
    public static HtmlElementType Samp;
    public static HtmlElementType Script;
    public static HtmlElementType Select;
    public static HtmlElementType Small;
    public static HtmlElementType Span;
    public static HtmlElementType Strike;
    public static HtmlElementType Strong;
    public static HtmlElementType Style;
    public static HtmlElementType Sub;
    public static HtmlElementType Sup;
    public static HtmlElementType Table;
    public static HtmlElementType Tbody;
    public static HtmlElementType Td;
    public static HtmlElementType Textarea;
    public static HtmlElementType Tfoot;
    public static HtmlElementType Th;
    public static HtmlElementType Thead;
    public static HtmlElementType Title;
    public static HtmlElementType Tr;
    public static HtmlElementType Tt;
    public static HtmlElementType U;
    public static HtmlElementType Ul;
    public static HtmlElementType Var;
}
public class DevExpress.CodeParser.HtmlScriptDefinition : HtmlElement {
    private string _ScriptText;
    private DotNetLanguageType _Language;
    private SourceRange _CodeRange;
    public LanguageElementType ElementType { get; }
    public string ScriptText { get; public set; }
    public DotNetLanguageType Language { get; public set; }
    public SourceRange CodeRange { get; public set; }
    private string DevExpress.CodeParser.IHtmlScriptDefinition.ScriptText { get; }
    private DotNetLanguageType DevExpress.CodeParser.IHtmlScriptDefinition.Language { get; }
    private TextRange DevExpress.CodeParser.IHtmlScriptDefinition.CodeRange { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual LanguageElementType get_ElementType();
    public string get_ScriptText();
    public void set_ScriptText(string value);
    public DotNetLanguageType get_Language();
    public void set_Language(DotNetLanguageType value);
    public SourceRange get_CodeRange();
    public void set_CodeRange(SourceRange value);
    private sealed virtual override string DevExpress.CodeParser.IHtmlScriptDefinition.get_ScriptText();
    private sealed virtual override DotNetLanguageType DevExpress.CodeParser.IHtmlScriptDefinition.get_Language();
    private sealed virtual override TextRange DevExpress.CodeParser.IHtmlScriptDefinition.get_CodeRange();
}
public class DevExpress.CodeParser.HtmlStyleDefinition : HtmlElement {
    private string _StyleText;
    private SourceRange _TextRange;
    public LanguageElementType ElementType { get; }
    public string StyleText { get; public set; }
    public SourceRange TextRange { get; public set; }
    private string DevExpress.CodeParser.IHtmlStyleDefinition.StyleText { get; }
    private TextRange DevExpress.CodeParser.IHtmlStyleDefinition.TextRange { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_StyleText();
    public void set_StyleText(string value);
    public SourceRange get_TextRange();
    public void set_TextRange(SourceRange value);
    private sealed virtual override string DevExpress.CodeParser.IHtmlStyleDefinition.get_StyleText();
    private sealed virtual override TextRange DevExpress.CodeParser.IHtmlStyleDefinition.get_TextRange();
}
public class DevExpress.CodeParser.HtmlText : XmlText {
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.HtmlXmlCodeGenBase : LanguageElementCodeGenBase {
    public HtmlXmlCodeGenBase(CodeGen codeGen);
    public virtual void GenerateElement(LanguageElement languageElement);
    protected virtual bool GenerateHtmlXmlNode(XmlNode xmlNode);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.HybridObjectStorage : object {
    private static int INT_MaxItemsCount;
    private Hashtable _CaseSensitiveHash;
    private Hashtable _CaseInsensitiveHash;
    private bool _LimitSize;
    private Hashtable CaseSensitiveHash { get; }
    private Hashtable CaseInsensitiveHash { get; }
    internal bool LimitSize { get; internal set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public int Count { get; }
    public object Item { get; public set; }
    private void AddItemInternal(Hashtable table, object key, object value);
    [IteratorStateMachineAttribute("DevExpress.CodeParser.HybridObjectStorage/<GetValues>d__6")]
public IEnumerable`1<object> GetValues();
    public virtual void Add(object key, object value);
    public virtual void Remove(object key);
    public virtual void Clear();
    public object Get(object key);
    public object Get(object key, bool ignoreCase);
    public virtual bool Contains(object key);
    public bool Contains(object key, bool ignoreCase);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    public virtual IDictionaryEnumerator GetEnumerator();
    public String[] GetAllNames(bool caseSensitive);
    public Hashtable GetCaseSensitiveHash();
    public Hashtable GetCaseInsensitiveHash();
    public Hashtable GetHashTable(bool isCaseSensitive);
    private Hashtable get_CaseSensitiveHash();
    private Hashtable get_CaseInsensitiveHash();
    internal bool get_LimitSize();
    internal void set_LimitSize(bool value);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual int get_Count();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
}
public interface DevExpress.CodeParser.IAbortStatement {
}
public interface DevExpress.CodeParser.IAddHandlerStatement {
}
public interface DevExpress.CodeParser.IAddressOfExpression {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IAggregateExpression {
    public IExpressionCollection QueryOperators { get; }
    public IElementCollection IntoElements { get; }
    public abstract virtual IExpressionCollection get_QueryOperators();
    public abstract virtual IElementCollection get_IntoElements();
}
public interface DevExpress.CodeParser.IAliasDeclaration {
    public string AliasName { get; }
    public IExpression Expression { get; }
    public abstract virtual string get_AliasName();
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IAliasList {
    public NameValueCollection AliasList { get; }
    public abstract virtual NameValueCollection get_AliasList();
}
public interface DevExpress.CodeParser.IAnonymousConstructorExpression {
}
public interface DevExpress.CodeParser.IAnonymousMethodExpression {
    public bool IsAsynchronous { get; }
    public bool ParameterListOmitted { get; }
    public abstract virtual bool get_IsAsynchronous();
    public abstract virtual bool get_ParameterListOmitted();
}
public interface DevExpress.CodeParser.IAnonymousTypeElement {
}
public interface DevExpress.CodeParser.IAnonymousTypeReferenceExpression {
    public IAnonymousTypeElement AnonymousType { get; }
    public abstract virtual IAnonymousTypeElement get_AnonymousType();
}
public interface DevExpress.CodeParser.IArgumentDirectionExpression {
    public ArgumentDirection Direction { get; }
    public IExpression Expression { get; }
    public abstract virtual ArgumentDirection get_Direction();
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IArrayCreateExpression {
    public ITypeReferenceExpression BaseType { get; }
    public IExpressionCollection Dimensions { get; }
    public IArrayInitializerExpression Initializer { get; }
    public abstract virtual ITypeReferenceExpression get_BaseType();
    public abstract virtual IExpressionCollection get_Dimensions();
    public abstract virtual IArrayInitializerExpression get_Initializer();
}
public interface DevExpress.CodeParser.IArrayInitializerExpression {
    public IExpressionCollection Initializers { get; }
    public abstract virtual IExpressionCollection get_Initializers();
}
public interface DevExpress.CodeParser.IArrayNameModifier {
    public IExpressionCollection SizeInitializers { get; }
    public abstract virtual IExpressionCollection get_SizeInitializers();
}
public interface DevExpress.CodeParser.IArrayTypeElement {
    public ITypeElement BaseType { get; }
    public int Rank { get; }
    public abstract virtual ITypeElement get_BaseType();
    public abstract virtual int get_Rank();
}
public interface DevExpress.CodeParser.IAspCodeEmbedding {
}
public interface DevExpress.CodeParser.IAspDirective {
}
public interface DevExpress.CodeParser.IAspSourceFile {
    public LanguageElement Asp { get; }
    public LanguageElement Code { get; }
    public StringCollection IncludedScriptFiles { get; }
    public StringCollection IncludedStyleSheetFiles { get; }
    public string MasterPageFile { get; }
    public string ModelTypeName { get; }
    public abstract virtual LanguageElement get_Asp();
    public abstract virtual LanguageElement get_Code();
    public abstract virtual StringCollection get_IncludedScriptFiles();
    public abstract virtual StringCollection get_IncludedStyleSheetFiles();
    public abstract virtual string get_MasterPageFile();
    public abstract virtual string get_ModelTypeName();
}
public interface DevExpress.CodeParser.IAssemblyModel {
    public IAssemblyReference Assembly { get; }
    public String[] FriendAssemblyNames { get; }
    public abstract virtual IElement FindElementByFullName(string fullName, bool ignoreCase);
    public abstract virtual void CompleteElement(IElement element, bool full);
    public abstract virtual void CompleteElementIfNeeded(IElement element);
    public abstract virtual IAssemblyReference get_Assembly();
    public abstract virtual String[] get_FriendAssemblyNames();
}
public interface DevExpress.CodeParser.IAssemblyReference {
    public string Name { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public interface DevExpress.CodeParser.IAssignmentExpression {
    public AssignmentOperatorType AssignmentOperatorType { get; }
    public abstract virtual AssignmentOperatorType get_AssignmentOperatorType();
}
public interface DevExpress.CodeParser.IAssignmentStatement {
    public IExpression LeftSide { get; }
    public IExpression Expression { get; }
    public AssignmentOperatorType AssignmentOperator { get; }
    public abstract virtual IExpression get_LeftSide();
    public abstract virtual IExpression get_Expression();
    public abstract virtual AssignmentOperatorType get_AssignmentOperator();
}
public interface DevExpress.CodeParser.IAttributeElement {
    public IExpressionCollection Arguments { get; }
    public IExpression Qualifier { get; }
    public bool HasTargetNode { get; }
    public AttributeTargetType TargetType { get; }
    public abstract virtual IExpressionCollection get_Arguments();
    public abstract virtual IExpression get_Qualifier();
    public abstract virtual bool get_HasTargetNode();
    public abstract virtual AttributeTargetType get_TargetType();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IAttributeElementCollection {
    public IAttributeElement Item { get; }
    public abstract virtual int IndexOf(IAttributeElement e);
    public abstract virtual IAttributeElement get_Item(int index);
}
public interface DevExpress.CodeParser.IAttributeSectionElement {
    public bool HasTargetNode { get; }
    public abstract virtual bool get_HasTargetNode();
}
public interface DevExpress.CodeParser.IAttributeVariableInitializer {
}
public interface DevExpress.CodeParser.IAwaitExpression {
    public IExpression SourceExpression { get; }
    public abstract virtual IExpression get_SourceExpression();
}
public interface DevExpress.CodeParser.IBaseReferenceExpression {
}
public interface DevExpress.CodeParser.IBaseVariable {
    public bool IsLocal { get; }
    public bool IsField { get; }
    public bool IsParameter { get; }
    public bool IsTypeDef { get; }
    [EditorBrowsableAttribute("1")]
public bool IsAspxTag { get; }
    [EditorBrowsableAttribute("1")]
public bool IsRunAtServer { get; }
    public IExpression NameQualifier { get; }
    public abstract virtual bool get_IsLocal();
    public abstract virtual bool get_IsField();
    public abstract virtual bool get_IsParameter();
    public abstract virtual bool get_IsTypeDef();
    public abstract virtual bool get_IsAspxTag();
    public abstract virtual bool get_IsRunAtServer();
    public abstract virtual IExpression get_NameQualifier();
}
public interface DevExpress.CodeParser.IBaseXmlNode {
}
public interface DevExpress.CodeParser.IBinaryOperatorExpression {
    public IExpression LeftSide { get; }
    public IExpression RightSide { get; }
    public BinaryOperatorType BinaryOperator { get; }
    public abstract virtual IExpression get_LeftSide();
    public abstract virtual IExpression get_RightSide();
    public abstract virtual BinaryOperatorType get_BinaryOperator();
}
public interface DevExpress.CodeParser.IBinaryOperatorExpressionType {
    public BinaryOperatorType BinaryOperator { get; public set; }
    public abstract virtual BinaryOperatorType get_BinaryOperator();
    public abstract virtual void set_BinaryOperator(BinaryOperatorType value);
}
public interface DevExpress.CodeParser.IBlockStatement {
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IBraceSettings {
    public BracesOnNewLineOptions Item { get; }
    public abstract virtual BracesOnNewLineOptions get_Item(LanguageElement element);
}
public interface DevExpress.CodeParser.IBreakStatement {
}
public interface DevExpress.CodeParser.ICallStatement {
    public IExpression CalledExpression { get; }
    public abstract virtual IExpression get_CalledExpression();
}
public interface DevExpress.CodeParser.ICanRestoreFromGeneratedSymbols {
    public abstract virtual IElement RestoreFromGeneratedSymbols(IElement element);
}
public interface DevExpress.CodeParser.ICapableBlock {
    public DelimiterBlockType BlockType { get; }
    public bool HasDelimitedBlock { get; }
    public abstract virtual DelimiterBlockType get_BlockType();
    public abstract virtual bool get_HasDelimitedBlock();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ICaseClauseCollection {
    public ICaseClauseStatement Item { get; }
    public abstract virtual int IndexOf(ICaseClauseStatement st);
    public abstract virtual ICaseClauseStatement Find(string name);
    public abstract virtual ICaseClauseStatement get_Item(int index);
}
public interface DevExpress.CodeParser.ICaseClausesList {
    public ICaseClauseCollection Clauses { get; }
    public abstract virtual ICaseClauseCollection get_Clauses();
}
public interface DevExpress.CodeParser.ICaseClauseStatement {
    public IExpression StartExpression { get; }
    public IExpression EndExpression { get; }
    public abstract virtual IExpression get_StartExpression();
    public abstract virtual IExpression get_EndExpression();
}
public interface DevExpress.CodeParser.ICaseStatement {
    public IExpression Expression { get; }
    public ICaseClausesList CaseClauses { get; }
    public bool IsDefault { get; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual ICaseClausesList get_CaseClauses();
    public abstract virtual bool get_IsDefault();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ICaseStatementCollection {
    public ICaseStatement Item { get; }
    public abstract virtual int IndexOf(ICaseStatement t);
    public abstract virtual ICaseStatement Find(string name);
    public abstract virtual ICaseStatement get_Item(int index);
}
public interface DevExpress.CodeParser.ICastTargetExpression {
}
public interface DevExpress.CodeParser.ICatchStatement {
    public IElement ExceptionVariable { get; }
    public IElement Condition { get; }
    public abstract virtual IElement get_ExceptionVariable();
    public abstract virtual IElement get_Condition();
}
public interface DevExpress.CodeParser.ICheckedExpression {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.ICheckedStatement {
}
public interface DevExpress.CodeParser.IClassElement {
}
public interface DevExpress.CodeParser.IClassTemplateParameter {
}
public interface DevExpress.CodeParser.IClassTypeParameterConstraint {
}
public interface DevExpress.CodeParser.ICollapsibleRegion {
    public bool Collapsed { get; public set; }
    public bool Expanded { get; public set; }
    public SourceRange Range { get; }
    public string Text { get; public set; }
    public abstract virtual void Collapse(bool undoable);
    public abstract virtual void Collapse();
    public abstract virtual void Expand(bool undoable);
    public abstract virtual void Expand();
    public abstract virtual bool get_Collapsed();
    public abstract virtual void set_Collapsed(bool value);
    public abstract virtual bool get_Expanded();
    public abstract virtual void set_Expanded(bool value);
    public abstract virtual SourceRange get_Range();
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
}
public interface DevExpress.CodeParser.IComments {
    public CommentCollection AllComments { get; }
    public abstract virtual CommentCollection get_AllComments();
}
public interface DevExpress.CodeParser.ICompilerDirectives {
    public CompilerDirectiveCollection CompilerDirectives { get; }
    public CompilerDirective CompilerDirectiveRootNode { get; }
    public abstract virtual CompilerDirectiveCollection get_CompilerDirectives();
    public abstract virtual CompilerDirective get_CompilerDirectiveRootNode();
}
public interface DevExpress.CodeParser.IComplexExpression {
    public IExpressionCollection Expressions { get; }
    public abstract virtual IExpressionCollection get_Expressions();
}
public interface DevExpress.CodeParser.IConditionalExpression {
    public IExpression Condition { get; }
    public IExpression TrueExpression { get; }
    public IExpression FalseExpression { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IExpression get_TrueExpression();
    public abstract virtual IExpression get_FalseExpression();
}
public interface DevExpress.CodeParser.IConditionalStatement {
}
public interface DevExpress.CodeParser.IConditionalTypeCast {
    public bool IsIfOperator { get; public set; }
    public abstract virtual bool get_IsIfOperator();
    public abstract virtual void set_IsIfOperator(bool value);
}
public interface DevExpress.CodeParser.IConstElement {
}
public interface DevExpress.CodeParser.IConstructorInitializerElement {
    public InitializerTarget Target { get; }
    public IExpressionCollection Arguments { get; }
    public IExpression Expression { get; }
    public abstract virtual InitializerTarget get_Target();
    public abstract virtual IExpressionCollection get_Arguments();
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IContinueStatement {
}
public interface DevExpress.CodeParser.ICppQualifiedElementReferenceExpression {
}
public interface DevExpress.CodeParser.ICssAngleLiteral {
}
public interface DevExpress.CodeParser.ICssAttributeSelector {
    public string Value { get; }
    public AttributeSelectorEqualityType EqualityType { get; }
    public bool IsStringValue { get; }
    public abstract virtual string get_Value();
    public abstract virtual AttributeSelectorEqualityType get_EqualityType();
    public abstract virtual bool get_IsStringValue();
}
public interface DevExpress.CodeParser.ICssCharsetDeclaration {
    public string Charset { get; }
    public abstract virtual string get_Charset();
}
public interface DevExpress.CodeParser.ICssColorReference {
}
public interface DevExpress.CodeParser.ICssCommentTag {
    public CommentTagKind Kind { get; }
    public abstract virtual CommentTagKind get_Kind();
}
public interface DevExpress.CodeParser.ICssElement {
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ICssElementCollection {
    public ICssElement Item { get; }
    public abstract virtual int IndexOf(ICssElement e);
    public abstract virtual ICssElement get_Item(int index);
}
public interface DevExpress.CodeParser.ICssExpression {
    public ICssTerm PrimitiveValue { get; }
    public ExpressionDelimiter Delimiter { get; }
    public abstract virtual ICssTerm get_PrimitiveValue();
    public abstract virtual ExpressionDelimiter get_Delimiter();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ICssExpressionCollection {
    public ICssExpression Item { get; }
    public abstract virtual int IndexOf(ICssExpression e);
    public abstract virtual ICssExpression get_Item(int index);
}
public interface DevExpress.CodeParser.ICssFrequencyLiteral {
}
public interface DevExpress.CodeParser.ICssFunctionReference {
    public ICssTermCollection Parameters { get; }
    public abstract virtual ICssTermCollection get_Parameters();
}
public interface DevExpress.CodeParser.ICssIdentifierReference {
}
public interface DevExpress.CodeParser.ICssImportDirective {
    public string Source { get; }
    public StringCollection SupportedMediaTypes { get; }
    public abstract virtual string get_Source();
    public abstract virtual StringCollection get_SupportedMediaTypes();
}
public interface DevExpress.CodeParser.ICssLengthLiteral {
}
public interface DevExpress.CodeParser.ICssMeasuredNumber {
    public CssMeasureUnit Unit { get; }
    public abstract virtual CssMeasureUnit get_Unit();
}
public interface DevExpress.CodeParser.ICssMediaDirective {
    public StringCollection MediaTypes { get; }
    public abstract virtual StringCollection get_MediaTypes();
}
public interface DevExpress.CodeParser.ICssMediaExpression {
    public string MediaFeature { get; }
    public CssTerm Expression { get; }
    public abstract virtual string get_MediaFeature();
    public abstract virtual CssTerm get_Expression();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ICssMediaExpressionCollection {
    public ICssMediaExpression Item { get; }
    public abstract virtual int IndexOf(ICssMediaExpression e);
    public abstract virtual ICssMediaExpression get_Item(int index);
}
public interface DevExpress.CodeParser.ICssMediaQuery {
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ICssMediaQueryCollection {
    public ICssMediaQuery Item { get; }
    public abstract virtual int IndexOf(ICssMediaQuery e);
    public abstract virtual ICssMediaQuery get_Item(int index);
}
public interface DevExpress.CodeParser.ICssNumberLiteral {
    public object Value { get; }
    public abstract virtual object get_Value();
}
public interface DevExpress.CodeParser.ICssPageStyle {
    public ICssPropertyDeclarationCollection Properties { get; }
    public abstract virtual ICssPropertyDeclarationCollection get_Properties();
}
public interface DevExpress.CodeParser.ICssPercentLiteral {
}
public interface DevExpress.CodeParser.ICssPropertyDeclaration {
    public bool IsEqual { get; }
    public ICssTermCollection Values { get; }
    public bool IsImportant { get; }
    public abstract virtual bool get_IsEqual();
    public abstract virtual ICssTermCollection get_Values();
    public abstract virtual bool get_IsImportant();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ICssPropertyDeclarationCollection {
    public ICssPropertyDeclaration Item { get; }
    public abstract virtual int IndexOf(ICssPropertyDeclaration e);
    public abstract virtual ICssPropertyDeclaration get_Item(int index);
}
public interface DevExpress.CodeParser.ICssPseudoFunctionSelector {
    public string Param { get; }
    public abstract virtual string get_Param();
}
public interface DevExpress.CodeParser.ICssPseudoSelector {
}
public interface DevExpress.CodeParser.ICssSelector {
    public CssSelectorType SelectorType { get; }
    public ICssSelector Ancestor { get; }
    public ICssSelector ChildSelector { get; }
    public abstract virtual CssSelectorType get_SelectorType();
    public abstract virtual ICssSelector get_Ancestor();
    public abstract virtual ICssSelector get_ChildSelector();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ICssSelectorCollection {
    public ICssSelector Item { get; }
    public abstract virtual int IndexOf(ICssSelector e);
    public abstract virtual ICssSelector get_Item(int index);
}
public interface DevExpress.CodeParser.ICssStringLiteral {
    public string Value { get; }
    public abstract virtual string get_Value();
}
public interface DevExpress.CodeParser.ICssStyleRule {
    public ICssSelectorCollection Selectors { get; }
    public abstract virtual ICssSelectorCollection get_Selectors();
}
public interface DevExpress.CodeParser.ICssStyleSheet {
    public ICssElementCollection CssElements { get; }
    public abstract virtual ICssElementCollection get_CssElements();
}
public interface DevExpress.CodeParser.ICssTerm {
    public ExpressionDelimiter Delimiter { get; }
    public PrecedingSign Sign { get; }
    public abstract virtual ExpressionDelimiter get_Delimiter();
    public abstract virtual PrecedingSign get_Sign();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ICssTermCollection {
    public ICssTerm Item { get; }
    public abstract virtual int IndexOf(ICssTerm e);
    public abstract virtual ICssTerm get_Item(int index);
}
public interface DevExpress.CodeParser.ICssTimeLiteral {
}
public interface DevExpress.CodeParser.ICssURIReference {
    public string URI { get; }
    public abstract virtual string get_URI();
}
public interface DevExpress.CodeParser.ICTypeExpression {
}
public interface DevExpress.CodeParser.IDefaultValueExpression {
    public ITypeReferenceExpression TypeReference { get; }
    public abstract virtual ITypeReferenceExpression get_TypeReference();
}
public interface DevExpress.CodeParser.IDelegateElement {
    public IElementCollection DelegateMethods { get; }
    public abstract virtual IElementCollection get_DelegateMethods();
}
public interface DevExpress.CodeParser.IDeleteExpression {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IDirectCastExpression {
}
public interface DevExpress.CodeParser.IDisposableEditPoint {
    public int Line { get; }
    public int Offset { get; }
    public bool IsDisposed { get; }
    public bool IsPushable { get; public set; }
    public bool IsAnchorable { get; public set; }
    public abstract virtual int get_Line();
    public abstract virtual int get_Offset();
    public abstract virtual bool get_IsDisposed();
    public abstract virtual void Dispose();
    public abstract virtual bool get_IsPushable();
    public abstract virtual void set_IsPushable(bool value);
    public abstract virtual bool get_IsAnchorable();
    public abstract virtual void set_IsAnchorable(bool value);
}
public interface DevExpress.CodeParser.IDisposableEditPointFactory {
    public abstract virtual IDisposableEditPoint CreateDisposableEditPoint(int lineNumber, int columnOffset);
    public abstract virtual IDisposableEditPoint CreateDisposableEditPoint(int lineNumber, int columnOffset, string name);
}
public interface DevExpress.CodeParser.IDistinctExpression {
}
public interface DevExpress.CodeParser.IDocument {
    public IDXCoreTextView ActiveView { get; }
    public IDXCoreTextView InactiveView { get; }
    public string RegionStartKeyword { get; }
    public string RegionEndKeyword { get; }
    public string FullName { get; }
    public ParserBase Parser { get; }
    public string Language { get; }
    public int LineCount { get; }
    public string Text { get; }
    public string Name { get; }
    public SourceRange Range { get; }
    public bool IsDisposed { get; }
    public bool IsDisposing { get; }
    public IProjectElement ProjectElement { get; }
    [EditorBrowsableAttribute("1")]
public DocumentHistory History { get; }
    [EditorBrowsableAttribute("1")]
public LanguageElement FileNode { get; }
    public abstract virtual void Activate();
    public abstract virtual int LengthOfLine(int lineNumber);
    public abstract virtual void SelectText(int startLine, int startOffset, int endLine, int endOffset);
    public abstract virtual void DeleteText(SourceRange range);
    public abstract virtual void DoParse();
    public abstract virtual void FullParse();
    public abstract virtual LanguageElement Parse(ParserContext context);
    public abstract virtual SourceRange InsertText(SourcePoint point, string text);
    public abstract virtual string GetText(SourceRange range);
    public abstract virtual bool GetSelectionBounds(Int32& startLine, Int32& startOffset, Int32& endLine, Int32& endOffset);
    public abstract virtual void ReplaceSelection(string Text, bool KeepSelection);
    public abstract virtual void AddHeaderFooter(LanguageElement aLanguageElement, String[] aHeader, String[] aFooter, bool aSelect);
    public abstract virtual ICollapsibleRegion GetCollapsibleRegion(RegionDirective region);
    public abstract virtual ICollapsibleRegion GetCollapsibleRegion(SourceRange range);
    public abstract virtual ICollapsibleRegion GetCollapsibleRegion(RegionDirective region, IDXCoreTextView textView);
    public abstract virtual ICollapsibleRegion GetCollapsibleRegion(SourceRange range, IDXCoreTextView textView);
    public abstract virtual void AddNamespace(Namespace aNamespace);
    public abstract virtual void ClearNamespaces();
    public abstract virtual SourceRange IncludeWhitespace(SourceRange sourceRange);
    public abstract virtual SourceRange IncludeLeadingWhiteSpace(SourceRange sourceRange);
    public abstract virtual SourceRange IncludeTrailingWhiteSpace(SourceRange sourceRange);
    public abstract virtual QueuedDelete QueueDelete(SourceRange range);
    public abstract virtual QueuedDelete QueueDelete(LanguageElement element);
    public abstract virtual QueuedDelete QueueDelete(LanguageElement firstSibling, LanguageElement lastSibling);
    public abstract virtual QueuedInsert QueueInsert(SourcePoint insertionPoint, string newCode);
    public abstract virtual QueuedReplace QueueReplace(SourceRange range, string newCode);
    public abstract virtual QueuedReplace QueueReplace(LanguageElement element, string newCode);
    public abstract virtual QueuedReplace QueueReplace(LanguageElement firstSibling, LanguageElement lastSibling, string newCode);
    public abstract virtual void QueueMove(SourceRange range, SourcePoint insertionPoint);
    public abstract virtual void ApplyQueuedEdits();
    public abstract virtual void ApplyQueuedEdits(string operation);
    public abstract virtual void Move(SourceRange range, SourcePoint insertionPoint, string operation);
    public abstract virtual void MoveWithBinding(SourceRange range, SourcePoint insertionPoint, string operation);
    public abstract virtual void Replace(SourceRange range, string newCode, string operation);
    public abstract virtual void Replace(SourceRange range, string newCode, string operation, bool format);
    public abstract virtual SourceRange Format(SourceRange range);
    public abstract virtual string GetText(int startLine, int startOffset, int endLine, int endOffset);
    public abstract virtual string GetText(int lineNumber);
    public abstract virtual SourceRange SetText(SourceRange range, string text);
    public abstract virtual SourceRange IncludePrecedingEmptyLines(SourceRange sourceRange);
    public abstract virtual SourceRange IncludeTrailingEmptyLines(SourceRange sourceRange);
    public abstract virtual SourcePoint GetStartEmptyLinePoint(SourcePoint sourcePoint);
    public abstract virtual SourcePoint GetEndEmptyLinePoint(SourcePoint sourcePoint);
    public abstract virtual IProjectElement GetProjectElement();
    public abstract virtual ISourceReader GetSourceReader(SourceRange range);
    public abstract virtual bool HasChangesInMemory();
    public abstract virtual bool BufferAndFileSizesAreSame();
    public abstract virtual String[] GetChildFilePaths();
    public abstract virtual SourceRange ExpandText(int line, int offset, string text);
    public abstract virtual SourceRange ExpandText(SourcePoint point, string text);
    public abstract virtual IDXCoreTextView get_ActiveView();
    public abstract virtual IDXCoreTextView get_InactiveView();
    public abstract virtual string get_RegionStartKeyword();
    public abstract virtual string get_RegionEndKeyword();
    public abstract virtual string get_FullName();
    public abstract virtual ParserBase get_Parser();
    public abstract virtual string get_Language();
    public abstract virtual int get_LineCount();
    public abstract virtual string get_Text();
    public abstract virtual void GetSurroundingText(SourcePoint point, String& leftText, String& rightText);
    public abstract virtual string get_Name();
    public abstract virtual SourceRange get_Range();
    public abstract virtual bool get_IsDisposed();
    public abstract virtual bool get_IsDisposing();
    public abstract virtual IProjectElement get_ProjectElement();
    public abstract virtual DocumentHistory get_History();
    public abstract virtual LanguageElement get_FileNode();
    public abstract virtual void OnBeforeParse(SourceRange range, LanguageElement parent, LanguageElement nodeBefore, LanguageElement nodeAfter, LanguageElementCollection invalidatedNodes);
    public abstract virtual void OnAfterParse(SourceRange range, LanguageElement parent, LanguageElement nodeBefore, LanguageElement nodeAfter, LanguageElementCollection invalidatedNodes, LanguageElement result, bool allChangesParsed);
    public abstract virtual bool InCollapsedRange(LanguageElement languageElement, IDXCoreTextView textView);
    [EditorBrowsableAttribute("1")]
public abstract virtual void MacrosRedefined();
}
public interface DevExpress.CodeParser.IDoStatement {
    public IExpression Condition { get; }
    public abstract virtual IExpression get_Condition();
}
public interface DevExpress.CodeParser.IDteProjectItem {
    public abstract virtual SourceFileBuildAction GetBuildAction();
}
public interface DevExpress.CodeParser.IDXCoreTextView {
    public LanguageElement FileNode { get; }
    public abstract virtual void EnsureSpanIsVisible(int startLine, int startOffset, int endLine, int endOffset);
    public abstract virtual void GetTopAndBottomLines(Int32& topLine, Int32& bottomLine);
    public abstract virtual void Select(int startLine, int startOffset, int endLine, int endOffset);
    public abstract virtual void Select(int startLine, int startOffset, int endLine, int endOffset, bool ensureVisible);
    public abstract virtual void Select(SourceRange range);
    public abstract virtual void Select(SourceRange range, bool ensureVisible);
    public abstract virtual SourceRange GetSelectionRange();
    public abstract virtual LanguageElement get_FileNode();
}
public interface DevExpress.CodeParser.IDynamicTypeElement {
}
public interface DevExpress.CodeParser.IElaboratedTypeElement {
    public ElaboratedKind ElaboratedKind { get; }
    public IExpression Expression { get; }
    public abstract virtual ElaboratedKind get_ElaboratedKind();
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IElement {
    public string Name { get; }
    public IProjectElement Project { get; }
    public ISolutionElement Solution { get; }
    public IAssemblyModel AssemblyModel { get; }
    public IElement Parent { get; }
    public ITypeElement ParentType { get; }
    public IEventElement ParentEvent { get; }
    public IMethodElement ParentMethod { get; }
    public IElement ParentMethodOrAccessor { get; }
    public IElement ParentMethodOrPropertyOrEvent { get; }
    public IMemberElement ParentMember { get; }
    public IPropertyElement ParentProperty { get; }
    public INamespaceElement ParentNamespace { get; }
    public IElementCollection Children { get; }
    public IEnumerable`1<IElement> AllChildren { get; }
    public IElementCollection CodeChildren { get; }
    public ISourceFileCollection Files { get; }
    public ISourceFile FirstFile { get; }
    public ITextRangeCollection NameRanges { get; }
    public TextRange FirstNameRange { get; }
    public ITextRangeCollection Ranges { get; }
    public TextRange FirstRange { get; }
    public LanguageElementType ElementType { get; }
    public string FullName { get; }
    public string RootNamespaceFullName { get; }
    public IElement NextSibling { get; }
    public IElement PreviousSibling { get; }
    public bool CompletesPrevious { get; }
    public int ImageIndex { get; }
    public bool InReferencedAssembly { get; }
    public bool IsMember { get; }
    public bool IsNestedType { get; }
    [EditorBrowsableAttribute("1")]
public bool IsFakeNode { get; }
    [EditorBrowsableAttribute("1")]
public bool IsTypeDeclaration { get; }
    public abstract virtual void Accept(IElementVisitor visitor);
    public abstract virtual IElement GetParent(LanguageElementType type, LanguageElementType[] types);
    public abstract virtual IElement GetParentStatementOrVariable();
    public abstract virtual IElement FindChildByName(string name);
    public abstract virtual bool IsParentedBy(IElement element);
    public abstract virtual IElement Clone();
    public abstract virtual IElement Clone(ElementCloneOptions options);
    public abstract virtual IElement GetDeclaration();
    public abstract virtual IElement GetDeclaration(bool restore);
    public abstract virtual LanguageElement ToLanguageElement();
    public abstract virtual IElementCollection FindAllReferences();
    public abstract virtual IElementCollection FindAllReferences(IElement scope);
    public abstract virtual string get_Name();
    public abstract virtual IProjectElement get_Project();
    public abstract virtual ISolutionElement get_Solution();
    public abstract virtual IAssemblyModel get_AssemblyModel();
    public abstract virtual IElement get_Parent();
    public abstract virtual ITypeElement get_ParentType();
    public abstract virtual IEventElement get_ParentEvent();
    public abstract virtual IMethodElement get_ParentMethod();
    public abstract virtual IElement get_ParentMethodOrAccessor();
    public abstract virtual IElement get_ParentMethodOrPropertyOrEvent();
    public abstract virtual IMemberElement get_ParentMember();
    public abstract virtual IPropertyElement get_ParentProperty();
    public abstract virtual INamespaceElement get_ParentNamespace();
    public abstract virtual IElementCollection get_Children();
    public abstract virtual IEnumerable`1<IElement> get_AllChildren();
    public abstract virtual IElementCollection get_CodeChildren();
    public abstract virtual ISourceFileCollection get_Files();
    public abstract virtual ISourceFile get_FirstFile();
    public abstract virtual ITextRangeCollection get_NameRanges();
    public abstract virtual TextRange get_FirstNameRange();
    public abstract virtual ITextRangeCollection get_Ranges();
    public abstract virtual TextRange get_FirstRange();
    public abstract virtual LanguageElementType get_ElementType();
    public abstract virtual string get_FullName();
    public abstract virtual string get_RootNamespaceFullName();
    public abstract virtual IElement get_NextSibling();
    public abstract virtual IElement get_PreviousSibling();
    public abstract virtual bool get_CompletesPrevious();
    public abstract virtual int get_ImageIndex();
    public abstract virtual bool get_InReferencedAssembly();
    public abstract virtual bool get_IsMember();
    public abstract virtual bool get_IsNestedType();
    public abstract virtual bool get_IsFakeNode();
    public abstract virtual bool get_IsTypeDeclaration();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.IElementCollection : NodeList {
    public static IElementCollection Empty;
    public IElement Item { get; public set; }
    public CollectionType CollectionType { get; }
    public IElementCollection(int capacity);
    private static IElementCollection();
    private sealed virtual override IEnumerator`1<IElement> System.Collections.Generic.IEnumerable<DevExpress.CodeParser.IElement>.GetEnumerator();
    protected virtual NodeList CreateInstance();
    public virtual int Add(IElement element);
    public void AddRange(IEnumerable`1<IElement> elements);
    public int IndexOf(IElement element);
    public virtual void Insert(int index, IElement element);
    public virtual void Remove(IElement element);
    public IElement Find(IElement element);
    public bool Contains(IElement element);
    public IElement FindElementByFullName(string fullName, bool caseSensitive);
    public IElementCollection DeepClone();
    public IElementCollection DeepClone(ElementCloneOptions options);
    public LanguageElementCollection ToLanguageElementCollection();
    public static int IndexOf(IElement[] elements, IElement element);
    [IteratorStateMachineAttribute("DevExpress.CodeParser.IElementCollection/<GetEnumerable>d__18")]
public IEnumerable`1<IElement> GetEnumerable();
    public SourceRange GetRange();
    public static SourceRange GetRange(IElement element);
    public static SourceRange GetRange(IEnumerable`1<IElement> elements);
    public IElement get_Item(int index);
    public void set_Item(int index, IElement value);
    public sealed virtual CollectionType get_CollectionType();
}
public interface DevExpress.CodeParser.IElementCollectionFilter {
    public abstract virtual IElementCollection Apply(IElementCollection elements);
}
public interface DevExpress.CodeParser.IElementFilter {
    public abstract virtual bool Apply(IElement element);
    public abstract virtual bool SkipChildren(IElement element);
}
public interface DevExpress.CodeParser.IElementModifier {
    public abstract virtual void SetParent(IElement parent);
    public abstract virtual void SetName(string newName);
    public abstract virtual void ReplaceChild(IElement oldNode, IElement newNode);
    public abstract virtual void InsertChild(int index, IElement child);
    public abstract virtual void SetFakeNode(bool isFakeNode);
}
public interface DevExpress.CodeParser.IElementReferenceExpression {
    public bool IsModified { get; }
    public abstract virtual bool get_IsModified();
}
public interface DevExpress.CodeParser.IElementVisitor {
    public abstract virtual void Visit(IElement element);
}
public interface DevExpress.CodeParser.IElseIfStatement {
}
public interface DevExpress.CodeParser.IElseStatement {
}
public interface DevExpress.CodeParser.IEmptyArgumentExpression {
}
public interface DevExpress.CodeParser.IEnumElement {
    public IExpression ValueExpression { get; }
    public abstract virtual IExpression get_ValueExpression();
}
public interface DevExpress.CodeParser.IEnumerationElement {
    public string UnderlyingType { get; }
    public abstract virtual string get_UnderlyingType();
}
public interface DevExpress.CodeParser.IEqualsExpression {
}
public interface DevExpress.CodeParser.IEventElement {
    public IMethodElement AddMethod { get; }
    public IMethodElement RemoveMethod { get; }
    public IMethodElement RaiseMethod { get; }
    public IExpression Initializer { get; }
    [EditorBrowsableAttribute("1")]
public IElementCollection ImplicitElements { get; }
    public abstract virtual IMethodElement get_AddMethod();
    public abstract virtual IMethodElement get_RemoveMethod();
    public abstract virtual IMethodElement get_RaiseMethod();
    public abstract virtual IExpression get_Initializer();
    public abstract virtual IElementCollection get_ImplicitElements();
}
public interface DevExpress.CodeParser.IEventElementModifier {
    public abstract virtual void SetAddMethod(IMethodElement method);
    public abstract virtual void SetRemoveMethod(IMethodElement method);
}
public interface DevExpress.CodeParser.IExpression {
    public bool IsStatement { get; }
    public abstract virtual bool Is(string fullTypeName);
    public abstract virtual bool Is(ITypeElement type);
    public abstract virtual bool Is(Type type);
    public abstract virtual bool Is(ISourceTreeResolver resolver, string fullTypeName);
    public abstract virtual bool get_IsStatement();
    public abstract virtual IElement Resolve(ISourceTreeResolver resolver);
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IExpressionCollection {
    public IExpression Item { get; }
    public abstract virtual int IndexOf(IExpression e);
    public abstract virtual IExpression get_Item(int index);
}
public interface DevExpress.CodeParser.IExpressionInverter {
    public abstract virtual Expression Invert(Expression expression);
}
public interface DevExpress.CodeParser.IExtensionMethodParam {
}
public interface DevExpress.CodeParser.IExternAlias {
}
public interface DevExpress.CodeParser.IExternDeclaration {
    public bool HasBrackets { get; }
    public abstract virtual bool get_HasBrackets();
}
public class DevExpress.CodeParser.If : IfElse {
    private static int INT_MaintainanceComplexity;
    private LanguageElement _Condition;
    private bool _HasElseStatement;
    public LanguageElementType ElementType { get; }
    protected int ThisMaintenanceComplexity { get; }
    [DescriptionAttribute("True if this if-block has a matching else statement.")]
[CategoryAttribute("Details")]
[DefaultValueAttribute("False")]
public bool HasElseStatement { get; }
    public Statement ElseStatement { get; }
    public bool AcceptsElse { get; }
    public SourceRange TrueStatementsBlockRange { get; }
    public SourceRange FalseStatementsBlockRange { get; }
    public SourceRange TrueStatementsRange { get; }
    public SourceRange FalseStatementsRange { get; }
    public LanguageElement Condition { get; public set; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IIfStatement.Condition { get; }
    private IStatement DevExpress.CodeParser.IIfStatement.ElseStatement { get; }
    private bool DevExpress.CodeParser.IIfStatement.HasElseStatement { get; }
    public If(Expression expression, LanguageElementCollection block);
    public If(Expression expression, LanguageElementCollection block, SourceRange range);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    [EditorBrowsableAttribute("1")]
public void SetExpression(Expression expression);
    [EditorBrowsableAttribute("1")]
public void SetCondition(LanguageElement condition);
    public virtual int GetImageIndex();
    public virtual string GetDetailNodeDescription(int index);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    protected virtual int get_ThisMaintenanceComplexity();
    public bool get_HasElseStatement();
    public Statement get_ElseStatement();
    public virtual bool get_AcceptsElse();
    public SourceRange get_TrueStatementsBlockRange();
    public SourceRange get_FalseStatementsBlockRange();
    public SourceRange get_TrueStatementsRange();
    public SourceRange get_FalseStatementsRange();
    public LanguageElement get_Condition();
    public void set_Condition(LanguageElement value);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IIfStatement.get_Condition();
    private sealed virtual override IStatement DevExpress.CodeParser.IIfStatement.get_ElseStatement();
    private sealed virtual override bool DevExpress.CodeParser.IIfStatement.get_HasElseStatement();
    public virtual string ToString();
}
public interface DevExpress.CodeParser.IFakeStatement {
    public bool HasDelimitedBlock { get; }
    public abstract virtual IEnumerable`1<IElement> GetBlockChildren();
    public abstract virtual bool get_HasDelimitedBlock();
}
public class DevExpress.CodeParser.IfCodeGenStyle : ElementCodeGenStyle {
    private bool _AddSpaceAfterKeyword;
    public LanguageElementType ElementType { get; }
    public bool AddSpaceAfterKeyword { get; public set; }
    public virtual LanguageElementType get_ElementType();
    public bool get_AddSpaceAfterKeyword();
    public void set_AddSpaceAfterKeyword(bool value);
}
public class DevExpress.CodeParser.IfDefDirective : IfDirective {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.IfDirective : CompilerDirective {
    private string _Expression;
    private bool _ExpressionValue;
    public LanguageElementType ElementType { get; }
    public string Expression { get; public set; }
    public bool ExpressionValue { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Expression();
    public void set_Expression(string value);
    public bool get_ExpressionValue();
    public void set_ExpressionValue(bool value);
}
public abstract class DevExpress.CodeParser.IfElse : ConditionalParentToSingleStatement {
    private bool _IsOneLine;
    protected int StatementCount { get; }
    public bool IsOneLine { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    protected int get_StatementCount();
    public bool get_IsOneLine();
    public void set_IsOneLine(bool value);
}
public interface DevExpress.CodeParser.IFieldElement {
    public bool IsConst { get; }
    public IExpression Expression { get; }
    public bool IsBitField { get; }
    public IExpression BitFieldSize { get; }
    public bool IsVolatile { get; }
    public bool IsObjectCreationInit { get; }
    public bool IsFixedSizeBuffer { get; }
    public bool IsWithEvents { get; }
    public IElement NodeLink { get; }
    public bool HasNodeLink { get; }
    public abstract virtual bool get_IsConst();
    public abstract virtual IExpression get_Expression();
    public abstract virtual bool get_IsBitField();
    public abstract virtual IExpression get_BitFieldSize();
    public abstract virtual bool get_IsVolatile();
    public abstract virtual bool get_IsObjectCreationInit();
    public abstract virtual bool get_IsFixedSizeBuffer();
    public abstract virtual bool get_IsWithEvents();
    public abstract virtual IElement get_NodeLink();
    public abstract virtual bool get_HasNodeLink();
}
public interface DevExpress.CodeParser.IFinallyStatement {
}
public interface DevExpress.CodeParser.IFixedStatement {
    public IVariableDeclarationStatementCollection Initializers { get; }
    public abstract virtual IVariableDeclarationStatementCollection get_Initializers();
}
public interface DevExpress.CodeParser.IFlowBreakStatement {
}
public class DevExpress.CodeParser.IfnDefDirective : IfDirective {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.IfOperatorExpression : ConditionalExpression {
    public LanguageElementType ElementType { get; }
    public IfOperatorExpression(Expression condition, Expression falseExpression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public interface DevExpress.CodeParser.IForEachStatement {
    public IVariableDeclarationStatement LoopVariable { get; }
    public IExpression Expression { get; }
    public IExpression NextExpression { get; }
    public abstract virtual IVariableDeclarationStatement get_LoopVariable();
    public abstract virtual IExpression get_Expression();
    public abstract virtual IExpression get_NextExpression();
}
public interface DevExpress.CodeParser.IFormattingElement {
}
public interface DevExpress.CodeParser.IForStatement {
    public IExpression Condition { get; }
    public IElementCollection Initializers { get; }
    public IExpressionCollection Incrementors { get; }
    public IExpression ToExpression { get; }
    public IExpression StepExpression { get; }
    public IExpressionCollection NextExpressions { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IElementCollection get_Initializers();
    public abstract virtual IExpressionCollection get_Incrementors();
    public abstract virtual IExpression get_ToExpression();
    public abstract virtual IExpression get_StepExpression();
    public abstract virtual IExpressionCollection get_NextExpressions();
}
public interface DevExpress.CodeParser.IFromExpression {
    public IExpressionCollection InExpressions { get; }
    public abstract virtual IExpressionCollection get_InExpressions();
}
public interface DevExpress.CodeParser.IFunctionPointerTypeReference {
    public IElementCollection Parameters { get; }
    public int ParametersCount { get; }
    public ITypeReferenceExpression ReturnType { get; }
    public abstract virtual IElementCollection get_Parameters();
    public abstract virtual int get_ParametersCount();
    public abstract virtual ITypeReferenceExpression get_ReturnType();
}
public interface DevExpress.CodeParser.IGenericElement {
    public ITypeParameterCollection TypeParameters { get; }
    public bool IsGeneric { get; }
    public bool IsActivatedGeneric { get; }
    public IGenericElement GenericTemplate { get; }
    public abstract virtual ITypeParameterCollection get_TypeParameters();
    public abstract virtual bool get_IsGeneric();
    public abstract virtual bool get_IsActivatedGeneric();
    public abstract virtual IGenericElement get_GenericTemplate();
}
public interface DevExpress.CodeParser.IGenericElementModifier {
    public abstract virtual void AddTypeParameter(ITypeParameter typeParameter);
    public abstract virtual void RemoveTypeParameter(ITypeParameter typeParameter);
    public abstract virtual void InsertTypeParameter(int index, ITypeParameter typeParameter);
}
public interface DevExpress.CodeParser.IGenericExpression {
    public bool IsGeneric { get; }
    public ITypeReferenceExpressionCollection TypeArguments { get; }
    public int TypeArity { get; }
    public abstract virtual bool get_IsGeneric();
    public abstract virtual ITypeReferenceExpressionCollection get_TypeArguments();
    public abstract virtual int get_TypeArity();
}
public interface DevExpress.CodeParser.IGetXmlNamespaceOperator {
}
public interface DevExpress.CodeParser.IGroupByExpression {
    public IElementCollection GroupList { get; }
    public IElementCollection ByList { get; }
    public IElementCollection IntoElements { get; }
    public abstract virtual IElementCollection get_GroupList();
    public abstract virtual IElementCollection get_ByList();
    public abstract virtual IElementCollection get_IntoElements();
}
public interface DevExpress.CodeParser.IGroupExpression {
    public IExpression GroupBy { get; }
    public IExpression GroupTarget { get; }
    public abstract virtual IExpression get_GroupBy();
    public abstract virtual IExpression get_GroupTarget();
}
public interface DevExpress.CodeParser.IHandlerStatement {
    public IExpression Expression { get; }
    public IExpression AddressExpression { get; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual IExpression get_AddressExpression();
}
public interface DevExpress.CodeParser.IHasArguments {
    public ExpressionCollection Arguments { get; }
    public int ArgumentsCount { get; }
    public abstract virtual void AddArgument(Expression arg);
    public abstract virtual ExpressionCollection get_Arguments();
    public abstract virtual int get_ArgumentsCount();
}
public interface DevExpress.CodeParser.IHasArrayNameModifier {
    public ICollection Modifiers { get; }
    public abstract virtual ICollection get_Modifiers();
}
public interface DevExpress.CodeParser.IHasAttributes {
    public IAttributeElementCollection Attributes { get; }
    public abstract virtual IAttributeElementCollection get_Attributes();
}
public interface DevExpress.CodeParser.IHasAttributesModifier {
    public abstract virtual void AddAttribute(IAttributeElement attribute);
    public abstract virtual void RemoveAttribute(IAttributeElement attribute);
}
public interface DevExpress.CodeParser.IHasBlock {
    public SourceRange BlockStart { get; }
    public SourceRange BlockEnd { get; }
    public abstract virtual SourceRange get_BlockStart();
    public abstract virtual SourceRange get_BlockEnd();
    public abstract virtual void SetBlockStart(SourceRange blockStart);
    public abstract virtual void SetBlockEnd(SourceRange blockEnd);
}
public interface DevExpress.CodeParser.IHasParameters {
    public LanguageElementCollection Parameters { get; }
    public int ParameterCount { get; }
    public abstract virtual LanguageElementCollection get_Parameters();
    public abstract virtual int get_ParameterCount();
}
public interface DevExpress.CodeParser.IHasParens {
    public SourceRange ParensRange { get; }
    public abstract virtual SourceRange get_ParensRange();
}
public interface DevExpress.CodeParser.IHasQualifier {
    public Expression Qualifier { get; public set; }
    public abstract virtual Expression get_Qualifier();
    public abstract virtual void set_Qualifier(Expression value);
}
public interface DevExpress.CodeParser.IHasResolvePoint {
    public IElement ResolvePoint { get; public set; }
    public abstract virtual IElement get_ResolvePoint();
    public abstract virtual void set_ResolvePoint(IElement value);
}
[ObsoleteAttribute("Use IHasQualifier instead")]
public interface DevExpress.CodeParser.IHasSource {
    [EditorBrowsableAttribute("1")]
public Expression Source { get; public set; }
    public abstract virtual Expression get_Source();
    public abstract virtual void set_Source(Expression value);
}
public interface DevExpress.CodeParser.IHasType {
    public ITypeReferenceExpression Type { get; }
    public abstract virtual bool Is(string fullTypeName);
    public abstract virtual bool Is(ITypeElement type);
    public abstract virtual bool Is(Type type);
    public abstract virtual bool Is(ISourceTreeResolver resolver, string fullTypeName);
    public abstract virtual ITypeReferenceExpression get_Type();
}
public interface DevExpress.CodeParser.IHtmlAttribute {
    public IExpression InlineExpression { get; }
    public DotNetLanguageType ScriptLanguage { get; }
    public abstract virtual IExpression get_InlineExpression();
    public abstract virtual DotNetLanguageType get_ScriptLanguage();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IHtmlAttributeCollection {
    public IHtmlAttribute Item { get; }
    public abstract virtual int IndexOf(IHtmlAttribute e);
    public abstract virtual IHtmlAttribute get_Item(int index);
}
public interface DevExpress.CodeParser.IHtmlElement {
    public IHtmlAttributeCollection Attributes { get; }
    public abstract virtual IHtmlAttributeCollection get_Attributes();
}
public interface DevExpress.CodeParser.IHtmlScriptDefinition {
    public string ScriptText { get; }
    public DotNetLanguageType Language { get; }
    public TextRange CodeRange { get; }
    public abstract virtual string get_ScriptText();
    public abstract virtual DotNetLanguageType get_Language();
    public abstract virtual TextRange get_CodeRange();
}
public interface DevExpress.CodeParser.IHtmlStyleDefinition {
    public string StyleText { get; }
    public TextRange TextRange { get; }
    public abstract virtual string get_StyleText();
    public abstract virtual TextRange get_TextRange();
}
public interface DevExpress.CodeParser.IIfOperatorExpression {
}
public interface DevExpress.CodeParser.IIfStatement {
    public IExpression Condition { get; }
    public IStatement ElseStatement { get; }
    public bool HasElseStatement { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IStatement get_ElseStatement();
    public abstract virtual bool get_HasElseStatement();
}
public interface DevExpress.CodeParser.IImplicitVariable {
}
public interface DevExpress.CodeParser.IIncludeDirectiveList {
    public SortedList IncludeDirectiveList { get; }
    public abstract virtual SortedList get_IncludeDirectiveList();
}
public interface DevExpress.CodeParser.IIndexerExpression {
    public IExpressionCollection Arguments { get; }
    public abstract virtual IExpressionCollection get_Arguments();
}
public interface DevExpress.CodeParser.IInExpression {
    public IQueryIdent QueryIdent { get; }
    public IExpression Expression { get; }
    public abstract virtual IQueryIdent get_QueryIdent();
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IInterfaceClassElement {
}
public interface DevExpress.CodeParser.IInterfaceElement {
}
public interface DevExpress.CodeParser.IInterfaceStructElement {
}
public interface DevExpress.CodeParser.IIntoContainingElement {
    public LanguageElementCollection IntoElements { get; }
    public abstract virtual void AddIntoElement(LanguageElement element);
    public abstract virtual LanguageElementCollection get_IntoElements();
}
public interface DevExpress.CodeParser.IIntoExpression {
    public IQueryIdent IntoTarget { get; }
    public abstract virtual IQueryIdent get_IntoTarget();
}
public interface DevExpress.CodeParser.IIsExpression {
}
public interface DevExpress.CodeParser.IIsNotExpression {
}
public interface DevExpress.CodeParser.IJoinExpression {
    public IInExpression InExpression { get; }
    public IExpressionCollection JoinExpressions { get; }
    public IExpressionCollection EqualsExpressions { get; }
    public abstract virtual IInExpression get_InExpression();
    public abstract virtual IExpressionCollection get_JoinExpressions();
    public abstract virtual IExpressionCollection get_EqualsExpressions();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IJoinExpressionCollection {
    public IJoinExpression Item { get; }
    public abstract virtual int IndexOf(IJoinExpression e);
    public abstract virtual IJoinExpression get_Item(int index);
}
public interface DevExpress.CodeParser.IJoinIntoExpression {
    public IElementCollection IntoElements { get; }
    public abstract virtual IElementCollection get_IntoElements();
}
public interface DevExpress.CodeParser.ILambdaExpression {
}
public interface DevExpress.CodeParser.ILambdaImplicitlyTypedParam {
}
public interface DevExpress.CodeParser.ILetExpression {
    public IElementCollection Declarations { get; }
    public abstract virtual IElementCollection get_Declarations();
}
public interface DevExpress.CodeParser.ILexer {
    public int Start { get; }
    public int End { get; }
    public int Line { get; }
    public int Col { get; }
    public int EndLine { get; }
    public int EndCol { get; }
    public string Comment { get; }
    public int CommentLine { get; }
    public int CommentCol { get; }
    public int CommentStart { get; }
    public int CommentEnd { get; }
    public abstract virtual bool Advance();
    public abstract virtual int Token();
    public abstract virtual string Value();
    public abstract virtual char CharValue();
    public abstract virtual void Reset(TextReader reader, int line, int col);
    public abstract virtual int get_Start();
    public abstract virtual int get_End();
    public abstract virtual int get_Line();
    public abstract virtual int get_Col();
    public abstract virtual int get_EndLine();
    public abstract virtual int get_EndCol();
    public abstract virtual string get_Comment();
    public abstract virtual int get_CommentLine();
    public abstract virtual int get_CommentCol();
    public abstract virtual int get_CommentStart();
    public abstract virtual int get_CommentEnd();
}
public interface DevExpress.CodeParser.ILocalDeclaration {
    public bool IsImplicit { get; }
    public bool IsReturnedValue { get; }
    public abstract virtual bool get_IsImplicit();
    public abstract virtual bool get_IsReturnedValue();
}
public interface DevExpress.CodeParser.ILockStatement {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.ILogicalInversionExpression {
}
public interface DevExpress.CodeParser.ILogicalOperationExpression {
    public LogicalOperator LogicalOperator { get; }
    public abstract virtual LogicalOperator get_LogicalOperator();
}
public class DevExpress.CodeParser.ImageIndex : object {
    public static int None;
    public static int Assignment;
    public static int BaseType;
    public static int CaseBlock;
    public static int CatchBlock;
    public static int Class;
    public static int ClassAliasImport;
    public static int CodeBlock;
    public static int CSharpComment;
    public static int ConditionalDirective;
    public static int Constructor;
    public static int Delegate;
    public static int CSharpDocComment;
    public static int DoWhile;
    public static int ElseBlock;
    public static int EnumElement;
    public static int Enumeration;
    public static int Event;
    public static int Expression;
    public static int Field;
    public static int File;
    public static int FinallyBlock;
    public static int FlowBreak;
    public static int ForEach;
    public static int ForLoop;
    public static int IfBlock;
    public static int IndexedProperty;
    public static int Interface;
    public static int Internal;
    public static int Lock;
    public static int Method;
    public static int MethodCall;
    public static int Namespace;
    public static int Private;
    public static int Property;
    public static int Protected;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ImageIndex.ProtectedOrInternal instead.")]
public static int ProtectedInternal;
    public static int ProtectedOrInternal;
    public static int Reference;
    public static int Region;
    public static int ResourceString;
    public static int RootNode;
    public static int Set;
    public static int StaticClass;
    public static int StaticConstructor;
    public static int StaticField;
    public static int StaticIndexedProperty;
    public static int StaticMethod;
    public static int StaticProperty;
    public static int StaticStruct;
    public static int Struct;
    public static int SwitchStatement;
    public static int ThreadVar;
    public static int TryBlock;
    public static int UsingOrImports;
    public static int UsingStatement;
    public static int WhileDo;
    public static int WithBlock;
    public static int DocumentElement;
    public static int LanguageElement;
    public static int BitwiseEnum;
    public static int StaticEnumeration;
    public static int StaticBitwiseEnum;
    public static int Constant;
    public static int StaticConstant;
    public static int FixedField;
    public static int FixedBlock;
    public static int Param;
    public static int ParamIn;
    public static int ParamOut;
    public static int ParamRef;
    public static int ParamArray;
    public static int Attribute;
    public static int AssemblyCode;
    public static int IllegalVisibility;
    public static int VisualBasicSourceFile;
    public static int CPlusPlusSourceFile;
    public static int CSharpSourceFile;
    public static int VisualJSharpSourceFile;
    public static int StaticEvent;
    public static int Abort;
    public static int Continue;
    public static int Return;
    public static int Throw;
    public static int Break;
    public static int Goto;
    public static int Label;
    public static int Statement;
    public static int End;
    public static int Stop;
    public static int TypeCast;
    public static int TypeOf;
    public static int ObjectCreation;
    public static int BinaryOperator;
    public static int MethodCallExpression;
    public static int TypeReference;
    public static int MethodReference;
    public static int Module;
    public static int ElementReference;
    public static int PrimitiveExpression;
    public static int ArgumentDirection;
    public static int ThisReference;
    public static int UnaryOperator;
    public static int Indexer;
    public static int AddressOfExpression;
    public static int ArrayCreateExpression;
    public static int BaseReference;
    public static int CheckedExpression;
    public static int UncheckedExpression;
    public static int ConditionalExpression;
    public static int IsExpression;
    public static int Public;
    public static int Comment;
    public static int DocComment;
    public static int DocCommentSummary;
    public static int DocCommentParam;
    public static int DocCommentReturns;
    public static int DocCommentSeeAlso;
    public static int DocCommentElement;
    public static int ProtectedAndInternal;
    public static int DocCommentText;
    public static int DocCommentAttribute;
    public static int DocCommentList;
    public static int DocCommentItem;
    public static int DocCommentCodeMultiLine;
    public static int DocCommentCodeSingleLine;
    public static int DocCommentParagraph;
    public static int LogicalOperation;
    public static int LogicalInversion;
    public static int UnaryIncrement;
    public static int UnaryDecrement;
    public static int RelationalOperation;
    public static int TypeParameter;
    public static int NestedMethod;
    public static int HtmlScript;
    public static int ServerControlElement;
    public static int AspCodeNugget;
    public static int XmlElement;
    public static int Project;
    public static int WebProject;
    public static int AspxFile;
    public static int CodeBehindFile;
    public static int StyleSheet;
    public static int WebConfig;
    public static int XamlFile;
    public static int SqlFile;
    public static int YieldBreak;
    public static int YieldReturn;
    public static int MarkupExtensionExpression;
    public static int DependencyProperty;
}
public interface DevExpress.CodeParser.IMarkupElement {
}
public interface DevExpress.CodeParser.IMarkupExtensionExpression {
}
public interface DevExpress.CodeParser.IMemberAccessExpression {
    public IWithStatement ParentWith { get; }
    public abstract virtual IWithStatement get_ParentWith();
}
public interface DevExpress.CodeParser.IMemberElement {
    public IExpressionCollection Implements { get; }
    public IExpression NameQualifier { get; }
    public MemberVisibility Visibility { get; }
    public bool IsDefaultVisibility { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsNew { get; }
    public bool IsPartial { get; }
    public bool IsReadOnly { get; }
    public bool IsStatic { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsExplicitInterfaceMember { get; }
    public bool IsIterator { get; }
    public string Signature { get; }
    public bool HasDelimitedBlock { get; }
    public abstract virtual string GetOverrideCode();
    public abstract virtual string GetOverrideCode(bool callBase);
    public abstract virtual string GetOverrideCode(bool callBase, string codeBefore, string codeAfter);
    public abstract virtual IExpressionCollection get_Implements();
    public abstract virtual IExpression get_NameQualifier();
    public abstract virtual MemberVisibility get_Visibility();
    public abstract virtual bool get_IsDefaultVisibility();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsOverride();
    public abstract virtual bool get_IsNew();
    public abstract virtual bool get_IsPartial();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsExtern();
    public abstract virtual bool get_IsExplicitInterfaceMember();
    public abstract virtual bool get_IsIterator();
    public abstract virtual string get_Signature();
    public abstract virtual bool get_HasDelimitedBlock();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IMemberElementCollection {
    public IMemberElement Item { get; }
    public abstract virtual int IndexOf(IMemberElement m);
    public abstract virtual IMemberElement get_Item(int index);
    public abstract virtual IEnumerable`1<IElement> GetEnumerable();
}
public interface DevExpress.CodeParser.IMemberElementModifier {
    public abstract virtual void SetVisibility(MemberVisibility visibility);
    public abstract virtual void SetIsStatic(bool isStatic);
    public abstract virtual void SetIsAbstract(bool isAbstract);
    public abstract virtual void SetIsSealed(bool isSealed);
    public abstract virtual void SetIsVirtual(bool isVirtual);
    public abstract virtual void SetIsOverride(bool isOverride);
    public abstract virtual void SetIsExtern(bool isExtern);
    public abstract virtual void SetIsReadOnly(bool isReadOnly);
}
public interface DevExpress.CodeParser.IMemberInitializerExpression {
    public IExpression Value { get; }
    public abstract virtual IExpression get_Value();
}
public interface DevExpress.CodeParser.IMethodCallExpression {
    public IExpressionCollection Arguments { get; }
    public abstract virtual IExpressionCollection get_Arguments();
}
public interface DevExpress.CodeParser.IMethodCallStatement {
    public IExpressionCollection Arguments { get; }
    public abstract virtual IExpressionCollection get_Arguments();
}
public interface DevExpress.CodeParser.IMethodElement {
    public bool IsConstructor { get; }
    public bool IsAsynchronous { get; }
    public bool IsSerializationConstructor { get; }
    public bool IsDestructor { get; }
    public bool IsTypeInitializer { get; }
    public bool HasImplicitVariable { get; }
    public MethodTypeEnum MethodType { get; }
    public IBaseVariable ImplicitVariable { get; }
    public bool IsMemberFunctionConst { get; }
    public bool IsClassOperator { get; }
    public bool IsImplicitCast { get; }
    public bool IsExplicitCast { get; }
    public bool IsWebMethod { get; }
    public IExpressionCollection HandlesExpressions { get; }
    public IExpressionCollection ImplementsExpressions { get; }
    public string Lib { get; }
    public string Alias { get; }
    public abstract virtual bool IsExtensionMethod();
    public abstract virtual bool IsExtensionMethod(ISourceTreeResolver resolver);
    public abstract virtual bool IsMainProcedure();
    public abstract virtual bool IsInitializeComponent();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual bool get_IsAsynchronous();
    public abstract virtual bool get_IsSerializationConstructor();
    public abstract virtual bool get_IsDestructor();
    public abstract virtual bool get_IsTypeInitializer();
    public abstract virtual bool get_HasImplicitVariable();
    public abstract virtual MethodTypeEnum get_MethodType();
    public abstract virtual IBaseVariable get_ImplicitVariable();
    public abstract virtual bool get_IsMemberFunctionConst();
    public abstract virtual bool get_IsClassOperator();
    public abstract virtual bool get_IsImplicitCast();
    public abstract virtual bool get_IsExplicitCast();
    public abstract virtual bool get_IsWebMethod();
    public abstract virtual IExpressionCollection get_HandlesExpressions();
    public abstract virtual IExpressionCollection get_ImplementsExpressions();
    public abstract virtual string get_Lib();
    public abstract virtual string get_Alias();
}
public interface DevExpress.CodeParser.IMethodElementModifier {
    public abstract virtual void SetIsClassOperator(bool isClassOpearator);
    public abstract virtual void SetIsImplicitCast(bool isImplicitCast);
    public abstract virtual void SetIsExplicitCast(bool isExplicitCast);
}
public interface DevExpress.CodeParser.IMethodGroupElement {
    public IMemberElementCollection Elements { get; }
    public abstract virtual IMemberElementCollection get_Elements();
}
public interface DevExpress.CodeParser.IMethodPrototypeElement {
}
public interface DevExpress.CodeParser.IMethodReferenceExpression {
}
public interface DevExpress.CodeParser.IModuleElement {
}
public class DevExpress.CodeParser.ImplicitVariable : InitializedVariable {
    public LanguageElementType ElementType { get; }
    public ImplicitVariable(string name, Expression initializer);
    public ImplicitVariable(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ImportDirective : CompilerDirective {
    private string _Expression;
    private bool _IsQuotationMarks;
    public LanguageElementType ElementType { get; }
    public string Expression { get; public set; }
    public bool IsQuotationMarks { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Expression();
    public void set_Expression(string value);
    public bool get_IsQuotationMarks();
    public void set_IsQuotationMarks(bool value);
}
public interface DevExpress.CodeParser.IMyClassExpression {
}
public interface DevExpress.CodeParser.INamedTemplateParameter {
}
public interface DevExpress.CodeParser.INamedTypeParameterConstraint {
    public ITypeReferenceExpression TypeReference { get; }
    public abstract virtual ITypeReferenceExpression get_TypeReference();
}
public interface DevExpress.CodeParser.INamespaceElement {
    public INamespaceElementCollection Namespaces { get; }
    public ITypeElementCollection Types { get; }
    public abstract virtual INamespaceElementCollection get_Namespaces();
    public abstract virtual ITypeElementCollection get_Types();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.INamespaceElementCollection {
    public INamespaceElement Item { get; }
    public abstract virtual int IndexOf(INamespaceElement e);
    public abstract virtual INamespaceElement get_Item(int index);
}
public interface DevExpress.CodeParser.INamespaceReference {
    public bool IsAlias { get; }
    public IExpression NameExpression { get; }
    public IExpression Expression { get; }
    public abstract virtual bool get_IsAlias();
    public abstract virtual IExpression get_NameExpression();
    public abstract virtual IExpression get_Expression();
}
public class DevExpress.CodeParser.IncludeDirective : CompilerDirective {
    private string _Expression;
    private bool _IsSystemFile;
    private string _FilePath;
    public LanguageElementType ElementType { get; }
    public string Expression { get; public set; }
    public bool IsSystemFile { get; public set; }
    public string FilePath { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Expression();
    public void set_Expression(string value);
    public bool get_IsSystemFile();
    public void set_IsSystemFile(bool value);
    public string get_FilePath();
    public void set_FilePath(string value);
}
public class DevExpress.CodeParser.IndexerExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _Source;
    private ExpressionCollection _Arguments;
    protected int ThisMaintenanceComplexity { get; }
    public bool NeedsInvertParens { get; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; }
    public Expression Qualifier { get; public set; }
    [ObsoleteAttribute("Use Qualifier instead")]
[EditorBrowsableAttribute("1")]
public Expression Source { get; public set; }
    public ExpressionCollection Arguments { get; public set; }
    private IExpressionCollection DevExpress.CodeParser.IIndexerExpression.Arguments { get; }
    private IExpression DevExpress.CodeParser.IWithSource.Source { get; }
    private IExpressionCollection DevExpress.CodeParser.IWithArguments.Args { get; }
    public IndexerExpression(Expression source);
    private bool ComareIndexerArguments(IndexerExpression expression);
    private void SetArguments(ExpressionCollection args);
    protected internal void SetSource(Expression source);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddArgument(Expression arg);
    public void AddArguments(IEnumerable`1<Expression> arguments);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual bool get_NeedsInvertParens();
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    public sealed virtual Expression get_Qualifier();
    public sealed virtual void set_Qualifier(Expression value);
    public sealed virtual Expression get_Source();
    public sealed virtual void set_Source(Expression value);
    public ExpressionCollection get_Arguments();
    public void set_Arguments(ExpressionCollection value);
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IIndexerExpression.get_Arguments();
    private sealed virtual override IExpression DevExpress.CodeParser.IWithSource.get_Source();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IWithArguments.get_Args();
}
public interface DevExpress.CodeParser.INestedTemplateParameter {
    public IElementCollection Parameters { get; }
    public abstract virtual IElementCollection get_Parameters();
}
public interface DevExpress.CodeParser.INewExternalIDLink {
}
public interface DevExpress.CodeParser.INewExternalIDSystemLink {
}
public interface DevExpress.CodeParser.INewExternalPublicLink {
}
public interface DevExpress.CodeParser.INewTypeParameterConstraint {
}
public class DevExpress.CodeParser.InExpression : QueryExpressionBase {
    private QueryIdent _QueryIdent;
    private Expression _Expression;
    private InExpressionType _InExpressionType;
    public QueryIdent QueryIdent { get; public set; }
    public Expression Expression { get; public set; }
    public LanguageElementType ElementType { get; }
    public InExpressionType InExpressionType { get; public set; }
    private IExpression DevExpress.CodeParser.IInExpression.Expression { get; }
    private IQueryIdent DevExpress.CodeParser.IInExpression.QueryIdent { get; }
    public InExpression(QueryIdent queryIdent, Expression exp);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public QueryIdent get_QueryIdent();
    public void set_QueryIdent(QueryIdent value);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual LanguageElementType get_ElementType();
    public virtual string ToString();
    public InExpressionType get_InExpressionType();
    public void set_InExpressionType(InExpressionType value);
    private sealed virtual override IExpression DevExpress.CodeParser.IInExpression.get_Expression();
    private sealed virtual override IQueryIdent DevExpress.CodeParser.IInExpression.get_QueryIdent();
}
public enum DevExpress.CodeParser.InExpressionType : Enum {
    public int value__;
    public static InExpressionType InExpression;
    public static InExpressionType LetExpression;
}
public enum DevExpress.CodeParser.InheritanceModel : Enum {
    public int value__;
    public static InheritanceModel Default;
    public static InheritanceModel Single;
    public static InheritanceModel Multiple;
    public static InheritanceModel Virtual;
}
public abstract class DevExpress.CodeParser.InitializedValue : Variable {
    private Expression _Expression;
    private bool _IsShortInitialize;
    [DescriptionAttribute("The expression used to initialize this variable.")]
[CategoryAttribute("")]
public Expression Expression { get; public set; }
    public bool IsShortInitialize { get; public set; }
    private bool DevExpress.CodeParser.IFieldElement.IsConst { get; }
    private IExpression DevExpress.CodeParser.IFieldElement.Expression { get; }
    private bool DevExpress.CodeParser.IFieldElement.IsBitField { get; }
    private IExpression DevExpress.CodeParser.IFieldElement.BitFieldSize { get; }
    private bool DevExpress.CodeParser.IVariableDeclarationStatement.IsConst { get; }
    private IExpression DevExpress.CodeParser.IVariableDeclarationStatement.Expression { get; }
    private bool DevExpress.CodeParser.IVariableDeclarationStatement.IsBitField { get; }
    private IExpression DevExpress.CodeParser.IVariableDeclarationStatement.BitFieldSize { get; }
    public InitializedValue(string type, string name);
    public InitializedValue(string type, string name, Expression expr);
    protected void SetExpression(Expression expression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual string GetDetailNodeDescription(int index);
    public virtual string ToString();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public bool get_IsShortInitialize();
    public void set_IsShortInitialize(bool value);
    private sealed virtual override bool DevExpress.CodeParser.IFieldElement.get_IsConst();
    private sealed virtual override IExpression DevExpress.CodeParser.IFieldElement.get_Expression();
    private sealed virtual override bool DevExpress.CodeParser.IFieldElement.get_IsBitField();
    private sealed virtual override IExpression DevExpress.CodeParser.IFieldElement.get_BitFieldSize();
    private sealed virtual override bool DevExpress.CodeParser.IVariableDeclarationStatement.get_IsConst();
    private sealed virtual override IExpression DevExpress.CodeParser.IVariableDeclarationStatement.get_Expression();
    private sealed virtual override bool DevExpress.CodeParser.IVariableDeclarationStatement.get_IsBitField();
    private sealed virtual override IExpression DevExpress.CodeParser.IVariableDeclarationStatement.get_BitFieldSize();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
}
public class DevExpress.CodeParser.InitializedVariable : InitializedValue {
    private bool _IsObjectCreationInit;
    public LanguageElementType ElementType { get; }
    public bool IsObjectCreationInit { get; public set; }
    public InitializedVariable(string name);
    public InitializedVariable(string type, string name);
    public InitializedVariable(string type, string name, Expression expr);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_IsObjectCreationInit();
    public virtual void set_IsObjectCreationInit(bool value);
}
public class DevExpress.CodeParser.InitializedVolatile : InitializedVariable {
    public LanguageElementType ElementType { get; }
    public Expression Value { get; public set; }
    public InitializedVolatile(string type, string name);
    public InitializedVolatile(string type, string name, Expression expr);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Value();
    public void set_Value(Expression value);
}
public enum DevExpress.CodeParser.InitializerTarget : Enum {
    public byte value__;
    public static InitializerTarget Ancestor;
    public static InitializerTarget ThisClass;
    public static InitializerTarget Expression;
}
public class DevExpress.CodeParser.InsignificantDirectiveText : FormattingText {
    public InsignificantDirectiveText(string text);
    public virtual object Clone();
}
public class DevExpress.CodeParser.Interface : Class {
    public LanguageElementType ElementType { get; }
    public Interface(string name);
    public virtual int GetImageIndex();
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual MemberVisibility[] GetValidVisibilities();
    public virtual LanguageElement GetMostComplexMember();
    public virtual double GetAverageCyclomaticComplexity();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.InterfaceClass : Interface {
    public LanguageElementType ElementType { get; }
    public InterfaceClass(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.InterfaceStruct : Interface {
    public LanguageElementType ElementType { get; }
    public InterfaceStruct(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.IntNum : Number {
    protected int IntItem { get; protected set; }
    protected int get_IntItem();
    protected void set_IntItem(int value);
    protected Number DoCalculate(Number param);
    protected Number ReturnNumberForItem(int item);
    public virtual Number Add(Number param);
    public virtual Number Sub(Number param);
    public virtual Number Mul(Number param);
    public virtual Number Div(Number param);
    public virtual Number ModDiv(Number param);
    public virtual Number MinusSign();
    public virtual Number PlusSign();
    public virtual Number Decrement();
    public virtual Number Increment();
    public virtual Number And(Number param);
    public virtual Number Or(Number param);
    public virtual Number Xor(Number param);
    public virtual Number LeftShift(Number param);
    public virtual Number RightShift(Number param);
    public virtual bool IsTrue();
    public virtual bool IsEqualTo(Number param);
    public virtual bool IsBelow(Number param);
    public virtual bool IsBelowOrEqual(Number param);
    public virtual bool IsGreater(Number param);
    public virtual bool IsGreaterOrEqual(Number param);
}
public class DevExpress.CodeParser.IntoExpression : QueryExpressionBase {
    private QueryIdent _IntoTarget;
    public QueryIdent IntoTarget { get; }
    public LanguageElementType ElementType { get; }
    private IQueryIdent DevExpress.CodeParser.IIntoExpression.IntoTarget { get; }
    public IntoExpression(QueryIdent intoTarget);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public void SetIntoTarget(QueryIdent intoTarget);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public QueryIdent get_IntoTarget();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IQueryIdent DevExpress.CodeParser.IIntoExpression.get_IntoTarget();
    public virtual string ToString();
}
public interface DevExpress.CodeParser.INullCoalescingExpression {
}
public class DevExpress.CodeParser.InversionFilter : ElementFilterBase {
    private IElementFilter _Filter;
    public InversionFilter(IElementFilter filter);
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
}
public interface DevExpress.CodeParser.IObjectCreationExpression {
    public ITypeReferenceExpression ObjectType { get; }
    public IObjectInitializerExpression ObjectInitializer { get; }
    public IExpressionCollection Arguments { get; }
    public abstract virtual ITypeReferenceExpression get_ObjectType();
    public abstract virtual IObjectInitializerExpression get_ObjectInitializer();
    public abstract virtual IExpressionCollection get_Arguments();
}
public interface DevExpress.CodeParser.IObjectInitializerExpression {
    public IExpressionCollection Initializers { get; }
    public abstract virtual IExpressionCollection get_Initializers();
}
public interface DevExpress.CodeParser.IOperatorExpression {
}
public interface DevExpress.CodeParser.IOrderByExpression {
    public IExpressionCollection Orderings { get; }
    public abstract virtual IExpressionCollection get_Orderings();
}
public interface DevExpress.CodeParser.IOrderingExpression {
    public IExpression Ordering { get; }
    public OrderingType Order { get; }
    public abstract virtual IExpression get_Ordering();
    public abstract virtual OrderingType get_Order();
}
public interface DevExpress.CodeParser.IParameterElement {
    public ArgumentDirection Direction { get; }
    public bool IsOptional { get; }
    public bool IsParamArray { get; }
    public bool IsArgList { get; }
    public IExpression DefaultValue { get; }
    public abstract virtual ArgumentDirection get_Direction();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsParamArray();
    public abstract virtual bool get_IsArgList();
    public abstract virtual IExpression get_DefaultValue();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IParameterElementCollection {
    public IParameterElement Item { get; }
    public abstract virtual int IndexOf(IParameterElement e);
    public abstract virtual IParameterElement get_Item(int index);
}
public interface DevExpress.CodeParser.IParameterElementModifier {
    public abstract virtual void SetType(ITypeReferenceExpression type);
    public abstract virtual void SetDirection(ArgumentDirection direction);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use IParameterElementModifier.")]
public interface DevExpress.CodeParser.IParameterModifier {
    public abstract virtual void SetType(ITypeReferenceExpression type);
}
public interface DevExpress.CodeParser.IParenthesizedExpression {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IParsedFile {
}
public interface DevExpress.CodeParser.IPointerElementReference {
}
public interface DevExpress.CodeParser.IPrimitiveExpression {
    public bool IsBooleanLiteral { get; }
    public bool IsStringLiteral { get; }
    public bool IsCharLiteral { get; }
    public bool IsNullLiteral { get; }
    public object Value { get; }
    public bool IsVerbatimString { get; }
    public PrimitiveType PrimitiveType { get; }
    public abstract virtual bool get_IsBooleanLiteral();
    public abstract virtual bool get_IsStringLiteral();
    public abstract virtual bool get_IsCharLiteral();
    public abstract virtual bool get_IsNullLiteral();
    public abstract virtual object get_Value();
    public abstract virtual bool get_IsVerbatimString();
    public abstract virtual PrimitiveType get_PrimitiveType();
}
public interface DevExpress.CodeParser.IProjectElement {
    public IProjectSourceModelCache SourceModel { get; }
    public bool HasRootNamespace { get; }
    public string RootNamespace { get; }
    public bool IsClosed { get; }
    public bool IsCaseSensitiveLanguage { get; }
    public string Language { get; }
    public ISolutionElement Solution { get; }
    public string Name { get; }
    public string FullName { get; }
    public bool HasNativeCompileOptions { get; }
    public bool HasOldSyntaxCompileOptions { get; }
    public bool CanUseAspImportedNamespaces { get; }
    public string AssemblyName { get; }
    public String[] FriendAssemblyNames { get; }
    public StringCollection ImportedNamespaces { get; }
    public FrameworkVersion TargetFramework { get; }
    public bool NotImportStdLib { get; }
    public bool SupportsRootNamespace { get; }
    public OptionInfer OptionInfer { get; public set; }
    public OptionStrict OptionStrict { get; public set; }
    public OptionExplicit OptionExplicit { get; public set; }
    public int AllFilesCount { get; }
    public NodeList AllFiles { get; }
    public string FilePath { get; }
    public bool IsMiscProject { get; }
    public bool IsWebSite { get; }
    public String[] Defines { get; }
    public Dictionary`2<string, object> ValueDefines { get; }
    public abstract virtual FilteredSourceFile[] FilterDiskFiles(string name);
    public abstract virtual FilteredSourceFile[] FilterDiskFiles(StringCollection names);
    [EditorBrowsableAttribute("1")]
public abstract virtual FilteredSourceFile[] FilterDiskFile(StringCollection names, SourceFile proxy);
    public abstract virtual ISourceFileCollection GetAllFiles();
    public abstract virtual void ReleaseAllDiskFiles();
    public abstract virtual IElement FindByFullNameInsideAssemblies(string fullName, bool cache, bool isCaseSensitive);
    public abstract virtual IElementCollection FindElementsByFullNameInsideAssemblies(string fullName, bool cache, bool isCaseSensitive);
    public abstract virtual IElement FindElementInsideDefaultNamespace(string name);
    public abstract virtual IElement FindElementInsideDefaultNamespace(string name, bool isCaseSensitive);
    public abstract virtual IElement FindElementInsideNamespace(string namespaceFullName, string name);
    public abstract virtual IElement FindElementInsideNamespace(string namespaceFullName, string name, bool isCaseSensitive);
    public abstract virtual IElement FindElementInsideParentNamespace(string namespaceFullName, string name);
    public abstract virtual IElement FindElementInsideParentNamespace(string namespaceFullName, string name, bool isCaseSensitive);
    public abstract virtual IElement FindElementInsideParentNamespace(IElement start, string name);
    public abstract virtual IElement FindElementByFullName(string fullName);
    public abstract virtual IElement FindElementByFullName(string fullName, bool isCaseSensitive);
    public abstract virtual IElement FindElementByFullName(string fullName, bool searchInAssemblies, bool cache);
    public abstract virtual IElement FindElementByFullName(string fullName, bool searchInAssemblies, bool cache, bool isCaseSensitive);
    [ObsoleteAttribute("Use FindElementByFullName instead.")]
[EditorBrowsableAttribute("1")]
public abstract virtual IElement FindTypeOrNamespaceByFullName(string fullName, bool searchInAssemblies, bool cache);
    public abstract virtual IAssemblyReference FindAssemblyByAlias(string alias);
    public abstract virtual IElementCollection FindAllAssembliesByAlias(string alias);
    public abstract virtual IElement FindElementInsideIncludes(string filePath, string name);
    public abstract virtual IElementCollection FindExtensionMethods(string nameSpace, string name, bool isCaseSensitive);
    public abstract virtual IElementCollection FindExtensionMethods(ISourceTreeResolver resolver, string nameSpace, string name, bool isCaseSensitive);
    public abstract virtual StringCollection GetFileImportedNamespaces(ISourceFile file);
    [EditorBrowsableAttribute("1")]
public abstract virtual StringCollection GetFileImportedNamespaces(SourceFile file, bool useFileUsingList);
    public abstract virtual IElementCollection GetModuleMembers(string name);
    public abstract virtual IElementCollection GetModules(string name);
    public abstract virtual IElementFilter GetDirectlyVisibleMembersFilter();
    public abstract virtual bool IsBuiltInType(string name);
    public abstract virtual bool IsBuiltInType(IElement element, string name);
    public abstract virtual string GetFullTypeName(string name);
    public abstract virtual string GetFullTypeName(IElement element, string name);
    public abstract virtual string GetSimpleTypeName(string name);
    public abstract virtual string GetSimpleTypeName(IElement element, string name);
    public abstract virtual ISourceFile FindDiskFile(string path);
    public abstract virtual ISourceFile FindDiskFile(ISourceFile file);
    public abstract virtual bool IsCaseSensitive(IElement element);
    public abstract virtual IElementCollection FindCssStylesByClassName(ISourceFile file, string styleName, string ancestorName);
    public abstract virtual IElementCollection FindCssStylesById(ISourceFile file, string id, string ancestorName);
    public abstract virtual IEnumerable`1<IAttributeElement> GetAssemblyAttributes();
    public abstract virtual IProjectSourceModelCache get_SourceModel();
    public abstract virtual bool get_HasRootNamespace();
    public abstract virtual string get_RootNamespace();
    public abstract virtual bool get_IsClosed();
    public abstract virtual bool get_IsCaseSensitiveLanguage();
    public abstract virtual string get_Language();
    public abstract virtual ISolutionElement get_Solution();
    public abstract virtual string get_Name();
    public abstract virtual string get_FullName();
    public abstract virtual bool get_HasNativeCompileOptions();
    public abstract virtual bool get_HasOldSyntaxCompileOptions();
    public abstract virtual bool get_CanUseAspImportedNamespaces();
    public abstract virtual string get_AssemblyName();
    public abstract virtual String[] get_FriendAssemblyNames();
    public abstract virtual StringCollection get_ImportedNamespaces();
    public abstract virtual FrameworkVersion get_TargetFramework();
    public abstract virtual bool get_NotImportStdLib();
    public abstract virtual bool get_SupportsRootNamespace();
    public abstract virtual void InvalidateProjectSymbols(SourceFile sourceFile);
    public abstract virtual void ReleaseDiskFile(SourceFile proxy);
    public abstract virtual void BuildProjectSymbols(SourceFile sourceFile);
    public abstract virtual SourceFile SynchronizeDiskFile(string name, SourceFile value);
    public abstract virtual void RemoveFilePathsForMacroCalls(List`1<string> macroCalls, string fileName);
    public abstract virtual OptionInfer get_OptionInfer();
    public abstract virtual void set_OptionInfer(OptionInfer value);
    public abstract virtual OptionStrict get_OptionStrict();
    public abstract virtual void set_OptionStrict(OptionStrict value);
    public abstract virtual OptionExplicit get_OptionExplicit();
    public abstract virtual void set_OptionExplicit(OptionExplicit value);
    public abstract virtual IElement GetParent(LanguageElementType languageElementType);
    public abstract virtual int get_AllFilesCount();
    public abstract virtual NodeList get_AllFiles();
    public abstract virtual string get_FilePath();
    public abstract virtual bool get_IsMiscProject();
    public abstract virtual bool get_IsWebSite();
    public abstract virtual String[] get_Defines();
    public abstract virtual Dictionary`2<string, object> get_ValueDefines();
    public abstract virtual void ClearProjectSymbols(SourceFile sourceFile);
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IProjectElementCollection {
    public IProjectElement Item { get; }
    public abstract virtual int IndexOf(IProjectElement e);
    public abstract virtual IProjectElement get_Item(int index);
}
public interface DevExpress.CodeParser.IProjectSourceModelCache {
    public abstract virtual void DisableSymbolsSync();
    public abstract virtual void EnableSymbolsSync();
}
public interface DevExpress.CodeParser.IPropertyElement {
    public bool IsIndexed { get; }
    public bool IsAutoImplemented { get; }
    public IMethodElement GetMethod { get; }
    public IMethodElement SetMethod { get; }
    public IExpression Initializer { get; }
    public abstract virtual bool get_IsIndexed();
    public abstract virtual bool get_IsAutoImplemented();
    public abstract virtual IMethodElement get_GetMethod();
    public abstract virtual IMethodElement get_SetMethod();
    public abstract virtual IExpression get_Initializer();
}
public interface DevExpress.CodeParser.IPropertyElementModifier {
    public abstract virtual void SetGetMethod(IMethodElement method);
    public abstract virtual void SetSetMethod(IMethodElement method);
}
public interface DevExpress.CodeParser.IQualifiedAliasExpression {
    public bool IsGlobal { get; }
    public abstract virtual bool get_IsGlobal();
}
public interface DevExpress.CodeParser.IQualifiedElementReferenceExpression {
}
public interface DevExpress.CodeParser.IQualifiedNestedReference {
}
[EditorBrowsableAttribute("1")]
public interface DevExpress.CodeParser.IQueryableCollectionReferenceExpression {
    public IExpression Expression { get; }
    public IExpressionCollection AdditionalExpressions { get; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual IExpressionCollection get_AdditionalExpressions();
}
public interface DevExpress.CodeParser.IQueryExpression {
    public IExpression Translation { get; }
    public abstract virtual IExpression get_Translation();
}
public interface DevExpress.CodeParser.IQueryExpressionBase {
}
public interface DevExpress.CodeParser.IQueryIdent {
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IQueryIdentCollection {
    public IQueryIdent Item { get; }
    public abstract virtual int IndexOf(IQueryIdent e);
    public abstract virtual IQueryIdent get_Item(int index);
}
public interface DevExpress.CodeParser.IRazorCodeParser {
    public abstract virtual LanguageElementCollection ParseRazorFunctions(ISourceReader reader, Int32& scannerPositionDelta);
    public abstract virtual LanguageElementCollection ParseRazorCode(ISourceReader reader, Int32& scannerPositionDelta);
    public abstract virtual LanguageElement ParseRazorHelper(ISourceReader reader, Int32& scannerPositionDelta);
}
public interface DevExpress.CodeParser.IReDimExpression {
    public ICollection Modifiers { get; }
    public IExpression Expression { get; }
    public abstract virtual ICollection get_Modifiers();
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IRefClassElement {
}
public interface DevExpress.CodeParser.IReferenceExpression {
    public string FullSignature { get; }
    public IExpression NameQualifier { get; }
    [EditorBrowsableAttribute("1")]
public bool IsMulOperator { get; }
    public abstract virtual string get_FullSignature();
    public abstract virtual IExpression get_NameQualifier();
    public abstract virtual bool get_IsMulOperator();
}
public interface DevExpress.CodeParser.IRefStructElement {
}
public interface DevExpress.CodeParser.IRegions {
    public RegionDirectiveCollection Regions { get; }
    public RegionDirective RegionRootNode { get; }
    public abstract virtual RegionDirectiveCollection get_Regions();
    public abstract virtual RegionDirective get_RegionRootNode();
}
public interface DevExpress.CodeParser.IRelationalOperationExpression {
    public RelationalOperator RelationalOperator { get; }
    public abstract virtual RelationalOperator get_RelationalOperator();
}
public interface DevExpress.CodeParser.IRemoveHandlerStatement {
}
public interface DevExpress.CodeParser.IResolvingCache {
    public abstract virtual void AddElementType(IElement element, IElement type);
    public abstract virtual IElement GetElementType(IElement element);
    public abstract virtual bool ContainsElementType(IElement element);
    public abstract virtual void AddResolvedElement(IElement element, IElement type);
    public abstract virtual void AddResolvedElement(IElement element, IElement type, bool resolveMethodGroup);
    public abstract virtual IElement GetResolvedElement(IElement element);
    public abstract virtual IElement GetResolvedElement(IElement element, bool resolveMethodGroup);
    public abstract virtual bool ContainsResolvedElement(IElement element);
    public abstract virtual bool ContainsResolvedElement(IElement element, bool resolveMethodGroup);
    public abstract virtual void AddElementModules(IElement element, IElementCollection modules);
    public abstract virtual IElementCollection GetElementModules(IElement element);
    public abstract virtual bool ContainsElementModules(IElement element);
    public abstract virtual void AddModuleMembers(IElement element, string name, IElementCollection elements);
    public abstract virtual IElementCollection GetModuleMembers(IElement element, string name, bool caseSensitive);
    public abstract virtual bool ContainsModuleMembers(IElement element, string name, bool caseSensitive);
    public abstract virtual void AddResolvedMethodGroup(IElement element, IElement type);
    public abstract virtual IElement GetResolvedMethodGroup(IElement element);
    public abstract virtual bool ContainsResolvedMethodGroup(IElement element);
    public abstract virtual void AddMetaDataElement(string fullName, IElement element);
    public abstract virtual IElement GetMetaDataElement(string fullName);
    public abstract virtual bool ContainsMetaDataElement(string fullName);
    public abstract virtual void AddTypeRef(IElement type, ITypeReferenceExpression reference);
    public abstract virtual ITypeReferenceExpression GetTypeRef(IElement type);
    public abstract virtual SiblingHelper GetSiblingHelper(IElement element);
    public abstract virtual bool ContainsTypeRef(IElement type);
}
public interface DevExpress.CodeParser.IReturnStatement {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public class DevExpress.CodeParser.Is : TypeCheck {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public bool NeedsInvertParens { get; }
    public LanguageElementType ElementType { get; }
    public Is(Expression left, Token token, Expression right);
    public Is(Expression left, Expression right);
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual bool get_NeedsInvertParens();
    public virtual LanguageElementType get_ElementType();
}
public interface DevExpress.CodeParser.ISelectExpression {
    public IElementCollection ReturnedElements { get; }
    public abstract virtual IElementCollection get_ReturnedElements();
}
public interface DevExpress.CodeParser.ISerializableCollection {
    public CollectionType CollectionType { get; }
    public abstract virtual CollectionType get_CollectionType();
}
public interface DevExpress.CodeParser.IShortInitializeExpression {
    public IExpressionCollection Arguments { get; }
    public abstract virtual IExpressionCollection get_Arguments();
}
public interface DevExpress.CodeParser.ISizeOfExpression {
    public IExpression TypeReference { get; }
    public abstract virtual IExpression get_TypeReference();
}
public interface DevExpress.CodeParser.ISnippetCodeElement {
    public string Code { get; }
    public abstract virtual string get_Code();
}
public class DevExpress.CodeParser.IsNot : TypeCheck {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public bool NeedsInvertParens { get; }
    public LanguageElementType ElementType { get; }
    public IsNot(Expression left, Token token, Expression right);
    public IsNot(Expression left, Expression right);
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual bool get_NeedsInvertParens();
    public virtual LanguageElementType get_ElementType();
}
public interface DevExpress.CodeParser.ISolutionElement {
    public IProjectElementCollection Projects { get; }
    public IResolvingCache ResolvingCache { get; }
    public abstract virtual IProjectElementCollection get_Projects();
    public abstract virtual IResolvingCache get_ResolvingCache();
}
public interface DevExpress.CodeParser.ISourceFile {
    public NameValueCollection AliasList { get; }
    public Hashtable AliasHash { get; }
    public SortedList AssemblyList { get; }
    public string AspPageBaseType { get; }
    public SortedList UsingList { get; }
    public abstract virtual NameValueCollection get_AliasList();
    public abstract virtual Hashtable get_AliasHash();
    public abstract virtual SortedList get_AssemblyList();
    public abstract virtual string get_AspPageBaseType();
    public abstract virtual SortedList get_UsingList();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ISourceFileCollection {
    public ISourceFile Item { get; }
    public abstract virtual int IndexOf(ISourceFile f);
    public abstract virtual int IndexOf(string fileName);
    public abstract virtual ISourceFile get_Item(int index);
}
public interface DevExpress.CodeParser.ISourceFileManager {
    [ObsoleteAttribute("Use GetParsedFile(ISourceFile proxy, ParsingMode mode)")]
public abstract virtual ISourceFile GetParsedFile(ISourceFile proxy, bool bindComments);
    public abstract virtual ISourceFile GetParsedFile(ISourceFile proxy, ParsingMode mode);
}
public interface DevExpress.CodeParser.ISourceReader {
    public int StartLine { get; }
    public int StartColumn { get; }
    public bool IsDocumentReader { get; }
    public bool IsDisposing { get; }
    public bool IsDisposed { get; }
    public abstract virtual int get_StartLine();
    public abstract virtual int get_StartColumn();
    public abstract virtual TextReader GetStream();
    public abstract virtual void OffsetSubStream(int line, int column);
    public abstract virtual ISourceReader GetSubStream(int startPos, int length, int line, int column);
    public abstract virtual bool get_IsDocumentReader();
    public abstract virtual bool get_IsDisposing();
    public abstract virtual bool get_IsDisposed();
}
public interface DevExpress.CodeParser.ISourceTreeResolver {
    public ISourceTreeResolverOptions Options { get; }
    public abstract virtual void BeginResolve();
    public abstract virtual void EndResolve();
    public abstract virtual bool IsTypeReference(IElement type, IElement start);
    public abstract virtual bool IsDeclarationOverridden(IElement declaration, IElement target);
    public abstract virtual ArrayList ResolveAncestorInterfaces(ITypeElement type);
    public abstract virtual IElement ResolveTypeAncestor(ITypeElement type);
    public abstract virtual ITypeElement[] ResolveBaseTypes(ITypeElement type);
    public abstract virtual ITypeElement[] ResolveAllBaseTypes(ITypeElement type);
    public abstract virtual ArrayList ResolveList(IElement element, StringCollection simpleNames);
    public abstract virtual ArrayList Resolve(IElement start, string fullName);
    public abstract virtual ArrayList Resolve(IElement start, string fullName, bool isNamespace);
    public abstract virtual IElement ResolveFirst(IElement start, string fullName);
    public abstract virtual IElement ResolveFirst(IElement start, string fullName, bool isNamespace);
    public abstract virtual IElement ResolveType(IElement start, string typeName);
    public abstract virtual IElementCollection ResolveTypes(IElement start, string typeName, bool breakOnFirstFound);
    public abstract virtual IElement FindLocalDeclaration(IElement element);
    public abstract virtual IElement FindLocalDeclaration(IElement start, string name);
    public abstract virtual IElement FindFieldDeclaration(IElement element);
    public abstract virtual IElementCollection FindConstructors(IObjectCreationExpression element, IExpressionCollection arguments);
    public abstract virtual IElementCollection FindConstructors(IConstructorInitializerElement element, IExpressionCollection arguments);
    public abstract virtual IElementCollection FindConstructors(IMethodReferenceExpression reference, IExpressionCollection arguments);
    public abstract virtual IElementCollection FindConstructors(ITypeElement type, IExpressionCollection arguments);
    public abstract virtual IElementCollection FindConstructors(IElement start, ITypeElement type, IExpressionCollection arguments);
    public abstract virtual IElement FindFirstDeclaration(IExpression expression);
    public abstract virtual IElement FindFirstElementDeclaration(IElement element);
    public abstract virtual IElementCollection FindElementDeclarations(IElement element);
    public abstract virtual IElementCollection FindMethodDeclarations(IExpression element, IExpressionCollection arguments, bool searchOnlyInCurrentClass, bool filterByArguments);
    public abstract virtual IElementCollection FilterExplicitDeclarationsIfNeeded(IElementCollection declarations, IExpression active);
    public abstract virtual IElement FindMatchingMember(IElementCollection members, IMemberElement member);
    public abstract virtual IElementCollection FindMatchingMembers(IElementCollection members, IMemberElement member, bool ignoreInterfaceName);
    [EditorBrowsableAttribute("1")]
public abstract virtual IElementCollection FindMatchingMembers(IElementCollection members, IMemberElement member, bool ignoreInterfaceName, bool checkExplicitMembers);
    public abstract virtual ITypeElement FindParentType(IElement element);
    public abstract virtual IMethodPrototypeElement FindPrototype(IMethodElement method);
    public abstract virtual IMethodPrototypeElement[] FindPrototypes(IMethodElement method);
    public abstract virtual IFieldElement[] FindPrototypes(IBaseVariable variable);
    [EditorBrowsableAttribute("1")]
public abstract virtual IElement FindAccessorPrototype(IMethodElement method);
    public abstract virtual IFieldElement FindPrototype(IBaseVariable variable);
    public abstract virtual IElement FindAttributeDeclaration(IElement element);
    [EditorBrowsableAttribute("1")]
public abstract virtual IMemberElement GetBaseMember(IMemberElement target);
    public abstract virtual IElement Resolve(IElementReferenceExpression expression);
    public abstract virtual IElement Resolve(IAddressOfExpression expression);
    public abstract virtual IElement Resolve(IAwaitExpression expression);
    public abstract virtual IElement Resolve(IArrayCreateExpression expression);
    public abstract virtual IElement Resolve(IArgumentDirectionExpression expression);
    public abstract virtual IElement Resolve(IAssignmentExpression expression);
    public abstract virtual IElement Resolve(ICheckedExpression expression);
    public abstract virtual IElement Resolve(IConditionalExpression expression);
    public abstract virtual IElement Resolve(IUncheckedExpression expression);
    public abstract virtual IElement Resolve(ILogicalInversionExpression expression);
    public abstract virtual IElement Resolve(ILogicalOperationExpression expression);
    public abstract virtual IElement Resolve(IRelationalOperationExpression expression);
    public abstract virtual IElement Resolve(IParenthesizedExpression expression);
    public abstract virtual IElement Resolve(IObjectCreationExpression expression);
    public abstract virtual IElement Resolve(ITypeCastExpression expression);
    public abstract virtual IElement Resolve(IConditionalTypeCast expression);
    public abstract virtual IElement Resolve(ITypeCheckExpression expression);
    public abstract virtual IElement Resolve(ITypeReferenceExpression expression);
    public abstract virtual IElement Resolve(IElement start, PrimitiveType type);
    public abstract virtual IElement Resolve(IPrimitiveExpression expression);
    public abstract virtual IElement Resolve(IThisReferenceExpression expression);
    public abstract virtual IElement Resolve(IBaseReferenceExpression expression);
    public abstract virtual IElement Resolve(IIndexerExpression expression);
    public abstract virtual IElement Resolve(ITypeOfIsExpression expression);
    public abstract virtual IElement Resolve(ISizeOfExpression expression);
    public abstract virtual IElement Resolve(IUnaryOperatorExpression expression);
    public abstract virtual IElement Resolve(IBinaryOperatorExpression expression);
    public abstract virtual IElement Resolve(ITypeOfExpression expression);
    public abstract virtual IElement Resolve(IMethodReferenceExpression expression);
    public abstract virtual IElement Resolve(IMethodCallExpression expression);
    public abstract virtual IElement Resolve(IIsNotExpression expression);
    public abstract virtual IElement Resolve(IMemberAccessExpression expression);
    public abstract virtual IElement Resolve(IQueryExpression expression);
    public abstract virtual IElement Resolve(IDefaultValueExpression expression);
    public abstract virtual IElement Resolve(IArrayInitializerExpression expression);
    public abstract virtual IElement Resolve(IAnonymousMethodExpression expression);
    public abstract virtual IElement Resolve(ILambdaExpression expression);
    public abstract virtual IElement Resolve(IMemberInitializerExpression expression);
    public abstract virtual IElement Resolve(IXmlNode expression);
    public abstract virtual IElement Resolve(IXmlExpression expression);
    public abstract virtual IElement Resolve(IXmlElementReferenceExpression expression);
    public abstract virtual IElement Resolve(IXmlAttributeReferenceExpression expression);
    public abstract virtual IElement Resolve(IGetXmlNamespaceOperator expression);
    public abstract virtual IElement Resolve(IEmptyArgumentExpression expression);
    public abstract virtual IElement Resolve(IMarkupExtensionExpression expression);
    public abstract virtual IElement ResolveElementType(IElement element);
    public abstract virtual IElement ResolveType(ITypeReferenceExpression typeRef);
    public abstract virtual IElement FindTypeOrNamespace(IElement element);
    public abstract virtual bool IsImplicitVariableReference(IElement reference);
    public abstract virtual bool IsAttributeMemberAssignment(IExpression expression);
    public abstract virtual IElement ResolveNullable(ITypeReferenceExpression typeRef);
    public abstract virtual IElement ResolveExpression(IExpression expression);
    public abstract virtual IElement ResolveExpression(IExpression expression, bool resolveMethodGroup);
    public abstract virtual IElement ResolveMethodGroup(IExpression expression);
    public abstract virtual ITypeElement ResolveCoreType(IElement start, string typeName);
    public abstract virtual ITypeElement ResolveSystemObject(IElement start);
    public abstract virtual ITypeElement ResolveSystemString(IElement start);
    public abstract virtual ITypeElement ResolveSystemArray(IElement start);
    public abstract virtual ITypeElement ResolveSystemValueType(IElement start);
    public abstract virtual ITypeElement ResolveSystemEnumType(IElement start);
    public abstract virtual ITypeElement ResolveSystemDelegateType(IElement start);
    public abstract virtual ITypeElement ResolveSystemMultiCastDelegateType(IElement start);
    public abstract virtual ITypeElement ResolveSystemNullable(IElement start);
    public abstract virtual ITypeElement ResolveSystemGenericIEnumerable(IElement start);
    public abstract virtual IElement GetDeclaration(IElement element);
    public abstract virtual IResolvingCache GetResolvingCache();
    public abstract virtual void SetActiveProject(IProjectElement project);
    public abstract virtual ISourceTreeResolverOptions get_Options();
    [EditorBrowsableAttribute("1")]
public abstract virtual IElementCollection FindAllElementDeclarations(IElement element);
}
public interface DevExpress.CodeParser.ISourceTreeResolverOptions {
    public bool SearchInAssemblies { get; public set; }
    public bool ResolveAliases { get; public set; }
    public abstract virtual bool get_SearchInAssemblies();
    public abstract virtual void set_SearchInAssemblies(bool value);
    public abstract virtual bool get_ResolveAliases();
    public abstract virtual void set_ResolveAliases(bool value);
}
public interface DevExpress.CodeParser.IStatement {
    public bool HasDelimitedBlock { get; }
    public abstract virtual IEnumerable`1<IElement> GetBlockChildren();
    public abstract virtual bool get_HasDelimitedBlock();
}
public interface DevExpress.CodeParser.IStructElement {
}
public interface DevExpress.CodeParser.IStructTypeParameterConstraint {
}
public interface DevExpress.CodeParser.IStructuralParserServices {
    public ISourceTreeResolver SourceTreeResolver { get; }
    public IFormattingService FormattingService { get; }
    public ISolutionElement ActiveSolution { get; }
    public abstract virtual ArrayList FindAllReferencesForBaseVariable(BaseVariable variable);
    public abstract virtual bool IsKeyword(string name);
    public abstract virtual bool IsKeyword(IReferenceExpression reference);
    public abstract virtual bool IsKeywordElement(IElement element);
    public abstract virtual Expression BuildQueryTranslation(QueryExpression queryExpression);
    public abstract virtual string GetEscapedString(string projectLanguage, string name, bool isVerbatim);
    public abstract virtual ISourceTreeResolver get_SourceTreeResolver();
    public abstract virtual Expression Invert(Expression expression);
    public abstract virtual Expression Simplify(Expression expression);
    public abstract virtual Expression Simplify(Expression expression, bool considerMethodCalls);
    public abstract virtual LanguageElementCollection GetUnusedDeclarations(IEnumerable allVariables);
    public abstract virtual IElement FindElementByFullName(IElementCollection iElementCollection, string fullName, bool caseSensitive);
    public abstract virtual ITypeElement[] GetAllDescendants(ITypeElement delegateDefinition);
    public abstract virtual ITypeElement[] GetAllDescendants(ITypeElement delegateDefinition, IElement scope);
    public abstract virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver, ITypeElement delegateDefinition);
    public abstract virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver, ITypeElement delegateDefinition, IElement scope);
    public abstract virtual ITypeElement[] GetDescendants(ITypeElement delegateDefinition);
    public abstract virtual ITypeElement[] GetDescendants(ITypeElement delegateDefinition, IElement scope);
    public abstract virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver, ITypeElement delegateDefinition);
    public abstract virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver, ITypeElement delegateDefinition, IElement scope);
    public abstract virtual string GetSignaturePart(IElement element);
    public abstract virtual string ReplaceAccessOperators(string fullName);
    public abstract virtual string GetOverrideCode(IMemberElement member, bool callBase, string codeBefore, string codeAfter);
    public abstract virtual TypeReferenceExpression GetMethodType(AnonymousMethodExpression anonymousMethod);
    public abstract virtual string GenerateElement(LanguageElement element);
    public abstract virtual string GenerateElement(LanguageElement element, int precedingWhiteSpaceCount);
    public abstract virtual string GenerateElement(LanguageElement element, string languageID, int precedingWhiteSpaceCount);
    public abstract virtual bool IsBuiltInType(string typeName);
    public abstract virtual string GetSimpleTypeName(string typeName);
    public abstract virtual string GetComment(string text, string languageID);
    public abstract virtual bool IdentifiersMatch(string first, string second);
    public abstract virtual string ExtractFirstIdentifier(String& remainingIdentifiers);
    public abstract virtual bool IsCollapsible(LanguageElement element);
    public abstract virtual SourceRange GetCollapsibleRange(LanguageElement element);
    public abstract virtual bool DescendsFrom(ITypeElement type, string fullTypeName);
    public abstract virtual bool DescendsFrom(ISourceTreeResolver resolver, ITypeElement type, string fullTypeName);
    public abstract virtual IElement FindElementInSnapshotStructure(IElement declaration);
    public abstract virtual bool InMacroCall(LanguageElement element);
    public abstract virtual IElement GetDeclaration(IElement element);
    public abstract virtual IElement GetDeclaration(IElement element, bool restore);
    public abstract virtual IElementCollection FindAllReferences(IElement element);
    public abstract virtual IElementCollection FindAllReferences(IElement scope, IElement element);
    public abstract virtual IAssemblyModel GetAssemblyModel(LanguageElement element);
    public abstract virtual bool IsEventHandler(IMethodElement element);
    public abstract virtual bool IsMainProcedure(Method method);
    public abstract virtual bool IsSerializationConstructor(IMethodElement method);
    public abstract virtual bool IsInitializeComponent(IMethodElement method);
    public abstract virtual bool IsInteriorPtrPointer(TypeReferenceExpression type);
    public abstract virtual IElementFilter GetMemberSignatureFilter(Method method);
    public abstract virtual ITypeElement[] GetAllBaseTypes(ITypeElement element);
    public abstract virtual bool IsWebMethod(Method method);
    public abstract virtual bool CheckExtensionMethod(IMethodElement method);
    public abstract virtual bool CheckExtensionMethod(ISourceTreeResolver resolver, IMethodElement method);
    public abstract virtual bool HasDllImportAttribute(IMethodElement method);
    public abstract virtual bool DeclarationsMatch(ISourceTreeResolver resolver, IElement first, IElement second);
    public abstract virtual bool IsIdenticalTo(IElement first, IElement second);
    public abstract virtual ITypeReferenceExpression GetInnerType(TypeReferenceExpression typeReferenceExpression);
    public abstract virtual bool UsesTypeParameters(TypeReferenceExpression typeReferenceExpression, IGenericElement generic);
    public abstract virtual bool IsTypeParameter(TypeReferenceExpression typeReferenceExpression, IGenericElement generic);
    public abstract virtual IMemberElement FindMember(ITypeElement type, string name, IElementFilter filter, bool searchInAncestors);
    public abstract virtual IMemberElementCollection FindMembers(ISourceTreeResolver resolver, ITypeElement type, string name, IElementFilter filter, bool searchInAncestors);
    public abstract virtual IMemberElementCollection FindMembers(ITypeElement type, string name, IElementFilter filter, bool searchInAncestors);
    public abstract virtual SourceFileBuildAction GetBuildAction(SourceFile sourceFile);
    public abstract virtual ParserBase GetParserFromLanguageID(string language);
    public abstract virtual IBraceSettings LoadBraceSettings();
    public abstract virtual ITabSettings GetTabSettings(ParserLanguageID language);
    public abstract virtual IFormattingService get_FormattingService();
    public abstract virtual ILogger GetLogger();
    public abstract virtual string GetXMLTagName();
    public abstract virtual ISolutionElement get_ActiveSolution();
}
public interface DevExpress.CodeParser.ISwitchStatement {
    public IExpression Expression { get; }
    public ICaseStatementCollection CaseStatements { get; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual ICaseStatementCollection get_CaseStatements();
}
public interface DevExpress.CodeParser.ITabSettings {
    public bool InsertSpaces { get; public set; }
    public int TabSize { get; public set; }
    public abstract virtual bool get_InsertSpaces();
    public abstract virtual void set_InsertSpaces(bool value);
    public abstract virtual int get_TabSize();
    public abstract virtual void set_TabSize(int value);
}
public interface DevExpress.CodeParser.ITemplateParameter {
    public IExpression DefaultValue { get; }
    public abstract virtual IExpression get_DefaultValue();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ITextRangeCollection {
    public TextRange Item { get; }
    public abstract virtual int IndexOf(TextRange r);
    public abstract virtual TextRange get_Item(int index);
}
public interface DevExpress.CodeParser.ITextStrings {
    public TextStringCollection TextStrings { get; }
    public abstract virtual TextStringCollection get_TextStrings();
}
public interface DevExpress.CodeParser.IThisReferenceExpression {
}
public interface DevExpress.CodeParser.IThrowStatement {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.ITokenCategoryHelper {
    public abstract virtual TokenCategory GetUncategorizedTokenCategory(Token token);
    public abstract virtual TokenCollection GetTokens(string code);
    public abstract virtual string GetTokenCategory(Token token);
    public abstract virtual string GetTokenCategory(Token token, ParserVersion version);
}
public interface DevExpress.CodeParser.ITokenReader {
    public Token CurrentToken { get; }
    public Token NextToken { get; }
    public bool Eof { get; }
    public abstract virtual Token get_CurrentToken();
    public abstract virtual Token get_NextToken();
    public abstract virtual bool get_Eof();
    public abstract virtual Token MoveForward();
}
public interface DevExpress.CodeParser.ITryStatement {
}
public interface DevExpress.CodeParser.ITypeCastExpression {
    public ITypeReferenceExpression TypeReference { get; }
    public IExpression Target { get; }
    public abstract virtual ITypeReferenceExpression get_TypeReference();
    public abstract virtual IExpression get_Target();
}
public interface DevExpress.CodeParser.ITypeCheckExpression {
}
public interface DevExpress.CodeParser.ITypedElementReferenceExpression {
    public char TypeCharacter { get; }
    public abstract virtual char get_TypeCharacter();
}
public interface DevExpress.CodeParser.ITypeElement {
    public ITypeReferenceExpression PrimaryAncestor { get; }
    public ITypeReferenceExpressionCollection SecondaryAncestors { get; }
    public IMemberElementCollection Members { get; }
    public bool IsTypeParameter { get; }
    public abstract virtual ITypeReferenceExpression get_PrimaryAncestor();
    public abstract virtual ITypeReferenceExpressionCollection get_SecondaryAncestors();
    public abstract virtual IMemberElementCollection get_Members();
    public abstract virtual bool get_IsTypeParameter();
    public abstract virtual ITypeElement[] GetAllDescendants();
    public abstract virtual ITypeElement[] GetAllDescendants(IElement scope);
    public abstract virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver);
    public abstract virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver, IElement scope);
    public abstract virtual ITypeElement GetBaseType();
    public abstract virtual ITypeElement GetBaseType(ISourceTreeResolver resolver);
    public abstract virtual ITypeElement[] GetBaseTypes();
    public abstract virtual ITypeElement[] GetBaseTypes(ISourceTreeResolver resolver);
    public abstract virtual ITypeElement[] GetDescendants();
    public abstract virtual ITypeElement[] GetDescendants(IElement scope);
    public abstract virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver);
    public abstract virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver, IElement scope);
    public abstract virtual bool Is(string fullTypeName);
    public abstract virtual bool Is(ITypeElement parentElement);
    public abstract virtual bool Is(Type type);
    public abstract virtual bool Is(ISourceTreeResolver resolver, string fullTypeName);
    public abstract virtual bool Is(ISourceTreeResolver resolver, ITypeElement parentElement);
    public abstract virtual bool Is(ISourceTreeResolver resolver, Type type);
    public abstract virtual bool DescendsFrom(string fullTypeName);
    public abstract virtual bool DescendsFrom(ITypeElement parentElement);
    public abstract virtual bool DescendsFrom(Type type);
    public abstract virtual bool DescendsFrom(ISourceTreeResolver resolver, string fullTypeName);
    public abstract virtual bool DescendsFrom(ISourceTreeResolver resolver, ITypeElement parentElement);
    public abstract virtual bool DescendsFrom(ISourceTreeResolver resolver, Type type);
    public abstract virtual IMemberElement FindMember(string name);
    public abstract virtual IMemberElement FindMember(string name, bool searchInAncestors);
    public abstract virtual IMemberElement FindMember(string name, IElementFilter filter, bool searchInAncestors);
    public abstract virtual IMemberElementCollection FindMembers(string name);
    public abstract virtual IMemberElementCollection FindMembers(ISourceTreeResolver resolver, string name);
    public abstract virtual IMemberElementCollection FindMembers(string name, bool searchInAncestors);
    public abstract virtual IMemberElementCollection FindMembers(string name, IElementFilter filter, bool searchInAncestors);
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ITypeElementCollection {
    public ITypeElement Item { get; }
    public abstract virtual int IndexOf(ITypeElement t);
    public abstract virtual ITypeElement get_Item(int index);
}
public interface DevExpress.CodeParser.ITypeElementModifier {
    public abstract virtual void SetPrimaryAncestor(ITypeReferenceExpression type);
    public abstract virtual void AddSecondaryAncestor(ITypeReferenceExpression type);
    public abstract virtual void AddMember(IMemberElement member);
    public abstract virtual void RemoveMember(IMemberElement member);
}
public interface DevExpress.CodeParser.ITypeOfExpression {
    public ITypeReferenceExpression TypeReference { get; }
    public abstract virtual ITypeReferenceExpression get_TypeReference();
}
public interface DevExpress.CodeParser.ITypeOfIsExpression {
    public IExpression Expression { get; }
    public ITypeReferenceExpression TypeReference { get; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual ITypeReferenceExpression get_TypeReference();
}
public interface DevExpress.CodeParser.ITypeParameter {
    public bool IsActivated { get; }
    public ITypeReferenceExpression ActivatedType { get; }
    public ITypeParameterConstraintCollection Constraints { get; }
    public TypeParameterDirection Direction { get; }
    public abstract virtual bool get_IsActivated();
    public abstract virtual ITypeReferenceExpression get_ActivatedType();
    public abstract virtual ITypeParameterConstraintCollection get_Constraints();
    public abstract virtual TypeParameterDirection get_Direction();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ITypeParameterCollection {
    public ITypeParameter Item { get; }
    public abstract virtual int IndexOf(ITypeParameter t);
    public abstract virtual ITypeParameter Find(string name);
    public abstract virtual ITypeParameter get_Item(int index);
}
public interface DevExpress.CodeParser.ITypeParameterConstraint {
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ITypeParameterConstraintCollection {
    public ITypeParameterConstraint Item { get; }
    public abstract virtual int IndexOf(ITypeParameterConstraint t);
    public abstract virtual ITypeParameterConstraint get_Item(int index);
}
public interface DevExpress.CodeParser.ITypeParameterModifier {
    public abstract virtual void SetActivatedType(ITypeReferenceExpression type);
    public abstract virtual void AddConstraint(ITypeParameterConstraint constraint);
    public abstract virtual void RemoveConstraint(ITypeParameterConstraint constraint);
    public abstract virtual void SetDirection(TypeParameterDirection direction);
}
public interface DevExpress.CodeParser.ITypeReferenceExpression {
    public ITypeReferenceExpression BaseType { get; }
    public int Rank { get; }
    public IExpressionCollection ArrayBounds { get; }
    public bool IsArrayType { get; }
    public bool IsPointerType { get; }
    public bool IsConst { get; }
    public bool IsVolatile { get; }
    public bool IsReferenceType { get; }
    public bool IsManaged { get; }
    public bool IsNullable { get; }
    public bool IsDynamic { get; }
    public bool IsUnbound { get; }
    public TypeReferenceType TypeReferenceType { get; }
    public bool HasElementType { get; }
    public abstract virtual bool IsIdenticalTo(ITypeReferenceExpression typeRef);
    public abstract virtual ITypeReferenceExpression GetElementType();
    public abstract virtual bool UsesTypeParameters(IGenericElement generic);
    public abstract virtual bool IsTypeParameter(IGenericElement generic);
    public abstract virtual ITypeReferenceExpression CreateArrayReference(int rank);
    public abstract virtual ITypeReferenceExpression get_BaseType();
    public abstract virtual int get_Rank();
    public abstract virtual IExpressionCollection get_ArrayBounds();
    public abstract virtual bool get_IsArrayType();
    public abstract virtual bool get_IsPointerType();
    public abstract virtual bool get_IsConst();
    public abstract virtual bool get_IsVolatile();
    public abstract virtual bool get_IsReferenceType();
    public abstract virtual bool get_IsManaged();
    public abstract virtual bool get_IsNullable();
    public abstract virtual bool get_IsDynamic();
    public abstract virtual bool get_IsUnbound();
    public abstract virtual TypeReferenceType get_TypeReferenceType();
    public abstract virtual bool get_HasElementType();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.ITypeReferenceExpressionCollection {
    public ITypeReferenceExpression Item { get; }
    public abstract virtual int IndexOf(ITypeReferenceExpression t);
    public abstract virtual ITypeReferenceExpression get_Item(int index);
}
public interface DevExpress.CodeParser.ITypeReferenceExpressionModifier {
    public abstract virtual ITypeReferenceExpression CreateResolvePoint();
}
public interface DevExpress.CodeParser.IUnaryDecrementExpression {
}
public interface DevExpress.CodeParser.IUnaryIncrementExpression {
}
public interface DevExpress.CodeParser.IUnaryOperatorExpression {
    [ObsoleteAttribute("Use Expression instead.")]
[EditorBrowsableAttribute("1")]
public IExpression UnaryExpression { get; }
    public IExpression Expression { get; }
    public bool IsPostOperator { get; }
    public UnaryOperatorType UnaryOperator { get; }
    public abstract virtual IExpression get_UnaryExpression();
    public abstract virtual IExpression get_Expression();
    public abstract virtual bool get_IsPostOperator();
    public abstract virtual UnaryOperatorType get_UnaryOperator();
}
public interface DevExpress.CodeParser.IUncheckedExpression {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IUncheckedStatement {
}
public interface DevExpress.CodeParser.IUnionElement {
}
public interface DevExpress.CodeParser.IUnsafeStatement {
}
public interface DevExpress.CodeParser.IUsingDeclarationStatement {
    public INamespaceReference NamespaceReference { get; }
    public abstract virtual INamespaceReference get_NamespaceReference();
}
public interface DevExpress.CodeParser.IUsingList {
    public SortedList UsingList { get; }
    public abstract virtual SortedList get_UsingList();
}
public interface DevExpress.CodeParser.IUsingStatement {
    public IElementCollection Initializers { get; }
    public abstract virtual IElementCollection get_Initializers();
}
public interface DevExpress.CodeParser.IValueClassElement {
}
public interface DevExpress.CodeParser.IValueStructElement {
}
public interface DevExpress.CodeParser.IVariableDeclarationStatement {
    public bool IsConst { get; }
    public IExpression Expression { get; }
    public bool IsBitField { get; }
    public IExpression BitFieldSize { get; }
    public bool IsVolatile { get; }
    public bool IsObjectCreationInit { get; }
    public bool IsFixedSizeBuffer { get; }
    public bool HasIterationExpression { get; }
    public IExpression IterationExpression { get; }
    public abstract virtual bool get_IsConst();
    public abstract virtual IExpression get_Expression();
    public abstract virtual bool get_IsBitField();
    public abstract virtual IExpression get_BitFieldSize();
    public abstract virtual bool get_IsVolatile();
    public abstract virtual bool get_IsObjectCreationInit();
    public abstract virtual bool get_IsFixedSizeBuffer();
    public abstract virtual bool get_HasIterationExpression();
    public abstract virtual IExpression get_IterationExpression();
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IVariableDeclarationStatementCollection {
    public IVariableDeclarationStatement Item { get; }
    public abstract virtual int IndexOf(IVariableDeclarationStatement st);
    public abstract virtual IVariableDeclarationStatement Find(string name);
    public abstract virtual IVariableDeclarationStatement get_Item(int index);
}
public interface DevExpress.CodeParser.IWhereExpression {
    public IExpression WhereClause { get; }
    public abstract virtual IExpression get_WhereClause();
}
public interface DevExpress.CodeParser.IWhileStatement {
    public IExpression Condition { get; }
    public abstract virtual IExpression get_Condition();
}
public interface DevExpress.CodeParser.IWithArguments {
    public IExpressionCollection Args { get; }
    public abstract virtual IExpressionCollection get_Args();
}
public interface DevExpress.CodeParser.IWithArgumentsModifier {
    public abstract virtual void AddArgument(IExpression argument);
    public abstract virtual void RemoveArgument(IExpression argument);
    public abstract virtual void InsertArgument(int index, IExpression argument);
}
public interface DevExpress.CodeParser.IWithParameters {
    public IParameterElementCollection Parameters { get; }
    public abstract virtual IParameterElementCollection get_Parameters();
}
public interface DevExpress.CodeParser.IWithParametersModifier {
    public abstract virtual void AddParameter(IParameterElement parameter);
    public abstract virtual void RemoveParameter(IParameterElement parameter);
    public abstract virtual void InsertParameter(int index, IParameterElement parameter);
}
public interface DevExpress.CodeParser.IWithSource {
    public IExpression Source { get; }
    public abstract virtual IExpression get_Source();
}
public interface DevExpress.CodeParser.IWithStatement {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IXmlAnyContentSpec {
}
public interface DevExpress.CodeParser.IXmlAttribute {
    public string Value { get; }
    public TextRange ValueRange { get; }
    public abstract virtual string get_Value();
    public abstract virtual TextRange get_ValueRange();
}
public interface DevExpress.CodeParser.IXmlAttributeDeclaration {
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IXmlAttributeDeclarationCollection {
    public IXmlAttributeDeclaration Item { get; }
    public abstract virtual int IndexOf(IXmlAttributeDeclaration e);
    public abstract virtual IXmlAttributeDeclaration get_Item(int index);
}
public interface DevExpress.CodeParser.IXmlAttributeListDeclaration {
    public IXmlAttributeDeclarationCollection AttributesDecl { get; }
    public abstract virtual IXmlAttributeDeclarationCollection get_AttributesDecl();
}
public interface DevExpress.CodeParser.IXmlAttributeReferenceExpression {
}
public interface DevExpress.CodeParser.IXmlBaseContentSpec {
}
public interface DevExpress.CodeParser.IXmlCharacterData {
}
public interface DevExpress.CodeParser.IXmlCharReference {
}
public interface DevExpress.CodeParser.IXmlChildrenContentSpec {
    public IXmlContentParticle Source { get; }
    public abstract virtual IXmlContentParticle get_Source();
}
public interface DevExpress.CodeParser.IXmlChoiceContentParticle {
}
public interface DevExpress.CodeParser.IXmlContentParticle {
}
[DefaultMemberAttribute("Item")]
public interface DevExpress.CodeParser.IXmlContentParticleCollection {
    public IXmlContentParticle Item { get; }
    public abstract virtual int IndexOf(IXmlContentParticle e);
    public abstract virtual IXmlContentParticle get_Item(int index);
}
public interface DevExpress.CodeParser.IXmlDocComments {
    public CommentCollection AllXmlDocComments { get; }
    public abstract virtual CommentCollection get_AllXmlDocComments();
}
public interface DevExpress.CodeParser.IXmlDocParser {
    public abstract virtual ArrayList ParseXmlDocNodes(ISourceReader reader);
    public abstract virtual ArrayList ParseXmlDocNodes(string xmlDoc);
    public abstract virtual XmlNode ParseXmlDocNode(ISourceReader reader);
    public abstract virtual XmlNode ParseXmlDocNode(string xmlDoc);
}
public interface DevExpress.CodeParser.IXmlElement {
}
public interface DevExpress.CodeParser.IXmlElementReferenceExpression {
}
public interface DevExpress.CodeParser.IXmlEmptyContentSpec {
}
public interface DevExpress.CodeParser.IXmlExpression {
}
public interface DevExpress.CodeParser.IXmlMixedContentSpec {
}
public interface DevExpress.CodeParser.IXmlName {
}
public interface DevExpress.CodeParser.IXmlNamedContentParticle {
}
public interface DevExpress.CodeParser.IXmlNamespaceReference {
}
public interface DevExpress.CodeParser.IXmlNode {
    public abstract virtual IElement Resolve(ISourceTreeResolver resolver);
}
public interface DevExpress.CodeParser.IXmlSequenceContentParticle {
}
public interface DevExpress.CodeParser.IXmlSequencedContentParticle {
}
public interface DevExpress.CodeParser.IYieldBreakStatement {
}
public interface DevExpress.CodeParser.IYieldReturnStatement {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface DevExpress.CodeParser.IYieldStatement {
}
public class DevExpress.CodeParser.JavaScript.JavaScriptCodegen : CodeGen {
    internal FormattingTable FormattingTable { get; }
    public JavaScriptCodegen(CodeGenOptions options);
    private void AddCharOperatorsToFormattingElements(FormattingTokenType tokenType, FormattingElements result);
    private bool ContextIsInitializerExpression();
    private bool ContextIsAnonymousMethodExpression();
    protected virtual DirectiveCodeGenBase CreateDirectiveGen();
    protected virtual ExpressionCodeGenBase CreateExpressionGen();
    protected virtual MemberCodeGenBase CreateMemberGen();
    protected virtual StatementCodeGenBase CreateStatementGen();
    protected virtual SupportElementCodeGenBase CreateSupportElementGen();
    protected virtual TypeDeclarationCodeGenBase CreateTypeDeclarationGen();
    protected virtual XmlCodeGenBase CreateXmlGen();
    protected virtual NamespaceReferenceGenBase CreateNamespaceReferenceGen();
    protected virtual NamespaceGenBase CreateNamespaceGen();
    protected virtual SnippetCodeGenBase CreateSnippetGen();
    protected virtual TemplateCodeGenBase CreateTemplateGen();
    protected virtual TemplateParameterCodeGenBase CreateTemplateParameterGen();
    protected virtual HtmlXmlCodeGenBase CreateHtmlXmlGen();
    internal virtual FormattingTable get_FormattingTable();
    public virtual void GenerateMemberVisibilitySpecifier(MemberVisibilitySpecifier specifier);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptExpressionCodeGen : TokenCExpressionCodeGenBase {
    public JavaScriptExpressionCodeGen(CodeGen codeGen);
    protected virtual void GenerateArgumentDirection(ArgumentDirection direction);
    protected virtual void GenerateBaseReferenceExpression(BaseReferenceExpression expression);
    protected virtual void GenerateCheckedExpression(CheckedExpression expression);
    protected virtual void GenerateConditionalTypeCast(ConditionalTypeCast expression);
    protected virtual void GenerateCppQualifiedElementReference(CppQualifiedElementReference expression);
    protected virtual void GenerateDefaultValueExpression(DefaultValueExpression expression);
    protected virtual void GenerateDeleteArrayExpression(DeleteArrayExpression expression);
    protected virtual void GenerateDistinctExpression(DistinctExpression expression);
    protected virtual void GenerateElaboratedTypeReference(ElaboratedTypeReference expression);
    protected virtual void GenerateEqualsExpression(EqualsExpression expression);
    protected virtual void GenerateFromExpression(FromExpression expression);
    protected virtual void GenerateGenericTypeArguments(TypeReferenceExpressionCollection arguments);
    protected virtual void GenerateGroupByExpression(GroupByExpression expression);
    protected virtual void GenerateInExpression(InExpression expression);
    protected virtual void GenerateIntoExpression(IntoExpression expression);
    protected virtual void GenerateJoinExpression(JoinExpression expression);
    protected virtual void GenerateJoinIntoExpression(JoinIntoExpression expression);
    protected virtual void GenerateLambdaExpression(LambdaExpression expression);
    protected virtual void GenerateLetExpression(LetExpression expression);
    protected virtual void GenerateManagedArrayCreateExpression(ManagedArrayCreateExpression expression);
    protected virtual void GenerateManagedObjectCreationExpression(ManagedObjectCreationExpression expression);
    protected virtual void GenerateNullCoalescingExpression(NullCoalescingExpression expression);
    protected virtual void GenerateOrderByExpression(OrderByExpression expression);
    protected virtual void GenerateOrderingExpression(OrderingExpression expression);
    protected virtual void GenerateParametizedArrayCreateExpression(ParametrizedArrayCreateExpression expression);
    protected virtual void GenerateParametizedObjectCreationExpression(ParametrizedObjectCreationExpression expression);
    protected virtual void GeneratePointerElementReference(PointerElementReference expression);
    protected virtual void GeneratePointerMethodReference(PointerMethodReference expression);
    protected virtual void GenerateQualifiedAliasExpression(QualifiedAliasExpression expression);
    protected virtual void GenerateQualifiedMethodReference(QualifiedMethodReference expression);
    protected virtual void GenerateQualifiedNestedReference(QualifiedNestedReference expression);
    protected virtual void GenerateQualifiedNestedTypeReference(QualifiedNestedTypeReference expression);
    protected virtual void GenerateQualifiedTypeReferenceExpression(QualifiedTypeReferenceExpression expression);
    protected virtual void GenerateQueryExpression(QueryExpression expression);
    protected virtual void GenerateSelectExpression(SelectExpression expression);
    protected virtual void GenerateUncheckedExpression(UncheckedExpression expression);
    protected virtual void GenerateWhereExpression(WhereExpression expression);
    protected virtual void GenerateArgumentDirectionExpression(ArgumentDirectionExpression expression);
    private void GenerateAnonymousConstructorExpression(AnonymousConstructorExpression expression);
    private void GenerateParenthesizedTypeReferenceExpression(ParenthesizedTypeReferenceExpression expression);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    protected virtual void GenerateAnonymousMethodExpression(AnonymousMethodExpression expression);
    protected virtual void GenerateArrayInitializerExpression(ArrayInitializerExpression expression);
    protected virtual bool GenerateExpression(Expression expression);
    protected virtual void GenerateBooleanLiteral(bool value);
    protected virtual void GenerateCharLiteral(char value);
    protected virtual void GenerateComplexExpression(ComplexExpression expression);
    protected virtual void GenerateDeleteExpression(DeleteExpression expression);
    protected void GenerateEmptyArrayElementExpression(EmptyArrayElementExpression expression);
    protected virtual void GenerateMemberInitializerExpression(MemberInitializerExpression expression);
    protected virtual void GenerateNullLiteral();
    protected virtual void GenerateNumberLiteral(string name, object value, PrimitiveType type);
    protected virtual void GenerateObjectInitializerExpression(ObjectInitializerExpression expression);
    protected virtual void GenerateStringLiteral(string value);
    protected virtual void GenerateTypeCheck(TypeCheck expression);
    protected virtual void GenerateTypeOfExpression(TypeOfExpression expression);
    protected virtual void GenerateUnaryOperatorExpression(UnaryOperatorExpression expression);
    protected virtual bool IsEscapedString(string value);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual void GenerateParameters(ICollection parameters);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptExpressionInverter : ExpressionInverterBase {
    protected virtual Expression InvertIsExpression(Is expression);
    protected virtual Expression InvertIsNotExpression(IsNot expression);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptExpressionParser : ExpressionParserBase {
    public JavaScriptExpressionParser(ParserBase parser);
    public virtual Expression Parse(ISourceReader reader);
    public virtual TypeReferenceExpression ParseTypeReferenceExpression(ISourceReader reader);
}
internal class DevExpress.CodeParser.JavaScript.JavaScriptLanguageUtils : LanguageUtils {
    public virtual Tokenizer CreateTokenizer();
    public virtual ParserBase CreateParser(ParserVersion version, EmbededLanguageKind languageKind, DotNetLanguageType embededLanguage);
    public virtual CodeGen CreateCodeGen();
    public virtual ElementBuilder CreateElementBuilder();
}
public class DevExpress.CodeParser.JavaScript.JavaScriptMemberCodeGen : MemberCodeGenBase {
    public JavaScriptMemberCodeGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    private void GenerateVariableStart(Variable member);
    private void GenerateVariableEnd(Variable member);
    protected virtual void GenerateConst(Const member);
    protected virtual void GenerateConstVolatile(ConstVolatile member);
    protected virtual void GenerateDelegate(DelegateDefinition member);
    protected virtual void GenerateEnumElement(EnumElement member);
    protected virtual void GenerateEvent(Event member);
    protected virtual void GenerateExtensionMethodParam(ExtensionMethodParam member);
    public virtual void GenerateGenericModifier(GenericModifier generic);
    protected virtual void GenerateInitializedVolatile(InitializedVolatile member);
    protected virtual void GenerateMethodPrototype(MethodPrototype member);
    protected virtual void GenerateProperty(Property member);
    protected virtual void GenerateQueryIdent(QueryIdent expression);
    public virtual void GenerateTypeParameter(TypeParameter parameter);
    public virtual void GenerateTypeParameterConstraint(TypeParameterConstraint constraint);
    protected virtual void GenerateVolatile(Volatile member);
    protected virtual void GenerateImplicitVariable(ImplicitVariable member);
    protected virtual void GenerateLambdaImplicitlyTypedParam(LambdaImplicitlyTypedParam member);
    protected virtual void GenerateMethod(Method member);
    protected virtual void GenerateVariable(Variable member);
    protected virtual void GenerateInitializedVariable(InitializedVariable member);
    protected virtual void GenerateParameter(Param member);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptParser : FormattingParserBase {
    private bool _InsideForEachLoop;
    private bool _PreviousTokenWasComment;
    private CommentCollection _Comments;
    private static int _MaxMult;
    protected bool InsideForEachLoop { get; protected set; }
    public string Language { get; }
    public CommentCollection Comments { get; }
    protected virtual void HandlePragmas();
    private void Parser();
    private void SourceElement();
    private void Statement();
    private void FunctionDeclaration();
    private void Identifier();
    private void FormalParameterList(LanguageElementCollection& parameters);
    private void FunctionBody();
    private void FormalParameter(Param& parameter);
    private void LabelledStatement();
    private void Block();
    private void EmptyStatement();
    private void ExpressionStatement();
    private void IfStatement();
    private void DoStatement();
    private void WhileStatement();
    private void ForStatements();
    private void ContinueStatement();
    private void BreakStatement();
    private void ReturnStatement();
    private void WithStatement();
    private void VariableStatement();
    private void SwitchStatement();
    private void ThrowStatement();
    private void TryStatement();
    private void StatementList();
    private void VariableDeclarationList(LanguageElementCollection& variableList);
    private void VariableDeclaration(SourceRange varRange, SourceRange startRange, Variable& variable);
    private void AssignmentExpression(Expression& result);
    private void Expression(Expression& result);
    private void CaseClause();
    private void Catch();
    private void Finally();
    private void PrimaryExpression(Expression& result);
    private void Literal(Expression& result);
    private void ArrayLiteral(Expression& result);
    private void ObjectLiteral(Expression& result);
    private void ElementList(ExpressionCollection& initializers);
    private void EmptyArrayElementExpression(Expression& result);
    private void PropertyNameAndValueList(ExpressionCollection& initializers);
    private void NameValuePair(Expression& initializer);
    private void PropertyName();
    private void TypeReference(TypeReferenceExpression& typeReference);
    private void NewExpression(Expression& result);
    private void ArgumentList(ExpressionCollection& arguments);
    private void FunctionExpression(Expression& result);
    private void MemberExpression(Expression& result);
    private void PostfixExpression(Expression& result);
    private void UnaryExpression(Expression& result);
    private void MultiplicativeExpression(Expression& result);
    private void AdditiveExpression(Expression& result);
    private void ShiftExpression(Expression& result);
    private void RelationalExpression(Expression& result);
    private void EqualityExpression(Expression& result);
    private void BitwiseAndExpression(Expression& result);
    private void BitwiseXorExpression(Expression& result);
    private void BitwiseOrExpression(Expression& result);
    private void LogicalAndExpression(Expression& result);
    private void LogicalOrExpression(Expression& result);
    private void ConditionalExpression(Expression& result);
    private void AssignmentOperator();
    private void Parse();
    protected virtual Boolean[0...,0...] CreateSetArray();
    private Expression CreateUnaryIncrement(Expression sourceExpression, Token operatorToken, bool isPostfix);
    private void ProcessExpressionForUnary(Expression expr);
    private Expression CreateUnaryDecrement(Expression sourceExpression, Token operatorToken, bool isPostfix);
    private BinaryOperatorType GetBinaryOperatorType(Token operatorToken);
    private void SetVariableProperties(BaseVariable variable, SourceRange nameRange, SourceRange varRange, SourceRange startRange, SourceRange endRange);
    private Expression GetMethodReference(Expression source);
    private LogicalOperator GetLogicalOperatorType(Token operatorToken);
    private RelationalOperator GetRelationalOperatorType(Token operatorToken);
    private AssignmentOperatorType GetOperatorType(Token operatorToken);
    private ImplicitVariable CreateImplicitVariable(string name, Expression initializer, SourceRange operatorRange);
    private bool TokenIsComment(int tokenType);
    private void SetCommentProperties(Token commentToken, string commentTokenValue, int textStartOffset, int textEndOffset, CommentType commentType, Comment comment);
    private void AddMultiLineXmlComment(Token commentToken);
    private void AddMultiLineComment(Token commentToken);
    private void AddSingleLineXmlComment(Token commentToken);
    private void AddSingleLineComment(Token commentToken);
    private void AddCommentNode(Token commentToken);
    protected void SetMethodProperties(Method method, SourceRange nameRange, SourceRange parenOpenRange, SourceRange parenCloseRange, LanguageElementCollection parameters);
    protected Param CreateParam(Token paramToken);
    protected bool IsLabelledStatement();
    protected TypeReferenceExpression CreateTypeReference(Token idToken);
    protected TypeReferenceExpression CreateTypeReference(TypeReferenceExpression qualifier, Token idToken);
    protected Variable CreateVariable(string name, SourceRange nameRange, Expression initializer, SourceRange varRange, SourceRange startRange, SourceRange endRange, SourceRange operatorRange);
    protected bool IsForEachLoop();
    protected ElementReferenceExpression CreateElementReference(Token idToken);
    protected ElementReferenceExpression CreateElementReference(Expression source, Token idToken);
    protected AssignmentExpression CreateAssignmentExpression(Expression leftPart, Expression rightPart, Token operatorToken);
    protected Expression CreateConditionalExpression(Expression condition, Expression trueExpression, Expression falseExpression);
    protected Expression CreateLogicalOperation(Expression leftSide, Expression rightSide, Token operatorToken);
    protected Expression CreateRelationalOperation(Expression leftSide, Expression rightSide, Token operatorToken);
    protected Expression CreateBinaryOperatorExpression(Expression leftSide, Expression rightSide, Token operatorToken);
    protected Expression CreateTypeCheckExpression(Expression leftSide, Expression rightSide, Token operatorToken);
    protected Expression CreateUnaryPostfixIncrement(Expression sourceExpression, Token operatorToken);
    protected Expression CreateUnaryPrefixIncrement(Expression sourceExpression, Token operatorToken);
    protected Expression CreateUnaryPostfixDecrement(Expression sourceExpression, Token operatorToken);
    protected Expression CreateUnaryPrefixDecrement(Expression sourceExpression, Token operatorToken);
    protected Expression CreateUnaryExpression(Expression sourceExpression, Token operatorToken);
    protected Expression CreateDeleteExpression(Expression sourceExpression, Token operatorToken);
    protected Expression CreateLogicalInversion(Expression sourceExpression, Token operatorToken);
    protected Expression CreateTypeOfExpression(Expression sourceExpression, Token operatorToken);
    protected Expression CreateThisExpression(Token thisToken);
    protected Expression CreateParenthesizedExpression(Expression sourceExpression, SourceRange startRange, SourceRange endRange);
    protected Expression CreateObjectInitializer(ExpressionCollection initializers, SourceRange startRange, SourceRange endRange);
    protected Expression CreateMemberInitializer(Token nameToken, Expression initializerValue);
    protected Expression CreateArrayInitializerExpression(SourceRange startRange, SourceRange endRange, ExpressionCollection initializers);
    protected ObjectCreationExpression CreateObjectCreationExpression(TypeReferenceExpression objectType, ExpressionCollection arguments, SourceRange lparRange, SourceRange rparRange, SourceRange startRange, SourceRange endRange);
    protected AnonymousMethodExpression CreateAnonymousMethod(SourceRange startRange, SourceRange lparRange, SourceRange rparRange, LanguageElementCollection parameters, Token nameToken);
    protected AnonymousConstructorExpression CreateAnonymousConstructor(SourceRange startRange, SourceRange lparRange, SourceRange rparRange, LanguageElementCollection parameters, Token nameToken);
    protected Expression CreateIndexerExpression(Expression source, Expression argument, SourceRange endRange);
    protected MethodCallExpression CreateMethodCallExpression(Expression source, ExpressionCollection arguments, SourceRange lparRange, SourceRange rparRange);
    protected virtual void Get();
    protected virtual void CleanUpParser();
    protected Token Peek();
    protected void PrepareForParsing(ISourceReader reader);
    protected void DisposeReader(ISourceReader& reader);
    protected bool get_InsideForEachLoop();
    protected void set_InsideForEachLoop(bool value);
    public LanguageElement Parse(ISourceReader reader);
    protected virtual LanguageElement DoParse(ParserContext parserContext, ISourceReader reader);
    public TypeReferenceExpression ParseTypeReferenceExpression(ISourceReader reader);
    public Expression ParseExpression(ISourceReader reader);
    public virtual IExpressionInverter CreateExpressionInverter();
    public virtual string get_Language();
    public virtual CommentCollection get_Comments();
    protected virtual TokenCategory GetTokenCategory(CategorizedToken token);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptParserErrors : ParserErrorsBase {
    protected virtual string GetSyntaxErrorText(int n);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptPrimitiveTypeUtils : object {
    private static string STR_0X;
    private static string STR_0x;
    private static bool IsHexLiteral(string value);
    private static bool IsOctLiteral(string value);
    private static bool ConvertToInt(string value, Int32& result);
    private static bool ConvertToDecimal(string value, Decimal& result);
    private static PrimitiveType GetIntegerTypeFromValue(string value);
    private static bool GetIntegerLiteralValue(string value, Int32& intValue);
    private static bool GetFloatingPointLiteralValue(string value, Decimal& realValue);
    private static int HexToInt(string s);
    private static int OctToInt(string s);
    private static string GetStringLiteralValue(string s);
    private static string RemoveQuotes(string s);
    private static string RemoveCharQuotes(string s);
    public static PrimitiveType ToPrimitiveType(int tokenType, string value);
    public static object ToPrimitiveValue(int tokenType, string value);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptScanner : GeneratedScannerBase {
    private static int charSetSize;
    private static int UnicodeLetterIndex;
    private static int noSym;
    private Int16[] start;
    public bool ShouldReadRegExpToken;
    public JavaScriptScanner(ISourceReader s);
    protected virtual void InitializeIgnoreTable();
    protected virtual void NextChCasing();
    protected virtual void AddCh();
    private void CheckLiteral();
    protected virtual void NextTokenComments();
    protected virtual void NextTokenScan(int state);
    private void ReadEscapedChar();
    private void SeparateDivEquals(Token& token);
    private Token ScanString(string text, int startLine, int startColumn);
    private void SeparateDiv(Token& token);
    private void RescanToken(Token& token);
    private void SetErrorToken();
    protected virtual int GetUnicodeLetterIndex();
    protected virtual int GetNextState(int input);
    protected void ReadRegExpToken();
    protected virtual void NextTokenEnd();
    protected virtual Token CreateToken();
}
public class DevExpress.CodeParser.JavaScript.JavaScriptStatementCodeGen : TokenCStatementCodeGenBase {
    public JavaScriptStatementCodeGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    protected virtual void GenerateCheckedStatement(Checked statement);
    protected virtual void GenerateConstructorInitializer(ConstructorInitializer initializer);
    protected virtual void GenerateEventAddStatement(EventAdd statement);
    protected virtual void GenerateEventRaiseStatement(EventRaise statement);
    protected virtual void GenerateEventRemoveStatement(EventRemove statement);
    protected virtual void GenerateFixedStatement(Fixed statement);
    protected virtual void GenerateLockStatement(Lock statement);
    protected virtual void GeneratePropertyAccessorGetStatement(Get statement);
    protected virtual void GeneratePropertyAccessorSetStatement(Set statement);
    protected virtual void GenerateRaiseEventStatement(RaiseEvent statement);
    protected virtual void GenerateUncheckedStatement(Unchecked statement);
    protected virtual void GenerateYieldBreakStatement(YieldBreak statement);
    protected virtual void GenerateYieldReturnStatement(YieldReturn statement);
    protected virtual void GenerateBreakStatement(Break statement);
    protected virtual void GenerateContinueStatement(Continue statement);
    protected virtual void GenerateEmptyStatement(EmptyStatement statement);
    protected virtual void GenerateForEachStatement(ForEach statement);
    protected virtual void GenerateThrowStatement(Throw statement);
    protected virtual void GenerateWithStatement(With statement);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptSupportElementCodeGen : TokenSupportElementCodeGenBase {
    public JavaScriptSupportElementCodeGen(CodeGen codeGen);
    protected virtual void GenerateCppAttribute(CppAttributeSection element);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptTokens : LanguageTokensBase {
    protected virtual StringCollection CreateKeywords();
    public virtual bool IsComment(int type);
    public virtual bool IsDirective(int type);
    public virtual bool IsIdentifier(string word);
    public virtual bool IsKeyword(string word);
    public virtual bool IsNumber(int type);
    public virtual bool IsStandardType(string word);
    public virtual bool IsStringLiteral(int type);
    public virtual bool IsXmlDocComment(int type);
    public virtual int ToTokenType(string token);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptTokensCategoryHelper : object {
    public sealed virtual TokenCategory GetUncategorizedTokenCategory(Token token);
    public sealed virtual TokenCollection GetTokens(string code);
    public sealed virtual string GetTokenCategory(Token token);
    public sealed virtual string GetTokenCategory(Token token, ParserVersion version);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptTokensHelper : object {
    public static Token GetFirstToken(string number);
    public static bool IsIdentifier(int type);
    public static bool IsString(int type);
    public static bool IsComment(int type);
    public static bool IsKeyword(string keyword);
    public static bool IsKeyword(int type);
    public static bool IsNumber(string number);
    public static bool IsNumber(int type);
    public static bool IsOperator(int type);
    public static string GetTokenCategory(Token token);
    public static TokenCollection GetTokens(string text);
    public static TokenCategory GetUncategorizedTokenCategory(Token token);
}
public class DevExpress.CodeParser.JavaScript.JavaScriptXmlCodeGen : XmlCodeGenBase {
    public JavaScriptXmlCodeGen(CodeGen codeGen);
    public virtual void GenerateCode(CodeWriter writer, LanguageElement languageElement, bool calculateIndent);
    protected virtual void GenerateXmlPrefix();
}
public class DevExpress.CodeParser.JavaScript.Tokens : object {
    public static int FINALLY;
    public static int SHIFTRIGHT;
    public static int FALSE;
    public static int XORSYMBOL;
    public static int ANDEQUAL;
    public static int XOREQUAL;
    public static int BITAND;
    public static int STRINGLITERAL;
    public static int BREAK;
    public static int MINUSMINUS;
    public static int LPAR;
    public static int DO;
    public static int XMLCOMMENT;
    public static int LESSTHAN;
    public static int DOUBLEEQUALS;
    public static int PLUS;
    public static int SHIFTLEFT;
    public static int SEMICOLON;
    public static int OROR;
    public static int SINGLELINECOMMENT;
    public static int WITH;
    public static int IDENTIFIER;
    public static int SLASH;
    public static int NEW;
    public static int ASTERISK;
    public static int TRIPLESHIFTRIGHT;
    public static int COLON;
    public static int OREQUAL;
    public static int TRIPLEEQUALS;
    public static int IFKEYWORD;
    public static int EOF;
    public static int RBRACE;
    public static int GREATERTHAN;
    public static int QUESTIONSYMBOL;
    public static int CODEEMBEDDING;
    public static int SWITCH;
    public static int MODEQUAL;
    public static int INSTANCEOF;
    public static int DECIMALLITERAL;
    public static int BITOR;
    public static int PERCENTSYMBOL;
    public static int LBRACK;
    public static int WHILE;
    public static int CONTINUE;
    public static int FOR;
    public static int ELSE;
    public static int RETURN;
    public static int TRY;
    public static int CATCH;
    public static int TILDE;
    public static int DIVEQUAL;
    public static int LBRACE;
    public static int DEFAULT;
    public static int DOT;
    public static int EXCLAMATIONSYMBOL;
    public static int FUNCTION;
    public static int REGEXPLITERAL;
    public static int RBRACK;
    public static int NOTDOUBLEEQUALS;
    public static int THIS;
    public static int RPAR;
    public static int MULEQUAL;
    public static int EQUALSSYMBOL;
    public static int INTEGERLITERAL;
    public static int NOTEQUALS;
    public static int NULL;
    public static int CASE;
    public static int PLUSPLUS;
    public static int MULTILINECOMMENT;
    public static int ANDAND;
    public static int MINUS;
    public static int VAR;
    public static int VOID;
    public static int DELETE;
    public static int COMMA;
    public static int SHIFTRIGHTEQUAL;
    public static int TYPEOF;
    public static int LESSOREQUAL;
    public static int MINUSEQUAL;
    public static int TRIPLESHIFTRIGHTEQUAL;
    public static int THROW;
    public static int SHIFTLEFTEQUAL;
    public static int PLUSEQUAL;
    public static int GREATEROREQUAL;
    public static int TRUE;
    public static int IN;
    public static int MaxTokens;
    public static Int32[] Keywords;
    private static Tokens();
}
public class DevExpress.CodeParser.JoinExpression : JoinExpressionBase {
    public LanguageElementType ElementType { get; }
    private IInExpression DevExpress.CodeParser.IJoinExpression.InExpression { get; }
    private IExpressionCollection DevExpress.CodeParser.IJoinExpression.EqualsExpressions { get; }
    private IExpressionCollection DevExpress.CodeParser.IJoinExpression.JoinExpressions { get; }
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IInExpression DevExpress.CodeParser.IJoinExpression.get_InExpression();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IJoinExpression.get_EqualsExpressions();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IJoinExpression.get_JoinExpressions();
}
public abstract class DevExpress.CodeParser.JoinExpressionBase : QueryExpressionBase {
    private InExpression _InExpression;
    private ExpressionCollection _EqualsExpressions;
    private ExpressionCollection _JoinExpressions;
    public ExpressionCollection EqualsExpressions { get; }
    public ExpressionCollection JoinExpressions { get; }
    public InExpression InExpression { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public void SetInExpression(InExpression expression);
    public void AddEqualsExpressions(IEnumerable`1<Expression> equalsExpressions);
    public void AddEqualsExpression(EqualsExpression exp);
    public void AddJoinExpressions(IEnumerable`1<Expression> joinExpressions);
    public void AddJoinExpression(JoinExpressionBase exp);
    public ExpressionCollection get_EqualsExpressions();
    public ExpressionCollection get_JoinExpressions();
    public InExpression get_InExpression();
}
public class DevExpress.CodeParser.JoinIntoExpression : JoinExpression {
    private LanguageElementCollection _IntoElements;
    public LanguageElementCollection IntoElements { get; }
    private IElementCollection DevExpress.CodeParser.IJoinIntoExpression.IntoElements { get; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddIntoElements(IEnumerable`1<LanguageElement> elements);
    public sealed virtual void AddIntoElement(LanguageElement element);
    public virtual string ToString();
    public sealed virtual LanguageElementCollection get_IntoElements();
    private sealed virtual override IElementCollection DevExpress.CodeParser.IJoinIntoExpression.get_IntoElements();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.Label : Statement {
    public LanguageElementType ElementType { get; }
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.LambdaExpression : AnonymousMethodExpression {
    private SourceRange _OperatorRange;
    [CompilerGeneratedAttribute]
private bool <IsFunction>k__BackingField;
    public bool IsFunction { get; public set; }
    public LanguageElementType ElementType { get; }
    public SourceRange OperatorRange { get; public set; }
    public bool ParameterListOmitted { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddStatement(Statement statement);
    [CompilerGeneratedAttribute]
public virtual bool get_IsFunction();
    [CompilerGeneratedAttribute]
public virtual void set_IsFunction(bool value);
    public virtual LanguageElementType get_ElementType();
    public SourceRange get_OperatorRange();
    public void set_OperatorRange(SourceRange value);
    public virtual bool get_ParameterListOmitted();
    public virtual void set_ParameterListOmitted(bool value);
}
public class DevExpress.CodeParser.LambdaFunctionExpression : LambdaExpression {
    private TypeReferenceExpression _Type;
    public LanguageElementType ElementType { get; }
    public TypeReferenceExpression Type { get; public set; }
    public bool IsFunction { get; public set; }
    private ITypeReferenceExpression DevExpress.CodeParser.IHasType.Type { get; }
    public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public void SetType(TypeReferenceExpression type);
    public virtual LanguageElementType get_ElementType();
    public TypeReferenceExpression get_Type();
    public void set_Type(TypeReferenceExpression value);
    public virtual bool get_IsFunction();
    public virtual void set_IsFunction(bool value);
    private sealed virtual override bool DevExpress.CodeParser.IHasType.Is(string fullTypeName);
    private sealed virtual override bool DevExpress.CodeParser.IHasType.Is(ITypeElement type);
    private sealed virtual override bool DevExpress.CodeParser.IHasType.Is(Type type);
    private sealed virtual override bool DevExpress.CodeParser.IHasType.Is(ISourceTreeResolver resolver, string fullTypeName);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.IHasType.get_Type();
}
public class DevExpress.CodeParser.LambdaImplicitlyTypedParam : Param {
    public LanguageElementType ElementType { get; }
    public LambdaImplicitlyTypedParam(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.LanguageElement : DocumentElement {
    private bool _IsFakeNode;
    private bool _HasErrors;
    private LanguageElementTokens _Tokens;
    private bool _IsRemoved;
    private static int INT_LoopPreventCount;
    private short _SiblingCounter;
    private LanguageElement _Parent;
    private int _Index;
    private bool _IsDetailNode;
    protected int ThisMaintenanceComplexity { get; }
    [EditorBrowsableAttribute("1")]
protected PostponedParsingData PostponedData { get; protected set; }
    [EditorBrowsableAttribute("1")]
protected internal NodeList OwningList { get; }
    [EditorBrowsableAttribute("1")]
protected CommentCollection PostponedComments { get; protected set; }
    public string MacroCall { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool ParsingPostponedTokens { get; public set; }
    [DescriptionAttribute("The source range of this language element.")]
[CategoryAttribute("Position")]
public SourceRange Range { get; }
    [DescriptionAttribute("Whether this language element can contain code statements.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("False")]
public bool CanContainCode { get; }
    [DescriptionAttribute("Whether XML documentation comments can be bound to this language element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("False")]
public bool CanBeDocumented { get; }
    [DescriptionAttribute("True if this language element connects to the previous statement or preprocessor directive (e.g., catch, finally, #if, #elif, #warning, etc.).")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("False")]
public bool CompletesPrevious { get; }
    [DescriptionAttribute("Gets whether this node declares an identifier or not. If true, the Name property will hold the name of the identifier.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("False")]
public bool DeclaresIdentifier { get; }
    [DescriptionAttribute("The type of this language element.")]
[CategoryAttribute("Description")]
public LanguageElementType ElementType { get; }
    [DescriptionAttribute("Whether this language element is inside a Method.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideMethod { get; }
    [DescriptionAttribute("Returns true if this language element is inside an Event.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideEvent { get; }
    [DescriptionAttribute("Returns true if this language element is inside an Event accessor.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideEventAccessor { get; }
    [DescriptionAttribute("Returns true if this language element is inside left side of an assignment.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideAssignment { get; }
    [DescriptionAttribute("Returns true if this language element is used inside out argument direction expression.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideOutArgumentDirection { get; }
    [DescriptionAttribute("Returns true if this language element is used inside ref argument direction expression.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideRefArgumentDirection { get; }
    [DescriptionAttribute("Returns true if this language element is used inside increment expression.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideIncrement { get; }
    [DescriptionAttribute("Returns true if this language element is used inside decrement expression.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideDecrement { get; }
    [DescriptionAttribute("Whether this language element is inside a Property.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideProperty { get; }
    [DescriptionAttribute("Whether this language element is inside a Class.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideClass { get; }
    [DescriptionAttribute("Whether this language element is inside a Struct.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideStruct { get; }
    [DescriptionAttribute("Whether this language element is inside an Interface declaration.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideInterface { get; }
    [DescriptionAttribute("Whether this language element is inside a Namespace.")]
[CategoryAttribute("Location")]
[DefaultValueAttribute("False")]
public bool InsideNamespace { get; }
    [DescriptionAttribute("Whether this language element is a detail node.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("False")]
public bool IsDetailNode { get; public set; }
    [DescriptionAttribute("Returns true if this language element was parsed from a source file.")]
public bool HasDocument { get; }
    [DescriptionAttribute("Gets the number of parent nodes between this node and the topmost node, inclusive of the topmost node.")]
[CategoryAttribute("Location")]
public int LevelsDeep { get; }
    [DescriptionAttribute("The parent of this language element.")]
[CategoryAttribute("Family")]
public LanguageElement Parent { get; }
    [DescriptionAttribute("The parent of this language element.")]
[CategoryAttribute("Family")]
public SourceFile FileNode { get; }
    [DescriptionAttribute("The region that parents this node.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public RegionDirective ParentRegion { get; }
    [DescriptionAttribute("Returns true if this language element is loop statement.")]
[CategoryAttribute("Family")]
public bool IsLoop { get; }
    [DescriptionAttribute("The parenting loop, switch statement, or other code block that can be broken by a "break;" statement.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public ParentingStatement ParentLoop { get; }
    [DescriptionAttribute("The parenting try block that contains this language element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public Try ParentTryBlock { get; }
    [DescriptionAttribute("Gets parent with statement for this element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement ParentWith { get; }
    [DescriptionAttribute("Gets the full path for this element's parent.")]
[CategoryAttribute("Location")]
public string ParentPath { get; }
    [DescriptionAttribute("Gets path segment for this element.")]
[CategoryAttribute("Location")]
public string PathSegment { get; }
    public ISolutionElement Solution { get; }
    public IProjectElement Project { get; }
    [DescriptionAttribute("The location of this node as a string.")]
[CategoryAttribute("Location")]
public string Location { get; }
    [DescriptionAttribute("Gets the location of this node as a string starting with root namespace.")]
[CategoryAttribute("Location")]
[EditorBrowsableAttribute("1")]
public string RootNamespaceLocation { get; }
    [DescriptionAttribute("The previous node in the code following the start of this node.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement PreviousNode { get; }
    [DescriptionAttribute("The next node in the code following the start of this node.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement NextNode { get; }
    [DescriptionAttribute("The next sibling to this element, or null if no siblings follow this element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement NextSibling { get; }
    [DescriptionAttribute("The previous sibling to this element, or null if no siblings precede this element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement PreviousSibling { get; }
    [DescriptionAttribute("The next non-comment sibling to this element, or null if no siblings containing code follow this element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement NextCodeSibling { get; }
    [DescriptionAttribute("The previous non-comment sibling to this element, or null if no siblings containing code precede this element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement PreviousCodeSibling { get; }
    [DescriptionAttribute("The first detail node of this element, or null if no detail nodes exist.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement FirstDetail { get; }
    [DescriptionAttribute("The first child to this element, or null if no children exist.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement FirstChild { get; }
    [DescriptionAttribute("The first sibling of this language element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement FirstSibling { get; }
    [DescriptionAttribute("The language elements parented by this element.")]
[CategoryAttribute("Family")]
public NodeList Nodes { get; }
    [DescriptionAttribute("The detail language elements associated with this element.")]
[CategoryAttribute("Family")]
public NodeList DetailNodes { get; }
    [EditorBrowsableAttribute("1")]
public bool UsePostponedParsing { get; }
    [EditorBrowsableAttribute("1")]
public bool HasUnparsedCode { get; }
    [EditorBrowsableAttribute("1")]
public ISourceReader UnparsedCode { get; }
    [EditorBrowsableAttribute("1")]
public bool HasPostponedComments { get; }
    [DescriptionAttribute("The index into the OwningList.")]
[CategoryAttribute("Family")]
[EditorBrowsableAttribute("1")]
[DefaultValueAttribute("-1")]
public int Index { get; }
    [DescriptionAttribute("The last sibling of this language element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement LastSibling { get; }
    [EditorBrowsableAttribute("1")]
public bool IsFakeNode { get; }
    [DescriptionAttribute("The last child to this element, or null if no children exist.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement LastChild { get; }
    [DescriptionAttribute("The last detail to this element, or null if no details exist.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public LanguageElement LastDetail { get; }
    [DescriptionAttribute("Gets the IDocument associated with the parenting SourceFile language element. May return null if this node was parsed from a file on disk.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public IDocument Document { get; }
    [DescriptionAttribute("Returns a view associated with the document that was the source for this language element.")]
[CategoryAttribute("Family")]
[DefaultValueAttribute("")]
public IDXCoreTextView View { get; }
    public bool IsCollapsible { get; }
    public SourceRange CollapsibleRange { get; }
    protected bool HasOuterRangeChildren { get; }
    [EditorBrowsableAttribute("1")]
public bool IsTypeDeclaration { get; }
    [EditorBrowsableAttribute("1")]
public LanguageElementTokens Tokens { get; public set; }
    public bool Collapsed { get; public set; }
    public bool Expanded { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool HasErrors { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsRemoved { get; public set; }
    private string DevExpress.CodeParser.IElement.Name { get; }
    private string DevExpress.CodeParser.IElement.FullName { get; }
    private IElement DevExpress.CodeParser.IElement.Parent { get; }
    private ITypeElement DevExpress.CodeParser.IElement.ParentType { get; }
    private IEventElement DevExpress.CodeParser.IElement.ParentEvent { get; }
    private IMemberElement DevExpress.CodeParser.IElement.ParentMember { get; }
    private IMethodElement DevExpress.CodeParser.IElement.ParentMethod { get; }
    private IElement DevExpress.CodeParser.IElement.ParentMethodOrAccessor { get; }
    private IElement DevExpress.CodeParser.IElement.ParentMethodOrPropertyOrEvent { get; }
    private IPropertyElement DevExpress.CodeParser.IElement.ParentProperty { get; }
    private INamespaceElement DevExpress.CodeParser.IElement.ParentNamespace { get; }
    private IProjectElement DevExpress.CodeParser.IElement.Project { get; }
    private ISolutionElement DevExpress.CodeParser.IElement.Solution { get; }
    private IAssemblyModel DevExpress.CodeParser.IElement.AssemblyModel { get; }
    private IElementCollection DevExpress.CodeParser.IElement.Children { get; }
    private IEnumerable`1<IElement> DevExpress.CodeParser.IElement.AllChildren { get; }
    private IElementCollection DevExpress.CodeParser.IElement.CodeChildren { get; }
    private ISourceFileCollection DevExpress.CodeParser.IElement.Files { get; }
    private ISourceFile DevExpress.CodeParser.IElement.FirstFile { get; }
    private ITextRangeCollection DevExpress.CodeParser.IElement.Ranges { get; }
    private TextRange DevExpress.CodeParser.IElement.FirstRange { get; }
    private ITextRangeCollection DevExpress.CodeParser.IElement.NameRanges { get; }
    private TextRange DevExpress.CodeParser.IElement.FirstNameRange { get; }
    private IElement DevExpress.CodeParser.IElement.NextSibling { get; }
    private IElement DevExpress.CodeParser.IElement.PreviousSibling { get; }
    private string DevExpress.CodeParser.IElement.RootNamespaceFullName { get; }
    private bool DevExpress.CodeParser.IElement.InReferencedAssembly { get; }
    private bool DevExpress.CodeParser.IElement.IsMember { get; }
    private bool DevExpress.CodeParser.IElement.IsNestedType { get; }
    private int DevExpress.CodeParser.IElement.ImageIndex { get; }
    private void SetSelection(int startLine, int startOffset, int endLine, int endOffset, bool ensureVisible);
    private void SetSelection(IDXCoreTextView textView, int startLine, int startOffset, int endLine, int endOffset, bool ensureVisible);
    private void AdjustStartToElement(LanguageElement element, Int32& startLine, Int32& startOffset);
    private void ParseAllPostponedElementsInNodes(NodeList nodes);
    private bool CheckNodeListIndexes(NodeList nodeList);
    private void CheckIndexes(LanguageElement element);
    private void ValidateIndices();
    private bool FindInList(NodeList list, LanguageElement element);
    private bool FindInScope(LanguageElement scope, LanguageElement element);
    private bool IsTrailingComment(LanguageElement target, LanguageElement element);
    private void SetNodeLinks(NodeList nodes);
    private LanguageElement GetOuterRangeChild(int line, int column, NodeList nodes);
    private LanguageElement GetChildAtInternal(int line, int column, NodeList lChildList);
    private int GetNodeIndexBeforeInternal(NodeList list, int line, int offset);
    private int GetNodeIndexAfterInternal(NodeList list, int line, int offset);
    private static bool IsInsideNodeList(NodeList list, SourcePoint point);
    private bool CanInjectInside(SourceRange targetRange, SourceRange elementRange);
    private bool CanInjectBetween(SourceRange prev, SourceRange next, SourceRange elementRange);
    private void InjectElement(LanguageElement element);
    private ICollection CollectRegions(LanguageElement regionRootNode);
    private void InjectRegions(LanguageElement regionRootNode);
    private bool NodeIsAlreadyAdded(LanguageElement parent, NodeList nodeList, LanguageElement node);
    [EditorBrowsableAttribute("1")]
protected void CleanUpPostponedData();
    protected ICollapsibleRegion GetCollapsibleRegion();
    protected ICollapsibleRegion GetCollapsibleRegion(IDXCoreTextView textView);
    protected bool InsertNodeToNodeListWithoutReIndex(NodeList list, int index, LanguageElement node);
    protected void IncreaseNodesIndices(NodeList list, int startFrom);
    protected void DecreaseNodesIndices(NodeList list, int startFrom);
    protected internal virtual bool GetCanBeDocumented();
    protected virtual LanguageElement GetPreviousChildIdentifier(LanguageElement startingChildNode, LanguageElement aReferenceNode);
    protected virtual LanguageElement GetLastSiblingInScope(LanguageElement referenceNode);
    protected virtual bool AllChildrenAccessibleByGrandchildren();
    protected virtual LanguageElement GetLastIdentifierInList(NodeList list);
    protected virtual LanguageElement GetLastDetailIdentifier();
    protected virtual LanguageElement GetLastIdentifier();
    protected virtual void AddNodeToNodeList(NodeList aList, LanguageElement aLanguageElement);
    protected virtual void AddNodesToNodeList(NodeList aList, LanguageElementCollectionBase nodes);
    protected virtual void RemoveNodeFromNodeList(NodeList list, LanguageElement element);
    protected virtual void InsertNodeToNodeList(NodeList list, int index, LanguageElement node);
    protected virtual void InsertNodesToNodeList(NodeList list, int index, LanguageElementCollectionBase nodes);
    protected virtual LanguageElement FindDeclarationInList(NodeList list, string firstIdentifier, string remainingIdentifiers, LanguageElement viewer);
    [EditorBrowsableAttribute("1")]
protected virtual LanguageElement FindChildDeclaration(string firstIdentifier, string remainingIdentifiers, LanguageElement viewer);
    [EditorBrowsableAttribute("1")]
protected virtual LanguageElement FindDetailDeclaration(string firstIdentifier, string remainingIdentifiers, LanguageElement viewer);
    [EditorBrowsableAttribute("1")]
protected int GetNodeIndexAfter(NodeList list, int line, int offset);
    [EditorBrowsableAttribute("1")]
protected int GetNodeIndexBefore(NodeList list, int line, int offset);
    [EditorBrowsableAttribute("1")]
protected LanguageElement GetNodeAfter(NodeList list, int line, int offset);
    [EditorBrowsableAttribute("1")]
protected LanguageElement GetNodeBefore(NodeList list, int line, int offset);
    [EditorBrowsableAttribute("1")]
protected virtual string GetSignaturePart();
    [EditorBrowsableAttribute("1")]
protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    [EditorBrowsableAttribute("1")]
protected virtual int NumberOfTrueStatements(ParserBase parser, ParentToSingleStatement Stmt);
    protected virtual void CloneRegions(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
protected virtual void FillFormattingCollection(FormattingParsingElementCollection data);
    [EditorBrowsableAttribute("1")]
public FormattingElements GetFormattingElements(FormattingTokenType type);
    [EditorBrowsableAttribute("1")]
public FormattingElements GetFormattingElements(FormattingTokenType type, int index);
    [EditorBrowsableAttribute("1")]
public void FillFormattingCollectionWithChildren(FormattingParsingElementCollection data);
    public void AddHeader(string header);
    public void AddHeader(String[] header);
    public void AddHeaderFooter(string header, string footer);
    public void AddHeaderFooter(string header, string footer, bool selectText);
    public void AddHeaderFooter(String[] header, String[] footer);
    public void AddHeaderFooter(String[] header, String[] footer, bool selectText);
    public void AddFooter(string footer);
    public void AddFooter(String[] footer);
    public LanguageElement ClosestParent(LanguageElement element1, LanguageElement element2);
    public virtual void CleanUpOwnedReferences();
    public bool ContainsSelection();
    public virtual int GetChildCyclomaticComplexity();
    public Class GetDeclaringType();
    public virtual LanguageElement GetParent(LanguageElementType aType);
    public LanguageElement GetParent(LanguageElementType type, LanguageElementType[] types);
    public LanguageElement GetParentClassInterfaceOrStruct();
    public LanguageElement GetParentClassInterfaceStructOrModule();
    public LanguageElement GetParentTypeDeclaration();
    public virtual LanguageElement GetParentingStatementParent();
    public Method GetMethod();
    public LanguageElement GetElementThatCanBeDocumented();
    public Property GetProperty();
    public PropertyAccessor GetPropertyAccessor();
    public EventAccessor GetEventAccessor();
    public Class GetClass();
    public ValueClass GetValueClass();
    public ManagedClass GetManagedClass();
    public ValueStruct GetValueStruct();
    public ManagedStruct GetManagedStruct();
    public InterfaceClass GetInterfaceClass();
    public InterfaceStruct GetInterfaceStruct();
    public Interface GetInterface();
    public Struct GetStruct();
    public Namespace GetNamespace();
    public Event GetEvent();
    public AnonymousMethodExpression GetAnonymousExpression();
    public SourceFile GetSourceFile();
    [EditorBrowsableAttribute("1")]
public void GetSourceFileSupportLists(RegionDirective& regionDirectives, TextStringCollection& strings, CompilerDirective& compilerDirectives);
    [EditorBrowsableAttribute("1")]
public void GetSourceFileSupportLists(RegionDirective& regionDirectives, TextStringCollection& strings, CompilerDirective& compilerDirectives, SourceFile& sourceFile);
    public virtual string GetTypeName();
    public virtual VisualStudioDocument GetParentDocument();
    public LanguageElement GetLastCodeChild();
    public LanguageElement GetPreviousIdentifier(LanguageElement referenceNode);
    public LanguageElement GetPreviousIdentifier(LanguageElement referenceNode, int refLine, int refColumn);
    public SourceRange GetFullBlockRange();
    public SourceRange GetFullBlockRange(BlockElements blockElements);
    public void GetFullBlockCoordinates(Int32& startLine, Int32& startOffset, Int32& endLine, Int32& endOffset);
    public void GetFullBlockCoordinates(Int32& startLine, Int32& startOffset, Int32& endLine, Int32& endOffset, BlockElements blockElements);
    public void GetFullBlockNodes(LanguageElement& startNode, LanguageElement& endNode);
    public void GetFullBlockNodes(BlockElements blockElements, LanguageElement& startNode, LanguageElement& endNode);
    public void MoveTo(SourcePoint target, string operation);
    public void ReplaceWith(string newCode, string operation);
    public void ReplaceWith(string newCode, string operation, bool format);
    public void FullBlockMoveTo(SourcePoint target, string operation);
    public void FullBlockMoveTo(SourcePoint target, string operation, BlockElements blockElements);
    public void FullBlockMoveWithBinding(SourcePoint target, string operation);
    public void FullBlockMoveWithBinding(SourcePoint target, string operation, BlockElements blockElements);
    public void FullBlockReplaceWith(string newCode, string operation);
    public void FullBlockReplaceWith(string newCode, string operation, BlockElements blockElements);
    public SourceRange GetCutRange();
    public SourceRange GetFullBlockCutRange();
    public SourceRange GetFullBlockCutRange(BlockElements blockElements);
    public void SelectCode(bool ensureVisible);
    public void SelectCode();
    public void SelectFullBlock(IDXCoreTextView textView, bool ensureVisible);
    public void SelectFullBlock(IDXCoreTextView textView);
    public void SelectFullBlock(bool ensureVisible);
    public void SelectFullBlock();
    public Method GetParentMethod();
    public LanguageElement GetParentElementThatCanBeDocumented();
    public Property GetParentProperty();
    public PropertyAccessor GetParentPropertyAccessor();
    public EventAccessor GetParentEventAccessor();
    public Class GetParentClass();
    public ManagedClass GetParentManagedClass();
    public ManagedStruct GetParentManagedStruct();
    public InterfaceClass GetParentInterfaceClass();
    public InterfaceStruct GetParentInterfaceStruct();
    public ValueClass GetParentValueClass();
    public ValueStruct GetParentValueStruct();
    public Interface GetParentInterface();
    public Struct GetParentStruct();
    public Namespace GetParentNamespace();
    public Event GetParentEvent();
    public AnonymousMethodExpression GetParentAnonymousExpression();
    [EditorBrowsableAttribute("1")]
public LanguageElement GetCodeNodeFromList(NodeList list);
    public LanguageElement GetFirstCodeChild();
    public LanguageElement GetFirstCodeChild(bool useDetailNodes);
    public CodeElement GetNextCodeElementSibling();
    public CodeElement GetPreviousCodeElementSibling();
    public LanguageElement GetParentLoopOrFinallyTarget();
    public LanguageElement GetParentMethodOrProperty();
    public LanguageElement GetParentMethodOrPropertyOrEvent();
    public LanguageElement GetParentMethodOrPropertyAccessor();
    public LanguageElement GetParentMethodOrAccessor();
    public LanguageElement GetParentMethodOrAccessor(bool checkAnonymousMethod);
    public LanguageElement GetAnonymousMethodOrLambda();
    public LanguageElement GetParentMethodOrEventAccessor();
    public LanguageElement GetParentCodeBlock();
    public LanguageElement GetParentStatementOrVariable();
    public string GetStartString();
    [EditorBrowsableAttribute("1")]
public IElement GetFromLiteModel();
    public bool InsideSelection();
    public bool IsSibling(LanguageElement aLanguageElement);
    public bool IsDeeperThan(LanguageElement aLanguageElement);
    public bool SameEndPoint(LanguageElement aLanguageElement);
    public bool SameStartPoint(LanguageElement aLanguageElement);
    [EditorBrowsableAttribute("2")]
public virtual void AddNode(LanguageElement element);
    [EditorBrowsableAttribute("2")]
public virtual void AddNodes(LanguageElementCollectionBase nodes);
    [EditorBrowsableAttribute("2")]
public virtual void InsertNode(int index, LanguageElement element);
    [EditorBrowsableAttribute("2")]
public virtual void InsertNodes(int index, LanguageElementCollectionBase nodes);
    [EditorBrowsableAttribute("2")]
public virtual void RemoveNode(LanguageElement element);
    [EditorBrowsableAttribute("2")]
internal void RemoveNodesBetweenIndexes(int startIndex, int endIndex);
    public void RemoveFromParent();
    public virtual void RemoveNodesFromIndex(int index);
    [EditorBrowsableAttribute("2")]
public virtual void RemoveNodes(LanguageElementCollectionBase nodes);
    [EditorBrowsableAttribute("1")]
public virtual void RemoveNodes(NodeList nodes);
    [EditorBrowsableAttribute("2")]
public virtual void RemoveAllNodes();
    [EditorBrowsableAttribute("2")]
public virtual void ReplaceNode(LanguageElement oldElement, LanguageElement newElement);
    [EditorBrowsableAttribute("2")]
public void ReplaceNodes(LanguageElementCollectionBase oldNodes, LanguageElementCollectionBase newNodes);
    [EditorBrowsableAttribute("2")]
public virtual void AddDetailNode(LanguageElement element);
    [EditorBrowsableAttribute("2")]
public virtual void AddDetailNodes(LanguageElementCollectionBase nodes);
    [EditorBrowsableAttribute("2")]
public virtual void InsertDetailNode(int index, LanguageElement element);
    [EditorBrowsableAttribute("2")]
public virtual void InsertDetailNodes(int index, LanguageElementCollectionBase nodes);
    [EditorBrowsableAttribute("2")]
public virtual void RemoveDetailNode(LanguageElement element);
    [EditorBrowsableAttribute("2")]
public virtual void RemoveDetailNodes(LanguageElementCollectionBase nodes);
    [EditorBrowsableAttribute("2")]
public virtual void ReplaceDetailNode(LanguageElement oldElement, LanguageElement newElement);
    public virtual void ReplaceDetailNode(LanguageElement oldElement, LanguageElementCollectionBase newElements);
    public virtual void ReplaceNode(LanguageElement oldElement, LanguageElementCollectionBase newElements);
    [EditorBrowsableAttribute("2")]
public void ReplaceDetailNodes(LanguageElementCollectionBase oldNodes, LanguageElementCollectionBase newNodes);
    public static void RemoveChildElement(LanguageElement element);
    public static void ReplaceChildElement(LanguageElement oldElement, LanguageElement newElement);
    public static void MoveChildElementBefore(LanguageElement child, LanguageElement targetElement);
    [ObsoleteAttribute("Use CollapseInView")]
public void Collapse(bool undoable);
    [ObsoleteAttribute("Use CollapseInView")]
public void Collapse();
    [ObsoleteAttribute("Use ExpandInView")]
public void Expand(bool undoable);
    [ObsoleteAttribute("Use ExpandInView")]
public void Expand();
    public bool InSameProject(LanguageElement element);
    public virtual bool IsRelatedTo(LanguageElement element);
    public virtual bool IsVisibleFrom(LanguageElement viewer);
    public virtual bool IsIdentifier(string identifier, LanguageElement viewer);
    public virtual bool IdentifiersMatch(string first, string second);
    public string ExtractFirstIdentifier(String& remainingIdentifiers);
    [EditorBrowsableAttribute("1")]
public LanguageElement FindDeclaration(string firstIdentifier, string remainingIdentifiers, LanguageElement viewer);
    public LanguageElement FindDeclaration(string identifier, LanguageElement viewer);
    public virtual LanguageElement FindChildByName(string aName);
    public virtual LanguageElement FindChildByName(string aName, bool lookInDetail);
    public virtual LanguageElement FindChildByElementType(LanguageElementType type);
    public virtual LanguageElement FindChildByElementType(LanguageElementType type, bool lookInDetail);
    public LanguageElement GetChildAfter(SourcePoint sourcePoint);
    public LanguageElement GetChildAfter(int line, int offset);
    public LanguageElement GetSiblingBefore(int line, int offset);
    public LanguageElement GetSiblingAfter(int line, int offset);
    public virtual LanguageElement GetChildAt(SourcePoint sourcePoint);
    private LanguageElement GetNearestChildInMacro(int line, int column);
    public virtual LanguageElement GetChildAt(int line, int column);
    public LanguageElement GetChildBefore(SourcePoint sourcePoint);
    public LanguageElement GetChildBefore(int line, int offset);
    public virtual int GetCyclomaticComplexity();
    public virtual int GetMaintenanceComplexity();
    public bool Inside(LanguageElementType aElementType);
    public bool Inside(LanguageElementType[] types);
    public virtual int GetImageIndex();
    public virtual LanguageElement GetNodeAt(SourcePoint sourcePoint);
    public virtual LanguageElement GetNodeAt(int line, int column);
    [EditorBrowsableAttribute("1")]
public ParentingStatement GetNearestParentingStatement(SourcePoint point);
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual MemberVisibility[] GetValidVisibilities();
    public bool IsParentedBy(LanguageElement aParentElement);
    public bool MatchesSelection();
    public bool Parents(LanguageElement aChildElement);
    [EditorBrowsableAttribute("1")]
public virtual bool RangeIsClean(SourceRange sourceRange);
    public virtual string ToString();
    public virtual string GetFullPath();
    [EditorBrowsableAttribute("2")]
public bool PointInDetails(SourcePoint point);
    [EditorBrowsableAttribute("2")]
public bool PointInNodes(SourcePoint point);
    [EditorBrowsableAttribute("2")]
public bool HasInDetails(LanguageElement element);
    [EditorBrowsableAttribute("2")]
public bool HasInNodes(LanguageElement element);
    [EditorBrowsableAttribute("2")]
public bool IsDetailOfParentStatement();
    [EditorBrowsableAttribute("2")]
public ParentingStatement GetParentParentingStatement();
    [EditorBrowsableAttribute("1")]
public LanguageElement GetFirstLevelParentInCustomElement(LanguageElementType elementType);
    [EditorBrowsableAttribute("1")]
public LanguageElement GetFirstLevelParentInParentMethod();
    [EditorBrowsableAttribute("1")]
public LanguageElement GetFirstLevelParentInParentProperty();
    [EditorBrowsableAttribute("1")]
public LanguageElement GetFirstLevelParentInParentMethodOrProperty();
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public virtual void ParseOnDemandIfNeeded();
    [EditorBrowsableAttribute("1")]
public void ParseAllPostponedElements();
    [EditorBrowsableAttribute("1")]
public virtual void SetParent(LanguageElement aParent);
    private sealed virtual override void DevExpress.CodeParser.IElementModifier.SetName(string name);
    private sealed virtual override void DevExpress.CodeParser.IElementModifier.InsertChild(int index, IElement child);
    [EditorBrowsableAttribute("1")]
public void SetFakeFlag(bool isFakeNode);
    [EditorBrowsableAttribute("1")]
public void SetIndex(int index);
    public virtual IElement GetDeclaration();
    public virtual IElement GetDeclaration(bool restore);
    public virtual IElementCollection FindAllReferences();
    public virtual IElementCollection FindAllReferences(IElement scope);
    protected virtual int get_ThisMaintenanceComplexity();
    protected virtual PostponedParsingData get_PostponedData();
    protected virtual void set_PostponedData(PostponedParsingData value);
    protected internal NodeList get_OwningList();
    protected CommentCollection get_PostponedComments();
    protected void set_PostponedComments(CommentCollection value);
    public virtual string get_MacroCall();
    public virtual void set_MacroCall(string value);
    public bool get_ParsingPostponedTokens();
    public void set_ParsingPostponedTokens(bool value);
    public SourceRange get_Range();
    public virtual bool get_CanContainCode();
    public bool get_CanBeDocumented();
    public virtual bool get_CompletesPrevious();
    public virtual bool get_DeclaresIdentifier();
    public abstract virtual LanguageElementType get_ElementType();
    public bool get_InsideMethod();
    public bool get_InsideEvent();
    public bool get_InsideEventAccessor();
    public bool get_InsideAssignment();
    public bool get_InsideOutArgumentDirection();
    public bool get_InsideRefArgumentDirection();
    public bool get_InsideIncrement();
    public bool get_InsideDecrement();
    public bool get_InsideProperty();
    public bool get_InsideClass();
    public bool get_InsideStruct();
    public bool get_InsideInterface();
    public bool get_InsideNamespace();
    public bool get_IsDetailNode();
    public void set_IsDetailNode(bool value);
    public bool get_HasDocument();
    public int get_LevelsDeep();
    public LanguageElement get_Parent();
    public SourceFile get_FileNode();
    public RegionDirective get_ParentRegion();
    public bool get_IsLoop();
    public ParentingStatement get_ParentLoop();
    public Try get_ParentTryBlock();
    public LanguageElement get_ParentWith();
    public virtual string get_ParentPath();
    public virtual string get_PathSegment();
    public virtual ISolutionElement get_Solution();
    public virtual IProjectElement get_Project();
    public string get_Location();
    public string GetFileLocation();
    public string get_RootNamespaceLocation();
    public LanguageElement get_PreviousNode();
    public LanguageElement get_NextNode();
    public virtual LanguageElement get_NextSibling();
    public virtual LanguageElement get_PreviousSibling();
    public virtual LanguageElement get_NextCodeSibling();
    public LanguageElement NextStandaloneCodeSibling(LanguageElement element);
    public LanguageElement NextStandaloneCodeSibling();
    public virtual LanguageElement get_PreviousCodeSibling();
    public virtual LanguageElement get_FirstDetail();
    public virtual LanguageElement get_FirstChild();
    public LanguageElement get_FirstSibling();
    public virtual NodeList get_Nodes();
    public virtual NodeList get_DetailNodes();
    public virtual bool get_UsePostponedParsing();
    public bool get_HasUnparsedCode();
    public ISourceReader get_UnparsedCode();
    public bool get_HasPostponedComments();
    public int get_Index();
    public LanguageElement get_LastSibling();
    public sealed virtual bool get_IsFakeNode();
    public virtual LanguageElement get_LastChild();
    public virtual LanguageElement get_LastDetail();
    public virtual IDocument get_Document();
    public IDXCoreTextView get_View();
    public bool get_IsCollapsible();
    public SourceRange get_CollapsibleRange();
    protected virtual bool get_HasOuterRangeChildren();
    public virtual bool get_IsTypeDeclaration();
    public void set_Tokens(LanguageElementTokens value);
    public LanguageElementTokens get_Tokens();
    public bool get_Collapsed();
    public void set_Collapsed(bool value);
    public bool get_Expanded();
    public void set_Expanded(bool value);
    public bool IsExpandedInView(IDXCoreTextView textView);
    public void ExpandInView(IDXCoreTextView textView);
    public void ExpandInView(IDXCoreTextView textView, bool undoable);
    public bool IsCollapsedInView(IDXCoreTextView textView);
    public void CollapseInView(IDXCoreTextView textView);
    public void Collapse(IDXCoreTextView textView, bool undoable);
    public bool InCollapsedRange(IDXCoreTextView textView);
    public bool get_HasErrors();
    public void set_HasErrors(bool value);
    public bool get_IsRemoved();
    public void set_IsRemoved(bool value);
    private sealed virtual override void DevExpress.CodeParser.IElement.Accept(IElementVisitor visitor);
    private sealed virtual override IElement DevExpress.CodeParser.IElement.GetParent(LanguageElementType type, LanguageElementType[] args);
    private sealed virtual override IElement DevExpress.CodeParser.IElement.GetParentStatementOrVariable();
    private sealed virtual override IElement DevExpress.CodeParser.IElement.FindChildByName(string name);
    private sealed virtual override bool DevExpress.CodeParser.IElement.IsParentedBy(IElement element);
    private sealed virtual override IElement DevExpress.CodeParser.IElement.Clone();
    private sealed virtual override IElement DevExpress.CodeParser.IElement.Clone(ElementCloneOptions options);
    private sealed virtual override LanguageElement DevExpress.CodeParser.IElement.ToLanguageElement();
    private sealed virtual override string DevExpress.CodeParser.IElement.get_Name();
    private sealed virtual override string DevExpress.CodeParser.IElement.get_FullName();
    private sealed virtual override IElement DevExpress.CodeParser.IElement.get_Parent();
    private sealed virtual override ITypeElement DevExpress.CodeParser.IElement.get_ParentType();
    private sealed virtual override IEventElement DevExpress.CodeParser.IElement.get_ParentEvent();
    private sealed virtual override IMemberElement DevExpress.CodeParser.IElement.get_ParentMember();
    private sealed virtual override IMethodElement DevExpress.CodeParser.IElement.get_ParentMethod();
    private sealed virtual override IElement DevExpress.CodeParser.IElement.get_ParentMethodOrAccessor();
    private sealed virtual override IElement DevExpress.CodeParser.IElement.get_ParentMethodOrPropertyOrEvent();
    private sealed virtual override IPropertyElement DevExpress.CodeParser.IElement.get_ParentProperty();
    private sealed virtual override INamespaceElement DevExpress.CodeParser.IElement.get_ParentNamespace();
    private sealed virtual override IProjectElement DevExpress.CodeParser.IElement.get_Project();
    private sealed virtual override ISolutionElement DevExpress.CodeParser.IElement.get_Solution();
    private sealed virtual override IAssemblyModel DevExpress.CodeParser.IElement.get_AssemblyModel();
    private sealed virtual override IElementCollection DevExpress.CodeParser.IElement.get_Children();
    [IteratorStateMachineAttribute("DevExpress.CodeParser.LanguageElement/<DevExpress-CodeParser-IElement-get_AllChildren>d__468")]
private sealed virtual override IEnumerable`1<IElement> DevExpress.CodeParser.IElement.get_AllChildren();
    private sealed virtual override IElementCollection DevExpress.CodeParser.IElement.get_CodeChildren();
    private sealed virtual override ISourceFileCollection DevExpress.CodeParser.IElement.get_Files();
    private sealed virtual override ISourceFile DevExpress.CodeParser.IElement.get_FirstFile();
    private sealed virtual override ITextRangeCollection DevExpress.CodeParser.IElement.get_Ranges();
    private sealed virtual override TextRange DevExpress.CodeParser.IElement.get_FirstRange();
    private sealed virtual override ITextRangeCollection DevExpress.CodeParser.IElement.get_NameRanges();
    private sealed virtual override TextRange DevExpress.CodeParser.IElement.get_FirstNameRange();
    private sealed virtual override IElement DevExpress.CodeParser.IElement.get_NextSibling();
    private sealed virtual override IElement DevExpress.CodeParser.IElement.get_PreviousSibling();
    private sealed virtual override string DevExpress.CodeParser.IElement.get_RootNamespaceFullName();
    private sealed virtual override bool DevExpress.CodeParser.IElement.get_InReferencedAssembly();
    private sealed virtual override bool DevExpress.CodeParser.IElement.get_IsMember();
    private sealed virtual override bool DevExpress.CodeParser.IElement.get_IsNestedType();
    private sealed virtual override int DevExpress.CodeParser.IElement.get_ImageIndex();
    private sealed virtual override void DevExpress.CodeParser.IElementModifier.SetParent(IElement parent);
    private sealed virtual override void DevExpress.CodeParser.IElementModifier.ReplaceChild(IElement oldNode, IElement newNode);
    private sealed virtual override void DevExpress.CodeParser.IElementModifier.SetFakeNode(bool isFakeNode);
    public sealed virtual IEnumerator GetEnumerator();
}
public abstract class DevExpress.CodeParser.LanguageElementCodeGenBase : CodeGenObject {
    private CodeGen _CodeGen;
    protected CodeGen CodeGen { get; }
    protected FormattingTokenGen TokenGen { get; }
    public CodeGenOptions Options { get; }
    public LanguageElement Context { get; }
    public LanguageElementCodeGenBase(CodeGen codeGen);
    private bool FindElement(LanguageElementType[] list, LanguageElement element);
    private bool WillSkipOtherElements(ICollection parameters, LanguageElementType[] excludeElements, int paramIndex);
    private void WriteDelimiter(FormattingTokenType[] delimiters, Int32& delimiterIndex);
    private void AddLineBreakAfterDelimiterIfNeeded(bool needLineBreak, LanguageElement generated);
    protected string GetLineContinuation();
    protected bool SkipElement(LanguageElement element);
    protected bool ContextMatch(LanguageElementType type);
    protected virtual void Write(string text);
    protected virtual void Write(string text, bool split);
    protected virtual void IncreaseIndent();
    protected virtual void DecreaseIndent();
    protected IDisposable GetIndent(bool needIndent);
    protected IDisposable GetIndent();
    protected IDisposable GetClearIndent(bool needClear);
    internal bool ElementWasGenerated(LanguageElement element);
    internal void AddGeneratedElement(LanguageElement element);
    internal void RemoveGeneratedElement(LanguageElement element);
    public virtual bool GenerateElementTail(LanguageElement element);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual void GenerateElementCollection(ICollection parameters, FormattingTokenType delimiter, bool lineBreakAfterDelimiter, LanguageElementType[] excludeElements);
    public virtual void GenerateElementCollection(ICollection parameters, FormattingTokenType[] delimiters, bool lineBreakAfterDelimiter, LanguageElementType[] excludeElements);
    public virtual void GenerateParameters(ICollection parameters);
    public virtual bool IsSkipped(LanguageElement element);
    public virtual void AddSkipped(LanguageElement element);
    public virtual void ClearSkippedElements();
    [EditorBrowsableAttribute("1")]
public CodeGen GetCodeGen();
    public void GenerateElementCollection(ICollection parameters);
    public void GenerateElementCollection(ICollection parameters, FormattingTokenType delimiter);
    public void GenerateElementCollection(ICollection parameters, FormattingTokenType[] delimiters);
    public void GenerateElementCollection(ICollection parameters, FormattingTokenType delimiter, LanguageElementType[] excludeElements);
    public void GenerateElementCollection(ICollection parameters, FormattingTokenType delimiter, bool lineBreakAfterDelimiter);
    public void Write(TokenList types);
    public void Write(FormattingTokenType[] types);
    public void Write(FormattingTokenType type);
    public void Write(FormattingTokenType type, int index);
    public void Write(FormattingTokenType type, string tokenText);
    public void Write(FormattingTokenType type, int index, string tokenText);
    public void Write(FormattingTokenType type, int contextsIndex, int index, string tokenText);
    public void Write(GenTextArgs args);
    public void CodeWritePrevFormattingElements(FormattingTokenType type);
    public void CodeWriteNextFormattingElements(FormattingTokenType type);
    protected virtual CodeGen get_CodeGen();
    protected FormattingTokenGen get_TokenGen();
    public virtual CodeGenOptions get_Options();
    public LanguageElement get_Context();
    private bool SkipElementOld(LanguageElement element);
    public void GenerateParameters(ICollection parameters, string delimiter);
    public void GenerateElementCollection(ICollection parameters, string delimiter);
    public void GenerateElementCollection(ICollection parameters, string delimiter, LanguageElementType[] excludeElements);
    public void GenerateElementCollection(ICollection parameters, string delimiter, bool lineBreakAfterDelimiter);
    public virtual void GenerateElementCollection(ICollection parameters, string delimiter, bool lineBreakAfterDelimiter, LanguageElementType[] excludeElements);
    protected void WriteOpenBrace(bool onNewLine, bool spaceBefore, bool spaceAfter, bool increaseIndent);
    protected void WriteCloseBrace(bool onNewLine, bool spaceBefore, bool decreaseIndent);
    protected string GetCommaDelimeter();
    protected string GetCommaDelimeter(string endOfLineChar);
    protected void WriteOpenParen(bool spaceBefore, bool spaceAfter);
    protected void WriteCloseParen(bool spaceBefore);
    protected void WriteLineTerminator(bool needWrite, LanguageElement element);
    protected void WriteDot();
    protected void WriteOperator(string op);
    protected void WriteSemicolon();
    protected void WriteSemicolon(bool spacingAfter);
    protected void WriteWhithing(bool before, string text, bool after);
    public void GenerateElementsByRules(NodeList parameters, ElementsGenerationRules rules);
    private void PrepareNextElementSpaces(string firstSpaces, ElementsGenerationRules rules);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.LanguageElementCollection : LanguageElementCollectionBase {
    public static LanguageElementCollection Empty;
    public LanguageElement Item { get; public set; }
    private static LanguageElementCollection();
    public int Add(LanguageElement value);
    public void Add(LanguageElementCollection collection);
    public void AddRange(LanguageElementCollection collection);
    public bool Contains(LanguageElement value);
    public void CopyTo(LanguageElement[] array, int index);
    public int IndexOf(LanguageElement value);
    public void Insert(int index, LanguageElement value);
    public void Remove(LanguageElement value);
    public void Sort();
    public void SortReverse();
    public static LanguageElementCollection FromNodeList(NodeList nodes);
    public static LanguageElementCollection FromArray(LanguageElement[] elements);
    public void RemoveElementsInRange(SourceRange range);
    public void RemoveRange(int startIndex, int count);
    protected virtual NodeList CreateInstance();
    public LanguageElementCollection DeepClone(ElementCloneOptions options);
    public LanguageElement get_Item(int index);
    public void set_Item(int index, LanguageElement value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.LanguageElementCollectionBase : NodeList {
    protected LanguageElement Item { get; protected set; }
    [IteratorStateMachineAttribute("DevExpress.CodeParser.LanguageElementCollectionBase/<System-Collections-Generic-IEnumerable<DevExpress-CodeParser-LanguageElement>-GetEnumerator>d__0")]
private sealed virtual override IEnumerator`1<LanguageElement> System.Collections.Generic.IEnumerable<DevExpress.CodeParser.LanguageElement>.GetEnumerator();
    protected int Add(LanguageElement element);
    protected void AddRange(LanguageElementCollectionBase collection);
    protected int IndexOf(LanguageElement element);
    protected void Insert(int index, LanguageElement element);
    protected void Remove(LanguageElement element);
    protected LanguageElement Find(LanguageElement element);
    protected bool Contains(LanguageElement element);
    protected virtual NodeList CreateInstance();
    public virtual string ToString();
    public SourceRange GetRange();
    protected LanguageElement get_Item(int index);
    protected void set_Item(int index, LanguageElement value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerator <>n__0();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.LanguageElementList : NodeList {
    public LanguageElement Item { get; public set; }
    protected virtual NodeList CreateInstance();
    public LanguageElement get_Item(int index);
    public void set_Item(int index, LanguageElement value);
}
public abstract class DevExpress.CodeParser.LanguageElementParserBase : object {
    private ParserBase _Parser;
    public ParserBase Parser { get; }
    public LanguageElementParserBase(ParserBase parser);
    public ParserBase get_Parser();
}
public class DevExpress.CodeParser.LanguageElementRestorer : object {
    private static string GetText(SourceFile file);
    private static LanguageElement GetStartForExpression(LanguageElement node);
    private static LanguageElement GetAppropriateStart(LanguageElement scope, SourceRange range);
    [EditorBrowsableAttribute("1")]
public static LanguageElement FindElement(LanguageElement scope, SourceRange range, bool checkNameRangeOnly);
    [EditorBrowsableAttribute("1")]
public static LanguageElement FindElement(LanguageElement scope, SourceRange range, LanguageElementType type);
    [EditorBrowsableAttribute("1")]
public static LanguageElement FindElement(LanguageElement scope, SourceRange range, LanguageElementType type, bool checkNameRangeOnly);
    private static bool IsValidType(LanguageElementType first, LanguageElementType second);
    private static bool IsValidVariable(LanguageElementType first, LanguageElementType second);
    private static bool IsValidQualifiedTypeReference(LanguageElementType first, LanguageElementType second);
    private static bool TryConvertAspxFieldTag(LanguageElementCollection result, IFieldElement field, IElement element);
    public static LanguageElementCollection ConvertToLanguageElements(IElement element);
    private static bool NeedsToCheckNameRangeOnly(LanguageElementType type);
    public static LanguageElement ConvertToLanguageElement(IElement element);
    public static LanguageElementCollection ConvertToLanguageElements(IElementCollection elements);
}
public class DevExpress.CodeParser.LanguageElementTokens : object {
    private Dictionary`2<FormattingTokenType, FormattingElementCollection> _Coll;
    public LanguageElementTokens(List`1<FormattingParsingElement> elements);
    public LanguageElementTokens(FormattingTokenType type, FormattingElementCollection collection);
    public LanguageElementTokens(FormattingTokenType[] type, FormattingElementCollection[] collection);
    private void Convert(List`1<FormattingParsingElement> elements);
    private static bool DeleteDirective(LanguageElement fromElement, PreprocessorDirective searchElement);
    private FormattingElementCollection GetFormattingElementCollection(TokenPosition position);
    private FormattingElements GetFormattingElements(TokenPosition position);
    private bool LastIsEOL(FormattingElements elements);
    private int FindLineByIndex(List`1<int> indexesEOLs, int index);
    private FormattingElements CutTokens(FormattingElements elements, PreprocessorDirective leave, LanguageElement cut, List`1<FullDirective> emptyFulls, Dictionary`2<PreprocessorDirective, LanguageElement> regionsToDelete, LanguageElementCollection& commentsToFirst, LanguageElementCollection& commentsToSecond);
    [EditorBrowsableAttribute("1")]
public void AddElements(FormattingTokenType type, IEnumerable`1<IFormattingElement> fe);
    public bool HasElement(FormattingTokenType type);
    public void RemoveAll(Type type);
    public FormattingElements Get(FormattingTokenType type, int index);
    public LanguageElementTokens Clone(ElementCloneOptions options);
    public PreprocessorDirective GetLeaveFromSourceFile(SourceFile file, List`1<FullDirective> fulls);
    public FormattingElements CutTokens(TokenPosition positionFrom, PreprocessorDirective leave, LanguageElement cut, List`1<FullDirective> emptyFulls, Dictionary`2<PreprocessorDirective, LanguageElement> regionsToDelete, LanguageElementCollection& commentsToFirst, LanguageElementCollection& commentsToSecond);
    public void CutTokens(FormattingTokenType type, int index, PreprocessorDirective leave, LanguageElement cut, List`1<FullDirective> emptyFulls, Dictionary`2<PreprocessorDirective, LanguageElement> regionsToDelete, FormattingElements& fesToFirst, FormattingElements& fesToSecond, LanguageElementCollection& elementsToFirst, LanguageElementCollection& elementsToSecond);
    public static void DeleteRegions(Dictionary`2<PreprocessorDirective, LanguageElement> regionsToDelete);
    public bool AddEOLToEnd();
    public void DeleteLastEOL();
    public bool PasteTokens(TokenPosition toPosition, FormattingElements elementsToAdd);
    public void PasteTokens(FormattingTokenType typeToAdd, int indexToAdd, FormattingElements elementsToAdd);
    public void AddCommentOrRegion(TokenPosition toPosition, int indent, LanguageElement toAdd);
    public void AddEmptyLinesToEnd(int countEmptyLines);
    public void DeleteEmptyLines(FormattingTokenType type, int index);
    public void DeleteEmptyLines(FormattingTokenType type, int index, bool attemptDeleteLastLine);
}
public enum DevExpress.CodeParser.LanguageElementType : Enum {
    public short value__;
    public static LanguageElementType Unknown;
    public static LanguageElementType Module;
    public static LanguageElementType Block;
    public static LanguageElementType Class;
    public static LanguageElementType Const;
    public static LanguageElementType Method;
    public static LanguageElementType Variable;
    public static LanguageElementType Enum;
    public static LanguageElementType PreprocessorDirective;
    public static LanguageElementType ErrorDirective;
    public static LanguageElementType ElifDirective;
    public static LanguageElementType IfDirective;
    public static LanguageElementType ElseDirective;
    public static LanguageElementType DefineDirective;
    public static LanguageElementType UndefineDirective;
    public static LanguageElementType EndifDirective;
    public static LanguageElementType EndRegionDirective;
    public static LanguageElementType WarningDirective;
    public static LanguageElementType LineDirective;
    public static LanguageElementType PragmaDirective;
    public static LanguageElementType AttributeSection;
    public static LanguageElementType Attribute;
    public static LanguageElementType Document;
    public static LanguageElementType SourceFile;
    public static LanguageElementType Namespace;
    public static LanguageElementType Do;
    public static LanguageElementType Parameter;
    public static LanguageElementType Property;
    public static LanguageElementType Assignment;
    public static LanguageElementType EventAccessor;
    public static LanguageElementType PropertyAccessor;
    public static LanguageElementType PropertyAccessorGet;
    public static LanguageElementType PropertyAccessorSet;
    public static LanguageElementType ParameterReference;
    public static LanguageElementType Statement;
    public static LanguageElementType EmptyStatement;
    public static LanguageElementType NamespaceReference;
    public static LanguageElementType Interface;
    public static LanguageElementType Fixed;
    public static LanguageElementType Abort;
    public static LanguageElementType If;
    public static LanguageElementType Else;
    public static LanguageElementType Case;
    public static LanguageElementType FlowBreak;
    public static LanguageElementType Switch;
    public static LanguageElementType For;
    public static LanguageElementType ForEach;
    public static LanguageElementType Struct;
    public static LanguageElementType While;
    public static LanguageElementType Try;
    public static LanguageElementType Catch;
    public static LanguageElementType Finally;
    public static LanguageElementType Return;
    public static LanguageElementType Break;
    public static LanguageElementType Throw;
    public static LanguageElementType Continue;
    public static LanguageElementType Region;
    public static LanguageElementType Lock;
    public static LanguageElementType UsingStatement;
    public static LanguageElementType InitializedVariable;
    public static LanguageElementType Delegate;
    public static LanguageElementType Event;
    public static LanguageElementType Goto;
    public static LanguageElementType Label;
    public static LanguageElementType Checked;
    public static LanguageElementType Unchecked;
    public static LanguageElementType EnumElement;
    public static LanguageElementType MethodCall;
    public static LanguageElementType Comment;
    public static LanguageElementType XmlDocComment;
    public static LanguageElementType EventAdd;
    public static LanguageElementType EventRemove;
    public static LanguageElementType TextString;
    public static LanguageElementType Expression;
    public static LanguageElementType With;
    public static LanguageElementType Resume;
    public static LanguageElementType RemoveHandler;
    public static LanguageElementType ElseIf;
    public static LanguageElementType Stop;
    public static LanguageElementType End;
    public static LanguageElementType ElementReference;
    public static LanguageElementType ConstructorInitializer;
    public static LanguageElementType XmlDocElement;
    public static LanguageElementType XmlDocText;
    public static LanguageElementType XmlDocAttribute;
    public static LanguageElementType XmlReference;
    public static LanguageElementType XmlCharacterData;
    public static LanguageElementType Local;
    public static LanguageElementType TypeDeclaration;
    public static LanguageElementType CallStatement;
    public static LanguageElementType CaseClausesList;
    public static LanguageElementType CaseClause;
    public static LanguageElementType MiscFiles;
    public static LanguageElementType AssemblyReference;
    public static LanguageElementType ProjectElement;
    public static LanguageElementType SolutionElement;
    public static LanguageElementType VisualStudioDocument;
    public static LanguageElementType QueuedInsert;
    public static LanguageElementType QueuedDelete;
    public static LanguageElementType QueuedReplace;
    public static LanguageElementType ArgumentDirectionExpression;
    public static LanguageElementType ArrayCreateExpression;
    public static LanguageElementType ArrayInitializerExpression;
    public static LanguageElementType AssignmentExpression;
    public static LanguageElementType AddressOfExpression;
    public static LanguageElementType BaseReferenceExpression;
    public static LanguageElementType BinaryOperatorExpression;
    public static LanguageElementType CheckedExpression;
    public static LanguageElementType ConditionalExpression;
    public static LanguageElementType ElementReferenceExpression;
    public static LanguageElementType IndexerExpression;
    public static LanguageElementType MethodCallExpression;
    public static LanguageElementType MethodReferenceExpression;
    public static LanguageElementType ObjectCreationExpression;
    public static LanguageElementType ParenthesizedTypeReferenceExpression;
    public static LanguageElementType ParenthesizedExpression;
    public static LanguageElementType PrimitiveExpression;
    public static LanguageElementType QueueSnippetExpression;
    public static LanguageElementType SizeOfExpression;
    public static LanguageElementType SnippetExpression;
    public static LanguageElementType ThisReferenceExpression;
    public static LanguageElementType MyClassExpression;
    public static LanguageElementType TypeCastExpression;
    public static LanguageElementType TypeOfExpression;
    public static LanguageElementType TypeOfIsExpression;
    public static LanguageElementType TypeReferenceExpression;
    public static LanguageElementType UnaryOperatorExpression;
    public static LanguageElementType UncheckedExpression;
    public static LanguageElementType DirectCastExpression;
    public static LanguageElementType CTypeExpression;
    public static LanguageElementType CastTargetExpression;
    public static LanguageElementType LogicalOperation;
    public static LanguageElementType LogicalInversion;
    public static LanguageElementType UnaryIncrement;
    public static LanguageElementType UnaryDecrement;
    public static LanguageElementType RelationalOperation;
    public static LanguageElementType TypeCheck;
    public static LanguageElementType ConditionalTypeCast;
    public static LanguageElementType MemberAccessExpression;
    public static LanguageElementType IsNot;
    public static LanguageElementType Is;
    public static LanguageElementType AttributeVariableInitializer;
    public static LanguageElementType OnError;
    public static LanguageElementType ReDim;
    public static LanguageElementType ConstDirective;
    public static LanguageElementType OptionDirective;
    public static LanguageElementType AddHandler;
    public static LanguageElementType ArrayNameModifier;
    public static LanguageElementType EmptyParens;
    public static LanguageElementType EmptyCommaDelimiter;
    public static LanguageElementType SnippetCodeElement;
    public static LanguageElementType SnippetCodeMember;
    public static LanguageElementType SnippetCodeStatement;
    public static LanguageElementType SnippetCodeStatementBlock;
    public static LanguageElementType Exit;
    public static LanguageElementType PartialLanguageElement;
    public static LanguageElementType ElementList;
    public static LanguageElementType RaiseEvent;
    public static LanguageElementType AnonymousMethodExpression;
    public static LanguageElementType AnonymousConstructorExpression;
    public static LanguageElementType DefaultValueExpression;
    public static LanguageElementType NullCoalescingExpression;
    public static LanguageElementType QualifiedAliasExpression;
    public static LanguageElementType GenericModifier;
    public static LanguageElementType TypeParameter;
    public static LanguageElementType TypeParameterConstraint;
    public static LanguageElementType NewTypeParameterConstraint;
    public static LanguageElementType ClassTypeParameterConstraint;
    public static LanguageElementType StructTypeParameterConstraint;
    public static LanguageElementType NamedTypeParameterConstraint;
    public static LanguageElementType YieldBreak;
    public static LanguageElementType YieldReturn;
    public static LanguageElementType ExternAlias;
    public static LanguageElementType EventRaise;
    public static LanguageElementType Volatile;
    public static LanguageElementType InitializedVolatile;
    public static LanguageElementType MethodPrototype;
    public static LanguageElementType QualifiedTypeReferenceExpression;
    public static LanguageElementType AncestorTypeReference;
    public static LanguageElementType ParametrizedObjectCreationExpression;
    public static LanguageElementType ParametrizedArrayCreateExpression;
    public static LanguageElementType DeleteExpression;
    public static LanguageElementType ManagedObjectCreationExpression;
    public static LanguageElementType FunctionPointerTypeReference;
    public static LanguageElementType BitFieldVariable;
    public static LanguageElementType BitFieldVolatile;
    public static LanguageElementType BitFieldConst;
    public static LanguageElementType CppQualifiedElementReference;
    public static LanguageElementType QualifiedNestedReference;
    public static LanguageElementType QualifiedNestedTypeReference;
    public static LanguageElementType PointerElementReference;
    public static LanguageElementType ElaboratedTypeReference;
    public static LanguageElementType UsingDeclaration;
    public static LanguageElementType AccessDeclaration;
    public static LanguageElementType Union;
    public static LanguageElementType ManagedClass;
    public static LanguageElementType ManagedStruct;
    public static LanguageElementType InterfaceClass;
    public static LanguageElementType InterfaceStruct;
    public static LanguageElementType ValueClass;
    public static LanguageElementType ValueStruct;
    public static LanguageElementType CppAttributeSection;
    public static LanguageElementType ClassTypeParameter;
    public static LanguageElementType TypenameTypeParameter;
    public static LanguageElementType ValueClassTypeParameterConstraint;
    public static LanguageElementType ValueStructTypeParameterConstraint;
    public static LanguageElementType ComplexExpression;
    public static LanguageElementType PointerMethodReference;
    public static LanguageElementType QualifiedMethodReference;
    public static LanguageElementType StaticCastExpression;
    public static LanguageElementType DynamicCastExpression;
    public static LanguageElementType ReinterpretCastExpression;
    public static LanguageElementType ConstCastExpression;
    public static LanguageElementType DeleteArrayExpression;
    public static LanguageElementType ComplexConstructorInitializer;
    public static LanguageElementType TemplateModifier;
    public static LanguageElementType NamedTemplateParameter;
    public static LanguageElementType ClassTemplateParameter;
    public static LanguageElementType NestedTemplateParameter;
    public static LanguageElementType MemberVisibilitySpecifier;
    public static LanguageElementType ExternDeclaration;
    public static LanguageElementType TemplateExpression;
    public static LanguageElementType TryCastExpression;
    public static LanguageElementType IfDefDirective;
    public static LanguageElementType IfnDefDirective;
    public static LanguageElementType IncludeDirective;
    public static LanguageElementType ImportDirective;
    public static LanguageElementType ManagedArrayCreateExpression;
    public static LanguageElementType AssemblerStatement;
    public static LanguageElementType Except;
    public static LanguageElementType SafeCastExpression;
    public static LanguageElementType HtmlElement;
    public static LanguageElementType HtmlText;
    public static LanguageElementType HtmlAttribute;
    public static LanguageElementType HtmlScript;
    public static LanguageElementType HtmlStyle;
    public static LanguageElementType MacroExpressionCall;
    public static LanguageElementType AspDirective;
    public static LanguageElementType AspCodeEmbedding;
    public static LanguageElementType AspDataBinding;
    public static LanguageElementType AspExpressionEmbedding;
    public static LanguageElementType ExpressionTypeArgument;
    public static LanguageElementType ConstVolatile;
    public static LanguageElementType ServerControlElement;
    public static LanguageElementType PageDirective;
    public static LanguageElementType RegisterDirective;
    public static LanguageElementType ControlDirective;
    public static LanguageElementType MasterDirective;
    public static LanguageElementType ContentPlaceHolder;
    public static LanguageElementType NestedMethod;
    public static LanguageElementType AspImportDirective;
    public static LanguageElementType UnsafeStatement;
    public static LanguageElementType FictiveAspComment;
    public static LanguageElementType ImplicitVariable;
    public static LanguageElementType ExtensionMethodParam;
    public static LanguageElementType MemberInitializerExpression;
    public static LanguageElementType ObjectInitializerExpression;
    public static LanguageElementType LambdaExpression;
    public static LanguageElementType FromExpression;
    public static LanguageElementType QueryIdent;
    public static LanguageElementType JoinExpression;
    public static LanguageElementType QueryExpression;
    public static LanguageElementType QueryBodyExpression;
    public static LanguageElementType LetExpression;
    public static LanguageElementType WhereExpression;
    public static LanguageElementType OrderingExpression;
    public static LanguageElementType OrderByExpression;
    public static LanguageElementType SelectExpression;
    public static LanguageElementType IntoExpression;
    public static LanguageElementType LambdaImplicitlyTypedParam;
    public static LanguageElementType Distinct;
    public static LanguageElementType InExpression;
    [EditorBrowsableAttribute("1")]
public static LanguageElementType QueryableCollectionReferenceExpression;
    public static LanguageElementType AtgCodeGenSetting;
    public static LanguageElementType AtgParserRule;
    public static LanguageElementType AtgParserPartition;
    public static LanguageElementType AtgResolver;
    public static LanguageElementType AtgFactor;
    public static LanguageElementType AtgComplexFactor;
    public static LanguageElementType AtgTerminal;
    public static LanguageElementType AtgExpression;
    public static LanguageElementType AtgTokenAlias;
    public static LanguageElementType AtgTokenDeclaration;
    public static LanguageElementType AtgCode;
    public static LanguageElementType VbXmlExpression;
    public static LanguageElementType ComplexGenericModifier;
    public static LanguageElementType XmlAttributeReference;
    public static LanguageElementType XmlElementReference;
    public static LanguageElementType AggregateExpression;
    public static LanguageElementType EqualsExpression;
    public static LanguageElementType GroupByExpression;
    public static LanguageElementType JoinIntoExpression;
    public static LanguageElementType SkipExpression;
    public static LanguageElementType SkipWhileExpression;
    public static LanguageElementType TakeExpression;
    public static LanguageElementType TakeWhileExpression;
    public static LanguageElementType EmptyArrayElementExpression;
    public static LanguageElementType EmptyArgumentExpression;
    public static LanguageElementType TypedElementReferenceExpression;
    public static LanguageElementType ReDimExpression;
    public static LanguageElementType OptionStatement;
    public static LanguageElementType Erase;
    public static LanguageElementType IfOperatorExpression;
    public static LanguageElementType GetXmlNamespaceOperator;
    public static LanguageElementType XmlNamespaceReference;
    public static LanguageElementType ShortInitializeExpression;
    public static LanguageElementType Comprehension;
    public static LanguageElementType ParenthesizedTypeReference;
    public static LanguageElementType Pattern;
    public static LanguageElementType Rule;
    public static LanguageElementType Rules;
    public static LanguageElementType SequentialExecutionExpression;
    public static LanguageElementType MatchExpression;
    public static LanguageElementType TupleExpression;
    public static LanguageElementType Tuple;
    public static LanguageElementType ListInitializerExpression;
    public static LanguageElementType BindingExpression;
    public static LanguageElementType DoStatement;
    public static LanguageElementType QuotationExpression;
    public static LanguageElementType RangeExpression;
    public static LanguageElementType SequenceExpression;
    public static LanguageElementType ILExpression;
    public static LanguageElementType VariableTypeReferenceExpression;
    public static LanguageElementType TypeConstraint;
    public static LanguageElementType CoercionConstraint;
    public static LanguageElementType DefaultConstructorConstraint;
    public static LanguageElementType MemberConstraint;
    public static LanguageElementType NotNullableStructConstraint;
    public static LanguageElementType NullnessConstraint;
    public static LanguageElementType ReferenceTypeConstraint;
    public static LanguageElementType Measure;
    public static LanguageElementType MeasureReferenceExpression;
    public static LanguageElementType PowerMeasureExpression;
    public static LanguageElementType ParenthesizedMeasureExpression;
    public static LanguageElementType ProductMeasureExpression;
    public static LanguageElementType QuotientMeasureExpression;
    public static LanguageElementType ReciprocalMeasureExpression;
    public static LanguageElementType DimensionlessMeasureExpression;
    public static LanguageElementType BlockExpression;
    public static LanguageElementType IfExpression;
    public static LanguageElementType ForExpression;
    public static LanguageElementType ForEachExpression;
    public static LanguageElementType TryWithExpression;
    public static LanguageElementType TryFinallyExpression;
    public static LanguageElementType WhileExpression;
    public static LanguageElementType ResourceBindingExpression;
    public static LanguageElementType FunctionExpression;
    public static LanguageElementType MatchingFunctionExpression;
    public static LanguageElementType DelayedExpression;
    public static LanguageElementType StaticUpcastExpression;
    public static LanguageElementType DynamicDowncastExpression;
    public static LanguageElementType AssertExpression;
    public static LanguageElementType BindingComputation;
    public static LanguageElementType SequentialComputation;
    public static LanguageElementType AutoCleanupComputation;
    public static LanguageElementType YieldComputation;
    public static LanguageElementType YieldResult;
    public static LanguageElementType ReturnComputation;
    public static LanguageElementType ReturnResult;
    public static LanguageElementType IterationComputation;
    public static LanguageElementType Exception;
    public static LanguageElementType AggregateElementReferenceExpression;
    public static LanguageElementType AggregateMethodCallExpression;
    public static LanguageElementType CorruptedLanguageElement;
    public static LanguageElementType ObjectCollectionInitializer;
    public static LanguageElementType LambdaFunctionExpression;
    public static LanguageElementType NullableTypeModifier;
    public static LanguageElementType AwaitExpression;
    public static LanguageElementType CssExpression;
    public static LanguageElementType CssFunctionReference;
    public static LanguageElementType CssAttribute;
    public static LanguageElementType CssCommentTag;
    public static LanguageElementType CssCharsetDeclaration;
    public static LanguageElementType CssColorReference;
    public static LanguageElementType CssPropertyDeclaration;
    public static LanguageElementType CssSelector;
    public static LanguageElementType CssAngleLiteral;
    public static LanguageElementType CssPseudoId;
    public static LanguageElementType CssFrequencyLiteral;
    public static LanguageElementType CssLengthLiteral;
    public static LanguageElementType CssTimeLiteral;
    public static LanguageElementType CssPageStyleDefinition;
    public static LanguageElementType CssPercentLiteral;
    public static LanguageElementType CssStyleSheet;
    public static LanguageElementType CssIdentifierReference;
    public static LanguageElementType CssURI;
    public static LanguageElementType CssStringLiteral;
    public static LanguageElementType CssStyleRule;
    public static LanguageElementType CssMediaDirective;
    public static LanguageElementType CssMediaQuery;
    public static LanguageElementType CssMediaExpression;
    public static LanguageElementType CssNumberLiteral;
    public static LanguageElementType CssPseudoFunction;
    public static LanguageElementType CssImportDirective;
    public static LanguageElementType RazorModelDirective;
    public static LanguageElementType RazorInheritsDirective;
    public static LanguageElementType RazorInlineHtmlExpression;
    public static LanguageElementType RazorSectionElement;
    public static LanguageElementType MarkupExtensionExpression;
    public static LanguageElementType DependencyProperty;
}
public abstract class DevExpress.CodeParser.LanguageTokensBase : object {
    protected abstract virtual StringCollection CreateKeywords();
    public virtual bool IsNewLine(char ch);
    public virtual bool IsNewLine(string s);
    public virtual bool IsWhiteSpace(char ch);
    public abstract virtual bool IsKeyword(string word);
    public abstract virtual bool IsIdentifier(string word);
    public abstract virtual bool IsDirective(int type);
    public abstract virtual bool IsStringLiteral(int type);
    public abstract virtual bool IsNumber(int type);
    public abstract virtual bool IsComment(int type);
    public abstract virtual bool IsXmlDocComment(int type);
    public abstract virtual bool IsStandardType(string word);
    public virtual bool IsOperator(int type);
    public abstract virtual int ToTokenType(string token);
}
public abstract class DevExpress.CodeParser.LanguageUtils : object {
    private static ParserVersion ENUM_LastParsertVersion;
    public static ParserLanguageID GetLanguageId(string fileNameOrFileExtension);
    public static LanguageUtils Create(ParserLanguageID languageId);
    public static LanguageUtils Create(string fileNameOrFileExtension);
    public static Tokenizer GetTokenizer(ParserLanguageID languageId);
    public static Tokenizer GetTokenizer(string fileExtension);
    public ParserBase CreateParser();
    public abstract virtual Tokenizer CreateTokenizer();
    public abstract virtual ParserBase CreateParser(ParserVersion version, EmbededLanguageKind languageKind, DotNetLanguageType embededLanguage);
    public abstract virtual CodeGen CreateCodeGen();
    public abstract virtual ElementBuilder CreateElementBuilder();
}
public class DevExpress.CodeParser.LetExpression : QueryExpressionBase {
    private LanguageElementCollection _Declarations;
    public LanguageElementCollection Declarations { get; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddDeclarations(IEnumerable`1<LanguageElement> declarations);
    public void AddDeclaration(LanguageElement element);
    public LanguageElementCollection get_Declarations();
    public virtual LanguageElementType get_ElementType();
    public virtual string ToString();
}
public class DevExpress.CodeParser.LineDirective : CompilerDirective {
    private int _LineNumber;
    private string _FileName;
    private bool _Hidden;
    private bool _Default;
    public LanguageElementType ElementType { get; }
    public int LineNumber { get; public set; }
    public string FileName { get; public set; }
    public bool Hidden { get; public set; }
    public bool Default { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public int get_LineNumber();
    public void set_LineNumber(int value);
    public string get_FileName();
    public void set_FileName(string value);
    public bool get_Hidden();
    public void set_Hidden(bool value);
    public bool get_Default();
    public void set_Default(bool value);
}
public class DevExpress.CodeParser.LineRange : ValueType {
    private int _NumLines;
    public int NumLines { get; }
    public LineRange(int numLines);
    public static int op_Implicit(LineRange lineRange);
    public static LineRange op_Implicit(int numLines);
    public static bool op_Equality(LineRange left, int right);
    public static bool op_Inequality(LineRange left, int right);
    public static bool op_Equality(int left, LineRange right);
    public static bool op_Inequality(int left, LineRange right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LineRange obj);
    public bool Equals(int obj);
    public int get_NumLines();
}
public enum DevExpress.CodeParser.LineTerminator : Enum {
    public int value__;
    public static LineTerminator None;
    public static LineTerminator MSDOS;
    public static LineTerminator Mac;
    public static LineTerminator Unix;
    public static LineTerminator LineSeparator;
    public static LineTerminator ParagraphSeparator;
}
public enum DevExpress.CodeParser.LineTerminatorChar : Enum {
    public int value__;
    public static LineTerminatorChar Unknown;
    public static LineTerminatorChar CarriageReturn;
    public static LineTerminatorChar LineFeed;
    public static LineTerminatorChar LineSeparator;
    public static LineTerminatorChar ParagraphSeparator;
}
[DefaultMemberAttribute("Item")]
internal class DevExpress.CodeParser.LinkedList : object {
    private int m_Count;
    private Node m_Cursor;
    private int m_CursorIndex;
    private Node m_Head;
    private Node m_Tail;
    private NodeCache m_NodeCache;
    private object m_SyncRoot;
    public int Count { get; }
    public object Current { get; }
    public bool IsAfterLast { get; }
    public bool IsBeforeFirst { get; }
    public object Item { get; public set; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private Node AllocNode();
    private Node AllocNode(object value);
    private void FreeNode(Node node);
    private void PositionAtIndex(int index);
    public sealed virtual int Add(object value);
    public void AddRange(ICollection range);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public void DeleteAtCursor();
    public object First();
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public void InsertAtCursor(object value);
    public object Last();
    public void MoveAfterLast();
    public void MoveBeforeFirst();
    public void MoveNext();
    public void MovePrior();
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual int get_Count();
    public object get_Current();
    public bool get_IsAfterLast();
    public bool get_IsBeforeFirst();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
}
public class DevExpress.CodeParser.LiteAttributeElementCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IAttributeElement DevExpress.CodeParser.IAttributeElementCollection.Item { get; }
    public LiteAttributeElementCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IAttributeElementCollection.IndexOf(IAttributeElement e);
    private sealed virtual override IAttributeElement DevExpress.CodeParser.IAttributeElementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteCaseClauseCollection : NodeList {
    public CollectionType CollectionType { get; }
    private ICaseClauseStatement DevExpress.CodeParser.ICaseClauseCollection.Item { get; }
    public LiteCaseClauseCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ICaseClauseCollection.IndexOf(ICaseClauseStatement st);
    private sealed virtual override ICaseClauseStatement DevExpress.CodeParser.ICaseClauseCollection.Find(string name);
    private sealed virtual override ICaseClauseStatement DevExpress.CodeParser.ICaseClauseCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteCaseStatementCollection : NodeList {
    public CollectionType CollectionType { get; }
    private ICaseStatement DevExpress.CodeParser.ICaseStatementCollection.Item { get; }
    public LiteCaseStatementCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ICaseStatementCollection.IndexOf(ICaseStatement st);
    private sealed virtual override ICaseStatement DevExpress.CodeParser.ICaseStatementCollection.Find(string name);
    private sealed virtual override ICaseStatement DevExpress.CodeParser.ICaseStatementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteCssElementCollection : NodeList {
    public CollectionType CollectionType { get; }
    private ICssElement DevExpress.CodeParser.ICssElementCollection.Item { get; }
    public LiteCssElementCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ICssElementCollection.IndexOf(ICssElement e);
    private sealed virtual override ICssElement DevExpress.CodeParser.ICssElementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteCssExpressionCollection : NodeList {
    private CollectionType DevExpress.CodeParser.ISerializableCollection.CollectionType { get; }
    private ICssExpression DevExpress.CodeParser.ICssExpressionCollection.Item { get; }
    public LiteCssExpressionCollection(int capacity);
    protected virtual NodeList CreateInstance();
    private sealed virtual override CollectionType DevExpress.CodeParser.ISerializableCollection.get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ICssExpressionCollection.IndexOf(ICssExpression e);
    private sealed virtual override ICssExpression DevExpress.CodeParser.ICssExpressionCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteCssPropertyDeclarationCollection : NodeList {
    private CollectionType DevExpress.CodeParser.ISerializableCollection.CollectionType { get; }
    private ICssPropertyDeclaration DevExpress.CodeParser.ICssPropertyDeclarationCollection.Item { get; }
    public LiteCssPropertyDeclarationCollection(int capacity);
    protected virtual NodeList CreateInstance();
    private sealed virtual override CollectionType DevExpress.CodeParser.ISerializableCollection.get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ICssPropertyDeclarationCollection.IndexOf(ICssPropertyDeclaration e);
    private sealed virtual override ICssPropertyDeclaration DevExpress.CodeParser.ICssPropertyDeclarationCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteCssSelectorCollection : NodeList {
    private CollectionType DevExpress.CodeParser.ISerializableCollection.CollectionType { get; }
    private ICssSelector DevExpress.CodeParser.ICssSelectorCollection.Item { get; }
    public LiteCssSelectorCollection(int capacity);
    protected virtual NodeList CreateInstance();
    private sealed virtual override CollectionType DevExpress.CodeParser.ISerializableCollection.get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ICssSelectorCollection.IndexOf(ICssSelector e);
    private sealed virtual override ICssSelector DevExpress.CodeParser.ICssSelectorCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteCssTermCollection : NodeList {
    private CollectionType DevExpress.CodeParser.ISerializableCollection.CollectionType { get; }
    private ICssTerm DevExpress.CodeParser.ICssTermCollection.Item { get; }
    public LiteCssTermCollection(int capacity);
    protected virtual NodeList CreateInstance();
    private sealed virtual override CollectionType DevExpress.CodeParser.ISerializableCollection.get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ICssTermCollection.IndexOf(ICssTerm e);
    private sealed virtual override ICssTerm DevExpress.CodeParser.ICssTermCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteExpressionCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IExpression DevExpress.CodeParser.IExpressionCollection.Item { get; }
    public LiteExpressionCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IExpressionCollection.IndexOf(IExpression e);
    private sealed virtual override IExpression DevExpress.CodeParser.IExpressionCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteHtmlAttributeCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IHtmlAttribute DevExpress.CodeParser.IHtmlAttributeCollection.Item { get; }
    public LiteHtmlAttributeCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IHtmlAttributeCollection.IndexOf(IHtmlAttribute e);
    private sealed virtual override IHtmlAttribute DevExpress.CodeParser.IHtmlAttributeCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteJoinExpressionCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IJoinExpression DevExpress.CodeParser.IJoinExpressionCollection.Item { get; }
    public LiteJoinExpressionCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IJoinExpressionCollection.IndexOf(IJoinExpression e);
    private sealed virtual override IJoinExpression DevExpress.CodeParser.IJoinExpressionCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteMemberElementCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IMemberElement DevExpress.CodeParser.IMemberElementCollection.Item { get; }
    public LiteMemberElementCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    [IteratorStateMachineAttribute("DevExpress.CodeParser.LiteMemberElementCollection/<DevExpress-CodeParser-IMemberElementCollection-GetEnumerable>d__5")]
private sealed virtual override IEnumerable`1<IElement> DevExpress.CodeParser.IMemberElementCollection.GetEnumerable();
    private sealed virtual override int DevExpress.CodeParser.IMemberElementCollection.IndexOf(IMemberElement m);
    private sealed virtual override IMemberElement DevExpress.CodeParser.IMemberElementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteNamespaceElementCollection : NodeList {
    public CollectionType CollectionType { get; }
    private INamespaceElement DevExpress.CodeParser.INamespaceElementCollection.Item { get; }
    public LiteNamespaceElementCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.INamespaceElementCollection.IndexOf(INamespaceElement e);
    private sealed virtual override INamespaceElement DevExpress.CodeParser.INamespaceElementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteParameterElementCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IParameterElement DevExpress.CodeParser.IParameterElementCollection.Item { get; }
    public LiteParameterElementCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IParameterElementCollection.IndexOf(IParameterElement e);
    private sealed virtual override IParameterElement DevExpress.CodeParser.IParameterElementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteProjectElementCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IProjectElement DevExpress.CodeParser.IProjectElementCollection.Item { get; }
    public LiteProjectElementCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IProjectElementCollection.IndexOf(IProjectElement e);
    private sealed virtual override IProjectElement DevExpress.CodeParser.IProjectElementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteQueryIdentCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IQueryIdent DevExpress.CodeParser.IQueryIdentCollection.Item { get; }
    public LiteQueryIdentCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IQueryIdentCollection.IndexOf(IQueryIdent e);
    private sealed virtual override IQueryIdent DevExpress.CodeParser.IQueryIdentCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteSourceFileCollection : NodeList {
    public CollectionType CollectionType { get; }
    private ISourceFile DevExpress.CodeParser.ISourceFileCollection.Item { get; }
    public LiteSourceFileCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ISourceFileCollection.IndexOf(ISourceFile f);
    private sealed virtual override int DevExpress.CodeParser.ISourceFileCollection.IndexOf(string fileName);
    private sealed virtual override ISourceFile DevExpress.CodeParser.ISourceFileCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteTypeElementCollection : NodeList {
    public CollectionType CollectionType { get; }
    private ITypeElement DevExpress.CodeParser.ITypeElementCollection.Item { get; }
    public LiteTypeElementCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ITypeElementCollection.IndexOf(ITypeElement t);
    private sealed virtual override ITypeElement DevExpress.CodeParser.ITypeElementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteTypeParameterCollection : NodeList {
    public CollectionType CollectionType { get; }
    private ITypeParameter DevExpress.CodeParser.ITypeParameterCollection.Item { get; }
    public LiteTypeParameterCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ITypeParameterCollection.IndexOf(ITypeParameter t);
    private sealed virtual override ITypeParameter DevExpress.CodeParser.ITypeParameterCollection.Find(string name);
    private sealed virtual override ITypeParameter DevExpress.CodeParser.ITypeParameterCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteTypeParameterConstraintCollection : NodeList {
    public CollectionType CollectionType { get; }
    private ITypeParameterConstraint DevExpress.CodeParser.ITypeParameterConstraintCollection.Item { get; }
    public LiteTypeParameterConstraintCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ITypeParameterConstraintCollection.IndexOf(ITypeParameterConstraint t);
    private sealed virtual override ITypeParameterConstraint DevExpress.CodeParser.ITypeParameterConstraintCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteTypeReferenceExpressionCollection : NodeList {
    public CollectionType CollectionType { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeReferenceExpressionCollection.Item { get; }
    public LiteTypeReferenceExpressionCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ITypeReferenceExpressionCollection.IndexOf(ITypeReferenceExpression t);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeReferenceExpressionCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteVariableDeclarationStatementCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IVariableDeclarationStatement DevExpress.CodeParser.IVariableDeclarationStatementCollection.Item { get; }
    public LiteVariableDeclarationStatementCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IVariableDeclarationStatementCollection.IndexOf(IVariableDeclarationStatement t);
    private sealed virtual override IVariableDeclarationStatement DevExpress.CodeParser.IVariableDeclarationStatementCollection.Find(string name);
    private sealed virtual override IVariableDeclarationStatement DevExpress.CodeParser.IVariableDeclarationStatementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteXmlAttributeDeclarationCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IXmlAttributeDeclaration DevExpress.CodeParser.IXmlAttributeDeclarationCollection.Item { get; }
    public LiteXmlAttributeDeclarationCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IXmlAttributeDeclarationCollection.IndexOf(IXmlAttributeDeclaration e);
    private sealed virtual override IXmlAttributeDeclaration DevExpress.CodeParser.IXmlAttributeDeclarationCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LiteXmlContentParticleCollection : NodeList {
    public CollectionType CollectionType { get; }
    private IXmlContentParticle DevExpress.CodeParser.IXmlContentParticleCollection.Item { get; }
    public LiteXmlContentParticleCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.IXmlContentParticleCollection.IndexOf(IXmlContentParticle e);
    private sealed virtual override IXmlContentParticle DevExpress.CodeParser.IXmlContentParticleCollection.get_Item(int index);
}
public class DevExpress.CodeParser.LocalFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public virtual IElementCollection Apply(IElementCollection elements);
}
public class DevExpress.CodeParser.LocalNameFilter : object {
    private SourceRange _Range;
    public LocalNameFilter(SourceRange range);
    public sealed virtual bool Apply(IElement element);
    public sealed virtual bool SkipChildren(IElement element);
}
public class DevExpress.CodeParser.Lock : ParentToSingleStatement {
    private static int INT_MaintainanceComplexity;
    private Expression _Expression;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.ILockStatement.Expression { get; }
    public Lock(Expression expression);
    protected void SetExpression(Expression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.ILockStatement.get_Expression();
}
public class DevExpress.CodeParser.LogicalInversion : UnaryOperatorExpression {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public LogicalInversion(Token token, Expression expression);
    public LogicalInversion(Token token, Expression expression, bool isPost);
    public LogicalInversion(Expression expression);
    public LogicalInversion(Expression expression, bool isPost);
    protected virtual object EvaluateExpression();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.LogicalOperation : BinaryOperatorExpression {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public LogicalOperator LogicalOperator { get; public set; }
    private LogicalOperator DevExpress.CodeParser.ILogicalOperationExpression.LogicalOperator { get; }
    public LogicalOperation(Expression left, Token token, Expression right);
    public LogicalOperation(Expression left, Token token, Expression right, LogicalOperator op, SourceRange range);
    public LogicalOperation(Expression left, LogicalOperator op, Expression right);
    protected virtual object EvaluateExpression();
    protected virtual void SetLogicalOperator(LogicalOperator op);
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    private bool HasCondition(LanguageElement element);
    public virtual int GetCyclomaticComplexity();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public static BinaryOperatorType GetBinaryOperatorType(LogicalOperator op);
    public static LogicalOperator GetLogicalOperatorType(BinaryOperatorType op);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public LogicalOperator get_LogicalOperator();
    public void set_LogicalOperator(LogicalOperator value);
    private sealed virtual override LogicalOperator DevExpress.CodeParser.ILogicalOperationExpression.get_LogicalOperator();
}
public enum DevExpress.CodeParser.LogicalOperator : Enum {
    public byte value__;
    public static LogicalOperator None;
    public static LogicalOperator And;
    public static LogicalOperator Or;
    public static LogicalOperator ShortCircuitAnd;
    public static LogicalOperator ShortCircuitOr;
    public static LogicalOperator ExclusiveOr;
}
public class DevExpress.CodeParser.MacroExpressionCall : Expression {
    private Expression _Expession;
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    public MacroExpressionCall(string name);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
}
public class DevExpress.CodeParser.MacroInfo : object {
    private SourceRange _MacroFullRange;
    private SourceRange _MacroNameRange;
    private SourceRange _MacroDefinitionNameRange;
    private string _MacroDefinitionFilePath;
    private string _MacroExpansion;
    public SourceRange MacroDefinitionNameRange { get; public set; }
    public string MacroDefinitionFilePath { get; public set; }
    [ObsoleteAttribute("MacroFilePath is obsolete. Use MacroDefinitionFilePath instead.")]
public string MacroFilePath { get; public set; }
    public string MacroExpansion { get; public set; }
    public SourceRange MacroFullRange { get; public set; }
    public SourceRange MacroNameRange { get; public set; }
    public MacroInfo(SourceRange fullRange, string path);
    public SourceRange get_MacroDefinitionNameRange();
    public void set_MacroDefinitionNameRange(SourceRange value);
    public string get_MacroDefinitionFilePath();
    public void set_MacroDefinitionFilePath(string value);
    public string get_MacroFilePath();
    public void set_MacroFilePath(string value);
    public string get_MacroExpansion();
    public void set_MacroExpansion(string value);
    public SourceRange get_MacroFullRange();
    public void set_MacroFullRange(SourceRange value);
    public SourceRange get_MacroNameRange();
    public void set_MacroNameRange(SourceRange value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.MacroInfoCollection : DictionaryBase {
    private Hashtable _FullMacroRanges;
    private bool _SyncMacroRanges;
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public MacroInfo Item { get; public set; }
    public Hashtable FullMacroRanges { get; }
    private void UpdateFullMacroRanges();
    protected virtual void OnClear();
    protected virtual void OnInsert(object key, object value);
    protected virtual void OnRemove(object key, object value);
    public void Add(SourceRange keyRange, MacroInfo info);
    public void AddRange(IDictionary range);
    public bool ContainsKey(object key);
    public void Remove(SourceRange keyRange);
    public string GetExpansion(SourceRange keyRange);
    public ICollection get_Keys();
    public ICollection get_Values();
    public MacroInfo get_Item(SourceRange keyRange);
    public void set_Item(SourceRange keyRange, MacroInfo value);
    public bool ContainsFullRange(SourceRange range);
    public Hashtable get_FullMacroRanges();
}
public class DevExpress.CodeParser.ManagedArrayCreateExpression : ArrayCreateExpression {
    public LanguageElementType ElementType { get; }
    public ManagedArrayCreateExpression(TypeReferenceExpression type);
    public ManagedArrayCreateExpression(TypeReferenceExpression type, ExpressionCollection dimensions);
    public ManagedArrayCreateExpression(TypeReferenceExpression type, ExpressionCollection dimensions, ArrayInitializerExpression initializer);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ManagedClass : Class {
    public LanguageElementType ElementType { get; }
    public ManagedClass(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ManagedObjectCreationExpression : ObjectCreationExpression {
    private ExpressionCollection _Dimensions;
    private ArrayInitializerExpression _ArrayInitializers;
    private ArrayKindModifier _ArrayKind;
    public LanguageElementType ElementType { get; }
    public ArrayInitializerExpression ArrayInitializers { get; public set; }
    public ExpressionCollection Dimensions { get; public set; }
    public ArrayKindModifier ArrayKind { get; public set; }
    public ManagedObjectCreationExpression(TypeReferenceExpression type);
    public ManagedObjectCreationExpression(TypeReferenceExpression type, ExpressionCollection ctorArguments);
    public ManagedObjectCreationExpression(TypeReferenceExpression type, ExpressionCollection ctorArguments, ArrayInitializerExpression arrayinit);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public ArrayInitializerExpression get_ArrayInitializers();
    public void set_ArrayInitializers(ArrayInitializerExpression value);
    public ExpressionCollection get_Dimensions();
    public void set_Dimensions(ExpressionCollection value);
    public ArrayKindModifier get_ArrayKind();
    public void set_ArrayKind(ArrayKindModifier value);
}
public class DevExpress.CodeParser.ManagedStruct : Struct {
    public LanguageElementType ElementType { get; }
    public ManagedStruct(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.MarkupExtensionExpression : Expression {
    private SourceRange _NameRange;
    private ExpressionCollection _Arguments;
    private ExpressionCollection _Initializers;
    private Expression _Qualifier;
    public ExpressionCollection Arguments { get; }
    private IExpressionCollection DevExpress.CodeParser.IWithArguments.Args { get; }
    public int ArgumentCount { get; }
    public int InitializerCount { get; }
    public LanguageElementType ElementType { get; }
    public ExpressionCollection Initializers { get; }
    public SourceRange NameRange { get; public set; }
    public Expression Qualifier { get; public set; }
    private Expression DevExpress.CodeParser.IHasSource.Source { get; private set; }
    private IExpression DevExpress.CodeParser.IWithSource.Source { get; }
    private int DevExpress.CodeParser.IHasArguments.ArgumentsCount { get; }
    private IExpressionCollection DevExpress.CodeParser.IObjectInitializerExpression.Initializers { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public sealed virtual void AddArgument(Expression argument);
    public void AddInitializer(Expression initializer);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public sealed virtual ExpressionCollection get_Arguments();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IWithArguments.get_Args();
    public int get_ArgumentCount();
    public int get_InitializerCount();
    public virtual LanguageElementType get_ElementType();
    public ExpressionCollection get_Initializers();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public sealed virtual Expression get_Qualifier();
    public sealed virtual void set_Qualifier(Expression value);
    private sealed virtual override Expression DevExpress.CodeParser.IHasSource.get_Source();
    private sealed virtual override void DevExpress.CodeParser.IHasSource.set_Source(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IWithSource.get_Source();
    private sealed virtual override int DevExpress.CodeParser.IHasArguments.get_ArgumentsCount();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IObjectInitializerExpression.get_Initializers();
}
public class DevExpress.CodeParser.MasterDirective : PageDirective {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.Member : AccessSpecifiedElement {
    private string _Signature;
    private SourceRange _TypeRange;
    private string _MemberType;
    private TypeReferenceExpression _MemberTypeReference;
    private SourceRange _AsRange;
    private PostponedParsingData _PostponedData;
    private StringCollection _Implements;
    private ExpressionCollection _ImplementsExpressions;
    private ExpressionCollection _HandlesExpressions;
    private bool _IsExplicitInterfaceMember;
    private SourceRange _ConstRange;
    private bool _Unclosed;
    [EditorBrowsableAttribute("1")]
public bool Unclosed { get; public set; }
    protected PostponedParsingData PostponedData { get; protected set; }
    [DescriptionAttribute("The type of this member or method.")]
[CategoryAttribute("Details")]
[DefaultValueAttribute("")]
public string MemberType { get; public set; }
    [DescriptionAttribute("The type of this member or method.")]
[CategoryAttribute("Details")]
[DefaultValueAttribute("")]
public TypeReferenceExpression MemberTypeReference { get; public set; }
    [DescriptionAttribute("The SourceRange of this member type.")]
[CategoryAttribute("Details")]
public SourceRange TypeRange { get; public set; }
    [DescriptionAttribute("The signature of this member.")]
[CategoryAttribute("Details")]
public string Signature { get; }
    [DescriptionAttribute("Returns true if this member is explicitly declared interface member.")]
[CategoryAttribute("Details")]
public bool IsExplicitInterfaceMember { get; public set; }
    [CategoryAttribute("Details")]
public StringCollection Implements { get; }
    [CategoryAttribute("Details")]
public int ImplementsCount { get; }
    [CategoryAttribute("Details")]
public ExpressionCollection ImplementsExpressions { get; }
    [CategoryAttribute("Details")]
public ExpressionCollection HandlesExpressions { get; }
    public SourceRange ConstRange { get; public set; }
    public SourceRange AsRange { get; public set; }
    [DescriptionAttribute("True if the visibility of this member can not be changed (e.g., illegal, param, local, or if this is a static constructor).")]
[CategoryAttribute("Access")]
public bool VisibilityIsFixed { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.IHasType.Type { get; }
    public bool get_Unclosed();
    public void set_Unclosed(bool value);
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected string GetFullSignature();
    protected virtual string GetSignature();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    protected virtual IExpressionCollection GetImplementExpressions();
    public virtual int GetImageIndex();
    public virtual string GetTypeName();
    public void AddImplementsExpression(Expression expression);
    [EditorBrowsableAttribute("1")]
public string GetNameWithoutImplementsQualifier();
    [EditorBrowsableAttribute("1")]
public void RemoveImplementsExpression(Expression expression);
    [EditorBrowsableAttribute("1")]
public void AddHandlesExpression(Expression expression);
    [EditorBrowsableAttribute("1")]
public void RemoveHandlesExpression(Expression expression);
    [EditorBrowsableAttribute("1")]
public void SetMemberTypeReference(TypeReferenceExpression type);
    public virtual bool Is(string fullTypeName);
    public virtual bool Is(ITypeElement type);
    public virtual bool Is(Type type);
    public virtual bool Is(ISourceTreeResolver resolver, string fullTypeName);
    protected virtual PostponedParsingData get_PostponedData();
    protected virtual void set_PostponedData(PostponedParsingData value);
    public string get_MemberType();
    public void set_MemberType(string value);
    public TypeReferenceExpression get_MemberTypeReference();
    public void set_MemberTypeReference(TypeReferenceExpression value);
    public SourceRange get_TypeRange();
    public void set_TypeRange(SourceRange value);
    public string get_Signature();
    public virtual bool get_IsExplicitInterfaceMember();
    public virtual void set_IsExplicitInterfaceMember(bool value);
    public StringCollection get_Implements();
    public int get_ImplementsCount();
    public ExpressionCollection get_ImplementsExpressions();
    public ExpressionCollection get_HandlesExpressions();
    public SourceRange get_ConstRange();
    public void set_ConstRange(SourceRange value);
    public SourceRange get_AsRange();
    public void set_AsRange(SourceRange value);
    public virtual bool get_VisibilityIsFixed();
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.IHasType.get_Type();
    [EditorBrowsableAttribute("1")]
public virtual void SetAccessSpecifiers(AccessSpecifiers specifiers);
    private void CheckVisibilities();
}
public enum DevExpress.CodeParser.MemberAccesOperatorType : Enum {
    public int value__;
    public static MemberAccesOperatorType Default;
    public static MemberAccesOperatorType Nested;
    public static MemberAccesOperatorType Pointer;
}
public class DevExpress.CodeParser.MemberAccessExpression : Expression {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; }
    private IWithStatement DevExpress.CodeParser.IMemberAccessExpression.ParentWith { get; }
    public MemberAccessExpression(string name, SourceRange nameRange);
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    private sealed virtual override IWithStatement DevExpress.CodeParser.IMemberAccessExpression.get_ParentWith();
}
public abstract class DevExpress.CodeParser.MemberCodeGenBase : LanguageElementCodeGenBase {
    public MemberCodeGenBase(CodeGen codeGen);
    public virtual void GenerateElement(LanguageElement element);
    protected virtual void GenerateMultiVars(Variable var);
    protected virtual bool IsInitializer(LanguageElement element);
    protected virtual bool GenerateMember(Member member);
    protected abstract virtual void GenerateImplicitVariable(ImplicitVariable member);
    protected abstract virtual void GenerateExtensionMethodParam(ExtensionMethodParam member);
    protected abstract virtual void GenerateLambdaImplicitlyTypedParam(LambdaImplicitlyTypedParam member);
    protected abstract virtual void GenerateMethod(Method member);
    protected abstract virtual void GenerateMethodPrototype(MethodPrototype member);
    protected abstract virtual void GenerateEvent(Event member);
    protected abstract virtual void GenerateProperty(Property member);
    protected abstract virtual void GenerateDelegate(DelegateDefinition member);
    protected abstract virtual void GenerateConstVolatile(ConstVolatile member);
    protected abstract virtual void GenerateConst(Const member);
    protected abstract virtual void GenerateVolatile(Volatile member);
    protected abstract virtual void GenerateVariable(Variable member);
    protected abstract virtual void GenerateInitializedVolatile(InitializedVolatile member);
    protected abstract virtual void GenerateInitializedVariable(InitializedVariable member);
    protected abstract virtual void GenerateParameter(Param member);
    protected abstract virtual void GenerateEnumElement(EnumElement member);
    protected abstract virtual void GenerateQueryIdent(QueryIdent expression);
    public abstract virtual void GenerateTypeParameterConstraint(TypeParameterConstraint constraint);
    public abstract virtual void GenerateGenericModifier(GenericModifier generic);
    public abstract virtual void GenerateTypeParameter(TypeParameter parameter);
    public virtual void GenerateTypeParameterConstraints(GenericModifier generic, bool addLastNewLine);
    public virtual void GenerateTypeParameterConstraints(TypeParameterCollection collection, bool addLastNewLine);
    public virtual void GenerateTypeParameters(GenericModifier generic);
    public virtual bool IsMemberGenElement(LanguageElement element);
    public virtual void GenerateTypeParameterCollection(TypeParameterCollection collection);
    protected virtual void GenerateTypeParameterConstraintCollection(TypeParameterConstraintCollection constraints);
}
public class DevExpress.CodeParser.MemberElementCollection : NodeList {
    private IMemberElement DevExpress.CodeParser.IMemberElementCollection.Item { get; }
    protected virtual NodeList CreateInstance();
    [IteratorStateMachineAttribute("DevExpress.CodeParser.MemberElementCollection/<DevExpress-CodeParser-IMemberElementCollection-GetEnumerable>d__1")]
private sealed virtual override IEnumerable`1<IElement> DevExpress.CodeParser.IMemberElementCollection.GetEnumerable();
    private sealed virtual override int DevExpress.CodeParser.IMemberElementCollection.IndexOf(IMemberElement m);
    private sealed virtual override IMemberElement DevExpress.CodeParser.IMemberElementCollection.get_Item(int index);
}
public class DevExpress.CodeParser.MemberFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public static bool IsMember(IElement element);
}
public class DevExpress.CodeParser.MemberInitializerExpression : Expression {
    private Expression _Value;
    private SourceRange _NameRange;
    private bool _IsKey;
    public SourceRange NameRange { get; public set; }
    public Expression Value { get; public set; }
    public bool IsKey { get; public set; }
    public LanguageElementType ElementType { get; }
    private IExpression DevExpress.CodeParser.IMemberInitializerExpression.Value { get; }
    public MemberInitializerExpression(string name, Expression value);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool IsIdenticalTo(Expression expression);
    public void SetValue(Expression expression);
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public Expression get_Value();
    public void set_Value(Expression value);
    public bool get_IsKey();
    public void set_IsKey(bool value);
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IExpression DevExpress.CodeParser.IMemberInitializerExpression.get_Value();
}
[EditorBrowsableAttribute("1")]
public class DevExpress.CodeParser.MemberSignatureBuilder : object {
    private static char CHAR_AccentChar;
    private static char CHAR_Comma;
    private static char CHAR_Space;
    private static string STR_TypeSeparator;
    private static char CHAR_OpenParen;
    private static char CHAR_CloseParen;
    private static char CHAR_OpenSquareBracket;
    private static char CHAR_CloseSquareBracket;
    private static char CHAR_LessThan;
    private static char CHAR_GreaterThan;
    private static string STR_ConstructorName;
    private static string STR_DestructorName;
    private static string STR_DoubleColons;
    private static string STR_Reference;
    private static string STR_Void;
    private static bool ArrayIsNullOrEmpty(ICollection collection);
    private static bool MethodHasNoReturnType(IMethodElement method);
    private static void AppendType(StringBuilder builder, IHasType hasType);
    private static void AppendType(StringBuilder builder, IHasType hasType, bool addVoid);
    private static void AppendAccessorParameters(StringBuilder builder, IMemberElement member, IMethodElement accessor);
    private static void AppendParameters(StringBuilder builder, IParameterElementCollection parameters);
    private static bool IsActivatedGenericParameter(IParameterElement parameter);
    private static void AppendParameters(StringBuilder builder, IParameterElementCollection parameters, bool addSpaceSplitter);
    private static void AppendParameters(StringBuilder builder, IMethodElement method);
    private static void AppendParameters(StringBuilder builder, IMethodElement method, bool addSpaceSplitter);
    private static void AppendParameters(StringBuilder builder, IDelegateElement del);
    private static void AppendParentType(StringBuilder builder, IMemberElement member);
    private static string BuildSignaturePart(string baseName, ITypeParameterCollection typeParameters, bool buildGenerics);
    private static string BuildSignaturePart(string baseName, int paramsCount);
    private static string BuildSignaturePart(IMemberElement member, bool buildGenerics, String& name, Int32& nameIndex);
    private static bool CanContainAccessor(IMemberElement member);
    private static bool IsAccessor(IMethodElement method);
    private static string GetTypeSignature(ITypeElement type, bool buildGenerics, String& name, Int32& nameIndex);
    private static string GetDelegateSignature(IDelegateElement delegateElement, bool buildGenerics, String& name, Int32& nameIndex);
    private static string GetMethodSignature(IMethodElement method, bool buildGenerics, String& name, Int32& nameIndex);
    private static string GetPropertySignature(IPropertyElement property, String& name, Int32& nameIndex);
    private static string GetEventSignature(IEventElement eventElement, String& name, Int32& nameIndex);
    public static string GetSignature(IMemberElement member);
    [EditorBrowsableAttribute("1")]
public static string GetSignature(IMemberElement member, bool buildGenerics, String& name, Int32& nameIndex);
    internal static string GetSignatureForXmlDocumentation(IMemberElement member, bool buildGenerics, String& name, Int32& nameIndex);
}
public enum DevExpress.CodeParser.MemberVisibility : Enum {
    public byte value__;
    public static MemberVisibility Illegal;
    public static MemberVisibility Local;
    public static MemberVisibility Param;
    public static MemberVisibility Private;
    public static MemberVisibility Protected;
    public static MemberVisibility ProtectedInternal;
    public static MemberVisibility Internal;
    public static MemberVisibility Public;
    public static MemberVisibility Published;
    public static MemberVisibility Friend;
    public static MemberVisibility ProtectedFriend;
}
public class DevExpress.CodeParser.MemberVisibilityFilter : ElementFilterBase {
    private IEnumerable`1<MemberVisibility> _Visibilities;
    public MemberVisibilityFilter(MemberVisibility visibility);
    public MemberVisibilityFilter(IEnumerable`1<MemberVisibility> visibilities);
    private bool VisibilityMatches(IElement element);
    public virtual bool Apply(IElement element);
}
public class DevExpress.CodeParser.MemberVisibilitySpecifier : CodeElement {
    private MemberVisibility _MemberVisibility;
    public LanguageElementType ElementType { get; }
    public MemberVisibility MemberVisibility { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public MemberVisibility get_MemberVisibility();
    public void set_MemberVisibility(MemberVisibility value);
}
public enum DevExpress.CodeParser.MemberVisibilityType : Enum {
    public int value__;
    public static MemberVisibilityType Public;
    public static MemberVisibilityType Private;
    public static MemberVisibilityType Protected;
}
public abstract class DevExpress.CodeParser.MemberWithParameters : Member {
    private LanguageElementCollection _Parameters;
    private TextRangeWrapper _ParensRange;
    [DescriptionAttribute("The parameters to this element.")]
[CategoryAttribute("Details")]
public LanguageElementCollection Parameters { get; }
    [DescriptionAttribute("The number of parameters declared by this element.")]
[CategoryAttribute("Details")]
public int ParameterCount { get; }
    public IEnumerable AllParameters { get; }
    public SourceRange ParensRange { get; }
    private IParameterElementCollection DevExpress.CodeParser.IWithParameters.Parameters { get; }
    private void AddAttributeSections();
    private void AddAttributeSections(Param param, NodeList nodeList);
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.AddParameter(IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.RemoveParameter(IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.InsertParameter(int index, IParameterElement parameter);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    [EditorBrowsableAttribute("1")]
public void SetParameters(LanguageElementCollection parameters);
    public Param GetParameter(string name);
    public Param GetParameter(int index);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(Token parenOpen, Token parenClose);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(SourceRange range);
    public void AddParameter(Param parameter);
    public void AddParameters(LanguageElementCollection parameters);
    public void RemoveParameter(Param parameter);
    public void RemoveParameters(LanguageElementCollection parameters);
    public void InsertParameter(int index, Param parameter);
    public sealed virtual LanguageElementCollection get_Parameters();
    public sealed virtual int get_ParameterCount();
    public IEnumerable get_AllParameters();
    public sealed virtual SourceRange get_ParensRange();
    private sealed virtual override IParameterElementCollection DevExpress.CodeParser.IWithParameters.get_Parameters();
}
internal class DevExpress.CodeParser.MemoryHelper : object {
    private static int INT_ObjectHeaderSize;
    private static int INT_ReferenceSize;
    private static int INT_Byte;
    private static int INT_SByte;
    private static int INT_Int16;
    private static int INT_UInt16;
    private static int INT_Int32;
    private static int INT_UInt32;
    private static int INT_Int64;
    private static int INT_UInt64;
    private static int INT_Char;
    private static int INT_Single;
    private static int INT_Double;
    private static int INT_Decimal;
    private static int INT_Boolean;
    private static int INT_SourcePoint;
    private static int INT_SourceRange;
    private static string STR_Byte;
    private static string STR_SByte;
    private static string STR_Int16;
    private static string STR_UInt16;
    private static string STR_Int32;
    private static string STR_UInt32;
    private static string STR_Int64;
    private static string STR_UInt64;
    private static string STR_Char;
    private static string STR_Single;
    private static string STR_Double;
    private static string STR_Decimal;
    private static string STR_String;
    private static string STR_Boolean;
    private static string STR_SourcePoint;
    private static string STR_SourceRange;
    private static long GetFieldSize(object instance, FieldInfo field);
    public static long SizeOf(object instance);
}
public class DevExpress.CodeParser.Method : MemberWithParameters {
    private static int INT_MaintainanceComplexity;
    private BaseVariable _ImplicitVariable;
    private TypeReferenceExpressionCollection _ExceptionSpecification;
    private MethodTypeEnum _MethodType;
    private MethodFlags _MethodFlags;
    private string _CharsetModifier;
    private StringCollection _Handles;
    private bool _MethodHasTryBlock;
    private bool _IsConst;
    private bool _IsMemberFunctionConst;
    private CallingConventionSpecifier _CallingConvention;
    private OperatorType _OverloadsOperator;
    private bool _GenerateCodeBlock;
    private string _Lib;
    private string _Alias;
    private SourceRange _ParamOpenRange;
    private SourceRange _ParamCloseRange;
    private SourceRange _MethodKeyWordRange;
    public bool IsSerializationConstructor { get; }
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public StringCollection Handles { get; }
    public int HandlesCount { get; }
    [DescriptionAttribute("Returns true if this method is constructor.")]
[CategoryAttribute("Details")]
public bool IsConstructor { get; public set; }
    [DescriptionAttribute("Returns true if this method is destructor.")]
[CategoryAttribute("Details")]
public bool IsDestructor { get; public set; }
    [DescriptionAttribute("Returns true if this method is finalizer.")]
[CategoryAttribute("Details")]
public bool IsFinalizer { get; public set; }
    [DescriptionAttribute("Returns true if this method is operator override.")]
[CategoryAttribute("Details")]
public bool IsClassOperator { get; public set; }
    [DescriptionAttribute("Returns true if this method defines implicit type cast.")]
[CategoryAttribute("Details")]
public bool IsImplicitCast { get; public set; }
    [DescriptionAttribute("Returns true if this method defines explicit type cast.")]
[CategoryAttribute("Details")]
public bool IsExplicitCast { get; public set; }
    public bool IsConst { get; public set; }
    public CallingConventionSpecifier CallingConvention { get; public set; }
    public TypeReferenceExpressionCollection ExceptionSpecification { get; public set; }
    public bool MethodHasTryBlock { get; public set; }
    public bool IsMemberFunctionConst { get; public set; }
    [ObsoleteAttribute("Use IsExplicitInterfaceMember instead.")]
[EditorBrowsableAttribute("1")]
public bool IsExplicitInterfaceMethod { get; public set; }
    public MemberVisibility[] ValidVisibilities { get; }
    [DescriptionAttribute("True if the visibility of this member can not be changed (e.g., illegal, param, local, or if this is a static constructor).")]
[CategoryAttribute("Access")]
public bool VisibilityIsFixed { get; }
    public OperatorType OverloadsOperator { get; public set; }
    [DescriptionAttribute("Returns char set modifier set for this method.")]
[CategoryAttribute("Details")]
public string CharsetModifier { get; public set; }
    [DescriptionAttribute("The type of this method (e.g., Constructor, Destructor, Function, or Void).")]
[CategoryAttribute("Details")]
public MethodTypeEnum MethodType { get; public set; }
    public SourceRange ParamOpenRange { get; public set; }
    public SourceRange ParamCloseRange { get; public set; }
    public SourceRange MethodKeyWordRange { get; }
    public ConstructorInitializer Initializer { get; }
    public bool HasInitializer { get; }
    public BaseVariable ImplicitVariable { get; public set; }
    public bool GenerateCodeBlock { get; public set; }
    public bool HasImplicitVariable { get; }
    public bool CanContainCode { get; }
    public bool IsNewContext { get; }
    public string Lib { get; public set; }
    public string Alias { get; public set; }
    public bool IsWebMethod { get; }
    public bool HasDllImportAttribute { get; }
    private IExpressionCollection DevExpress.CodeParser.IMethodElement.HandlesExpressions { get; }
    private IExpressionCollection DevExpress.CodeParser.IMethodElement.ImplementsExpressions { get; }
    private string DevExpress.CodeParser.IMethodElement.Alias { get; }
    private string DevExpress.CodeParser.IMethodElement.Lib { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsConstructor { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsDestructor { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsTypeInitializer { get; }
    private IBaseVariable DevExpress.CodeParser.IMethodElement.ImplicitVariable { get; }
    [DescriptionAttribute("True if this method has async modifier.")]
[CategoryAttribute("Access")]
[DefaultValueAttribute("False")]
public bool IsAsynchronous { get; public set; }
    public Method(string name);
    public Method(string type, string name);
    private bool NeedToBackOut(LanguageElement element);
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual int GetCyclomaticComplexity();
    public virtual bool RangeIsClean(SourceRange sourceRange);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected bool FlagIsSet(MethodFlags flag);
    protected void SetFlagValue(MethodFlags flag, bool value);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public Method CreateMethod();
    public MethodPrototype CreateMethodPrototype();
    public AnonymousMethodExpression CreateAnonymousMethod();
    public bool IsEventHandler();
    public sealed virtual bool IsMainProcedure();
    public sealed virtual bool IsInitializeComponent();
    public sealed virtual bool get_IsSerializationConstructor();
    private bool ContainsFlag(MethodCharacteristics options, MethodCharacteristics flag);
    private bool CheckInteriorPtrPointer();
    private bool CheckPinPtrPointer();
    private bool ContainsMethod(ITypeElement baseType, Method method);
    private bool CheckInterfaceImplementor();
    private bool CheckInClass();
    private bool CheckInStruct();
    private bool CheckInModule();
    private bool CheckInInterface();
    [EditorBrowsableAttribute("1")]
public bool HasCharacteristics(MethodCharacteristics options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public StringCollection get_Handles();
    public int get_HandlesCount();
    public bool get_IsConstructor();
    public void set_IsConstructor(bool value);
    public bool get_IsDestructor();
    public void set_IsDestructor(bool value);
    public bool get_IsFinalizer();
    public void set_IsFinalizer(bool value);
    public sealed virtual bool get_IsClassOperator();
    public void set_IsClassOperator(bool value);
    public sealed virtual bool get_IsImplicitCast();
    public void set_IsImplicitCast(bool value);
    public sealed virtual bool get_IsExplicitCast();
    public void set_IsExplicitCast(bool value);
    public virtual bool get_IsConst();
    public virtual void set_IsConst(bool value);
    public CallingConventionSpecifier get_CallingConvention();
    public void set_CallingConvention(CallingConventionSpecifier value);
    public TypeReferenceExpressionCollection get_ExceptionSpecification();
    public void set_ExceptionSpecification(TypeReferenceExpressionCollection value);
    public bool get_MethodHasTryBlock();
    public void set_MethodHasTryBlock(bool value);
    public sealed virtual bool get_IsMemberFunctionConst();
    public void set_IsMemberFunctionConst(bool value);
    public bool get_IsExplicitInterfaceMethod();
    public void set_IsExplicitInterfaceMethod(bool value);
    public virtual MemberVisibility[] get_ValidVisibilities();
    public virtual bool get_VisibilityIsFixed();
    public OperatorType get_OverloadsOperator();
    public void set_OverloadsOperator(OperatorType value);
    public string get_CharsetModifier();
    public void set_CharsetModifier(string value);
    public sealed virtual MethodTypeEnum get_MethodType();
    public void set_MethodType(MethodTypeEnum value);
    public SourceRange get_ParamOpenRange();
    public void set_ParamOpenRange(SourceRange value);
    public SourceRange get_ParamCloseRange();
    public void set_ParamCloseRange(SourceRange value);
    public void SetAsRange(SourceRange range);
    public void SetMethodKeyWordRange(SourceRange range);
    public SourceRange get_MethodKeyWordRange();
    public ConstructorInitializer get_Initializer();
    public bool get_HasInitializer();
    public BaseVariable get_ImplicitVariable();
    public void set_ImplicitVariable(BaseVariable value);
    public bool get_GenerateCodeBlock();
    public void set_GenerateCodeBlock(bool value);
    public sealed virtual bool get_HasImplicitVariable();
    public virtual bool get_CanContainCode();
    public virtual bool get_IsNewContext();
    public string get_Lib();
    public void set_Lib(string value);
    public string get_Alias();
    public void set_Alias(string value);
    public sealed virtual bool get_IsWebMethod();
    public bool get_HasDllImportAttribute();
    public static bool CheckExtensionMethod(IMethodElement method);
    public static bool CheckExtensionMethod(ISourceTreeResolver resolver, IMethodElement method);
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsExtensionMethod();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsExtensionMethod(ISourceTreeResolver resolver);
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMethodElement.get_HandlesExpressions();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMethodElement.get_ImplementsExpressions();
    private sealed virtual override string DevExpress.CodeParser.IMethodElement.get_Alias();
    private sealed virtual override string DevExpress.CodeParser.IMethodElement.get_Lib();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsConstructor();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsDestructor();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsTypeInitializer();
    private sealed virtual override IBaseVariable DevExpress.CodeParser.IMethodElement.get_ImplicitVariable();
    public sealed virtual bool get_IsAsynchronous();
    public void set_IsAsynchronous(bool value);
    private sealed virtual override void DevExpress.CodeParser.IMethodElementModifier.SetIsClassOperator(bool isClassOperator);
    private sealed virtual override void DevExpress.CodeParser.IMethodElementModifier.SetIsExplicitCast(bool isExplicitCast);
    private sealed virtual override void DevExpress.CodeParser.IMethodElementModifier.SetIsImplicitCast(bool isImplicitCast);
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
}
public class DevExpress.CodeParser.MethodCall : Statement {
    private Expression _Source;
    private ExpressionCollection _Arguments;
    private bool _IsBaseConstructorCall;
    private TextRangeWrapper _ParensRange;
    private TextRange _NameRange;
    public LanguageElementType ElementType { get; }
    public Expression Qualifier { get; public set; }
    [ObsoleteAttribute("Use Qualifier instead")]
[EditorBrowsableAttribute("1")]
public Expression Source { get; public set; }
    public SourceRange NameRange { get; }
    public ExpressionCollection Arguments { get; public set; }
    [DescriptionAttribute("Returns true if this method is call to base construtor.")]
[CategoryAttribute("Details")]
public bool IsBaseConstructorCall { get; public set; }
    public bool IsGeneric { get; }
    public TypeReferenceExpressionCollection TypeArguments { get; }
    private IExpressionCollection DevExpress.CodeParser.IMethodCallStatement.Arguments { get; }
    private IExpressionCollection DevExpress.CodeParser.IWithArguments.Args { get; }
    private ITypeReferenceExpressionCollection DevExpress.CodeParser.IGenericExpression.TypeArguments { get; }
    private int DevExpress.CodeParser.IGenericExpression.TypeArity { get; }
    private IExpression DevExpress.CodeParser.IWithSource.Source { get; }
    public SourceRange ParensRange { get; }
    private ExpressionCollection DevExpress.CodeParser.IHasArguments.Arguments { get; }
    public int ArgumentsCount { get; }
    public MethodCall(Expression source);
    protected void SetQualifier(Expression expression);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual string GetDetailNodeDescription(int index);
    public static MethodCall FromMethodCallExpression(MethodCallExpression expression);
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected void SetArguments(ExpressionCollection arguments);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(Token parenOpen, Token parenClose);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(SourceRange range);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual Expression get_Qualifier();
    public sealed virtual void set_Qualifier(Expression value);
    public sealed virtual Expression get_Source();
    public sealed virtual void set_Source(Expression value);
    public virtual SourceRange get_NameRange();
    public ExpressionCollection get_Arguments();
    public void set_Arguments(ExpressionCollection value);
    public bool get_IsBaseConstructorCall();
    public void set_IsBaseConstructorCall(bool value);
    public sealed virtual bool get_IsGeneric();
    public TypeReferenceExpressionCollection get_TypeArguments();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMethodCallStatement.get_Arguments();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IWithArguments.get_Args();
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.AddArgument(IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.InsertArgument(int index, IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.RemoveArgument(IExpression argument);
    private sealed virtual override ITypeReferenceExpressionCollection DevExpress.CodeParser.IGenericExpression.get_TypeArguments();
    private sealed virtual override int DevExpress.CodeParser.IGenericExpression.get_TypeArity();
    private sealed virtual override IExpression DevExpress.CodeParser.IWithSource.get_Source();
    public sealed virtual SourceRange get_ParensRange();
    private sealed virtual override ExpressionCollection DevExpress.CodeParser.IHasArguments.get_Arguments();
    public sealed virtual void AddArgument(Expression arg);
    public void RemoveArgument(Expression arg);
    public void InsertArgument(int index, Expression arg);
    public sealed virtual int get_ArgumentsCount();
}
public class DevExpress.CodeParser.MethodCallExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _Source;
    private ExpressionCollection _Arguments;
    private TextRange _NameRange;
    private TextRangeWrapper _ParensRange;
    private bool _IsBaseConstructorCall;
    protected int ThisMaintenanceComplexity { get; }
    [DescriptionAttribute("Returns true if this method is call to base construtor.")]
[CategoryAttribute("Details")]
public bool IsBaseConstructorCall { get; public set; }
    public bool NeedsInvertParens { get; }
    public LanguageElementType ElementType { get; }
    public Expression Qualifier { get; public set; }
    [ObsoleteAttribute("Use Qualifier instead")]
[EditorBrowsableAttribute("1")]
public Expression Source { get; public set; }
    public ExpressionCollection Arguments { get; public set; }
    public bool CanBeStatement { get; }
    public SourceRange NameRange { get; }
    public bool IsGeneric { get; }
    public TypeReferenceExpressionCollection TypeArguments { get; }
    private IExpressionCollection DevExpress.CodeParser.IMethodCallExpression.Arguments { get; }
    private IExpressionCollection DevExpress.CodeParser.IWithArguments.Args { get; }
    private ITypeReferenceExpressionCollection DevExpress.CodeParser.IGenericExpression.TypeArguments { get; }
    private int DevExpress.CodeParser.IGenericExpression.TypeArity { get; }
    private IExpression DevExpress.CodeParser.IWithSource.Source { get; }
    public SourceRange ParensRange { get; }
    private ExpressionCollection DevExpress.CodeParser.IHasArguments.Arguments { get; }
    public int ArgumentsCount { get; }
    public MethodCallExpression(Expression source);
    private bool ComareArguments(MethodCallExpression expression);
    private void SetSource(Expression source);
    private void SetArguments(ExpressionCollection arguments);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(Token parenOpen, Token parenClose);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(SourceRange range);
    public sealed virtual void AddArgument(Expression arg);
    public void AddArguments(IEnumerable`1<Expression> arguments);
    public void RemoveArgument(Expression arg);
    public void InsertArgument(int index, Expression arg);
    protected virtual int get_ThisMaintenanceComplexity();
    public bool get_IsBaseConstructorCall();
    public void set_IsBaseConstructorCall(bool value);
    public virtual bool get_NeedsInvertParens();
    public virtual LanguageElementType get_ElementType();
    public sealed virtual Expression get_Qualifier();
    public sealed virtual void set_Qualifier(Expression value);
    public sealed virtual Expression get_Source();
    public sealed virtual void set_Source(Expression value);
    public ExpressionCollection get_Arguments();
    public void set_Arguments(ExpressionCollection value);
    public virtual bool get_CanBeStatement();
    public virtual SourceRange get_NameRange();
    public sealed virtual bool get_IsGeneric();
    public TypeReferenceExpressionCollection get_TypeArguments();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMethodCallExpression.get_Arguments();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IWithArguments.get_Args();
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.AddArgument(IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.InsertArgument(int index, IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.RemoveArgument(IExpression argument);
    private sealed virtual override ITypeReferenceExpressionCollection DevExpress.CodeParser.IGenericExpression.get_TypeArguments();
    private sealed virtual override int DevExpress.CodeParser.IGenericExpression.get_TypeArity();
    private sealed virtual override IExpression DevExpress.CodeParser.IWithSource.get_Source();
    public sealed virtual SourceRange get_ParensRange();
    private sealed virtual override ExpressionCollection DevExpress.CodeParser.IHasArguments.get_Arguments();
    public sealed virtual int get_ArgumentsCount();
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum DevExpress.CodeParser.MethodCharacteristics : Enum {
    public int value__;
    public static MethodCharacteristics Abstract;
    public static MethodCharacteristics Virtual;
    public static MethodCharacteristics Override;
    public static MethodCharacteristics New;
    public static MethodCharacteristics Extern;
    public static MethodCharacteristics ClassOperator;
    public static MethodCharacteristics MainProcedure;
    public static MethodCharacteristics PinPtrPointer;
    public static MethodCharacteristics InteriorPtrPointer;
    public static MethodCharacteristics Generic;
    public static MethodCharacteristics InterfaceImplementer;
    public static MethodCharacteristics EventHandler;
    public static MethodCharacteristics InClass;
    public static MethodCharacteristics InStruct;
    public static MethodCharacteristics InModule;
    public static MethodCharacteristics InInterface;
    public static MethodCharacteristics IsExtensionMethod;
    public static MethodCharacteristics IsWebMethod;
}
public class DevExpress.CodeParser.MethodFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public virtual IElementCollection Apply(IElementCollection elements);
}
[FlagsAttribute]
public enum DevExpress.CodeParser.MethodFlags : Enum {
    public byte value__;
    public static MethodFlags None;
    public static MethodFlags IsClassOperator;
    public static MethodFlags IsImplicitCast;
    public static MethodFlags IsExplicitCast;
}
public class DevExpress.CodeParser.MethodPrototype : Method {
    public LanguageElementType ElementType { get; }
    public MethodPrototype(string type, string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
}
public class DevExpress.CodeParser.MethodReferenceExpression : ReferenceExpressionBase {
    private static int INT_MaintainanceComplexity;
    private Expression _Source;
    private TextRange _NameRange;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Qualifier { get; public set; }
    public SourceRange NameRange { get; }
    public MethodReferenceExpression(string name);
    public MethodReferenceExpression(string name, SourceRange namerange);
    public MethodReferenceExpression(Expression source, string name);
    public MethodReferenceExpression(Expression source, string name, SourceRange namerange);
    private void SetSource(Expression source);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual Expression get_Qualifier();
    public virtual void set_Qualifier(Expression value);
    public virtual SourceRange get_NameRange();
}
public enum DevExpress.CodeParser.MethodTypeEnum : Enum {
    public byte value__;
    public static MethodTypeEnum Constructor;
    public static MethodTypeEnum Destructor;
    public static MethodTypeEnum Function;
    public static MethodTypeEnum Void;
    public static MethodTypeEnum Property;
    public static MethodTypeEnum Event;
    public static MethodTypeEnum Finalizer;
}
public class DevExpress.CodeParser.Module : TypeDeclaration {
    protected int ModuleToken;
    public LanguageElementType ElementType { get; }
    public bool IsNewContext { get; }
    public bool IsStatic { get; public set; }
    public Module(string name);
    public Module(string name, LanguageElementCollection block);
    public Module(string name, SourceRange nameRange, LanguageElementCollection block, SourceRange range);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual MemberVisibility[] GetValidVisibilities();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_IsNewContext();
    public virtual bool get_IsStatic();
    public virtual void set_IsStatic(bool value);
}
public class DevExpress.CodeParser.MyClassExpression : ThisReferenceExpression {
    public LanguageElementType ElementType { get; }
    public MyClassExpression(string name);
    public MyClassExpression(string name, SourceRange range);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.NamedAtgElement : BaseAtgElement {
    private SourceRange _NameRange;
    public SourceRange NameRange { get; public set; }
    protected virtual void UpdateRanges();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
}
public class DevExpress.CodeParser.NamedTemplateParameter : TemplateParameter {
    public LanguageElementType ElementType { get; }
    private TypeParameterDirection DevExpress.CodeParser.ITypeParameter.Direction { get; }
    public NamedTemplateParameter(string name, Expression defaultValue);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override TypeParameterDirection DevExpress.CodeParser.ITypeParameter.get_Direction();
}
public class DevExpress.CodeParser.NamedTypeParameterConstraint : TypeParameterConstraint {
    private TypeReferenceExpression _TypeReference;
    public LanguageElementType ElementType { get; }
    public TypeReferenceExpression TypeReference { get; public set; }
    private ITypeReferenceExpression DevExpress.CodeParser.INamedTypeParameterConstraint.TypeReference { get; }
    public NamedTypeParameterConstraint(TypeReferenceExpression typeReference);
    private void GetTypeReferenceFromDetailNodes();
    protected virtual void SetTypeReference(TypeReferenceExpression typeReference);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual void CleanUpOwnedReferences();
    public virtual LanguageElementType get_ElementType();
    public TypeReferenceExpression get_TypeReference();
    public void set_TypeReference(TypeReferenceExpression value);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.INamedTypeParameterConstraint.get_TypeReference();
}
public class DevExpress.CodeParser.Namespace : DelimiterCapableBlock {
    private TextRange _NameRange;
    private string _FullName;
    private IDocument _ParentDocument;
    private bool _HasEndingSemicolon;
    public string PathSegment { get; }
    public string FullName { get; }
    public LanguageElementType ElementType { get; }
    public bool DeclaresIdentifier { get; }
    public bool IsNewContext { get; }
    public SourceRange NameRange { get; public set; }
    public IEnumerable AllNamespaces { get; }
    public IEnumerable AllTypes { get; }
    public bool HasEndingSemicolon { get; public set; }
    private INamespaceElementCollection DevExpress.CodeParser.INamespaceElement.Namespaces { get; }
    private ITypeElementCollection DevExpress.CodeParser.INamespaceElement.Types { get; }
    public Namespace(string name);
    public Namespace(IDocument document);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual int GetImageIndex();
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual MemberVisibility[] GetValidVisibilities();
    public virtual string get_PathSegment();
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public void SetNamespaceCollection(NamespaceCollection namespaceCollection);
    public virtual void CleanUpOwnedReferences();
    public virtual string get_FullName();
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_DeclaresIdentifier();
    public virtual bool get_IsNewContext();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public IEnumerable get_AllNamespaces();
    public IEnumerable get_AllTypes();
    public bool get_HasEndingSemicolon();
    public void set_HasEndingSemicolon(bool value);
    private sealed virtual override INamespaceElementCollection DevExpress.CodeParser.INamespaceElement.get_Namespaces();
    private sealed virtual override ITypeElementCollection DevExpress.CodeParser.INamespaceElement.get_Types();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.NamespaceCollection : LanguageElementCollectionBase {
    private string _FullName;
    public Namespace Item { get; public set; }
    public string FullName { get; }
    public NamespaceCollection(string fullName);
    private void ClearMemberReferencesToThis();
    protected virtual void OnClear();
    protected NamespaceCollection CreateInstance();
    protected void CloneElements(NamespaceCollection target, ElementCloneOptions options);
    public int Add(Namespace aNamespace);
    public void Remove(Namespace aNamespace);
    public int IndexOf(Namespace aNamespace);
    public void Insert(int index, Namespace aNamespace);
    public Namespace Find(Namespace aNamespace);
    public bool Contains(Namespace aNamespace);
    public NamespaceCollection DeepClone();
    public NamespaceCollection DeepClone(ElementCloneOptions options);
    public Namespace get_Item(int index);
    public void set_Item(int index, Namespace value);
    public string get_FullName();
}
public class DevExpress.CodeParser.NamespaceFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
}
public abstract class DevExpress.CodeParser.NamespaceGenBase : LanguageElementCodeGenBase {
    public NamespaceGenBase(CodeGen codeGen);
    protected abstract virtual void GenerateNamespace(Namespace element);
    public virtual void GenerateElement(LanguageElement languageElement);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public class DevExpress.CodeParser.NamespaceReference : CodeElement {
    private static int INT_MaintainanceComplexity;
    private TextRange _NameRange;
    private TextRange _AliasNameRange;
    private bool _IsAlias;
    private string _AliasName;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; public set; }
    [DescriptionAttribute("The name of the namespace (or potentially the class in the VB Imports statement) that this language element alias points to.")]
[CategoryAttribute("Details")]
[DefaultValueAttribute("")]
public string AliasName { get; public set; }
    [DescriptionAttribute("Gets or sets source range if the alias name.")]
[CategoryAttribute("Details")]
public SourceRange AliasNameRange { get; public set; }
    [DescriptionAttribute("True if this Using or Imports statement is an alias.")]
[CategoryAttribute("Details")]
[DefaultValueAttribute("False")]
public bool IsAlias { get; public set; }
    public Expression AliasExpression { get; }
    private IExpression DevExpress.CodeParser.INamespaceReference.NameExpression { get; }
    private IExpression DevExpress.CodeParser.INamespaceReference.Expression { get; }
    public NamespaceReference(string nameSpace);
    public NamespaceReference(string aliasName, string nameSpace);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public string get_AliasName();
    public void set_AliasName(string value);
    public SourceRange get_AliasNameRange();
    public void set_AliasNameRange(SourceRange value);
    public sealed virtual bool get_IsAlias();
    public void set_IsAlias(bool value);
    public Expression get_AliasExpression();
    private sealed virtual override IExpression DevExpress.CodeParser.INamespaceReference.get_NameExpression();
    private sealed virtual override IExpression DevExpress.CodeParser.INamespaceReference.get_Expression();
}
public abstract class DevExpress.CodeParser.NamespaceReferenceGenBase : LanguageElementCodeGenBase {
    public NamespaceReferenceGenBase(CodeGen codeGen);
    protected abstract virtual void GenerateExternAlias(ExternAlias element);
    protected abstract virtual void GenerateNamespaceReference(NamespaceReference element);
    protected virtual void GenerateXmlNamespaceReference(XmlNamespaceReference element);
    public virtual void GenerateElement(LanguageElement languageElement);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public class DevExpress.CodeParser.NestedMethod : Block {
    public LanguageElementType ElementType { get; }
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.NestedTemplateParameter : TemplateParameter {
    private LanguageElementCollection _Parameters;
    public LanguageElementType ElementType { get; }
    public LanguageElementCollection Parameters { get; public set; }
    public int ParametersCount { get; }
    private IElementCollection DevExpress.CodeParser.INestedTemplateParameter.Parameters { get; }
    public NestedTemplateParameter(string name, Expression defaultValue, LanguageElementCollection parameters);
    public virtual string ToString();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public LanguageElementCollection get_Parameters();
    public void set_Parameters(LanguageElementCollection value);
    public int get_ParametersCount();
    private sealed virtual override IElementCollection DevExpress.CodeParser.INestedTemplateParameter.get_Parameters();
}
public abstract class DevExpress.CodeParser.NewExternalIDLink : BaseXmlNode {
}
public class DevExpress.CodeParser.NewExternalIDPublicLink : NewExternalIDLink {
    private string _SystemURI;
    private string _PublicID;
    public XmlNodeType XmlNodeType { get; }
    public string SystemURI { get; public set; }
    public string PublicID { get; public set; }
    public virtual XmlNodeType get_XmlNodeType();
    public string get_SystemURI();
    public void set_SystemURI(string value);
    public string get_PublicID();
    public void set_PublicID(string value);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.NewExternalIDSystemLink : NewExternalIDLink {
    private string _SystemURI;
    public XmlNodeType XmlNodeType { get; }
    public string SystemURI { get; public set; }
    public virtual XmlNodeType get_XmlNodeType();
    public string get_SystemURI();
    public void set_SystemURI(string value);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.NewTypeParameterConstraint : TypeParameterConstraint {
    public LanguageElementType ElementType { get; }
    public NewTypeParameterConstraint(string name, SourceRange range);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.NodeList : object {
    private int _Size;
    private object _Object;
    private Object[] _Items;
    public static NodeList Empty;
    private bool IsSingleValue { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public int Count { get; }
    public object Item { get; public set; }
    public object SyncRoot { get; }
    public NodeList(int capacity);
    private static NodeList();
    private bool get_IsSingleValue();
    private void EnsureCapacity(int capacity);
    private void EnsureCapacity(int capacity, int count);
    protected virtual NodeList CreateInstance();
    protected virtual void CloneElements(NodeList targetList, ElementCloneOptions options);
    public virtual bool get_IsReadOnly();
    public virtual int Add(object value);
    public virtual void RemoveAt(int index);
    public virtual void RemoveFrom(int index);
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, IList value);
    public virtual void Remove(object value);
    public sealed virtual bool Contains(object value);
    public virtual void Clear();
    public sealed virtual int IndexOf(object value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Array array, int index);
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
    public static void VisitNodeList(NodeList list, IElementVisitor visitor);
    public void VisitNodeList(IElementVisitor visitor);
    public virtual void AddRange(ICollection range);
    public void Sort(IComparer comparer);
    public void Sort(int index, int length, IComparer comparer);
    public Object[] ToArray();
    public Array ToArray(Type type);
    public void IncreaseNodesIndices(int startFrom);
    public int BinarySearch(int index, object value, IComparer comparer);
    public int BinarySearch(int index, int length, object value, IComparer comparer);
    public static ArrayList ToArrayList(NodeList list);
    public ArrayList ToArrayList();
    public virtual void Replace(object oldObject, object newObject);
    public virtual NodeList DeepClone();
    public virtual NodeList DeepClone(ElementCloneOptions options);
    protected virtual void OnClear();
}
public class DevExpress.CodeParser.NonPrivateMemberFilter : ElementFilterBase {
    private MemberVisibilityFilter _PrivateMemberFilter;
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
}
public class DevExpress.CodeParser.Nothing : object {
    public static bool GetBool();
    public static string GetString();
    public static Number GetNumber();
}
public class DevExpress.CodeParser.NullableTypeModifier : LanguageElement {
    public LanguageElementType ElementType { get; }
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
}
public class DevExpress.CodeParser.NullCoalescingExpression : BinaryOperatorExpression {
    public LanguageElementType ElementType { get; }
    public NullCoalescingExpression(Expression left, Expression right);
    public NullCoalescingExpression(Expression left, Expression right, SourceRange range);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual int GetCyclomaticComplexity();
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.Number : object {
    private object _Item;
    public object Item { get; public set; }
    public abstract virtual Number Add(Number param);
    public abstract virtual Number Sub(Number param);
    public abstract virtual Number Mul(Number param);
    public abstract virtual Number Div(Number param);
    public abstract virtual Number ModDiv(Number param);
    public abstract virtual Number MinusSign();
    public abstract virtual Number PlusSign();
    public abstract virtual Number Decrement();
    public abstract virtual Number Increment();
    public abstract virtual Number LeftShift(Number param);
    public abstract virtual Number RightShift(Number param);
    public abstract virtual Number Or(Number param);
    public abstract virtual Number And(Number param);
    public abstract virtual Number Xor(Number param);
    public abstract virtual bool IsTrue();
    public abstract virtual bool IsEqualTo(Number param);
    public abstract virtual bool IsBelow(Number param);
    public abstract virtual bool IsGreater(Number param);
    public abstract virtual bool IsBelowOrEqual(Number param);
    public abstract virtual bool IsGreaterOrEqual(Number param);
    public object get_Item();
    public void set_Item(object value);
}
public class DevExpress.CodeParser.ObjectCollectionInitializer : ObjectInitializerExpression {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ObjectCreationExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private TypeReferenceExpression _ObjectType;
    private ExpressionCollection _Arguments;
    private bool _HasNOGCModifier;
    private TextRangeWrapper _ParensRange;
    private ObjectInitializerExpression _ObjectInitializer;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public TypeReferenceExpression ObjectType { get; public set; }
    public ExpressionCollection Arguments { get; public set; }
    public SourceRange NameRange { get; }
    public ObjectInitializerExpression ObjectInitializer { get; public set; }
    public bool CanBeStatement { get; }
    public bool HasNOGCModifier { get; public set; }
    private ITypeReferenceExpression DevExpress.CodeParser.IObjectCreationExpression.ObjectType { get; }
    private IObjectInitializerExpression DevExpress.CodeParser.IObjectCreationExpression.ObjectInitializer { get; }
    private IExpressionCollection DevExpress.CodeParser.IObjectCreationExpression.Arguments { get; }
    public SourceRange ParensRange { get; }
    public int ArgumentsCount { get; }
    private IExpressionCollection DevExpress.CodeParser.IWithArguments.Args { get; }
    public ObjectCreationExpression(TypeReferenceExpression type);
    public ObjectCreationExpression(TypeReferenceExpression type, ExpressionCollection arguments);
    private void SetObjectType(TypeReferenceExpression type);
    private void SetObjectInitializer(ObjectInitializerExpression initializer);
    private void SetArguments(ExpressionCollection arguments);
    public virtual string ToString();
    public virtual int GetImageIndex();
    private bool ComareArguments(ObjectCreationExpression expression);
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(Token parenOpen, Token parenClose);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(SourceRange range);
    protected virtual void UpdateRanges();
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public sealed virtual void AddArgument(Expression arg);
    public void AddArguments(IEnumerable`1<Expression> arguments);
    public void RemoveArgument(Expression arg);
    public void InsertArgument(int index, Expression arg);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public TypeReferenceExpression get_ObjectType();
    public void set_ObjectType(TypeReferenceExpression value);
    public sealed virtual ExpressionCollection get_Arguments();
    public void set_Arguments(ExpressionCollection value);
    public virtual SourceRange get_NameRange();
    public ObjectInitializerExpression get_ObjectInitializer();
    public void set_ObjectInitializer(ObjectInitializerExpression value);
    public virtual bool get_CanBeStatement();
    public bool get_HasNOGCModifier();
    public void set_HasNOGCModifier(bool value);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.IObjectCreationExpression.get_ObjectType();
    private sealed virtual override IObjectInitializerExpression DevExpress.CodeParser.IObjectCreationExpression.get_ObjectInitializer();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IObjectCreationExpression.get_Arguments();
    public sealed virtual SourceRange get_ParensRange();
    public sealed virtual int get_ArgumentsCount();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IWithArguments.get_Args();
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.AddArgument(IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.InsertArgument(int index, IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.RemoveArgument(IExpression argument);
}
public class DevExpress.CodeParser.ObjectInitializerExpression : Expression {
    private ExpressionCollection _Initializers;
    public ExpressionCollection Initializers { get; }
    public LanguageElementType ElementType { get; }
    private IExpressionCollection DevExpress.CodeParser.IObjectInitializerExpression.Initializers { get; }
    private bool ComareInitializers(ObjectInitializerExpression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool IsIdenticalTo(Expression expression);
    public void AddInitializers(IEnumerable`1<Expression> initializers);
    public void AddInitializer(Expression init);
    public ExpressionCollection get_Initializers();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IObjectInitializerExpression.get_Initializers();
}
public class DevExpress.CodeParser.OnError : Statement {
    private string _Statement;
    public LanguageElementType ElementType { get; }
    public string Statement { get; }
    public OnError(string statement, SourceRange range);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Statement();
}
public abstract class DevExpress.CodeParser.OperatorExpression : Expression {
    private SourceRange _NameRange;
    public SourceRange NameRange { get; }
    public SourceRange OperatorRange { get; }
    public string OperatorText { get; public set; }
    public OperatorExpression(string operatorText);
    public OperatorExpression(Token operatorToken);
    public OperatorExpression(SourceRange operatorRange, string operatorText);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    [EditorBrowsableAttribute("1")]
public void SetOperatorRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetOperatorText(string text);
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual SourceRange get_NameRange();
    public SourceRange get_OperatorRange();
    public string get_OperatorText();
    public void set_OperatorText(string value);
}
public enum DevExpress.CodeParser.OperatorType : Enum {
    public int value__;
    public static OperatorType None;
    public static OperatorType Decrement;
    public static OperatorType Increment;
    public static OperatorType UnaryNegation;
    public static OperatorType UnaryPlus;
    public static OperatorType LogicalNot;
    public static OperatorType True;
    public static OperatorType False;
    public static OperatorType AddressOf;
    public static OperatorType OnesComplement;
    public static OperatorType PointerDereference;
    public static OperatorType Addition;
    public static OperatorType Subtraction;
    public static OperatorType Multiply;
    public static OperatorType Division;
    public static OperatorType Modulus;
    public static OperatorType ExclusiveOr;
    public static OperatorType BitwiseAnd;
    public static OperatorType BitwiseOr;
    public static OperatorType LogicalAnd;
    public static OperatorType LogicalOr;
    public static OperatorType Assign;
    public static OperatorType LeftShift;
    public static OperatorType RightShift;
    public static OperatorType SignedRightShift;
    public static OperatorType UnsignedRightShift;
    public static OperatorType Equality;
    public static OperatorType GreaterThan;
    public static OperatorType LessThan;
    public static OperatorType Inequality;
    public static OperatorType GreaterThanOrEqual;
    public static OperatorType LessThanOrEqual;
    public static OperatorType UnsignedRightShiftAssignment;
    public static OperatorType MemberSelection;
    public static OperatorType RightShiftAssignment;
    public static OperatorType MultiplicationAssignment;
    public static OperatorType PointerToMemberSelection;
    public static OperatorType SubtractionAssignment;
    public static OperatorType ExclusiveOrAssignment;
    public static OperatorType LeftShiftAssignment;
    public static OperatorType ModulusAssignment;
    public static OperatorType AdditionAssignment;
    public static OperatorType BitwiseAndAssignment;
    public static OperatorType BitwiseOrAssignment;
    public static OperatorType Comma;
    public static OperatorType DivisionAssignment;
    public static OperatorType Concatenate;
    public static OperatorType Exponent;
    public static OperatorType IntegerDivision;
    public static OperatorType Like;
}
public class DevExpress.CodeParser.OptionDirective : CompilerDirective {
    private string _Option;
    public string Option { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public string get_Option();
    public void set_Option(string value);
    public virtual LanguageElementType get_ElementType();
}
public enum DevExpress.CodeParser.OptionExplicit : Enum {
    public int value__;
    public static OptionExplicit On;
    public static OptionExplicit Off;
}
public enum DevExpress.CodeParser.OptionInfer : Enum {
    public int value__;
    public static OptionInfer On;
    public static OptionInfer Off;
}
public enum DevExpress.CodeParser.OptionState : Enum {
    public int value__;
    public static OptionState On;
    public static OptionState Off;
    public static OptionState Binary;
    public static OptionState Text;
}
public class DevExpress.CodeParser.OptionStatement : Statement {
    private OptionState _State;
    private OptionType _Type;
    public OptionState State { get; public set; }
    public OptionType Type { get; public set; }
    public LanguageElementType ElementType { get; }
    public OptionStatement(OptionState state, OptionType type);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public OptionState get_State();
    public void set_State(OptionState value);
    public OptionType get_Type();
    public void set_Type(OptionType value);
    public virtual LanguageElementType get_ElementType();
    public virtual int GetImageIndex();
}
public enum DevExpress.CodeParser.OptionStrict : Enum {
    public int value__;
    public static OptionStrict On;
    public static OptionStrict Off;
}
public enum DevExpress.CodeParser.OptionType : Enum {
    public int value__;
    public static OptionType Explicit;
    public static OptionType Infer;
    public static OptionType Compare;
    public static OptionType Strict;
}
public class DevExpress.CodeParser.OrderByExpression : QueryExpressionBase {
    private ExpressionCollection _Orderings;
    public ExpressionCollection Orderings { get; }
    public LanguageElementType ElementType { get; }
    private IExpressionCollection DevExpress.CodeParser.IOrderByExpression.Orderings { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public void AddOrderings(IEnumerable`1<IElement> orderings);
    public void AddOrdering(OrderingExpression ordering);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public ExpressionCollection get_Orderings();
    public virtual LanguageElementType get_ElementType();
    public virtual string ToString();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IOrderByExpression.get_Orderings();
}
public class DevExpress.CodeParser.OrderingExpression : QueryExpressionBase {
    private OrderingType _Order;
    private Expression _Ordering;
    public Expression Ordering { get; }
    public OrderingType Order { get; public set; }
    public LanguageElementType ElementType { get; }
    private IExpression DevExpress.CodeParser.IOrderingExpression.Ordering { get; }
    public OrderingExpression(OrderingType order, Expression ordering);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public void SetOrdering(Expression ordering);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public Expression get_Ordering();
    public sealed virtual OrderingType get_Order();
    public void set_Order(OrderingType value);
    public virtual LanguageElementType get_ElementType();
    public virtual string ToString();
    private sealed virtual override IExpression DevExpress.CodeParser.IOrderingExpression.get_Ordering();
}
public enum DevExpress.CodeParser.OrderingType : Enum {
    public int value__;
    public static OrderingType Default;
    public static OrderingType Ascending;
    public static OrderingType Descending;
}
public class DevExpress.CodeParser.PageDirective : AspDirective {
    public LanguageElementType ElementType { get; }
    public PageLanguageType LanguageID { get; }
    public string Inherits { get; public set; }
    public string CodeFile { get; public set; }
    public string CodeBehind { get; public set; }
    public string MasterPageFile { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public PageLanguageType get_LanguageID();
    public string get_Inherits();
    public void set_Inherits(string value);
    public string get_CodeFile();
    public void set_CodeFile(string value);
    public string get_CodeBehind();
    public void set_CodeBehind(string value);
    public string get_MasterPageFile();
    public void set_MasterPageFile(string value);
}
public enum DevExpress.CodeParser.PageLanguageType : Enum {
    public int value__;
    public static PageLanguageType CSharp;
    public static PageLanguageType VB;
    public static PageLanguageType JSharp;
    public static PageLanguageType Unknown;
}
public class DevExpress.CodeParser.Param : BaseVariable {
    private static int INT_InParamMaintainanceComplexity;
    private static int INT_RefOutParamMaintainanceComplexity;
    private ArgumentDirection _Direction;
    private bool _IsOptional;
    private string _DefaultValue;
    private Expression _DefaultValueExpression;
    private SourceRange _DirectionRange;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public bool DeclaresIdentifier { get; }
    [DescriptionAttribute("The type of this parameter.")]
[CategoryAttribute("Details")]
public string ParamType { get; public set; }
    [DescriptionAttribute("The default value for this parameter, if specified.")]
[CategoryAttribute("Details")]
public string DefaultValue { get; public set; }
    [DescriptionAttribute("Gets or sets parameter direction (in/out/ref).")]
[CategoryAttribute("Details")]
public ArgumentDirection Direction { get; public set; }
    public SourceRange DirectionRange { get; public set; }
    [DescriptionAttribute("True if this parameter is optional.")]
[CategoryAttribute("Details")]
public bool IsOptional { get; public set; }
    [DescriptionAttribute("True if this parameter is passed by value.")]
[CategoryAttribute("Details")]
public bool IsByVal { get; }
    [DescriptionAttribute("True if this parameter is passed by reference.")]
[CategoryAttribute("Details")]
public bool IsReferenceParam { get; }
    [DescriptionAttribute("True if this is an out parameter.")]
[CategoryAttribute("Details")]
public bool IsOutParam { get; }
    [DescriptionAttribute("True if this parameter is an array of objects.")]
[CategoryAttribute("Details")]
public bool IsParamArray { get; }
    private bool DevExpress.CodeParser.IBaseVariable.IsParameter { get; }
    private IExpression DevExpress.CodeParser.IParameterElement.DefaultValue { get; }
    public Expression DefaultValueExpression { get; public set; }
    public bool IsArgList { get; }
    public Param(string name);
    public Param(string type, string name);
    protected virtual int get_ThisMaintenanceComplexity();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual string GetTypeName();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void SetFullTypeName(string fullTypeName);
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_DeclaresIdentifier();
    public string get_ParamType();
    public void set_ParamType(string value);
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public sealed virtual ArgumentDirection get_Direction();
    public void set_Direction(ArgumentDirection value);
    public SourceRange get_DirectionRange();
    public void set_DirectionRange(SourceRange value);
    public sealed virtual bool get_IsOptional();
    public void set_IsOptional(bool value);
    public bool get_IsByVal();
    public bool get_IsReferenceParam();
    public bool get_IsOutParam();
    public sealed virtual bool get_IsParamArray();
    private sealed virtual override bool DevExpress.CodeParser.IBaseVariable.get_IsParameter();
    private sealed virtual override IExpression DevExpress.CodeParser.IParameterElement.get_DefaultValue();
    private sealed virtual override void DevExpress.CodeParser.IParameterElementModifier.SetType(ITypeReferenceExpression type);
    private sealed virtual override void DevExpress.CodeParser.IParameterElementModifier.SetDirection(ArgumentDirection direction);
    public Expression get_DefaultValueExpression();
    public void set_DefaultValueExpression(Expression value);
    public sealed virtual bool get_IsArgList();
}
public class DevExpress.CodeParser.ParameterLessMethodFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public virtual IElementCollection Apply(IElementCollection elements);
}
public class DevExpress.CodeParser.ParametrizedArrayCreateExpression : ArrayCreateExpression {
    private ExpressionCollection _NewOperatorArguments;
    public LanguageElementType ElementType { get; }
    public ExpressionCollection NewOperatorArguments { get; public set; }
    public ParametrizedArrayCreateExpression(TypeReferenceExpression type, ExpressionCollection dimensions, ExpressionCollection newArguments);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public ExpressionCollection get_NewOperatorArguments();
    public void set_NewOperatorArguments(ExpressionCollection value);
}
public class DevExpress.CodeParser.ParametrizedObjectCreationExpression : ObjectCreationExpression {
    private ExpressionCollection _NewOperatorArguments;
    public LanguageElementType ElementType { get; }
    public ExpressionCollection NewOperatorArguments { get; public set; }
    public ParametrizedObjectCreationExpression(TypeReferenceExpression type, ExpressionCollection ctorArguments, ExpressionCollection newArguments);
    private void SetNewOperatorArguments(ExpressionCollection newArguments);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public ExpressionCollection get_NewOperatorArguments();
    public void set_NewOperatorArguments(ExpressionCollection value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.ParamsStringCollection : NodeList {
    public string Item { get; public set; }
    protected int Add(string element);
    protected void AddRange(ParamsStringCollection collection);
    protected int IndexOf(string element);
    protected void Insert(int index, string element);
    protected void Remove(string element);
    protected string Find(string element);
    protected bool Contains(string element);
    protected virtual NodeList CreateInstance();
    public string get_Item(int index);
    public void set_Item(int index, string value);
}
public class DevExpress.CodeParser.ParenthesizedExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _Exp;
    protected int ThisMaintenanceComplexity { get; }
    public bool NeedsInvertParens { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IParenthesizedExpression.Expression { get; }
    public ParenthesizedExpression(Expression expression);
    protected virtual int get_ThisMaintenanceComplexity();
    protected void SetExpression(Expression expression);
    protected virtual object EvaluateExpression();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool get_NeedsInvertParens();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IParenthesizedExpression.get_Expression();
}
public class DevExpress.CodeParser.ParenthesizedTypeReferenceExpression : TypeReferenceExpression {
    private Expression _Expression;
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IParenthesizedExpression.Expression { get; }
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IParenthesizedExpression.get_Expression();
}
public class DevExpress.CodeParser.ParentingStatement : Statement {
    private TextRangeWrapper _ParensRange;
    private bool _IsBreakable;
    private bool _HasBlock;
    [DescriptionAttribute("True if this language element contains a block of code.")]
[CategoryAttribute("Family")]
public bool HasBlock { get; public set; }
    public bool IsBreakable { get; public set; }
    public bool IsNewContext { get; }
    public IEnumerable AllStatements { get; }
    public IEnumerable AllVariables { get; }
    public IEnumerable AllFlowBreaks { get; }
    public SourceRange ParensRange { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual string ToString();
    public virtual int GetCyclomaticComplexity();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public LanguageElementCollection GetUnusedDeclarations();
    [EditorBrowsableAttribute("1")]
public void SetParensRange(Token parenOpen, Token parenClose);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(SourceRange range);
    public bool get_HasBlock();
    public void set_HasBlock(bool value);
    public bool get_IsBreakable();
    public void set_IsBreakable(bool value);
    public virtual bool get_IsNewContext();
    public IEnumerable get_AllStatements();
    public IEnumerable get_AllVariables();
    public IEnumerable get_AllFlowBreaks();
    public sealed virtual SourceRange get_ParensRange();
}
public class DevExpress.CodeParser.ParentToSingleStatement : ParentingStatement {
    public bool AcceptsElse { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool get_AcceptsElse();
}
public abstract class DevExpress.CodeParser.ParserBase : object {
    private double _ParseTime;
    private bool _IsParsing;
    private ExpressionParserBase _ExpressionParser;
    private LanguageElement _RootContext;
    private LanguageElement _Context;
    private TextStringCollection _TextStrings;
    private RegionDirective _RegionContext;
    private CompilerDirective _CompilerDirectiveContext;
    private IDocument _Document;
    private SourceRange _ParseRange;
    private bool _AllowCommentsInParseTree;
    private object _SyncObject;
    private bool _LastParsingHasEOF;
    protected ParserErrorsBase parserErrors;
    public string Language { get; }
    public bool IsParsing { get; }
    public bool LastParsingHasEOF { get; public set; }
    public double ParseTime { get; }
    public ExpressionParserBase ExpressionParser { get; }
    public LanguageElement Context { get; }
    public LanguageElement RootContext { get; }
    public TextStringCollection TextStrings { get; }
    public RegionDirective RegionContext { get; public set; }
    public CompilerDirective CompilerDirectiveContext { get; public set; }
    public ParserErrorsBase ParseErrors { get; }
    public IDocument Document { get; }
    public SourceRange ParseRange { get; }
    public bool AllowCommentsInParseTree { get; public set; }
    private void CorrectContextRange(LanguageElement context, CommentCollection remainingComments);
    private void ProcessTextStrings();
    public abstract virtual ExpressionParserBase CreateExpressionParser();
    public abstract virtual IExpressionInverter CreateExpressionInverter();
    protected virtual void PrepareForParse(ParserContext parserContext);
    protected virtual void FinishParsing();
    protected virtual void CleanUpInternalData();
    [EditorBrowsableAttribute("1")]
protected virtual InitializedVariable CreateInitializedVariable();
    [EditorBrowsableAttribute("1")]
protected virtual Variable CreateVariable();
    [EditorBrowsableAttribute("1")]
protected virtual Const CreateConst();
    [EditorBrowsableAttribute("1")]
protected virtual void LinkVariablesList(LanguageElementCollection variables);
    [EditorBrowsableAttribute("1")]
protected virtual void SetVariableTypes(LanguageElementCollection variables);
    protected virtual LanguageElement DoParse(ParserContext parserContext, ISourceReader reader);
    public abstract virtual bool SupportsFileExtension(string ext);
    public abstract virtual string GetFullTypeName(string simpleName);
    public virtual SourceFile GetSourceFile(string fileName);
    public virtual void GotoParent(Token endToken, int adjustment);
    public virtual void GotoParent(Token endToken, int adjustment, bool overwrite);
    public virtual void GotoParent(Token endToken);
    public virtual void GotoParent(LanguageElement element);
    public virtual void GotoParent(int endLine, int endOffset);
    public void GotoParentContext();
    public void GotoParentRegion();
    public virtual void IntroduceComments(LanguageElement context);
    public virtual void IntroduceComments(LanguageElement context, CommentCollection comments);
    public virtual LanguageElement Parse(LanguageElement context, RegionDirective regionContext, TextStringCollection textStrings, CompilerDirective compilerDirective, ISourceReader reader);
    public virtual LanguageElement Parse(LanguageElement context, RegionDirective regionContext, TextStringCollection textStrings, CompilerDirective compilerDirectiveContext, ISourceReader reader, IDocument document);
    public virtual LanguageElement Parse(ParserContext parserContext, ISourceReader reader);
    public virtual LanguageElement ParseMiscFile(ParserContext parserContext, ISourceReader reader);
    protected virtual LanguageElement CallParsing(ParserContext parserContext, ISourceReader reader);
    protected void SetupSourceFile();
    [ObsoleteAttribute("Use ParseString instead.")]
[EditorBrowsableAttribute("1")]
public LanguageElement ParseSring(string code);
    public LanguageElement ParseString(string code);
    [EditorBrowsableAttribute("1")]
public ICollection ParseStatements(string code);
    public LanguageElement ParseString(string code, int line, int column);
    public LanguageElement ParseFile(string path);
    public LanguageElement ParseFile(string path, Encoding encoding);
    public LanguageElement ParseFile(string path, Encoding encoding, ErrorList& errors);
    public LanguageElement ParseFile(SourceFile file);
    public void SetContext(LanguageElement value);
    public virtual bool IsQueryExpressionStart(string str);
    public abstract virtual string get_Language();
    public bool get_IsParsing();
    public bool get_LastParsingHasEOF();
    public void set_LastParsingHasEOF(bool value);
    public double get_ParseTime();
    public ExpressionParserBase get_ExpressionParser();
    public LanguageElement get_Context();
    public LanguageElement get_RootContext();
    public TextStringCollection get_TextStrings();
    public RegionDirective get_RegionContext();
    public void set_RegionContext(RegionDirective value);
    public CompilerDirective get_CompilerDirectiveContext();
    public void set_CompilerDirectiveContext(CompilerDirective value);
    public ParserErrorsBase get_ParseErrors();
    public IDocument get_Document();
    public SourceRange get_ParseRange();
    public bool get_AllowCommentsInParseTree();
    public void set_AllowCommentsInParseTree(bool value);
}
public class DevExpress.CodeParser.ParserContext : object {
    private LanguageElement _Context;
    private LanguageElement _ContextAfterParse;
    private RegionDirective _RegionContext;
    private TextStringCollection _TextStrings;
    private CompilerDirective _CompilerDirectiveContext;
    private ISourceReader _SourceReader;
    private IDocument _Document;
    private SourceRange _ParseRange;
    private CommentCollection _Comments;
    private SourceFile _SourceFile;
    private bool _AllowCommentsInParseTree;
    private bool _SaveUserFormat;
    private ScannerExtension _ScannerExtension;
    private ErrorList _Errors;
    public LanguageElement Context { get; public set; }
    public LanguageElement ContextAfterParse { get; public set; }
    public RegionDirective RegionContext { get; public set; }
    public TextStringCollection TextStrings { get; public set; }
    public CompilerDirective CompilerDirectiveContext { get; public set; }
    public ISourceReader SourceReader { get; public set; }
    public IDocument Document { get; public set; }
    public SourceRange ParseRange { get; public set; }
    public bool AllowCommentsInParseTree { get; public set; }
    public bool SaveUserFormat { get; public set; }
    public CommentCollection Comments { get; public set; }
    public SourceFile SourceFile { get; public set; }
    public ScannerExtension ScannerExtension { get; public set; }
    public ErrorList Errors { get; public set; }
    public void AutoSetValues();
    public void IntroduceComments();
    protected void ClearValues();
    public LanguageElement get_Context();
    public void set_Context(LanguageElement value);
    public LanguageElement get_ContextAfterParse();
    public void set_ContextAfterParse(LanguageElement value);
    public RegionDirective get_RegionContext();
    public void set_RegionContext(RegionDirective value);
    public TextStringCollection get_TextStrings();
    public void set_TextStrings(TextStringCollection value);
    public CompilerDirective get_CompilerDirectiveContext();
    public void set_CompilerDirectiveContext(CompilerDirective value);
    public ISourceReader get_SourceReader();
    public void set_SourceReader(ISourceReader value);
    public IDocument get_Document();
    public void set_Document(IDocument value);
    public SourceRange get_ParseRange();
    public void set_ParseRange(SourceRange value);
    public bool get_AllowCommentsInParseTree();
    public void set_AllowCommentsInParseTree(bool value);
    public bool get_SaveUserFormat();
    public void set_SaveUserFormat(bool value);
    public CommentCollection get_Comments();
    public void set_Comments(CommentCollection value);
    public SourceFile get_SourceFile();
    public void set_SourceFile(SourceFile value);
    public ScannerExtension get_ScannerExtension();
    public void set_ScannerExtension(ScannerExtension value);
    public ErrorList get_Errors();
    public void set_Errors(ErrorList value);
}
public abstract class DevExpress.CodeParser.ParserErrorsBase : object {
    private static string errMsgFormat;
    private StringCollection errors;
    private ErrorList _Errors;
    public ErrorList Errors { get; }
    public int Count { get; }
    public ErrorList get_Errors();
    protected abstract virtual string GetSyntaxErrorText(int n);
    protected void LogError(string format, Object[] args);
    public void SynErr(int line, int col, int n);
    public void SemErr(int line, int col, int n);
    public void Error(int line, int col, string s);
    public void Exception(string s);
    public void Clear();
    public int get_Count();
    public ErrorList GetClonedErrorList();
}
public class DevExpress.CodeParser.ParserException : Exception {
    public ParserException(string msg);
    public ParserException(string msg, Exception innerException);
}
public static class DevExpress.CodeParser.ParserFactory : object {
    private static ParserVersion DefaultParserVersion;
    public static ParserBase CreateParserForFileExtension(string extension);
    public static ParserBase CreateParserForFileExtension(string extension, ParserVersion parserVersion);
    public static ParserBase CreateParser(string language);
    public static ParserBase CreateParser(string language, ParserVersion parserVersion);
    public static ParserBase CreateParser(ParserLanguageID languageID);
    public static ParserBase CreateParser(ParserLanguageID languageID, ParserVersion parserVersion);
}
public static class DevExpress.CodeParser.ParserLanguage : object {
    private static string STR_Cs;
    private static string STR_DotCs;
    private static string STR_Csproj;
    private static string STR_DotCSProj;
    private static string STR_Vb;
    private static string STR_DotVb;
    private static string STR_Vbproj;
    private static string STR_DotVBProj;
    private static string STR_H;
    private static string STR_DotH;
    private static string STR_Hh;
    private static string STR_DotHh;
    private static string STR_Cpp;
    private static string STR_DotCpp;
    private static string STR_CPPproj;
    private static string STR_DotCppProj;
    private static string STR_Xaml;
    private static string STR_DotXaml;
    private static string STR_Js;
    private static string STR_DotJs;
    private static string STR_Html;
    private static string STR_DotHtml;
    private static string STR_Htm;
    private static string STR_DotHtm;
    private static string STR_Xml;
    private static string STR_DotXml;
    private static string STR_Css;
    private static string STR_DotCss;
    public static string ToString(ParserLanguageID language);
    public static ParserLanguageID FromString(string language);
    public static ParserLanguageID FromFileExtension(string extension);
}
[FlagsAttribute]
public enum DevExpress.CodeParser.ParserLanguageID : Enum {
    public int value__;
    public static ParserLanguageID None;
    public static ParserLanguageID CSharp;
    public static ParserLanguageID Basic;
    public static ParserLanguageID Cpp;
    public static ParserLanguageID Html;
    public static ParserLanguageID JavaScript;
    public static ParserLanguageID Xaml;
    public static ParserLanguageID Xml;
    public static ParserLanguageID Css;
    public static ParserLanguageID FSharp;
}
public static class DevExpress.CodeParser.ParserUtils : object {
    public static object GetCloneFromNodeList(NodeList target, NodeList source, object obj);
    public static object GetCloneFromNodes(BaseElement target, BaseElement source, object obj);
    public static void GetClonesFromNodes(NodeList targetNodes, NodeList sourceNodes, NodeList targetCollection, NodeList sourceCollection);
    public static LanguageElementCollection GetSelectedNodes(LanguageElement scope, SourceRange range);
    private static bool IsBadPoint(SourcePoint point);
    private static bool ContainsPoint(IList list, int startIndex, int endIndex, SourcePoint point);
    public static bool RangeIsCorrupted(SourceRange range);
    private static Position GetPosition(IList list, int startIndex, int endIndex, SourcePoint point);
    public static int GetIndexAt(IList list, SourcePoint point);
    public static int GetIndexAt(IList list, SourcePoint point, Position& position);
    public static int GetIndexAt(IList list, int startIndex, int endIndex, SourcePoint point);
    public static int GetIndexAt(IList list, int startIndex, int endIndex, SourcePoint point, Position& position);
    public static bool GetBounds(IList list, SourceRange range, Int32& left, Int32& right);
    public static bool GetBounds(IList list, int startIndex, int endIndex, SourceRange range, Int32& left, Int32& right);
    public static IList`1<LanguageElement> GetNodesInRange(LanguageElement scope, SourceRange range);
    public static IList`1<LanguageElement> GetNodesInRange(LanguageElement scope, SourceRange range, bool useBinarySerach);
    public static IList`1<LanguageElement> GetNodesInRange(NodeList nodes, SourceRange range);
    public static IList`1<LanguageElement> GetNodesInRange(NodeList nodes, SourceRange range, bool useBinarySerach);
    public static void RemoveNodesInRange(LanguageElement scope, SourceRange range);
    public static void RemoveNodesInRange(NodeList nodes, SourceRange range, bool useBinarySerach, bool recursive);
    public static void RemoveNodesInRange(NodeList nodes, SourceRange range);
    public static void RemoveNodesInRange(NodeList nodes, SourceRange range, bool useBinarySerach);
    public static int CountChildStatements(Statement statement);
    public static bool IsStatement(LanguageElement element);
    public static int CountStatements(NodeList nodes);
    public static string GetElementTypeName(LanguageElement element);
    public static TypeReferenceExpression GetElementType(LanguageElement element);
}
public enum DevExpress.CodeParser.ParserVersion : Enum {
    public int value__;
    public static ParserVersion Unknown;
    public static ParserVersion VS2002;
    public static ParserVersion VS2003;
    public static ParserVersion VS2005;
    public static ParserVersion VS2008;
    public static ParserVersion VS2010;
    public static ParserVersion VS2011;
    public static ParserVersion VS2012;
    public static ParserVersion VS2014;
}
[FlagsAttribute]
public enum DevExpress.CodeParser.ParsingMode : Enum {
    public int value__;
    public static ParsingMode Simple;
    public static ParsingMode BindComments;
    public static ParsingMode SaveUserFormat;
}
public abstract class DevExpress.CodeParser.PathElement : LanguageElement {
    private string _FilePath;
    private string _LocalPath;
    public string FilePath { get; }
    [EditorBrowsableAttribute("1")]
public string LocalPath { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use LocalPath")]
public string LocaPath { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public void SetFilePath(string newPath);
    public string get_FilePath();
    public string get_LocalPath();
    public string get_LocaPath();
}
internal class DevExpress.CodeParser.PathPart : object {
    private string _Name;
    private LanguageElement _Element;
    public string Name { get; }
    public LanguageElement Element { get; }
    public PathPart(string name, LanguageElement element);
    public string get_Name();
    public LanguageElement get_Element();
}
public static class DevExpress.CodeParser.PathUtils : object {
    public static string GetLocalPath(string uri);
    public static string AddDirSeparatorIfNeed(string path);
}
public abstract class DevExpress.CodeParser.Patterns.DemandObjectManager : object {
    private Hashtable _ProxiesHash;
    private Hashtable _Proxies;
    private ArrayList _ObjectsToLive;
    protected ArrayList ObjectsToLive { get; }
    protected Hashtable Proxies { get; }
    protected int ProxiesCount { get; }
    protected Hashtable ProxiesHash { get; }
    public int LiveObjectsCount { get; }
    protected virtual override void Finalize();
    private int GetLiveObjectsCount();
    protected virtual void Dispose(bool disposing);
    protected void RegisterObject(IDemandObjectProxy proxy, object obj);
    protected abstract virtual object CreateObjectForProxy(IDemandObjectProxy proxy);
    public void UpdateKey(object oldKey, object newKey);
    public void AddProxy(IDemandObjectProxy proxy);
    public void RemoveProxy(IDemandObjectProxy proxy);
    public object RequestObject(IDemandObjectProxy proxy);
    public object RequestObject(IDemandObjectProxy proxy, bool forceCreate);
    public void ReleaseObject(IDemandObjectProxy proxy);
    public void ReleaseAllObjects();
    public void ReplaceObject(IDemandObjectProxy proxy, object obj);
    public object GetAliveObject(IDemandObjectProxy proxy);
    protected ArrayList get_ObjectsToLive();
    protected Hashtable get_Proxies();
    protected int get_ProxiesCount();
    protected Hashtable get_ProxiesHash();
    public int get_LiveObjectsCount();
    public sealed virtual void Dispose();
}
public interface DevExpress.CodeParser.Patterns.IDemandObjectProxy {
    public object Key { get; }
    public DemandObjectManager Manager { get; public set; }
    public abstract virtual object get_Key();
    public abstract virtual DemandObjectManager get_Manager();
    public abstract virtual void set_Manager(DemandObjectManager value);
}
public class DevExpress.CodeParser.PointerElementReference : CppQualifiedElementReference {
    public LanguageElementType ElementType { get; }
    public PointerElementReference(Expression source, string name, SourceRange namerange);
    protected virtual string GetNameWithQualifier();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.PointerMethodReference : CppMethodReferenceExpression {
    public LanguageElementType ElementType { get; }
    public PointerMethodReference(Expression source, string name, SourceRange namerange);
    protected virtual string GetNameWithQualifier();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.PostponedParsingData : object {
    private CommentCollection _Comments;
    private ISourceReader _UnparsedCode;
    private RegionDirective _RegionContext;
    private bool _IsParsing;
    private int _LineOffset;
    private int _ColumnOffset;
    private ParserBase _Parser;
    public bool IsParsing { get; public set; }
    public CommentCollection Comments { get; public set; }
    public ISourceReader UnparsedCode { get; public set; }
    public RegionDirective RegionContext { get; public set; }
    public bool HasUnparsedCode { get; }
    public bool HasComments { get; }
    public int LineOffset { get; public set; }
    public int ColumnOffset { get; public set; }
    public ParserBase Parser { get; public set; }
    public void CleanUp();
    public bool get_IsParsing();
    public void set_IsParsing(bool value);
    public CommentCollection get_Comments();
    public void set_Comments(CommentCollection value);
    public ISourceReader get_UnparsedCode();
    public void set_UnparsedCode(ISourceReader value);
    public RegionDirective get_RegionContext();
    public void set_RegionContext(RegionDirective value);
    public bool get_HasUnparsedCode();
    public bool get_HasComments();
    public int get_LineOffset();
    public void set_LineOffset(int value);
    public int get_ColumnOffset();
    public void set_ColumnOffset(int value);
    public ParserBase get_Parser();
    public void set_Parser(ParserBase value);
}
public class DevExpress.CodeParser.PragmaDirective : CompilerDirective {
    private string _Text;
    public string Text { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public string get_Text();
    public void set_Text(string value);
    public virtual LanguageElementType get_ElementType();
}
public enum DevExpress.CodeParser.PrecedingSign : Enum {
    public byte value__;
    public static PrecedingSign None;
    public static PrecedingSign Plus;
    public static PrecedingSign Minus;
}
public class DevExpress.CodeParser.PredicateElementFilter : ElementFilterBase {
    private Predicate`1<IElement> _Predicate;
    public PredicateElementFilter(Predicate`1<IElement> predicate);
    public virtual bool Apply(IElement element);
}
public enum DevExpress.CodeParser.PreprocessingValueType : Enum {
    public byte value__;
    public static PreprocessingValueType None;
    public static PreprocessingValueType String;
    public static PreprocessingValueType Bool;
    public static PreprocessingValueType IntNumber;
    public static PreprocessingValueType FloatNumber;
    public static PreprocessingValueType Nothing;
}
public class DevExpress.CodeParser.PreprocessorDirective : CodeElement {
    public bool CompletesPrevious { get; }
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool get_CompletesPrevious();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.PrimitiveExpression : Expression {
    private string _Literal;
    private bool _IsVerbatimStringLiteral;
    private PrimitiveType _PrimitiveType;
    public LanguageElementType ElementType { get; }
    public bool NeedsInvertParens { get; }
    public bool IsNumberLiteral { get; }
    public string Literal { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool CanHasEscapeSequence { get; }
    [CategoryAttribute("Expression Type")]
[DescriptionAttribute("Returns true if this primitive expression is boolean literal (true or false in C#).")]
public bool IsBooleanLiteral { get; }
    [CategoryAttribute("Expression Type")]
[DescriptionAttribute("Returns true if this primitive expression is string literal.")]
public bool IsStringLiteral { get; }
    [CategoryAttribute("Expression Type")]
[DescriptionAttribute("Returns true if this primitive expression is char literal.")]
public bool IsCharLiteral { get; }
    [CategoryAttribute("Expression Type")]
[DescriptionAttribute("Returns true if this primitive expression is DateTime literal.")]
public bool IsDateTime { get; }
    [CategoryAttribute("Expression Type")]
[DescriptionAttribute("Returns true if this primitive expression is null literal.")]
public bool IsNullLiteral { get; }
    [CategoryAttribute("Expression Type")]
[DescriptionAttribute("Gets or sets primitive type of this expression.")]
public PrimitiveType PrimitiveType { get; public set; }
    [DescriptionAttribute("Gets or sets primitive value of this expression.")]
public object PrimitiveValue { get; public set; }
    [CategoryAttribute("Expression Type")]
[DescriptionAttribute("Gets expression type name.")]
public string ExpressionTypeName { get; }
    public SourceRange NameRange { get; }
    public bool IsVerbatimStringLiteral { get; public set; }
    private object DevExpress.CodeParser.IPrimitiveExpression.Value { get; }
    private PrimitiveType DevExpress.CodeParser.IPrimitiveExpression.PrimitiveType { get; }
    private bool DevExpress.CodeParser.IPrimitiveExpression.IsVerbatimString { get; }
    public PrimitiveExpression(string value);
    public PrimitiveExpression(string value, SourceRange range);
    private void InitializeValue(object value);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public static PrimitiveExpression FromObject(object value);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual object EvaluateExpression();
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_NeedsInvertParens();
    public bool get_IsNumberLiteral();
    public string get_Literal();
    public void set_Literal(string value);
    public virtual bool get_CanHasEscapeSequence();
    public sealed virtual bool get_IsBooleanLiteral();
    public sealed virtual bool get_IsStringLiteral();
    public sealed virtual bool get_IsCharLiteral();
    public bool get_IsDateTime();
    public sealed virtual bool get_IsNullLiteral();
    public PrimitiveType get_PrimitiveType();
    public void set_PrimitiveType(PrimitiveType value);
    public object get_PrimitiveValue();
    public void set_PrimitiveValue(object value);
    public virtual string get_ExpressionTypeName();
    public virtual SourceRange get_NameRange();
    public bool get_IsVerbatimStringLiteral();
    public void set_IsVerbatimStringLiteral(bool value);
    private sealed virtual override object DevExpress.CodeParser.IPrimitiveExpression.get_Value();
    private sealed virtual override PrimitiveType DevExpress.CodeParser.IPrimitiveExpression.get_PrimitiveType();
    private sealed virtual override bool DevExpress.CodeParser.IPrimitiveExpression.get_IsVerbatimString();
}
public enum DevExpress.CodeParser.PrimitiveType : Enum {
    public byte value__;
    public static PrimitiveType Undefined;
    public static PrimitiveType Boolean;
    public static PrimitiveType Byte;
    public static PrimitiveType SByte;
    public static PrimitiveType Char;
    public static PrimitiveType DBNull;
    public static PrimitiveType Int16;
    public static PrimitiveType Int32;
    public static PrimitiveType Int64;
    public static PrimitiveType UInt16;
    public static PrimitiveType UInt32;
    public static PrimitiveType UInt64;
    public static PrimitiveType Single;
    public static PrimitiveType Double;
    public static PrimitiveType Decimal;
    public static PrimitiveType DateTime;
    public static PrimitiveType Object;
    public static PrimitiveType String;
    public static PrimitiveType Void;
    public static PrimitiveType RegularExpression;
    public static PrimitiveType Path;
}
public static class DevExpress.CodeParser.PrimitiveTypeUtils : object {
    public static string SystemVoid;
    public static string SystemString;
    public static string SystemObject;
    public static string SystemDateTime;
    public static string SystemDecimal;
    public static string SystemDouble;
    public static string SystemSingle;
    public static string SystemUInt64;
    public static string SystemUInt32;
    public static string SystemUInt16;
    public static string SystemInt64;
    public static string SystemInt32;
    public static string SystemInt16;
    public static string SystemDBNull;
    public static string SystemChar;
    public static string SystemSByte;
    public static string SystemByte;
    public static string SystemBoolean;
    private static Dictionary`2<PrimitiveType, List`1<PrimitiveType>> _PossibleTypesTable;
    private static List`1<PrimitiveType> _AllPossibleTypes;
    public static string GetFullTypeName(PrimitiveType type);
    public static bool IsPrimitiveType(string fullName);
    public static PrimitiveType ToPrimitiveType(string fullName);
    public static bool IsSByte(decimal value);
    public static bool IsByte(decimal value);
    public static bool IsShort(decimal value);
    public static bool IsUShort(decimal value);
    public static bool IsInt(decimal value);
    public static bool IsUInt(decimal value);
    public static bool IsLong(decimal value);
    public static bool IsULong(decimal value);
    private static List`1<PrimitiveType> GetAllPossibleTypes();
    private static List`1<PrimitiveType> GetPossibleTypesForInt32();
    private static List`1<PrimitiveType> GetPossibleTypesForUInt32();
    private static List`1<PrimitiveType> GetPossibleTypesForInt64();
    private static List`1<PrimitiveType> GetPossibleTypesForUInt64();
    private static List`1<PrimitiveType> GetPossibleTypesForSingle();
    private static List`1<PrimitiveType> GetPossibleTypesForDecimal();
    private static List`1<PrimitiveType> GetPossibleTypesForDouble();
    private static Dictionary`2<PrimitiveType, List`1<PrimitiveType>> GetPossibleTypesTable();
    public static List`1<PrimitiveType> GetBinaryOperatorPossibleTypes(PrimitiveType type);
    public static List`1<PrimitiveType> GetBinaryOperatorPossibleTypes(object value);
    public static List`1<PrimitiveType> GetBinaryOperatorPossibleTypes(object value, PrimitiveType primitiveType);
    public static List`1<PrimitiveType> GetPrimitiveTypes(object value);
    public static PrimitiveType GetPrimitiveType(object value);
    public static List`1<PrimitiveType> GetPrimitiveTypes(decimal value);
    public static PrimitiveType GetPrimitiveType(decimal value);
    public static object GetDefaultValue(string fullTypeName);
    public static void GetMinAndMaxValues(PrimitiveType type, Decimal& minValue, Decimal& maxValue);
    public static object GetDefaultValue(PrimitiveType type);
    public static PrimitiveType ToPrimitiveType(IElement type);
    public static PrimitiveType PromoteType(IElement type);
    public static PrimitiveType PromoteType(IElement type, UnaryOperatorType unaryOperator);
    public static PrimitiveType PromoteType(PrimitiveType type);
    public static PrimitiveType PromoteType(PrimitiveType type, UnaryOperatorType unaryOperator);
    public static PrimitiveType PromoteTypes(IElement firstType, IElement secondType);
    public static PrimitiveType PromoteTypes(PrimitiveType first, PrimitiveType second);
    public static bool IsIntegerType(object value);
    public static bool IsIntegerType(PrimitiveType type);
}
public class DevExpress.CodeParser.Property : MemberWithParameters {
    private static int INT_MaintainanceComplexity;
    private Expression _Initializer;
    private bool _IsAutoImplemented;
    private bool _GenerateAccessors;
    private bool _GenerateParens;
    private SourceRange _IndexOpenRange;
    private SourceRange _IndexCloseRange;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    [DescriptionAttribute("True if this property can be read.")]
[CategoryAttribute("Details")]
[DefaultValueAttribute("True")]
public bool HasGetter { get; }
    [DescriptionAttribute("True if this property can be written to.")]
[CategoryAttribute("Details")]
public bool HasSetter { get; }
    [DescriptionAttribute("True if this property can be read.")]
[CategoryAttribute("Details")]
[DefaultValueAttribute("True")]
[ObsoleteAttribute("Use HasGetter instead.")]
[EditorBrowsableAttribute("1")]
public bool IsReadable { get; }
    [DescriptionAttribute("True if this property can be written to.")]
[CategoryAttribute("Details")]
[ObsoleteAttribute("Use HasSetter instead.")]
[EditorBrowsableAttribute("1")]
public bool IsWritable { get; }
    [DescriptionAttribute("True if this property is an indexer.")]
[CategoryAttribute("Details")]
[DefaultValueAttribute("False")]
public bool IsIndexed { get; }
    [DescriptionAttribute("Gets the Set accessor for this property, if available. Returns null if this property is read-only.")]
[CategoryAttribute("Family")]
public Set Setter { get; }
    [DescriptionAttribute("Returns the Get accessor for this property, if available. Returns null if this property is write-only.")]
[CategoryAttribute("Family")]
public Get Getter { get; }
    public SourceRange IndexOpenRange { get; public set; }
    public SourceRange IndexCloseRange { get; public set; }
    public bool IsNewContext { get; }
    public bool IsAutoImplemented { get; public set; }
    [BrowsableAttribute("False")]
public bool GenerateAccessors { get; public set; }
    [BrowsableAttribute("False")]
public bool GenerateParens { get; public set; }
    public Expression Initializer { get; public set; }
    private IMethodElement DevExpress.CodeParser.IPropertyElement.GetMethod { get; }
    private IMethodElement DevExpress.CodeParser.IPropertyElement.SetMethod { get; }
    private IExpression DevExpress.CodeParser.IPropertyElement.Initializer { get; }
    public Property(string name);
    public Property(string type, string name);
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    [EditorBrowsableAttribute("1")]
public void SetIndexedPropertyNameWithoutImplementsQualifier();
    public virtual int GetCyclomaticComplexity();
    public virtual MemberVisibility GetDefaultVisibility();
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public bool get_HasGetter();
    public bool get_HasSetter();
    public bool get_IsReadable();
    public bool get_IsWritable();
    public sealed virtual bool get_IsIndexed();
    public Set get_Setter();
    public Get get_Getter();
    public SourceRange get_IndexOpenRange();
    public void set_IndexOpenRange(SourceRange value);
    public SourceRange get_IndexCloseRange();
    public void set_IndexCloseRange(SourceRange value);
    public virtual bool get_IsNewContext();
    public sealed virtual bool get_IsAutoImplemented();
    public void set_IsAutoImplemented(bool value);
    public bool get_GenerateAccessors();
    public void set_GenerateAccessors(bool value);
    public bool get_GenerateParens();
    public void set_GenerateParens(bool value);
    public Expression get_Initializer();
    public void set_Initializer(Expression value);
    private sealed virtual override IMethodElement DevExpress.CodeParser.IPropertyElement.get_GetMethod();
    private sealed virtual override IMethodElement DevExpress.CodeParser.IPropertyElement.get_SetMethod();
    private sealed virtual override IExpression DevExpress.CodeParser.IPropertyElement.get_Initializer();
    private sealed virtual override void DevExpress.CodeParser.IPropertyElementModifier.SetGetMethod(IMethodElement method);
    private sealed virtual override void DevExpress.CodeParser.IPropertyElementModifier.SetSetMethod(IMethodElement method);
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
}
public abstract class DevExpress.CodeParser.PropertyAccessor : Accessor {
    private TypeReferenceExpression _AccessorType;
    private bool _IsPrototype;
    public Property ParentProperty { get; }
    public TypeReferenceExpression AccessorType { get; public set; }
    public LanguageElementType ElementType { get; }
    public bool IsPrototype { get; public set; }
    [EditorBrowsableAttribute("1")]
protected ITypeReferenceExpression Type { get; }
    [DescriptionAttribute("The name of the property that contains this accessor.")]
[CategoryAttribute("Family")]
public string PropertyName { get; }
    [EditorBrowsableAttribute("1")]
public MethodTypeEnum MethodType { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsAsynchronous { get; }
    private string DevExpress.CodeParser.IMethodElement.Lib { get; }
    private string DevExpress.CodeParser.IMethodElement.Alias { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsConstructor { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsSerializationConstructor { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsDestructor { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsWebMethod { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsTypeInitializer { get; }
    private IBaseVariable DevExpress.CodeParser.IMethodElement.ImplicitVariable { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsMemberFunctionConst { get; }
    private IExpressionCollection DevExpress.CodeParser.IMethodElement.HandlesExpressions { get; }
    private IExpressionCollection DevExpress.CodeParser.IMethodElement.ImplementsExpressions { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsClassOperator { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsImplicitCast { get; }
    private bool DevExpress.CodeParser.IMethodElement.IsExplicitCast { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsIterator { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsDefaultVisibility { get; }
    private IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.Attributes { get; }
    private MemberVisibility DevExpress.CodeParser.IMemberElement.Visibility { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsAbstract { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsVirtual { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsOverride { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsNew { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsPartial { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsStatic { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsSealed { get; }
    private bool DevExpress.CodeParser.IMemberElement.IsExplicitInterfaceMember { get; }
    private IExpression DevExpress.CodeParser.IMemberElement.NameQualifier { get; }
    private string DevExpress.CodeParser.IMemberElement.Signature { get; }
    private IExpressionCollection DevExpress.CodeParser.IMemberElement.Implements { get; }
    private bool DevExpress.CodeParser.IGenericElement.IsGeneric { get; }
    private ITypeParameterCollection DevExpress.CodeParser.IGenericElement.TypeParameters { get; }
    private IGenericElement DevExpress.CodeParser.IGenericElement.GenericTemplate { get; }
    private bool DevExpress.CodeParser.IGenericElement.IsActivatedGeneric { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.IHasType.Type { get; }
    private IParameterElementCollection DevExpress.CodeParser.IWithParameters.Parameters { get; }
    public LanguageElementCollection Parameters { get; }
    public int ParameterCount { get; }
    protected virtual string GetAccessorName();
    public virtual int GetCyclomaticComplexity();
    public virtual int GetImageIndex();
    public void AddParameter(Param parameter);
    public void AddParameters(LanguageElementCollection parameters);
    public void RemoveParameter(Param parameter);
    public void RemoveParameters(LanguageElementCollection parameters);
    public void InsertParameter(int index, Param parameter);
    public Property get_ParentProperty();
    public TypeReferenceExpression get_AccessorType();
    public void set_AccessorType(TypeReferenceExpression value);
    public virtual LanguageElementType get_ElementType();
    public bool get_IsPrototype();
    public void set_IsPrototype(bool value);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual ITypeReferenceExpression get_Type();
    public string get_PropertyName();
    public virtual MethodTypeEnum get_MethodType();
    public virtual MemberVisibility[] GetValidVisibilities();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsAsynchronous();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsExtensionMethod();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsExtensionMethod(ISourceTreeResolver resolver);
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsMainProcedure();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.IsInitializeComponent();
    private sealed virtual override string DevExpress.CodeParser.IMethodElement.get_Lib();
    private sealed virtual override string DevExpress.CodeParser.IMethodElement.get_Alias();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsConstructor();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsSerializationConstructor();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsDestructor();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsWebMethod();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsTypeInitializer();
    private sealed virtual override IBaseVariable DevExpress.CodeParser.IMethodElement.get_ImplicitVariable();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsMemberFunctionConst();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMethodElement.get_HandlesExpressions();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMethodElement.get_ImplementsExpressions();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsClassOperator();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsImplicitCast();
    private sealed virtual override bool DevExpress.CodeParser.IMethodElement.get_IsExplicitCast();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsIterator();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsDefaultVisibility();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.GetOverrideCode();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.GetOverrideCode(bool callBase);
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.GetOverrideCode(bool callBase, string beforeCode, string afterCode);
    private sealed virtual override IAttributeElementCollection DevExpress.CodeParser.IHasAttributes.get_Attributes();
    private sealed virtual override MemberVisibility DevExpress.CodeParser.IMemberElement.get_Visibility();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsAbstract();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsVirtual();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsOverride();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsNew();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsPartial();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsStatic();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsSealed();
    private sealed virtual override bool DevExpress.CodeParser.IMemberElement.get_IsExplicitInterfaceMember();
    private sealed virtual override IExpression DevExpress.CodeParser.IMemberElement.get_NameQualifier();
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IMemberElement.get_Implements();
    private sealed virtual override bool DevExpress.CodeParser.IGenericElement.get_IsGeneric();
    private sealed virtual override ITypeParameterCollection DevExpress.CodeParser.IGenericElement.get_TypeParameters();
    private sealed virtual override IGenericElement DevExpress.CodeParser.IGenericElement.get_GenericTemplate();
    private sealed virtual override bool DevExpress.CodeParser.IGenericElement.get_IsActivatedGeneric();
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.IHasType.get_Type();
    private sealed virtual override IParameterElementCollection DevExpress.CodeParser.IWithParameters.get_Parameters();
    public sealed virtual LanguageElementCollection get_Parameters();
    public sealed virtual int get_ParameterCount();
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.AddParameter(IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.RemoveParameter(IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IWithParametersModifier.InsertParameter(int index, IParameterElement parameter);
    private sealed virtual override void DevExpress.CodeParser.IGenericElementModifier.AddTypeParameter(ITypeParameter typeParameter);
    private sealed virtual override void DevExpress.CodeParser.IGenericElementModifier.InsertTypeParameter(int index, ITypeParameter typeParameter);
    private sealed virtual override void DevExpress.CodeParser.IGenericElementModifier.RemoveTypeParameter(ITypeParameter typeParameter);
    private sealed virtual override void DevExpress.CodeParser.IMethodElementModifier.SetIsClassOperator(bool isClassOperator);
    private sealed virtual override void DevExpress.CodeParser.IMethodElementModifier.SetIsExplicitCast(bool isExplicitCast);
    private sealed virtual override void DevExpress.CodeParser.IMethodElementModifier.SetIsImplicitCast(bool isImplicitCast);
}
public class DevExpress.CodeParser.PropertyFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
}
public class DevExpress.CodeParser.PublicParameterLessMethodFilter : ElementFilterBase {
    private ComplexAndFilter _Filter;
    private ComplexAndFilter BuildFilter();
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public virtual IElementCollection Apply(IElementCollection elements);
}
[ObsoleteAttribute("Use QualifiedExpressionHelper instead.")]
public class DevExpress.CodeParser.QuailifiedExpressionHelper : QualifiedExpressionHelper {
}
public class DevExpress.CodeParser.QualifiedAliasExpression : ElementReferenceExpression {
    private bool _IsGlobal;
    public LanguageElementType ElementType { get; }
    public bool IsGlobal { get; public set; }
    private bool DevExpress.CodeParser.IQualifiedAliasExpression.IsGlobal { get; }
    public QualifiedAliasExpression(string name);
    public QualifiedAliasExpression(string name, SourceRange range);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public bool get_IsGlobal();
    public void set_IsGlobal(bool value);
    private sealed virtual override bool DevExpress.CodeParser.IQualifiedAliasExpression.get_IsGlobal();
}
public class DevExpress.CodeParser.QualifiedElementReference : ElementReferenceExpression {
    private Expression _Source;
    public Expression Qualifier { get; public set; }
    public bool HasCleanReferences { get; }
    public QualifiedElementReference(string name);
    public QualifiedElementReference(string name, SourceRange namerange);
    public QualifiedElementReference(Expression source, string name, SourceRange namerange);
    private void SetSource(Expression source);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual Expression get_Qualifier();
    public virtual void set_Qualifier(Expression value);
    public virtual bool get_HasCleanReferences();
}
public class DevExpress.CodeParser.QualifiedExpressionHelper : object {
    private static bool IsSimpleReference(IElement element);
    public static int GetLevel(IHasQualifier element);
    public static LanguageElement GetByLevel(LanguageElement element, int level);
    public static LanguageElement GetStartElement(LanguageElement element);
    public static LanguageElement GetEndElement(LanguageElement element);
    private static LanguageElement GetEndElement(LanguageElement element, bool expressionOnly);
    public static LanguageElement GetEndExpression(LanguageElement element);
    public static bool HasCleanReferences(IElement element);
}
public class DevExpress.CodeParser.QualifiedMethodReference : CppMethodReferenceExpression {
    public LanguageElementType ElementType { get; }
    public QualifiedMethodReference(Expression source, string name, SourceRange namerange);
    protected virtual string GetNameWithQualifier();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.QualifiedNestedReference : CppQualifiedElementReference {
    public LanguageElementType ElementType { get; }
    public QualifiedNestedReference(Expression source, string name, SourceRange namerange);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.QualifiedNestedTypeReference : TypeReferenceExpression {
    public LanguageElementType ElementType { get; }
    public QualifiedNestedTypeReference(TypeReferenceExpression source, string name, SourceRange namerange);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.QualifiedTypeReferenceExpression : TypeReferenceExpression {
    public LanguageElementType ElementType { get; }
    public QualifiedTypeReferenceExpression(string type);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
[EditorBrowsableAttribute("1")]
public class DevExpress.CodeParser.QueryableCollectionReferenceExpression : Expression {
    private Expression _Expression;
    private TypeReferenceExpression _Type;
    private ExpressionCollection _AdditionalExpressions;
    public Expression Expression { get; public set; }
    public ExpressionCollection AdditionalExpressions { get; }
    public LanguageElementType ElementType { get; }
    private IExpression DevExpress.CodeParser.IQueryableCollectionReferenceExpression.Expression { get; }
    private IExpressionCollection DevExpress.CodeParser.IQueryableCollectionReferenceExpression.AdditionalExpressions { get; }
    public QueryableCollectionReferenceExpression(Expression expression, TypeReferenceExpression type);
    private MethodCallExpression GetMethodCall(Expression expression, string name, TypeReferenceExpressionCollection typeArguments);
    private MethodCallExpression GetAsQueryableMethodCall(Expression expression);
    private MethodCallExpression GetAsEnumerableMethodCall(Expression expression);
    private MethodCallExpression GetCastMethodCall(Expression expression, TypeReferenceExpression type);
    private TypeReferenceExpression CreateSystemObjectTypeReference();
    private ExpressionCollection GetAdditionalExpressions();
    protected void SetExpression(Expression expression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public ExpressionCollection get_AdditionalExpressions();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IExpression DevExpress.CodeParser.IQueryableCollectionReferenceExpression.get_Expression();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IQueryableCollectionReferenceExpression.get_AdditionalExpressions();
}
public class DevExpress.CodeParser.QueryExpression : QueryExpressionBase {
    private Expression _Translation;
    private bool _IsTranslation;
    public LanguageElementType ElementType { get; }
    public Expression Translation { get; public set; }
    public bool IsTranslation { get; public set; }
    private IExpression DevExpress.CodeParser.IQueryExpression.Translation { get; }
    private Expression BuildQueryTranslation();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Translation();
    public void set_Translation(Expression value);
    public bool get_IsTranslation();
    public void set_IsTranslation(bool value);
    private sealed virtual override IExpression DevExpress.CodeParser.IQueryExpression.get_Translation();
}
public abstract class DevExpress.CodeParser.QueryExpressionBase : Expression {
    public virtual IElement Resolve(ISourceTreeResolver resolver);
}
public class DevExpress.CodeParser.QueryIdent : InitializedVariable {
    public LanguageElementType ElementType { get; }
    public QueryIdent(string name);
    public QueryIdent(string type, string name);
    public QueryIdent(string type, string name, Expression expr);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.QueuedDelete : QueuedEdit {
    private static string STR_Delete;
    private LanguageElementCollection _SeveredNodes;
    private LanguageElement _StartDelete;
    private LanguageElement _EndDelete;
    public LanguageElementType ElementType { get; }
    [EditorBrowsableAttribute("1")]
public LanguageElementCollection SeveredNodes { get; }
    public QueuedDelete(SourceRange sourceRange);
    public QueuedDelete(LanguageElement element);
    public QueuedDelete(LanguageElement firstSibling, LanguageElement lastSibling);
    private void ValidateElement(LanguageElement element);
    private void ValidateSiblings(LanguageElement firstSibling, LanguageElement lastSibling);
    private void BorrowNodesFromTree(LanguageElement firstSibling, LanguageElement lastSibling);
    private void BorrowNodeFromTree(LanguageElement element);
    protected virtual void ApplyEdit(IDocument iDocument, bool format);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public LanguageElementCollection get_SeveredNodes();
}
public abstract class DevExpress.CodeParser.QueuedEdit : LanguageElement {
    private bool _AppliedEdit;
    private SourceRange _BoundRange;
    public SourceRange BoundRange { get; }
    protected abstract virtual void ApplyEdit(IDocument iDocument, bool format);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    private void SetPushableOptions(bool start, bool end);
    private void GetPushableOptions(Boolean& start, Boolean& end);
    public void Apply(IDocument iDocument);
    public void Apply(IDocument iDocument, bool format);
    public void BindToCode(IDisposableEditPointFactory document);
    public void RemoveBinding();
    public SourceRange get_BoundRange();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.QueuedEditCollection : CollectionBase {
    public QueuedEdit Item { get; public set; }
    public int Add(QueuedEdit edit);
    public void AddRange(QueuedEditCollection edits);
    public void Remove(QueuedEdit edit);
    public void BindToCode(IDisposableEditPointFactory factory);
    public void RemoveBinding();
    public QueuedEdit get_Item(int index);
    public void set_Item(int index, QueuedEdit value);
}
public class DevExpress.CodeParser.QueuedInsert : QueuedEdit {
    private string _NewCode;
    public LanguageElementType ElementType { get; }
    public string NewCode { get; public set; }
    public QueuedInsert(SourcePoint insertionPoint, string newCode);
    protected virtual void ApplyEdit(IDocument iDocument, bool format);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_NewCode();
    public void set_NewCode(string value);
}
public class DevExpress.CodeParser.QueuedReplace : QueuedDelete {
    private static string STR_Replace;
    private string _NewCode;
    private bool _UseTextExpansion;
    public LanguageElementType ElementType { get; }
    public string NewCode { get; public set; }
    public bool UseTextExpansion { get; public set; }
    public QueuedReplace(SourceRange sourceRange, string newCode);
    public QueuedReplace(LanguageElement element, string newCode);
    public QueuedReplace(LanguageElement firstSibling, LanguageElement lastSibling, string newCode);
    private void ReplaceText(IDocument iDocument, bool format);
    protected virtual void ApplyEdit(IDocument iDocument, bool format);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_NewCode();
    public void set_NewCode(string value);
    public bool get_UseTextExpansion();
    public void set_UseTextExpansion(bool value);
}
public enum DevExpress.CodeParser.QuoteType : Enum {
    public int value__;
    public static QuoteType None;
    public static QuoteType SingleQuote;
    public static QuoteType DoubleQuote;
}
public class DevExpress.CodeParser.RaiseEvent : Statement {
    private Expression _Expression;
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; }
    public RaiseEvent(Expression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
}
public class DevExpress.CodeParser.RangeTransform : object {
    private static IComparer _RangeComparer;
    private static IComparer _OriginalPointComparer;
    private static IComparer _TransformedPointComparer;
    private int _StartLine;
    private int _EndLine;
    private int _StartOffset;
    private int _EndOffset;
    private int _LineTransform;
    private int _OffsetTransform;
    public static IComparer RangeComparer { get; }
    public static IComparer OriginalPointComparer { get; }
    public static IComparer TransformedPointComparer { get; }
    public int StartLine { get; public set; }
    public int EndLine { get; public set; }
    public int StartOffset { get; public set; }
    public int EndOffset { get; public set; }
    public bool HasTransformValue { get; }
    public RangeTransform(RangeTransform source);
    public RangeTransform(TextRange range, int lineTransform, int offsetTransform);
    private void Move(int line, int offset);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public int CompareTo(RangeTransform transform);
    public int CompareToTransformed(TextPoint point);
    public int CompareToOriginal(TextPoint point);
    public bool IsStart(TextPoint point);
    public bool IsContainedInTransformed(TextRange range);
    public bool ContainsOriginal(int line, int offset);
    public bool ContainsTransformed(int line, int offset);
    public bool StartsAfter(TextPoint point);
    public void Shift(int line, int lineTransform, int offsetTransform);
    public void Apply(Int32& line, Int32& offset);
    public void Restore(Int32& line, Int32& offset);
    public void TrimStart(TextPoint point);
    public void TrimEnd(TextPoint point);
    public RangeTransform Insert(TextRange range);
    public RangeTransform Delete(TextRange range);
    public static IComparer get_RangeComparer();
    public static IComparer get_OriginalPointComparer();
    public static IComparer get_TransformedPointComparer();
    public int get_StartLine();
    public void set_StartLine(int value);
    public int get_EndLine();
    public void set_EndLine(int value);
    public int get_StartOffset();
    public void set_StartOffset(int value);
    public int get_EndOffset();
    public void set_EndOffset(int value);
    public bool get_HasTransformValue();
}
public class DevExpress.CodeParser.RazorFunctions : AspCodeEmbedding {
    public bool IsFunctionsEmbedding { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual bool get_IsFunctionsEmbedding();
    public virtual MemberVisibility[] GetValidVisibilities();
}
public class DevExpress.CodeParser.RazorHelper : AspCodeEmbedding {
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual MemberVisibility[] GetValidVisibilities();
}
public class DevExpress.CodeParser.RazorInheritsDirective : AspDirective {
    private string _Model;
    private SourceRange _ModelRange;
    public LanguageElementType ElementType { get; }
    public string Model { get; public set; }
    public SourceRange ModelRange { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public string get_Model();
    public void set_Model(string value);
    public SourceRange get_ModelRange();
    public void set_ModelRange(SourceRange value);
}
public class DevExpress.CodeParser.RazorInlineHtmlExpression : Expression {
    private HtmlElement _HtmlElement;
    public HtmlElement HtmlElement { get; public set; }
    public LanguageElementType ElementType { get; }
    public RazorInlineHtmlExpression(HtmlElement htmlElement);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public void SetHtmlElement(HtmlElement htmlElement);
    public HtmlElement get_HtmlElement();
    public void set_HtmlElement(HtmlElement value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.RazorModelDirective : AspDirective {
    private string _Model;
    private SourceRange _ModelRange;
    public LanguageElementType ElementType { get; }
    public string Model { get; public set; }
    public SourceRange ModelRange { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public string get_Model();
    public void set_Model(string value);
    public SourceRange get_ModelRange();
    public void set_ModelRange(SourceRange value);
}
public class DevExpress.CodeParser.RazorSection : AspCodeEmbedding {
    private DotNetLanguageType _DotNetLanguageType;
    public LanguageElementType ElementType { get; }
    public DotNetLanguageType DotNetLanguageType { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public DotNetLanguageType get_DotNetLanguageType();
    public void set_DotNetLanguageType(DotNetLanguageType value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.ReadOnlyHashtable : Hashtable {
    private static ReadOnlyHashtable _Empty;
    public object Item { get; public set; }
    public static ReadOnlyHashtable Empty { get; }
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual void Remove(object key);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public static ReadOnlyHashtable get_Empty();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.ReadOnlyLanguageElementCollection : ReadOnlyCollectionBase {
    public LanguageElement Item { get; }
    public ReadOnlyLanguageElementCollection(IList source);
    public int IndexOf(LanguageElement element);
    public LanguageElement FindByName(string name);
    public bool Contains(LanguageElement element);
    public LanguageElement get_Item(int index);
}
public class DevExpress.CodeParser.ReadOnlyNameValueCollection : NameValueCollection {
    private static ReadOnlyNameValueCollection _Empty;
    public static ReadOnlyNameValueCollection Empty { get; }
    public virtual void Add(string name, string value);
    public virtual void Remove(string name);
    public virtual void Set(string name, string value);
    public static ReadOnlyNameValueCollection get_Empty();
}
[DefaultMemberAttribute("Item")]
internal class DevExpress.CodeParser.ReadOnlySortedList : SortedList {
    private static ReadOnlySortedList _Empty;
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public static ReadOnlySortedList Empty { get; }
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual void Remove(object key);
    public virtual void RemoveAt(int index);
    public virtual void SetByIndex(int index, object value);
    public virtual bool get_IsReadOnly();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public static ReadOnlySortedList get_Empty();
}
public class DevExpress.CodeParser.ReadOnlyStringCollection : StringCollection {
    private static ReadOnlyStringCollection _Empty;
    public static ReadOnlyStringCollection Empty { get; }
    public static ReadOnlyStringCollection get_Empty();
}
public class DevExpress.CodeParser.ReDim : Statement {
    private bool _HasPreserve;
    private ExpressionCollection _Expressions;
    public LanguageElementType ElementType { get; }
    public bool HasPreserve { get; }
    public ExpressionCollection Expressions { get; }
    public ReDim(bool hasPreserve, ExpressionCollection expressions);
    private void SetExpressionsModifiedFlag(ExpressionCollection expressions);
    private void SetExpressionsModifiedFlag(ExpressionCollection expressions, bool force);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public bool get_HasPreserve();
    public ExpressionCollection get_Expressions();
}
public class DevExpress.CodeParser.ReDimExpression : Expression {
    private LanguageElementCollection _Modifiers;
    private SourceRange _NameRange;
    private Expression _Expression;
    public LanguageElementType ElementType { get; }
    public LanguageElementCollection Modifiers { get; }
    public Expression Expression { get; public set; }
    public SourceRange NameRange { get; public set; }
    private IExpression DevExpress.CodeParser.IReDimExpression.Expression { get; }
    private ICollection DevExpress.CodeParser.IReDimExpression.Modifiers { get; }
    private void SetExpression(Expression expression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public void AddModifiers(IEnumerable`1<LanguageElement> modifiers);
    public void AddModifiers(IEnumerable`1<ArrayNameModifier> modifiers);
    public void AddModifier(ArrayNameModifier modifier);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual LanguageElementType get_ElementType();
    public LanguageElementCollection get_Modifiers();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    private sealed virtual override IExpression DevExpress.CodeParser.IReDimExpression.get_Expression();
    private sealed virtual override ICollection DevExpress.CodeParser.IReDimExpression.get_Modifiers();
}
public abstract class DevExpress.CodeParser.ReferenceExpressionBase : Expression {
    private TypeReferenceExpressionCollection _TypeArguments;
    private Expression _NameQualifier;
    private bool _IsMulOperator;
    public Expression Qualifier { get; public set; }
    [ObsoleteAttribute("Use Qualifier instead")]
[EditorBrowsableAttribute("1")]
public Expression Source { get; public set; }
    public bool IsGeneric { get; }
    public TypeReferenceExpressionCollection TypeArguments { get; public set; }
    public bool IsTypeArgument { get; }
    public ReferenceExpressionBase ParentGenericReference { get; }
    public int TypeArity { get; public set; }
    public Expression NameQualifier { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsMulOperator { get; public set; }
    private ITypeReferenceExpressionCollection DevExpress.CodeParser.IGenericExpression.TypeArguments { get; }
    private IExpression DevExpress.CodeParser.IWithSource.Source { get; }
    private IExpression DevExpress.CodeParser.IReferenceExpression.NameQualifier { get; }
    public string FullSignature { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    [EditorBrowsableAttribute("1")]
protected void SetTypeArguments(TypeReferenceExpressionCollection typeArguments);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual string ToString();
    internal void GetDataFrom(BaseElement source);
    public QualifiedElementReference CreateQualifiedElementReference();
    public virtual bool IsIdenticalTo(Expression expression);
    public void AddTypeArgument(TypeReferenceExpression typeArgument);
    public void AddTypeArguments(IEnumerable`1<TypeReferenceExpression> typeArguments);
    public abstract virtual Expression get_Qualifier();
    public abstract virtual void set_Qualifier(Expression value);
    public sealed virtual Expression get_Source();
    public sealed virtual void set_Source(Expression value);
    public virtual bool get_IsGeneric();
    public virtual TypeReferenceExpressionCollection get_TypeArguments();
    public virtual void set_TypeArguments(TypeReferenceExpressionCollection value);
    public bool get_IsTypeArgument();
    public ReferenceExpressionBase get_ParentGenericReference();
    public virtual int get_TypeArity();
    public virtual void set_TypeArity(int value);
    public Expression get_NameQualifier();
    public void set_NameQualifier(Expression value);
    public sealed virtual bool get_IsMulOperator();
    public void set_IsMulOperator(bool value);
    private sealed virtual override ITypeReferenceExpressionCollection DevExpress.CodeParser.IGenericExpression.get_TypeArguments();
    private sealed virtual override IExpression DevExpress.CodeParser.IWithSource.get_Source();
    private sealed virtual override IExpression DevExpress.CodeParser.IReferenceExpression.get_NameQualifier();
    public sealed virtual string get_FullSignature();
}
public class DevExpress.CodeParser.ReferenceFilter : ElementFilterBase {
    private ElementRangeFilter _RangeFilter;
    private bool _HasThisOrBaseReferences;
    public bool HasThisOrBaseReferences { get; }
    public ReferenceFilter(SourceRange range);
    public virtual bool Apply(IElement element);
    public bool get_HasThisOrBaseReferences();
}
public class DevExpress.CodeParser.RegionDirective : PreprocessorDirective {
    private int _EndTokenLength;
    private int _StartTokenLength;
    private SourceRange _NameRange;
    public bool CompletesPrevious { get; }
    public LanguageElementType ElementType { get; }
    public int EndTokenLength { get; }
    public int StartTokenLength { get; }
    [ObsoleteAttribute("Use Range instead.")]
public SourceRange FullRange { get; }
    public SourceRange NameRange { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual bool Contains(int line, int offset);
    public virtual int GetImageIndex();
    [EditorBrowsableAttribute("1")]
public void SetStartTokenLength(Token token);
    [EditorBrowsableAttribute("1")]
public void SetStartTokenLength(int value);
    [EditorBrowsableAttribute("1")]
public void SetEndTokenLength(Token token);
    [EditorBrowsableAttribute("1")]
public void SetEndTokenLength(int value);
    public void ToggleCollapsedState();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public static bool Equals(RegionDirective region1, RegionDirective region2);
    public RegionDirectiveCollection GetSubRegions();
    public virtual bool get_CompletesPrevious();
    public virtual LanguageElementType get_ElementType();
    public int get_EndTokenLength();
    public int get_StartTokenLength();
    public SourceRange get_FullRange();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.RegionDirectiveCollection : NodeList {
    public RegionDirective Item { get; }
    protected virtual NodeList CreateInstance();
    public void Add(RegionDirective aRegionDirective);
    public void Remove(RegionDirective aRegionDirective);
    public RegionDirective Find(string aRegionDirective);
    public RegionDirective Find(RegionDirective region);
    public bool Contains(string aRegionDirective);
    public bool Contains(RegionDirective region);
    public RegionDirective get_Item(int aIndex);
}
public class DevExpress.CodeParser.RegionDirectiveFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
}
public class DevExpress.CodeParser.RegisterDirective : AspDirective {
    public LanguageElementType ElementType { get; }
    public string Assembly { get; public set; }
    public string Namespace { get; public set; }
    public string Src { get; public set; }
    public string TagName { get; public set; }
    public string TagPrefix { get; public set; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Assembly();
    public void set_Assembly(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Src();
    public void set_Src(string value);
    public string get_TagName();
    public void set_TagName(string value);
    public string get_TagPrefix();
    public void set_TagPrefix(string value);
}
public class DevExpress.CodeParser.ReinterpretCastExpression : CppTypeCastExpression {
    public LanguageElementType ElementType { get; }
    protected virtual string GetString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.RelationalOperation : BinaryOperatorExpression {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public RelationalOperator RelationalOperator { get; public set; }
    private RelationalOperator DevExpress.CodeParser.IRelationalOperationExpression.RelationalOperator { get; }
    public RelationalOperation(Expression left, Token token, Expression right);
    public RelationalOperation(Expression left, Token token, Expression right, RelationalOperator relationalOperator, SourceRange range);
    public RelationalOperation(Expression left, RelationalOperator op, Expression right);
    private bool CheckSymetric(RelationalOperation op);
    private bool CheckAsymetric(RelationalOperation op);
    private bool CheckEquality(RelationalOperation op);
    private bool CheckInequality(RelationalOperation op);
    private bool CheckLessThan(RelationalOperation op);
    private bool CheckGreaterThan(RelationalOperation op);
    private bool CheckLessOrEqual(RelationalOperation op);
    private bool CheckGreaterOrEqual(RelationalOperation op);
    protected virtual void SetRelationalOperator(RelationalOperator op);
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public static RelationalOperator InvertRelationalOperator(RelationalOperator op);
    public static BinaryOperatorType GetBinaryOperatorType(RelationalOperator op);
    public static RelationalOperator GetRelationalOperatorType(BinaryOperatorType op);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public RelationalOperator get_RelationalOperator();
    public void set_RelationalOperator(RelationalOperator value);
    private sealed virtual override RelationalOperator DevExpress.CodeParser.IRelationalOperationExpression.get_RelationalOperator();
}
public enum DevExpress.CodeParser.RelationalOperator : Enum {
    public byte value__;
    public static RelationalOperator None;
    public static RelationalOperator Equality;
    public static RelationalOperator Inequality;
    public static RelationalOperator LessThan;
    public static RelationalOperator GreaterThan;
    public static RelationalOperator LessOrEqual;
    public static RelationalOperator GreaterOrEqual;
    public static RelationalOperator Like;
    public static RelationalOperator StrictEquality;
    public static RelationalOperator StrictInequality;
}
public class DevExpress.CodeParser.RemoveHandler : HandlerStatement {
    public LanguageElementType ElementType { get; }
    public RemoveHandler(Expression expression, Expression address);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public enum DevExpress.CodeParser.RepeatCount : Enum {
    public int value__;
    public static RepeatCount Once;
    public static RepeatCount ZeroOrOnce;
    public static RepeatCount ZeroOrMore;
    public static RepeatCount OnceOrMore;
}
public class DevExpress.CodeParser.Resume : FlowBreak {
    private string _Label;
    private bool _HasNextClause;
    public LanguageElementType ElementType { get; }
    public string Label { get; public set; }
    public bool HasNextClause { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_Label();
    public void set_Label(string value);
    public bool get_HasNextClause();
    public void set_HasNextClause(bool value);
}
public class DevExpress.CodeParser.Return : FlowBreak {
    private static int INT_MaintainanceComplexity;
    private Expression _Expression;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IReturnStatement.Expression { get; }
    public Return(Expression expression);
    protected virtual int get_ThisMaintenanceComplexity();
    protected void SetExpression(Expression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual LanguageElement FindTarget();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IReturnStatement.get_Expression();
}
internal class DevExpress.CodeParser.ReverseSorter : Sorter {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
public class DevExpress.CodeParser.SafeCastExpression : CppTypeCastExpression {
    public LanguageElementType ElementType { get; }
    protected virtual string GetString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ScannerExtension : object {
    private Queue _TokenBlocks;
    private Token GetTokenFromBlock(TokenBlock block);
    public void EnqueueBlock(SourceRange range, int type);
    public void EnqueueBlock(TokenBlock block);
    public Token Scan(int startLine, int startOffset);
    public Token Scan(SourcePoint point);
    public TokenCollection GetTailTokens();
}
public enum DevExpress.CodeParser.SearchScope : Enum {
    public int value__;
    public static SearchScope ThisDeclaration;
    public static SearchScope AllPartialClasses;
}
public class DevExpress.CodeParser.SelectExpression : QueryExpressionBase {
    private LanguageElementCollection _ReturnedElements;
    [EditorBrowsableAttribute("1")]
public LanguageElementCollection ReturnedElements { get; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public void AddReturnedExpression(LanguageElement element);
    public void AddReturnedElements(IEnumerable`1<LanguageElement> elements);
    public void AddReturnedElement(LanguageElement element);
    public LanguageElementCollection get_ReturnedElements();
    public virtual LanguageElementType get_ElementType();
    public virtual string ToString();
}
public class DevExpress.CodeParser.ServerControlElement : HtmlElement {
    private ActiveHtmlTagPart _ActiveHtmlTagPart;
    [EditorBrowsableAttribute("1")]
public ActiveHtmlTagPart ActiveHtmlTagPart { get; }
    public LanguageElementType ElementType { get; }
    public string TagPrefix { get; }
    public string TagName { get; }
    public SourceRange TagNameRange { get; }
    public SourceRange TagPrefixRange { get; }
    public SourceRange CloseNameRange { get; }
    public SourceRange CloseTagNameRange { get; }
    public SourceRange CloseTagPrefixRange { get; }
    [EditorBrowsableAttribute("1")]
public void EvaluateActivePart(SourcePoint activePoint);
    private bool SetActivePart(SourcePoint activePoint, SourceRange propertyRange, SourceRange qualifierRange);
    public ActiveHtmlTagPart get_ActiveHtmlTagPart();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public string get_TagPrefix();
    public string get_TagName();
    public SourceRange get_TagNameRange();
    public SourceRange get_TagPrefixRange();
    public SourceRange GetPropertyRange(SourceRange& qualifierRange);
    public SourceRange GetClosePropertyRange(SourceRange& qualifierRange);
    private SourceRange GetPropertyRangeCore(SourcePoint end, SourceRange& qualifierRange);
    public string GetPropertyName(String& qualifierName);
    public SourceRange get_CloseNameRange();
    public virtual SourceRange get_CloseTagNameRange();
    public SourceRange get_CloseTagPrefixRange();
}
public class DevExpress.CodeParser.Set : PropertyAccessor {
    private static string STR_Value;
    private LanguageElementCollection _Parameters;
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public LanguageElementCollection Parameters { get; public set; }
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string GetValueParameterName();
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual LanguageElementCollection get_Parameters();
    public virtual void set_Parameters(LanguageElementCollection value);
}
public class DevExpress.CodeParser.ShortInitializeExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private ExpressionCollection _Arguments;
    private TextRangeWrapper _ParensRange;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public ExpressionCollection Arguments { get; public set; }
    public bool CanBeStatement { get; }
    public bool IsGeneric { get; }
    private IExpressionCollection DevExpress.CodeParser.IShortInitializeExpression.Arguments { get; }
    public SourceRange ParensRange { get; }
    private ExpressionCollection DevExpress.CodeParser.IHasArguments.Arguments { get; }
    public int ArgumentsCount { get; }
    private IExpressionCollection DevExpress.CodeParser.IWithArguments.Args { get; }
    private void SetArguments(ExpressionCollection arguments);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(Token parenOpen, Token parenClose);
    [EditorBrowsableAttribute("1")]
public void SetParensRange(SourceRange range);
    public sealed virtual void AddArgument(Expression arg);
    public void AddArguments(IEnumerable`1<Expression> arguments);
    public void RemoveArgument(Expression arg);
    public void InsertArgument(int index, Expression arg);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public ExpressionCollection get_Arguments();
    public void set_Arguments(ExpressionCollection value);
    public virtual bool get_CanBeStatement();
    public bool get_IsGeneric();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IShortInitializeExpression.get_Arguments();
    public sealed virtual SourceRange get_ParensRange();
    private sealed virtual override ExpressionCollection DevExpress.CodeParser.IHasArguments.get_Arguments();
    public sealed virtual int get_ArgumentsCount();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.IWithArguments.get_Args();
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.AddArgument(IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.InsertArgument(int index, IExpression argument);
    private sealed virtual override void DevExpress.CodeParser.IWithArgumentsModifier.RemoveArgument(IExpression argument);
}
public class DevExpress.CodeParser.SiblingHelper : object {
    private IElement _Start;
    private Dictionary`2<IElement, List`1<IElement>> _ElementsCache;
    private Dictionary`2<IElement, int> _ElementsIndexCache;
    public SiblingHelper(IElement start);
    private void SetStart(IElement start);
    private void BuildElements();
    private void BuildElements(IElement parent, IEnumerable`1<IElement> children, Dictionary`2<IElement, List`1<IElement>> elements);
    private IElement GetPrevious(IElement element, Boolean& isSibling);
    public IElement GetPreviousElement(IElement element, Boolean& isSibling);
    public static IElement GetParentMember(IElement start);
}
[EditorBrowsableAttribute("1")]
public static class DevExpress.CodeParser.SignatureBuilder : object {
    public static string GetSignature(IElement element);
    [EditorBrowsableAttribute("1")]
public static string GetSignatureForXmlDocumentation(IMemberElement member);
    [EditorBrowsableAttribute("1")]
public static string GetSignature(IElement element, bool buildGenerics, String& name, Int32& nameIndex);
}
public class DevExpress.CodeParser.SizeOfExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _TypeReference;
    private bool _IsParenthesizedExpression;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public bool IsParenthesizedExpression { get; public set; }
    public Expression TypeReference { get; public set; }
    private IExpression DevExpress.CodeParser.ISizeOfExpression.TypeReference { get; }
    public SizeOfExpression(Expression type);
    public SizeOfExpression(TypeReferenceExpression type);
    private void SetTypeReference(Expression type);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public bool get_IsParenthesizedExpression();
    public void set_IsParenthesizedExpression(bool value);
    public Expression get_TypeReference();
    public void set_TypeReference(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.ISizeOfExpression.get_TypeReference();
}
public class DevExpress.CodeParser.SkipExpression : SkipExpressionBase {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.SkipExpressionBase : QueryExpressionBase {
    private Expression _Expression;
    public Expression Expression { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public Expression get_Expression();
    public void set_Expression(Expression value);
}
public class DevExpress.CodeParser.SkipWhileExpression : SkipExpressionBase {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.SnippetCodeElement : CodeElement {
    public LanguageElementType ElementType { get; }
    public string Code { get; }
    public SnippetCodeElement(string code);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_Code();
}
public abstract class DevExpress.CodeParser.SnippetCodeGenBase : LanguageElementCodeGenBase {
    public SnippetCodeGenBase(CodeGen codeGen);
    public virtual void GenerateElement(LanguageElement languageElement);
    protected virtual bool GenerateSnippet(LanguageElement snippet);
    protected abstract virtual void GenerateSnippetCodeElement(SnippetCodeElement snippet);
    protected abstract virtual void GenerateSnippetCodeMember(SnippetCodeMember snippet);
    protected abstract virtual void GenerateSnippetCodeStatement(SnippetCodeStatement snippet);
    protected abstract virtual void GenerateSnippetCodeStatementBlock(SnippetCodeStatementBlock snippet);
    protected abstract virtual void GenerateSnippetExpression(SnippetExpression snippet);
}
public class DevExpress.CodeParser.SnippetCodeMember : Member {
    public LanguageElementType ElementType { get; }
    public string Code { get; }
    public SnippetCodeMember(string code);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_Code();
}
public class DevExpress.CodeParser.SnippetCodeStatement : Statement {
    private bool _AddStatementTerminator;
    private bool _AddBlock;
    public LanguageElementType ElementType { get; }
    public string Code { get; }
    public bool AddStatementTerminator { get; }
    public bool AddBlock { get; }
    public SnippetCodeStatement(string code);
    public SnippetCodeStatement(string code, bool addStatementTerminator);
    public SnippetCodeStatement(string code, bool addStatementTerminator, bool addBlock);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_Code();
    public bool get_AddStatementTerminator();
    public bool get_AddBlock();
}
public class DevExpress.CodeParser.SnippetCodeStatementBlock : DelimiterCapableBlock {
    private bool _AddNewLineAfter;
    public LanguageElementType ElementType { get; }
    public string Code { get; }
    public bool AddNewLineAfter { get; }
    public SnippetCodeStatementBlock(string code);
    public SnippetCodeStatementBlock(string code, bool addNewLineAfter);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_Code();
    public bool get_AddNewLineAfter();
}
public class DevExpress.CodeParser.SnippetExpression : Expression {
    public LanguageElementType ElementType { get; }
    public string Code { get; }
    public SnippetExpression(string code);
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual LanguageElementType get_ElementType();
    public sealed virtual string get_Code();
}
internal class DevExpress.CodeParser.Sorter : object {
    protected int InnerCompare(object x, object y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
public class DevExpress.CodeParser.SourceFile : VisualStudioDocument {
    private bool _WasParsedWithNullProject;
    private Nullable`1<DateTime> _LastWriteTime;
    private Nullable`1<long> _FileSize;
    private int _ThreadHandlingCounter;
    private DemandObjectManager _Manager;
    private CompilerDirective _CompilerDirectiveRootNode;
    private RegionDirective _SimpleDirectiveHolder;
    private Nullable`1<OptionStrict> _OptionStrict;
    private Nullable`1<OptionInfer> _OptionInfer;
    private Nullable`1<OptionExplicit> _OptionExplicit;
    private NameValueCollection _AliasList;
    private RegionDirective _RegionRootNode;
    private FullIfDirective _FullDirectiveRootNode;
    private bool _MustCreateFullDirectiveRootNode;
    private SortedList _UsingList;
    private SortedList _IncludeDirectiveList;
    private SortedList _AssemblyList;
    private Hashtable _AliasHash;
    private TextStringCollection _TextStringCollection;
    private CommentCollection _AllComments;
    private CommentCollection _AllXmlDocComments;
    private StringCollection _IncludedScriptFiles;
    private StringCollection _IncludedStyleSheetFiles;
    private string _MasterPageFile;
    private List`1<string> _MacrosCalls;
    private string _ModelTypeName;
    private MacroInfoCollection _MacroRanges;
    private bool _ContainsPartialTypeAndShouldBeParsed;
    private bool _IsOpened;
    private bool _SymbolsInvalidated;
    private bool _SymbolsInvalidating;
    private bool _SymbolsBuilt;
    private bool _HasUnparsedDocumentCode;
    private bool _NeedReload;
    private bool _SaveUserFormat;
    private bool _IsCustomToolOutput;
    private DotNetLanguageType _AspPageLanguage;
    private string _AspPageBaseType;
    private string _CodeBehindFileName;
    private LanguageElement _CodeLayer;
    private StringCollection _DeclaredNamespaces;
    private Dictionary`2<string, object> _Data;
    private SourceFileBuildAction _LoadBuildAction;
    private StringCollection _FriendAssemblyNamesList;
    private IDteProjectItem _CachedProjectItem;
    private bool _IsLink;
    private object DevExpress.CodeParser.Patterns.IDemandObjectProxy.Key { get; }
    protected CommentCollection InnerAllComments { get; }
    protected CommentCollection InnerAllXmlDocComments { get; }
    internal IDteProjectItem CachedProjectItem { get; internal set; }
    public OptionStrict OptionStrict { get; public set; }
    public OptionInfer OptionInfer { get; public set; }
    public OptionExplicit OptionExplicit { get; public set; }
    public NodeList Nodes { get; }
    public LanguageElementType ElementType { get; }
    public bool IsOpened { get; }
    public bool IsGenerated { get; }
    [EditorBrowsableAttribute("1")]
public bool SymbolsInvalidated { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool SymbolsInvalidating { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool SymbolsBuilt { get; public set; }
    [EditorBrowsableAttribute("1")]
public DateTime LastWriteTime { get; public set; }
    [EditorBrowsableAttribute("1")]
public long FileSize { get; public set; }
    public bool WasModifiedOnDisk { get; }
    public IEnumerable AllNamespaces { get; }
    public IEnumerable AllTypes { get; }
    public bool HasUnparsedDocumentCode { get; public set; }
    public MacroInfoCollection MacroRanges { get; }
    [EditorBrowsableAttribute("1")]
public bool IsThreadHandling { get; }
    [EditorBrowsableAttribute("1")]
public DotNetLanguageType AspPageLanguage { get; public set; }
    [EditorBrowsableAttribute("1")]
public string AspPageBaseType { get; public set; }
    public CompilerDirectiveCollection CompilerDirectives { get; }
    public CompilerDirective CompilerDirectiveRootNode { get; }
    public RegionDirectiveCollection Regions { get; }
    public IEnumerable AllRegions { get; }
    public RegionDirective RegionRootNode { get; }
    public FullIfDirective FullDirectiveRootNode { get; }
    internal RegionDirective SimpleDirectiveHolder { get; }
    public SortedList UsingList { get; public set; }
    public SortedList AssemblyList { get; public set; }
    public SortedList IncludeDirectiveList { get; public set; }
    public NameValueCollection AliasList { get; public set; }
    public Hashtable AliasHash { get; public set; }
    public TextStringCollection TextStrings { get; public set; }
    public CommentCollection AllComments { get; }
    public CommentCollection AllXmlDocComments { get; }
    private DemandObjectManager DevExpress.CodeParser.Patterns.IDemandObjectProxy.Manager { get; private set; }
    private bool HasManager { get; }
    public LanguageElement Asp { get; }
    public LanguageElement Code { get; public set; }
    public string CodeBehindFileName { get; public set; }
    public bool IsAspFile { get; }
    public bool IsHeaderFile { get; }
    public int DeclaredNamespacesCount { get; }
    public StringCollection DeclaredNamespaces { get; }
    public int LinesCount { get; }
    public StringCollection IncludedScriptFiles { get; }
    public StringCollection IncludedStyleSheetFiles { get; }
    public string MasterPageFile { get; }
    [EditorBrowsableAttribute("1")]
public string ModelTypeName { get; }
    public int FriendAssemblyNamesCount { get; }
    public String[] FriendAssemblyNames { get; }
    public SourceFileBuildAction BuildAction { get; }
    public bool HasCompileBuildAction { get; }
    [EditorBrowsableAttribute("1")]
public List`1<string> MacrosCalls { get; public set; }
    public SourceFileBuildAction LoadBuildAction { get; public set; }
    public bool IsLink { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool WasParsedWithNullProject { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool NeedReload { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool ContainsPartialTypeAndShouldBeParsed { get; public set; }
    public bool IsCustomToolOutput { get; public set; }
    public bool SaveUserFormat { get; public set; }
    public SourceFile(string fileName);
    private void SetFileSizeAndLastWriteTime();
    private StringCollection CloneStringCollection(StringCollection sourceCollection);
    private sealed virtual override object DevExpress.CodeParser.Patterns.IDemandObjectProxy.get_Key();
    private RegionDirective CalculateRegionRootNode();
    private FullIfDirective CalculateFullDirectiveRootNode();
    private SourceFile DemandObjectData(DemandObjectManager manager);
    private NodeList DemandNodes();
    public SourceFile GetParsedFile(bool bindComments);
    public SourceFile GetParsedFile(ParsingMode mode);
    private NameValueCollection CloneNameValueCollection(NameValueCollection source);
    private Hashtable CloneHashtable(Hashtable source);
    private SortedList CloneSortedList(SortedList source);
    private void SetParent(Hashtable aliasHash);
    private SourceFileBuildAction GetBuildAction();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual SourceRange GetTransformedRange(TextRange original);
    [EditorBrowsableAttribute("1")]
protected virtual void FillFormattingCollection(FormattingParsingElementCollection data);
    public virtual void LoadCache();
    public virtual void InvalidateRange(SourceRange range);
    public virtual void BindAdditionalElementsToCode(IDisposableEditPointFactory textDoc);
    public virtual void BindAdditionalElementsToCode(IDisposableEditPointFactory textDoc, SourceRange containingRange);
    public static SourceFile Parse(string code, string language);
    [EditorBrowsableAttribute("1")]
public void Open();
    [EditorBrowsableAttribute("1")]
public void Close();
    [EditorBrowsableAttribute("1")]
public void SetName(string value);
    [EditorBrowsableAttribute("1")]
public void InvalidateProjectSymbols();
    [EditorBrowsableAttribute("1")]
public virtual void Invalidate();
    [EditorBrowsableAttribute("1")]
public virtual void BuildProjectSymbols();
    private void ClearProjectSymbols();
    private void CloneMacrosCalls(List`1<string> macrosCalls);
    private void RemoveMacrosCalls(List`1<string> macroCalls, string fileName);
    public void RemoveMacrosCalls();
    [EditorBrowsableAttribute("1")]
public void Synchronize(SourceFile fileNode);
    [EditorBrowsableAttribute("2")]
public SourceFile GetSourceFileProxy();
    public virtual MemberVisibility[] GetValidVisibilities();
    public void AddComment(Comment comment);
    public void AddComment(Comment comment, bool useSorting);
    public void RemoveComment(Comment comment);
    public void AddXmlDocComment(XmlDocComment xmlDoc);
    [EditorBrowsableAttribute("1")]
public void AddInvalidateMacro(string name);
    [EditorBrowsableAttribute("1")]
public void ClearInvalidateMacros();
    public void AddFriendAssemblyName(string name);
    public void RemoveFriendAssemblyName(string name);
    public void ClearFriendAssemblyNames();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public Expression GetAlias(string name);
    public T GetData(string key);
    public void SetData(string key, T data);
    public bool HasData(string key);
    [EditorBrowsableAttribute("1")]
public void SetOptionStrict(Nullable`1<OptionStrict> optionStrict);
    [EditorBrowsableAttribute("1")]
public void SetOptionInfer(Nullable`1<OptionInfer> optionInfer);
    [EditorBrowsableAttribute("1")]
public void SetOptionExplicit(Nullable`1<OptionExplicit> optionExplicit);
    [EditorBrowsableAttribute("1")]
public void SetMasterPageFile(string masterPageFile);
    [EditorBrowsableAttribute("1")]
public void SetModelTypeName(string modelTypeName);
    protected CommentCollection get_InnerAllComments();
    protected CommentCollection get_InnerAllXmlDocComments();
    internal IDteProjectItem get_CachedProjectItem();
    internal void set_CachedProjectItem(IDteProjectItem value);
    public OptionStrict get_OptionStrict();
    public void set_OptionStrict(OptionStrict value);
    public OptionInfer get_OptionInfer();
    public void set_OptionInfer(OptionInfer value);
    public OptionExplicit get_OptionExplicit();
    public void set_OptionExplicit(OptionExplicit value);
    public virtual NodeList get_Nodes();
    public virtual LanguageElementType get_ElementType();
    public bool get_IsOpened();
    public bool get_IsGenerated();
    public bool get_SymbolsInvalidated();
    public void set_SymbolsInvalidated(bool value);
    public bool get_SymbolsInvalidating();
    public void set_SymbolsInvalidating(bool value);
    public bool get_SymbolsBuilt();
    public void set_SymbolsBuilt(bool value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    public long get_FileSize();
    public void set_FileSize(long value);
    public bool get_WasModifiedOnDisk();
    public IEnumerable get_AllNamespaces();
    public IEnumerable get_AllTypes();
    public bool get_HasUnparsedDocumentCode();
    public void set_HasUnparsedDocumentCode(bool value);
    public MacroInfoCollection get_MacroRanges();
    public bool get_IsThreadHandling();
    [EditorBrowsableAttribute("1")]
public void StartThreadHandling();
    [EditorBrowsableAttribute("1")]
public void EndThreadHandling();
    public DotNetLanguageType get_AspPageLanguage();
    public void set_AspPageLanguage(DotNetLanguageType value);
    public sealed virtual string get_AspPageBaseType();
    public void set_AspPageBaseType(string value);
    public sealed virtual CompilerDirectiveCollection get_CompilerDirectives();
    public sealed virtual CompilerDirective get_CompilerDirectiveRootNode();
    private void UpdateParentRanges(LanguageElement currentRootNode, RegionDirective resultNode, SourcePoint endPoint);
    private void UpdateParentEndTokenLength(LanguageElement currentRootNode, SourceRange endRange);
    internal void InvalidateSimples(SourceRange range, LanguageElementCollection trailingSimples);
    internal void RestoreTrailingRegions(LanguageElementCollection trailingRegions);
    internal void SetRegionDirectiveHolderParent(LanguageElement parent);
    public void AddRegionDirective(RegionDirective regionDirective);
    public void AddEndRegionDirective(EndRegionDirective endRegionDirective);
    [EditorBrowsableAttribute("1")]
public void AddRegionDirective(LanguageElement region);
    public void AddDirective(PreprocessorDirective directive);
    public void AddSimpleDirective(PreprocessorDirective directive);
    public void AddSimpleDirective(PreprocessorDirective directive, bool inEach);
    [EditorBrowsableAttribute("1")]
public void RemoveRegionDirective(LanguageElement region);
    [EditorBrowsableAttribute("1")]
public void RemoveRegionDirectives(IList`1<LanguageElement> regions);
    [EditorBrowsableAttribute("1")]
public void RemoveRegionsInRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void RemoveRegionDirectivesFrom(int index);
    [EditorBrowsableAttribute("1")]
public void RemoveCorruptedRegions(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetHistoryForRegions(DocumentHistorySlice history);
    public sealed virtual RegionDirectiveCollection get_Regions();
    public IEnumerable get_AllRegions();
    public sealed virtual RegionDirective get_RegionRootNode();
    public FullIfDirective get_FullDirectiveRootNode();
    internal RegionDirective get_SimpleDirectiveHolder();
    public sealed virtual SortedList get_UsingList();
    public void set_UsingList(SortedList value);
    public sealed virtual SortedList get_AssemblyList();
    public void set_AssemblyList(SortedList value);
    public sealed virtual SortedList get_IncludeDirectiveList();
    public void set_IncludeDirectiveList(SortedList value);
    public sealed virtual NameValueCollection get_AliasList();
    public void set_AliasList(NameValueCollection value);
    public sealed virtual Hashtable get_AliasHash();
    public void set_AliasHash(Hashtable value);
    public sealed virtual TextStringCollection get_TextStrings();
    public void set_TextStrings(TextStringCollection value);
    public sealed virtual CommentCollection get_AllComments();
    public sealed virtual CommentCollection get_AllXmlDocComments();
    private sealed virtual override DemandObjectManager DevExpress.CodeParser.Patterns.IDemandObjectProxy.get_Manager();
    private sealed virtual override void DevExpress.CodeParser.Patterns.IDemandObjectProxy.set_Manager(DemandObjectManager value);
    private bool get_HasManager();
    public sealed virtual LanguageElement get_Asp();
    public sealed virtual LanguageElement get_Code();
    public void set_Code(LanguageElement value);
    public string get_CodeBehindFileName();
    public void set_CodeBehindFileName(string value);
    public bool get_IsAspFile();
    public bool get_IsHeaderFile();
    public int get_DeclaredNamespacesCount();
    public StringCollection get_DeclaredNamespaces();
    public int get_LinesCount();
    public sealed virtual StringCollection get_IncludedScriptFiles();
    public sealed virtual StringCollection get_IncludedStyleSheetFiles();
    public sealed virtual string get_MasterPageFile();
    public sealed virtual string get_ModelTypeName();
    public virtual int get_FriendAssemblyNamesCount();
    public virtual String[] get_FriendAssemblyNames();
    public SourceFileBuildAction get_BuildAction();
    public bool get_HasCompileBuildAction();
    public List`1<string> get_MacrosCalls();
    public void set_MacrosCalls(List`1<string> value);
    public SourceFileBuildAction get_LoadBuildAction();
    public void set_LoadBuildAction(SourceFileBuildAction value);
    public bool get_IsLink();
    public void set_IsLink(bool value);
    public bool get_WasParsedWithNullProject();
    public void set_WasParsedWithNullProject(bool value);
    public bool get_NeedReload();
    public void set_NeedReload(bool value);
    public bool get_ContainsPartialTypeAndShouldBeParsed();
    public void set_ContainsPartialTypeAndShouldBeParsed(bool value);
    public bool get_IsCustomToolOutput();
    public void set_IsCustomToolOutput(bool value);
    public bool get_SaveUserFormat();
    public void set_SaveUserFormat(bool value);
}
public enum DevExpress.CodeParser.SourceFileBuildAction : Enum {
    public int value__;
    public static SourceFileBuildAction None;
    public static SourceFileBuildAction Compile;
    public static SourceFileBuildAction Content;
    public static SourceFileBuildAction EmbeddedResource;
    public static SourceFileBuildAction Shadow;
}
public class DevExpress.CodeParser.SourceFileCodeGenBase : LanguageElementCodeGenBase {
    public SourceFileCodeGenBase(CodeGen codeGen);
    public virtual void GenerateElement(LanguageElement languageElement);
}
public class DevExpress.CodeParser.SourceFileStartText : FormattingText {
    public SourceFileStartText(string text);
    public virtual object Clone();
}
public class DevExpress.CodeParser.SourceLine : object {
    private SourcePoint _Start;
    private string _Text;
    public SourcePoint Start { get; public set; }
    public string Text { get; public set; }
    public SourceLine(int line, int offset);
    public SourceLine(int line, int offset, string text);
    public SourceLine(SourcePoint point, string text);
    public SourcePoint get_Start();
    public void set_Start(SourcePoint value);
    public string get_Text();
    public void set_Text(string value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.SourceLineCollection : CollectionBase {
    public SourceLine Item { get; public set; }
    public int Add(SourceLine aSourceLine);
    public int IndexOf(SourceLine aSourceLine);
    public void Insert(int index, SourceLine aSourceLine);
    public void Remove(SourceLine aSourceLine);
    public SourceLine Find(SourceLine aSourceLine);
    public bool Contains(SourceLine aSourceLine);
    public SourceLine get_Item(int index);
    public void set_Item(int index, SourceLine value);
}
public class DevExpress.CodeParser.SourceLinesReader : object {
    private SourceLineCollection _SourceLines;
    private string _Text;
    private bool _Eof;
    private int _StartLine;
    private int _StartColumn;
    private int _CurrentLine;
    private int _CurrentColumn;
    private int _Line;
    private int _LinePos;
    public int StartLine { get; }
    public int StartColumn { get; }
    public int CurrentLine { get; public set; }
    public int CurrentColumn { get; public set; }
    private bool DevExpress.CodeParser.ISourceReader.IsDocumentReader { get; }
    public SourceLineCollection SourceLines { get; }
    public int LineCount { get; }
    public int Line { get; }
    public int LinePos { get; }
    public bool ManagesCoordinates { get; }
    public bool IsDisposing { get; }
    public bool IsDisposed { get; }
    public SourceLinesReader(SourceLineCollection lines);
    public sealed virtual TextReader GetStream();
    public char CurrentChar();
    public char NextChar();
    public void UndoChar();
    public string Text(int aStartPos, int aLength);
    public bool Eof();
    public void IncreaseColumn();
    public int Position();
    public void Seek(int position);
    public int ToPosition(int line, int linePos);
    public SourcePoint ToPoint(int pos);
    public int GetMaxPosition();
    public string GetText();
    public sealed virtual int get_StartLine();
    public sealed virtual int get_StartColumn();
    public int get_CurrentLine();
    public void set_CurrentLine(int value);
    public int get_CurrentColumn();
    public void set_CurrentColumn(int value);
    private sealed virtual override bool DevExpress.CodeParser.ISourceReader.get_IsDocumentReader();
    public sealed virtual void OffsetSubStream(int line, int column);
    public sealed virtual ISourceReader GetSubStream(int startPos, int length, int line, int column);
    public SourceLineCollection get_SourceLines();
    public int get_LineCount();
    public int get_Line();
    public int get_LinePos();
    public bool get_ManagesCoordinates();
    public sealed virtual bool get_IsDisposing();
    public sealed virtual bool get_IsDisposed();
    public sealed virtual void Dispose();
}
public class DevExpress.CodeParser.SourcePoint : ValueType {
    private int _Line;
    private int _Offset;
    private SourcePointBinding _Binding;
    private byte _IsAnchorPushable;
    internal IDisposableEditPoint _BindingPoint;
    public static SourcePoint Empty;
    public bool IsBoundToCode { get; }
    public bool IsAnchored { get; }
    public bool IsEmpty { get; }
    public int Line { get; public set; }
    public int Offset { get; public set; }
    public SourcePointBinding Binding { get; }
    public IDisposableEditPoint BindingPoint { get; }
    public bool HasBindingPoint { get; }
    public bool IsAnchorPushable { get; public set; }
    public SourcePoint(int line, int offset);
    public SourcePoint(SourcePoint point);
    private static SourcePoint();
    private static bool NeedToAdjustForInsertion(int line, int offset, int topLine, int topOffset, bool pushable);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SourcePoint point);
    public bool Equals(int line, int offset);
    public virtual int GetHashCode();
    public virtual string ToString();
    public void AdjustForInsertion(SourceRange insertion);
    public void AdjustForDeletion(SourceRange deletion);
    [EditorBrowsableAttribute("1")]
public void SetFast(int line, int offset);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("SetPoint is obsolete -- use Set method instead.")]
public void SetPoint(int line, int offset);
    public void Set(int line, int offset);
    public void Set(SourcePoint sourcePoint);
    public void Set(Token token);
    public void SetOffset(int offset);
    public void BindToCode(IDisposableEditPointFactory editPointFactory);
    public void BindToCode(IDisposableEditPointFactory editPointFactory, bool pushable);
    public void RemoveBinding();
    public void AnchorToSourcePoint(SourcePoint sourcePoint);
    public void AnchorToSourcePoint(SourcePoint sourcePoint, bool pushable);
    public void HoistAnchor();
    public void RemoveAllBindings();
    public SourcePoint OffsetPoint(int lines, int columns);
    public SourcePoint ExtractFromDocument(SourcePoint newOrigin);
    public SourcePoint RestoreToDocument(SourcePoint customOrigin);
    public bool get_IsBoundToCode();
    public bool get_IsAnchored();
    public bool get_IsEmpty();
    public int get_Line();
    public void set_Line(int value);
    public int get_Offset();
    public void set_Offset(int value);
    public SourcePointBinding get_Binding();
    public IDisposableEditPoint get_BindingPoint();
    public bool get_HasBindingPoint();
    public bool get_IsAnchorPushable();
    public void set_IsAnchorPushable(bool value);
    private void SetBinding(SourcePointBinding binding);
    public static bool op_Equality(SourcePoint point1, SourcePoint point2);
    public static bool op_Inequality(SourcePoint point1, SourcePoint point2);
    public static bool op_GreaterThan(SourcePoint point1, SourcePoint point2);
    public static bool op_LessThan(SourcePoint point1, SourcePoint point2);
    public static bool op_GreaterThanOrEqual(SourcePoint point1, SourcePoint point2);
    public static bool op_LessThanOrEqual(SourcePoint point1, SourcePoint point2);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(SourcePoint point);
    public int UnboundCompareTo(SourcePoint point);
    public static int CompareTo(int firstLine, int firstOffset, int secondLine, int secondOffset);
    private sealed virtual override object System.ICloneable.Clone();
    public SourcePoint Clone();
}
public enum DevExpress.CodeParser.SourcePointBinding : Enum {
    public byte value__;
    public static SourcePointBinding None;
    public static SourcePointBinding EditPoint;
    public static SourcePointBinding Anchor;
}
public class DevExpress.CodeParser.SourceRange : ValueType {
    public SourcePoint Start;
    public SourcePoint End;
    public static SourceRange Empty;
    public bool IsBoundToCode { get; }
    public bool IsAnchored { get; }
    public SourcePoint Bottom { get; }
    public int CharsIncludedOnLastLine { get; }
    public int Height { get; }
    public bool IsEmpty { get; }
    public bool IsPoint { get; }
    public LineRange LineCount { get; }
    [EditorBrowsableAttribute("1")]
public LineRange LineCountMinusOne { get; }
    public SourceRange LogicalRange { get; }
    public bool StartPrecedesEnd { get; }
    public SourcePoint Top { get; }
    public SourceRange(int line, int offset);
    public SourceRange(SourcePoint sourcePoint);
    public SourceRange(int startLine, int startOffset, int endLine, int endOffset);
    public SourceRange(SourcePoint start, SourcePoint end);
    public SourceRange(SourceRange range);
    public SourceRange(TextPoint start, TextPoint end);
    private static SourceRange();
    private void GetTopAndBottom(SourcePoint& top, SourcePoint& bottom);
    public void AdjustForInsertion(SourceRange insertion);
    public void AdjustForDeletion(SourceRange deletion);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("SetRange is Obsolete. Use the Set method instead.")]
public void SetRange(Token token);
    [EditorBrowsableAttribute("1")]
public void Set(Token token);
    public void Set(int startLine, int startOffset, int endLine, int endOffset);
    public void Set(SourcePoint startPoint, SourcePoint endPoint);
    public void Set(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetFast(int startLine, int startOffset, int endLine, int endOffset);
    public static void AnchorToSourcePoint(Object& range, SourcePoint point);
    public static void HoistAnchor(Object& range);
    public static void AdjustForDeletion(Object& range, SourceRange deletion);
    public static void AdjustForInsertion(Object& range, SourceRange insertion);
    public static void Set(Object& range, Token token);
    public static void Set(Object& range, SourceRange sourceRange);
    public static void SetEnd(Object& range, SourcePoint point);
    public static void SetEnd(Object& range, Token token);
    public static SourceRange Get(object range);
    public virtual bool Equals(object aObj);
    public sealed virtual bool Equals(SourceRange range);
    public bool Equals(SourcePoint start, SourcePoint end);
    public bool Equals(int startLine, int startOffset, int endLine, int endOffset);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool Contains(int line, int offset);
    public bool Contains(SourcePoint sourcePoint);
    [EditorBrowsableAttribute("1")]
public bool FastContains(SourceRange range);
    public bool Contains(SourceRange range);
    public bool IntersectsWith(SourceRange range);
    [EditorBrowsableAttribute("1")]
public bool Intersects(SourceRange range);
    public bool Surrounds(SourcePoint sourcePoint);
    public bool EndsBefore(SourceRange sourceRange);
    public bool EndsBefore(int lineNumber, int columnOffset);
    public bool StartsAfter(int lineNumber, int columnOffset);
    public bool StartsAfter(SourceRange sourceRange);
    public bool StartsBefore(int lineNumber, int columnOffset);
    public bool EndsAfter(int lineNumber, int columnOffset);
    public bool Overlaps(SourceRange range);
    public bool Holds(SourcePoint testPoint);
    public void BindToCode(IDisposableEditPointFactory editPointFactory);
    public void RemoveBinding();
    public void RemoveAllBindings();
    public void AnchorToSourcePoint(SourcePoint sourcePoint);
    public void HoistAnchor();
    public SourceRange OffsetRange(int lines, int columns);
    public SourceRange ExtractFromDocument(SourcePoint newOrigin);
    public SourceRange RestoreToDocument(SourcePoint customOrigin);
    public bool get_IsBoundToCode();
    public bool get_IsAnchored();
    private static SourcePoint GetMax(SourcePoint a, SourcePoint b);
    private static SourcePoint GetMin(SourcePoint a, SourcePoint b);
    public static SourceRange Union(SourceRange a, SourceRange b);
    public SourcePoint get_Bottom();
    public int get_CharsIncludedOnLastLine();
    public int get_Height();
    public bool get_IsEmpty();
    public bool get_IsPoint();
    public LineRange get_LineCount();
    public LineRange get_LineCountMinusOne();
    public SourceRange get_LogicalRange();
    public bool get_StartPrecedesEnd();
    public SourcePoint get_Top();
    public static bool op_Equality(SourceRange range1, SourceRange range2);
    public static bool op_Inequality(SourceRange range1, SourceRange range2);
    public static SourceRange op_Subtraction(SourceRange sourceRange, LineRange lineRange);
    public static SourceRange op_Addition(SourceRange sourceRange, LineRange lineRange);
    private sealed virtual override object System.ICloneable.Clone();
    public SourceRange Clone();
}
public class DevExpress.CodeParser.SourceRangeComparer : object {
    public sealed virtual int Compare(SourceRange x, SourceRange y);
}
public class DevExpress.CodeParser.SourceRangeUtils : object {
    public static SourceRange GetRange(object a, object b);
    public static SourceRange GetRange(object a);
    public static SourceRange GetRange(Object[] objs);
}
public class DevExpress.CodeParser.SourceRangeWrapper : object {
    public SourceRange Range;
    public SourceRangeWrapper(SourceRange range);
}
public class DevExpress.CodeParser.SourceStringReader : object {
    private string _String;
    private int _StartLine;
    private int _StartColumn;
    public bool IsDisposing { get; }
    public bool IsDisposed { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    private bool DevExpress.CodeParser.ISourceReader.IsDocumentReader { get; }
    public SourceStringReader(string s);
    public SourceStringReader(string filePath, Encoding encoding);
    public SourceStringReader(string s, int line, int column);
    public sealed virtual void Dispose();
    public sealed virtual TextReader GetStream();
    public sealed virtual void OffsetSubStream(int line, int column);
    public sealed virtual ISourceReader GetSubStream(int startPos, int length, int line, int column);
    public sealed virtual bool get_IsDisposing();
    public sealed virtual bool get_IsDisposed();
    public sealed virtual int get_StartLine();
    public sealed virtual int get_StartColumn();
    private sealed virtual override bool DevExpress.CodeParser.ISourceReader.get_IsDocumentReader();
}
public class DevExpress.CodeParser.SourceTextRange : object {
    private SourceRange _Range;
    private string _Text;
    public SourceRange Range { get; public set; }
    public string Text { get; public set; }
    public SourceTextRange(string text, SourceRange range);
    public SourceRange get_Range();
    public void set_Range(SourceRange value);
    public string get_Text();
    public void set_Text(string value);
}
public class DevExpress.CodeParser.SourceTreeCommenter : object {
    private SourceFile _SourceFile;
    private DocumentHistorySlice _History;
    private Hashtable NodesAndIndexes;
    private IncludeDirective _FirstInclude;
    private bool _UseSorting;
    protected SourceFile SourceFile { get; protected set; }
    public bool UseSorting { get; public set; }
    public SourceTreeCommenter(DocumentHistorySlice history);
    private void AddComment(CodeElement taget, Comment comment);
    private void AddComment(SourceFile taget, Comment comment);
    private void AddXmlDocCommentToStartNode(XmlDocComment xmlDoc);
    private void AddUsualCommentToStartNode(Comment comment);
    private void AddCommentToSourceFile(SourceFile fileNode, Comment comment);
    private void AddCommentToSourceFile(SourceFile fileNode, Comment comment, LanguageElement node);
    private void AddCommentsToStartNode(CommentCollection comments);
    private void InsertSupportElement(CodeElement node, SupportElement element);
    private void ReindexNode(NodeList nodes);
    private void ReindexNodes();
    private XmlDocComment BindXmlDocCommentToNode(CodeElement node, XmlDocComment xmlDoc);
    private void BindUsualCommentToNode(CodeElement node, Comment comment);
    private void BindCommentToNode(CodeElement node, Comment comment);
    private void BindCommentToSourceFile(SourceFile fileNode, Comment comment);
    private void BindCommentToSourceFile(SourceFile fileNode, Comment comment, LanguageElement node);
    public CodeElement GetNextCodeElementSibling(LanguageElement node);
    private bool CanStartFromComment(LanguageElement node, Comment comment);
    private bool CanBindTrailingComment(CodeElement node, Comment comment);
    private bool CouldEnterChildren(LanguageElement node);
    private bool ContainRange(SourceRange[] innerRanges, SourceRange range);
    private SourcePoint GetNodesStartPoint(NodeList nodes);
    private SourcePoint GetNodesEndPoint(NodeList nodes);
    private SourceRange GetRangeFromNodes(NodeList nodes);
    private SourceRange GetDetailsRange(LanguageElement node, bool invertedOrder);
    private SourceRange GetNodesRange(LanguageElement node, bool invertedOrder);
    private SourceRange[] GetInnerSourceRanges(SourceRange commonRange, SourceRange detailsRange, SourceRange nodesRange);
    private SourceRange[] GetInnerSourceRangesForNode(LanguageElement node);
    private bool HasIncludeDirectiveInside(SourcePoint start, SourcePoint end);
    private void AddPrecedingCommentsToNode(LanguageElement node, CommentCollection comments);
    private bool AddCommentToNextObjectInitializerChildren(LanguageElement node, CommentCollection comments, Comment comment, int index);
    private void AddTrailingComment(LanguageElement node, CommentCollection comments);
    private bool AddCommentToFirstObjectInitializerChildren(LanguageElement node, CommentCollection comments, Comment comment, int index);
    private void AddInnerCommentsBeforeChildren(LanguageElement node, CommentCollection comments);
    private void AddCommentsToNodes(NodeList nodes, CommentCollection comments);
    private void AddCommentsToChildren(LanguageElement node, CommentCollection comments);
    private void AddInnerCommentsAfterChildren(LanguageElement node, CommentCollection comments);
    private void AddTrailingCommentsToNode(LanguageElement node, CommentCollection comments);
    private void AddSourceFileLevelComments(LanguageElement node, CommentCollection comments);
    private LanguageElement GetHasParensParent(LanguageElement node);
    private bool OutOfParentParens(LanguageElement node, Comment comment);
    private void AddCommentsToNode(LanguageElement node, CommentCollection comments);
    private IncludeDirective GetFirstIncludeDirective(CompilerDirectiveCollection directives);
    private void StoreSourceFileNode(LanguageElement node);
    private void CleanUpSourceFileNode();
    public void CommentNode(LanguageElement node, CommentCollection comments);
    protected SourceFile get_SourceFile();
    protected void set_SourceFile(SourceFile value);
    public bool get_UseSorting();
    public void set_UseSorting(bool value);
}
public class DevExpress.CodeParser.SourceTreeEnumerator : object {
    private IElementFilter _Filter;
    private LanguageElement _StartNodeParent;
    private LanguageElement _StartNode;
    private LanguageElement _StopNode;
    private LanguageElement _CurrentNode;
    private bool _IsInStart;
    private bool _SkipScope;
    private Hashtable _IteratedNodes;
    private Hashtable IteratedNodes { get; }
    private bool HasFilter { get; }
    private IElementFilter Filter { get; }
    public object Current { get; }
    public bool SkipScope { get; public set; }
    public SourceTreeEnumerator(LanguageElement start);
    public SourceTreeEnumerator(LanguageElement start, IElementFilter filter);
    public SourceTreeEnumerator(LanguageElement scope, LanguageElement start, IElementFilter filter);
    private LanguageElement GetLastChild(LanguageElement node);
    private LanguageElement GetDeepestChild(LanguageElement node);
    private LanguageElement DefineStopNode(LanguageElement node);
    private bool IsIterationCompleted(LanguageElement node);
    private bool ApplyFilter(LanguageElement node);
    private LanguageElement GetFirstChild(LanguageElement node);
    private LanguageElement GetStartNode(LanguageElement node, bool skipStart);
    private bool GetNextNode(LanguageElement& node);
    private bool GetNextNodeInternal(LanguageElement& node);
    private bool GetNextFilteredNode(LanguageElement& node);
    private Hashtable get_IteratedNodes();
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    private bool get_HasFilter();
    private IElementFilter get_Filter();
    public sealed virtual object get_Current();
    public bool get_SkipScope();
    public void set_SkipScope(bool value);
}
public class DevExpress.CodeParser.Statement : DelimiterCapableBlock {
    private Expression _SourceExpression;
    public LanguageElementType ElementType { get; }
    public bool CanContainCode { get; }
    public Expression SourceExpression { get; public set; }
    public bool HasDelimitedBlock { get; }
    public Statement(string code);
    [IteratorStateMachineAttribute("DevExpress.CodeParser.Statement/<GetBlockChildren>d__3")]
public sealed virtual IEnumerable`1<IElement> GetBlockChildren();
    public virtual int GetImageIndex();
    public static Statement FromExpression(Expression expression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual MemberVisibility GetDefaultVisibility();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_CanContainCode();
    public Expression get_SourceExpression();
    public void set_SourceExpression(Expression value);
    public sealed virtual bool get_HasDelimitedBlock();
}
public abstract class DevExpress.CodeParser.StatementCodeGenBase : LanguageElementCodeGenBase {
    public StatementCodeGenBase(CodeGen codeGen);
    protected virtual bool GenerateStatement(Statement statement);
    protected virtual void GenerateUnsafeStatement(UnsafeStatement statement);
    protected abstract virtual void GenerateMethodCallStatement(MethodCall statement);
    protected abstract virtual void GenerateAbortStatement(Abort statement);
    protected abstract virtual void GenerateThrowStatement(Throw statement);
    protected abstract virtual void GenerateBreakStatement(Break statement);
    protected abstract virtual void GenerateContinueStatement(Continue statement);
    protected abstract virtual void GenerateStatementStatement(Statement statement);
    protected abstract virtual void GenerateGotoStatement(Goto statement);
    protected abstract virtual void GenerateReturnStatement(Return statement);
    protected abstract virtual void GenerateAssignmentStatement(Assignment statement);
    protected abstract virtual void GenerateBlockStatement(Block statement);
    protected abstract virtual void GenerateCheckedStatement(Checked statement);
    protected abstract virtual void GenerateUncheckedStatement(Unchecked statement);
    protected abstract virtual void GenerateSwitchStatement(Switch statement);
    protected abstract virtual void GenerateCaseStatement(Case statement);
    protected abstract virtual void GenerateTryStatement(Try statement);
    protected abstract virtual void GenerateCatchStatement(Catch statement);
    protected abstract virtual void GenerateFinallyStatement(Finally statement);
    protected abstract virtual void GenerateFixedStatement(Fixed statement);
    protected abstract virtual void GenerateLockStatement(Lock statement);
    protected abstract virtual void GenerateUsingStatement(UsingStatement statement);
    protected abstract virtual void GenerateDoStatement(Do statement);
    protected abstract virtual void GenerateForStatement(For statement);
    protected abstract virtual void GenerateForEachStatement(ForEach statement);
    protected abstract virtual void GenerateWhileStatement(While statement);
    protected abstract virtual void GenerateIfStatement(If statement);
    protected abstract virtual void GenerateElseIfStatement(ElseIf statement);
    protected abstract virtual void GenerateElseStatement(Else statement);
    protected abstract virtual void GenerateEventAddStatement(EventAdd statement);
    protected abstract virtual void GenerateEventRaiseStatement(EventRaise statement);
    protected abstract virtual void GenerateEventRemoveStatement(EventRemove statement);
    protected abstract virtual void GeneratePropertyAccessorGetStatement(Get statement);
    protected abstract virtual void GeneratePropertyAccessorSetStatement(Set statement);
    protected abstract virtual void GenerateWithStatement(With statement);
    protected abstract virtual void GenerateRaiseEventStatement(RaiseEvent statement);
    protected abstract virtual void GenerateYieldBreakStatement(YieldBreak statement);
    protected abstract virtual void GenerateYieldReturnStatement(YieldReturn statement);
    protected abstract virtual void GenerateEmptyStatement(EmptyStatement statement);
    protected abstract virtual void GenerateConstructorInitializer(ConstructorInitializer initializer);
    protected abstract virtual void GenerateOptionStatement(OptionStatement statement);
    public virtual void GenerateElement(LanguageElement languageElement);
}
public class DevExpress.CodeParser.StaticCastExpression : CppTypeCastExpression {
    public LanguageElementType ElementType { get; }
    protected virtual string GetString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.Stop : FlowBreak {
    public LanguageElementType ElementType { get; }
    public virtual string ToString();
    public virtual LanguageElement FindTarget();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public static class DevExpress.CodeParser.StringHelper : object {
    private static LineTerminatorChar GetLineTerminatorChar(char character);
    public static StringCollection CloneStringCollection(StringCollection source);
    public static String[] SplitLines(string text);
    public static String[] SplitLines(string text, bool removeLastIfEmpty);
    public static LineTerminator GetLineTerminator(string text);
    public static LineTerminator GetLineTerminator(string text, int index);
    public static int GetLineTerminatorLength(LineTerminator lineTerm);
    public static bool EndsWithLineTerminator(string text);
}
public class DevExpress.CodeParser.Struct : Class {
    public LanguageElementType ElementType { get; }
    public Struct(string name);
    public virtual int GetImageIndex();
    public virtual MemberVisibility[] GetValidVisibilities();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.StructTypeParameterConstraint : TypeParameterConstraint {
    public LanguageElementType ElementType { get; }
    public StructTypeParameterConstraint(string name, SourceRange range);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public static class DevExpress.CodeParser.StructuralParserServicesHolder : object {
    private static IFormattingService _FormattingService;
    public static IStructuralParserServices StructuralParserServices;
    public static ISourceTreeResolver SourceTreeResolver { get; }
    public static IFormattingService FormattingService { get; }
    public static ISolutionElement ActiveSolution { get; }
    private static StructuralParserServicesHolder();
    public static void SetFormattingService(IFormattingService fs);
    public static ArrayList FindAllReferencesForBaseVariable(BaseVariable variable);
    public static bool IsKeyword(string name);
    public static bool IsKeyword(IReferenceExpression reference);
    public static bool IsKeywordElement(IElement element);
    public static Expression BuildQueryTranslation(QueryExpression queryExpression);
    public static string GetEscapedString(string projectLanguage, string name, bool isVerbatim);
    public static Expression Invert(Expression expression);
    public static Expression Simplify(Expression expression);
    public static Expression Simplify(Expression expression, bool considerMethodCalls);
    public static LanguageElementCollection GetUnusedDeclarations(IEnumerable allVariables);
    public static IElement FindElementByFullName(IElementCollection iElementCollection, string fullName, bool caseSensitive);
    public static ITypeElement[] GetAllDescendants(ITypeElement delegateDefinition);
    public static ITypeElement[] GetAllDescendants(ITypeElement delegateDefinition, IElement scope);
    public static ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver, ITypeElement delegateDefinition);
    public static ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver, ITypeElement delegateDefinition, IElement scope);
    public static ITypeElement[] GetDescendants(ITypeElement delegateDefinition);
    public static ITypeElement[] GetDescendants(ITypeElement delegateDefinition, IElement scope);
    public static ITypeElement[] GetDescendants(ISourceTreeResolver resolver, ITypeElement delegateDefinition);
    public static ITypeElement[] GetDescendants(ISourceTreeResolver resolver, ITypeElement delegateDefinition, IElement scope);
    public static string GetSignaturePart(IElement element);
    public static string ReplaceAccessOperators(string fullName);
    public static string GetOverrideCode(IMemberElement member, bool callBase, string codeBefore, string codeAfter);
    public static TypeReferenceExpression GetMethodType(AnonymousMethodExpression anonymousMethod);
    public static string GenerateElement(LanguageElement element);
    public static string GenerateElement(LanguageElement element, int precedingWhiteSpaceCount);
    public static string GenerateElement(LanguageElement element, string languageID, int precedingWhiteSpaceCount);
    public static bool IsBuiltInType(string typeName);
    public static string GetSimpleTypeName(string typeName);
    public static string GetComment(string text, string languageID);
    public static bool IdentifiersMatch(string first, string second);
    public static string ExtractFirstIdentifier(String& remainingIdentifiers);
    public static bool IsCollapsible(LanguageElement element);
    public static SourceRange GetCollapsibleRange(LanguageElement element);
    public static bool DescendsFrom(ITypeElement type, string fullTypeName);
    public static bool DescendsFrom(ISourceTreeResolver resolver, ITypeElement type, string fullTypeName);
    public static IElement FindElementInSnapshotStructure(IElement declaration);
    public static bool InMacroCall(LanguageElement element);
    public static IElement GetDeclaration(IElement element);
    public static IElement GetDeclaration(IElement element, bool restore);
    public static IElementCollection FindAllReferences(IElement element);
    public static IElementCollection FindAllReferences(IElement scope, IElement element);
    public static IAssemblyModel GetAssemblyModel(LanguageElement element);
    public static bool IsEventHandler(IMethodElement element);
    public static bool IsMainProcedure(Method method);
    public static bool IsSerializationConstructor(Method method);
    public static bool IsInitializeComponent(IMethodElement method);
    public static bool IsInteriorPtrPointer(TypeReferenceExpression type);
    public static IElementFilter GetMemberSignatureFilter(Method method);
    public static ITypeElement[] GetAllBaseTypes(ITypeElement element);
    public static bool IsWebMethod(Method method);
    public static bool CheckExtensionMethod(IMethodElement method);
    public static bool CheckExtensionMethod(ISourceTreeResolver resolver, IMethodElement method);
    public static bool HasDllImportAttribute(IMethodElement method);
    public static bool DeclarationsMatch(ISourceTreeResolver resolver, IElement first, IElement second);
    public static bool IsIdenticalTo(IElement first, IElement second);
    public static ITypeReferenceExpression GetInnerType(TypeReferenceExpression typeReferenceExpression);
    public static bool UsesTypeParameters(TypeReferenceExpression typeReferenceExpression, IGenericElement generic);
    public static bool IsTypeParameter(TypeReferenceExpression typeReferenceExpression, IGenericElement generic);
    public static IMemberElement FindMember(ITypeElement type, string name, IElementFilter filter, bool searchInAncestors);
    public static IMemberElementCollection FindMembers(ISourceTreeResolver resolver, ITypeElement type, string name, IElementFilter filter, bool searchInAncestors);
    public static IMemberElementCollection FindMembers(ITypeElement type, string name, IElementFilter filter, bool searchInAncestors);
    public static SourceFileBuildAction GetBuildAction(SourceFile sourceFile);
    public static ParserBase GetParserFromLanguageID(string language);
    public static IBraceSettings LoadBraceSettings();
    public static ITabSettings GetTabSettings(ParserLanguageID language);
    public static ILogger GetLogger();
    public static string GetXMLTagName();
    public static ISourceTreeResolver get_SourceTreeResolver();
    public static IFormattingService get_FormattingService();
    public static ISolutionElement get_ActiveSolution();
}
public abstract class DevExpress.CodeParser.SupportElement : LanguageElement {
    private LanguageElement _TargetNode;
    private SupportElementPosition _Position;
    public LanguageElement TargetNode { get; }
    public SupportElementPosition Position { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public virtual void SetTarget(LanguageElement targetNode);
    public LanguageElement get_TargetNode();
    public SupportElementPosition get_Position();
    public void set_Position(SupportElementPosition value);
}
public abstract class DevExpress.CodeParser.SupportElementCodeGenBase : LanguageElementCodeGenBase {
    public SupportElementCodeGenBase(CodeGen codeGen);
    protected virtual bool GenerateSupportElement(SupportElement element);
    protected abstract virtual void GenerateAttribute(Attribute element);
    protected abstract virtual void GenerateAttribute(AttributeSection element);
    protected abstract virtual void GenerateComment(Comment element);
    protected abstract virtual void GenerateCppAttribute(CppAttributeSection element);
    protected virtual void GenerateElementComment(CodeElement codeElement, SupportElementPosition position);
    protected bool HasSameLineRange(Comment com);
    protected virtual bool HasSameLineRange(Comment com, SupportElementPosition possiblePosition);
    public virtual void GenerateElement(LanguageElement languageElement);
    public virtual void GenerateAttributes(LanguageElement element);
    public virtual void GenerateElementForeComment(LanguageElement element);
    public virtual void GenerateElementBackComment(LanguageElement element);
    public static bool HasAfterComment(CodeElement target);
    public static bool HasSameLineRange(CodeElement target, Comment comment);
}
public enum DevExpress.CodeParser.SupportElementPosition : Enum {
    public byte value__;
    public static SupportElementPosition Before;
    public static SupportElementPosition Inside;
    public static SupportElementPosition After;
}
internal class DevExpress.CodeParser.SupportElements : object {
    private NodeList _Attributes;
    private NodeList _AttributeSections;
    private CommentCollection _Comments;
    private XmlDocComment _DocComment;
    public NodeList Attributes { get; public set; }
    public int AttributeCount { get; }
    public NodeList AttributeSections { get; public set; }
    [DescriptionAttribute("The number of AttributeSections associated with this element.")]
[CategoryAttribute("SupportElements")]
public int AttributeSectionsCount { get; }
    [DescriptionAttribute("A create-on-demand collection of comments bound to this element.")]
[CategoryAttribute("SupportElements")]
public CommentCollection InnerComments { get; public set; }
    public NodeList InnerAttributes { get; public set; }
    public NodeList InnerAttributeSections { get; public set; }
    [DescriptionAttribute("The number of comments bound to this element.")]
[CategoryAttribute("SupportElements")]
public int CommentCount { get; }
    [DescriptionAttribute("Gets xml doc comment associated with this element.")]
[CategoryAttribute("SupportElements")]
public XmlDocComment DocComment { get; public set; }
    public void CleanUp();
    public void TransferCommentsTo(CodeElement element);
    public void TransferXmlDocCommentTo(CodeElement element);
    public void AddComment(Comment comment);
    public void InsertComment(int index, Comment comment);
    public void RemoveComment(Comment comment);
    public void AddAttribute(Attribute attribute);
    public void AddAttributeSection(AttributeSection section);
    public bool ContainsElement(LanguageElement element);
    public void ReplaceElement(LanguageElement oldElement, LanguageElement newElement);
    public NodeList get_Attributes();
    public void set_Attributes(NodeList value);
    public int get_AttributeCount();
    public NodeList get_AttributeSections();
    public void set_AttributeSections(NodeList value);
    public int get_AttributeSectionsCount();
    public CommentCollection get_InnerComments();
    public void set_InnerComments(CommentCollection value);
    public NodeList get_InnerAttributes();
    public void set_InnerAttributes(NodeList value);
    public NodeList get_InnerAttributeSections();
    public void set_InnerAttributeSections(NodeList value);
    public int get_CommentCount();
    public XmlDocComment get_DocComment();
    public void set_DocComment(XmlDocComment value);
}
public class DevExpress.CodeParser.Switch : ParentingStatement {
    private static int INT_MaintainanceComplexity;
    private Expression _Expression;
    private LiteCaseStatementCollection _CaseStatements;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public bool IsNewContext { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.ISwitchStatement.Expression { get; }
    private ICaseStatementCollection DevExpress.CodeParser.ISwitchStatement.CaseStatements { get; }
    private void SetExpression(Expression expression);
    public void AddCaseStatement(LanguageElement element);
    public void AddCaseStatements(LanguageElementCollection elements);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual void CleanUpOwnedReferences();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_IsNewContext();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.ISwitchStatement.get_Expression();
    private sealed virtual override ICaseStatementCollection DevExpress.CodeParser.ISwitchStatement.get_CaseStatements();
}
public enum DevExpress.CodeParser.SymbolType : Enum {
    public int value__;
    public static SymbolType Letter;
    public static SymbolType Digit;
    public static SymbolType WhiteSpace;
    public static SymbolType Others;
    public static SymbolType Unknown;
}
public class DevExpress.CodeParser.TabSettings : object {
    private bool _InsertSpaces;
    private int _TabSize;
    public bool InsertSpaces { get; public set; }
    public int TabSize { get; public set; }
    public TabSettings(bool insertSpaces, int tabSize);
    public sealed virtual bool get_InsertSpaces();
    public sealed virtual void set_InsertSpaces(bool value);
    public sealed virtual int get_TabSize();
    public sealed virtual void set_TabSize(int value);
}
public class DevExpress.CodeParser.TakeExpression : TakeExpressionBase {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.TakeExpressionBase : QueryExpressionBase {
    private Expression _Expression;
    public Expression Expression { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public Expression get_Expression();
    public void set_Expression(Expression value);
}
public class DevExpress.CodeParser.TakeWhileExpression : TakeExpressionBase {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.TemplateCodeGenBase : LanguageElementCodeGenBase {
    public TemplateCodeGenBase(CodeGen codeGen);
    public virtual void GenerateElement(LanguageElement languageElement);
    public virtual bool GenerateTemplate(TemplateModifier modifier);
}
public class DevExpress.CodeParser.TemplateExpression : ElementReferenceExpression {
    private Expression _Qualifier;
    public LanguageElementType ElementType { get; }
    public Expression Qualifier { get; public set; }
    public virtual string ToString();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual Expression get_Qualifier();
    public virtual void set_Qualifier(Expression value);
}
public class DevExpress.CodeParser.TemplateModifier : CodeElement {
    private bool _IsExport;
    private LanguageElementCollection _Parameters;
    public LanguageElementType ElementType { get; }
    public bool IsExport { get; public set; }
    public LanguageElementCollection Parameters { get; public set; }
    public int ParametersCount { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public bool get_IsExport();
    public void set_IsExport(bool value);
    public LanguageElementCollection get_Parameters();
    public void set_Parameters(LanguageElementCollection value);
    public int get_ParametersCount();
    public virtual string ToString();
}
public class DevExpress.CodeParser.TemplateParameter : CodeElement {
    private Expression _DefaultValue;
    public LanguageElementType ElementType { get; }
    public Expression DefaultValue { get; public set; }
    private IExpression DevExpress.CodeParser.ITemplateParameter.DefaultValue { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeParameter.ActivatedType { get; }
    private ITypeParameterConstraintCollection DevExpress.CodeParser.ITypeParameter.Constraints { get; }
    private bool DevExpress.CodeParser.ITypeParameter.IsActivated { get; }
    private TypeParameterDirection DevExpress.CodeParser.ITypeParameter.Direction { get; }
    public TemplateParameter(string name, Expression defaultValue);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_DefaultValue();
    public void set_DefaultValue(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.ITemplateParameter.get_DefaultValue();
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeParameter.get_ActivatedType();
    private sealed virtual override ITypeParameterConstraintCollection DevExpress.CodeParser.ITypeParameter.get_Constraints();
    private sealed virtual override bool DevExpress.CodeParser.ITypeParameter.get_IsActivated();
    private sealed virtual override TypeParameterDirection DevExpress.CodeParser.ITypeParameter.get_Direction();
}
public abstract class DevExpress.CodeParser.TemplateParameterCodeGenBase : LanguageElementCodeGenBase {
    public TemplateParameterCodeGenBase(CodeGen codeGen);
    protected abstract virtual void GenerateClassTemplateParameter(ClassTemplateParameter parameter);
    protected abstract virtual void GenerateNamedTemplateParameter(NamedTemplateParameter parameter);
    protected abstract virtual void GenerateNestedTemplateParameter(NestedTemplateParameter parameter);
    public virtual bool GenerateTemplateParameter(TemplateParameter parameter);
    public virtual void GenerateElement(LanguageElement languageElement);
}
public class DevExpress.CodeParser.TextPoint : ValueType {
    public static TextPoint Empty;
    private int _Line;
    private int _Offset;
    public int Offset { get; }
    public int Line { get; }
    public bool IsEmpty { get; }
    public TextPoint(int line, int offset);
    public int get_Offset();
    public int get_Line();
    public void Set(int line, int offset);
    public void Set(SourcePoint point);
    public void Set(Token token);
    public void SetOffset(int offset);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextPoint point);
    public virtual int GetHashCode();
    public int CompareTo(SourcePoint point);
    public virtual string ToString();
    public static SourcePoint op_Implicit(TextPoint point);
    public static TextPoint op_Implicit(SourcePoint point);
    public static bool op_Equality(TextPoint first, TextPoint second);
    public static bool op_Inequality(TextPoint first, TextPoint second);
    public bool get_IsEmpty();
}
internal class DevExpress.CodeParser.TextPointWrapper : object {
    public TextPoint Point;
}
public class DevExpress.CodeParser.TextRange : ValueType {
    public static TextRange Empty;
    public TextPoint Start;
    public TextPoint End;
    public bool IsPoint { get; }
    public bool IsEmpty { get; }
    public int LineCount { get; }
    public int LineCountMinusOne { get; }
    public TextRange(int startLine, int startOffset, int endLine, int endOffset);
    public TextRange(TextPoint start, TextPoint end);
    public void Set(int startLine, int startOffset, int endLine, int endOffset);
    public void Set(SourcePoint start, SourcePoint end);
    public void Set(SourceRange range);
    public void SetStart(TextPoint point);
    public void SetEnd(TextPoint point);
    public bool Contains(int line, int offset);
    public bool Contains(TextPoint point);
    public bool Contains(TextRange range);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextRange range);
    public virtual int GetHashCode();
    public virtual string ToString();
    public SourceRange ToSourceRange();
    public static bool op_Equality(TextRange range1, TextRange range2);
    public static bool op_Inequality(TextRange range1, TextRange range2);
    public bool get_IsPoint();
    public bool get_IsEmpty();
    public int get_LineCount();
    public int get_LineCountMinusOne();
    private sealed virtual override object System.ICloneable.Clone();
    public TextRange Clone();
    public static SourceRange op_Implicit(TextRange range);
    public static TextRange op_Implicit(SourceRange range);
}
public class DevExpress.CodeParser.TextRangeCollection : NodeList {
    public CollectionType CollectionType { get; }
    private TextRange DevExpress.CodeParser.ITextRangeCollection.Item { get; }
    public TextRangeCollection(int capacity);
    protected virtual NodeList CreateInstance();
    public sealed virtual CollectionType get_CollectionType();
    private sealed virtual override int DevExpress.CodeParser.ITextRangeCollection.IndexOf(TextRange r);
    private sealed virtual override TextRange DevExpress.CodeParser.ITextRangeCollection.get_Item(int index);
}
public class DevExpress.CodeParser.TextRangeWrapper : object {
    public TextRange Range;
    public TextRangeWrapper(TextRange range);
    public static void Set(TextRangeWrapper& _BlockStart, TextRange range);
    public static TextRange Get(TextRangeWrapper _BlockStart);
    public static TextRangeWrapper op_Implicit(SourceRange range);
    public static TextRangeWrapper op_Implicit(TextRange range);
    public static SourceRange op_Implicit(TextRangeWrapper range);
    public static TextRange op_Implicit(TextRangeWrapper range);
}
public class DevExpress.CodeParser.TextString : LanguageElement {
    private string _EscapedValue;
    private bool _IsVerbatim;
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use TextString.IsVerbatim")]
public bool IsLiteralString { get; }
    [EditorBrowsableAttribute("1")]
public DocumentHistorySlice History { get; }
    public string EscapedValue { get; }
    public bool IsVerbatim { get; }
    public PrimitiveExpression PrimitiveExpression { get; }
    public LanguageElementType ElementType { get; }
    public TextString(bool isVerbatim);
    public TextString(string text, bool isVerbatim);
    private string GetEscapedString(string name, bool isVerbatim);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected PrimitiveExpression GetPrimitiveExpression();
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public bool get_IsLiteralString();
    public virtual DocumentHistorySlice get_History();
    public string get_EscapedValue();
    public bool get_IsVerbatim();
    public PrimitiveExpression get_PrimitiveExpression();
    public virtual LanguageElementType get_ElementType();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.TextStringCollection : LanguageElementCollection {
    private Hashtable _RangesHash;
    public TextString Item { get; }
    protected virtual NodeList CreateInstance();
    public void Add(TextString s);
    public void AddUnique(TextString s);
    public void Remove(TextString s);
    public TextString Find(string s);
    public TextString Find(TextString s);
    public bool Contains(TextString s);
    public TextString get_Item(int index);
}
public class DevExpress.CodeParser.ThisReferenceExpression : Expression {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; }
    public ThisReferenceExpression(string name);
    public ThisReferenceExpression(string name, SourceRange range);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
}
public class DevExpress.CodeParser.Throw : Abort {
    private Expression _Expression;
    public LanguageElementType ElementType { get; }
    [DescriptionAttribute("The expression thrown.")]
[CategoryAttribute("Details")]
public Expression Expression { get; public set; }
    [DescriptionAttribute("The exception thrown.")]
[CategoryAttribute("Details")]
public string Exception { get; }
    private IExpression DevExpress.CodeParser.IThrowStatement.Expression { get; }
    protected void SetExpression(Expression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public string get_Exception();
    private sealed virtual override IExpression DevExpress.CodeParser.IThrowStatement.get_Expression();
}
public class DevExpress.CodeParser.Token : object {
    private short _Type;
    private int _StartPosition;
    private int _EndPosition;
    private int _Line;
    private int _EndLine;
    private int _Column;
    private int _EndColumn;
    private string _Value;
    private Token _Next;
    public int StartPosition { get; public set; }
    public int EndPosition { get; public set; }
    public int Line { get; public set; }
    public int EndLine { get; public set; }
    public int Column { get; public set; }
    public int EndColumn { get; public set; }
    public int Type { get; public set; }
    public SourceRange Range { get; public set; }
    public int Length { get; }
    public string EscapedValue { get; }
    public string Value { get; public set; }
    public Token Next { get; public set; }
    public Token(int type);
    public Token(SourceRange range, int tokenType, string value);
    public Token(int line, int column, int endLine, int endColumn, int tokenType, string value);
    public Token(int startPosition, int endPosition, int line, int column, int endLine, int endColumn, int tokenType, string value);
    private sealed virtual override object System.ICloneable.Clone();
    private string ReplaceUnicodeEscape(string s, int pos);
    protected string ReplaceUnicodeEscapes(string s);
    protected virtual void CloneDataFrom(Token source, ElementCloneOptions options);
    public SourceRange GetRange();
    public bool Match(int type);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual Token Clone();
    [EditorBrowsableAttribute("1")]
public virtual Token Clone(ElementCloneOptions options);
    public sealed virtual int get_StartPosition();
    public void set_StartPosition(int value);
    public sealed virtual int get_EndPosition();
    public void set_EndPosition(int value);
    public int get_Line();
    public void set_Line(int value);
    public int get_EndLine();
    public void set_EndLine(int value);
    public int get_Column();
    public void set_Column(int value);
    public int get_EndColumn();
    public void set_EndColumn(int value);
    public int get_Type();
    public void set_Type(int value);
    public SourceRange get_Range();
    public void set_Range(SourceRange value);
    public sealed virtual int get_Length();
    public string get_EscapedValue();
    public string get_Value();
    public void set_Value(string value);
    public Token get_Next();
    public void set_Next(Token value);
}
public class DevExpress.CodeParser.TokenBlock : object {
    private int _Type;
    private SourceRange _Range;
    public SourceRange Range { get; }
    public int Type { get; }
    public bool IsUnknown { get; }
    public TokenBlock(SourceRange range, int type);
    public SourceRange get_Range();
    public int get_Type();
    public bool get_IsUnknown();
}
public abstract class DevExpress.CodeParser.TokenCategorizedParserBase : GeneratedParserBase {
    private TokenCollection _SavedTokens;
    private bool _SetTokensCategory;
    public TokenCollection SavedTokens { get; }
    public bool SetTokensCategory { get; public set; }
    protected abstract virtual TokenCategory GetTokenCategory(CategorizedToken token);
    protected void SetKeywordTokenCategory(Token token);
    protected virtual void Get();
    public void SaveCategorizedTokenIfNeeded(Token token);
    public TokenCollection get_SavedTokens();
    public bool get_SetTokensCategory();
    public void set_SetTokensCategory(bool value);
}
public enum DevExpress.CodeParser.TokenCategory : Enum {
    public int value__;
    public static TokenCategory Text;
    public static TokenCategory Keyword;
    public static TokenCategory Operator;
    public static TokenCategory PreprocessorKeyword;
    public static TokenCategory String;
    public static TokenCategory Number;
    public static TokenCategory Comment;
    public static TokenCategory XmlComment;
    public static TokenCategory Identifier;
    public static TokenCategory CssComment;
    public static TokenCategory CssKeyword;
    public static TokenCategory CssPropertyName;
    public static TokenCategory CssPropertyValue;
    public static TokenCategory CssSelector;
    public static TokenCategory CssStringValue;
    public static TokenCategory HtmlServerSideScript;
    public static TokenCategory HtmlElementName;
    public static TokenCategory HtmlEntity;
    public static TokenCategory HtmlOperator;
    public static TokenCategory HtmlComment;
    public static TokenCategory HtmlAttributeName;
    public static TokenCategory HtmlAttributeValue;
    public static TokenCategory HtmlString;
    public static TokenCategory HtmlTagDelimiter;
    public static TokenCategory Unknown;
}
public static class DevExpress.CodeParser.TokenCategoryHelperFactory : object {
    public static ITokenCategoryHelper CreateHelperForFileExtensions(string extension);
    public static ITokenCategoryHelper CreateHelper(ParserLanguageID languageID);
}
public abstract class DevExpress.CodeParser.TokenCExpressionCodeGenBase : TokenExpressionCodeGenBase {
    public TokenCExpressionCodeGenBase(CodeGen codeGen);
    private static FormattingTokenType GetTokenType(AssignmentOperatorType opType);
    protected virtual void GenerateDateTimeMinValue();
    protected virtual string GetBinaryOperatorText(BinaryOperatorType operatorType);
    protected virtual void GenerateTypedElementReferenceExpression(TypedElementReferenceExpression expression);
    protected virtual bool GenerateExpression(Expression expression);
    protected virtual bool GenerateMacroExpression(Expression expression);
    protected virtual void GeneratePrimitiveExpression(PrimitiveExpression expression);
    protected virtual void GenerateExpressionTypeArgument(ExpressionTypeArgument expression);
    protected virtual void GenerateLogicalOperation(LogicalOperation expression);
    protected virtual void GenerateBinaryOperator(BinaryOperatorExpression expression);
    protected virtual void GenerateBinaryOperator(BinaryOperatorType op);
    protected virtual void GenerateTypeOfIsExpression(TypeOfIsExpression expression);
    protected virtual void GenerateAttributeVariableInitializer(AttributeVariableInitializer expression);
    protected virtual void GenerateIsNot(IsNot expression);
    protected virtual void GenerateConditionalExpression(ConditionalExpression expression);
    protected virtual void GenerateThisReferenceExpression(ThisReferenceExpression expression);
    protected virtual void GenerateMyClassExpression(MyClassExpression expression);
    protected virtual void GenerateTypeReferenceExpression(TypeReferenceExpression expression);
    protected virtual void GenerateIndexerExpression(IndexerExpression expression);
    protected virtual void GenerateLogicalInversion(LogicalInversion expression);
    protected virtual void GenerateAddressOfExpression(AddressOfExpression expression);
    protected virtual void GenerateAssignmentExpression(AssignmentExpression expression);
    protected virtual void GenerateTypeCastExpression(TypeCastExpression expression);
    protected virtual void GenerateArrayInitializerExpression(ArrayInitializerExpression expression);
    protected virtual void GenerateUnaryIncrement(UnaryIncrement expression);
    protected virtual void GenerateUnaryDecrement(UnaryDecrement expression);
    protected virtual void GenerateArrayCreateExpression(ArrayCreateExpression expression);
    protected virtual void GenerateObjectCreationExpression(ObjectCreationExpression expression);
    protected virtual void GenerateAnonymousMethodExpression(AnonymousMethodExpression expression);
    protected virtual void GenerateDateTime(object value);
    protected virtual void GenerateSizeOfExpression(SizeOfExpression expression);
    protected virtual void GenerateFunctionPointerTypeReference(FunctionPointerTypeReference expression);
    public virtual bool HasName(TypeReferenceExpression expression);
    public virtual void GenerateName(TypeReferenceExpression expression);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public static void GenerateAssignmentOperatorText(LanguageElementCodeGenBase codeGen);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.TokenCollection : CollectionBase {
    public Token Item { get; public set; }
    private IToken DevExpress.CodeParser.ITokenCollection.Item { get; }
    public int Add(Token token);
    public int IndexOf(Token token);
    public void Insert(int index, Token token);
    public void Remove(Token token);
    public bool Contains(Token token);
    public Token get_Item(int index);
    public void set_Item(int index, Token value);
    private sealed virtual override IToken DevExpress.CodeParser.ITokenCollection.get_Item(int index);
}
public class DevExpress.CodeParser.TokenCSnippetCodeGen : SnippetCodeGenBase {
    public TokenCSnippetCodeGen(CodeGen codeGen);
    protected virtual void GenerateSnippetCodeElement(SnippetCodeElement snippet);
    protected virtual void GenerateSnippetCodeMember(SnippetCodeMember snippet);
    protected virtual void GenerateSnippetCodeStatement(SnippetCodeStatement snippet);
    protected virtual void GenerateSnippetCodeStatementBlock(SnippetCodeStatementBlock snippet);
    protected virtual void GenerateSnippetExpression(SnippetExpression snippet);
}
public abstract class DevExpress.CodeParser.TokenCStatementCodeGenBase : StatementCodeGenBase {
    public TokenCStatementCodeGenBase(CodeGen codeGen);
    private bool HasChildVariables(Statement statement);
    private static bool HasAtLeastOneSnipppet(LanguageElement element);
    private static bool IsSystemSnippet(SnippetCodeElement element);
    protected static bool IsIfStatementWithElseAndNestedIf(Statement statement);
    protected void GenerateBlockStatementContents(Statement statement);
    protected void GenerateParentingStatement(ParentingStatement statement, FormattingTokenType keyword, FormattingTokenType delimiter);
    protected void GenerateParentingStatement(ParentingStatement statement, NodeList collection, FormattingTokenType keyword, FormattingTokenType delimiter);
    protected virtual void GenerateLabelStatement(Label statement);
    protected virtual void GenerateUnsafeStatement(UnsafeStatement statement);
    protected virtual void GenerateOptionStatement(OptionStatement statement);
    protected virtual bool GenerateStatement(Statement statement);
    protected virtual void GenerateAbortStatement(Abort statement);
    protected virtual void GenerateGotoStatement(Goto statement);
    protected virtual void GenerateBreakStatement(Break statement);
    protected virtual void GenerateContinueStatement(Continue statement);
    protected virtual void GenerateStatementStatement(Statement statement);
    protected virtual void GenerateMethodCallStatement(MethodCall statement);
    protected virtual void GenerateAssignmentStatement(Assignment statement);
    protected virtual void GenerateSwitchStatement(Switch statement);
    protected virtual void GenerateCaseStatement(Case statement);
    protected virtual void GenerateTryStatement(Try statement);
    protected virtual void GenerateCatchStatement(Catch statement);
    protected virtual void GenerateFinallyStatement(Finally statement);
    protected virtual void GenerateUsingStatement(UsingStatement statement);
    protected virtual void GenerateDoStatement(Do statement);
    protected virtual void GenerateForStatement(For statement);
    protected virtual void GenerateForEachStatement(ForEach statement);
    protected virtual void GenerateWhileStatement(While statement);
    protected virtual void GenerateIfStatement(If statement);
    protected virtual void GenerateElseIfStatement(ElseIf statement);
    protected virtual void GenerateElseStatement(Else statement);
    protected virtual void GenerateEmptyStatement(EmptyStatement statement);
    protected virtual void GenerateBlockStatement(Block statement);
    protected virtual void GenerateReturnStatement(Return statement);
    internal static bool NeedToAddBraces(Statement statement, CodeGenOptions options);
    internal static bool NeedToAddBraces(Statement statement, CodeGenOptions options, Boolean& alwaysHasBlock);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
}
public abstract class DevExpress.CodeParser.TokenExpressionCodeGenBase : ExpressionCodeGenBase {
    public TokenExpressionCodeGenBase(CodeGen codeGen);
    protected virtual void GenerateExpressionList(ExpressionCollectionBase expressions, FormattingTokenType delimiter);
    protected virtual void GenerateExpressionList(ExpressionCollectionBase expressions, FormattingTokenType delimiter, bool lineBreakAfterDelimiter);
    protected virtual FormattingTokenType GetBinaryOperatorToken(BinaryOperatorType op);
    protected virtual FormattingTokenType GetOperatorToken(UnaryOperatorExpression expression);
    protected virtual void GenerateReferenceExpressionBase(ReferenceExpressionBase expression, string delimiter);
    protected virtual void GenerateMethodCallExpression(MethodCallExpression expression);
    protected virtual void GenerateShortInitializeExpression(ShortInitializeExpression expression);
    protected virtual void GenerateParenthesizedExpression(ParenthesizedExpression expression);
    protected virtual void GeneratePrimitiveExpression(PrimitiveExpression expression);
    protected virtual void GenerateUnaryOperatorExpression(UnaryOperatorExpression expression);
    protected virtual void GenerateBinaryOperatorExpression(BinaryOperatorExpression expression);
    protected void GenerateUnaryOperator(UnaryOperatorExpression expression, FormattingTokenType operatorType);
}
public class DevExpress.CodeParser.TokenGenArgs : object {
    private FormattingElements _FormattingElements;
    private FormattingElements _UserFormattingElements;
    private bool _EndsEOLNecessary;
    public bool IsEmpty { get; }
    public FormattingElements FormattingElements { get; }
    public FormattingElements UserFormattingElements { get; }
    public bool EndsEOLNecessary { get; public set; }
    public TokenGenArgs(FormattingElements formattingElements);
    public bool get_IsEmpty();
    public void AddWhiteSpace();
    public void AddDecreaseIndent();
    public void AddIncreaseIndent();
    public void AddClearIndent();
    public void AddRestoreIndent();
    public void Reset();
    public bool Contains(object element);
    public void AddNewLine(int countConsecutive);
    public void AddNewLine();
    public void SetFormattingElements(FormattingElements nextElements);
    public void SetUserFormattingElements(FormattingElements userTokens);
    public FormattingElements get_FormattingElements();
    public FormattingElements get_UserFormattingElements();
    public bool get_EndsEOLNecessary();
    public void set_EndsEOLNecessary(bool value);
    public void ClearFormattingElements();
    internal bool IsLastElementNewLine();
    internal bool IsLastElementWhiteSpace();
    internal bool IsLastElementIndent();
    public TokenGenArgs SaveAndReset();
    public TokenGenArgs LogicForProcessComment();
}
public abstract class DevExpress.CodeParser.Tokenizer : object {
    public virtual TokenCategory GetUncategorizedTokenCategory(Token token);
    public virtual string GetTokenCategory(Token token, ParserVersion version);
    public abstract virtual IList`1<CategorizedToken> GetTokens(string code, EmbededLanguageKind languageKind, DotNetLanguageType embeddingDefaultLanguage);
    public IList`1<CategorizedToken> GetTokens(string code, DotNetLanguageType codeEmbeddingDefaultLanguage);
    public IList`1<CategorizedToken> GetTokens(string code);
    public string GetTokenCategory(Token token);
}
public abstract class DevExpress.CodeParser.TokenizerBase : object {
    private ISourceReader _SourceReader;
    private ScannerExtension _ScannerExtension;
    private Token _CurrentToken;
    private Token _NextToken;
    private TextStringCollection _TextStrings;
    private CommentCollection _Comments;
    private LanguageTokensBase _Tokens;
    private Queue _TokenQueue;
    private String[] emptyString;
    protected LanguageTokensBase Tokens { get; protected set; }
    protected Queue TokenQueue { get; }
    public ISourceReader SourceReader { get; public set; }
    public ScannerExtension ScannerExtension { get; public set; }
    public Token CurrentToken { get; public set; }
    public Token NextToken { get; public set; }
    public CommentCollection Comments { get; public set; }
    public TextStringCollection TextStrings { get; public set; }
    public bool Eof { get; }
    public TokenizerBase(ISourceReader reader);
    public TokenizerBase(ISourceReader reader, ScannerExtension extension);
    protected abstract virtual void CreateTokens();
    protected abstract virtual Token GotoNext();
    protected virtual Token GotoNextWithScannerExtension();
    protected virtual Token GetNextTokenFromLexer();
    protected virtual Token GetNextTokenWithScannerExtension(ScannerExtension extension, Token lexerToken);
    protected virtual void Prepare();
    protected string GetEmptyString(int length);
    public abstract virtual Token GetCodeBlock(Token token);
    public virtual void Reset(ISourceReader sourceReader);
    public virtual Token MoveForward();
    protected LanguageTokensBase get_Tokens();
    protected void set_Tokens(LanguageTokensBase value);
    protected Queue get_TokenQueue();
    public ISourceReader get_SourceReader();
    public void set_SourceReader(ISourceReader value);
    public ScannerExtension get_ScannerExtension();
    public void set_ScannerExtension(ScannerExtension value);
    public sealed virtual Token get_CurrentToken();
    public void set_CurrentToken(Token value);
    public sealed virtual Token get_NextToken();
    public void set_NextToken(Token value);
    public CommentCollection get_Comments();
    public void set_Comments(CommentCollection value);
    public TextStringCollection get_TextStrings();
    public void set_TextStrings(TextStringCollection value);
    public virtual bool get_Eof();
}
public enum DevExpress.CodeParser.TokenLanguage : Enum {
    public int value__;
    public static TokenLanguage Unknown;
    public static TokenLanguage CSharp;
    public static TokenLanguage Basic;
    public static TokenLanguage Html;
    public static TokenLanguage Css;
    public static TokenLanguage Xml;
    public static TokenLanguage JavaScript;
    public static TokenLanguage FSharp;
    public static TokenLanguage CPlusPlus;
}
public class DevExpress.CodeParser.TokenList : List`1<FormattingTokenType> {
    public TokenList(FormattingTokenType[] types);
    public TokenList Clone();
    public void AddUnique(TokenList tokenList);
    public void AddUnique(FormattingTokenType[] tokens);
    public bool ContainsAtLeastOne(TokenList tokens);
    public TokenList And(TokenList tokens);
    public static TokenList Merge(TokenList fTokens, TokenList sTokens);
    public static TokenList Load(XmlNode ruleNode);
    public void Save(XmlNode ruleNode);
}
public enum DevExpress.CodeParser.TokenPosition : Enum {
    public byte value__;
    public static TokenPosition Inside;
    public static TokenPosition BeforeFirstCodeChild;
    public static TokenPosition AfterEnd;
}
public class DevExpress.CodeParser.TokenQueueBase : object {
    private LinkedList _Queue;
    private int _CurrentPos;
    private Token _LastDequeuedToken;
    public int CurrentPos { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Token CurrentToken { get; }
    public Token NextToken { get; }
    public Token LastToken { get; }
    public Token LastDequeuedToken { get; }
    public bool Eof { get; }
    private sealed virtual override object System.ICloneable.Clone();
    public void Append(TokenQueueBase queue);
    public sealed virtual void CopyTo(Array array, int index);
    public bool Contains(Token token);
    public sealed virtual IEnumerator GetEnumerator();
    public TokenQueueBase Clone();
    public Token Peek();
    public Token Peek(int index);
    public void Clear();
    public Token Dequeue();
    public void Enqueue(Token token);
    public Token DequeueToken();
    public void EnqueueToken(Token token);
    public int TokenPosition(int token);
    public Token LookUpToken(int pos);
    public sealed virtual Token MoveForward();
    public bool ContainsToken(int token);
    public int GetUnparentedTokenPosition(int tokenType, int openType, int closeType);
    public bool ContainsUnparentedToken(int token);
    public virtual TokenQueueBase CloneQueue();
    public bool CurrentTokenMatches(int tokenType);
    public virtual string ToString();
    public void SkipUpTo(int tokenType);
    public void SkipUpTo(int tokenType, bool include);
    public TokenQueueBase QueueUpTo(int tokenType);
    public TokenQueueBase QueueUpTo(int tokenType, bool include);
    public void SetCurrentPos(int pos);
    public int get_CurrentPos();
    public void set_CurrentPos(int value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual Token get_CurrentToken();
    public sealed virtual Token get_NextToken();
    public Token get_LastToken();
    public Token get_LastDequeuedToken();
    public sealed virtual bool get_Eof();
}
public class DevExpress.CodeParser.TokenSourceFileCodeGenBase : SourceFileCodeGenBase {
    public TokenSourceFileCodeGenBase(CodeGen codeGen);
    private bool HasFileStartToken(SourceFile file);
    public virtual void GenerateElement(LanguageElement languageElement);
}
public abstract class DevExpress.CodeParser.TokenSupportElementCodeGenBase : SupportElementCodeGenBase {
    public TokenSupportElementCodeGenBase(CodeGen codeGen);
    protected virtual void GenerateAttributeTargetType(AttributeTargetType target);
    protected virtual void GenerateAttributeQualifier(Attribute attr, FormattingTokenType delimiter);
    protected virtual void GenerateAttribute(Attribute attr);
    protected virtual void GenerateAttribute(AttributeSection section);
    protected virtual void GenerateComment(Comment comment);
    protected virtual void GenerateElementComment(CodeElement codeElement, SupportElementPosition position);
    public virtual void GenerateAttributes(LanguageElement element);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    private bool GenerateCodeBlock(PropertyAccessor target);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
}
public class DevExpress.CodeParser.Try : ParentingStatement {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public virtual int GetCyclomaticComplexity();
    public virtual int GetImageIndex();
    public Finally GetFinally();
    public LanguageElement GetFinallyTarget();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.TryCastExpression : CppTypeCastExpression {
    public LanguageElementType ElementType { get; }
    protected virtual string GetString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.TypeCastExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private TypeReferenceExpression _TypeReference;
    private Expression _Target;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public TypeReferenceExpression TypeReference { get; public set; }
    public Expression Target { get; public set; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeCastExpression.TypeReference { get; }
    private IExpression DevExpress.CodeParser.ITypeCastExpression.Target { get; }
    public TypeCastExpression(TypeReferenceExpression type, Expression target);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public void SetTypeReference(TypeReferenceExpression type);
    public void SetTarget(Expression target);
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public TypeReferenceExpression get_TypeReference();
    public void set_TypeReference(TypeReferenceExpression value);
    public Expression get_Target();
    public void set_Target(Expression value);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeCastExpression.get_TypeReference();
    private sealed virtual override IExpression DevExpress.CodeParser.ITypeCastExpression.get_Target();
}
public class DevExpress.CodeParser.TypeCheck : BinaryOperatorExpression {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public TypeCheck(Expression left, Token token, Expression right);
    public TypeCheck(Expression left, Expression right);
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual int GetImageIndex();
}
public class DevExpress.CodeParser.TypeDeclaration : AccessSpecifiedElement {
    private bool _IsPartial;
    private TypeReferenceExpression _PrimaryAncestorType;
    private TypeReferenceExpressionCollection _SecondaryAncestorTypes;
    private bool _HasEndingSemicolon;
    private bool _GenerateBlock;
    public bool HasDefaultConstructor { get; }
    public LanguageElementType ElementType { get; }
    public TypeReferenceExpression PrimaryAncestorType { get; public set; }
    public TypeReferenceExpressionCollection SecondaryAncestorTypes { get; public set; }
    public bool IsNewContext { get; }
    public string FullName { get; }
    public IEnumerable AllFields { get; }
    public IEnumerable AllConstants { get; }
    public IEnumerable AllProperties { get; }
    public IEnumerable AllMethods { get; }
    public IEnumerable AllEvents { get; }
    public IEnumerable AllTypes { get; }
    public IEnumerable AllChildTypes { get; }
    public IEnumerable AllMembers { get; }
    private bool DevExpress.CodeParser.ITypeElement.IsTypeParameter { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeElement.PrimaryAncestor { get; }
    private ITypeReferenceExpressionCollection DevExpress.CodeParser.ITypeElement.SecondaryAncestors { get; }
    private IMemberElementCollection DevExpress.CodeParser.ITypeElement.Members { get; }
    [EditorBrowsableAttribute("1")]
public bool IsTypeDeclaration { get; }
    public bool HasEndingSemicolon { get; public set; }
    public bool GenerateBlock { get; public set; }
    public TypeDeclaration(string name);
    private bool CanHaveDeclarationInCurrentType(IElement element);
    protected virtual void SetPrimaryAncestorType(TypeReferenceExpression type);
    protected virtual void SetSecondaryAncestorTypes(TypeReferenceExpressionCollection types);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public sealed virtual IMemberElement FindMember(string name);
    public sealed virtual IMemberElement FindMember(string name, bool searchInAncestors);
    public sealed virtual IMemberElement FindMember(string name, IElementFilter filter, bool searchInAncestors);
    public sealed virtual IMemberElementCollection FindMembers(string name);
    public sealed virtual IMemberElementCollection FindMembers(ISourceTreeResolver resolver, string name);
    public sealed virtual IMemberElementCollection FindMembers(string name, bool searchInAncestors);
    public sealed virtual IMemberElementCollection FindMembers(string name, IElementFilter filter, bool searchInAncestors);
    public IMemberElementCollection FindMembers(ISourceTreeResolver resolver, string name, IElementFilter filter, bool searchInAncestors);
    public sealed virtual ITypeElement[] GetAllDescendants();
    public sealed virtual ITypeElement[] GetAllDescendants(IElement scope);
    public sealed virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver);
    public sealed virtual ITypeElement[] GetAllDescendants(ISourceTreeResolver resolver, IElement scope);
    public sealed virtual ITypeElement GetBaseType();
    public sealed virtual ITypeElement GetBaseType(ISourceTreeResolver resolver);
    public sealed virtual ITypeElement[] GetBaseTypes();
    public sealed virtual ITypeElement[] GetBaseTypes(ISourceTreeResolver resolver);
    public sealed virtual ITypeElement[] GetDescendants();
    public sealed virtual ITypeElement[] GetDescendants(IElement scope);
    public sealed virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver);
    public sealed virtual ITypeElement[] GetDescendants(ISourceTreeResolver resolver, IElement scope);
    public sealed virtual bool Is(string fullTypeName);
    public sealed virtual bool Is(ITypeElement type);
    public sealed virtual bool Is(Type type);
    public sealed virtual bool Is(ISourceTreeResolver resolver, string fullTypeName);
    public sealed virtual bool Is(ISourceTreeResolver resolver, ITypeElement type);
    public sealed virtual bool Is(ISourceTreeResolver resolver, Type type);
    public sealed virtual bool DescendsFrom(string fullTypeName);
    public sealed virtual bool DescendsFrom(ITypeElement type);
    public sealed virtual bool DescendsFrom(Type type);
    public sealed virtual bool DescendsFrom(ISourceTreeResolver resolver, string fullTypeName);
    public sealed virtual bool DescendsFrom(ISourceTreeResolver resolver, ITypeElement type);
    public sealed virtual bool DescendsFrom(ISourceTreeResolver resolver, Type type);
    public virtual void CleanUpOwnedReferences();
    public void AddSecondaryAncestorType(TypeReferenceExpression type);
    public void AddSecondaryAncestorTypes(TypeReferenceExpressionCollection types);
    private ITypeElement GetTypeElementFromCache(ITypeElement type);
    private bool TypeContainsDeclaration(ISourceTreeResolver resolver, ITypeElement type, IMemberElement declaration, SearchScope scope);
    public bool Declares(IElement element);
    public bool Declares(IElement element, bool searchBaseClasses);
    public bool Declares(IElement element, SearchScope scope, bool searchBaseClasses);
    public bool get_HasDefaultConstructor();
    public virtual LanguageElementType get_ElementType();
    public TypeReferenceExpression get_PrimaryAncestorType();
    public void set_PrimaryAncestorType(TypeReferenceExpression value);
    public TypeReferenceExpressionCollection get_SecondaryAncestorTypes();
    public void set_SecondaryAncestorTypes(TypeReferenceExpressionCollection value);
    public virtual bool get_IsNewContext();
    public sealed virtual string get_FullName();
    public IEnumerable get_AllFields();
    public IEnumerable get_AllConstants();
    public IEnumerable get_AllProperties();
    public IEnumerable get_AllMethods();
    public IEnumerable get_AllEvents();
    public IEnumerable get_AllTypes();
    public IEnumerable get_AllChildTypes();
    public IEnumerable get_AllMembers();
    private sealed virtual override bool DevExpress.CodeParser.ITypeElement.get_IsTypeParameter();
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeElement.get_PrimaryAncestor();
    private sealed virtual override ITypeReferenceExpressionCollection DevExpress.CodeParser.ITypeElement.get_SecondaryAncestors();
    private sealed virtual override IMemberElementCollection DevExpress.CodeParser.ITypeElement.get_Members();
    public virtual bool get_IsTypeDeclaration();
    public bool get_HasEndingSemicolon();
    public void set_HasEndingSemicolon(bool value);
    public bool get_GenerateBlock();
    public void set_GenerateBlock(bool value);
    private sealed virtual override void DevExpress.CodeParser.ITypeElementModifier.SetPrimaryAncestor(ITypeReferenceExpression type);
    private sealed virtual override void DevExpress.CodeParser.ITypeElementModifier.AddSecondaryAncestor(ITypeReferenceExpression type);
    private sealed virtual override void DevExpress.CodeParser.ITypeElementModifier.AddMember(IMemberElement member);
    private sealed virtual override void DevExpress.CodeParser.ITypeElementModifier.RemoveMember(IMemberElement member);
}
public abstract class DevExpress.CodeParser.TypeDeclarationCodeGenBase : LanguageElementCodeGenBase {
    public TypeDeclarationCodeGenBase(CodeGen codeGen);
    protected virtual bool GenerateTypeDeclaration(TypeDeclaration typeDeclaration);
    protected virtual void GenerateMembers(NodeList nodeList);
    protected abstract virtual void GenerateModuleDeclaration(Module type);
    protected abstract virtual void GenerateClassDeclaration(Class type);
    protected abstract virtual void GenerateStructDeclaration(Struct type);
    protected abstract virtual void GenerateManagedClassDeclaration(ManagedClass type);
    protected abstract virtual void GenerateManagedStructDeclaration(ManagedStruct type);
    protected abstract virtual void GenerateInterfaceClassDeclaration(InterfaceClass type);
    protected abstract virtual void GenerateInterfaceStructDeclaration(InterfaceStruct type);
    protected abstract virtual void GenerateValueClassDeclaration(ValueClass type);
    protected abstract virtual void GenerateValueStructDeclaration(ValueStruct type);
    protected abstract virtual void GenerateInterfaceDeclaration(Interface type);
    protected abstract virtual void GenerateEnumDeclaration(Enumeration type);
    protected abstract virtual void GenerateUnionDeclaration(Union type);
    public virtual void GenerateElement(LanguageElement languageElement);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public class DevExpress.CodeParser.TypeDeclarationFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public static bool IsTypeDeclaration(IElement element);
}
public class DevExpress.CodeParser.TypedElementReferenceExpression : ElementReferenceExpression {
    private char _TypeCharacter;
    private SourceRange _TypeCharacterRange;
    public char TypeCharacter { get; public set; }
    public SourceRange TypeCharacterRange { get; public set; }
    public LanguageElementType ElementType { get; }
    public TypedElementReferenceExpression(string name, char typeCharacter, SourceRange typeCharacterRange);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public sealed virtual char get_TypeCharacter();
    public void set_TypeCharacter(char value);
    public void SetTypeChar(char ch);
    public SourceRange get_TypeCharacterRange();
    public void set_TypeCharacterRange(SourceRange value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.TypeElementsFilter : ElementFilterBase {
    private TypeDeclaration _Scope;
    private bool _SearchBaseClasses;
    public TypeDeclaration Scope { get; }
    public TypeElementsFilter(TypeDeclaration scope);
    public TypeElementsFilter(TypeDeclaration scope, bool searchBaseClasses);
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public virtual IElementCollection Apply(IElementCollection elements);
    public TypeDeclaration get_Scope();
}
public class DevExpress.CodeParser.TypenameTypeParameter : CppTypeParameter {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.TypeOfExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _TypeReference;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public TypeReferenceExpression TypeReference { get; public set; }
    public Expression Expression { get; public set; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeOfExpression.TypeReference { get; }
    public TypeOfExpression(Expression type);
    public TypeOfExpression(TypeReferenceExpression type);
    private void SetTypeReference(Expression type);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public TypeReferenceExpression get_TypeReference();
    public void set_TypeReference(TypeReferenceExpression value);
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeOfExpression.get_TypeReference();
}
public class DevExpress.CodeParser.TypeOfIsExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _Exp;
    private TypeReferenceExpression _TypeReference;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    public TypeReferenceExpression TypeReference { get; public set; }
    private IExpression DevExpress.CodeParser.ITypeOfIsExpression.Expression { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeOfIsExpression.TypeReference { get; }
    private IExpression DevExpress.CodeParser.IBinaryOperatorExpression.LeftSide { get; }
    private BinaryOperatorType DevExpress.CodeParser.IBinaryOperatorExpression.BinaryOperator { get; }
    private IExpression DevExpress.CodeParser.IBinaryOperatorExpression.RightSide { get; }
    public TypeOfIsExpression(Expression expression, TypeReferenceExpression type);
    private void SetExpression(Expression expression);
    private void SetTypeReference(TypeReferenceExpression type);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public TypeReferenceExpression get_TypeReference();
    public void set_TypeReference(TypeReferenceExpression value);
    private sealed virtual override IExpression DevExpress.CodeParser.ITypeOfIsExpression.get_Expression();
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeOfIsExpression.get_TypeReference();
    private sealed virtual override IExpression DevExpress.CodeParser.IBinaryOperatorExpression.get_LeftSide();
    private sealed virtual override BinaryOperatorType DevExpress.CodeParser.IBinaryOperatorExpression.get_BinaryOperator();
    private sealed virtual override IExpression DevExpress.CodeParser.IBinaryOperatorExpression.get_RightSide();
}
public class DevExpress.CodeParser.TypeOrNamespaceFilter : ElementFilterBase {
    private TypeDeclarationFilter _TypeFilter;
    private NamespaceFilter _NamespaceFilter;
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
}
public class DevExpress.CodeParser.TypeParameter : CodeElement {
    private TypeParameterConstraintCollection _Constraints;
    private ITypeReferenceExpression _ActivatedType;
    private SourceRange _NameRange;
    private TypeParameterDirection _Direction;
    public TypeParameterDirection Direction { get; public set; }
    public LanguageElementType ElementType { get; }
    public TypeParameterConstraintCollection Constraints { get; public set; }
    public SourceRange NameRange { get; public set; }
    protected bool HasOuterRangeChildren { get; }
    private bool DevExpress.CodeParser.ITypeParameter.IsActivated { get; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeParameter.ActivatedType { get; }
    private ITypeParameterConstraintCollection DevExpress.CodeParser.ITypeParameter.Constraints { get; }
    private TypeParameterDirection DevExpress.CodeParser.ITypeParameter.Direction { get; }
    public TypeParameter(string name);
    public TypeParameter(string name, SourceRange range);
    public TypeParameter(string name, TypeParameterConstraintCollection constraints, SourceRange range);
    private void GetConstraintsFromDetailNodes();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual void CleanUpOwnedReferences();
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void SetConstraints(TypeParameterConstraintCollection constraints);
    public virtual int GetImageIndex();
    public void AddConstraint(TypeParameterConstraint constraint);
    public void RemoveConstraint(TypeParameterConstraint constraint);
    public TypeParameterDirection get_Direction();
    public void set_Direction(TypeParameterDirection value);
    public virtual LanguageElementType get_ElementType();
    public TypeParameterConstraintCollection get_Constraints();
    public void set_Constraints(TypeParameterConstraintCollection value);
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    protected virtual bool get_HasOuterRangeChildren();
    private sealed virtual override bool DevExpress.CodeParser.ITypeParameter.get_IsActivated();
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeParameter.get_ActivatedType();
    private sealed virtual override ITypeParameterConstraintCollection DevExpress.CodeParser.ITypeParameter.get_Constraints();
    private sealed virtual override TypeParameterDirection DevExpress.CodeParser.ITypeParameter.get_Direction();
    private sealed virtual override void DevExpress.CodeParser.ITypeParameterModifier.SetActivatedType(ITypeReferenceExpression type);
    private sealed virtual override void DevExpress.CodeParser.ITypeParameterModifier.AddConstraint(ITypeParameterConstraint constraint);
    private sealed virtual override void DevExpress.CodeParser.ITypeParameterModifier.RemoveConstraint(ITypeParameterConstraint constraint);
    private sealed virtual override void DevExpress.CodeParser.ITypeParameterModifier.SetDirection(TypeParameterDirection direction);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.TypeParameterCollection : LanguageElementCollectionBase {
    public TypeParameter Item { get; public set; }
    private ITypeParameter DevExpress.CodeParser.ITypeParameterCollection.Item { get; }
    public int Add(TypeParameter value);
    public void Add(TypeParameterCollection collection);
    public void AddRange(TypeParameterCollection collection);
    public bool Contains(TypeParameter value);
    public void CopyTo(TypeParameter[] array, int index);
    public int IndexOf(TypeParameter value);
    public void Insert(int index, TypeParameter value);
    public void Remove(TypeParameter value);
    public TypeParameter Find(string name);
    public virtual string ToString();
    public TypeParameter get_Item(int index);
    public void set_Item(int index, TypeParameter value);
    private sealed virtual override int DevExpress.CodeParser.ITypeParameterCollection.IndexOf(ITypeParameter t);
    private sealed virtual override ITypeParameter DevExpress.CodeParser.ITypeParameterCollection.Find(string name);
    private sealed virtual override ITypeParameter DevExpress.CodeParser.ITypeParameterCollection.get_Item(int index);
}
public abstract class DevExpress.CodeParser.TypeParameterConstraint : LanguageElement {
    public SourceRange NameRange { get; public set; }
    public TypeParameterConstraint(string name, SourceRange range);
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.TypeParameterConstraintCollection : LanguageElementCollectionBase {
    public TypeParameterConstraint Item { get; public set; }
    private ITypeParameterConstraint DevExpress.CodeParser.ITypeParameterConstraintCollection.Item { get; }
    public int Add(TypeParameterConstraint value);
    public void Add(TypeParameterConstraintCollection collection);
    public void AddRange(TypeParameterConstraintCollection collection);
    public bool Contains(TypeParameterConstraint value);
    public void CopyTo(TypeParameterConstraint[] array, int index);
    public int IndexOf(TypeParameterConstraint value);
    public void Insert(int index, TypeParameterConstraint value);
    public void Remove(TypeParameterConstraint value);
    public TypeParameterConstraint get_Item(int index);
    public void set_Item(int index, TypeParameterConstraint value);
    private sealed virtual override int DevExpress.CodeParser.ITypeParameterConstraintCollection.IndexOf(ITypeParameterConstraint t);
    private sealed virtual override ITypeParameterConstraint DevExpress.CodeParser.ITypeParameterConstraintCollection.get_Item(int index);
}
public enum DevExpress.CodeParser.TypeParameterDirection : Enum {
    public byte value__;
    public static TypeParameterDirection In;
    public static TypeParameterDirection Out;
    public static TypeParameterDirection None;
}
public class DevExpress.CodeParser.TypeReferenceExpression : ReferenceExpressionBase {
    private static int INT_MaintainanceComplexity;
    private bool _IsConst;
    private bool _IsVolatile;
    private bool _IsManaged;
    private int _Rank;
    private int _TypeArity;
    private bool _IsUnbound;
    private TextRange _NameRange;
    private TypeReferenceType _Type;
    private Expression _BaseType;
    private ExpressionCollection _ArrayBounds;
    private bool _IsNullable;
    private bool _IsDynamic;
    private GCReferenceType _GCType;
    private ArrayStorageClassQualifier _ArrayStorageClass;
    private TypeReferenceExpression _BasedPointer;
    private bool _IsTypeCharacter;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; public set; }
    public GCReferenceType GCType { get; public set; }
    public TypeReferenceExpression BaseType { get; public set; }
    public Expression Qualifier { get; public set; }
    public int Rank { get; public set; }
    public ExpressionCollection ArrayBounds { get; public set; }
    public bool IsArrayType { get; }
    public bool IsPointerType { get; }
    public bool IsConst { get; public set; }
    public bool IsVolatile { get; public set; }
    public bool IsManaged { get; public set; }
    public bool IsReferenceType { get; }
    public bool IsNullable { get; public set; }
    public bool IsDynamic { get; public set; }
    public int TypeArity { get; public set; }
    public bool IsUnbound { get; public set; }
    public TypeReferenceType TypeReferenceType { get; public set; }
    public bool HasElementType { get; }
    public ArrayStorageClassQualifier ArrayStorageClass { get; public set; }
    public TypeReferenceExpression BasedPointer { get; public set; }
    public bool IsTypeCharacter { get; public set; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeReferenceExpression.BaseType { get; }
    private int DevExpress.CodeParser.ITypeReferenceExpression.Rank { get; }
    private IExpressionCollection DevExpress.CodeParser.ITypeReferenceExpression.ArrayBounds { get; }
    private bool DevExpress.CodeParser.ITypeReferenceExpression.IsNullable { get; }
    private bool DevExpress.CodeParser.ITypeReferenceExpression.IsDynamic { get; }
    public TypeReferenceExpression(string type);
    public TypeReferenceExpression(string type, SourceRange range);
    public TypeReferenceExpression(string type, TypeReferenceExpressionCollection typeArguments, SourceRange range);
    public TypeReferenceExpression(TypeReferenceExpression type, int rank);
    public TypeReferenceExpression(TypeReferenceExpression type, int rank, ExpressionCollection bounds);
    public TypeReferenceExpression(TypeReferenceExpression type);
    public TypeReferenceExpression(TypeReferenceExpression type, TypeReferenceType typeReference);
    public TypeReferenceExpression(TypeReferenceType typeReference);
    public TypeReferenceExpression(int rank, ExpressionCollection bounds);
    public TypeReferenceExpression(TypeReferenceExpression type, bool isNullable);
    public TypeReferenceExpression(string name, SourceRange nameRange, TypeReferenceExpression type);
    public TypeReferenceExpression(string type, int typeArity, SourceRange range);
    protected void SetArrayBounds(ExpressionCollection bounds);
    protected void SetBaseType(TypeReferenceExpression baseType);
    protected void SetRank(int rank);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    [EditorBrowsableAttribute("1")]
public void SetTypeProperties(ITypeReferenceExpression type);
    [EditorBrowsableAttribute("1")]
public void SetBaseTypeAfterCreation(TypeReferenceExpression baseType);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public sealed virtual bool IsIdenticalTo(ITypeReferenceExpression typeRef);
    public sealed virtual ITypeReferenceExpression GetElementType();
    public sealed virtual bool UsesTypeParameters(IGenericElement generic);
    public sealed virtual bool IsTypeParameter(IGenericElement generic);
    public sealed virtual ITypeReferenceExpression CreateArrayReference(int rank);
    public virtual bool Is(string fullTypeName);
    public virtual bool Is(ITypeElement type);
    public virtual bool Is(Type type);
    public virtual bool Is(ISourceTreeResolver resolver, string fullTypeName);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public GCReferenceType get_GCType();
    public void set_GCType(GCReferenceType value);
    public virtual TypeReferenceExpression get_BaseType();
    public virtual void set_BaseType(TypeReferenceExpression value);
    public virtual Expression get_Qualifier();
    public virtual void set_Qualifier(Expression value);
    public virtual int get_Rank();
    public virtual void set_Rank(int value);
    public virtual ExpressionCollection get_ArrayBounds();
    public virtual void set_ArrayBounds(ExpressionCollection value);
    public virtual bool get_IsArrayType();
    public virtual bool get_IsPointerType();
    public virtual bool get_IsConst();
    public virtual void set_IsConst(bool value);
    public virtual bool get_IsVolatile();
    public virtual void set_IsVolatile(bool value);
    public virtual bool get_IsManaged();
    public virtual void set_IsManaged(bool value);
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsNullable();
    public virtual void set_IsNullable(bool value);
    public virtual bool get_IsDynamic();
    public virtual void set_IsDynamic(bool value);
    public virtual int get_TypeArity();
    public virtual void set_TypeArity(int value);
    public virtual bool get_IsUnbound();
    public virtual void set_IsUnbound(bool value);
    public virtual TypeReferenceType get_TypeReferenceType();
    public virtual void set_TypeReferenceType(TypeReferenceType value);
    public sealed virtual bool get_HasElementType();
    public ArrayStorageClassQualifier get_ArrayStorageClass();
    public void set_ArrayStorageClass(ArrayStorageClassQualifier value);
    public TypeReferenceExpression get_BasedPointer();
    public void set_BasedPointer(TypeReferenceExpression value);
    public bool get_IsTypeCharacter();
    public void set_IsTypeCharacter(bool value);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeReferenceExpression.get_BaseType();
    private sealed virtual override int DevExpress.CodeParser.ITypeReferenceExpression.get_Rank();
    private sealed virtual override IExpressionCollection DevExpress.CodeParser.ITypeReferenceExpression.get_ArrayBounds();
    private sealed virtual override bool DevExpress.CodeParser.ITypeReferenceExpression.get_IsNullable();
    private sealed virtual override bool DevExpress.CodeParser.ITypeReferenceExpression.get_IsDynamic();
    public virtual ITypeReferenceExpression CreateResolvePoint();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.TypeReferenceExpressionCollection : ExpressionCollectionBase {
    public TypeReferenceExpression Item { get; public set; }
    private ITypeReferenceExpression DevExpress.CodeParser.ITypeReferenceExpressionCollection.Item { get; }
    [IteratorStateMachineAttribute("DevExpress.CodeParser.TypeReferenceExpressionCollection/<System-Collections-Generic-IEnumerable<DevExpress-CodeParser-TypeReferenceExpression>-GetEnumerator>d__0")]
private sealed virtual override IEnumerator`1<TypeReferenceExpression> System.Collections.Generic.IEnumerable<DevExpress.CodeParser.TypeReferenceExpression>.GetEnumerator();
    public int Add(TypeReferenceExpression expression);
    public void AddRange(TypeReferenceExpressionCollection collection);
    public int IndexOf(TypeReferenceExpression expression);
    public void Insert(int index, TypeReferenceExpression expression);
    public void Remove(TypeReferenceExpression expression);
    public Expression Find(TypeReferenceExpression expression);
    public bool Contains(TypeReferenceExpression expression);
    public StringCollection ToStringCollection();
    protected virtual NodeList CreateInstance();
    public TypeReferenceExpression get_Item(int index);
    public void set_Item(int index, TypeReferenceExpression value);
    private sealed virtual override int DevExpress.CodeParser.ITypeReferenceExpressionCollection.IndexOf(ITypeReferenceExpression t);
    private sealed virtual override ITypeReferenceExpression DevExpress.CodeParser.ITypeReferenceExpressionCollection.get_Item(int index);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerator <>n__0();
}
public class DevExpress.CodeParser.TypeReferenceExpressionWrapper : TypeReferenceExpression {
    private LanguageElement _ResolvePoint;
    private IElement DevExpress.CodeParser.IHasResolvePoint.ResolvePoint { get; private set; }
    public string Name { get; public set; }
    public SourceRange NameRange { get; public set; }
    public TypeReferenceExpression BaseType { get; public set; }
    public int Rank { get; public set; }
    public ExpressionCollection ArrayBounds { get; public set; }
    public bool IsArrayType { get; }
    public bool IsPointerType { get; }
    public bool IsConst { get; }
    public bool IsVolatile { get; }
    public bool IsReferenceType { get; }
    public bool IsManaged { get; }
    public TypeReferenceType TypeReferenceType { get; }
    public bool IsNullable { get; public set; }
    public bool IsUnbound { get; }
    public LanguageElement ResolvePoint { get; public set; }
    public bool IsGeneric { get; }
    public TypeReferenceExpressionCollection TypeArguments { get; }
    public TypeReferenceExpressionWrapper(TypeReferenceExpression typeReference);
    private sealed virtual override IElement DevExpress.CodeParser.IHasResolvePoint.get_ResolvePoint();
    private sealed virtual override void DevExpress.CodeParser.IHasResolvePoint.set_ResolvePoint(IElement value);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    private TypeReferenceExpression GetTypeReference();
    public virtual string ToString();
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual SourceRange get_NameRange();
    public virtual void set_NameRange(SourceRange value);
    public virtual TypeReferenceExpression get_BaseType();
    public virtual void set_BaseType(TypeReferenceExpression value);
    public virtual int get_Rank();
    public virtual void set_Rank(int value);
    public virtual ExpressionCollection get_ArrayBounds();
    public virtual void set_ArrayBounds(ExpressionCollection value);
    public virtual bool get_IsArrayType();
    public virtual bool get_IsPointerType();
    public virtual bool get_IsConst();
    public virtual bool get_IsVolatile();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsManaged();
    public virtual TypeReferenceType get_TypeReferenceType();
    public virtual bool get_IsNullable();
    public virtual void set_IsNullable(bool value);
    public virtual bool get_IsUnbound();
    public LanguageElement get_ResolvePoint();
    public void set_ResolvePoint(LanguageElement value);
    public virtual bool get_IsGeneric();
    public virtual TypeReferenceExpressionCollection get_TypeArguments();
    public virtual ITypeReferenceExpression CreateResolvePoint();
}
public enum DevExpress.CodeParser.TypeReferenceType : Enum {
    public int value__;
    public static TypeReferenceType None;
    public static TypeReferenceType Array;
    public static TypeReferenceType Pointer;
    public static TypeReferenceType Reference;
}
public class DevExpress.CodeParser.UnaryDecrement : UnaryOperatorExpression {
    private static int INT_PreMaintainanceComplexity;
    private static int INT_PostMaintainanceComplexity;
    public bool CanBeStatement { get; }
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public UnaryDecrement(Token token, Expression expression, bool isPostDecrement);
    public UnaryDecrement(Expression expression, bool isPostDecrement);
    public virtual bool get_CanBeStatement();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.UnaryIncrement : UnaryOperatorExpression {
    private static int INT_PreMaintainanceComplexity;
    private static int INT_PostMaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public bool CanBeStatement { get; }
    public UnaryIncrement(Token token, Expression expression, bool isPostIncrement);
    public UnaryIncrement(Expression expression, bool isPostIncrement);
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_CanBeStatement();
}
public class DevExpress.CodeParser.UnaryOperatorExpression : OperatorExpression {
    private static int INT_MaintainanceComplexity;
    private UnaryOperatorType _Operator;
    private Expression _Expression;
    private bool _IsPostOperator;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    [ObsoleteAttribute("Use Expression instead.")]
[EditorBrowsableAttribute("1")]
public Expression UnaryExpression { get; public set; }
    public bool IsPostOperator { get; public set; }
    public UnaryOperatorType UnaryOperator { get; public set; }
    [ObsoleteAttribute("Use UnaryOperator instead.")]
[EditorBrowsableAttribute("1")]
public UnaryOperatorType Operator { get; public set; }
    private IExpression DevExpress.CodeParser.IUnaryOperatorExpression.UnaryExpression { get; }
    private IExpression DevExpress.CodeParser.IUnaryOperatorExpression.Expression { get; }
    private bool DevExpress.CodeParser.IUnaryOperatorExpression.IsPostOperator { get; }
    private UnaryOperatorType DevExpress.CodeParser.IUnaryOperatorExpression.UnaryOperator { get; }
    public UnaryOperatorExpression(Token token, Expression expression);
    public UnaryOperatorExpression(Expression expression);
    public UnaryOperatorExpression(Token token, Expression expression, bool isPostOperator);
    public UnaryOperatorExpression(Expression expression, bool isPostOperator);
    public UnaryOperatorExpression(string op, Expression expression, bool isPostOperator);
    public UnaryOperatorExpression(UnaryOperatorType op, Expression expression, bool isPostOperator);
    protected void SetExpression(Expression expression);
    [ObsoleteAttribute("Use SetExpression instead.")]
[EditorBrowsableAttribute("1")]
protected void SetUnaryExpression(Expression expression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void OwnedReferencesTransferred();
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public static OperatorType GetOverloadableOperatorType(UnaryOperatorType unary);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    public Expression get_UnaryExpression();
    public void set_UnaryExpression(Expression value);
    public bool get_IsPostOperator();
    public void set_IsPostOperator(bool value);
    public UnaryOperatorType get_UnaryOperator();
    public void set_UnaryOperator(UnaryOperatorType value);
    public UnaryOperatorType get_Operator();
    public void set_Operator(UnaryOperatorType value);
    private sealed virtual override IExpression DevExpress.CodeParser.IUnaryOperatorExpression.get_UnaryExpression();
    private sealed virtual override IExpression DevExpress.CodeParser.IUnaryOperatorExpression.get_Expression();
    private sealed virtual override bool DevExpress.CodeParser.IUnaryOperatorExpression.get_IsPostOperator();
    private sealed virtual override UnaryOperatorType DevExpress.CodeParser.IUnaryOperatorExpression.get_UnaryOperator();
}
public enum DevExpress.CodeParser.UnaryOperatorType : Enum {
    public byte value__;
    public static UnaryOperatorType None;
    public static UnaryOperatorType Decrement;
    public static UnaryOperatorType Increment;
    public static UnaryOperatorType UnaryNegation;
    public static UnaryOperatorType UnaryPlus;
    public static UnaryOperatorType LogicalNot;
    public static UnaryOperatorType AddressOf;
    public static UnaryOperatorType OnesComplement;
    public static UnaryOperatorType PointerDereference;
    public static UnaryOperatorType TrackingReference;
}
public class DevExpress.CodeParser.Unchecked : ParentingStatement {
    public LanguageElementType ElementType { get; }
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.UncheckedExpression : Expression {
    private static int INT_MaintainanceComplexity;
    private Expression _Exp;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IUncheckedExpression.Expression { get; }
    public UncheckedExpression(Expression expression);
    private void SetExpression(Expression expression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual bool IsIdenticalTo(Expression expression);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IUncheckedExpression.get_Expression();
}
public class DevExpress.CodeParser.UndefDirective : CompilerDirective {
    public string Symbol { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public string get_Symbol();
    public void set_Symbol(string value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.Union : Class {
    public LanguageElementType ElementType { get; }
    public Union(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.UnsafeStatement : ParentToSingleStatement {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.UsingDeclaration : NamespaceReference {
    private Expression _Declaration;
    public LanguageElementType ElementType { get; }
    public Expression Declaration { get; public set; }
    public UsingDeclaration(Expression declaration);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Declaration();
    public void set_Declaration(Expression value);
}
public class DevExpress.CodeParser.UsingDeclarationFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
}
public class DevExpress.CodeParser.UsingStatement : ParentToSingleStatement {
    private LanguageElementCollection _Initializers;
    public LanguageElementType ElementType { get; }
    [ObsoleteAttribute("Use Initializers instead.")]
[EditorBrowsableAttribute("1")]
public LanguageElement InitializedDeclaration { get; }
    public LanguageElementCollection Initializers { get; }
    private IElementCollection DevExpress.CodeParser.IUsingStatement.Initializers { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public void AddInitializer(LanguageElement initializer);
    public void AddInitializers(LanguageElementCollection initializers);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public LanguageElement get_InitializedDeclaration();
    public LanguageElementCollection get_Initializers();
    private sealed virtual override IElementCollection DevExpress.CodeParser.IUsingStatement.get_Initializers();
}
public class DevExpress.CodeParser.ValueClass : Class {
    public LanguageElementType ElementType { get; }
    public ValueClass(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ValueClassTypeParameterConstraint : TypeParameterConstraint {
    public LanguageElementType ElementType { get; }
    public ValueClassTypeParameterConstraint(string name, SourceRange range);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ValueStruct : Struct {
    public LanguageElementType ElementType { get; }
    public ValueStruct(string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.ValueStructTypeParameterConstraint : TypeParameterConstraint {
    public LanguageElementType ElementType { get; }
    public ValueStructTypeParameterConstraint(string name, SourceRange range);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.Variable : BaseVariable {
    private Variable _AncestorVariable;
    private Variable _PreviousVariable;
    private Variable _NextVariable;
    private bool _IsEvent;
    private Expression _FixedSize;
    private bool _HasType;
    private bool _IsAspxTag;
    private bool _IsRunAtServer;
    [EditorBrowsableAttribute("1")]
public string ArrayModifier;
    public LanguageElementType ElementType { get; }
    public bool IsDefaultVisibility { get; }
    public bool IsNew { get; }
    public bool IsReadOnly { get; }
    public bool IsStatic { get; }
    public bool IsVolatile { get; }
    public bool IsWithEvents { get; }
    public MemberVisibility Visibility { get; }
    [DescriptionAttribute("The Variable that contibutes type, modifiers (static, volatile, new, and/or readonly), and visibility to this variable. This property will be assigned if this variable was declared in a list (e.g., "int a, b;").")]
[CategoryAttribute("Modifiers")]
public Variable AncestorVariable { get; }
    [DescriptionAttribute("True if this variable inherits modifiers from a previously-declared variable. For example, in the C# declaration "int aa, bb;", bb inherits its type and modifiers from aa. If this property is true, you can access the variable providing the modifiers through the AncestorVariable property.")]
[CategoryAttribute("Modifiers")]
public bool InheritsModifiers { get; }
    [DescriptionAttribute("Gets previous variable if this variable is in declaration list. E.g. for the code int i, j, k; previous variable for "j" will be "i".")]
[CategoryAttribute("Family")]
public Variable PreviousVariable { get; }
    [DescriptionAttribute("Gets next variable if this variable is in declaration list. E.g. for the code int i, j, k; next variable for "j" will be "k".")]
[CategoryAttribute("Family")]
public Variable NextVariable { get; }
    [DescriptionAttribute("Returns true if this variable is in variable declaration list. E.g. for the code int i, j, k; variables i, j, k are in list.")]
[CategoryAttribute("Family")]
public bool IsInDeclarationList { get; }
    [DescriptionAttribute("Returns first variable inside variable delcaration list. E.g. for the code int i, j, k; it will return i variable.")]
[CategoryAttribute("Family")]
public Variable FirstVariable { get; }
    [DescriptionAttribute("Returns last variable inside variable delcaration list. E.g. for the code int i, j, k; it will return k variable.")]
[CategoryAttribute("Family")]
public Variable LastVariable { get; }
    [DescriptionAttribute("Returns true if this variable is in the start of a variable declaration list.")]
[CategoryAttribute("Family")]
public bool IsStart { get; }
    [DescriptionAttribute("Returns true if this variable is in the middle of a variable declaration list.")]
[CategoryAttribute("Family")]
public bool IsMiddle { get; }
    [DescriptionAttribute("Returns true if this variable is in the end of a variable declaration list.")]
[CategoryAttribute("Family")]
public bool IsEnd { get; }
    [DescriptionAttribute("Returns true if this variable has type.")]
[CategoryAttribute("Family")]
public bool HasType { get; public set; }
    [DescriptionAttribute("Returns true if this variable declares fixed size buffer.")]
[CategoryAttribute("Family")]
public bool IsFixedSizeBuffer { get; }
    [DescriptionAttribute("Gets or sets fixed size variable expression.")]
[CategoryAttribute("Family")]
public Expression FixedSize { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsAspxTag { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IsRunAtServer { get; public set; }
    private bool DevExpress.CodeParser.IFieldElement.IsConst { get; }
    private IExpression DevExpress.CodeParser.IFieldElement.Expression { get; }
    private bool DevExpress.CodeParser.IFieldElement.IsBitField { get; }
    private IExpression DevExpress.CodeParser.IFieldElement.BitFieldSize { get; }
    private IElement DevExpress.CodeParser.IFieldElement.NodeLink { get; }
    private bool DevExpress.CodeParser.IFieldElement.HasNodeLink { get; }
    public bool IsEvent { get; public set; }
    public Variable(string name);
    public Variable(string type, string name);
    protected internal virtual bool GetCanBeDocumented();
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
protected virtual void SetFixedSize(Expression expression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual void CleanUpOwnedReferences();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("2")]
public void SetNextVariable(Variable variable);
    [EditorBrowsableAttribute("2")]
public void SetPreviousVariable(Variable variable);
    [EditorBrowsableAttribute("2")]
public void SetAncestorVariable(Variable variable);
    public ArrayList GetDeclarationList();
    public ArrayList GetReferencesInRange(SourceRange range);
    private Variable RequestClonedVariable(Variable variable, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_IsDefaultVisibility();
    public virtual bool get_IsNew();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVolatile();
    public virtual bool get_IsWithEvents();
    public virtual MemberVisibility get_Visibility();
    public Variable get_AncestorVariable();
    public bool get_InheritsModifiers();
    public Variable get_PreviousVariable();
    public Variable get_NextVariable();
    public bool get_IsInDeclarationList();
    public Variable get_FirstVariable();
    public Variable get_LastVariable();
    public bool get_IsStart();
    public bool get_IsMiddle();
    public bool get_IsEnd();
    public bool get_HasType();
    public void set_HasType(bool value);
    public virtual bool get_IsFixedSizeBuffer();
    public Expression get_FixedSize();
    public void set_FixedSize(Expression value);
    public virtual bool get_IsAspxTag();
    public virtual void set_IsAspxTag(bool value);
    public virtual bool get_IsRunAtServer();
    public virtual void set_IsRunAtServer(bool value);
    private sealed virtual override bool DevExpress.CodeParser.IFieldElement.get_IsConst();
    private sealed virtual override IExpression DevExpress.CodeParser.IFieldElement.get_Expression();
    private sealed virtual override bool DevExpress.CodeParser.IFieldElement.get_IsBitField();
    private sealed virtual override IExpression DevExpress.CodeParser.IFieldElement.get_BitFieldSize();
    private sealed virtual override IElement DevExpress.CodeParser.IFieldElement.get_NodeLink();
    private sealed virtual override bool DevExpress.CodeParser.IFieldElement.get_HasNodeLink();
    public bool get_IsEvent();
    public void set_IsEvent(bool value);
    private sealed virtual override string DevExpress.CodeParser.IMemberElement.get_Signature();
}
public class DevExpress.CodeParser.VariableFilter : ElementFilterBase {
    public virtual bool Apply(IElement element);
    public virtual bool SkipChildren(IElement element);
    public virtual IElementCollection Apply(IElementCollection elements);
}
public class DevExpress.CodeParser.VB.AdaptedScannerBase : object {
    protected static char EOT;
    protected static char EOF;
    private string _CharsFromPeekTokens;
    private int _CharIndex;
    private int _CharPeekIndex;
    private VBScannerBase _Scanner;
    private char _PrevChar;
    private char ch;
    private Token tokens;
    protected string CharsFromPeekTokens { get; protected set; }
    protected int CharIndex { get; protected set; }
    protected char PrevChar { get; protected set; }
    protected Token Tokens { get; protected set; }
    protected char Ch { get; protected set; }
    public char CurrentChar { get; public set; }
    private void AddCharsFromPeek(string str);
    private ArrayList GetXmlTokens(Token peekToken, int startIndex);
    private string GetIntervalValue(SourceRange fRange, SourceRange sRange);
    private string GetIntervalValue(SourcePoint fPoint, SourcePoint sPoint);
    private string GetLineTerms(int count);
    private string GetWhitespaces(int count);
    private char GetCharsInPeekTokens();
    private bool HasCharsInPeekTokens();
    protected char PeekChar(Boolean& correctChar);
    protected void NextCh();
    protected void SetCharFromScanner();
    protected void ResetCharPeek();
    protected void ResetCharsFromPeekTokens();
    protected void SetCharsFromPeekTokens(ArrayList xmlTokens);
    protected void SetCharsFromPeekTokens(Token fToken, Token sToken);
    protected void ResetPeekIndex();
    protected bool IsEof();
    protected bool IsEof(char chr);
    protected void DeletePeekElements(int startIndex, string peekString);
    protected char GetPeekChar(Boolean& correctChar);
    protected char GetPeekCharCore(Boolean& correctChar);
    protected string get_CharsFromPeekTokens();
    protected void set_CharsFromPeekTokens(string value);
    protected int get_CharIndex();
    protected void set_CharIndex(int value);
    protected char get_PrevChar();
    protected void set_PrevChar(char value);
    protected Token get_Tokens();
    protected void set_Tokens(Token value);
    protected char get_Ch();
    protected void set_Ch(char value);
    public void SetScanner(VBScannerBase scanner);
    public char get_CurrentChar();
    public void set_CurrentChar(char value);
}
public enum DevExpress.CodeParser.VB.BlockType : Enum {
    public int value__;
    public static BlockType None;
    public static BlockType IfSingleLineStatement;
}
public enum DevExpress.CodeParser.VB.ContinueKind : Enum {
    public byte value__;
    public static ContinueKind Unknown;
    public static ContinueKind Do;
    public static ContinueKind For;
    public static ContinueKind While;
}
public class DevExpress.CodeParser.VB.CorruptedLanguageElement : LanguageElement {
    private CorruptedType _CorruptedType;
    private SourceRange _EndBlockRange;
    public SourceRange EndBlockRange { get; public set; }
    public LanguageElementType ElementType { get; }
    public CorruptedType CorruptedType { get; public set; }
    public bool IsCorrupted { get; }
    protected virtual void UpdateRanges();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public SourceRange get_EndBlockRange();
    public void set_EndBlockRange(SourceRange value);
    public virtual LanguageElementType get_ElementType();
    public CorruptedType get_CorruptedType();
    public void set_CorruptedType(CorruptedType value);
    public sealed virtual bool get_IsCorrupted();
}
public enum DevExpress.CodeParser.VB.CorruptedType : Enum {
    public int value__;
    public static CorruptedType Class;
    public static CorruptedType Struct;
    public static CorruptedType Module;
    public static CorruptedType Interface;
    public static CorruptedType Event;
    public static CorruptedType Namespace;
    public static CorruptedType AddHandler;
    public static CorruptedType RemoveHandler;
    public static CorruptedType RaiseEvent;
    public static CorruptedType Get;
    public static CorruptedType Set;
    public static CorruptedType Enum;
    public static CorruptedType Property;
    public static CorruptedType Sub;
    public static CorruptedType Function;
    public static CorruptedType Operator;
    public static CorruptedType Block;
}
public enum DevExpress.CodeParser.VB.CreateElementType : Enum {
    public int value__;
    public static CreateElementType ElementReferenceExpression;
    public static CreateElementType TypeReferenceExpression;
    public static CreateElementType ArrayCreationExpression;
    public static CreateElementType ObjectCreationExpression;
    public static CreateElementType DelegateCreationExpression;
    public static CreateElementType None;
}
public class DevExpress.CodeParser.VB.DeclarationsCache : object {
    private ArrayList _Scopes;
    private Hashtable _VisibleDeclarations;
    private Hashtable ActiveScope { get; }
    private Hashtable get_ActiveScope();
    public DeclarationsCache GetClone();
    public void AddDeclaration(LanguageElement element);
    public void OpenScope();
    public void CloseScope();
    public LanguageElement GetDeclaration(string name);
    public bool HasDeclaration(string name);
    public void Reset();
    public void Remove(LanguageElement element);
}
public enum DevExpress.CodeParser.VB.DeclaratorType : Enum {
    public int value__;
    public static DeclaratorType Const;
    public static DeclaratorType Dim;
    public static DeclaratorType Static;
    public static DeclaratorType QueryIdent;
    public static DeclaratorType CanAggregateFunction;
    public static DeclaratorType CanAggregateElement;
    public static DeclaratorType None;
}
public class DevExpress.CodeParser.VB.Error : FlowBreak {
    private Expression _Expression;
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; }
    public Error(Expression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
}
public class DevExpress.CodeParser.VB.ExitStatement : Exit {
    public ExitStatement(string exitKind, SourceRange range);
    public virtual ExitKind ResolveExitKind(string exitKind);
    public virtual bool MatchesExitKind(LanguageElement target);
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public interface DevExpress.CodeParser.VB.ICorruptedElement {
    public bool IsCorrupted { get; }
    public abstract virtual bool get_IsCorrupted();
}
public class DevExpress.CodeParser.VB.LocalVarArrayCollection : object {
    private StringCollection _VarNames;
    public void AddVarArrayName(BaseVariable var);
    public bool IsVarArrayName(string name);
    public void Clear();
}
public class DevExpress.CodeParser.VB.MemberModifier : object {
    private Token _MustInherit;
    private Token _Default;
    private Token _Friend;
    private Token _Shadows;
    private Token _Overrides;
    private Token _Private;
    private Token _Protected;
    private Token _Public;
    private Token _NotInheritable;
    private Token _NotOverridable;
    private Token _Shared;
    private Token _Overridable;
    private Token _Overloads;
    private Token _Readonly;
    private Token _Writeonly;
    public Token MustInherit { get; public set; }
    public Token Default { get; public set; }
    public Token Friend { get; public set; }
    public Token Shadows { get; public set; }
    public Token Overrides { get; public set; }
    public Token Private { get; public set; }
    public Token Protected { get; public set; }
    public Token Public { get; public set; }
    public Token NotInheritable { get; public set; }
    public Token NotOverridable { get; public set; }
    public Token Shared { get; public set; }
    public Token Overridable { get; public set; }
    public Token Overloads { get; public set; }
    public Token Readonly { get; public set; }
    public Token Writeonly { get; public set; }
    public Token get_MustInherit();
    public void set_MustInherit(Token value);
    public Token get_Default();
    public void set_Default(Token value);
    public Token get_Friend();
    public void set_Friend(Token value);
    public Token get_Shadows();
    public void set_Shadows(Token value);
    public Token get_Overrides();
    public void set_Overrides(Token value);
    public Token get_Private();
    public void set_Private(Token value);
    public Token get_Protected();
    public void set_Protected(Token value);
    public Token get_Public();
    public void set_Public(Token value);
    public Token get_NotInheritable();
    public void set_NotInheritable(Token value);
    public Token get_NotOverridable();
    public void set_NotOverridable(Token value);
    public Token get_Shared();
    public void set_Shared(Token value);
    public Token get_Overridable();
    public void set_Overridable(Token value);
    public Token get_Overloads();
    public void set_Overloads(Token value);
    public Token get_Readonly();
    public void set_Readonly(Token value);
    public Token get_Writeonly();
    public void set_Writeonly(Token value);
}
public class DevExpress.CodeParser.VB.MethodHelper : object {
    public bool IsMustInherit;
    private TokenQueueBase _Modifiers;
    public MethodHelper(TokenQueueBase modifiers);
    public bool WithoutBody();
}
public class DevExpress.CodeParser.VB.OnDemandParsingParameters : object {
    private Token _StartBlockToken;
    private Token _EndBlockToken;
    public Token StartBlockToken { get; }
    public Token EndBlockToken { get; }
    public OnDemandParsingParameters(Token startBlockToken, Token endBlockToken);
    public Token get_StartBlockToken();
    public Token get_EndBlockToken();
}
public abstract class DevExpress.CodeParser.VB.Preprocessor.Evaluator : object {
    private static object ProcessOperation(int type, string lExp, string rExp);
    private static object ProcessOperation(int type, Number lExp, Number rExp);
    private static object PrepareExp(object exp);
    public static object Eval(object lExp, object rExp, int operatorType);
    private static object ProcessOperation(int opType, ResultType ppType, object lExp, object rExp);
    public static PpResult GetResult(object exp);
    private static PpResult GetPpResult(bool cond);
    private static ResultType GetConversationType(object lExp, object rExp);
    private static ResultType GetConversationType(ResultType lType, ResultType rType);
    private static ResultType GetType(object exp);
    private static Number GetNumber(object val);
    public static IntNum GetZeroInt();
    private static object OrElse(Number lExp, Number rExp);
    private static object AndAlso(Number lExp, Number rExp);
    private static object NotEquals(Number lExp, Number rExp);
    private static object Equals(Number lExp, Number rExp);
    private static object ProcessBinaryOperation(int type, Number lExp, Number rExp);
    private static object Not(Number lExp);
    private static object ProcessUnaryOperation(int type, Number lExp);
    private static string GetString(object val);
    private static object ProcessBinaryOperation(int type, string lExp, string rExp);
    private static bool GetConditionFromNumber(Number num);
    public static Number GetNumberFromCondition(bool cond);
}
public enum DevExpress.CodeParser.VB.Preprocessor.PpResult : Enum {
    public int value__;
    public static PpResult True;
    public static PpResult False;
    public static PpResult Invalid;
}
public class DevExpress.CodeParser.VB.Preprocessor.PreprocessorErrors : ParserErrorsBase {
    protected virtual string GetSyntaxErrorText(int n);
}
public class DevExpress.CodeParser.VB.Preprocessor.Tokens : object {
    public static int Preserve;
    public static int SByte;
    public static int Descending;
    public static int Each;
    public static int AndAlso;
    public static int EndRegion;
    public static int CUShort;
    public static int Xor;
    public static int By;
    public static int Like;
    public static int MyBase;
    public static int CLng;
    public static int SingleLineCloseTag;
    public static int Call;
    public static int Case;
    public static int String;
    public static int Interface;
    public static int From;
    public static int Until;
    public static int Auto;
    public static int ByRef;
    public static int Property;
    public static int ParenClose;
    public static int Strict;
    public static int GoSub;
    public static int NotOverridable;
    public static int New;
    public static int StringLiteral;
    public static int Region;
    public static int LessThan;
    public static int ExternalSourceDirective;
    public static int CBool;
    public static int ShiftLeft;
    public static int XmlCommentString;
    public static int Select;
    public static int EqualsSymbol;
    public static int Let;
    public static int CloseTag;
    public static int Static;
    public static int Overloads;
    public static int Imports;
    public static int Module;
    public static int EndIf;
    public static int CStr;
    public static int CChar;
    public static int Explicit;
    public static int In;
    public static int Long;
    public static int CurlyBraceClose;
    public static int PlusEqual;
    public static int CloseEmbeddedCodeTag;
    public static int Comma;
    public static int Handles;
    public static int Not;
    public static int GreaterOrEqual;
    public static int CByte;
    public static int Single;
    public static int Aggregate;
    public static int Structure;
    public static int CShort;
    public static int Delegate;
    public static int Erase;
    public static int Ascending;
    public static int Then;
    public static int Binary;
    public static int When;
    public static int Overridable;
    public static int Out;
    public static int Do;
    public static int Shadows;
    public static int Friend;
    public static int ULong;
    public static int LineTerminator;
    public static int MulEqual;
    public static int Wend;
    public static int While;
    public static int Off;
    public static int AddToken;
    public static int Using;
    public static int CDbl;
    public static int DivEqual;
    public static int SyncLock;
    public static int RemoveHandler;
    public static int BackSlashEquals;
    public static int Partial;
    public static int CInt;
    public static int MinusEqual;
    public static int ColonEquals;
    public static int Const;
    public static int Minus;
    public static int Ansi;
    public static int True;
    public static int Char;
    public static int IsTrue;
    public static int ElseIfDirective;
    public static int EqualsToken;
    public static int GetTypeToken;
    public static int Loop;
    public static int Group;
    public static int IfToken;
    public static int CommAtSymbol;
    public static int Custom;
    public static int IntegerLiteral;
    public static int Event;
    public static int FloatingPointLiteral;
    public static int CType;
    public static int LineContinuation;
    public static int Order;
    public static int ShiftRightEqual;
    public static int XorEqual;
    public static int GreaterThan;
    public static int Private;
    public static int Byte;
    public static int Identifier;
    public static int ReadOnly;
    public static int NotEquals;
    public static int Return;
    public static int CULng;
    public static int TripleDot;
    public static int Inherits;
    public static int MyClass;
    public static int Declare;
    public static int Unicode;
    public static int Get;
    public static int ShiftRight;
    public static int Short;
    public static int Or;
    public static int ParenOpen;
    public static int Widening;
    public static int CSng;
    public static int Shared;
    public static int Assembly;
    public static int MustOverride;
    public static int Implements;
    public static int BackSlash;
    public static int SingleLineComment;
    public static int Integer;
    public static int AddHandler;
    public static int Function;
    public static int Slash;
    public static int Is;
    public static int Rem;
    public static int CUInt;
    public static int Namespace;
    public static int Continue;
    public static int Me;
    public static int Global;
    public static int SingleLineXmlComment;
    public static int As;
    public static int Resume;
    public static int Sub;
    public static int WithEvents;
    public static int EndToken;
    public static int ReDim;
    public static int Finally;
    public static int Where;
    public static int Nothing;
    public static int Alias;
    public static int Catch;
    public static int Enum;
    public static int For;
    public static int Of;
    public static int Protected;
    public static int CSByte;
    public static int And;
    public static int Colon;
    public static int OpenEmbeddedCodeTag;
    public static int Operator;
    public static int Try;
    public static int OrElse;
    public static int Error;
    public static int Optional;
    public static int IsNot;
    public static int Mod;
    public static int Dim;
    public static int LessOrEqual;
    public static int ConstDirective;
    public static int Take;
    public static int False;
    public static int Boolean;
    public static int On;
    public static int NotInheritable;
    public static int CDec;
    public static int Sharp;
    public static int Overrides;
    public static int Into;
    public static int UShort;
    public static int Narrowing;
    public static int BitAnd;
    public static int ByVal;
    public static int IsFalse;
    public static int EndifDirective;
    public static int PercentSymbol;
    public static int AndEqual;
    public static int Set;
    public static int Else;
    public static int Option;
    public static int GoTo;
    public static int Object;
    public static int With;
    public static int Variant;
    public static int MustInherit;
    public static int Class;
    public static int Default;
    public static int Join;
    public static int Date;
    public static int ElseIf;
    public static int RaiseEvent;
    public static int Plus;
    public static int Dot;
    public static int CurlyBraceOpen;
    public static int Lib;
    public static int Throw;
    public static int Text;
    public static int ShiftLeftEqual;
    public static int TryCast;
    public static int CharacterLiteral;
    public static int DirectCast;
    public static int Next;
    public static int ExclamationSymbol;
    public static int Distinct;
    public static int Question;
    public static int Double;
    public static int Compare;
    public static int CDate;
    public static int XorSymbol;
    public static int ToToken;
    public static int EOF;
    public static int Exit;
    public static int WriteOnly;
    public static int ParamArray;
    public static int Stop;
    public static int AddressOf;
    public static int Infer;
    public static int RemoveToken;
    public static int IfDirective;
    public static int Asterisk;
    public static int UInteger;
    public static int Step;
    public static int DollarSymbol;
    public static int ElseDirective;
    public static int Decimal;
    public static int Public;
    public static int KeyToken;
    public static int Skip;
    public static int TypeOf;
    public static int EndExternalSourceDirective;
    public static int CObj;
    public static int MaxTokens;
    public static Int32[] Keywords;
    private static Tokens();
}
public class DevExpress.CodeParser.VB.Preprocessor.VBPreprocessor : object {
    private static int minErrDist;
    private Stack _IfConditions;
    private SourceFile _SourceFile;
    private VB90Parser _VbParser;
    private VB90Scanner _Scanner;
    private Dictionary`2<string, object> _Defines;
    private Dictionary`2<string, object> _OnlyThisFileDefines;
    protected static bool T;
    protected static bool x;
    protected int errDist;
    protected Token tToken;
    protected Token la;
    protected ParserErrorsBase errors;
    protected Boolean[0...,0...] set;
    protected int maxTokens;
    private TokenCategorizedParserBase parser;
    public bool ConditionWasTrue { get; }
    protected Stack IfConditions { get; }
    protected VB90Scanner Scanner { get; protected set; }
    public VB90Parser VbParser { get; public set; }
    public SourceFile SourceFile { get; public set; }
    internal VBPreprocessor(VB90Scanner scanner, TokenCategorizedParserBase parser, Dictionary`2<string, object> defines);
    public VBPreprocessor(VB90Scanner scanner, TokenCategorizedParserBase parser, SourceFile rootNode);
    private bool IsEOF();
    private void IfWaitEndIf();
    protected void SkipToEolIfNeeded();
    protected void SkipToEOL();
    private void ResetNextChCounter();
    private bool IsNextChar(char ch);
    private bool GetBool(object expValue);
    private bool GetBool(PpResult result);
    protected void ProcessIFDirectiveCondition(bool condition);
    protected void ProcessDirectiveCondition(bool condition);
    private void ProcessDirectiveConditionCore(object expVal);
    public bool get_ConditionWasTrue();
    protected void ProcessEndIf();
    protected Stack get_IfConditions();
    public void CleanUp();
    protected VB90Scanner get_Scanner();
    protected void set_Scanner(VB90Scanner value);
    protected void Get();
    private void CreateDefinesCollections();
    private void InitStandartPrep();
    private void AddProjectDefines(SourceFile sourceFile);
    private void AddProjectDefines(Dictionary`2<string, object> projectDefines);
    protected void AddConst(string name, object value);
    private object GetConstValue(string name);
    public void InitPreprocessor(VB90Scanner scanner, SourceFile rootNode);
    private void InitDefines(SourceFile sourceFile);
    [EditorBrowsableAttribute("1")]
public static PpResult EvaluateExpression(string str);
    public static object GetExpressionValue(string str, Dictionary`2<string, object> prevProjectDefines);
    private object EvaluateExpressionCore();
    private PpResult EvaluateExpression();
    public void set_VbParser(VB90Parser value);
    public VB90Parser get_VbParser();
    public SourceFile get_SourceFile();
    public void set_SourceFile(SourceFile value);
    protected void AddRegion(RegionDirective regionDirective);
    protected void AddDirectiveNode(PreprocessorDirective directive);
    protected void Expect(int n);
    protected void SynErr(int n);
    public Token Preprocess(Token laToken);
    protected IntNum GetZeroInt();
    protected bool StartOf(int s);
    protected Number GetDoubleValue(string val);
    protected Number GetIntegerValue(string val);
    protected string GetStringValue(string val);
    protected string GetStringValueFromChar(string val);
    protected string GetStringValueCore(string val, int oddSymbols);
    private void AddDefineCall(string name);
    public object Eval(object lExp, object rExp, int operatorType);
    protected void HandlePragmas();
    private void PreprocessorRoot();
    private void WhitespaceLines();
    private void RegionGroup();
    private void ConditionGroup();
    private void ConstRule();
    private void ExternalRule();
    private void StatementTerminator();
    private void EternalSourceBegin();
    private void StringLiteralRule();
    private void Expression(Object& result);
    private void ExpressionValue(Boolean& result);
    private void StartRegionRule();
    private void EndRegionRule();
    private void IdentifierOrKeywordOrOperator();
    private void SimpleName(Object& result);
    private void LogicalXorOp(Object& result);
    private void LogicalOrOp(Object& result);
    private void LogicalAndOp(Object& result);
    private void LogicalNotOp(Object& result);
    private void RelationalOp(Object& result);
    private void ShiftOp(Object& result);
    private void ConcatenationOp(Object& result);
    private void AdditiveOp(Object& result);
    private void ModulusOp(Object& result);
    private void IntegerDivisionOp(Object& result);
    private void MultiplicativeOp(Object& result);
    private void UnaryExpression(Object& result);
    private void ExponentiationOp(Object& result);
    private void PrimaryExpression(Object& result);
    private void ParenthesizedExpressionRule(Object& result);
    private void Literal(Object& result);
    private void BooleanLiteral(Object& val);
    protected void StartRule();
    protected void WhitespaceLinesBase();
    protected Boolean[0...,0...] CreateSetArray();
}
public class DevExpress.CodeParser.VB.QualifiedIdentifier : object {
    private string _Identifier;
    private SourceRange _Range;
    private Expression _Expression;
    public string Identifier { get; public set; }
    public SourceRange Range { get; public set; }
    public Expression Expression { get; public set; }
    public QualifiedIdentifier(string identifier, SourceRange range);
    public string get_Identifier();
    public void set_Identifier(string value);
    public SourceRange get_Range();
    public void set_Range(SourceRange value);
    public Expression get_Expression();
    public void set_Expression(Expression value);
}
public class DevExpress.CodeParser.VB.SubMemberData : object {
    public Token NameToken;
    public LanguageElementCollection ParamCollection;
    public TypeReferenceExpression MemberTypeReference;
    public SourceRange TypeRange;
    public GenericModifier GenericModifier;
    public SourceRange NameRange;
    private ExpressionCollection _HandlesExpressions;
    private ExpressionCollection _ImplementCollection;
    private Expression _Initializer;
    private string _LibString;
    private string _AliasString;
    private SourceRange _ParamOpenRange;
    private SourceRange _ParamCloseRange;
    private SourceRange _AsRange;
    public Expression Initializer { get; public set; }
    public SourceRange AsRange { get; public set; }
    public SourceRange ParamOpenRange { get; public set; }
    public SourceRange ParamCloseRange { get; public set; }
    public string Name { get; }
    public string LibString { get; public set; }
    public string AliasString { get; public set; }
    public ExpressionCollection ImplementsCollection { get; }
    public ExpressionCollection HandlesExpressions { get; public set; }
    public Expression get_Initializer();
    public void set_Initializer(Expression value);
    public SourceRange get_AsRange();
    public void set_AsRange(SourceRange value);
    public void set_ParamOpenRange(SourceRange value);
    public SourceRange get_ParamOpenRange();
    public void set_ParamCloseRange(SourceRange value);
    public SourceRange get_ParamCloseRange();
    public string get_Name();
    public string get_LibString();
    public void set_LibString(string value);
    public string get_AliasString();
    public void set_AliasString(string value);
    public void AddImplement(ElementReferenceExpression element);
    public ExpressionCollection get_ImplementsCollection();
    public ExpressionCollection get_HandlesExpressions();
    public void set_HandlesExpressions(ExpressionCollection value);
}
public class DevExpress.CodeParser.VB.Tokens : object {
    public static int Preserve;
    public static int SByte;
    public static int Descending;
    public static int Each;
    public static int AndAlso;
    public static int EndRegion;
    public static int CUShort;
    public static int Xor;
    public static int By;
    public static int Like;
    public static int MyBase;
    public static int CLng;
    public static int SingleLineCloseTag;
    public static int Call;
    public static int Case;
    public static int String;
    public static int Interface;
    public static int From;
    public static int Until;
    public static int Auto;
    public static int ByRef;
    public static int Property;
    public static int ParenClose;
    public static int Strict;
    public static int GoSub;
    public static int NotOverridable;
    public static int New;
    public static int StringLiteral;
    public static int Region;
    public static int LessThan;
    public static int ExternalSourceDirective;
    public static int CBool;
    public static int ShiftLeft;
    public static int XmlCommentString;
    public static int Select;
    public static int EqualsSymbol;
    public static int Let;
    public static int CloseTag;
    public static int Static;
    public static int Overloads;
    public static int Imports;
    public static int Module;
    public static int EndIf;
    public static int CStr;
    public static int CChar;
    public static int Explicit;
    public static int In;
    public static int Long;
    public static int CurlyBraceClose;
    public static int PlusEqual;
    public static int CloseEmbeddedCodeTag;
    public static int Comma;
    public static int Handles;
    public static int Not;
    public static int GreaterOrEqual;
    public static int CByte;
    public static int Single;
    public static int Aggregate;
    public static int Structure;
    public static int CShort;
    public static int Delegate;
    public static int Erase;
    public static int Ascending;
    public static int Then;
    public static int Binary;
    public static int When;
    public static int Overridable;
    public static int Out;
    public static int Do;
    public static int Shadows;
    public static int Friend;
    public static int ULong;
    public static int LineTerminator;
    public static int MulEqual;
    public static int Wend;
    public static int While;
    public static int Off;
    public static int AddToken;
    public static int Using;
    public static int CDbl;
    public static int DivEqual;
    public static int SyncLock;
    public static int RemoveHandler;
    public static int BackSlashEquals;
    public static int Partial;
    public static int CInt;
    public static int MinusEqual;
    public static int ColonEquals;
    public static int Const;
    public static int Minus;
    public static int Ansi;
    public static int True;
    public static int Char;
    public static int IsTrue;
    public static int ElseIfDirective;
    public static int EqualsToken;
    public static int GetTypeToken;
    public static int Loop;
    public static int Group;
    public static int IfToken;
    public static int CommAtSymbol;
    public static int Custom;
    public static int IntegerLiteral;
    public static int Event;
    public static int FloatingPointLiteral;
    public static int CType;
    public static int LineContinuation;
    public static int Order;
    public static int ShiftRightEqual;
    public static int XorEqual;
    public static int GreaterThan;
    public static int Private;
    public static int Byte;
    public static int Identifier;
    public static int ReadOnly;
    public static int NotEquals;
    public static int Return;
    public static int CULng;
    public static int TripleDot;
    public static int Inherits;
    public static int MyClass;
    public static int Declare;
    public static int Unicode;
    public static int Get;
    public static int ShiftRight;
    public static int Short;
    public static int Or;
    public static int ParenOpen;
    public static int Widening;
    public static int CSng;
    public static int Shared;
    public static int Assembly;
    public static int MustOverride;
    public static int Implements;
    public static int BackSlash;
    public static int SingleLineComment;
    public static int Integer;
    public static int AddHandler;
    public static int Function;
    public static int Slash;
    public static int Is;
    public static int Rem;
    public static int CUInt;
    public static int Namespace;
    public static int Continue;
    public static int Me;
    public static int Global;
    public static int SingleLineXmlComment;
    public static int As;
    public static int Resume;
    public static int Sub;
    public static int WithEvents;
    public static int EndToken;
    public static int ReDim;
    public static int Finally;
    public static int Where;
    public static int Nothing;
    public static int Alias;
    public static int Catch;
    public static int Enum;
    public static int For;
    public static int Of;
    public static int Protected;
    public static int CSByte;
    public static int And;
    public static int Colon;
    public static int OpenEmbeddedCodeTag;
    public static int Operator;
    public static int Try;
    public static int OrElse;
    public static int Error;
    public static int Optional;
    public static int IsNot;
    public static int Mod;
    public static int Dim;
    public static int LessOrEqual;
    public static int ConstDirective;
    public static int Take;
    public static int False;
    public static int Boolean;
    public static int On;
    public static int NotInheritable;
    public static int CDec;
    public static int Sharp;
    public static int Overrides;
    public static int Into;
    public static int UShort;
    public static int Narrowing;
    public static int BitAnd;
    public static int ByVal;
    public static int IsFalse;
    public static int EndifDirective;
    public static int PercentSymbol;
    public static int AndEqual;
    public static int Set;
    public static int Else;
    public static int Option;
    public static int GoTo;
    public static int Object;
    public static int With;
    public static int Variant;
    public static int MustInherit;
    public static int Class;
    public static int Default;
    public static int Join;
    public static int Date;
    public static int ElseIf;
    public static int RaiseEvent;
    public static int Plus;
    public static int Dot;
    public static int CurlyBraceOpen;
    public static int Lib;
    public static int Throw;
    public static int Text;
    public static int ShiftLeftEqual;
    public static int TryCast;
    public static int CharacterLiteral;
    public static int DirectCast;
    public static int Next;
    public static int ExclamationSymbol;
    public static int Distinct;
    public static int Question;
    public static int Double;
    public static int Compare;
    public static int CDate;
    public static int XorSymbol;
    public static int ToToken;
    public static int EOF;
    public static int Exit;
    public static int WriteOnly;
    public static int ParamArray;
    public static int Stop;
    public static int AddressOf;
    public static int Infer;
    public static int RemoveToken;
    public static int IfDirective;
    public static int Asterisk;
    public static int UInteger;
    public static int Step;
    public static int DollarSymbol;
    public static int ElseDirective;
    public static int Decimal;
    public static int Public;
    public static int KeyToken;
    public static int Skip;
    public static int TypeOf;
    public static int EndExternalSourceDirective;
    public static int CObj;
    public static int MaxTokens;
    public static Int32[] Keywords;
    private static Tokens();
}
public class DevExpress.CodeParser.VB.TokenType : TokenType {
    private static int BaseIndex;
    public static int Imports;
    public static int Boolean;
    public static int Integer;
    public static int Structure;
    public static int UInteger;
    public static int ULongToken;
    public static int UShortToken;
    public static int AddHandler;
    public static int AddressOf;
    public static int Alias;
    public static int And;
    public static int AndAlso;
    public static int Ansi;
    public static int Assembly;
    public static int Auto;
    public static int ByRef;
    public static int ByVal;
    public static int Call;
    public static int Ctype;
    public static int Date;
    public static int Declare;
    public static int Dim;
    public static int DirectCast;
    public static int Each;
    public static int ElseIf;
    public static int End;
    public static int EndIf;
    public static int Erase;
    public static int Error;
    public static int Exit;
    public static int Friend;
    public static int Function;
    public static int GettypeToken;
    public static int GoSub;
    public static int Handles;
    public static int Implements;
    public static int Inherits;
    public static int Let;
    public static int Lib;
    public static int Like;
    public static int Loop;
    public static int Me;
    public static int Mod;
    public static int MustInherit;
    public static int MustOverride;
    public static int MyBase;
    public static int MyClass;
    public static int Next;
    public static int Not;
    public static int Nothing;
    public static int NotInheritable;
    public static int NotOverridable;
    public static int On;
    public static int Option;
    public static int Optional;
    public static int Or;
    public static int OrElse;
    public static int Overloads;
    public static int Overridable;
    public static int Overrides;
    public static int ParamArray;
    public static int Preserve;
    public static int Property;
    public static int RaiseEvent;
    public static int ReDim;
    public static int RemoveHandler;
    public static int Resume;
    public static int Select;
    public static int Shadows;
    public static int Shared;
    public static int Single;
    public static int Step;
    public static int Stop;
    public static int Sub;
    public static int SyncLock;
    public static int Then;
    public static int To;
    public static int Unicode;
    public static int Until;
    public static int Variant;
    public static int Wend;
    public static int When;
    public static int With;
    public static int WithEvents;
    public static int WriteOnly;
    public static int Xor;
    public static int Sharp;
    public static int LineContinuation;
    public static int BackSlash;
    public static int BackSlashEquals;
    public static int ConstDirective;
    public static int ElseIfDirective;
    public static int ExternalSourceDirective;
    public static int EndExternalSourceDirective;
    public static int DateLiteral;
    public static int IsNot;
    public static int ExternalCheckSum;
    public static int Using;
    public static int Global;
    public static int Of;
    public static int Mid;
    public static int Off;
    public static int Strict;
    public static int Compare;
    public static int Binary;
    public static int Text;
    public static int ProtectedFriend;
    public static int Custom;
    public static int IsTrue;
    public static int IsFalse;
    public static int Widening;
    public static int Narrowing;
    public static int TryCast;
    public static int CSByte;
    public static int CUInt;
    public static int CULng;
    public static int CUShort;
    public static int ColonEqual;
    public static int OpenParenOf;
    public static int LineterminatorElse;
    public static int GetTokenType(string name);
    public static string GetTokenName(int token);
}
public enum DevExpress.CodeParser.VB.TypeDeclarationEnum : Enum {
    public int value__;
    public static TypeDeclarationEnum Class;
    public static TypeDeclarationEnum Struct;
    public static TypeDeclarationEnum Interface;
    public static TypeDeclarationEnum Module;
}
public class DevExpress.CodeParser.VB.VariableListHelper : object {
    private TypeReferenceExpression _Type;
    private Expression _Initializer;
    private SourceRange _OperatorRange;
    private SourceRange _AsRange;
    private bool _IsObjectCreation;
    private bool _AddToContext;
    public bool AddToContext { get; public set; }
    public SourceRange AsRange { get; public set; }
    public Expression Initializer { get; public set; }
    public bool IsObjectCreation { get; public set; }
    public SourceRange OperatorRange { get; public set; }
    public TypeReferenceExpression Type { get; public set; }
    public VariableListHelper(bool addToContext);
    public bool get_AddToContext();
    public void set_AddToContext(bool value);
    public SourceRange get_AsRange();
    public void set_AsRange(SourceRange value);
    public Expression get_Initializer();
    public void set_Initializer(Expression value);
    public bool get_IsObjectCreation();
    public void set_IsObjectCreation(bool value);
    public SourceRange get_OperatorRange();
    public void set_OperatorRange(SourceRange value);
    public TypeReferenceExpression get_Type();
    public void set_Type(TypeReferenceExpression value);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.CodeParser.VB.VariableNameCollection : CollectionBase {
    public int Count { get; }
    public string Item { get; }
    public void Add(string name, VBDeclarator decl, SourceRange range, SourceRange nameRange);
    public int get_Count();
    public VBDeclarator GetDeclarator(int index);
    public SourceRange GetRange(int index);
    public SourceRange GetNameRange(int index);
    public string get_Item(int index);
}
public class DevExpress.CodeParser.VB.VB10KeyWords : object {
    private static StringCollection _KeyWords;
    public static StringCollection Collection { get; }
    private static VB10KeyWords();
    private static void CreateKeywords();
    public static StringCollection get_Collection();
}
public class DevExpress.CodeParser.VB.VB10Parser : VB90Parser {
    private Boolean[] _ImplicitLineContinuationAfterTokenTable;
    private Boolean[] _ImplicitLineContinuationBeforeTokenTable;
    protected virtual void SetUpLineContinuationCheckState();
    private void FillImplicitLineContinuationAfterTokenTable();
    private void FillImplicitLineContinuationBeforeTokenTable();
    private bool IsImplicitLineContinuationAfterToken(Token token);
    private bool IsImplicitLineContinuationBeforeToken(Token token);
    protected virtual void Get();
}
public class DevExpress.CodeParser.VB.VB10Tokens : VBTokensBase {
    private static VB10Tokens _Instance;
    public static VB10Tokens Instance { get; }
    protected virtual StringCollection CreateKeywords();
    public static VB10Tokens get_Instance();
}
public class DevExpress.CodeParser.VB.VB71ExpressionInverter : ExpressionInverterBase {
    protected virtual Expression InvertIsExpression(Is expression);
}
public class DevExpress.CodeParser.VB.VB71ExpressionParser : VBExpressionParserBase {
    public VBTokensBase VBTokens { get; }
    public VB71ExpressionParser(ParserBase parser);
    public virtual VBTokensBase get_VBTokens();
}
public class DevExpress.CodeParser.VB.VB71KeyWords : object {
    private static StringCollection _KeyWords;
    public static StringCollection Collection { get; }
    private static VB71KeyWords();
    private static void CreateKeywords();
    public static StringCollection get_Collection();
}
public class DevExpress.CodeParser.VB.VB71Parser : VBParserBase {
    public virtual ExpressionParserBase CreateExpressionParser();
    public virtual IExpressionInverter CreateExpressionInverter();
    public virtual string GetFullTypeName(string simpleName);
    public static string GetFullTypeNameString(string fullName);
    public static string GetSimpleTypeName(string fullName);
}
public class DevExpress.CodeParser.VB.VB71Tokens : VBTokensBase {
    private static VB71Tokens _Instance;
    public static VB71Tokens Instance { get; }
    protected virtual StringCollection CreateKeywords();
    public static VB71Tokens get_Instance();
}
public class DevExpress.CodeParser.VB.VB80KeyWords : object {
    private static StringCollection _KeyWords;
    public static StringCollection Collection { get; }
    private static VB80KeyWords();
    private static void CreateKeywords();
    public static StringCollection get_Collection();
}
public class DevExpress.CodeParser.VB.VB80Tokens : VBTokensBase {
    private static VB80Tokens _Instance;
    public static VB80Tokens Instance { get; }
    protected virtual StringCollection CreateKeywords();
    public static VB80Tokens get_Instance();
}
public class DevExpress.CodeParser.VB.VB90CodeGen : VBCodeGen {
    public VB90CodeGen(CodeGenOptions options);
    protected virtual ExpressionCodeGenBase CreateExpressionGen();
}
public class DevExpress.CodeParser.VB.VB90ExpressionCodeGen : VBExpressionCodeGen {
    public VB90ExpressionCodeGen(CodeGen codeGen);
    protected virtual void GenerateConditionalExpression(ConditionalExpression expression);
}
public class DevExpress.CodeParser.VB.VB90ExpressionInverter : ExpressionInverterBase {
    protected virtual Expression InvertIsExpression(Is expression);
    protected virtual Expression InvertIsNotExpression(IsNot expression);
}
public class DevExpress.CodeParser.VB.VB90ExpressionParser : ExpressionParserBase {
    public VB90ExpressionParser(ParserBase parser);
    public virtual Expression Parse(ISourceReader reader);
    public virtual TypeReferenceExpression ParseTypeReferenceExpression(string expression);
    public virtual TypeReferenceExpression ParseTypeReferenceExpression(ISourceReader reader);
}
public class DevExpress.CodeParser.VB.VB90KeyWords : object {
    private static StringCollection _KeyWords;
    public static StringCollection Collection { get; }
    private static VB90KeyWords();
    private static void CreateKeywords();
    public static StringCollection get_Collection();
}
public class DevExpress.CodeParser.VB.VB90Parser : FormattingParserBase {
    private LanguageElementCollection _MissedAttributes;
    private TokenQueueBase _MissedModifiers;
    private bool _IsNewContext;
    private static object _SyncObject;
    private bool _PreviousTokenWasComment;
    private CommentCollection _Comments;
    private VBPreprocessor _Preprocessor;
    private LocalVarArrayCollection _LocalVarArrayCollection;
    private ParserVersion _VsVersion;
    private DeclarationsCache _DeclarationsCache;
    private int _ExpressionNestingLevel;
    private bool _NotXmlNode;
    private bool _CheckImplicitLineContinuationAfterToken;
    private String[] _AggregateMethodNames;
    private ParserBase _HtmlParser;
    private static Boolean[0...,0...] _VbSet;
    private bool _SavedLineContinuationCheckState;
    private bool _LineContinuationCheckState;
    protected bool IsAsynchronousContext;
    private Int32[] _EndTokens;
    private Int32[] _StartDeclTokens;
    private Int32[] _EndDeclTokens;
    private int _FirstTokenStartPosition;
    private bool _ParseOnlyExpression;
    private bool _ParsingRazor;
    protected bool IsRazorEndCode;
    protected bool CheckImplicitLineContinuations { get; }
    protected bool CheckImplicitLineContinuationAfterToken { get; protected set; }
    protected bool OnDemand { get; }
    public string Language { get; }
    public CommentCollection Comments { get; }
    public VB90ParserErrors Errors { get; }
    public bool ParseOnlyExpression { get; public set; }
    protected LocalVarArrayCollection LocalVarArrayCollection { get; }
    [EditorBrowsableAttribute("1")]
public ParserVersion VsVersion { get; public set; }
    protected bool ParsingRazor { get; }
    protected FormattingTable FormattingTable { get; }
    private static VB90Parser();
    private void SetMissedAttributesAndModifiersIfNeeded(LanguageElementCollection missedAttributes, TokenQueueBase missedModifiers);
    private bool LaIsStartPropertyAccessor();
    private bool GetMissedAttributesAndModifiers(LanguageElementCollection& missedAttributes, TokenQueueBase& missedModifiers);
    private void ResetMissedAttributesAndModifiers();
    protected void ParseRootRule();
    protected string GetAccessorName(string prefix);
    protected void CallAppropriateParseRule(LanguageElement context);
    protected virtual LanguageElement DoParse(ParserContext parserContext, ISourceReader reader);
    protected int ConstructedTypeNameTailBase(ExpressionCollection& arguments);
    private void QualifiedIdentifier(QualifiedIdentifier& identifier);
    private void ObjectCreationExpressionCore(Expression& result, VBDeclarator& decl);
    private void ArrayCreationExpressionCore(Expression& result);
    private void DelegateCreationExpressionCore(Expression& result);
    public static string GetSimpleTypeName(string fullName);
    protected void StatementRuleBase(Statement& result);
    protected TypeReferenceExpression ParseTypeExpressionRule(TypeReferenceExpression& result);
    protected void ExpressionRuleBase(Expression& result);
    protected void LocalDeclarationStatementCoreBase(BaseVariable& result);
    protected void ClassMemberDeclarationBase(Member& result);
    protected void WhitespaceLinesBase();
    private void ParseMemberEnd();
    private void ParseMethodEnd();
    private void SetBlockRangeForEmptyContext();
    private bool HasContextElementType(LanguageElementType[] elementTypes);
    private bool IsCorruptedElement();
    private bool IsNamespaceCorruptedEnd();
    private bool IsTypeCorruptedEnd();
    private bool IsMemberCorruptedEnd();
    private void SetCorruptedType(Token token, CorruptedLanguageElement element);
    private bool IsYieldStatement();
    protected virtual void HandlePragmas();
    private void ParserRoot();
    private void ParserRootCore();
    private void EndNamespaceOrType();
    private void WhitespaceLines();
    private void OptionDirective();
    private void ImportsStmt();
    private void FileAttributesSection();
    private void NamespaceDeclaration();
    private void CorruptedEndDeclaration(Boolean& wasCorruptedElement);
    private void StatementTerminatorCall();
    private void StatementTerminator();
    private void OptionValue(OptionState& optionState);
    private void ImportClause(NamespaceReference& result);
    private void VarKeyword();
    private void EqualOperator();
    private void QualifiedIdentifier(QualifiedIdentifier& identifier, CreateElementType createElementType);
    private void AttributeList(AttributeSection section);
    private void AttributeSection(AttributeSection& section);
    private void AttributeSections(LanguageElementCollection& attributes);
    private void Attribute(Attribute& attribute);
    private void AttributeArguments(Attribute attribute);
    private void IdentifierOrKeyword(Token& token);
    private void ExpressionRule(Expression& result);
    private void ElementMemberDeclaration(LanguageElement& element);
    private void CorruptedEndDeclarationCore(LanguageElement& declaration, Boolean& wasCorruptedElement);
    private void TypeDeclarationRule(LanguageElement& declaration);
    private void ElementDeclaration(LanguageElement& declaration);
    private void EnumerationDeclaration(LanguageElement& declaration);
    private void DelegateDeclaration(LanguageElement& result);
    private void GenericModifierRule(GenericModifier& result);
    private void ClassBaseType(TypeDeclaration result);
    private void TypeImplementsClause(TypeDeclaration result);
    private void PrimitiveTypeName(TypeReferenceExpression& result);
    private void EnumBody();
    private void EnumMemberDeclaration();
    private void TypeName(TypeReferenceExpression& result, VBDeclarator& decl);
    private void MethodSignature(SubMemberData& result, VBDeclarator& decl);
    private void SubSignature(SubMemberData& result);
    private void IdentifierOrKeywordOrOperator(Token& token);
    private void TypeCharaterSymbol(TypeReferenceExpression& result);
    private void ParameterList(LanguageElementCollection& coll);
    private void CharsetModifier(String& result);
    private void MethodDeclaration(LanguageElement& result, OnDemandParsingParameters& onDemandParsingParameters, MethodHelper helper);
    private void Block(Token startBlockToken);
    private void NewExpression(Expression& result);
    private void HandlesOrImplement(SubMemberData& result);
    private void MemberImplementsClause(SubMemberData result);
    private void HandlesClause(SubMemberData result);
    private void PrimaryExpression(Expression& result);
    private void AttributesAndModifiers(LanguageElementCollection& attributes, TokenQueueBase& modifiers);
    private void MemberModifiers(TokenQueueBase& modifiers);
    private void DeclareVariableList(LanguageElementCollection& coll, bool isConst, bool addToContext);
    private void PropertyDeclaration(LanguageElement& result, LanguageElementCollection& accessors, OnDemandParsingParameters& onDemandParsingParameters, MethodHelper helper);
    private void CustomEventMemberDeclaration(LanguageElement& result);
    private void PropertyAccessorDeclarationList(LanguageElementCollection accessors, string name, SourceRange& blockEndRange);
    private void PropertyAccessorDeclaration(LanguageElementCollection accessors, string name);
    private void PropertyGetDeclaration(PropertyAccessor& result);
    private void PropertySetDeclaration(PropertyAccessor& result);
    private void EventAccessorDeclarations();
    private void EventAccessorDeclaration(LanguageElement& result);
    private void AddHandlerDeclaration(LanguageElement& result);
    private void RemoveHandlerDeclaration(LanguageElement& result);
    private void RaiseEventDeclaration(LanguageElement& result);
    private void EventDeclarationParameters(EventAccessor accessor);
    private void VarIdentifierCollection(VariableNameCollection& varColl);
    private void VarIdentifier(VBDeclarator& result);
    private void VarIdentifierOrKeyword();
    private void TypeCharacterRule(VBDeclarator& result);
    private void ArrayNameModifier(ArrayNameModifier& result);
    private void NullableTypeRule(TypeReferenceExpression& result, TypeReferenceExpression type);
    private void TypeParensRule(TypeReferenceExpression& result, TypeReferenceExpression type, VBDeclarator decl, SourceRange startRange);
    private void BoundsElement(Expression& result);
    private void BlockCore(Token startBlockToken, BlockType blockType, SourceRange& endBlockRange);
    private void BlockRule(SourceRange startBlockRange, BlockType blockType, bool skipSetBounds, SourceRange& endBlockRange);
    private void StatementRule(Statement& statement);
    private void LabelRule(Statement& result);
    private void RazorMarkup();
    private void EndStatement(Statement& result);
    private void LocalDeclarationStatement();
    private void EmbeddedStatement(Statement& result);
    private void LabelDeclarationStatement(Statement& result);
    private void LabelName();
    private void SyncLockStatement(Statement& result);
    private void LocalDeclarationStatementCore(LanguageElement& result, bool addToContext);
    private void DeclaratorQualifier(DeclaratorType& type);
    private void DeclareVariableWithOneQualifier(LanguageElement& variable, SourceRange startRange, DeclaratorType declaratorType, bool addToContext);
    private void VariableDeclaratorCore(Variable& var, Variable& endVar, DeclaratorType declaratorType, bool addToContext);
    private void ObjectCreationExpression(Expression& result, VBDeclarator& decl);
    private void WhileStatement(Statement& while);
    private void ContinueStatement(Statement& result);
    private void ExitStatement(Statement& result);
    private void WithStatement(Statement& result);
    private void TryBlock(Statement& result);
    private void CatchExceptionDeclaration(Catch result);
    private void DeclareVariableAssignDim(LanguageElement& result);
    private void CatchCondition(Catch result);
    private void CatchBlock(Statement& result);
    private void FinallyBlock(Statement& result);
    private void TryStatement();
    private void DoLoopStatement(Statement& result);
    private void WhileOrUntil(DoConditionType& result);
    private void LoopControlVariable(LanguageElement& result);
    private void AssignmentExpressionRule(Expression& result);
    private void DeclVariableCoreWithoutSpecifier(BaseVariable& result, DeclaratorType declaratorType);
    private void ElementReferenceQualifiedIdentifier(Expression& result);
    private void ExpressionList(LanguageElementList& list);
    private void ForStatement(Statement& result);
    private void IfStatement(Statement& result);
    private void ThrowStatement(Statement& result);
    private void ReturnStatement(Statement& result);
    private void AssignmentStatement(Statement& result);
    private void UsingStatementRule(Statement& result);
    private void YieldStatement(Statement& result);
    private void StopStatement(Statement& result);
    private void SelectStatement(Statement& result);
    private void GoToStatement(Statement& result);
    private void UnstructuredErrorStatement(Statement& result);
    private void ArrayHandlingStatement(Statement& result);
    private void RaiseEventStatement(Statement& result);
    private void AddHandlerStatement(Statement& result);
    private void RedimStatement(Statement& result);
    private void EraseStatement(Statement& result);
    private void ReDimExpressionListRule(ExpressionCollection& result);
    private void ReDimExpressionRule(Expression& reDimExp);
    private void ErrorStatement(Statement& result);
    private void OnErrorStatement(Statement& result);
    private void ResumeStatement(Statement& result);
    private void CaseClauses(LanguageElementCollection& coll);
    private void CaseClause(CaseClause& caseClause);
    private void PrimaryExpressionCore(Expression& result, bool canBeXmlExpression);
    private void AssignmentOperator(AssignmentOperatorType& type, String& operatorText);
    private void OperatorExpression(Expression& result);
    private void CastExpression(Expression& result);
    private void CastTarget(String& castTypeName, String& castKeyword);
    private void PrimitiveExpressionRule(Expression& result);
    private void DateRule(String& name);
    private void TrueOrFalseExpressionRule(Expression& result);
    private void ParenthesizedExpressionRule(Expression& result);
    private void MeOrMyBaseOrMyClassRule(Expression& result);
    private void AdressOfExpressionRule(Expression& result);
    private void TypeOfExpressionRule(Expression& result);
    private void IndexerInPrimaryExpressionRule(Expression& result);
    private void MethodCallExpression(Expression& result);
    private void ConstructedTypeNameTail(ExpressionCollection& result, Int32& typeArity);
    private void ArgumentList(ExpressionCollection& arguments, Int32& rank);
    private void MemberAccessExpressionRule(Expression& result);
    private void XmlAttributeReferenceExpressionRule(Expression& result);
    private void HeadIdentifierInPrimaryExpression(Expression& result);
    private void LogicalNotOpInPrimaryExpression(Expression& result);
    private void RelationalOp(Expression& result);
    private void UnaryExpressionInPrimaryExpression(Expression& result);
    private void ExponentiationOp(Expression& result);
    private void XmlElementReferenceExpressionRule(Expression& result);
    private void ReferenceExpressionRule(Expression& result, SourceRange startRange, bool isCall, SourceRange callRange, Boolean& isBaseConstructorCall);
    private void TryCast(Expression& result);
    private void XmlCommentStringRule(Expression result);
    private void XmlExpressionRule(Expression& result);
    private void LambdaExpression(Expression& result);
    private void AwaitExpression(Expression& result);
    private void ArrayInitializerExpressionRule(Expression& result);
    private void ConditionalExpression(Expression& result);
    private void SqlExpression(Expression& result);
    private void LogicalXorOp(Expression& result);
    private void LogicalOrOp(Expression& result);
    private void LogicalAndOp(Expression& result);
    private void LogicalNotOp(Expression& result);
    private void ShiftOp(Expression& result);
    private void ConcatenationOp(Expression& result);
    private void AdditiveOp(Expression& result);
    private void ModulusOp(Expression& result);
    private void IntegerDivisionOp(Expression& result);
    private void MultiplicativeOp(Expression& result);
    private void UnaryExpression(Expression& result);
    private void CreationExpressionCore(Expression& result, VBDeclarator& decl);
    private void ArrayOrCreationParenthesis(ExpressionCollection& arguments, Int32& rank);
    private void TypeNameCore(TypeReferenceExpression& result, VBDeclarator& declarator);
    private void InitializeParenthesis(Expression& result, TypeReferenceExpression& type, CreateElementType createElementType, SourceRange startRange);
    private void WithInitializersCore(Expression& result);
    private void WithInitializerList(ExpressionCollection& coll);
    private void MemberInitializerExpressionRule(Expression& result);
    private void AdditionObjectCreationInitializer(ObjectCreationExpression result);
    private void InitializerClause(Expression& result);
    private void FromInitializerCore(Expression& result);
    private void Argument(Expression& result);
    private void TypeArgumentList(ExpressionCollection& result, Int32& typeArity);
    private void TypeParameters(TypeParameterCollection& result);
    private void TypeParameterElement(TypeParameter& result);
    private void TypeParameterConstraintRule(TypeParameterConstraintCollection& result);
    private void TypeParameterConstraintList(TypeParameterConstraintCollection& result);
    private void TypeParameterConstraintElement(TypeParameterConstraint& result);
    private void ParameterRule(Param& param);
    private void ParameterQualifierRule(ArgumentDirection& result, SourceRange& directionRange);
    private void ProcedureModifier(Token& modifier);
    private void LambdaSignature(LambdaExpression result);
    private void LambdaParameterList(LambdaExpression result);
    private void LambdaOrSimpleParam(Param& param);
    private void LambdaParameter(Param& param);
    private void FromClause(Expression& result);
    private void QueryOperator(Expression& result);
    private void InExpressionRule(InExpression& result);
    private void QueryIdent(QueryIdent& ident);
    private void QueryIdentBase(QueryIdent& ident, DeclaratorType declaratorType);
    private void DistinctOperator(Expression& result);
    private void SelectOperator(Expression& vbSelect);
    private void WhereOperator(Expression& whereExpression);
    private void OrderByOperator(Expression& orderBy);
    private void SkipOperator(Expression& result);
    private void TakeOperator(Expression& result);
    private void JoinOperator(Expression& joinExpression);
    private void LetOperator(Expression& result);
    private void GroupJoinOperator(Expression& joinExpression);
    private void GroupByOperator(Expression& groupExp);
    private void EqualsExpressionRule(EqualsExpression& result);
    private void JoinBaseOperator(JoinExpressionBase result);
    private void IntoTailRuleForGroup(Expression result);
    private void JoinSourceRule(JoinExpressionBase result);
    private void JoinOrGroupJoinList(JoinExpressionBase result);
    private void OnQueryOperator(JoinExpressionBase result);
    private void FromOperator(Expression& vbFromExp);
    private void AggregateOperator(Expression& aggregateExpression);
    private void FromDeclarationList(FromExpression result);
    private void IntoTailRule(Expression result);
    private void QueryIdentOrExpressionList(LanguageElementCollection& result);
    private void IntoTailRuleBase(Expression result, DeclaratorType declaratorType);
    private void QueryIdentOrExpressionListBase(LanguageElementCollection& result, DeclaratorType declaratorType);
    private void QueryIdentOrExpression(LanguageElement& result, DeclaratorType declaratorType);
    private void OrderingList(OrderByExpression orderBy);
    private void OrderingRule(OrderingExpression& ordering);
    protected void Parse();
    protected virtual Boolean[0...,0...] CreateSetArray();
    protected virtual void SetUpLineContinuationCheckState();
    protected void DisableImplicitLineContinuationCheck();
    protected void EnableImplicitLineContinuationCheck();
    protected void RestoreImplicitLineContinuationCheck();
    protected bool get_CheckImplicitLineContinuations();
    protected bool get_CheckImplicitLineContinuationAfterToken();
    protected void set_CheckImplicitLineContinuationAfterToken(bool value);
    private ParserBase GetHtmlParser();
    protected virtual TokenCategory GetTokenCategory(CategorizedToken token);
    protected bool XmlCommentStringIsNextNode();
    private void SetTokensCategoryForXml(ParserBase htmlParser);
    private Expression ParseXmlString(string str, SourceRange startRange);
    protected string GetImportsXmlValue();
    protected NamespaceReference CreateXmlImports(string str, Token afterImportsToken);
    protected ElementReferenceExpression GetImportsElementRef(string str, Token afterImportsToken, string name);
    private int GetStartIndex(string str);
    protected static string GetXmlImportsName(string str);
    protected static string GetXmlImportsNamespace(string str);
    protected string GetOneTagXmlValue();
    protected string GetOneTagXmlValue(bool deleteAngelBrackets);
    protected Expression CreateXmlExpression();
    protected void SkipToEol();
    private bool HasAutoImplementedPropertyEnd();
    protected void StatementTerminatorRule();
    private bool AtLeastVS2010();
    private bool LessThanVS2010();
    private bool LessThanOrcas();
    private bool AtLeastOrcas();
    private bool AtLeastVS2005();
    protected bool IsUsing();
    protected bool IsOperatorMemberRule();
    protected bool IsCustomMemberRule();
    protected void SetElementMemberDeclarationProp(LanguageElement element, LanguageElementCollection accessors, TokenQueueBase modifiers, LanguageElementCollection attributes, OnDemandParsingParameters onDemandParsingParameters, SourceRange blockStart);
    protected bool IsContinue();
    protected bool IsTryCast();
    protected Token GetPeek();
    protected bool IsSqlExpression();
    protected bool IsSelectOrFromExpression();
    public void SetElementRange(LanguageElement element, SourceRange startRange, SourceRange endRange);
    protected virtual void Get();
    private void PassStatementTerminator();
    private void PreprocessToken();
    protected bool IsAliasImports();
    private bool IsPreprocessorDirective(Token token);
    public static bool IsPreprocessorDirective(int type);
    protected void PassAttributes(LanguageElement parent, CodeElement param);
    protected bool IsIdentifierOrKeyword();
    public static bool IsIdentifierOrKeyword(int type);
    protected bool IsIdentifier();
    public static bool IsIdentifier(int type);
    protected bool IsKeyword();
    public static bool IsIdentifierOrKeywordOrOperator(Token token);
    protected bool IsIdentifierOrKeywordOrOperator();
    public static bool IsOperator(Token token);
    public static bool IsOperator(int type);
    public static bool IsKeyword(int type);
    protected bool IsFileAttributeSection();
    protected bool IsNotParenClose();
    protected Expression GetAttributeVariableInitializer(Expression leftSide, Expression rigthSide, SourceRange range);
    protected bool IsNamedAssign();
    protected Method SetDeclareAttributes(Method result, bool isExtern, string charsetModifier);
    protected bool HasConst(TokenQueueBase modifiers);
    protected void SetAttributesAndModifiers(LanguageElement lanElement, LanguageElementCollection attributes, TokenQueueBase modifiers);
    protected void SetAttributesAndModifiers(LanguageElement lanElement, LanguageElementCollection attributes, TokenQueueBase modifiers, bool setStartRange);
    private bool IsAsyncModifier();
    private bool HasAsyncModifier(TokenQueueBase tokens);
    private bool IsAsyncLambda();
    private bool IsAwaitExpression();
    protected void SetWithEvents(Variable var, Token token);
    protected void SetBlockRange(LanguageElement element, SourceRange startRange, SourceRange endRange);
    protected void SetBlockRangeForEmptyElement(LanguageElement element, SourceRange startRange, SourceRange endRange);
    private bool MakePropertyAutoImplementedIfNeeded(VBProperty property, SubMemberData subData);
    protected void ReadBlockStartVB(SourceRange range);
    protected bool WaitNamespaceEndToken();
    protected bool WaitEventEndToken();
    protected bool WaitAddHandlerEndToken();
    protected bool WaitRemoveHandlerEndToken();
    protected bool WaitRaiseEventEndToken();
    protected bool WaitGetEndToken();
    protected bool WaitSetEndToken();
    protected bool WaitEnumEndToken();
    protected bool WaitPropertyEndToken();
    protected bool WaitMethodEndToken();
    protected bool WaitTypeEndToken();
    private bool IsPeekToken(Int32[] nextTokens);
    private bool WaitToken(int type, Int32[] nextTokens);
    private bool IsEndDeclOnPeek();
    protected bool IsDeclEnd();
    protected void WaitIfConditionEnd();
    private void WaitTokens(Int32[] types);
    private bool HasTokenType(int tokenType, Int32[] tokens);
    protected LanguageElement SetOperatorAttributes(Method method);
    protected bool InInterface();
    protected string GetMemberType(TypeReferenceExpression typeReference, ICollection arrayModifiers);
    protected Variable CreateVariableList(Variable& endVar, VariableNameCollection coll, VBDeclarator decl, DeclaratorType declaratorType, VariableListHelper varListHelper);
    protected BaseVariable CreateVariable(string name, string type, TypeReferenceExpression typeReference, Expression initializer, DeclaratorType declaratorType);
    protected BaseVariable CreateVariable(string name, string type, LanguageElementCollection arrayModifiers, NullableTypeModifier nullableModifier, TypeReferenceExpression typeReference, Expression initializer, DeclaratorType declaratorType);
    protected BaseVariable CreateSingleVariable(string name, string type, LanguageElementCollection arrayModifiers, NullableTypeModifier nullableModifier, TypeReferenceExpression typeReference, Expression initializer, DeclaratorType declaratorType, bool isImplicitOnly);
    protected BaseVariable CreateVariable(string name, string type, LanguageElementCollection arrayModifiers, NullableTypeModifier nullableModifier, TypeReferenceExpression typeReference, Expression initializer, DeclaratorType declaratorType, bool addTypeToDetailNode);
    protected BaseVariable CreateVariable(string name, string type, LanguageElementCollection arrayModifiers, NullableTypeModifier nullableModifier, TypeReferenceExpression typeReference, Expression initializer, DeclaratorType declaratorType, bool addTypeToDetailNode, bool isImplicitOnly);
    private BaseVariable GetVar(string name, string type, TypeReferenceExpression typeReference, Expression initializer, DeclaratorType declaratorType, bool isImplicitOnly);
    protected bool IsQueryIdent(DeclaratorType declaratorType);
    protected BaseVariable CreateQueryIdent(string name, string typeName, TypeReferenceExpression type, Expression initializer, DeclaratorType declaratorType);
    private void AddVarToCache(BaseVariable var);
    private bool IsImplicitVarCore();
    protected bool IsImplicitVar();
    protected bool IsDeclareVariableCoreWithDecloratorType();
    protected virtual void OpenContext(LanguageElement context);
    protected virtual void CloseContext();
    protected string ToMemberType(string typeName, LanguageElementCollection arrayModifiers);
    private bool IsEOL(int type);
    protected bool IsVarInUsing();
    protected bool IsVariableInLoopControlVariable();
    protected TypeReferenceExpression ToTypeReferenceExpression(TypeReferenceExpression type, LanguageElementCollection arrayModifiers, LanguageElement nullableModifier, LanguageElement parent);
    protected bool IsLabel();
    protected bool NeedExitFromStatementLoop();
    protected bool IsEndStatement();
    protected void SetGenericArgumentsToQualifiedIdentifier(ReferenceExpressionBase expression);
    protected Expression CreateAttributeArgumentInitializer(Token token, Expression expression);
    protected void AddDirective(CompilerDirective directive);
    protected void AddAttribute(AttributeSection section, Attribute attribute);
    protected void AddAttributeArgument(Attribute attribute, Expression argument);
    protected void AddAttributes(CodeElement element, LanguageElementCollection attributes);
    protected string GetDateLiteral(string month, string day, string year, string hour, string minute, string second, string ampm, string dateDelemiter);
    protected PrimitiveExpression GetPrimitiveExpression(string value, SourceRange range, PrimitiveType type);
    protected BinaryOperatorExpression GetBinaryExpression(Expression left, string operatorName, BinaryOperatorType type, Expression right, SourceRange nameRange);
    protected LogicalOperation GetLogicalOperation(Expression left, string operatorName, LogicalOperator type, Expression right, SourceRange nameRange);
    protected RelationalOperation GetRelationalOperation(Expression left, string operatorName, RelationalOperator type, Expression right, SourceRange defaultRange);
    protected Expression GetExpressionForUnaryOperation(string name, SourceRange start, Expression expression);
    protected Assignment GetAssignment(Expression left, SourceTextRange textRange, AssignmentOperatorType type, Expression right);
    protected AssignmentExpression GetAssignmentExpression(Expression left, string operaorText, AssignmentOperatorType type, SourceRange operatorRange, Expression right);
    protected TypeReferenceExpression GetNullableType(TypeReferenceExpression expression);
    protected TypeReferenceExpression GetNullableType(TypeReferenceExpression expression, Token token);
    protected ReferenceExpressionBase GetExpression(string name, SourceRange nameRange, CreateElementType elementType);
    protected ReferenceExpressionBase GetExpression(Expression source, string name, SourceRange nameRange, CreateElementType elementType);
    protected bool isElementRef();
    protected bool IsLocalVar();
    protected bool IsField(TokenQueueBase modifiers);
    private TypeReferenceExpression GetTypeReferenceExpression(string name, SourceRange range);
    protected ElementReferenceExpression GetElementReference(string name, SourceRange range);
    protected ElementReferenceExpression GetElementReference(Expression source, string name, SourceRange nameRange);
    protected ElementReferenceExpression GetXmlAttrElementReference(Expression source, string name, SourceRange nameRange);
    protected ElementReferenceExpression GetXmlElementReference(Expression source, string name, SourceRange nameRange);
    private void SetPropertiesForElementReferenceExpression(ElementReferenceExpression result, Expression source, SourceRange nameRange);
    protected bool ConditionContext();
    protected void SetRange(LanguageElement element, Object[] args);
    private Token SkipParamQualifiers();
    private bool IsParamQualifier(int type);
    protected bool IsLambdaParameter();
    protected DelegateDefinition CreateDelegate(SubMemberData subMember, VBDeclarator decl);
    protected VBEvent CreateEvent(SubMemberData subMember, VBDeclarator decl);
    protected Method CreateMethod(SubMemberData subMember, MethodTypeEnum methodTypeEnum, TokenQueueBase modifiers, VBDeclarator decl, SourceRange methodKeyWordRange);
    private bool NeedToTrimEndDoubleQuote(string value);
    protected void AddTextString(Token stringToken);
    private BaseVariable GetImplicitVariableToMethod(SubMemberData subMember);
    protected VBProperty CreateProperty(SubMemberData subMember, TokenQueueBase modifiers, VBDeclarator decl);
    private void SetParametersToLocalVarArrayCollection(LanguageElementCollection parameters);
    private void FinishCreateMember(MemberWithParameters result, SubMemberData subMember, VBDeclarator decl, TokenQueueBase modifiers);
    private void SetDefaultVisibility(AccessSpecifiedElement element);
    private void AddType(MemberWithParameters result, TypeReferenceExpression type);
    protected void FinishCreateMember(MemberWithParameters result, LanguageElementCollection parameters, TypeReferenceExpression type, TokenQueueBase modifiers, VBDeclarator decl, GenericModifier genericModifier, SourceRange nameRange);
    protected void SetGenericTypeArguments(ExpressionCollection arguments, Token endToken, ReferenceExpressionBase result);
    protected void SetBlockRange(DelimiterCapableBlock block, SourceRange startRange, SourceRange endRange);
    protected ObjectCreationExpression GetObjectCreationExpression(TypeReferenceExpression type, ExpressionCollection args, SourceRange startRange, SourceRange endRange, SourceRange parensRange);
    protected TypeReferenceExpression GetArrayTypeReference(TypeReferenceExpression sourceType, ExpressionCollection coll, int rank);
    protected ArrayCreateExpression GetArrayCreateExpression(TypeReferenceExpression type, ArrayInitializerExpression initializer, SourceRange startRange, SourceRange endRange);
    protected TypeReferenceExpression GetTypeReferenceExpression(Expression source, string name, SourceRange range);
    public Expression ParseConditionExpression(Token& laToken, Token& token);
    private void PreparePreprocessor();
    protected void PrepareParse();
    protected void PrepareParse(LanguageElement context);
    protected void FinishParse(LanguageElement context);
    protected bool get_OnDemand();
    public virtual string GetFullTypeName(string simpleName);
    protected TypeReferenceExpression ParseTypeReferenceExpression();
    protected Expression ParseExpression();
    protected Statement ParseStatement();
    protected BaseVariable ParseVariable();
    protected Member ParseMember();
    protected LanguageElement Parse(LanguageElement context, ISourceReader reader);
    public LanguageElement ParseExpression(ISourceReader reader);
    public TypeReferenceExpression ParseTypeReferenceExpression(ISourceReader reader);
    public LanguageElement ParseStatement(ISourceReader reader);
    public LanguageElement ParseVariable(ISourceReader reader);
    public LanguageElement ParseMember(ISourceReader reader);
    public virtual SourceFile GetSourceFile(string fileName);
    public LanguageElement Parse(ISourceReader reader);
    protected void SetHasBlockAndBlockType();
    protected void SetHasBlockAndBlockType(LanguageElement element);
    protected Token SkipTokensToMethod();
    protected Token SkipTokensToProperty();
    private void AddTextStringOnDemand(Token token);
    protected Token SkipTokens(Int32[] tokenTypes);
    protected void SetPropertyAccessors(VBProperty property, LanguageElementCollection accessors);
    protected void SetBlockEnd(LanguageElement element);
    protected void SetBlockStart(LanguageElement element, SourceRange range);
    protected void AddBlockRangeOnDemand(LanguageElement element, OnDemandParsingParameters onDemandParsingParameters);
    protected void AddBlockRangeOnDemand(LanguageElement element, Token startToken, Token endToken);
    protected IndexerExpression CreateIndexerExpression(Expression sourceExpression, Expression argument);
    protected IndexerExpression CreateIndexerExpression(Expression sourceExpression, ExpressionCollection arguments);
    private void AddArgumentsToIndexerExpression(IndexerExpression indexerExpression, Expression argument);
    private void AddArgumentsToIndexerExpression(IndexerExpression indexerExpression, ExpressionCollection arguments);
    protected bool IsStatementTerminator();
    protected Expression MethodReferenceToMethodCall(Expression mre, ExpressionCollection parameters);
    protected Expression MethodReferenceToMethodCall(Expression mre, ExpressionCollection parameters, bool isBaseConstructorCall);
    private bool IsSingleLineXmlComment(Comment comment);
    private bool IsRemComment(Token token);
    private bool IsXmlComment(Token token);
    private bool IsSimpleSingleLineComment(Token token);
    private bool IsSingleLineCommentName(Token token, string name);
    private string GetSubStringInTokenValue(int startIndex, int lenght, Token token);
    protected void AddCommentNode(Token lCommentToken);
    private bool TokenIsComment(Token token);
    public virtual ExpressionParserBase CreateExpressionParser();
    protected virtual void CleanUpParser();
    protected void AddToUsingList(string name, string aliasName, Expression exp);
    public virtual string get_Language();
    public virtual CommentCollection get_Comments();
    public VB90ParserErrors get_Errors();
    public bool get_ParseOnlyExpression();
    public void set_ParseOnlyExpression(bool value);
    protected LocalVarArrayCollection get_LocalVarArrayCollection();
    public virtual ParserVersion get_VsVersion();
    public virtual void set_VsVersion(ParserVersion value);
    protected bool IsAssignmentOperator(Token token);
    protected bool IsRelationalOp(Token token);
    public virtual bool SupportsFileExtension(string ext);
    public virtual IExpressionInverter CreateExpressionInverter();
    protected bool IsQueryIdentForDeclaration(DeclaratorType type);
    protected Expression CreateAggregateExpressionIfNeeded(Expression exp, DeclaratorType declaratorType);
    private bool IsAggregateElementName(string name);
    private bool IsAggregateMethodName(string name);
    protected void AddEqualsExpression(JoinExpressionBase result, EqualsExpression exp);
    protected void SetGroupCollection(GroupByExpression result, LanguageElementCollection coll);
    protected void SetIntoCollection(Expression result, LanguageElementCollection coll);
    protected void SetGroupByCollection(GroupByExpression result, LanguageElementCollection coll);
    protected bool IsGroupJoinOperator();
    protected void SetSelectCollection(SelectExpression result, LanguageElementCollection coll);
    protected Expression GetInitializer(QueryIdent ident);
    protected string GetTypeCharacter();
    private bool IsTypeCharacter();
    private bool IsIndexer();
    private bool IsRelationalTokens(Token first, Token second);
    protected bool IsValidEndParsing();
    protected void RecoverParsing();
    protected void SetDefaultOptionStrict();
    protected void SetOptionStrict(OptionState state);
    protected void SetDefaultOptionExplicit();
    protected void SetOptionExplicit(OptionState state);
    protected void SetDefaultOptionInfer();
    protected void SetOptionInfer(OptionState state);
    private void LogSkipToken();
    private void SkipTokenToBlockEnd();
    private bool IsSkipTokensEnd();
    protected void SetParamProperties(Param param, VBDeclarator decl);
    protected void SetParamProperties(Param param, VBDeclarator decl, LanguageElementCollection& arrayModifiers, NullableTypeModifier& nullableModifier, TypeReferenceExpression& type);
    protected bool IsIfStatement();
    protected ConditionalExpression CreateIfExpression(Expression cond, Expression first, Expression second);
    protected Expression CreateConditionalTypeCast(Expression left, Expression right);
    protected LanguageElementCollection CreateVarNextColl(Variable firstVar);
    protected bool IsMethodReferenceExpression();
    protected void SetParensRanges(ParentingStatement target, SourceRange parenOpenRange, SourceRange parenCloseRange);
    private void AddImplicitParamToAccessor(VBProperty member, Accessor accessor);
    protected Statement GetSimpleStatement(Expression leftPart, SourceRange startRange);
    private bool IsEndDecl(int tokenType);
    private bool IsStartNewDecl(int tokenType);
    protected void GetEndToken(bool skipToken);
    protected bool get_ParsingRazor();
    private bool IsValidRazorStatementStart(Token la, int scannerStartPosition);
    public sealed virtual LanguageElementCollection ParseRazorFunctions(ISourceReader reader, Int32& scannerPositionDelta);
    private LanguageElementCollection ParseRazorStatement();
    private bool IsRazorMarkup();
    private void ParseRazorMarkup();
    private LanguageElementCollection ParseHtmlCode(Int32& scannerPositionDelta);
    private ISourceReader GetRazorReader();
    protected LanguageElementCollection ParseRazorExpression();
    private bool IsRazorCodeKeyword(Token token);
    public sealed virtual LanguageElementCollection ParseRazorCode(ISourceReader reader, Int32& scannerPositionDelta);
    public sealed virtual LanguageElement ParseRazorHelper(ISourceReader reader, Int32& scannerPositionDelta);
    private LanguageElement ParseRazorHelper();
    protected virtual FormattingTable get_FormattingTable();
}
public class DevExpress.CodeParser.VB.VB90ParserErrors : ParserErrorsBase {
    protected virtual string GetSyntaxErrorText(int n);
}
public class DevExpress.CodeParser.VB.VB90Scanner : VBScanner {
    public VB90Scanner(string input);
    public VB90Scanner(ISourceReader reader);
    public VB90Scanner(ISourceReader reader, int line, int offset);
}
public class DevExpress.CodeParser.VB.VB90SpecifiersHelper : object {
    public static void ParseSpecifiers(TokenQueueBase queue, Accessor element);
    private static void SetBlockRange(DelimiterCapableBlock block, TokenQueueBase queue);
    public static void ParseSpecifiers(TokenQueueBase queue, AccessSpecifiedElement element);
}
public class DevExpress.CodeParser.VB.VB90Tokens : VBTokensBase {
    private static VB90Tokens _Instance;
    public static VB90Tokens Instance { get; }
    protected virtual StringCollection CreateKeywords();
    public static VB90Tokens get_Instance();
}
public class DevExpress.CodeParser.VB.VBCodeGen : CodeGen {
    private bool _CheckForDetailNodes;
    private LanguageElement _FirstElement;
    protected string LineContinuation { get; }
    internal FormattingTable FormattingTable { get; }
    public bool CheckForDetailNodes { get; public set; }
    public VBCodeGen(CodeGenOptions options);
    private void GenerateCaseClauseList(CaseClausesList caseClausesList);
    private void GenerateCaseClause(CaseClause caseClause);
    private void GenerateArrayNameModifier(ArrayNameModifier element);
    private void AddOperatorTokens(FormattingTokenType tokenType, FormattingElements tokens);
    private void VBContextPoped(LanguageElement oldContext);
    private bool ContextIsEmptyArgumentList();
    private bool ContextIsNotEmptyArgumentList();
    protected virtual HtmlXmlCodeGenBase CreateHtmlXmlGen();
    protected virtual TemplateParameterCodeGenBase CreateTemplateParameterGen();
    protected virtual TemplateCodeGenBase CreateTemplateGen();
    protected virtual DirectiveCodeGenBase CreateDirectiveGen();
    protected virtual ExpressionCodeGenBase CreateExpressionGen();
    protected virtual MemberCodeGenBase CreateMemberGen();
    protected virtual StatementCodeGenBase CreateStatementGen();
    protected virtual SupportElementCodeGenBase CreateSupportElementGen();
    protected virtual TypeDeclarationCodeGenBase CreateTypeDeclarationGen();
    protected virtual XmlCodeGenBase CreateXmlGen();
    protected virtual NamespaceReferenceGenBase CreateNamespaceReferenceGen();
    protected virtual NamespaceGenBase CreateNamespaceGen();
    protected virtual SnippetCodeGenBase CreateSnippetGen();
    protected virtual bool IsSpecificElement(LanguageElement element);
    protected virtual bool IsFirstTypeAncestor(LanguageElement context, TypeDeclaration type);
    protected virtual bool IsFirst(LanguageElement context);
    protected virtual bool IsLast(LanguageElement context);
    protected virtual bool IsNotFirst(LanguageElement context);
    protected virtual bool NeedIndenting(LanguageElement context, bool pushed);
    protected virtual bool NeedWrapWithoutFirst(LanguageElement context);
    protected virtual bool NeedWrapFirst(LanguageElement context);
    protected virtual bool NeedAlignment(LanguageElement context, bool pushed);
    protected virtual void GenerateSpecificElement(LanguageElement element);
    protected virtual void ContextPushed();
    protected virtual void ContextPoped(LanguageElement oldContext);
    protected virtual void AddWrappingNewLine();
    protected bool ContextMatch(LanguageElementType type);
    protected virtual void GenerateElementList(LanguageElement element);
    protected virtual string get_LineContinuation();
    internal virtual FormattingTable get_FormattingTable();
    public void GenerateVisibility(MemberVisibility visibility);
    public virtual void GenerateMemberVisibilitySpecifier(MemberVisibilitySpecifier specifier);
    public virtual void GenerateElement(LanguageElement element);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public bool get_CheckForDetailNodes();
    public void set_CheckForDetailNodes(bool value);
}
public class DevExpress.CodeParser.VB.VBContinue : Continue {
    private ContinueKind _ContinueKind;
    public LanguageElementType ElementType { get; }
    public ContinueKind ContinueKind { get; }
    public VBContinue(ContinueKind continueKind);
    public VBContinue(Token continueKind, SourceRange range);
    private ContinueKind ToContinueKind(int tokenType);
    private bool MatchesContinueKind(LanguageElement element);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual int GetImageIndex();
    public virtual LanguageElement FindTarget();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public ContinueKind get_ContinueKind();
}
public class DevExpress.CodeParser.VB.VBDeclarator : object {
    private string _FullTypeName;
    private CreateElementType _CreateElementType;
    private LanguageElementCollection _ArrayModifiers;
    private NullableTypeModifier _NullableModifier;
    private TypeReferenceExpression _CharacterType;
    public LanguageElementCollection ArrayModifiers { get; }
    public NullableTypeModifier NullableModifier { get; public set; }
    public CreateElementType CreateElementType { get; public set; }
    public string FullTypeName { get; public set; }
    public TypeReferenceExpression CharacterType { get; public set; }
    public VBDeclarator(CreateElementType createElementType);
    public void AddArrayModifier(ArrayNameModifier modifier);
    public LanguageElementCollection get_ArrayModifiers();
    public NullableTypeModifier get_NullableModifier();
    public void set_NullableModifier(NullableTypeModifier value);
    public void set_CreateElementType(CreateElementType value);
    public CreateElementType get_CreateElementType();
    public void set_FullTypeName(string value);
    public string get_FullTypeName();
    public TypeReferenceExpression get_CharacterType();
    public void set_CharacterType(TypeReferenceExpression value);
}
public class DevExpress.CodeParser.VB.VBDirectiveCodeGen : DirectiveCodeGenBase {
    public VBDirectiveCodeGen(CodeGen codeGen);
    protected virtual void GenerateDefineDirective(DefineDirective directive);
    protected virtual void GenerateIfDirective(IfDirective directive);
    protected virtual void GenerateElifDirective(ElifDirective directive);
    protected virtual void GenerateElseDirective(ElseDirective directive);
    protected virtual void GenerateEndIfDirective(EndIfDirective directive);
    protected virtual void GenerateUndefDirective(UndefDirective directive);
    protected virtual void GenerateErrorDirective(ErrorDirective directive);
    protected virtual void GenerateWarningDirective(WarningDirective directive);
    protected virtual void GenerateLineDirective(LineDirective directive);
    protected virtual void GenerateRegion(RegionDirective directive);
    protected virtual void GenerateEndRegion(EndRegionDirective directive);
    protected virtual void GenerateIfDefDirective(IfDefDirective directive);
    protected virtual void GenerateIfnDefDirective(IfnDefDirective directive);
    protected virtual void GenerateIncludeDirective(IncludeDirective directive);
    protected virtual void GenerateImportDirective(ImportDirective directive);
}
public class DevExpress.CodeParser.VB.VBEvent : Event {
    private IElementCollection _ImplicitElements;
    public MemberVisibility[] ValidVisibilities { get; }
    public bool VisibilityIsFixed { get; }
    public IElementCollection ImplicitElements { get; }
    public VBEvent(string name);
    private DelegateDefinition GetEventDelegate();
    private Variable GetEventField(TypeReferenceExpression type);
    private IElementCollection GetImplicitElements();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual MemberVisibility[] get_ValidVisibilities();
    public virtual bool get_VisibilityIsFixed();
    public virtual IElementCollection get_ImplicitElements();
}
public class DevExpress.CodeParser.VB.VBExpressionCodeGen : TokenExpressionCodeGenBase {
    private CodeGen _HtmlCodeGen;
    private CodeGen HtmlCodeGen { get; }
    public VBExpressionCodeGen(CodeGen codeGen);
    private string DeleteLastEOL(string str);
    private bool IsNotNull(NodeList list);
    private bool ParentIsValidForArrayBoundsGeneration(Expression exp);
    private void GenerateTypeCharacter(string name);
    private void GeneratesIntoTail(IIntoContainingElement element);
    private void GenerateLambdaFunctionExpression(LambdaFunctionExpression expression);
    private void WrapQuery();
    private void GenerateJoinExpressionBase(JoinExpressionBase expression);
    private void GenerateAwaitExpression(AwaitExpression awaitExpression);
    private void GenerateQueryaleCollectionReferenceExpression(QueryableCollectionReferenceExpression expression);
    private CodeGen get_HtmlCodeGen();
    protected virtual bool GenerateMacroExpression(Expression expression);
    protected virtual bool GenerateSpecificExpression(Expression expression);
    protected virtual void GenerateBinaryOperator(BinaryOperatorExpression expression);
    protected virtual void GenerateLogicalOperation(LogicalOperation expression);
    protected virtual string GetBinaryOperatorText(BinaryOperatorType operatorType);
    protected virtual FormattingTokenType GetBinaryOperatorToken(BinaryOperatorType op);
    protected virtual void GenerateTypedElementReferenceExpression(TypedElementReferenceExpression expression);
    protected virtual void GenerateMyClassExpression(MyClassExpression expression);
    protected virtual void GenerateElementReferenceExpression(ElementReferenceExpression expression);
    protected virtual void GenerateManagedArrayCreateExpression(ManagedArrayCreateExpression expression);
    protected virtual void GenerateCppQualifiedElementReference(CppQualifiedElementReference expression);
    protected virtual void GenerateDeleteArrayExpression(DeleteArrayExpression expression);
    protected virtual void GenerateComplexExpression(ComplexExpression expression);
    protected virtual void GenerateExpressionTypeArgument(ExpressionTypeArgument expression);
    protected virtual void GenerateDeleteExpression(DeleteExpression expression);
    protected virtual void GenerateElaboratedTypeReference(ElaboratedTypeReference expression);
    protected virtual void GenerateManagedObjectCreationExpression(ManagedObjectCreationExpression expression);
    protected virtual void GenerateParametizedArrayCreateExpression(ParametrizedArrayCreateExpression expression);
    protected virtual void GenerateParametizedObjectCreationExpression(ParametrizedObjectCreationExpression expression);
    protected virtual void GeneratePointerElementReference(PointerElementReference expression);
    protected virtual void GenerateQualifiedNestedReference(QualifiedNestedReference expression);
    protected virtual void GenerateQualifiedNestedTypeReference(QualifiedNestedTypeReference expression);
    protected virtual void GenerateQualifiedTypeReferenceExpression(QualifiedTypeReferenceExpression expression);
    protected virtual void GenerateQualifiedMethodReference(QualifiedMethodReference expression);
    protected virtual void GeneratePointerMethodReference(PointerMethodReference expression);
    protected virtual void GenerateGenericTypeArguments(TypeReferenceExpressionCollection arguments);
    protected virtual void GenerateEqualsExpression(EqualsExpression expression);
    protected virtual void GenerateGroupByExpression(GroupByExpression expression);
    protected virtual void GenerateJoinIntoExpression(JoinIntoExpression expression);
    protected virtual void GenerateJoinExpression(JoinExpression expression);
    protected virtual void GenerateAddressOfExpression(AddressOfExpression expression);
    protected virtual void GenerateArgumentDirectionExpression(ArgumentDirectionExpression expression);
    protected virtual void GenerateArrayCreateExpression(ArrayCreateExpression expression);
    protected virtual void GenerateArrayInitializerExpression(ArrayInitializerExpression expression);
    protected virtual void GenerateAssignmentExpression(AssignmentExpression expression);
    protected virtual void GenerateBaseReferenceExpression(BaseReferenceExpression expression);
    protected virtual void GenerateConditionalExpression(ConditionalExpression expression);
    protected virtual void GenerateIndexerExpression(IndexerExpression expression);
    protected virtual void GenerateObjectCreationExpression(ObjectCreationExpression expression);
    protected virtual void GenerateBooleanLiteral(bool value);
    protected virtual bool IsEscapedString(string value);
    protected virtual void GenerateStringLiteral(string value);
    protected virtual void GenerateStringLiteralWithEscapeSequence(string value);
    protected virtual void GenerateCharLiteral(char value);
    protected virtual void GenerateNullLiteral();
    protected virtual void GenerateNumberLiteral(string name, object value, PrimitiveType type);
    protected virtual void GenerateDateTime(object value);
    protected virtual void GenerateThisReferenceExpression(ThisReferenceExpression expression);
    protected virtual void GenerateTypeCastExpression(TypeCastExpression expression);
    protected virtual void GenerateTypeOfExpression(TypeOfExpression expression);
    protected virtual void GenerateTypeOfIsExpression(TypeOfIsExpression expression);
    protected virtual void GenerateTypeReferenceExpression(TypeReferenceExpression expression);
    protected virtual void GenerateLogicalInversion(LogicalInversion expression);
    protected virtual void GenerateTypeCheck(TypeCheck expression);
    protected virtual void GenerateUnaryDecrement(UnaryDecrement expression);
    protected virtual void GenerateUnaryIncrement(UnaryIncrement expression);
    protected virtual void GenerateConditionalTypeCast(ConditionalTypeCast expression);
    protected virtual void GenerateParenthesizedExpression(ParenthesizedExpression expression);
    protected virtual void GenerateIsNot(IsNot expression);
    protected virtual void GenerateAttributeVariableInitializer(AttributeVariableInitializer expression);
    protected virtual void GenerateFromExpression(FromExpression expression);
    protected virtual void GenerateInExpression(InExpression expression);
    protected virtual void GenerateWhereExpression(WhereExpression expression);
    protected virtual void GenerateOrderingExpression(OrderingExpression expression);
    protected virtual void GenerateOrderByExpression(OrderByExpression expression);
    protected virtual void GenerateSelectExpression(SelectExpression expression);
    protected virtual void GenerateIntoExpression(IntoExpression expression);
    protected virtual void GenerateArgumentDirection(ArgumentDirection direction);
    protected virtual void GenerateCheckedExpression(CheckedExpression expression);
    protected virtual void GenerateUncheckedExpression(UncheckedExpression expression);
    protected virtual void GenerateSizeOfExpression(SizeOfExpression expression);
    protected virtual void GenerateAnonymousMethodExpression(AnonymousMethodExpression expression);
    protected virtual void GenerateDefaultValueExpression(DefaultValueExpression expression);
    protected virtual void GenerateNullCoalescingExpression(NullCoalescingExpression expression);
    protected virtual void GenerateQualifiedAliasExpression(QualifiedAliasExpression expression);
    protected virtual void GenerateMemberInitializerExpression(MemberInitializerExpression expression);
    protected virtual void GenerateObjectInitializerExpression(ObjectInitializerExpression expression);
    protected virtual void GenerateLambdaExpression(LambdaExpression expression);
    protected virtual void GenerateQueryExpression(QueryExpression expression);
    protected virtual void GenerateDistinctExpression(DistinctExpression expression);
    protected virtual void GenerateLetExpression(LetExpression expression);
    protected virtual void GenerateFunctionPointerTypeReference(FunctionPointerTypeReference expression);
    protected virtual void GenerateRelationalOperator(RelationalOperator relationalOperator);
    protected virtual void GenerateReferenceExpressionBase(ReferenceExpressionBase expression);
    protected virtual void GenerateXmlElementReferenceExpression(XmlElementReferenceExpression expression);
    protected virtual void GenerateXmlAttributeReferenceExpression(XmlAttributeReferenceExpression expression);
    protected virtual void GenerateXmlExpression(XmlExpression expression);
    protected virtual void GenerateIsExpression(Is expression);
    protected void GenerateReDimExpression(ReDimExpression expression);
    protected void GenerateAggregateExpression(AggregateExpression expression);
    protected void GenerateSkipExpression(SkipExpression expression);
    protected void GenerateSkipWhileExpression(SkipWhileExpression expression);
    protected void GenerateTakeExpression(TakeExpression expression);
    protected void GenerateTakeWhileExpression(TakeWhileExpression expression);
    protected void GenerateObjectCollectionInitializer(ObjectCollectionInitializer expression);
    protected void GenerateStringLiteralCore(string value, bool canHasEscapeConstants);
    protected void GenerateDirectCastExpression(DirectCastExpression expression);
    protected void GenerateCTypeExpression(CTypeExpression expression);
    protected void GenerateCTypeExpression(Expression target, TypeReferenceExpression type);
    protected void GenerateCastTargetExpression(CastTargetExpression expression);
    protected virtual FormattingTokenType GetOperatorToken(UnaryOperatorExpression expression);
    public void GenerateTypeString(string type);
    public static void GenerateAssignmentOperatorText(CodeGen codeGen, AssignmentOperatorType op);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
}
public abstract class DevExpress.CodeParser.VB.VBExpressionParserBase : ExpressionParserBase {
    public VBTokensBase VBTokens { get; }
    public VBExpressionParserBase(ParserBase parser);
    public abstract virtual VBTokensBase get_VBTokens();
}
public class DevExpress.CodeParser.VB.VBFor : For {
    private NodeList _NextExpressionList;
    public NodeList NextExpressionList { get; public set; }
    public virtual void AddNextExpression(LanguageElement element);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual void CleanUpOwnedReferences();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public NodeList get_NextExpressionList();
    public void set_NextExpressionList(NodeList value);
}
public class DevExpress.CodeParser.VB.VBForEach : ForEach {
    private Expression _NextExpression;
    private LanguageElement _Initializer;
    public LanguageElement Initializer { get; public set; }
    public Expression NextExpression { get; public set; }
    protected virtual void SetInitializer(LanguageElement value);
    protected virtual void SetNextExpression(Expression value);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual string ToString();
    public virtual void CleanUpOwnedReferences();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public LanguageElement get_Initializer();
    public void set_Initializer(LanguageElement value);
    public virtual Expression get_NextExpression();
    public virtual void set_NextExpression(Expression value);
}
internal class DevExpress.CodeParser.VB.VBLanguageUtils : LanguageUtils {
    public virtual ParserBase CreateParser(ParserVersion version, EmbededLanguageKind languageKind, DotNetLanguageType embededLanguage);
    public virtual CodeGen CreateCodeGen();
    public virtual ElementBuilder CreateElementBuilder();
    public virtual Tokenizer CreateTokenizer();
}
public class DevExpress.CodeParser.VB.VBMemberCodeGen : MemberCodeGenBase {
    protected VBCodeGen VBCodeGen { get; }
    public VBMemberCodeGen(CodeGen codeGen);
    private TypeReferenceExpression GetNotArrayAndNotNullableType(TypeReferenceExpression type);
    private TypeReferenceExpression GetBaseType(TypeReferenceExpression exp);
    private bool HasPrevVariable(Variable var);
    private bool GenerateArrayNameModifiers(Variable var);
    private bool NeedGenerate(Variable var);
    private bool IsSub(Member member);
    private bool CanGenerateMethodVisibility(Method method);
    private bool IsMemberWithoutBody(AccessSpecifiedElement element);
    private bool MemberWithVisibility(Member member);
    private bool IsDefaultVisibility(AccessSpecifiedElement element);
    private bool ShouldGenerateExtensionMethodAttribute(Method method);
    private bool ContainsExtensionAttribute(NodeList attributes);
    private bool ContainsExtensionMethodParameter(LanguageElementCollection parameters);
    private bool IsTypeCharacter(TypeReferenceExpression type);
    private void GenerateAccessSpecifiersInInterface(AccessSpecifiers access);
    private void GenerateMemberType(Member member);
    private void GenerateArgumentDirection(ArgumentDirection ad);
    private void GenerateVariableBase(Variable var);
    private void GenerateRootMemberType(Member member);
    private void WriteWithEvents(BaseVariable var);
    private void GenerateDim(Variable var);
    private void GenerateVariableBase(Variable var, bool generateMemberType);
    private void GenerateTypeCharacter(TypeReferenceExpression exp);
    private void GenerateVariableEnd(Variable var);
    private void GenerateMemberImplementsOrHandlesCollection(Member member);
    private void GenerateMemberImplementsCollection(Member member);
    private void GenerateMemberHandlesCollection(Member member);
    private void WriteString(FormattingTokenType type, string str);
    private void WriteMethodName(Method method);
    private void WriteMethodSpecifier(Method method);
    private bool IsMultilineMember(LanguageElement element);
    private bool IsSinlelineMember(LanguageElement element);
    protected virtual void GenerateTypeParameterConstraintCollection(TypeParameterConstraintCollection collection);
    protected virtual void GenerateInitializedVolatile(InitializedVolatile var);
    protected virtual void GenerateConstVolatile(ConstVolatile member);
    protected virtual void GenerateVolatile(Volatile member);
    protected virtual void GenerateMethodPrototype(MethodPrototype member);
    protected virtual void GenerateMethod(Method method);
    protected virtual void GenerateEvent(Event member);
    protected virtual void GenerateProperty(Property property);
    protected virtual void GenerateDelegate(DelegateDefinition member);
    protected virtual void GenerateConst(Const var);
    protected virtual void GenerateVariable(Variable var);
    protected virtual void GenerateInitializedVariable(InitializedVariable var);
    protected virtual void GenerateParameter(Param param);
    protected virtual void GenerateEnumElement(EnumElement element);
    protected virtual void GenerateImplicitVariable(ImplicitVariable member);
    protected virtual void GenerateExtensionMethodParam(ExtensionMethodParam member);
    protected virtual void GenerateLambdaImplicitlyTypedParam(LambdaImplicitlyTypedParam member);
    protected virtual void GenerateQueryIdent(QueryIdent member);
    protected VBCodeGen get_VBCodeGen();
    public void GenerateAccessSpecifiers(AccessSpecifiers access, bool forType);
    public void GenerateAccessSpecifiers(AccessSpecifiers access, bool forType, bool forLocal);
    public void GenerateMemberVisibility(AccessSpecifiedElement member);
    public void GenerateMemberVisibility(MemberVisibility visibility);
    public virtual void GenerateGenericModifier(GenericModifier generic);
    public virtual void GenerateTypeParameters(GenericModifier generic);
    public virtual void GenerateTypeParameterConstraints(GenericModifier generic, bool addLastNewLine);
    public virtual void GenerateTypeParameterConstraints(TypeParameterCollection collection, bool addLastNewLine);
    public virtual void GenerateTypeParameter(TypeParameter expression);
    public virtual void GenerateTypeParameterConstraint(TypeParameterConstraint constraint);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public class DevExpress.CodeParser.VB.VBMethod : Method {
    public MemberVisibility[] ValidVisibilities { get; }
    public bool VisibilityIsFixed { get; }
    public VBMethod(string typeName, string name);
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual MemberVisibility[] get_ValidVisibilities();
    public virtual bool get_VisibilityIsFixed();
}
public class DevExpress.CodeParser.VB.VBNamespaceGen : NamespaceGenBase {
    public VBNamespaceGen(CodeGen codeGen);
    protected virtual void GenerateNamespace(Namespace element);
}
public class DevExpress.CodeParser.VB.VBNamespaceReferenceGen : NamespaceReferenceGenBase {
    public VBNamespaceReferenceGen(CodeGen codeGen);
    protected virtual void GenerateXmlNamespaceReference(XmlNamespaceReference element);
    protected virtual void GenerateExternAlias(ExternAlias element);
    protected virtual void GenerateNamespaceReference(NamespaceReference element);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public class DevExpress.CodeParser.VB.VBOldExpressionInverter : ExpressionInverterBase {
    protected virtual Expression InvertIsExpression(Is expression);
}
public class DevExpress.CodeParser.VB.VBOperatorHelper : object {
    public static FormattingTokenType GetOperatorNaturalName(string name);
    private static OperatorType GetUnaryOperatorType(string name);
    private static OperatorType GetBinaryOperatorType(string name);
    private static string GetUnaryOperatorName(OperatorType type);
    private static string GetBinaryOperatorName(OperatorType type);
    public static OperatorType GetOperatorType(string value, int parameterCount);
    public static string GetOperatorName(OperatorType type, int parameterCount);
}
public abstract class DevExpress.CodeParser.VB.VBParserBase : ParserBase {
    public string Language { get; }
    protected virtual InitializedVariable CreateInitializedVariable();
    protected virtual Variable CreateVariable();
    protected virtual Const CreateConst();
    public virtual bool SupportsFileExtension(string ext);
    public virtual SourceFile GetSourceFile(string aSourceFileName);
    public virtual string get_Language();
}
public class DevExpress.CodeParser.VB.VBPrimitiveTypeUtils : object {
    private static string STR_H;
    private static string STR_h;
    private static string STR_O;
    private static string STR_o;
    private static string STR_S;
    private static string STR_US;
    private static string STR_uS;
    private static string STR_Us;
    private static string STR_us;
    private static string STR_I;
    private static string STR_UI;
    private static string STR_uI;
    private static string STR_Ui;
    private static string STR_ui;
    private static string STR_L;
    private static string STR_UL;
    private static string STR_uL;
    private static string STR_Ul;
    private static string STR_ul;
    private static string STR_F;
    private static string STR_R;
    private static string STR_D;
    private static string STR_F_;
    private static string STR_R_;
    private static string STR_D_;
    private static bool ConvertToDecimal(string value, Decimal& result);
    private static PrimitiveType GetIntegerTypeFromValue(string value);
    private static bool EndsWith(string str, string strEnd);
    private static string GetIntegerLiteralSuffix(string value);
    private static string GetFloatingPointLiteralSuffix(string value);
    private static bool GetIntegerLiteralValue(string value, Decimal& intValue);
    private static bool GetFloatingPointLiteralValue(string value, Decimal& realValue);
    public static PrimitiveType NarrowIntegerLiteralType(string value);
    private static PrimitiveType NarrowIntegerLiteralType(string suffix, decimal intValue);
    public static PrimitiveType NarrowFloatingPointLiteralType(string value);
    public static PrimitiveType NarrowCharAndStringLiteralType(string value);
    private static bool HasCharSuffix(string value);
    private static string RemoveQuotes(string s);
    private static string RemoveCharQuotes(string s);
    public static PrimitiveType ToPrimitiveType(Token token);
    public static PrimitiveType ToPrimitiveType(int tokenType, string value);
    public static object ToPrimitiveValue(Token token);
    public static object ToPrimitiveValue(int tokenType, string value);
    public static object ToPrimitiveValueFromPrimitiveType(PrimitiveType primitiveType, string value);
    public static bool IsHexLiteral(string value);
    public static bool IsOctalLiteral(string value);
    public static string GetTypeSuffix(object value, PrimitiveType type);
    private static string GetTypeSuffix(object value);
}
public class DevExpress.CodeParser.VB.VBProperty : Property {
    public MemberVisibility[] ValidVisibilities { get; }
    public bool VisibilityIsFixed { get; }
    public VBProperty(string Name, SourceRange range, LanguageElementCollection parameters);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual MemberVisibility[] get_ValidVisibilities();
    public virtual bool get_VisibilityIsFixed();
}
public class DevExpress.CodeParser.VB.VBPunctuators : object {
    private static Hashtable _Punctuators;
    public static ICollection TokenTypes { get; }
    private static VBPunctuators();
    public static ICollection get_TokenTypes();
    public static string GetPunctuator(int token);
}
public class DevExpress.CodeParser.VB.VBScanner : VBScannerBase {
    private static int charSetSize;
    private static int UnicodeLetterIndex;
    private static int noSym;
    private Int16[] start;
    private char valCh;
    public char CharValue { get; }
    public VBScanner(string input);
    public VBScanner(ISourceReader s);
    public VBScanner(ISourceReader reader, int line, int offset);
    protected virtual int GetUnicodeLetterIndex();
    protected virtual int GetNextState(int input);
    protected virtual void InitializeIgnoreTable();
    protected virtual void NextChCasing();
    protected virtual void AddCh();
    private void CheckLiteral();
    protected virtual void NextTokenScan(int state);
    protected virtual Token NextToken();
    public virtual char get_CharValue();
}
public abstract class DevExpress.CodeParser.VB.VBScannerBase : GeneratedScannerBase {
    private static char EOT;
    private XmlString _XmlString;
    public char CharValue { get; }
    public VBScannerBase(string input);
    public VBScannerBase(ISourceReader reader);
    public VBScannerBase(ISourceReader reader, int line, int offset);
    private void SeparateTypeCharacterFromId(string source, String& idText, String& typeCharText);
    private void SetTokenProperties(Token token, int tokenType, int startPosition, int endPosition, int line, int column, int endLine, int endColumn, string tokenText);
    private bool IdentifierContainsTypeCharacter(string tokenText);
    private int GetTokenTypeForTypeCharacter(string typeCharText);
    private Token GetTokenForIdentifierWithTypeCharacter(Token token);
    protected Token GetToken(Token token);
    private void SkipWs();
    private bool IsLineTerminator();
    protected virtual Token CreateToken();
    protected virtual void NextTokenEnd();
    protected virtual Token NextToken();
    public char GetTypeCharacter();
    public string GetXmlString(int startBufferIndex, string peekString);
    public string GetXmlString(int startBufferIndex);
    public string GetXmlImports(int startBufferIndex);
    public string GetXmlOneTag(int startBufferIndex);
    public void ResetNextChCounter();
    public void NextChar();
    public bool IsEof();
    public void SkipToEOL();
    public bool IsNextChar(char c);
    public virtual char get_CharValue();
}
public class DevExpress.CodeParser.VB.VBSnippetCodeGen : SnippetCodeGenBase {
    public VBSnippetCodeGen(CodeGen codeGen);
    protected virtual void GenerateSnippetCodeElement(SnippetCodeElement snippet);
    protected virtual void GenerateSnippetCodeMember(SnippetCodeMember snippet);
    protected virtual void GenerateSnippetCodeStatement(SnippetCodeStatement snippet);
    protected virtual void GenerateSnippetCodeStatementBlock(SnippetCodeStatementBlock snippet);
    protected virtual void GenerateSnippetExpression(SnippetExpression snippet);
}
internal class DevExpress.CodeParser.VB.VBSourceFile : SourceFile {
    public VBSourceFile(string fileName);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual int GetImageIndex();
}
public class DevExpress.CodeParser.VB.VBSpecifiersHelper : object {
    public static void ParseSpecifiers(TokenQueueBase queue, AccessSpecifiedElement element);
}
public class DevExpress.CodeParser.VB.VBStatementCodeGen : StatementCodeGenBase {
    protected VBCodeGen VBCodeGen { get; }
    public VBStatementCodeGen(CodeGen codeGen);
    private FormattingTokenType GetExitTarget(ExitStatement statement);
    private FormattingTokenType GetOptionType(OptionType type);
    private FormattingTokenType GetOptionState(OptionState state);
    private void GenerateStatementEnd(FormattingTokenType keyword);
    private void CloseTryStatementIfNeeded(Statement statement);
    private void GenerateDoCondition(Do statement);
    private void CloseIfStatementIfNeeded(Statement statement);
    private bool GenerateLastComments(List`1<Comment> lastComments);
    private void GenerateIfParentingStatement(IfElse statement, FormattingTokenType keyword);
    private void GenerateEventAccessor(EventAccessor statement, FormattingTokenType accessorName);
    private void GeneratePropertyAccessorStatement(PropertyAccessor statement, FormattingTokenType keyword);
    private List`1<Comment> GenerateWithoutLastComment(NodeList coll);
    protected void GenerateEndStatement(End statement);
    protected void GenerateCallStatement(CallStatement statement);
    protected void GenerateEraseStatement(Erase statement);
    protected void GenerateResumeStatement(Resume statement);
    protected void GenerateExitStatement(ExitStatement statement);
    protected void GenerateAddHandlerStatement(AddHandler statement);
    protected void GenerateRemoveHandlerStatement(RemoveHandler statement);
    protected void GenerateOnErrorStatement(OnError statement);
    protected void GenerateLabelStatement(Label statement);
    protected virtual void GenerateStopStatement(Stop statement);
    protected virtual void GenerateReDimStatement(ReDim statement);
    protected virtual void GenerateEventRaiseStatement(EventRaise statement);
    protected virtual void GenerateOptionStatement(OptionStatement statement);
    protected virtual bool GenerateStatement(Statement statement);
    protected virtual void GenerateMethodCallStatement(MethodCall statement);
    protected virtual void GenerateAbortStatement(Abort statement);
    protected virtual void GenerateThrowStatement(Throw statement);
    protected virtual void GenerateBreakStatement(Break statement);
    protected virtual void GenerateContinueStatement(Continue statement);
    protected virtual void GenerateStatementStatement(Statement statement);
    protected virtual void GenerateGotoStatement(Goto statement);
    protected virtual void GenerateReturnStatement(Return statement);
    protected virtual void GenerateAssignmentStatement(Assignment statement);
    protected virtual void GenerateBlockStatement(Block statement);
    protected virtual void GenerateCheckedStatement(Checked statement);
    protected virtual void GenerateUncheckedStatement(Unchecked statement);
    protected virtual void GenerateSwitchStatement(Switch statement);
    protected virtual void GenerateCaseStatement(Case statement);
    protected virtual void GenerateTryStatement(Try statement);
    protected virtual void GenerateCatchStatement(Catch statement);
    protected virtual void GenerateFinallyStatement(Finally statement);
    protected virtual void GenerateFixedStatement(Fixed statement);
    protected virtual void GenerateLockStatement(Lock statement);
    protected virtual void GenerateUsingStatement(UsingStatement statement);
    protected virtual void GenerateDoStatement(Do statement);
    protected virtual void GenerateForStatement(For statement);
    protected virtual void GenerateForEachStatement(ForEach statement);
    protected virtual void GenerateWhileStatement(While statement);
    protected virtual void GenerateIfStatement(If statement);
    protected virtual void GenerateElseIfStatement(ElseIf statement);
    protected virtual void GenerateElseStatement(Else statement);
    protected virtual void GenerateEventAddStatement(EventAdd statement);
    protected virtual void GenerateEventRemoveStatement(EventRemove statement);
    protected virtual void GeneratePropertyAccessorGetStatement(Get statement);
    protected virtual void GeneratePropertyAccessorSetStatement(Set statement);
    protected virtual void GenerateWithStatement(With statement);
    protected virtual void GenerateRaiseEventStatement(RaiseEvent statement);
    protected virtual void GenerateYieldBreakStatement(YieldBreak statement);
    protected virtual void GenerateYieldReturnStatement(YieldReturn statement);
    protected virtual void GenerateEmptyStatement(EmptyStatement statement);
    protected virtual void GenerateConstructorInitializer(ConstructorInitializer initializer);
    protected VBCodeGen get_VBCodeGen();
    public void GenerateCaseClause(CaseClause clause);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public class DevExpress.CodeParser.VB.VBSupportElementCodeGen : SupportElementCodeGenBase {
    public VBSupportElementCodeGen(CodeGen codeGen);
    private void GenerateAttributeTargetType(AttributeTargetType target);
    protected virtual void GenerateCppAttribute(CppAttributeSection element);
    protected virtual void GenerateAttribute(Attribute attr);
    protected virtual void GenerateAttribute(AttributeSection section);
    protected virtual void GenerateComment(Comment comment);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
    public virtual bool GenerateElementTail(LanguageElement element);
}
public abstract class DevExpress.CodeParser.VB.VBTokensBase : LanguageTokensBase {
    private Hashtable _Keywords;
    private Hashtable _Punctuators;
    private Hashtable _Directives;
    private Hashtable _Tokens;
    private String[] tokens;
    private Hashtable _PrimitiveToFullTypes;
    private Hashtable _FullToPrimitiveTypes;
    private static StringBuilder _Worker;
    public static char IntegerTypeCharacter;
    public static char LongTypeCharacter;
    public static char DecimalTypeCharacter;
    public static char SingleTypeCharacter;
    public static char DoubleTypeCharacter;
    public static char StringTypeCharacter;
    public static char ShortCharacter;
    public static char IntegerCharacter;
    public static char LongCharacter;
    public static char SingleCharacter;
    public static char DoubleCharacter;
    public static char DecimalCharacter;
    public Hashtable Keywords { get; }
    public Hashtable Punctuators { get; }
    public Hashtable Directives { get; }
    private static VBTokensBase();
    private void AddToken(int token, string name);
    private void AddDirective(string name, int token);
    private void PopulateTokenTable();
    private void LoadTokens(Hashtable source);
    private void LoadTokens();
    private void LoadKeyWords();
    private void LoadPunctuator(int type);
    private void LoadPunctuators();
    private void LoadDirectives();
    private void LoadTypeConversionTables();
    public Hashtable get_Keywords();
    public Hashtable get_Punctuators();
    public Hashtable get_Directives();
    public static bool IsEscapedIdentifier(string name);
    public static string RemoveIdentifierEscapes(string name);
    public int GetKeywordToken(string word);
    public string GetTokenString(int tokenType);
    public int GetDirectiveToken(string word);
    public string GetFullTypeName(string simpleName);
    public string GetSimpleTypeName(string fullName);
    public bool IsBooleanLiteral(int tokenType);
    public bool IsBooleanLiteral(string word);
    public bool IsNullLiteral(int tokenType);
    public bool IsNullLiteral(string word);
    public bool IsCastTargetToken(Token token);
    public bool IsTypeCharacter(char aCh);
    public bool IsIntegralTypeCharacter(char aCh);
    public bool IsFloatingPointTypeCharacter(char aCh);
    public bool IsLineContinuation(char ch);
    public virtual bool IsKeyword(string word);
    public virtual bool IsIdentifier(string word);
    public bool IsIdentifier(Token token);
    public virtual bool IsStandardType(string word);
    public bool IsStandardType(int tokenType);
    public bool IsOctalDigit(char ch);
    public bool IsHexDigit(char ch);
    public virtual bool IsDirective(int type);
    public bool IsPunctuator(string s);
    public virtual bool IsOperator(int type);
    public string GetPunctuator(Char[] chars, int length);
    public bool IsPunctuator(char ch);
    public bool IsPunctuator(Char[] chars);
    public virtual bool IsComment(int type);
    public virtual bool IsXmlDocComment(int type);
    public virtual bool IsNumber(int type);
    public virtual bool IsStringLiteral(int type);
    public virtual int ToTokenType(string token);
}
public class DevExpress.CodeParser.VB.VBTokensCategoryHelper : object {
    public sealed virtual TokenCategory GetUncategorizedTokenCategory(Token token);
    public sealed virtual TokenCollection GetTokens(string code);
    public sealed virtual string GetTokenCategory(Token token);
    public sealed virtual string GetTokenCategory(Token token, ParserVersion version);
}
public class DevExpress.CodeParser.VB.VBTokensHelper : object {
    private static string STR_XMLDocTag;
    public static TokenCollection GetTokens(string code);
    private static bool IsString(int type);
    private static bool IsNumber(int type);
    private static bool IsComment(int type);
    private static bool IsKeyword(int type);
    public static string GetTokenCategory(Token token);
    public static TokenCategory GetUncategorizedTokenCategory(Token token);
    public static string GetTokenCategory(Token token, ParserVersion version);
}
public class DevExpress.CodeParser.VB.VBTypeDeclarationCodeGen : TypeDeclarationCodeGenBase {
    public VBTypeDeclarationCodeGen(CodeGen codeGen);
    private void GenerateAncestorTypes(TypeDeclaration type);
    private void GenerateTypeDeclaration(TypeDeclaration type, FormattingTokenType keyword);
    private bool WriteComment(CodeElement element);
    private void GenerateTypeDeclaration(TypeDeclaration type, FormattingTokenType keyword, bool isGeneric, bool hasAncestors);
    protected virtual void GenerateModuleDeclaration(Module type);
    protected virtual void GenerateClassDeclaration(Class type);
    protected virtual void GenerateStructDeclaration(Struct type);
    protected virtual void GenerateInterfaceDeclaration(Interface type);
    protected virtual void GenerateEnumDeclaration(Enumeration type);
    protected virtual void GenerateUnionDeclaration(Union type);
    protected virtual void GenerateManagedClassDeclaration(ManagedClass type);
    protected virtual void GenerateManagedStructDeclaration(ManagedStruct type);
    protected virtual void GenerateInterfaceClassDeclaration(InterfaceClass type);
    protected virtual void GenerateInterfaceStructDeclaration(InterfaceStruct type);
    protected virtual void GenerateValueClassDeclaration(ValueClass type);
    protected virtual void GenerateValueStructDeclaration(ValueStruct type);
    public virtual FormattingElements NextFormattingElements(FormattingTokenType tokenType);
    public virtual FormattingElements PrevFormattingElements(FormattingTokenType tokenType);
}
public class DevExpress.CodeParser.VB.VBXmlCodeGen : XmlCodeGenBase {
    public VBXmlCodeGen(CodeGen codeGen);
    protected virtual void GenerateXmlPrefix();
}
public class DevExpress.CodeParser.VB.XMLDocComment : XmlDocComment {
    public virtual SourceLineCollection SplitDocComment();
    public virtual BaseElement Clone(ElementCloneOptions options);
}
public class DevExpress.CodeParser.VB.XmlString : AdaptedScannerBase {
    private static int XML_CHARS_SIZE;
    private int _XmlStack;
    private Char[] _XmlChars;
    private int _XmlCharIndex;
    private bool _FromCharTokens;
    private void PrepareXmlString(int startBufferIndex, string peekString, Token tokens);
    private bool IsPeekCharsCore(Char[] mas, int startIndex);
    private Char[] DoubleXmlChars(Char[] buf);
    private void DeleteWhitespaces();
    private bool BodyStep();
    private bool IsOneTagXmlString();
    private bool IsTag();
    private bool IsPrologTag();
    private bool IsNotSignificantChar();
    private bool IsDtdTag();
    private bool IsTagBegin();
    private bool IsTagCloseSymbol();
    private bool IsOneLineTagEnd();
    private bool IsTagEnd();
    private bool IsIdentifierStart(char chr);
    private bool IsXmlComment();
    private bool IsPeekChar(char peekChar);
    private bool IsPeekChars(Char[] mas);
    private bool PeekCharIsIdentifier();
    private void SkipToGT();
    private bool SkipEmbeddedCode();
    private void SkipCData();
    private bool SkipString();
    private void SkipToChar(char sym);
    private void SkipToEndCdata();
    private void SkipToEndXmlComment();
    private void SkipToEndEmbCode();
    private void SkipChars(int count);
    private bool SkipPrologTags();
    private void SkipXmlBody();
    private void SkipInternalComment();
    private bool Step();
    private void StepCore();
    private void WriteStep();
    private void ResetXmlSettings();
    public string GetXmlImports(int startBufferIndex, Token tokens);
    public string GetXmlElementRef(int startBufferIndex, Token tokens);
    public string GetXmlOneTag(int startBufferIndex, Token tokens);
    public string GetXmlString(int startBufferIndex, Token tokens);
    public string GetXmlString(int startBufferIndex, string peekString, Token tokens);
}
public class DevExpress.CodeParser.VBElementBuilder : ElementBuilder {
    private static string VBSTR_SystemInt32;
    public virtual Method BuildMethod(string memberType, string name);
    public virtual Event BuildEvent();
    public virtual Event BuildEvent(string name);
    public VBFor BuildFor(string iteratorVar, string toExpr, string stepExp);
    public virtual For BuildFor(string iteratorVar, Expression endCondition);
    public virtual For BuildFor(Expression endCondition);
    public For AddFor(LanguageElement parent, string iteratorVar, string toExpr, string stepExp);
    public virtual Method BuildDestructor(string className);
}
internal class DevExpress.CodeParser.VBFormattingTable : FormattingTable {
    private static FormattingTable _Instance;
    public static FormattingTable Instance { get; }
    protected virtual void FillFormattingTokenTypeCorrespondanceTable();
    public static FormattingTable get_Instance();
}
public class DevExpress.CodeParser.VisualStudioDocument : PathElement {
    private string _FileNameOnly;
    private IDocument _Document;
    private IProjectElement _Project;
    private string _Kind;
    public IDocument Document { get; }
    public IProjectElement Project { get; }
    public string Kind { get; }
    public LanguageElementType ElementType { get; }
    public bool IsNewContext { get; }
    public VisualStudioDocument(string kind, string name);
    protected void ClearFileName();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public void SetProject(IProjectElement project);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public void SetDocument(IDocument aDocument);
    [EditorBrowsableAttribute("1")]
public void AssignProject(IProjectElement project);
    public virtual void InvalidateRange(SourceRange range);
    public virtual void RangedParseComplete(SourceRange range, LanguageElement context);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual IDocument get_Document();
    public virtual IProjectElement get_Project();
    public string get_Kind();
    public virtual LanguageElementType get_ElementType();
    public virtual bool get_IsNewContext();
}
public class DevExpress.CodeParser.Volatile : Variable {
    public LanguageElementType ElementType { get; }
    public Volatile(string type, string name);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.WarningDirective : CompilerDirective {
    private string _Text;
    public string Text { get; public set; }
    public LanguageElementType ElementType { get; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public string get_Text();
    public void set_Text(string value);
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.WhereExpression : QueryExpressionBase {
    private Expression _WhereClause;
    public Expression WhereClause { get; }
    public LanguageElementType ElementType { get; }
    private IExpression DevExpress.CodeParser.IWhereExpression.WhereClause { get; }
    public WhereExpression(Expression whereClause);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public void SetWhereClause(Expression whereClause);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public Expression get_WhereClause();
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    private sealed virtual override IExpression DevExpress.CodeParser.IWhereExpression.get_WhereClause();
}
public class DevExpress.CodeParser.While : ConditionalParentToSingleStatement {
    private static int INT_MaintainanceComplexity;
    private Expression _Condition;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Condition { get; public set; }
    private IExpression DevExpress.CodeParser.IWhileStatement.Condition { get; }
    public While(Expression expression, LanguageElementCollection block);
    public While(Expression expression, LanguageElementCollection block, SourceRange range);
    protected void SetExpression(Expression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual string GetDetailNodeDescription(int index);
    [EditorBrowsableAttribute("1")]
public void SetCondition(Expression condition);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Condition();
    public void set_Condition(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IWhileStatement.get_Condition();
}
public class DevExpress.CodeParser.With : ParentingStatement {
    private static int INT_MaintainanceComplexity;
    private Expression _Expression;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IWithStatement.Expression { get; }
    public With(Expression expression, LanguageElementCollection block);
    public With(Expression expression, LanguageElementCollection block, SourceRange range);
    protected void SetExpression(Expression expression);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IWithStatement.get_Expression();
}
public class DevExpress.CodeParser.Xaml.MarkupExtensionParser : TokenCategorizedParserBase {
    public string Language { get; }
    private Expression ParseExpression(ISourceReader reader);
    private bool IsInitializer();
    protected virtual TokenCategory GetTokenCategory(CategorizedToken token);
    public virtual ExpressionParserBase CreateExpressionParser();
    public virtual string get_Language();
    protected virtual void Get();
    protected virtual void HandlePragmas();
    private void Parser();
    private void MarkupExtensionExpr(MarkupExtensionExpression& result);
    private void PartialName(Expression source, Expression& result);
    private void SimpleName(Expression& result);
    private void Name(Expression& result);
    private void Initializer(Expression& expr);
    private void Expression(Expression& expression);
    private void Indexer(Expression source, Expression& expr);
    private void Literal(Expression& result);
    private void Parse();
    protected virtual Boolean[0...,0...] CreateSetArray();
}
public class DevExpress.CodeParser.Xaml.MarkupExtensionParserErrors : ParserErrorsBase {
    protected virtual string GetSyntaxErrorText(int n);
}
public class DevExpress.CodeParser.Xaml.MarkupExtensionScanner : GeneratedScannerBase {
    private static int charSetSize;
    private static int UnicodeLetterIndex;
    private static int noSym;
    private Int16[] start;
    public MarkupExtensionScanner(ISourceReader s);
    protected virtual int GetUnicodeLetterIndex();
    protected virtual int GetNextState(int input);
    protected virtual void InitializeIgnoreTable();
    protected virtual void NextChCasing();
    protected virtual void AddCh();
    private void CheckLiteral();
    protected virtual void NextTokenComments();
    protected virtual void NextTokenScan(int state);
}
public class DevExpress.CodeParser.Xaml.Tokens : object {
    public static int EOF;
    public static int EQUALSTOKEN;
    public static int STRINGLITERAL;
    public static int CLOSEBRACE;
    public static int CLOSEBRACKET;
    public static int OPENBRACE;
    public static int PATH;
    public static int OPENBRACKET;
    public static int COMMA;
    public static int COLON;
    public static int IDENTIFIER;
    public static int INTEGERLITERAL;
    public static int DOT;
    public static int MaxTokens;
    public static Int32[] Keywords;
    private static Tokens();
}
public class DevExpress.CodeParser.Xml.HtmlCodeGen : object {
}
public class DevExpress.CodeParser.Xml.HtmlXmlCodeGen : CodeGen {
    public HtmlXmlCodeGen(CodeGenOptions options);
    protected virtual HtmlXmlCodeGenBase CreateHtmlXmlGen();
    protected virtual TemplateParameterCodeGenBase CreateTemplateParameterGen();
    protected virtual TemplateCodeGenBase CreateTemplateGen();
    protected virtual DirectiveCodeGenBase CreateDirectiveGen();
    protected virtual ExpressionCodeGenBase CreateExpressionGen();
    protected virtual MemberCodeGenBase CreateMemberGen();
    protected virtual StatementCodeGenBase CreateStatementGen();
    protected virtual SupportElementCodeGenBase CreateSupportElementGen();
    protected virtual TypeDeclarationCodeGenBase CreateTypeDeclarationGen();
    protected virtual XmlCodeGenBase CreateXmlGen();
    protected virtual NamespaceReferenceGenBase CreateNamespaceReferenceGen();
    protected virtual NamespaceGenBase CreateNamespaceGen();
    protected virtual SnippetCodeGenBase CreateSnippetGen();
    public virtual void GenerateElement(LanguageElement element);
    private void GenerateNodes(ICollection nodes);
    private void GenerateXmlElementList(ElementList list);
    public virtual void GenerateMemberVisibilitySpecifier(MemberVisibilitySpecifier specifier);
}
public class DevExpress.CodeParser.Xml.HtmlXmlNodesCodeGen : HtmlXmlCodeGenBase {
    public HtmlXmlNodesCodeGen(CodeGen codeGen);
    public virtual void GenerateElement(LanguageElement languageElement);
    protected virtual bool GenerateHtmlXmlNode(XmlNode xmlNode);
    public void GenerateHtmlXmlComment(Comment comment);
    public void GenerateRazorModelDirective(RazorModelDirective modelDirective);
    private void GenerateRazorSection(RazorSection razorSection);
    protected bool GenerateCssNode(BaseCssElement element);
    public void GenerateCssStyleSheet(CssStyleSheet element);
    public void GenerateCssStyleRule(CssStyleRule element);
    public void GenerateCssPropertyDeclaration(CssPropertyDeclaration element);
    public void GenerateCssSelector(CssSelector element);
    private void WriteCssSelector(CssSelector element);
    private void GenerateSelectorType(CssSelectorType type, string name, bool isFirst);
    private string AddString(string str, string addStr);
    public void GenerateCssAttributeSelector(CssAttributeSelector element);
    private void WriteCssAttributeSelector(CssAttributeSelector element);
    private void GenerateCssAttrValue(CssAttributeSelector element);
    public void GenerateCssPseudoSelector(CssPseudoSelector element);
    private void WriteCssPseudoSelector(CssPseudoSelector element);
    public void GenerateCssPseudoFunctionSelector(CssPseudoFunctionSelector element);
    private void WriteCssPseudoFunctionSelector(CssPseudoFunctionSelector element);
    public void GenerateCssIdentifierReference(CssIdentifierReference element);
    public void GenerateCssFunctionReference(CssFunctionReference element);
    private void GenerateCssTermCollection(CssTermCollection coll);
    public void GenerateCssStringLiteral(CssStringLiteral element);
    public void GenerateCssURIReference(CssURIReference element);
    public void GenerateCssColorReference(CssColorReference element);
    public void GenerateCssNumberLiteral(CssNumberLiteral element);
    private void GenerateTermElement(CssTerm element);
    private void GenerateCssMeasuredNumber(CssMeasuredNumber element);
    private void GenerateNumberLiteralBase(CssNumberLiteral element);
    private void GenerateNumberLiteralBase(CssNumberLiteral element, bool addNewLine);
    private void GenerateCssMeasuredNumber(CssMeasuredNumber element, bool addNewLine);
    private void GenerateTermElement(CssTerm element, bool addNewLine);
    private void GenerateCssValue(object element);
    private void GenerateCssMeasureUnit(CssMeasureUnit unit);
    private void GeneratePrecedingSign(PrecedingSign sign);
    public void GenerateCssLengthLiteral(CssLengthLiteral element);
    public void GenerateCssPercentLiteral(CssPercentLiteral element);
    public void GenerateCssTimeLiteral(CssTimeLiteral element);
    public void GenerateCssAngleLiteral(CssAngleLiteral element);
    public void GenerateCssFrequencyLiteral(CssFrequencyLiteral element);
    private void GenerateTermDelimiter(CssTerm element);
    private void WriteTermDelimiter(ExpressionDelimiter element);
    public void GenerateCssCharsetDeclaration(CssCharsetDeclaration element);
    public void GenerateCssImportDirective(CssImportDirective element);
    public void GenerateCssMediaDirective(CssMediaDirective element);
    public void GenerateCssCommentTag(CssCommentTag element);
    public void GenerateCssPageStyle(CssPageStyle element);
    private bool GenerateHtmlNodes(XmlNode xmlNode);
    private bool GenerateXmlNodes(XmlNode xmlNode);
    private bool GenerateBaseXmlNodes(BaseXmlNode xmlNode);
    public void GenerateHtmlAttribute(HtmlAttribute atr);
    public string GenerateMarkupExtensionExpression(MarkupExtensionExpression expression);
    private string GetAttributeDelimiters(HtmlAttribute atr);
    private bool ShouldAddNewLine(HtmlElement element);
    public void GenerateHtmlElement(HtmlElement element);
    private bool IncreaseIndent(HtmlElement element);
    private void GenerateElementBeg(HtmlElement element, bool addNewLine);
    private void GenerateElementBeg(HtmlElement element);
    private void GenerateElementBeg(HtmlElement element, string openSign, string closeSign, bool addNewLine);
    private void GenerateElementBeg(HtmlElement element, string openSign, string closeSign, bool addNewLine, string elementName);
    private string GetHtmlElementName(HtmlElement element);
    private void GenerateElementEnd(HtmlElement element);
    private void GenerateElementEnd(HtmlElement element, string elementName);
    private void GenerateElementEnd(HtmlElement element, string openSign, string closeSign);
    private void GenerateElementEnd(HtmlElement element, string openSign, string closeSign, string elementName);
    private void GenerateHtmlAttributesList(NodeList attributes);
    private void GenerateNodesList(NodeList elements, bool isIncreaseIndent);
    public void GenerateHtmlScript(HtmlScriptDefinition script);
    private void GenerateNodesFromOtherLanguages(CodeGen codeGen, NodeList nodes);
    private string GetScriptLanguage(DotNetLanguageType languageType);
    private bool IsUnknowLanguage(HtmlScriptDefinition element);
    private DotNetLanguageType GetLanguageType(HtmlScriptDefinition element);
    private CodeGen GetCodeGenerator(string languageName);
    private CodeGen GetScriptCodeGen(DotNetLanguageType languageType);
    public void GenerateHtmlStyle(HtmlStyleDefinition style);
    public void GenerateRegisterDirective(RegisterDirective element);
    public void GeneratePageDirective(PageDirective element);
    public void GenerateServerControlElement(ServerControlElement element);
    public void GenerateHtmlText(HtmlText text);
    public void GenerateAspCodeEmbedding(AspCodeEmbedding code);
    public void GenerateAspDirective(AspDirective directive);
    public void GenerateXmlAnyContentSpec(XmlAnyContentSpec spec);
    public void GenerateXmlAttributeDecl(XmlAttributeDeclaration decl);
    private void GenerateDefaultAttributeValueType(XmlAttributeDeclaration decl);
    private void WriteAttribute(XmlAttributeDeclaration decl);
    private void GenerateAttlistEnumeration(XmlAttributeDeclaration decl);
    private void GenerateStringCollection(StringCollection coll, string delimiter);
    public void GenerateXmlAttributeListDecl(XmlAttributeListDeclaration decl);
    public void GenerateXmlCharacterData(XmlCharacterData data);
    public void GenerateXmlCharReference(XmlCharReference data);
    public void GenerateXmlChildrenContentSpec(XmlChildrenContentSpec spec);
    public void GenerateXmlCPChoice(XmlChoiceContentParticle part);
    public void GenerateXmlCPSequence(XmlSequenceContentParticle part);
    private void GenerateRepeatCount(XmlContentParticle content);
    public void GenerateXmlDecl(XmlDecl decl);
    private void WriteXmlString(string name, string str);
    private void WriteString(string str);
    public void GenerateXmlDocTypeDecl(XmlDocTypeDecl decl);
    public void GenerateXmlElementDecl(XmlElementDecl decl);
    private void GenerateDescendantList(NodeList list, string delimiter, bool writeFirstDelimiter);
    private void GenerateDescendantList(NodeList list, string delimiter, bool writeFirstDelimiter, bool writeDelimiterAfterElements);
    private void GenerateDescendantList(NodeList list, string delimiter, bool writeFirstDelimiter, bool writeDelimiterAfterElements, bool writeLastDelimiter);
    private void GenerateDescendantList(NodeList list, string delimiter, bool writeFirstDelimiter, bool writeDelimiterAfterElements, bool writeLastDelimiter, bool addNewLine);
    private void GenerateDescendantList(NodeList list, string delimiter);
    private void GenerateDescendantList(NodeList list);
    private void GenerateDescendantList(NodeList list, bool writeFirstDelimiter);
    public void GenerateXmlEmptyContentSpec(XmlEmptyContentSpec spec);
    public void GenerateXmlEntityDecl(XmlEntityDecl decl);
    public void GenerateXmlExternalPublicID(NewExternalIDPublicLink link);
    public void GenerateXmlExternalSystemID(NewExternalIDSystemLink link);
    public void GenerateXmlMixedContentSpec(XmlMixedContentSpec spec);
    public void GenerateXmlName(XmlName name);
    public void GenerateXmlNamedCP(XmlNamedContentParticle part);
    public void GenerateXmlNameReference(XmlNameReference reference);
    public void GenerateXmlNotationDecl(XmlNotationDecl decl);
    public void GenerateXmlProcessingInstruction(XmlProcessingInstruction instr);
    public void GenerateXmlReference(XmlReference reference);
}
public class DevExpress.CodeParser.Xml.HtmlXmlSnippetCodeGen : SnippetCodeGenBase {
    public HtmlXmlSnippetCodeGen(CodeGen gen);
    protected virtual bool GenerateSnippet(LanguageElement snippet);
    protected virtual void GenerateSnippetCodeElement(SnippetCodeElement snippet);
    protected virtual void GenerateSnippetCodeMember(SnippetCodeMember snippet);
    protected virtual void GenerateSnippetCodeStatement(SnippetCodeStatement snippet);
    protected virtual void GenerateSnippetCodeStatementBlock(SnippetCodeStatementBlock snippet);
    protected virtual void GenerateSnippetExpression(SnippetExpression snippet);
}
public class DevExpress.CodeParser.Xml.NewXmlParser : XmlParserBase {
    protected virtual void HandlePragmas();
    private void Parser();
    private void Text(bool useTrim);
    private void Prolog();
    private void Element();
    private void Misc();
    private void XMLDecl();
    private void DocTypeDecl();
    private void VersionInfo(XmlDecl xmlDecl);
    private void EncodingDecl(XmlDecl xmlDecl);
    private void SDDecl(XmlDecl xmlDecl);
    private void Name();
    private void ExternalID(NewExternalIDLink& extID);
    private void IntSubset(XmlDocTypeDecl docTypeDecl);
    private void MarkupDecl(XmlDocTypeDecl docTypeDecl);
    private void DeclSep();
    private void ElementDecl(XmlElementDecl& elementDecl);
    private void AttlistDecl(XmlAttributeListDeclaration& result);
    private void EntityDecl(XmlEntityDecl& entityDecl);
    private void NotationDecl(XmlNotationDecl& notationDecl);
    private void PI(XmlProcessingInstruction& processingInstruction, bool checkForText);
    private void Comment();
    private void PEReference(XmlNameReference& nameRef);
    private void ContentSpec(XmlBaseContentSpec& contentSpec);
    private void Mixed(XmlMixedContentSpec& contentSpec);
    private void Children(XmlChildrenContentSpec& children);
    private void CpSequence(XmlContentParticle& choiceCP);
    private void Cp(XmlContentParticle& contentParticle);
    private void AttDef(XmlAttributeDeclaration& attrDecl);
    private void AttType(XmlAttributeDeclaration attrDecl);
    private void DefaultDecl(XmlAttributeDeclaration attrDecl);
    private void TokenizedType(XmlAttributeDeclaration attrDecl);
    private void Enumeration(XmlAttributeDeclaration attrDecl);
    private void EntityDef(XmlEntityDecl entityDecl);
    private void CDSect();
    private void Attribute(XmlAttribute& attribute);
    private void Content();
    private void Reference();
    private void Parse();
    protected virtual LanguageElement Parse(string code, int startLine, int startColumn);
    protected virtual LanguageElement DoParse(ParserContext parserContext, ISourceReader reader);
    public LanguageElement Parse(ISourceReader reader);
    protected virtual Boolean[0...,0...] CreateSetArray();
}
public class DevExpress.CodeParser.Xml.Tokens : object {
    public static int IDREF;
    public static int EOF;
    public static int PLUS;
    public static int NMTOKENS;
    public static int AMPERSAND;
    public static int XMLTAGOPEN;
    public static int ELEMENTDECL;
    public static int IDREFS;
    public static int NMTOKEN;
    public static int DOCTYPE;
    public static int CDATA;
    public static int COMMENT;
    public static int ENTITYDECL;
    public static int IMPLIED;
    public static int CDATASTART;
    public static int PICHARS;
    public static int PARENOPEN;
    public static int TAGCLOSESTART;
    public static int BITWISEOR;
    public static int CDATATOKEN;
    public static int ENCODING;
    public static int SINGLEQUOTE;
    public static int PARENCLOSE;
    public static int ENTITY;
    public static int ANYCONTENT;
    public static int SYSTEM;
    public static int EMPTYTAGCLOSE;
    public static int CDATAEND;
    public static int EQUALSTOKEN;
    public static int PCDATA;
    public static int COMMA;
    public static int PERCENTSYMBOL;
    public static int EMPTY;
    public static int TAGCLOSE;
    public static int SEMICOLON;
    public static int NOTATIONDECl;
    public static int ATTLISTDECL;
    public static int QUESTTAGOPEN;
    public static int PUBLIC;
    public static int NOTATION;
    public static int QUESTTAGCLOSE;
    public static int BRACKETCLOSE;
    public static int QUESTION;
    public static int STAR;
    public static int FIXED;
    public static int STANDALONE;
    public static int BRACKETOPEN;
    public static int ENTITIES;
    public static int REQUIRED;
    public static int NDATA;
    public static int VERSION;
    public static int TAGOPEN;
    public static int IDTOKEN;
    public static int CHARREF;
    public static int NAME;
    public static int MaxTokens;
    public static Int32[] Keywords;
    private static Tokens();
}
public class DevExpress.CodeParser.Xml.TokenType : TokenType {
    public static int Text;
}
public abstract class DevExpress.CodeParser.Xml.XmlLanguageParserBase : EmbeddedCodeParserBase {
    public string Language { get; }
    public virtual string get_Language();
}
internal class DevExpress.CodeParser.Xml.XmlLanguageUtils : LanguageUtils {
    public virtual Tokenizer CreateTokenizer();
    public virtual ParserBase CreateParser(ParserVersion version, EmbededLanguageKind languageKind, DotNetLanguageType embededLanguage);
    public virtual CodeGen CreateCodeGen();
    public virtual ElementBuilder CreateElementBuilder();
}
public abstract class DevExpress.CodeParser.Xml.XmlParserBase : XmlLanguageParserBase {
    protected XmlScanner XmlScanner { get; }
    private XmlNode GetXmlNode(LanguageElement root);
    private void FillArrayListWithNodes(ArrayList list, LanguageElement root);
    private string GetTextFromSourceLinesReader(SourceLinesReader linesReader);
    protected virtual TokenCategory GetTokenCategory(CategorizedToken token);
    protected abstract virtual LanguageElement Parse(string code, int startLine, int startColumn);
    public sealed virtual XmlNode ParseXmlDocNode(ISourceReader reader);
    public sealed virtual XmlNode ParseXmlDocNode(string xmlDoc);
    public sealed virtual ArrayList ParseXmlDocNodes(ISourceReader reader);
    public sealed virtual ArrayList ParseXmlDocNodes(string xmlDoc);
    protected XmlScanner get_XmlScanner();
}
public class DevExpress.CodeParser.Xml.XmlParserErrors : ParserErrorsBase {
    protected virtual string GetSyntaxErrorText(int n);
}
public class DevExpress.CodeParser.Xml.XmlScanner : XmlScannerBase {
    private static int charSetSize;
    private static int UnicodeLetterIndex;
    private static int noSym;
    private Int16[] start;
    public XmlScanner(ISourceReader s);
    protected virtual int GetUnicodeLetterIndex();
    protected virtual int GetNextState(int input);
    protected virtual void InitializeIgnoreTable();
    protected virtual void NextChCasing();
    protected virtual void AddCh();
    private void CheckLiteral();
    protected virtual void NextTokenComments();
    protected virtual void NextTokenScan(int state);
}
public abstract class DevExpress.CodeParser.Xml.XmlScannerBase : GeneratedScannerBase {
    private bool _ShouldReturnCharDataToken;
    private bool _ShouldReturnPIChars;
    private bool _ShouldCheckForXmlText;
    private bool _IsRazor;
    protected bool IsRazor { get; protected set; }
    protected int CDataTokenType { get; }
    protected int PICharsTokenType { get; }
    public bool ShouldReturnPIChars { get; public set; }
    public bool ShouldCheckForXmlText { get; public set; }
    public bool ShouldReturnCharDataToken { get; public set; }
    protected bool get_IsRazor();
    protected void set_IsRazor(bool value);
    protected bool IsRazorEmbeddingStartChar(char ch);
    protected virtual Token CreateToken();
    protected char PeekForSignificantChar();
    protected virtual bool NextTokenStart();
    protected bool IsElementName(string name);
    protected Token GetCharDataToken();
    protected Token GetPICharToken();
    protected Token GetXmlTextToken();
    protected bool IsReference(char currentChar);
    protected virtual int get_CDataTokenType();
    protected virtual int get_PICharsTokenType();
    public bool get_ShouldReturnPIChars();
    public void set_ShouldReturnPIChars(bool value);
    public bool get_ShouldCheckForXmlText();
    public void set_ShouldCheckForXmlText(bool value);
    public bool get_ShouldReturnCharDataToken();
    public void set_ShouldReturnCharDataToken(bool value);
}
public class DevExpress.CodeParser.XmlAnyContentSpec : XmlBaseContentSpec {
    public XmlNodeType XmlNodeType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlAttribute : XmlNode {
    private string _Value;
    private TextRange _NameRange;
    private TextRange _ValueRange;
    public string Value { get; public set; }
    public SourceRange ValueRange { get; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; }
    private string DevExpress.CodeParser.IXmlAttribute.Value { get; }
    private TextRange DevExpress.CodeParser.IXmlAttribute.ValueRange { get; }
    public XmlAttribute(string name);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    protected virtual void UpdateRanges();
    public virtual string ToString();
    public virtual int GetImageIndex();
    [EditorBrowsableAttribute("1")]
public void SetValue(string newValue);
    [EditorBrowsableAttribute("1")]
public void SetNameRange(SourceRange range);
    [EditorBrowsableAttribute("1")]
public void SetValueRange(SourceRange newRange);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual SourceRange get_ValueRange();
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
    private sealed virtual override string DevExpress.CodeParser.IXmlAttribute.get_Value();
    private sealed virtual override TextRange DevExpress.CodeParser.IXmlAttribute.get_ValueRange();
}
public class DevExpress.CodeParser.XmlAttributeDeclaration : BaseXmlNode {
    private AttributeType _AttributeType;
    private StringCollection _EnumerationMembers;
    private DefaultAttributeValueType _DefaultAttributeValueType;
    private string _DefaultAttributeValue;
    public XmlNodeType XmlNodeType { get; }
    public AttributeType AttributeType { get; public set; }
    public StringCollection EnumerationMembers { get; }
    public int EnumerationMembersCount { get; }
    public DefaultAttributeValueType DefaultAttributeValueType { get; public set; }
    public string DefaultAttributeValue { get; public set; }
    public virtual XmlNodeType get_XmlNodeType();
    public AttributeType get_AttributeType();
    public void set_AttributeType(AttributeType value);
    public StringCollection get_EnumerationMembers();
    public int get_EnumerationMembersCount();
    public DefaultAttributeValueType get_DefaultAttributeValueType();
    public void set_DefaultAttributeValueType(DefaultAttributeValueType value);
    public string get_DefaultAttributeValue();
    public void set_DefaultAttributeValue(string value);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlAttributeListDeclaration : BaseXmlNode {
    private LanguageElementCollection _AttributesDecl;
    public XmlNodeType XmlNodeType { get; }
    public LanguageElementCollection AttributesDecl { get; }
    public int AttributesDeclCount { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public LanguageElementCollection get_AttributesDecl();
    public int get_AttributesDeclCount();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlAttributeReferenceExpression : QualifiedElementReference {
    public LanguageElementType ElementType { get; }
    public XmlAttributeReferenceExpression(Expression source, string name, SourceRange nameRange);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
}
public abstract class DevExpress.CodeParser.XmlBaseContentSpec : BaseXmlNode {
}
public class DevExpress.CodeParser.XmlCharacterData : BaseXmlNode {
    public XmlNodeType XmlNodeType { get; }
    public LanguageElementType ElementType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlCharReference : BaseXmlNode {
    public XmlNodeType XmlNodeType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlChildrenContentSpec : XmlBaseContentSpec {
    private XmlContentParticle _Source;
    public XmlNodeType XmlNodeType { get; }
    public XmlContentParticle Source { get; public set; }
    public virtual XmlNodeType get_XmlNodeType();
    public XmlContentParticle get_Source();
    public void set_Source(XmlContentParticle value);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlChoiceContentParticle : XmlSequencedContentParticle {
    public XmlNodeType XmlNodeType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public abstract class DevExpress.CodeParser.XmlCodeGenBase : LanguageElementCodeGenBase {
    private XmlNode _LastGeneratedNode;
    public XmlCodeGenBase(CodeGen codeGen);
    private void GenerateReference(XmlReference xmlReference);
    private void GenerateBaseXmlNode(BaseXmlNode baseXmlNode);
    protected void GenerateQuote();
    protected abstract virtual void GenerateXmlPrefix();
    protected virtual void GenerateXmlDocComment(XmlDocComment xmlComment);
    protected virtual void StartXmlCommentLine(XmlDocComment xmlComment);
    protected virtual void GenerateEmptyComment(XmlDocComment xmlComment);
    protected virtual void GenerateXmlNodes(NodeList xmlNodes);
    protected virtual void GenerateXmlNode(XmlNode xmlNode);
    protected virtual void GenerateXmlDocElement(XmlElement xmlDocElement);
    protected virtual void GenerateXmlDocText(XmlText xmlDocText);
    protected virtual void GenerateXmlElementOpenTag(XmlElement xmlDocElement);
    protected virtual void GenerateXmlElementCloseTag(XmlElement xmlDocElement);
    protected virtual void GenerateXmlAttributesList(NodeList xmlAttributes);
    protected virtual void GenerateXmlAttribute(XmlAttribute xmlAttribute);
    internal virtual bool IsXmlGenElement(LanguageElement element);
    public virtual void GenerateElement(LanguageElement element);
}
public abstract class DevExpress.CodeParser.XmlContentParticle : BaseXmlNode {
    private RepeatCount _RepeatCount;
    public RepeatCount RepeatCount { get; public set; }
    public RepeatCount get_RepeatCount();
    public void set_RepeatCount(RepeatCount value);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlDecl : BaseXmlNode {
    private string _Version;
    private string _Encoding;
    private string _StandAlone;
    public XmlNodeType XmlNodeType { get; }
    public string Version { get; public set; }
    public string Encoding { get; public set; }
    public string StandAlone { get; public set; }
    public virtual XmlNodeType get_XmlNodeType();
    public string get_Version();
    public void set_Version(string value);
    public string get_Encoding();
    public void set_Encoding(string value);
    public string get_StandAlone();
    public void set_StandAlone(string value);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlDocComment : Comment {
    public LanguageElementType ElementType { get; }
    public bool MultiLine { get; public set; }
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual SourceLineCollection SplitDocComment();
    public virtual BaseElement Clone(ElementCloneOptions options);
    private void ParseXmlDocComment();
    public virtual XmlDocComment ParseXmlNodes();
    public virtual LanguageElementType get_ElementType();
    public bool get_MultiLine();
    public void set_MultiLine(bool value);
}
public class DevExpress.CodeParser.XmlDocTypeDecl : BaseXmlNode {
    public XmlNodeType XmlNodeType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlElement : XmlNode {
    private XmlElementType _XmlElementType;
    private TextRangeWrapper _BlockStart;
    private TextRangeWrapper _BlockEnd;
    private bool _HasCloseTag;
    public bool HasCloseTag { get; public set; }
    public NodeList XmlAttributes { get; }
    public bool HasAttributes { get; }
    public XmlElementType XmlElementType { get; }
    public LanguageElementType ElementType { get; }
    public DelimiterBlockType BlockType { get; }
    [CategoryAttribute("Block Delimiters")]
public bool HasDelimitedBlock { get; }
    [CategoryAttribute("Block Delimiters")]
public SourceRange BlockStart { get; }
    [CategoryAttribute("Block Delimiters")]
public SourceRange BlockEnd { get; }
    public XmlElement(string name);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public XmlAttribute GetAttribute(string attributeName);
    public XmlAttribute GetAttribute(string attributeName, bool ignoreCase);
    public string GetValue(string attributeName);
    public virtual BaseElement Clone(ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetBlockStart(SourceRange range);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetBlockEnd(SourceRange range);
    public bool get_HasCloseTag();
    public void set_HasCloseTag(bool value);
    public NodeList get_XmlAttributes();
    public bool get_HasAttributes();
    public XmlElementType get_XmlElementType();
    public virtual LanguageElementType get_ElementType();
    public sealed virtual DelimiterBlockType get_BlockType();
    public virtual bool get_HasDelimitedBlock();
    public sealed virtual SourceRange get_BlockStart();
    public sealed virtual SourceRange get_BlockEnd();
}
public class DevExpress.CodeParser.XmlElementDecl : BaseXmlNode {
    public XmlNodeType XmlNodeType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlElementReferenceExpression : QualifiedElementReference {
    private XmlReferenceType _XmlReferenceType;
    public LanguageElementType ElementType { get; }
    public XmlReferenceType XmlReferenceType { get; public set; }
    public XmlElementReferenceExpression(Expression source, string name, SourceRange nameRange);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElementType get_ElementType();
    public void set_XmlReferenceType(XmlReferenceType value);
    public XmlReferenceType get_XmlReferenceType();
}
public enum DevExpress.CodeParser.XmlElementType : Enum {
    public byte value__;
    [EditorBrowsableAttribute("1")]
public static XmlElementType NotSet;
    public static XmlElementType Unknown;
    public static XmlElementType Summary;
    public static XmlElementType Param;
    public static XmlElementType SeeAlso;
    public static XmlElementType Returns;
    public static XmlElementType FormattedSingleLineCode;
    public static XmlElementType FormattedMultiLineCode;
    public static XmlElementType List;
    public static XmlElementType Item;
    public static XmlElementType Paragraph;
    public static XmlElementType ParamRef;
    public static XmlElementType Description;
    public static XmlElementType Include;
    public static XmlElementType Example;
    public static XmlElementType Exception;
    public static XmlElementType Permission;
    public static XmlElementType Value;
    public static XmlElementType Remarks;
}
public class DevExpress.CodeParser.XmlEmptyContentSpec : XmlBaseContentSpec {
    public XmlNodeType XmlNodeType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlEntityDecl : BaseXmlNode {
    private bool _IsParameterEntity;
    private string _ImmediateValue;
    private NewExternalIDLink _ExternalLinkValue;
    private string _NDataValue;
    public XmlNodeType XmlNodeType { get; }
    public bool IsParameterEntity { get; public set; }
    public string ImmediateValue { get; public set; }
    public NewExternalIDLink ExternalLinkValue { get; public set; }
    public string NDataValue { get; public set; }
    public virtual XmlNodeType get_XmlNodeType();
    public bool get_IsParameterEntity();
    public void set_IsParameterEntity(bool value);
    public string get_ImmediateValue();
    public void set_ImmediateValue(string value);
    public NewExternalIDLink get_ExternalLinkValue();
    public void set_ExternalLinkValue(NewExternalIDLink value);
    public string get_NDataValue();
    public void set_NDataValue(string value);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlExpression : Expression {
    public LanguageElementType ElementType { get; }
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.XmlMixedContentSpec : XmlBaseContentSpec {
    private LanguageElementCollection _Names;
    public XmlNodeType XmlNodeType { get; }
    public LanguageElementCollection Names { get; }
    public int NamesCount { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public LanguageElementCollection get_Names();
    public int get_NamesCount();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlName : BaseXmlNode {
    public XmlNodeType XmlNodeType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlNamedContentParticle : XmlContentParticle {
    private XmlName _ParticleName;
    public XmlNodeType XmlNodeType { get; }
    public XmlName ParticleName { get; public set; }
    public virtual XmlNodeType get_XmlNodeType();
    public XmlName get_ParticleName();
    public void set_ParticleName(XmlName value);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlNameReference : XmlName {
    public XmlNodeType XmlNodeType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlNamespaceReference : NamespaceReference {
    private string _NamespaceName;
    public LanguageElementType ElementType { get; }
    public string NamespaceName { get; public set; }
    public XmlNamespaceReference(string prefixName);
    public XmlNamespaceReference(string prefixName, string namespaceName);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual LanguageElementType get_ElementType();
    public string get_NamespaceName();
    public void set_NamespaceName(string value);
}
public abstract class DevExpress.CodeParser.XmlNode : LanguageElement {
    public LanguageElementType ElementType { get; }
    public virtual IElement Resolve(ISourceTreeResolver resolver);
    public virtual LanguageElementType get_ElementType();
}
public enum DevExpress.CodeParser.XmlNodeType : Enum {
    public int value__;
    public static XmlNodeType Default;
    public static XmlNodeType Document;
    public static XmlNodeType Decl;
    public static XmlNodeType DocTypeDecl;
    public static XmlNodeType ExternalSystemID;
    public static XmlNodeType ExternalPublicID;
    public static XmlNodeType ElementDecl;
    public static XmlNodeType EmptyContentSpec;
    public static XmlNodeType AnyContentSpec;
    public static XmlNodeType MixedContentSpec;
    public static XmlNodeType ChildrenContentSpec;
    public static XmlNodeType Name;
    public static XmlNodeType NameReference;
    public static XmlNodeType NamedCP;
    public static XmlNodeType CPSequence;
    public static XmlNodeType CPChoice;
    public static XmlNodeType NotationDecl;
    public static XmlNodeType AttributeListDecl;
    public static XmlNodeType AttributeDecl;
    public static XmlNodeType EntityDecl;
    public static XmlNodeType ProcessingInstruction;
    public static XmlNodeType CharReference;
    public static XmlNodeType Reference;
    public static XmlNodeType CharacterData;
}
public class DevExpress.CodeParser.XmlNotationDecl : BaseXmlNode {
    private NewExternalIDLink _NotationLink;
    public XmlNodeType XmlNodeType { get; }
    public NewExternalIDLink NotationLink { get; public set; }
    public virtual XmlNodeType get_XmlNodeType();
    public NewExternalIDLink get_NotationLink();
    public void set_NotationLink(NewExternalIDLink value);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlProcessingInstruction : BaseXmlNode {
    private string _InstructionText;
    public XmlNodeType XmlNodeType { get; }
    public string InstructionText { get; public set; }
    public virtual XmlNodeType get_XmlNodeType();
    public string get_InstructionText();
    public void set_InstructionText(string value);
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public class DevExpress.CodeParser.XmlReference : BaseXmlNode {
    public XmlNodeType XmlNodeType { get; }
    public LanguageElementType ElementType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual LanguageElementType get_ElementType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public enum DevExpress.CodeParser.XmlReferenceType : Enum {
    public int value__;
    public static XmlReferenceType Default;
    public static XmlReferenceType TripleDot;
}
public class DevExpress.CodeParser.XmlSequenceContentParticle : XmlSequencedContentParticle {
    public XmlNodeType XmlNodeType { get; }
    public virtual XmlNodeType get_XmlNodeType();
    public virtual BaseElement Clone(ElementCloneOptions options);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
public abstract class DevExpress.CodeParser.XmlSequencedContentParticle : XmlContentParticle {
    private LanguageElementCollection _Particles;
    public LanguageElementCollection Particles { get; }
    public int ParticlesCount { get; }
    public LanguageElementCollection get_Particles();
    public int get_ParticlesCount();
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
}
[EditorBrowsableAttribute("1")]
public class DevExpress.CodeParser.XmlSignatureBuilder : object {
    private static string STR_OpenTag;
    private static string STR_CloseTag;
    private static string STR_Comma;
    private static string STR_Space;
    private static string STR_Equal;
    private static void AppendArtibutes(StringBuilder builder, HtmlAttributeCollection attributes);
    private static string GetXmlNodeSignature(BaseXmlNode element);
    private static string GetHtmlElementSignature(HtmlElement element);
    private static string GetXmlAttributeSignature(XmlAttribute element);
    private static string GetXmlTextSignature(XmlText element);
    private static string DefaultXmlSignature(XmlNode element);
    public static string GetSignature(XmlNode element);
    public static string GetSignature(BaseCssElement element);
}
public class DevExpress.CodeParser.XmlText : XmlNode {
    public string Text { get; public set; }
    public LanguageElementType ElementType { get; }
    public SourceRange NameRange { get; }
    public XmlText(string text);
    public virtual int GetImageIndex();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public string get_Text();
    public void set_Text(string value);
    public virtual LanguageElementType get_ElementType();
    public virtual SourceRange get_NameRange();
}
public abstract class DevExpress.CodeParser.Yield : FlowBreak {
    private static int INT_MaintainanceComplexity;
    protected int ThisMaintenanceComplexity { get; }
    protected virtual int get_ThisMaintenanceComplexity();
}
public class DevExpress.CodeParser.YieldBreak : Yield {
    public LanguageElementType ElementType { get; }
    public YieldBreak(SourceRange range);
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElement FindTarget();
    public virtual LanguageElementType get_ElementType();
}
public class DevExpress.CodeParser.YieldReturn : Yield {
    private static int INT_MaintainanceComplexity;
    private Expression _Expression;
    protected int ThisMaintenanceComplexity { get; }
    public LanguageElementType ElementType { get; }
    public Expression Expression { get; public set; }
    private IExpression DevExpress.CodeParser.IYieldReturnStatement.Expression { get; }
    public YieldReturn(SourceRange range);
    protected virtual void SetEpxression(Expression expression);
    protected virtual void ReplaceOwnedReference(LanguageElement oldElement, LanguageElement newElement);
    protected virtual void CloneDataFrom(BaseElement source, ElementCloneOptions options);
    [EditorBrowsableAttribute("1")]
public virtual void CleanUpOwnedReferences();
    public virtual int GetImageIndex();
    public virtual string ToString();
    public virtual BaseElement Clone(ElementCloneOptions options);
    public virtual LanguageElement FindTarget();
    protected virtual int get_ThisMaintenanceComplexity();
    public virtual LanguageElementType get_ElementType();
    public Expression get_Expression();
    public void set_Expression(Expression value);
    private sealed virtual override IExpression DevExpress.CodeParser.IYieldReturnStatement.get_Expression();
}
