public abstract class DevExpress.Pdf.Drawing.Common.RenderFontStorage`1 : object {
    private IDictionary`2<PdfFont, TRenderFont> storage;
    public TRenderFont GetRenderFont(PdfFont font);
    public virtual void RemoveRenderFont(PdfFont font);
    private TRenderFont CreateRenderFont(PdfFont font);
    protected virtual void Dispose(bool disposing);
    private void DisposeItem(TRenderFont item);
    public virtual void Clear();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected abstract virtual TRenderFont SubstituteRenderFont(PdfFont font);
    protected abstract virtual TRenderFont CreateTTFRenderFont(PdfFont font, Byte[] ttfFile);
    protected abstract virtual TRenderFont CreateCFFRenderFont(PdfFont font, Byte[] cffFile);
    protected abstract virtual TRenderFont CreateType1RenderFont(PdfFont font, PdfType1FontFileData type1File);
}
public static class DevExpress.Pdf.Drawing.Common.RenderFontStorageHelpers : object {
    public static string CreateFontName();
    private static short Min(Nullable`1<short> first, short second);
    private static short Max(Nullable`1<short> first, short second);
    public static Byte[] ValidateTTF(PdfFont font, Byte[] fontFileData, string fontName);
}
public class DevExpress.Pdf.Drawing.DirectX.D2D1BitmapTileInfo : object {
    private D2D1Bitmap bitmap;
    private PdfRectangle imageRectangle;
    public D2D1Bitmap Bitmap { get; }
    public PdfRectangle ImageRectangle { get; }
    public D2D1BitmapTileInfo(D2D1Bitmap bitmap, PdfRectangle imageRectangle);
    public D2D1Bitmap get_Bitmap();
    public PdfRectangle get_ImageRectangle();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.D2D1BitmapTileList : List`1<D2D1BitmapTileInfo> {
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.D3D11Context : object {
    private D3D11Device device;
    private D3D11DeviceContext context;
    [CompilerGeneratedAttribute]
private bool <IsSoftware>k__BackingField;
    public bool IsSoftware { get; }
    private D3D11Context(D3D11Device device, D3D11DeviceContext context, bool isSoftware);
    [SecuritySafeCriticalAttribute]
public static D3D11Context Create(bool forceSoftwareRendering);
    [CompilerGeneratedAttribute]
public bool get_IsSoftware();
    public D3D11Texture2D CreateTexture2D(Rectangle rect);
    public D3D11Texture2D CreateTexture2D(D3D11_TEXTURE2D_DESC desc);
    public DXGIDevice GetDevice();
    [SecuritySafeCriticalAttribute]
public void CopyFromMemoryTexture(D3D11Texture2D source, D2D1Bitmap target);
    [SecuritySafeCriticalAttribute]
public void PerformActionWithTextureData(D3D11Texture2D texture, Action`1<D3D11_MAPPED_SUBRESOURCE> action);
    [SecuritySafeCriticalAttribute]
public void PerformActionWithChunkedTextureData(D3D11Texture2D texture, int chunkSize, Action`3<D3D11_MAPPED_SUBRESOURCE, int, int> action);
    public void CleanUp();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.DirectWriteFont : object {
    private DWriteFontFile file;
    private DirectWriteStorageFontFileLoader loader;
    [CompilerGeneratedAttribute]
private int <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DWriteFontFace <FontFace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSubstituted>k__BackingField;
    public int Key { get; }
    public DWriteFontFace FontFace { get; }
    public bool IsSubstituted { get; }
    internal DirectWriteFont(DirectWriteStorageFontFileLoader loader, int key, DWriteFontFile file, DWriteFontFace face);
    public DirectWriteFont(DWriteFontFace face);
    [CompilerGeneratedAttribute]
public int get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual DWriteFontFace get_FontFace();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSubstituted();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.DirectWriteFontStorage : RenderFontStorage`1<DirectWriteFont> {
    private static bool shouldApplyStemFixup;
    private DWriteFactory factory;
    private CCWWrapper`1<DirectWriteStorageFontFileLoader> loader;
    private DirectWriteFontSubstitutionEngine substitutionEngine;
    private bool isDisposed;
    private int fontCounter;
    private DirectWriteStorageFontFileLoader Loader { get; }
    private static DirectWriteFontStorage();
    private static bool IsOS(UInt32 dwOS);
    [SecuritySafeCriticalAttribute]
private static bool IsWindowsServer();
    private static bool ShouldApplyStemFixup();
    private static bool ShouldFixBrokenStems(PdfType1FontCompactFontProgram program);
    private static Byte[] ValidateCFF(Byte[] cffData);
    private DirectWriteStorageFontFileLoader get_Loader();
    public virtual void Clear();
    protected virtual void Dispose(bool disposing);
    private DirectWriteFont CreateFontFace(Byte[] data, DWRITE_FONT_FACE_TYPE type);
    protected virtual DirectWriteFont CreateTTFRenderFont(PdfFont font, Byte[] ttfFont);
    protected virtual DirectWriteFont CreateCFFRenderFont(PdfFont font, Byte[] cffFont);
    protected virtual DirectWriteFont CreateType1RenderFont(PdfFont font, PdfType1FontFileData type1Font);
    protected virtual DirectWriteFont SubstituteRenderFont(PdfFont font);
    private sealed virtual override double DevExpress.Pdf.Native.IPdfRenderingFontInfoProvider.GetWidth(PdfFont font, int charCode);
    private sealed virtual override PdfFontMetricsMetadata DevExpress.Pdf.Native.IPdfRenderingFontInfoProvider.GetMetrics(PdfFont font);
}
public class DevExpress.Pdf.Drawing.DirectX.DirectWriteFontSubstitutionEngine : FontMatcher`3<DirectWriteSystemFontFamily, DirectWriteSystemFont, DWriteFont> {
    private static IList`1<DirectWriteSystemFontFamily> systemFonts;
    private DWriteFactory factory;
    private static DirectWriteFontSubstitutionEngine();
    public DirectWriteFontSubstitutionEngine(DWriteFactory factory);
    protected virtual DWriteFont GetNativeFont(DirectWriteSystemFont font);
    protected virtual DWriteFont GetFirstMatchingNativeFont(DirectWriteSystemFontFamily family, DXFontDescriptor descriptor);
}
public class DevExpress.Pdf.Drawing.DirectX.DirectWriteInMemoryFontFileStream : ComCallableWrapperBase {
    private IntPtr fontFilePtr;
    private long length;
    public IntPtr NativeObject { get; }
    private DirectWriteInMemoryFontFileStream(Byte[] fontFileData);
    public static CCWWrapper`1<DirectWriteInMemoryFontFileStream> Create(Byte[] fontFileData);
    public sealed virtual IntPtr get_NativeObject();
    [SecuritySafeCriticalAttribute]
private void AllocateMemory(Byte[] fontFileData);
    [SecuritySafeCriticalAttribute]
public sealed virtual int ReadFileFragment(IntPtr& fragmentStart, long fileOffset, long fragmentSize, IntPtr& fragmentContext);
    public sealed virtual int ReleaseFileFragment(IntPtr fragmentContext);
    public sealed virtual int GetFileSize(Int64& fileSize);
    public sealed virtual int GetLastWriteTime(Int64& lastWriteTime);
    [SecuritySafeCriticalAttribute]
protected virtual void FreeResources();
}
internal class DevExpress.Pdf.Drawing.DirectX.DirectWriteStorageFontFileLoader : ComCallableWrapperBase {
    private Dictionary`2<int, CCWWrapper`1<DirectWriteInMemoryFontFileStream>> storage;
    private IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.DirectWrite.CCW.IDWriteFontFileLoaderCCW>.NativeObject { get; }
    public static CCWWrapper`1<DirectWriteStorageFontFileLoader> Create();
    private sealed virtual override IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.DirectWrite.CCW.IDWriteFontFileLoaderCCW>.get_NativeObject();
    [SecuritySafeCriticalAttribute]
private sealed virtual override int DevExpress.DirectX.NativeInterop.DirectWrite.CCW.IDWriteFontFileLoaderCCW.CreateStreamFromKey(IntPtr fontFileReferenceKey, int fontFileReferenceKeySize, IntPtr& fontFileStream);
    public void Add(int key, Byte[] data);
    public void Remove(int key);
    public void Clear();
    protected virtual void FreeResources();
}
public class DevExpress.Pdf.Drawing.DirectX.DirectWriteSystemFont : object {
    [CompilerGeneratedAttribute]
private DirectWriteSystemFontFamily <Family>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FontIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSerif>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMonospaced>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PostScriptName>k__BackingField;
    public DirectWriteSystemFontFamily Family { get; }
    public int FontIndex { get; }
    public bool IsSerif { get; }
    public bool IsMonospaced { get; }
    public bool IsSymbol { get; }
    public string PostScriptName { get; }
    public DirectWriteSystemFont(DirectWriteSystemFontFamily parent, DWriteFont1 font, int fontIndex);
    [CompilerGeneratedAttribute]
public DirectWriteSystemFontFamily get_Family();
    [CompilerGeneratedAttribute]
public int get_FontIndex();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSerif();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMonospaced();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSymbol();
    [CompilerGeneratedAttribute]
public sealed virtual string get_PostScriptName();
}
public class DevExpress.Pdf.Drawing.DirectX.DirectWriteSystemFontFamily : object {
    [CompilerGeneratedAttribute]
private int <FamilyIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <FamilyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DirectWriteSystemFont> <Fonts>k__BackingField;
    public int FamilyIndex { get; }
    public HashSet`1<string> FamilyNames { get; }
    public IList`1<DirectWriteSystemFont> Fonts { get; }
    public DirectWriteSystemFontFamily(DWriteFontFamily family, int familyIndex);
    [CompilerGeneratedAttribute]
public int get_FamilyIndex();
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<string> get_FamilyNames();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<DirectWriteSystemFont> get_Fonts();
}
public class DevExpress.Pdf.Drawing.DirectX.DirectXNativeRenderer : object {
    private D2D1DeviceContext deviceContext;
    private D2D1Factory1 d2DFactory;
    private PdfTransformationMatrix Transform { get; }
    public InterpolationMode InterpolationMode { get; public set; }
    public SmoothingMode SmoothingMode { get; public set; }
    public DirectXNativeRenderer(D2D1DeviceContext deviceContext, D2D1Factory1 d2DFactory);
    private static D2D1_COLOR_F ToColorF(Color color);
    private static FLOAT4 ConvertColor(Color color);
    private static D2D1_GRADIENT_MESH_PATCH ToD2DPatch(PdfTensorProductBezierSurfaceInfo p);
    private PdfTransformationMatrix get_Transform();
    public sealed virtual InterpolationMode get_InterpolationMode();
    public sealed virtual void set_InterpolationMode(InterpolationMode value);
    public sealed virtual SmoothingMode get_SmoothingMode();
    public sealed virtual void set_SmoothingMode(SmoothingMode value);
    public sealed virtual void Clear(Color color);
    public sealed virtual void DrawCircle(Color color, float x, float y, float diameter);
    public sealed virtual void DrawImage(Byte[] bitmapData, int bitmapWidth, int bitmapHeight, int stride, Point offset);
    public sealed virtual void DrawNonlinearGradientLine(Byte[] brushBitmapData, int brushBitmapWidth, int stride, PdfTransformationMatrix brushMatrix, PointF startPoint, PointF endPoint, float gradientBrushPenWidth);
    public sealed virtual void DrawWithPalette(int bitmapWidth, int bitmapHeight, Color[] palette, Action`1<INativeRenderer> action);
    public sealed virtual void FillPath(Color color, GraphicsPath graphicsPath);
    [SecuritySafeCriticalAttribute]
public sealed virtual void FillTriangles(PdfRenderingTriangle[] triangles);
    [SecuritySafeCriticalAttribute]
public sealed virtual void FillPatches(IList`1<PdfTensorProductBezierSurfaceInfo> patches, PdfRectangle bbox);
    public sealed virtual void FillRectangle(Color color, Rectangle rectangle);
    public sealed virtual void PerformIsolatedOperation(Action action);
    public sealed virtual void RotateTransform(float degree);
    public sealed virtual void TranslateTransform(float locationX, float locationY);
    private void SetTransform(PdfTransformationMatrix matrix);
    private void PerformActionWithBitmap(Byte[] bitmapData, int bitmapWidth, int bitmapHeight, bool useAlpha, Action`1<D2D1Bitmap> drawAction);
    public sealed virtual void DrawGradient(ColorBlend blend, PointF centerPoint, float radius);
}
[GuidAttribute("9f251514-9d4d-4902-9d60-18988ab7d4b5")]
internal class DevExpress.Pdf.Drawing.DirectX.DXGraphicsAnalysis : ComObject {
    public DXGraphicsAnalysis(IntPtr nativeObject);
    public static DXGraphicsAnalysis CreateDebuggerHelper();
    [ConditionalAttribute("DEBUG")]
public void BeginCapture();
    [ConditionalAttribute("DEBUG")]
public void EndCapture();
}
[ExtensionAttribute]
internal static class DevExpress.Pdf.Drawing.DirectX.Extensions.RenderingExtensions : object {
    [ExtensionAttribute]
public static D2D_POINT_2F ToD2DPointF(PdfPoint point);
    [ExtensionAttribute]
public static D2D_POINT_2F ToD2DPointF(PointF point);
    [ExtensionAttribute]
public static D2D_RECT_F ToD2DRectF(PdfRectangle rectangle);
    [ExtensionAttribute]
public static D2D_RECT_U ToD2DRectU(PdfRectangle rectangle);
    [ExtensionAttribute]
public static D2D_MATRIX_3X2_F ToD2DMatrix(PdfTransformationMatrix matrix);
    [ExtensionAttribute]
public static D2D1_COLOR_F ToD2DColorF(PdfColor color, float alpha);
    [ExtensionAttribute]
public static D2D1_CAP_STYLE ToD2DLineCap(PdfLineCapStyle lineCap);
    [ExtensionAttribute]
public static PdfSize GetImageSizeConsideringMasks(PdfImage image);
    [ExtensionAttribute]
public static D2D1_LINE_JOIN ToD2DLineJoin(PdfLineJoinStyle lineJoin);
    [ExtensionAttribute]
public static D2D1_BLEND_MODE ToD2DBlendMode(PdfBlendMode blendMode);
    [ExtensionAttribute]
public static PdfTransformationMatrix ToPdfTransformationMatrix(D2D_MATRIX_3X2_F matrix);
    [ExtensionAttribute]
public static PdfRectangle ToPdfRectangle(D2D_RECT_F rectangle);
    [ExtensionAttribute]
public static PdfRectangle GetPdfBounds(D2D1Geometry geometry, D2D_MATRIX_3X2_F matrix);
    [ExtensionAttribute]
public static D2D_SIZE_U GetRoundedSize(D2D_RECT_U rect, double scaleFactor);
    [ExtensionAttribute]
public static Guid ToWICPixelFormat(PdfPixelFormat pixelFormat);
}
public class DevExpress.Pdf.Drawing.DirectX.FLOAT2 : ValueType {
    private float x;
    private float y;
    public FLOAT2(float x, float y);
}
public class DevExpress.Pdf.Drawing.DirectX.FLOAT4 : ValueType {
    private float x;
    private float y;
    private float z;
    private float w;
    public FLOAT4(float x, float y, float z, float w);
}
[UnmanagedFunctionPointerAttribute("3")]
public class DevExpress.Pdf.Drawing.DirectX.GetDelegate : MulticastDelegate {
    public GetDelegate(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr dataPtr, int dataSize, Int32& actualSize);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr dataPtr, int dataSize, Int32& actualSize, AsyncCallback callback, object object);
    public virtual int EndInvoke(Int32& actualSize, IAsyncResult result);
}
public interface DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush {
    public abstract virtual void Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXFillPathObject obj);
    public abstract virtual void Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXStrokePathObject obj);
    public abstract virtual void Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXThinLineObject obj);
    public abstract virtual void Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXGlyphRunObject obj);
    public abstract virtual void Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXMaskImageObject obj);
}
public interface DevExpress.Pdf.Drawing.DirectX.IPdfDirectXFontCachingResult {
    public DWriteFontFace FontFace { get; }
    public bool IsSubstituted { get; }
    public abstract virtual DWriteFontFace get_FontFace();
    public abstract virtual bool get_IsSubstituted();
}
public interface DevExpress.Pdf.Drawing.DirectX.IPdfDirectXGeometryObject {
    public PdfRectangle BoundingBox { get; }
    public bool IsAxisAligned { get; }
    public PdfTransformationMatrix Transform { get; }
    public D2D1Geometry Geometry { get; }
    public abstract virtual PdfRectangle get_BoundingBox();
    public abstract virtual bool get_IsAxisAligned();
    public abstract virtual PdfTransformationMatrix get_Transform();
    public abstract virtual D2D1Geometry get_Geometry();
}
public interface DevExpress.Pdf.Drawing.DirectX.IPdfDirectXGraphicsObjectClip {
    public abstract virtual void ApplyClip(D2D1DeviceContext deviceContext, PdfTransformationMatrix deviceTransform, bool initializeFromBackground);
    public abstract virtual void ResetClip(D2D1DeviceContext deviceContext);
}
public interface DevExpress.Pdf.Drawing.DirectX.IPdfDirectXObject {
    public bool SupportsNonTransparentBackground { get; }
    public PdfRectangle BoundingBox { get; }
    public abstract virtual bool get_SupportsNonTransparentBackground();
    public abstract virtual PdfRectangle get_BoundingBox();
    public abstract virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public abstract virtual int GetBlendCount(PdfRectangle viewport);
}
public interface DevExpress.Pdf.Drawing.DirectX.IPdfDirectXObjectPaint {
    public IPdfDirectXGraphicsObjectClip Clip { get; }
    public IReadOnlyList`1<IPdfDirectXGraphicsObjectClip> Layers { get; }
    public abstract virtual IPdfDirectXGraphicsObjectClip get_Clip();
    public abstract virtual IReadOnlyList`1<IPdfDirectXGraphicsObjectClip> get_Layers();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXAnnotationPainter : PdfAnnotationPainter {
    private PdfDirectXObjectFactory builder;
    public PdfDirectXAnnotationPainter(PdfRenderMode renderMode, PdfDirectXObjectFactory builder, PdfOptionalContentViewState viewState);
    protected virtual void DrawBitmap(PdfTransformationMatrix matrix, PdfEditorSettings settings, IPdfViewerController controller, PdfRectangle annotationRect);
    protected virtual void DrawForm(PdfTransformationMatrix matrix, PdfForm form);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXAtlasCache : object {
    private static int padding;
    private static int doublePadding;
    private static int maxAtlasDimension;
    private static int maxAtlasSampleCount;
    private static int smallMaskImageSampleCount;
    private static int minimumSmallImageCount;
    private static Size atlasSize;
    private IDictionary`2<PdfRenderImageAtlas, PdfDirectXImageAtlas> atlasStorage;
    private PdfRenderImageAtlasMapping mapping;
    public PdfDirectXAtlasCache(PdfDirectXPage page, PdfDirectXRenderingContext context);
    private static PdfDirectXAtlasCache();
    public static PdfRenderImageAtlasMapping CreateAtlasMap(ISet`1<PdfImage> images);
    private static bool IsSmallImage(PdfImage image);
    private static IDictionary`2<PdfRenderImageAtlas, PdfDirectXImageAtlas> CreateAtlasMap(PdfRenderImageAtlasMapping mapping, PdfDirectXRenderingContext context);
    public PdfDirectXImageAtlasItem GetAtlasItem(PdfImage image, bool shouldInterpolate);
    public void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXAxisAlignedClipBuilder : PdfDirectXClipBuilder {
    private PdfRectangle axisAlignedClip;
    private IPdfDirectXGraphicsObjectClip clipObject;
    public PdfDirectXAxisAlignedClipBuilder(PdfDirectXPageContext context, PdfRectangle axisAlignedClip);
    public virtual PdfDirectXClipBuilder Combine(D2D1Geometry geometry, D2D_MATRIX_3X2_F geometryTransform);
    public virtual PdfDirectXClipBuilder Combine(PdfRectangle rectangle);
    public virtual void Dispose();
    public virtual IPdfDirectXGraphicsObjectClip CreateObjectClip(bool isText);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXBitmapRenderTarget : PdfDirectXRenderTarget {
    private D2D1Bitmap bitmap;
    public PdfDirectXBitmapRenderTarget(D2D1DeviceContext deviceContext, D2D1Bitmap bitmap, bool supportsClearType);
    public PdfDirectXBitmapRenderTarget(D2D1DeviceContext deviceContext, D2D_SIZE_U bmpSize, IEnumerable`1<PdfDirectXRenderTargetObjectLayer> parentLayers);
    public D2D1Bitmap Close();
    public virtual void SetAsCurrent();
    public virtual D2D1Image GetBackdrop(D2D_RECT_U srcRect, double imageScaleFactor);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXBlendObjectDecorator : PdfDirectXObjectDecorator {
    private PdfBlendMode blendMode;
    public bool SupportsNonTransparentBackground { get; }
    public PdfDirectXBlendObjectDecorator(IPdfDirectXObject baseObject, PdfBlendMode blendMode);
    public virtual bool get_SupportsNonTransparentBackground();
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public virtual int GetBlendCount(PdfRectangle viewport);
}
public abstract class DevExpress.Pdf.Drawing.DirectX.PdfDirectXClipBuilder : object {
    private PdfDirectXPageContext context;
    private PdfRectangle clipBounds;
    public PdfRectangle ClipBounds { get; }
    protected PdfDirectXPageContext Context { get; }
    protected PdfDirectXClipBuilder(PdfDirectXPageContext context, PdfRectangle clipBounds);
    private static D2D1Geometry TransformGeometry(D2D1Geometry geometry, PdfDirectXPageContext context);
    public static PdfDirectXClipBuilder Create(PdfDirectXPageContext context, PdfRectangle boundingBox, PdfTransformationMatrix transformationMatrix, PdfDirectXClipBuilder parentClip);
    protected static PdfRectangle GetBounds(D2D1Geometry geometry);
    public PdfRectangle get_ClipBounds();
    protected PdfDirectXPageContext get_Context();
    public PdfDirectXClipBuilder Combine(IList`1<PdfGraphicsPath> paths, bool nonZero, PdfTransformationMatrix transformationMatrix);
    public abstract virtual void Dispose();
    public abstract virtual PdfDirectXClipBuilder Combine(D2D1Geometry geometry, D2D_MATRIX_3X2_F geometryTransform);
    public abstract virtual PdfDirectXClipBuilder Combine(PdfRectangle rectangle);
    protected PdfDirectXClipBuilder CombineGeometries(D2D1Geometry geometry, D2D1Geometry inputGeometry, D2D_MATRIX_3X2_F inputGeometryTransform);
    protected PdfRectangle GetAxisAlignedRectangleFromPath(IList`1<PdfGraphicsPath> paths, PdfTransformationMatrix matrix);
    public abstract virtual IPdfDirectXGraphicsObjectClip CreateObjectClip(bool isText);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXComboBoxObject : object {
    private IPdfViewerController controller;
    private PdfEditorSettings settings;
    [CompilerGeneratedAttribute]
private PdfTransformationMatrix <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <ImageBox>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <BoundingBox>k__BackingField;
    public PdfTransformationMatrix Transform { get; }
    public PdfRectangle ImageBox { get; }
    public PdfRectangle BoundingBox { get; }
    public bool SupportsNonTransparentBackground { get; }
    public PdfDirectXComboBoxObject(PdfEditorSettings settings, IPdfViewerController controller, PdfRectangle imageBox, PdfTransformationMatrix transform);
    [CompilerGeneratedAttribute]
public PdfTransformationMatrix get_Transform();
    [CompilerGeneratedAttribute]
public PdfRectangle get_ImageBox();
    [CompilerGeneratedAttribute]
public sealed virtual PdfRectangle get_BoundingBox();
    public sealed virtual bool get_SupportsNonTransparentBackground();
    public sealed virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public Bitmap CreateEditorBitmap();
    public sealed virtual void Dispose();
    public sealed virtual int GetBlendCount(PdfRectangle viewport);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXCommandListRenderTarget : PdfDirectXRenderTarget {
    private static float dipsDPI;
    private D2D1CommandList targetList;
    public PdfDirectXCommandListRenderTarget(D2D1DeviceContext deviceContext);
    public D2D1CommandList Close();
    public void ApplyEffect(Func`3<D2D1DeviceContext, D2D1Image, D2D1Effect> createPostProcessEffect);
    public virtual D2D1Image GetBackdrop(D2D_RECT_U srcRect, double imageScaleFactor);
    private void CopyContent(D2D1Image backdrop);
    public virtual void SetAsCurrent();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXDirectFontFaceGlyphRun : PdfDirectXGlyphRun {
    private DWRITE_GLYPH_RUN glyphRun;
    public DWRITE_GLYPH_RUN GlyphRun { get; }
    protected DWriteFontFace FontFace { get; }
    public PdfDirectXDirectFontFaceGlyphRun(PdfDirectXRenderingContext context, DWriteFontFace fontFace, Int16[] glyphIndices, Single[] glyphAdvances, PdfTransformationMatrix textTransform);
    public virtual DWRITE_GLYPH_RUN get_GlyphRun();
    protected virtual DWriteFontFace get_FontFace();
}
public static class DevExpress.Pdf.Drawing.DirectX.PdfDirectXEffectFactory : object {
    private static int colorMatrixElementCount;
    private static Guid colorMatrixEffectGuid;
    private static Guid blendEffectGuid;
    private static Guid tableTransferEffectGuid;
    private static PdfDirectXEffectFactory();
    private static void SetValue(D2D1Effect effect, int index, Single[] array);
    private static D2D1Effect CreateColorMatrixEffect(D2D1DeviceContext deviceContext, D2D1Image image, Single[] colorMatrix);
    public static D2D1Effect CreateColorMatrixEffect(D2D1DeviceContext deviceContext, D2D1Image image);
    public static D2D1Effect CreateRGBToGrayscaleEffect(D2D1DeviceContext deviceContext, D2D1Image image);
    public static D2D1Effect CreateBlendEffect(D2D1DeviceContext deviceContext, D2D1Image backdropImage, D2D1Image image, D2D1_BLEND_MODE blendMode);
    public static D2D1Effect CreateTableTransferEffect(D2D1DeviceContext deviceContext, D2D1Image image, Single[] redMappingTable, Single[] greenMappingTable, Single[] blueMappingTable);
    public static D2D1Effect CreateAlphaTableTransferEffect(D2D1DeviceContext deviceContext, D2D1Image image, Single[] alphaMappingTable);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXFillPathObject : PdfDirectXPaintObject {
    private PdfDirectXGeometry geometry;
    public bool IsAxisAligned { get; }
    public D2D1Geometry Geometry { get; }
    public PdfDirectXFillPathObject(PdfDirectXGeometry geometry, PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape, IPdfDirectXBrush brush);
    public sealed virtual bool get_IsAxisAligned();
    public sealed virtual D2D1Geometry get_Geometry();
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXFormObject : object {
    private PdfDirectXObjectList children;
    private PdfRectangle boundingBox;
    [CompilerGeneratedAttribute]
private bool <SupportsNonTransparentBackground>k__BackingField;
    public bool SupportsNonTransparentBackground { get; }
    public PdfRectangle BoundingBox { get; }
    protected PdfDirectXFormObject(PdfDirectXObjectList children, PdfRectangle boundingBox);
    public static PdfRectangle GetBoundingBox(PdfDirectXObjectList list);
    public static PdfDirectXFormObject Create(PdfDirectXObjectList formObjects);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SupportsNonTransparentBackground();
    public sealed virtual PdfRectangle get_BoundingBox();
    public sealed virtual int GetBlendCount(PdfRectangle viewport);
    public sealed virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXGenericClipBuilder : PdfDirectXClipBuilder {
    private D2D1Geometry clipGeometry;
    private PdfDirectXObjectGeometricMaskClip clipObject;
    public PdfDirectXGenericClipBuilder(PdfDirectXPageContext context, D2D1Geometry geometry);
    public virtual void Dispose();
    public virtual PdfDirectXClipBuilder Combine(D2D1Geometry geometry, D2D_MATRIX_3X2_F geometryTransform);
    public virtual PdfDirectXClipBuilder Combine(PdfRectangle rectangle);
    public virtual IPdfDirectXGraphicsObjectClip CreateObjectClip(bool isText);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXGeometry : ValueType {
    [CompilerGeneratedAttribute]
private D2D1Geometry <Geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAxisAligned>k__BackingField;
    public D2D1Geometry Geometry { get; }
    public bool IsAxisAligned { get; }
    public PdfDirectXGeometry(D2D1Geometry geometry, bool isAxisAligned);
    [CompilerGeneratedAttribute]
public D2D1Geometry get_Geometry();
    [CompilerGeneratedAttribute]
public bool get_IsAxisAligned();
    public sealed virtual void Dispose();
}
public abstract class DevExpress.Pdf.Drawing.DirectX.PdfDirectXGlyphRun : object {
    private Lazy`1<D2D1Geometry> textGeometry;
    private D2D1Factory factory;
    [CompilerGeneratedAttribute]
private PdfTransformationMatrix <TextTransform>k__BackingField;
    public PdfTransformationMatrix TextTransform { get; }
    public D2D1Geometry TextGeometry { get; }
    public DWRITE_GLYPH_RUN GlyphRun { get; }
    protected DWriteFontFace FontFace { get; }
    protected PdfDirectXGlyphRun(PdfDirectXRenderingContext context, PdfTransformationMatrix textTransform);
    [CompilerGeneratedAttribute]
public PdfTransformationMatrix get_TextTransform();
    public D2D1Geometry get_TextGeometry();
    public abstract virtual DWRITE_GLYPH_RUN get_GlyphRun();
    protected abstract virtual DWriteFontFace get_FontFace();
    public PdfRectangle GetUserSpaceBounds(D2D1DeviceContext deviceContext, PdfTransformationMatrix worldTransform);
    public sealed virtual void Dispose();
    private D2D1Geometry CreateGlyphGeometry();
    [CompilerGeneratedAttribute]
private D2D1Geometry <.ctor>b__11_0();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXGlyphRunObject : PdfDirectXPaintObject {
    [CompilerGeneratedAttribute]
private PdfDirectXGlyphRun <GlyphRun>k__BackingField;
    public PdfDirectXGlyphRun GlyphRun { get; }
    public bool IsAxisAligned { get; }
    public D2D1Geometry Geometry { get; }
    public PdfDirectXGlyphRunObject(PdfDirectXGlyphRun glyphRun, PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape, IPdfDirectXBrush brush);
    [CompilerGeneratedAttribute]
public PdfDirectXGlyphRun get_GlyphRun();
    public sealed virtual bool get_IsAxisAligned();
    public sealed virtual D2D1Geometry get_Geometry();
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXGouraudShadedTrianglesEffect : ComCallableWrapperBase {
    private static EventFactoryDelegate deletageRoot;
    private static List`1<Delegate> delegateList;
    public static Guid EffectId;
    private static Guid pixelShaderGuid;
    private static Guid vertextShaderGuid;
    private D2D1VertexBuffer vertexBuffer;
    private Vertex[] vertices;
    private D2D1EffectContext effectContext;
    private Byte[] vertextShader;
    private D2D1DrawInfo drawInfo;
    private bool isPreparedForRender;
    private D2D1VertexBuffer VertexBuffer { get; }
    private IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.Direct2D.CCW.ID2D1EffectImplCCW>.NativeObject { get; }
    private IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.Direct2D.CCW.ID2D1DrawTransformCCW>.NativeObject { get; }
    private static PdfDirectXGouraudShadedTrianglesEffect();
    [SecuritySafeCriticalAttribute]
private static int SetTriangles(IntPtr thisPtr, IntPtr dataPtr, int dataSize);
    [SecuritySafeCriticalAttribute]
private static int GetTriangles(IntPtr thisPtr, IntPtr dataPtr, int dataSize, Int32& actualSize);
    [SecuritySafeCriticalAttribute]
private static int CreateEffect(IntPtr result);
    [SecuritySafeCriticalAttribute]
private static D2D1_PROPERTY_BINDING CreateBinding(IntPtr propertyName, Delegate setDelegate, Delegate getDelegate);
    private static Byte[] GetCompiledShader(string shaderResourceName, string shaderTarget);
    public static void Register(D2D1Factory1 factory);
    public static CCWWrapper`1<PdfDirectXGouraudShadedTrianglesEffect> Create();
    private D2D1VertexBuffer get_VertexBuffer();
    private sealed virtual override IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.Direct2D.CCW.ID2D1EffectImplCCW>.get_NativeObject();
    private sealed virtual override IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.Direct2D.CCW.ID2D1DrawTransformCCW>.get_NativeObject();
    [SecuritySafeCriticalAttribute]
public sealed virtual int Initialize(D2D1EffectContext effectContext, D2D1TransformGraph transformGraph);
    public sealed virtual int PrepareForRender(D2D1_CHANGE_TYPE changeType);
    public sealed virtual int SetGraph(D2D1TransformGraph transformGraph);
    protected virtual void FreeResources();
    public sealed virtual int SetDrawInfo(D2D1DrawInfo drawInfo);
    public sealed virtual int GetInputCount();
    public sealed virtual int MapOutputRectToInputRects(D2D1_RECT_L& outputRect, IntPtr inputRects, int inputRectsCount);
    public sealed virtual int MapInputRectsToOutputRect(IntPtr inputRects, IntPtr inputOpaqueSubRects, int inputRectCount, D2D1_RECT_L& outputRect, D2D1_RECT_L& outputOpaqueSubRect);
    public sealed virtual int MapInvalidRect(int inputIndex, D2D1_RECT_L invalidInputRect, D2D1_RECT_L& invalidOutputRect);
    private void SetDpiFactor();
    private void CreateVertextBuffer();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXGraphicsState : object {
    private PdfDirectXPageContext pageContext;
    private IList`1<PdfDirectXClipBuilder> objectContainer;
    private PdfDirectXSoftMaskState softMaskState;
    private PdfDirectXClipBuilder clipState;
    public bool ClipIsNotEmpty { get; }
    public PdfDirectXSoftMask SoftMask { get; }
    public PdfDirectXClipBuilder ClipState { get; }
    private PdfDirectXGraphicsState(PdfDirectXGraphicsState parentState);
    public PdfDirectXGraphicsState(PdfDirectXPageContext pageContext, PdfDirectXClipBuilder initalClipState);
    public bool get_ClipIsNotEmpty();
    public PdfDirectXSoftMask get_SoftMask();
    public PdfDirectXClipBuilder get_ClipState();
    public void IntersectClip(IList`1<PdfGraphicsPath> paths, bool nonZero, PdfTransformationMatrix matrix);
    public void IntersectClip(D2D1Geometry textGeometry);
    public void UpdateSoftMask(PdfGraphicsState graphicsState);
    public sealed virtual void Dispose();
    public PdfDirectXGraphicsState Clone();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXImageAtlas : object {
    private PdfRenderImageAtlas atlas;
    private HashSet`1<PdfImage> imagesAlreadyInAtlas;
    private AtlasBitmap atlasBitmap;
    public PdfDirectXImageAtlas(PdfDirectXRenderingContext context, PdfRenderImageAtlas atlas, int padding);
    public PdfDirectXImageAtlasItem GetAtlasItem(PdfImage image, bool shouldInterpolate);
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXImageAtlasItem : object {
    private D2D1Bitmap atlasBitmap;
    private D2D_RECT_F sourceRect;
    public D2D1Bitmap AtlasBitmap { get; }
    public D2D_RECT_F SourceRect { get; }
    public PdfDirectXImageAtlasItem(D2D1Bitmap atlasBitmap, D2D_RECT_F sourceRect);
    public D2D1Bitmap get_AtlasBitmap();
    public D2D_RECT_F get_SourceRect();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXImageCache : PdfImageCache`1<D2D1Bitmap> {
    private static int maxImageSize;
    private WICImagingFactory wicFactory;
    private D2D1DeviceContext d2d1Context;
    private int maxImageEdgeSize;
    public PdfDirectXImageCache(PdfDirectXRenderingContext context, long capacity);
    private static Guid GetTargetPixelFormat(PdfPixelFormat format);
    protected virtual bool ShouldReplaceImage(PdfImageParameters imageParameters, PdfImageParameters oldParameters);
    public D2D1BitmapTileList GetCroppedImage(PdfImage image, PdfImageParameters parameters, PdfRectangle imageRectangle);
    protected virtual ImageCacheItem<D2D1Bitmap> CreateValue(PdfImage image, PdfImageParameters imageParameters);
    private D2D1Bitmap CreateBitmap(PdfImageData imageData, PdfImageParameters imageParemeters, Point offset, bool isMask, bool sharedImageData);
    private D2D1Bitmap CreateBitmap(PdfImageData imageData, PdfImageParameters imageParemeters, Point offset, bool sharedImageData);
    private D2D1Bitmap CreateMaskImage(PdfImageData imageData, PdfImageParameters imageParemeters, Point offset, bool sharedImageData);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXImageObject : PdfDirectXSingleObject {
    [CompilerGeneratedAttribute]
private PdfImage <Image>k__BackingField;
    public PdfImage Image { get; }
    public PdfDirectXImageObject(PdfImage image, PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape);
    [CompilerGeneratedAttribute]
public PdfImage get_Image();
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXIndirectFontFaceGlyphRun : PdfDirectXGlyphRun {
    private DirectWriteFontStorage fontCache;
    private Int16[] glyphIndices;
    private Single[] glyphAdvances;
    private PdfFont font;
    public DWRITE_GLYPH_RUN GlyphRun { get; }
    protected DWriteFontFace FontFace { get; }
    public PdfDirectXIndirectFontFaceGlyphRun(PdfDirectXRenderingContext context, PdfFont font, Int16[] glyphIndices, Single[] glyphAdvances, PdfTransformationMatrix textTransform);
    public virtual DWRITE_GLYPH_RUN get_GlyphRun();
    protected virtual DWriteFontFace get_FontFace();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXMaskImageObject : PdfDirectXPaintObject {
    [CompilerGeneratedAttribute]
private PdfImage <OpacityMask>k__BackingField;
    [CompilerGeneratedAttribute]
private D2D1Geometry <Geometry>k__BackingField;
    public PdfImage OpacityMask { get; }
    public bool IsAxisAligned { get; }
    public D2D1Geometry Geometry { get; }
    public PdfDirectXMaskImageObject(PdfImage image, D2D1Geometry rectGeometry, PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape, IPdfDirectXBrush maskBrush);
    [CompilerGeneratedAttribute]
public PdfImage get_OpacityMask();
    public sealed virtual bool get_IsAxisAligned();
    [CompilerGeneratedAttribute]
public sealed virtual D2D1Geometry get_Geometry();
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public virtual void Dispose();
}
public abstract class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObject : object {
    [CompilerGeneratedAttribute]
private float <Alpha>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfDirectXSoftMask <SoftMask>k__BackingField;
    public float Alpha { get; }
    public PdfDirectXSoftMask SoftMask { get; }
    public PdfRectangle BoundingBox { get; }
    public bool SupportsNonTransparentBackground { get; }
    protected PdfDirectXObject(PdfDirectXObjectTransparency transparency);
    [CompilerGeneratedAttribute]
public float get_Alpha();
    [CompilerGeneratedAttribute]
public PdfDirectXSoftMask get_SoftMask();
    public abstract virtual PdfRectangle get_BoundingBox();
    public virtual bool get_SupportsNonTransparentBackground();
    public abstract virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public virtual int GetBlendCount(PdfRectangle viewport);
    public virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObjectAxisAlignedClip : object {
    private PdfRectangle axisAlignedClip;
    public PdfDirectXObjectAxisAlignedClip(PdfRectangle axisAlignedClip);
    public sealed virtual void Dispose();
    public sealed virtual void ApplyClip(D2D1DeviceContext deviceContext, PdfTransformationMatrix deviceTransform, bool initializeFromBackground);
    public sealed virtual void ResetClip(D2D1DeviceContext deviceContext);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObjectDecorator : object {
    [CompilerGeneratedAttribute]
private IPdfDirectXObject <InnerObject>k__BackingField;
    protected IPdfDirectXObject InnerObject { get; }
    public PdfRectangle BoundingBox { get; }
    public bool SupportsNonTransparentBackground { get; }
    protected PdfDirectXObjectDecorator(IPdfDirectXObject innerObject);
    [CompilerGeneratedAttribute]
protected IPdfDirectXObject get_InnerObject();
    public virtual PdfRectangle get_BoundingBox();
    public virtual bool get_SupportsNonTransparentBackground();
    public virtual void Dispose();
    public abstract virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public virtual int GetBlendCount(PdfRectangle viewport);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObjectFactory : PdfCommandInterpreter {
    private PdfDirectXPageContext pageContext;
    private Stack`1<PdfDirectXGraphicsState> graphicsStateStack;
    private PdfDirectXClipBuilder initalClipState;
    private PdfGraphicsState patternGraphicsState;
    private int paintingObjectNumber;
    private Stack`1<IList`1<IPdfDirectXObject>> markedContentStack;
    private IList`1<IPdfDirectXObject> graphicsObjects;
    private PdfDirectXGraphicsState graphicsState;
    private D2D1Geometry textClipGeometry;
    protected IPdfRenderingFontInfoProvider RenderingFontInfoProvider { get; }
    private bool TransformDeterminantIsNotZero { get; }
    private PdfDirectXObjectFactory(PdfPage page, PdfDirectXRenderingContext renderingContext, bool useIndirectGlyphRuns);
    private PdfDirectXObjectFactory(PdfDirectXPageContext parentContext, PdfRectangle boundingBox, PdfGraphicsState initalGraphicsState);
    private PdfDirectXObjectFactory(PdfDirectXPageContext parentContext, PdfForm form, PdfGraphicsState initalGraphicsState, PdfDirectXClipBuilder parentClip);
    private static void ApplyOptionalContentViewState(IList`1<PdfDirectXOptionalContentGroupObject> groupObjects, PdfOptionalContentViewState optionalContentViewState);
    public static PdfDirectXPageInfo CreatePageInfo(PdfPage page, PdfDirectXRenderingContext context, PdfOptionalContentViewState optionalContentViewState);
    public static PdfDirectXObjectList CreateAnnotationList(PdfPage page, IPdfAnnotationState annotationState, IPdfViewerController controller, PdfRgbaColor highlightedFormFieldColor, PdfRenderMode renderMode, PdfDirectXRenderingContext context, PdfOptionalContentViewState optionalContentViewState);
    public static PdfDirectXObjectList CreateFormList(PdfDirectXPageContext pageContext, PdfForm form, PdfGraphicsState initalGraphicsState, PdfDirectXClipBuilder initalClip);
    private static PdfDirectXObjectList CreateCommandList(PdfDirectXPageContext pageContext, PdfRectangle boundingBox, IEnumerable`1<PdfCommand> commands);
    private static PdfDirectXObjectList CreateCommandList(PdfDirectXPageContext pageContext, PdfRectangle boundingBox, IEnumerable`1<PdfCommand> commands, PdfGraphicsState graphicsState);
    protected virtual IPdfRenderingFontInfoProvider get_RenderingFontInfoProvider();
    private bool get_TransformDeterminantIsNotZero();
    private void DrawOptionalContent(PdfOptionalContent optionalContent, Action drawAction);
    public virtual void DrawMarkedContent(IEnumerable`1<PdfCommand> commands, PdfProperties properties, string tag);
    public virtual void SaveGraphicsState();
    public virtual void RestoreGraphicsState();
    public virtual void DrawImage(PdfImage image);
    public virtual void DrawShading(PdfShading shading);
    private void AddObject(PdfRectangle boundingBox, Func`1<IPdfDirectXObject> createObject);
    protected virtual void FillPaths(bool useNonzeroWindingRule);
    protected virtual void StrokePaths();
    public void DrawComboBox(PdfTransformationMatrix matrix, PdfEditorSettings settings, IPdfViewerController controller, PdfRectangle boundingBox);
    protected virtual void ClipPaths();
    public virtual void EndText();
    private void CombineWithTextClip(D2D1Geometry geometry);
    protected virtual void DrawType3Glyph(PdfType3FontGlyph glyph);
    protected virtual void DrawString(PdfStringData stringData);
    public virtual void DrawForm(PdfForm form);
    public virtual void DrawTransparencyGroup(PdfGroupForm form);
    protected virtual void UpdateGraphicsState(PdfGraphicsStateChange change);
    protected virtual void Dispose(bool disposing);
    private PdfRectangle GetUserSpaceBounds(PdfRectangle objectBounds);
    private void ApplyBlendAndAddObject(IPdfDirectXObject obj);
    private IPdfDirectXBrush CreateStrokingBrush();
    private IPdfDirectXBrush CreateNonStrokingBrush();
    private PdfDirectXStrokeInfo CreateStrokeInfo();
    private PdfDirectXObjectShape GetShape(PdfRectangle userSpaceBoundingBox, bool isText);
    private PdfDirectXObjectTransparency GetTransparency();
    private PdfDirectXObjectTransparency GetTransparency(double alpha);
    private IPdfDirectXBrush CreateBrush(PdfColor brushColor, double alpha);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObjectGeometricMaskClip : object {
    private D2D1Geometry geometry;
    private PdfTransformationMatrix geometryTransform;
    private float alpha;
    [CompilerGeneratedAttribute]
private bool <InitializeFromBackground>k__BackingField;
    public bool InitializeFromBackground { get; public set; }
    public PdfDirectXObjectGeometricMaskClip(D2D1Geometry geometry);
    public PdfDirectXObjectGeometricMaskClip(D2D1Geometry geometry, PdfTransformationMatrix geometryTransform, float alpha);
    [CompilerGeneratedAttribute]
public bool get_InitializeFromBackground();
    [CompilerGeneratedAttribute]
public void set_InitializeFromBackground(bool value);
    public sealed virtual void Dispose();
    public sealed virtual void ApplyClip(D2D1DeviceContext deviceContext, PdfTransformationMatrix deviceTransform, bool supportsClearType);
    public sealed virtual void ResetClip(D2D1DeviceContext deviceContext);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObjectList : object {
    private IList`1<IPdfDirectXObject> list;
    private bool shouldDisposeList;
    protected IList`1<IPdfDirectXObject> List { get; }
    public bool SupportsNonTransparentBackground { get; }
    public PdfDirectXObjectList(IList`1<IPdfDirectXObject> list);
    protected PdfDirectXObjectList(IList`1<IPdfDirectXObject> list, bool disposeList);
    protected IList`1<IPdfDirectXObject> get_List();
    public bool get_SupportsNonTransparentBackground();
    public int GetBlendCount(PdfRectangle viewport);
    public void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<IPdfDirectXObject> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObjectPaint : object {
    private List`1<IPdfDirectXGraphicsObjectClip> layers;
    private List`1<bool> disposeFlags;
    [CompilerGeneratedAttribute]
private IPdfDirectXGraphicsObjectClip <Clip>k__BackingField;
    public IPdfDirectXGraphicsObjectClip Clip { get; private set; }
    public IReadOnlyList`1<IPdfDirectXGraphicsObjectClip> Layers { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IPdfDirectXGraphicsObjectClip get_Clip();
    [CompilerGeneratedAttribute]
private void set_Clip(IPdfDirectXGraphicsObjectClip value);
    public sealed virtual IReadOnlyList`1<IPdfDirectXGraphicsObjectClip> get_Layers();
    public void SetClip(IPdfDirectXGraphicsObjectClip clip);
    public void AddLayer(IPdfDirectXGraphicsObjectClip layer, bool disposeLayer);
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObjectShape : ValueType {
    [CompilerGeneratedAttribute]
private PdfTransformationMatrix <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private IPdfDirectXGraphicsObjectClip <Clip>k__BackingField;
    public PdfTransformationMatrix Transform { get; }
    public PdfRectangle BoundingBox { get; }
    public IPdfDirectXGraphicsObjectClip Clip { get; }
    public PdfDirectXObjectShape(PdfTransformationMatrix transform, PdfRectangle boundingBox, IPdfDirectXGraphicsObjectClip clip);
    [CompilerGeneratedAttribute]
public PdfTransformationMatrix get_Transform();
    [CompilerGeneratedAttribute]
public PdfRectangle get_BoundingBox();
    [CompilerGeneratedAttribute]
public IPdfDirectXGraphicsObjectClip get_Clip();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObjectTransparency : ValueType {
    public static PdfDirectXObjectTransparency Empty;
    [CompilerGeneratedAttribute]
private PdfDirectXSoftMask <SoftMask>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Alpha>k__BackingField;
    public PdfDirectXSoftMask SoftMask { get; }
    public float Alpha { get; }
    public PdfDirectXObjectTransparency(float alpha, PdfDirectXSoftMask softMask);
    private static PdfDirectXObjectTransparency();
    [CompilerGeneratedAttribute]
public PdfDirectXSoftMask get_SoftMask();
    [CompilerGeneratedAttribute]
public float get_Alpha();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXObjectTransparencyLayer : object {
    private PdfRectangle contentBounds;
    private D2D1Brush opacityBrush;
    private float alpha;
    private PdfTransformationMatrix opacityBrushTransform;
    private D2D1_ANTIALIAS_MODE antialiasMode;
    public PdfDirectXObjectTransparencyLayer(PdfRectangle contentBounds, D2D1Brush opacityBrush, PdfTransformationMatrix opacityTransform, float alpha, D2D1_ANTIALIAS_MODE antialiasMode);
    public sealed virtual void ApplyClip(D2D1DeviceContext deviceContext, PdfTransformationMatrix deviceTransform, bool initializeFromBackground);
    public sealed virtual void ResetClip(D2D1DeviceContext deviceContext);
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXOptionalContentGroupObject : object {
    [CompilerGeneratedAttribute]
private PdfDirectXFormObject <Contents>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfOptionalContentGroupFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfOptionalContent <OptionalContent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsNonTransparentBackground>k__BackingField;
    public PdfDirectXFormObject Contents { get; }
    public PdfOptionalContentGroupFlags Flags { get; public set; }
    public PdfOptionalContent OptionalContent { get; }
    public PdfRectangle BoundingBox { get; }
    public bool SupportsNonTransparentBackground { get; }
    public PdfDirectXOptionalContentGroupObject(PdfDirectXObjectList children, PdfOptionalContent optionalContent);
    [CompilerGeneratedAttribute]
public PdfDirectXFormObject get_Contents();
    [CompilerGeneratedAttribute]
public PdfOptionalContentGroupFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(PdfOptionalContentGroupFlags value);
    [CompilerGeneratedAttribute]
public PdfOptionalContent get_OptionalContent();
    public sealed virtual PdfRectangle get_BoundingBox();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SupportsNonTransparentBackground();
    public sealed virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public sealed virtual void Dispose();
    public sealed virtual int GetBlendCount(PdfRectangle viewport);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXPage : PdfDirectXObjectList {
    [CompilerGeneratedAttribute]
private PdfRenderImageAtlasMapping <Atlas>k__BackingField;
    public PdfRenderImageAtlasMapping Atlas { get; }
    public PdfDirectXPage(PdfDirectXPageInfo pageInfo);
    private PdfDirectXPage(IList`1<IPdfDirectXObject> objectList, PdfRenderImageAtlasMapping atlas);
    [CompilerGeneratedAttribute]
public PdfRenderImageAtlasMapping get_Atlas();
    public PdfDirectXPage Clone();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXPageCache : PdfCache`2<PdfPage, PdfDirectXPage> {
    private PdfDirectXRenderingContext context;
    public PdfDirectXPageCache(long limit, PdfDirectXRenderingContext context);
    public PdfDirectXPage GetPage(PdfPage page, PdfOptionalContentViewState optionalContentViewState);
    protected virtual long GetSizeOfValue(PdfDirectXPage value);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXPageContext : object {
    private PdfDirectXRenderingContext renderingContext;
    private bool useIndirectGlyphRuns;
    [CompilerGeneratedAttribute]
private PdfPage <Page>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<PdfImage> <Images>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<PdfType3FontGlyph, PdfDirectXObjectList> <Type3GlyphCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PdfDirectXOptionalContentGroupObject> <OptionalContentGroups>k__BackingField;
    public PdfPage Page { get; }
    public ISet`1<PdfImage> Images { get; }
    public IDictionary`2<PdfType3FontGlyph, PdfDirectXObjectList> Type3GlyphCache { get; }
    public IPdfRenderingFontInfoProvider WidthProvider { get; }
    public IList`1<PdfDirectXOptionalContentGroupObject> OptionalContentGroups { get; }
    public PdfDirectXPageContext(PdfPage page, PdfDirectXRenderingContext renderingContext, bool useIndirectGlyphRuns);
    [CompilerGeneratedAttribute]
public PdfPage get_Page();
    [CompilerGeneratedAttribute]
public ISet`1<PdfImage> get_Images();
    [CompilerGeneratedAttribute]
public IDictionary`2<PdfType3FontGlyph, PdfDirectXObjectList> get_Type3GlyphCache();
    public IPdfRenderingFontInfoProvider get_WidthProvider();
    [CompilerGeneratedAttribute]
public IList`1<PdfDirectXOptionalContentGroupObject> get_OptionalContentGroups();
    public IList`1<PdfDirectXGlyphRun> CreateGlyphRuns(PdfTextState textState, PdfStringData stringData);
    public D2D1StrokeStyle CreateStrokeStyle(PdfGraphicsState graphicsState);
    public D2D1StrokeStyle CreateStrokeStyle();
    public D2D1PathGeometry CreatePathGeometry();
    public D2D1Geometry CreateTransformedGeometry(D2D1Geometry geometry, D2D_MATRIX_3X2_F geometryTransform);
    public D2D1Geometry CreateGeometry(PdfRectangle rectangle);
    public PdfDirectXGeometry CreateGeometry(IList`1<PdfGraphicsPath> paths, bool outlineOnly, bool nonZero);
    public PdfRectangle GetGlyphRunBounds(PdfDirectXGlyphRun glyphRun, PdfTransformationMatrix transformationMatrix);
    public PdfDirectXSoftMask GetSoftMask(PdfCustomSoftMask softMask, PdfTransformationMatrix transform);
    public IPdfDirectXGraphicsObjectClip CreateShadingClip(PdfShading shading, PdfTransformationMatrix shadingTransformation);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXPageInfo : ValueType {
    [CompilerGeneratedAttribute]
private IList`1<IPdfDirectXObject> <Objects>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<PdfImage> <Images>k__BackingField;
    public IList`1<IPdfDirectXObject> Objects { get; private set; }
    public ISet`1<PdfImage> Images { get; private set; }
    public PdfDirectXPageInfo(IList`1<IPdfDirectXObject> objects, ISet`1<PdfImage> images);
    [CompilerGeneratedAttribute]
public IList`1<IPdfDirectXObject> get_Objects();
    [CompilerGeneratedAttribute]
private void set_Objects(IList`1<IPdfDirectXObject> value);
    [CompilerGeneratedAttribute]
public ISet`1<PdfImage> get_Images();
    [CompilerGeneratedAttribute]
private void set_Images(ISet`1<PdfImage> value);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXPageRenderingContext : object {
    private IDictionary`2<D2D1_COLOR_F, D2D1Brush> solidColorBrushCache;
    private Lazy`1<PdfDirectXStrokeInfo> fillGeometryStrokeInfo;
    [CompilerGeneratedAttribute]
private PdfDirectXRenderingContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfDirectXAtlasCache <AtlasCache>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfType3FontGlyphsCache`2<PdfDirectXType3FontCacheKey, D2D1Bitmap> <Type3GlyphCache>k__BackingField;
    public PdfDirectXRenderingContext Context { get; }
    public PdfDirectXAtlasCache AtlasCache { get; }
    public PdfType3FontGlyphsCache`2<PdfDirectXType3FontCacheKey, D2D1Bitmap> Type3GlyphCache { get; }
    public PdfDirectXStrokeInfo FillGeometryStrokeInfo { get; }
    public PdfDirectXPageRenderingContext(PdfDirectXRenderingContext context, PdfDirectXPage page);
    [CompilerGeneratedAttribute]
public PdfDirectXRenderingContext get_Context();
    [CompilerGeneratedAttribute]
public PdfDirectXAtlasCache get_AtlasCache();
    [CompilerGeneratedAttribute]
public PdfType3FontGlyphsCache`2<PdfDirectXType3FontCacheKey, D2D1Bitmap> get_Type3GlyphCache();
    public PdfDirectXStrokeInfo get_FillGeometryStrokeInfo();
    public D2D1Brush GetSolidBrush(D2D1_COLOR_F color);
    [IteratorStateMachineAttribute("DevExpress.Pdf.Drawing.DirectX.PdfDirectXPageRenderingContext/<CreateRenderImages>d__15")]
public IEnumerable`1<PdfDirectXRenderImage> CreateRenderImages(PdfImage image, PdfImageParameters parameters, PdfRectangle visibleImageRect);
    public D2D1Image CreateCommandListImage(PdfDirectXRenderTargetView viewInfo, PdfDirectXObjectList objects);
    public D2D1Bitmap CreateBitmapImage(PdfDirectXRenderTargetView viewInfo, D2D_SIZE_U bmpSize, PdfDirectXObjectList objects);
    public sealed virtual void Dispose();
}
public abstract class DevExpress.Pdf.Drawing.DirectX.PdfDirectXPaintObject : PdfDirectXSingleObject {
    [CompilerGeneratedAttribute]
private IPdfDirectXBrush <Brush>k__BackingField;
    public IPdfDirectXBrush Brush { get; }
    protected PdfDirectXPaintObject(PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape, IPdfDirectXBrush brush);
    [CompilerGeneratedAttribute]
public IPdfDirectXBrush get_Brush();
    public virtual void Dispose();
}
public abstract class DevExpress.Pdf.Drawing.DirectX.PdfDirectXPatternBrush`1 : object {
    [CompilerGeneratedAttribute]
private TPattern <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Alpha>k__BackingField;
    public TPattern Pattern { get; }
    public float Alpha { get; }
    protected PdfDirectXPatternBrush`1(TPattern pattern, float alpha);
    [CompilerGeneratedAttribute]
public TPattern get_Pattern();
    [CompilerGeneratedAttribute]
public float get_Alpha();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXPrintingProperties : object {
    [CompilerGeneratedAttribute]
private bool <ConvertToGrayscale>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ImageScaleFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private D2D1GdiMetafile <Overlay>k__BackingField;
    [CompilerGeneratedAttribute]
private PointF <OverlayOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintTextAsOutlines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsXpsPrinting>k__BackingField;
    public bool ConvertToGrayscale { get; public set; }
    public double ImageScaleFactor { get; public set; }
    public D2D1GdiMetafile Overlay { get; public set; }
    public PointF OverlayOffset { get; public set; }
    public bool PrintTextAsOutlines { get; public set; }
    public bool IsXpsPrinting { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ConvertToGrayscale();
    [CompilerGeneratedAttribute]
public void set_ConvertToGrayscale(bool value);
    [CompilerGeneratedAttribute]
public double get_ImageScaleFactor();
    [CompilerGeneratedAttribute]
public void set_ImageScaleFactor(double value);
    [CompilerGeneratedAttribute]
public D2D1GdiMetafile get_Overlay();
    [CompilerGeneratedAttribute]
public void set_Overlay(D2D1GdiMetafile value);
    [CompilerGeneratedAttribute]
public PointF get_OverlayOffset();
    [CompilerGeneratedAttribute]
public void set_OverlayOffset(PointF value);
    [CompilerGeneratedAttribute]
public bool get_PrintTextAsOutlines();
    [CompilerGeneratedAttribute]
public void set_PrintTextAsOutlines(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsXpsPrinting();
    [CompilerGeneratedAttribute]
public void set_IsXpsPrinting(bool value);
}
internal class DevExpress.Pdf.Drawing.DirectX.PdfDirectXRenderGlyphRunFont : object {
    private PdfFont font;
    private PdfDirectXRenderingContext context;
    private IPdfDirectXFontCachingResult renderFont;
    private bool useIndirectGlyphRuns;
    public bool IsSubstituted { get; }
    private PdfDirectXRenderGlyphRunFont(PdfDirectXRenderingContext context, PdfFont font, IPdfDirectXFontCachingResult renderFont, bool useIndirectGlyphRuns);
    public static PdfDirectXRenderGlyphRunFont Create(PdfDirectXRenderingContext context, PdfFont font, bool useIndirectGlyphRuns);
    public sealed virtual bool get_IsSubstituted();
    public sealed virtual Int16[] GetGlyphIndices(PdfStringData data);
    public sealed virtual Double[] GetGlyphWidths(Int16[] str, double fontSize);
    public sealed virtual PdfDirectXGlyphRun CreateGlyphRun(Int16[] glyphIndices, Single[] glyphAdvances, PdfTransformationMatrix textTransform);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXRenderImage : object {
    private IPdfDirectXRenderImage image;
    [CompilerGeneratedAttribute]
private bool <UseImageBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private D2D1_INTERPOLATION_MODE <InterpolationMode>k__BackingField;
    public D2D1Bitmap Bitmap { get; }
    public D2D_RECT_F SourceRect { get; }
    public PdfRectangle TargetRect { get; }
    public bool UseImageBrush { get; }
    public D2D1_INTERPOLATION_MODE InterpolationMode { get; }
    public PdfDirectXRenderImage(PdfDirectXImageAtlasItem item, D2D1_INTERPOLATION_MODE interpolationMode);
    public PdfDirectXRenderImage(PdfImageCacheItem<D2D1Bitmap> item, D2D1_INTERPOLATION_MODE interpolationMode);
    public PdfDirectXRenderImage(D2D1BitmapTileInfo item, D2D1_INTERPOLATION_MODE interpolationMode);
    private static D2D_RECT_F GetDefaultSourceRect(D2D1Bitmap image);
    public D2D1Bitmap get_Bitmap();
    public D2D_RECT_F get_SourceRect();
    public PdfRectangle get_TargetRect();
    [CompilerGeneratedAttribute]
public bool get_UseImageBrush();
    [CompilerGeneratedAttribute]
public D2D1_INTERPOLATION_MODE get_InterpolationMode();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXRenderingDeviceContext : object {
    private static float hairlineWidth;
    private static float zeroWidthHairlineWidth;
    private static double minPixelLimit;
    private static double xpsMinMatrixDeterminant;
    private static PdfTransformationMatrix imageSpaceInversionMatrix;
    private PdfDirectXPageRenderingContext pageContext;
    private PdfDirectXRenderTarget renderTarget;
    private PdfDirectXRenderTargetView viewInfo;
    public PdfRectangle Viewport { get; }
    public D2D1DeviceContext DeviceContext { get; }
    private PdfDirectXSolidColorBrush DefaultNonStrokingBrush { get; }
    private D2D1Factory1 Factory { get; }
    private bool SupportsClearType { get; }
    public PdfDirectXRenderingDeviceContext(PdfDirectXPageRenderingContext pageContext, PdfDirectXRenderTargetView viewInfo, PdfDirectXRenderTarget target);
    private static PdfDirectXRenderingDeviceContext();
    private void FillGeometryWithBrush(D2D1Geometry geometry, D2D_MATRIX_3X2_F transform, D2D1Brush brush);
    private void FillGeometryWithBrush(IPdfDirectXGeometryObject obj, D2D1Brush brush);
    private bool IsHairline(PdfTransformationMatrix fullTransform, float lineWidth);
    private D2D1StrokeStyle CreateHairlineStrokeStyle(PdfTransformationMatrix transform, float hairlineLineWidth, float sourceLineWidth, D2D1StrokeStyle sourceStyle);
    private void StrokeHairline(D2D1Geometry geometry, D2D1Brush brush, PdfDirectXStrokeInfo strokeInfo, PdfTransformationMatrix fullTransform);
    private bool ShouldApplyTransformProgrammatically(PdfTransformationMatrix matrix);
    private void StrokeGeometryWithBrush(PdfDirectXStrokePathObject obj, D2D1Brush brush);
    private void FillGlyphRunWithBrush(PdfDirectXGlyphRunObject obj, D2D1Brush brush);
    private D2D1_TEXT_ANTIALIAS_MODE GetTextAntialiasMode();
    private void StrokeLineWithBrush(PdfDirectXThinLineObject obj, D2D1Brush brush);
    private PdfDirectXObjectPaint CreateObjectPaint(PdfDirectXObject obj);
    private PdfDirectXObjectPaint CreateSingleObjectPaint(PdfDirectXSingleObject obj);
    private void PaintObject(PdfDirectXObjectPaint paint, Action renderAction);
    private void PaintClipped(PdfDirectXObjectPaint paint, IPdfDirectXGeometryObject clipGeometry, PdfDirectXStrokeInfo clipStroke, float clipAlpha, Action renderAction);
    private void PaintClipped(PdfDirectXObjectPaint paint, IPdfDirectXGeometryObject clipGeometry, float clipAlpha, Action renderAction);
    private void PaintClipped(PdfDirectXObjectPaint paint, D2D1Geometry clipGeometry, PdfTransformationMatrix clipTransform, float clipAlpha, bool diposeClip, Action renderAction);
    public void Render(PdfDirectXSolidColorBrush brush, PdfDirectXFillPathObject obj);
    public void Render(PdfDirectXSolidColorBrush brush, PdfDirectXStrokePathObject obj);
    public void Render(PdfDirectXSolidColorBrush brush, PdfDirectXThinLineObject obj);
    public void Render(PdfDirectXSolidColorBrush brush, PdfDirectXGlyphRunObject obj);
    public void Render(PdfDirectXTilingPatternBrush brush, PdfDirectXFillPathObject obj);
    private void PaintObject(PdfDirectXObjectPaint paint, PdfDirectXTilingPatternBrush brush, IPdfDirectXGeometryObject obj);
    public void Render(PdfDirectXTilingPatternBrush brush, PdfDirectXStrokePathObject obj);
    public void Render(PdfDirectXTilingPatternBrush brush, PdfDirectXThinLineObject obj);
    public void Render(PdfDirectXTilingPatternBrush brush, PdfDirectXGlyphRunObject obj);
    private D2D1Brush CreateTilingPatterBrush(D2D1Image brushImage, D2D_RECT_F sourceRect, PdfTransformationMatrix matrix, float alpha, PdfTransformationMatrix objectTransform);
    private D2D1Brush CreateTilingPatternBrush(PdfDirectXTilingPatternBrush brush, PdfTransformationMatrix objectTransform);
    private void FillWithTilingPattern(PdfDirectXTilingPattern pattern, PdfRectangle fillBounds);
    public void Render(PdfDirectXShadingPatternBrush brush, PdfDirectXFillPathObject obj);
    private void PaintObject(PdfDirectXObjectPaint paint, PdfDirectXShadingPatternBrush brush, IPdfDirectXGeometryObject obj);
    public void Render(PdfDirectXShadingPatternBrush brush, PdfDirectXStrokePathObject obj);
    public void Render(PdfDirectXShadingPatternBrush brush, PdfDirectXThinLineObject obj);
    public void Render(PdfDirectXShadingPatternBrush brush, PdfDirectXGlyphRunObject obj);
    private void DrawShadingPatternBrush(PdfDirectXShadingPattern pattern);
    private static int CalcDistance(PdfPoint start, PdfPoint end, double imageScaleFactor);
    private static bool ShouldInterpolate(PdfImage image, Size requestedSize);
    public PdfRectangle get_Viewport();
    public D2D1DeviceContext get_DeviceContext();
    private PdfDirectXSolidColorBrush get_DefaultNonStrokingBrush();
    private D2D1Factory1 get_Factory();
    private bool get_SupportsClearType();
    private PdfDirectXObjectTransparencyLayer CreateLayer(PdfRectangle boundingBox, PdfDirectXSoftMask softMaskInfo, float alpha);
    private D2D1Image ApplyLuminocity(PdfDirectXSoftMask softMaskInfo, D2D1Image maskImage);
    private D2D1Image ApplyTransferFunction(PdfDirectXSoftMask softMaskInfo, D2D1Image maskImage);
    private static Single[] CreateFunctionMappingTable(PdfFunction function);
    private D2D1Bitmap CreateBitmap(Action`1<PdfDirectXRenderingDeviceContext> renderAction, PdfRectangle contentRectangle, D2D_RECT_U deviceContentRectangle, bool cloneParentLayers);
    public void Blend(IPdfDirectXObject obj, PdfBlendMode blendMode);
    private void SetUserTransform(PdfTransformationMatrix matrix);
    private void ResetTransform();
    private void SetDeviceTransform(D2D_MATRIX_3X2_F transform);
    private bool MatrixEquals(D2D_MATRIX_3X2_F m1, D2D_MATRIX_3X2_F m2);
    private void DrawShading(PdfDirectXShadingPattern pattern, bool fillBackground);
    public void Render(PdfDirectXFillPathObject obj);
    public void Render(PdfDirectXGlyphRunObject obj);
    public void Render(PdfDirectXStrokePathObject obj);
    public void Render(PdfDirectXThinLineObject obj);
    private PdfTransformationMatrix GetImageFullTransform(PdfTransformationMatrix transform);
    private IEnumerable`1<PdfDirectXRenderImage> CreateRenderImages(PdfImage image, PdfTransformationMatrix objectTransformation);
    private IPdfDirectXBrush GetBrush(PdfDirectXPaintObject obj);
    public void Render(PdfDirectXMaskImageObject obj);
    public void Render(PdfDirectXImageObject obj);
    public void Render(PdfDirectXShadingObject obj);
    public void Render(PdfDirectXType3GlyphObject obj);
    [SecuritySafeCriticalAttribute]
public void Render(PdfDirectXComboBoxObject obj);
    public void Render(PdfDirectXOptionalContentGroupObject obj);
    public void Render(PdfDirectXTransparencyGroupObject obj);
    private void DrawIsolated(Action`1<PdfDirectXRenderingDeviceContext> imageRenderAction, PdfRectangle contentBounds);
    private void ApplyKnockout(PdfDirectXTransparencyGroupObject obj);
    [IteratorStateMachineAttribute("DevExpress.Pdf.Drawing.DirectX.PdfDirectXRenderingDeviceContext/<CreateMaskPaint>d__82")]
private IEnumerable`1<PdfDirectXObjectPaint> CreateMaskPaint(PdfDirectXMaskImageObject obj);
    public void Render(PdfDirectXSolidColorBrush brush, PdfDirectXMaskImageObject obj);
    public void Render(PdfDirectXTilingPatternBrush brush, PdfDirectXMaskImageObject obj);
    public void Render(PdfDirectXShadingPatternBrush brush, PdfDirectXMaskImageObject obj);
}
public abstract class DevExpress.Pdf.Drawing.DirectX.PdfDirectXRenderTarget : object {
    private D2D1DeviceContext deviceContext;
    private List`1<PdfDirectXRenderTargetObjectLayer> objectLayers;
    private int currentLayerIndex;
    private IPdfDirectXGraphicsObjectClip lastClip;
    private PdfTransformationMatrix lastClipDeviceTransform;
    private bool supportsClearTypeInital;
    protected D2D1DeviceContext DeviceContext { get; }
    public bool SupportsClearType { get; }
    public IEnumerable`1<PdfDirectXRenderTargetObjectLayer> Layers { get; }
    protected PdfDirectXRenderTarget(D2D1DeviceContext deviceContext, bool supportsClearType, IEnumerable`1<PdfDirectXRenderTargetObjectLayer> parentLayers);
    protected D2D1DeviceContext get_DeviceContext();
    public bool get_SupportsClearType();
    public IEnumerable`1<PdfDirectXRenderTargetObjectLayer> get_Layers();
    public abstract virtual void SetAsCurrent();
    public abstract virtual D2D1Image GetBackdrop(D2D_RECT_U srcRect, double imageScaleFactor);
    public void BeginRenderObject(IPdfDirectXObjectPaint objectPaint, PdfTransformationMatrix deviceTransform);
    public void EndRenderObject();
    public void RestoreLayers();
    public void ResetLayers();
    private void ResetLastClip();
    public void ResetLayersSoft();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXRenderTargetObjectLayer : ValueType {
    [CompilerGeneratedAttribute]
private IPdfDirectXGraphicsObjectClip <Clip>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IPdfDirectXGraphicsObjectClip> <Layers>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfTransformationMatrix <DeviceTransform>k__BackingField;
    public IPdfDirectXGraphicsObjectClip Clip { get; }
    public IReadOnlyList`1<IPdfDirectXGraphicsObjectClip> Layers { get; }
    public PdfTransformationMatrix DeviceTransform { get; }
    public PdfDirectXRenderTargetObjectLayer(IPdfDirectXGraphicsObjectClip clip, IReadOnlyList`1<IPdfDirectXGraphicsObjectClip> layers, PdfTransformationMatrix deviceTransform);
    [CompilerGeneratedAttribute]
public IPdfDirectXGraphicsObjectClip get_Clip();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IPdfDirectXGraphicsObjectClip> get_Layers();
    [CompilerGeneratedAttribute]
public PdfTransformationMatrix get_DeviceTransform();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXRenderTargetOptions : ValueType {
    public static PdfDirectXRenderTargetOptions Default;
    [CompilerGeneratedAttribute]
private float <DpiScale>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrinting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsXpsPrinting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintTextAsOutlines>k__BackingField;
    public float DpiScale { get; }
    public bool IsPrinting { get; }
    public bool IsXpsPrinting { get; }
    public bool PrintTextAsOutlines { get; }
    public PdfDirectXRenderTargetOptions(float dpiScale, bool isPrinting, bool isXpsPrinting, bool printTextAsOutlines);
    private static PdfDirectXRenderTargetOptions();
    [CompilerGeneratedAttribute]
public float get_DpiScale();
    [CompilerGeneratedAttribute]
public bool get_IsPrinting();
    [CompilerGeneratedAttribute]
public bool get_IsXpsPrinting();
    [CompilerGeneratedAttribute]
public bool get_PrintTextAsOutlines();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXRenderTargetView : object {
    [CompilerGeneratedAttribute]
private PdfTransformationMatrix <DeviceTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <Viewport>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <DeviceSpaceViewport>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfDirectXSolidColorBrush <DefaultBrush>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfDirectXRenderTargetOptions <Options>k__BackingField;
    public PdfTransformationMatrix DeviceTransform { get; }
    public PdfRectangle Viewport { get; }
    public PdfRectangle DeviceSpaceViewport { get; }
    public PdfDirectXSolidColorBrush DefaultBrush { get; }
    public PdfDirectXRenderTargetOptions Options { get; }
    public PdfDirectXRenderTargetView(PdfTransformationMatrix deviceTransform, PdfRectangle viewport, PdfDirectXRenderTargetOptions options);
    public PdfDirectXRenderTargetView(PdfTransformationMatrix deviceTransform, PdfRectangle viewport, PdfDirectXSolidColorBrush defaultBrush, PdfDirectXRenderTargetOptions options);
    private PdfDirectXRenderTargetView(PdfTransformationMatrix deviceTransform, PdfRectangle viewport, PdfRectangle deviceSpaceViewport, PdfDirectXSolidColorBrush defaultBrush, PdfDirectXRenderTargetOptions options);
    [CompilerGeneratedAttribute]
public PdfTransformationMatrix get_DeviceTransform();
    [CompilerGeneratedAttribute]
public PdfRectangle get_Viewport();
    [CompilerGeneratedAttribute]
public PdfRectangle get_DeviceSpaceViewport();
    [CompilerGeneratedAttribute]
public PdfDirectXSolidColorBrush get_DefaultBrush();
    [CompilerGeneratedAttribute]
public PdfDirectXRenderTargetOptions get_Options();
}
public static class DevExpress.Pdf.Drawing.DirectX.PdfDirectXShaderCache : object {
    private static IDictionary`2<string, Byte[]> compiledShadersCache;
    private static PdfDirectXShaderCache();
    private static Byte[] CompileShader(string shaderName, string shaderTarget);
    public static Byte[] GetCompliedShader(string shaderResourceName, string shaderTarget);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXShadingObject : PdfDirectXSingleObject {
    private PdfShading shading;
    private IPdfDirectXGraphicsObjectClip shadingClip;
    public PdfDirectXShadingPattern Pattern { get; }
    public PdfDirectXShadingObject(PdfShading shading, PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape, IPdfDirectXGraphicsObjectClip shadingClip);
    public PdfDirectXShadingPattern get_Pattern();
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXShadingPattern : ValueType {
    private PdfShading shading;
    private PdfTransformationMatrix transform;
    [CompilerGeneratedAttribute]
private IPdfDirectXGraphicsObjectClip <Clip>k__BackingField;
    public PdfShading Shading { get; }
    public PdfTransformationMatrix Transform { get; }
    public IPdfDirectXGraphicsObjectClip Clip { get; }
    public PdfDirectXShadingPattern(PdfShading shading, PdfTransformationMatrix transform, IPdfDirectXGraphicsObjectClip clip);
    public PdfShading get_Shading();
    public PdfTransformationMatrix get_Transform();
    [CompilerGeneratedAttribute]
public IPdfDirectXGraphicsObjectClip get_Clip();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXShadingPatternBrush : PdfDirectXPatternBrush`1<PdfDirectXShadingPattern> {
    public PdfDirectXShadingPatternBrush(PdfDirectXShadingPattern pattern, float alpha);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXFillPathObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXStrokePathObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXGlyphRunObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXThinLineObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXMaskImageObject obj);
    private sealed virtual override void System.IDisposable.Dispose();
}
public abstract class DevExpress.Pdf.Drawing.DirectX.PdfDirectXSingleObject : PdfDirectXObject {
    [CompilerGeneratedAttribute]
private IPdfDirectXGraphicsObjectClip <Clip>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfTransformationMatrix <Transform>k__BackingField;
    public IPdfDirectXGraphicsObjectClip Clip { get; }
    public PdfRectangle BoundingBox { get; }
    public PdfTransformationMatrix Transform { get; }
    protected PdfDirectXSingleObject(PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape);
    [CompilerGeneratedAttribute]
public IPdfDirectXGraphicsObjectClip get_Clip();
    [CompilerGeneratedAttribute]
public virtual PdfRectangle get_BoundingBox();
    [CompilerGeneratedAttribute]
public sealed virtual PdfTransformationMatrix get_Transform();
    public virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXSoftMask : object {
    [CompilerGeneratedAttribute]
private PdfTransformationMatrix <Transform>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfDirectXObjectList <MaskCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLuminosity>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfFunction <TransferFunction>k__BackingField;
    public PdfTransformationMatrix Transform { get; }
    public PdfDirectXObjectList MaskCommands { get; }
    public bool IsLuminosity { get; }
    public PdfRectangle BoundingBox { get; }
    public PdfFunction TransferFunction { get; }
    public PdfDirectXSoftMask(PdfTransformationMatrix transform, PdfDirectXObjectList maskCommands, bool isLuminosity, PdfRectangle boundingBox, PdfFunction transferFunction);
    [CompilerGeneratedAttribute]
public PdfTransformationMatrix get_Transform();
    [CompilerGeneratedAttribute]
public PdfDirectXObjectList get_MaskCommands();
    [CompilerGeneratedAttribute]
public bool get_IsLuminosity();
    [CompilerGeneratedAttribute]
public PdfRectangle get_BoundingBox();
    [CompilerGeneratedAttribute]
public PdfFunction get_TransferFunction();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXSoftMaskState : object {
    private Lazy`1<PdfDirectXSoftMask> softMaskInfo;
    public PdfDirectXSoftMask SoftMask { get; }
    public PdfDirectXSoftMaskState(PdfDirectXPageContext pageContext, PdfCustomSoftMask softMask, PdfTransformationMatrix transform);
    public PdfDirectXSoftMask get_SoftMask();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXSolidColorBrush : object {
    [CompilerGeneratedAttribute]
private D2D1_COLOR_F <Color>k__BackingField;
    public D2D1_COLOR_F Color { get; }
    public PdfDirectXSolidColorBrush(D2D1_COLOR_F color);
    [CompilerGeneratedAttribute]
public D2D1_COLOR_F get_Color();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXFillPathObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXStrokePathObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXGlyphRunObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXThinLineObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXMaskImageObject obj);
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXStrokeInfo : object {
    [CompilerGeneratedAttribute]
private D2D1StrokeStyle <StrokeStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private float <LineWidth>k__BackingField;
    public D2D1StrokeStyle StrokeStyle { get; }
    public float LineWidth { get; }
    public PdfDirectXStrokeInfo(D2D1StrokeStyle strokeStyle, float lineWidth);
    [CompilerGeneratedAttribute]
public D2D1StrokeStyle get_StrokeStyle();
    [CompilerGeneratedAttribute]
public float get_LineWidth();
    public void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXStrokePathObject : PdfDirectXPaintObject {
    private PdfDirectXGeometry geometry;
    [CompilerGeneratedAttribute]
private PdfDirectXStrokeInfo <StrokeInfo>k__BackingField;
    public PdfDirectXStrokeInfo StrokeInfo { get; }
    public bool IsAxisAligned { get; }
    public D2D1Geometry Geometry { get; }
    public PdfDirectXStrokePathObject(PdfDirectXGeometry geometry, PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape, IPdfDirectXBrush brush, PdfDirectXStrokeInfo strokeInfo);
    [CompilerGeneratedAttribute]
public PdfDirectXStrokeInfo get_StrokeInfo();
    public sealed virtual bool get_IsAxisAligned();
    public sealed virtual D2D1Geometry get_Geometry();
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
    public virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXThinLineObject : PdfDirectXStrokePathObject {
    [CompilerGeneratedAttribute]
private PdfLineSegment <LineSegment>k__BackingField;
    public PdfLineSegment LineSegment { get; }
    public PdfDirectXThinLineObject(PdfLineSegment lineSegment, PdfDirectXGeometry geometry, PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape, IPdfDirectXBrush brush, PdfDirectXStrokeInfo strokeInfo);
    [CompilerGeneratedAttribute]
public PdfLineSegment get_LineSegment();
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXTilingPattern : object {
    private PdfDirectXObjectList patternCommands;
    private double xStep;
    private double yStep;
    private PdfRectangle boundingBox;
    private PdfTransformationMatrix patternMatrix;
    public PdfDirectXObjectList PatternCommands { get; }
    public PdfTransformationMatrix PatternMatrix { get; }
    public double XStep { get; }
    public double YStep { get; }
    public PdfRectangle BoundingBox { get; }
    public PdfDirectXTilingPattern(PdfDirectXObjectList patternCommands, PdfRectangle boundingBox, double xStep, double yStep, PdfTransformationMatrix patternMatrix);
    public PdfDirectXObjectList get_PatternCommands();
    public PdfTransformationMatrix get_PatternMatrix();
    public double get_XStep();
    public double get_YStep();
    public PdfRectangle get_BoundingBox();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXTilingPatternBrush : PdfDirectXPatternBrush`1<PdfDirectXTilingPattern> {
    public PdfDirectXTilingPatternBrush(PdfDirectXTilingPattern pattern, float alpha);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXFillPathObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXStrokePathObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXGlyphRunObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXThinLineObject obj);
    private sealed virtual override void DevExpress.Pdf.Drawing.DirectX.IPdfDirectXBrush.Render(PdfDirectXRenderingDeviceContext deviceContext, PdfDirectXMaskImageObject obj);
    private sealed virtual override void System.IDisposable.Dispose();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXTransparencyGroupObject : PdfDirectXObject {
    [CompilerGeneratedAttribute]
private PdfDirectXFormObject <Form>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Isolated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Knockout>k__BackingField;
    public PdfDirectXFormObject Form { get; }
    public bool Isolated { get; }
    public bool Knockout { get; }
    public PdfRectangle BoundingBox { get; }
    public PdfDirectXTransparencyGroupObject(PdfDirectXObjectTransparency transparency, PdfDirectXFormObject form, bool isolated, bool knockout);
    [CompilerGeneratedAttribute]
public PdfDirectXFormObject get_Form();
    [CompilerGeneratedAttribute]
public bool get_Isolated();
    [CompilerGeneratedAttribute]
public bool get_Knockout();
    public virtual PdfRectangle get_BoundingBox();
    public virtual void Dispose();
    public virtual int GetBlendCount(PdfRectangle viewport);
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXType3FontCacheKey : object {
    private PdfDirectXObjectList charProc;
    private int a;
    private int b;
    private int c;
    private int d;
    private PdfDirectXSolidColorBrush nonStrokingColor;
    public PdfDirectXType3FontCacheKey(PdfDirectXObjectList charProc, PdfTransformationMatrix matrix, PdfDirectXSolidColorBrush nonStrokingColor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXType3GlyphObject : PdfDirectXSingleObject {
    [CompilerGeneratedAttribute]
private PdfDirectXObjectList <GlyphCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <GlyphBBox>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfDirectXSolidColorBrush <MaskColor>k__BackingField;
    public PdfDirectXObjectList GlyphCommands { get; }
    public PdfRectangle GlyphBBox { get; }
    public PdfDirectXSolidColorBrush MaskColor { get; }
    public PdfDirectXType3GlyphObject(PdfDirectXObjectList glyphCommands, PdfRectangle glyphBBox, PdfDirectXSolidColorBrush maskColor, PdfDirectXObjectTransparency transparency, PdfDirectXObjectShape shape);
    [CompilerGeneratedAttribute]
public PdfDirectXObjectList get_GlyphCommands();
    [CompilerGeneratedAttribute]
public PdfRectangle get_GlyphBBox();
    [CompilerGeneratedAttribute]
public PdfDirectXSolidColorBrush get_MaskColor();
    public virtual void Dispose();
    public virtual void Render(PdfDirectXRenderingDeviceContext deviceContext);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfDirectXVertexesBuilder : object {
    private Vertex[] vertices;
    private int v;
    private float minX;
    private float minY;
    private float maxX;
    private float maxY;
    public Vertex[] Vertices { get; }
    public D2D_RECT_F BoundingBox { get; }
    public PdfDirectXVertexesBuilder(int trianglesCount);
    public Vertex[] get_Vertices();
    public D2D_RECT_F get_BoundingBox();
    public void AppendTriangle(PdfRenderingTriangle triangle);
    private Vertex CreateVertex(PdfRenderingVertex vertex);
}
public abstract class DevExpress.Pdf.Drawing.DirectX.PdfEffectBase`1 : ComCallableWrapperBase {
    private static List`1<Delegate> delegateList;
    private D2D1VertexBuffer vertexBuffer;
    private D2D1EffectContext effectContext;
    private Byte[] vertextShader;
    private D2D1DrawInfo drawInfo;
    private bool isPreparedForRender;
    [CompilerGeneratedAttribute]
private TVertextData[] <Vertices>k__BackingField;
    private D2D1VertexBuffer VertexBuffer { get; }
    private IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.Direct2D.CCW.ID2D1EffectImplCCW>.NativeObject { get; }
    private IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.Direct2D.CCW.ID2D1DrawTransformCCW>.NativeObject { get; }
    protected D2D1EffectContext EffectContext { get; }
    protected D2D1DrawInfo DrawInfo { get; }
    protected TVertextData[] Vertices { get; protected set; }
    protected IList`1<VertexBufferElementDescription<TVertextData>> VertexBufferDescription { get; }
    protected Guid PixelShaderGuid { get; }
    protected Guid VertextShaderGuid { get; }
    protected string PixelShaderName { get; }
    protected string VertexShaderName { get; }
    protected bool UseDepthBuffer { get; }
    private static PdfEffectBase`1();
    [SecuritySafeCriticalAttribute]
private static D2D1_PROPERTY_BINDING CreateBinding(IntPtr propertyName, Delegate setDelegate, Delegate getDelegate);
    protected static Byte[] GetCompiledShader(string shaderResourceName, string shaderTarget);
    protected static void RegisterEffect(D2D1Factory1 factory, Guid effectId, IList`1<EffectPropertyDescription<TVertextData>> properties, EventFactoryDelegate createEffect);
    private D2D1VertexBuffer get_VertexBuffer();
    private sealed virtual override IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.Direct2D.CCW.ID2D1EffectImplCCW>.get_NativeObject();
    private sealed virtual override IntPtr DevExpress.DirectX.NativeInterop.CCW.IComCallableWrapper<DevExpress.DirectX.NativeInterop.Direct2D.CCW.ID2D1DrawTransformCCW>.get_NativeObject();
    protected D2D1EffectContext get_EffectContext();
    protected D2D1DrawInfo get_DrawInfo();
    [CompilerGeneratedAttribute]
protected TVertextData[] get_Vertices();
    [CompilerGeneratedAttribute]
protected void set_Vertices(TVertextData[] value);
    protected abstract virtual IList`1<VertexBufferElementDescription<TVertextData>> get_VertexBufferDescription();
    protected abstract virtual Guid get_PixelShaderGuid();
    protected abstract virtual Guid get_VertextShaderGuid();
    protected abstract virtual string get_PixelShaderName();
    protected abstract virtual string get_VertexShaderName();
    protected virtual bool get_UseDepthBuffer();
    [SecuritySafeCriticalAttribute]
public sealed virtual int Initialize(D2D1EffectContext effectContext, D2D1TransformGraph transformGraph);
    public sealed virtual int PrepareForRender(D2D1_CHANGE_TYPE changeType);
    public sealed virtual int SetGraph(D2D1TransformGraph transformGraph);
    protected virtual void FreeResources();
    public sealed virtual int SetDrawInfo(D2D1DrawInfo drawInfo);
    public sealed virtual int GetInputCount();
    public sealed virtual int MapOutputRectToInputRects(D2D1_RECT_L& outputRect, IntPtr inputRects, int inputRectsCount);
    public sealed virtual int MapInputRectsToOutputRect(IntPtr inputRects, IntPtr inputOpaqueSubRects, int inputRectCount, D2D1_RECT_L& outputRect, D2D1_RECT_L& outputOpaqueSubRect);
    public sealed virtual int MapInvalidRect(int inputIndex, D2D1_RECT_L invalidInputRect, D2D1_RECT_L& invalidOutputRect);
    private void SetDpiFactor();
    private void CreateVertextBuffer();
    protected virtual void SetPixelShaderConstantBuffer(D2D1DrawInfo info);
    protected virtual void PrepareForRender();
}
public class DevExpress.Pdf.Drawing.DirectX.PdfTensorProductBezierSurfaceVerticesBuilder : object {
    private List`1<TensorProductPatchVertex> vertices;
    private float minX;
    private float minY;
    private float maxX;
    private float maxY;
    public TensorProductPatchVertex[] Vertices { get; }
    public D2D_RECT_F BoundingBox { get; }
    public TensorProductPatchVertex[] get_Vertices();
    public D2D_RECT_F get_BoundingBox();
    public sealed virtual void AppendTriangle(PdfTensorProductBezierSurfacePoint p1, PdfTensorProductBezierSurfacePoint p2, PdfTensorProductBezierSurfacePoint p3, int patchId);
    private TensorProductPatchVertex CreateVertex(PdfTensorProductBezierSurfacePoint point, int patchId);
}
public class DevExpress.Pdf.Drawing.DirectX.PdfTensorProductPatchEffect : PdfEffectBase`1<TensorProductPatchVertex> {
    public static Guid EffectId;
    private static IList`1<EffectPropertyDescription<TensorProductPatchVertex>> properties;
    private static IList`1<VertexBufferElementDescription<TensorProductPatchVertex>> bufferDescription;
    [CompilerGeneratedAttribute]
private float <DepthFactor>k__BackingField;
    [CompilerGeneratedAttribute]
private FLOAT4[] <Colors>k__BackingField;
    private D2D1ResourceTexture texture;
    public static int VerticesPropertyIndex { get; }
    public static int DepthFactorPropertyIndex { get; }
    public static int ColorsPropertyIndex { get; }
    private float DepthFactor { get; private set; }
    private FLOAT4[] Colors { get; private set; }
    protected IList`1<VertexBufferElementDescription<TensorProductPatchVertex>> VertexBufferDescription { get; }
    protected Guid PixelShaderGuid { get; }
    protected Guid VertextShaderGuid { get; }
    protected string PixelShaderName { get; }
    protected string VertexShaderName { get; }
    protected bool UseDepthBuffer { get; }
    private static PdfTensorProductPatchEffect();
    public static int get_VerticesPropertyIndex();
    public static int get_DepthFactorPropertyIndex();
    public static int get_ColorsPropertyIndex();
    [SecuritySafeCriticalAttribute]
private static int SetVertices(IntPtr thisPtr, IntPtr dataPtr, int dataSize);
    [SecuritySafeCriticalAttribute]
private static int SetColors(IntPtr thisPtr, IntPtr dataPtr, int dataSize);
    [SecuritySafeCriticalAttribute]
private static int GetEmpty(IntPtr thisPtr, IntPtr dataPtr, int dataSize, Int32& actualSize);
    [SecuritySafeCriticalAttribute]
private static int SetDepthFactor(IntPtr thisPtr, IntPtr dataPtr, int dataSize);
    [SecuritySafeCriticalAttribute]
private static int CreateEffect(IntPtr result);
    public static void RegisterEffect(D2D1Factory1 factory);
    public static CCWWrapper`1<PdfTensorProductPatchEffect> Create();
    [CompilerGeneratedAttribute]
private float get_DepthFactor();
    [CompilerGeneratedAttribute]
private void set_DepthFactor(float value);
    [CompilerGeneratedAttribute]
private FLOAT4[] get_Colors();
    [CompilerGeneratedAttribute]
private void set_Colors(FLOAT4[] value);
    protected virtual IList`1<VertexBufferElementDescription<TensorProductPatchVertex>> get_VertexBufferDescription();
    protected virtual Guid get_PixelShaderGuid();
    protected virtual Guid get_VertextShaderGuid();
    protected virtual string get_PixelShaderName();
    protected virtual string get_VertexShaderName();
    protected virtual bool get_UseDepthBuffer();
    protected virtual void SetPixelShaderConstantBuffer(D2D1DrawInfo info);
    [SecuritySafeCriticalAttribute]
protected virtual void PrepareForRender();
    protected virtual void FreeResources();
}
public static class DevExpress.Pdf.Drawing.DirectX.PdfUnmanagedCodeHelpers : object {
    [SecuritySafeCriticalAttribute]
public static void DoActionWithPinnedObject(object o, Action`1<IntPtr> pinnedObjectPointerAction);
}
[UnmanagedFunctionPointerAttribute("3")]
public class DevExpress.Pdf.Drawing.DirectX.SetDelegate : MulticastDelegate {
    public SetDelegate(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr dataPtr, int dataSize);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr dataPtr, int dataSize, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public class DevExpress.Pdf.Drawing.DirectX.TensorProductPatchVertex : ValueType {
    private FLOAT2 Pos;
    private FLOAT2 UV;
    private int patchID;
    public TensorProductPatchVertex(FLOAT2 pos, FLOAT2 UV, int patchID);
}
public class DevExpress.Pdf.Drawing.DirectX.Vertex : ValueType {
    private FLOAT2 Pos;
    private FLOAT4 Color;
    public Vertex(FLOAT2 pos, FLOAT4 color);
}
[ExtensionAttribute]
internal static class DevExpress.Pdf.Drawing.Extensions.DrawingExtensions : object {
    [ExtensionAttribute]
public static Size ToGDISizeI(PdfSize size, float scale);
    [ExtensionAttribute]
public static Size ToGDISizeI(PdfSize size, Size maximumSize);
    [ExtensionAttribute]
public static SizeF ToGDISizeF(PdfSize size, float scale);
    [ExtensionAttribute]
public static PointF Div(PointF point, float value);
    [ExtensionAttribute]
public static PointF Mul(PointF point, float value);
    [ExtensionAttribute]
public static void DrawRectangle(Graphics graphics, Pen pen, RectangleF rectangle);
}
internal class DevExpress.Pdf.Drawing.GDI.AfmPfbCreator : PdfDisposableObject {
    private static Byte[] defaultNullSegment;
    private string fontName;
    private PdfFont font;
    private PdfType1FontFileData fontFileData;
    private short top;
    private short height;
    private short fontWeight;
    private byte pitchAndFamily;
    private short avgWidth;
    private short maxWidth;
    private short capHeight;
    private short xHeight;
    private short ascent;
    private short descent;
    private Stream pfmStream;
    private Stream pfbStream;
    private AfmPfbCreator(string fontName, PdfFont font, PdfType1FontFileData fontFileData, string pfmFileName, string pfbFileName);
    private static AfmPfbCreator();
    private static Stream CreateStream(string fileName);
    private static short ConvertToShort(double value);
    public static void CreateFontFiles(string fontName, PdfFont font, PdfType1FontFileData fontFileData, string pfmFileName, string pfbFileName);
    protected virtual void Dispose(bool disposing);
    private void WriteByte(byte value);
    private void WriteShort(short value);
    private void WriteInt(Stream stream, int value);
    private void WriteString(string value);
    private void CreateFiles();
}
public class DevExpress.Pdf.Drawing.GDI.GDIFont : object {
    internal static int NormalWeight;
    private static int BoldWeight;
    private GDIFontResource resource;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Weight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Italic>k__BackingField;
    [CompilerGeneratedAttribute]
private FontPitchAndFamily <PitchAndFamily>k__BackingField;
    public string Name { get; }
    public int Weight { get; }
    public bool Italic { get; }
    public FontPitchAndFamily PitchAndFamily { get; }
    public bool IsNotSubstituted { get; }
    public GDIFont(PdfFont font, GDIFontResource resource);
    public GDIFont(string name, int weight, bool italic, FontPitchAndFamily pitchAndFamily);
    private static int GetWeight(PdfFont font);
    internal static bool IsItalic(PdfFont font);
    internal static FontPitchAndFamily GetPitchAndFamily(PdfFont font);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_Weight();
    [CompilerGeneratedAttribute]
public bool get_Italic();
    [CompilerGeneratedAttribute]
public FontPitchAndFamily get_PitchAndFamily();
    public bool get_IsNotSubstituted();
    [SecuritySafeCriticalAttribute]
internal IntPtr CreateNativeFont(int fontSize, bool forceBold, FontQuality fontQuality);
    public sealed virtual void Dispose();
}
public abstract class DevExpress.Pdf.Drawing.GDI.GDIFontResource : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    protected GDIFontResource(string name);
    [SecuritySafeCriticalAttribute]
public static GDIFontResource CreateMemoryResource(string name, Byte[] fontFileData);
    [SecuritySafeCriticalAttribute]
public static GDIFontResource CreateType1FontFileResource(string fontName, PdfFont font, PdfType1FontFileData type1File, string fontFolderName);
    [CompilerGeneratedAttribute]
public string get_Name();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void RemoveFontResources();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.GDI.GDIFontStorage : RenderFontStorage`1<GDIFont> {
    private Lazy`1<GDIMeasuringContext> measuringContext;
    private string fontFolderName;
    private Stream lockFileStream;
    private string FontFolderName { get; }
    private string get_FontFolderName();
    private GDIFont CreateGDIFont(string fontName, PdfFont font, Byte[] data);
    protected virtual GDIFont CreateCFFRenderFont(PdfFont font, Byte[] cffFont);
    protected virtual GDIFont CreateTTFRenderFont(PdfFont font, Byte[] ttfFont);
    protected virtual GDIFont CreateType1RenderFont(PdfFont font, PdfType1FontFileData type1Font);
    private GDIFont CreateGDIFont(string fontName, PdfFont font, PdfType1FontFileData type1Font);
    protected virtual GDIFont SubstituteRenderFont(PdfFont font);
    protected virtual void Dispose(bool disposing);
    public virtual void RemoveRenderFont(PdfFont font);
    public virtual void Clear();
    private sealed virtual override double DevExpress.Pdf.Native.IPdfRenderingFontInfoProvider.GetWidth(PdfFont font, int charCode);
    private sealed virtual override PdfFontMetricsMetadata DevExpress.Pdf.Native.IPdfRenderingFontInfoProvider.GetMetrics(PdfFont font);
}
internal abstract class DevExpress.Pdf.Drawing.GDI.GDIImage : object {
    internal static PointF[] ImageDestinationPoints;
    private static PdfPoint[] pdfImageDestinationPoints;
    private PdfImageParameters parameters;
    private int bitsPerComponent;
    private int stride;
    private PixelFormat pixelFormat;
    private PdfImageColor[] palette;
    private bool isMask;
    private bool interpolate;
    private static PointF[] correctedImageDestinationPoints;
    public PdfImageParameters Parameters { get; }
    public int Stride { get; }
    public PixelFormat PixelFormat { get; }
    public PdfImageColor[] Palette { get; }
    public bool IsMask { get; }
    public int BitsPerComponent { get; }
    public bool Interpolate { get; }
    protected GDIImage(PdfImageData imageData, PdfImage image);
    private static GDIImage();
    public static Size GetImageSize(PdfTransformationMatrix transform);
    private static Byte[] GetImageRaster(PdfImageData imageData);
    public static GDIImage CreateRasterImage(PdfImage image, PdfImageData imageData);
    public static GDIImage CreateDataSourceImage(PdfImage image, PdfImageData imageData);
    public PdfImageParameters get_Parameters();
    public int get_Stride();
    public PixelFormat get_PixelFormat();
    public PdfImageColor[] get_Palette();
    public bool get_IsMask();
    public int get_BitsPerComponent();
    public bool get_Interpolate();
    protected void DrawImage(Graphics graphics, Bitmap bitmap, GDIImageRenderParams renderParams);
    protected void DrawImage(Graphics graphics, Bitmap bitmap, float top, float bottom, GDIImageRenderParams renderParams);
    [SecuritySafeCriticalAttribute]
private void PerformRendering(Byte[] data, int height, Color[] imagePalette, Action`1<Bitmap> action);
    public abstract virtual void Render(Graphics g, GDIImageRenderParams renderParams);
    public abstract virtual void Dispose();
}
internal class DevExpress.Pdf.Drawing.GDI.GDIImageCache : PdfImageCache`1<GDIImage> {
    public GDIImageCache(long capacity);
    protected virtual ImageCacheItem<GDIImage> CreateValue(PdfImage image, PdfImageParameters imageParameters);
}
internal class DevExpress.Pdf.Drawing.GDI.GDIImageRenderParams : ValueType {
    [CompilerGeneratedAttribute]
private Color[] <Palette>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Alpha>k__BackingField;
    [CompilerGeneratedAttribute]
private InterpolationMode <InterpolationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCorrectInterpolationGaps>k__BackingField;
    public Color[] Palette { get; }
    public double Alpha { get; }
    public InterpolationMode InterpolationMode { get; }
    public bool ShouldCorrectInterpolationGaps { get; }
    private GDIImageRenderParams(Color[] palette, double alpha, InterpolationMode interpolationMode, bool shouldCorrectInterpolationGaps);
    private static InterpolationMode GetInterpolationMode(GDIImage image, double scale, PdfTransformationMatrix gsTransform);
    public static GDIImageRenderParams Create(GDIImage gdiImage, PdfColor color, double alpha, double scale, PdfTransformationMatrix gsTransform);
    private static Color[] ConvertPalette(GDIImage image, PdfColor nonStrokingColor, double nonStrokingAlpha);
    [CompilerGeneratedAttribute]
public Color[] get_Palette();
    [CompilerGeneratedAttribute]
public double get_Alpha();
    [CompilerGeneratedAttribute]
public InterpolationMode get_InterpolationMode();
    [CompilerGeneratedAttribute]
public bool get_ShouldCorrectInterpolationGaps();
}
internal class DevExpress.Pdf.Drawing.GDI.GDIMeasuringContext : object {
    private Bitmap bitmap;
    private Graphics graphics;
    private IntPtr defaultFont;
    private GDIFont currentMeasuringFont;
    private IntPtr hdc;
    public double GetWidth(GDIFont font, int charCode);
    public PdfFontMetricsMetadata GetMetrics(GDIFont font);
    private T PerformActionWithFont(GDIFont font, Func`2<IntPtr, T> action);
    [SecuritySafeCriticalAttribute]
private static PdfFontMetricsMetadata GetMetrics(IntPtr hdc);
    [SecuritySafeCriticalAttribute]
private bool SelectFont(GDIFont font);
    [SecuritySafeCriticalAttribute]
public void Reset();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class DevExpress.Pdf.Drawing.GDI.GDIRenderingExtensions : object {
    [ExtensionAttribute]
public static void DrawBitmapWithAlphaConstant(Graphics graphics, Bitmap bitmap, PointF[] points, double alphaConstant);
    [ExtensionAttribute]
public static PointF ToPointF(PdfPoint point);
    [ExtensionAttribute]
public static RectangleF ToRectangleF(PdfRectangle rect);
    [ExtensionAttribute]
public static PdfRectangle ToPdfRectangle(RectangleF rectangle);
    [ExtensionAttribute]
public static Matrix ToGDIMatrix(PdfTransformationMatrix m);
    [ExtensionAttribute]
public static PdfTransformationMatrix ToPdfMatrix(Matrix m);
    [ExtensionAttribute]
public static Size ToBitmapSize(PdfRectangle rect);
    [ExtensionAttribute]
public static Rectangle ToBitmapRect(PdfRectangle rect);
    [ExtensionAttribute]
public static Color ToGDIColor(PdfColor color, double alphaConstant);
    [ExtensionAttribute]
public static Color ToGDIColor(PdfColor color);
    [ExtensionAttribute]
public static bool ShouldFillText(PdfTextRenderingMode mode);
    [ExtensionAttribute]
public static bool ShouldStrokeText(PdfTextRenderingMode mode);
    [ExtensionAttribute]
public static bool ShouldClipUsingText(PdfTextRenderingMode mode);
    [ExtensionAttribute]
public static LineCap ToGDILineCap(PdfLineCapStyle lineCap);
    [ExtensionAttribute]
public static DashCap ToGDIDashCap(PdfLineCapStyle lineCap);
    [ExtensionAttribute]
public static LineJoin ToGDILineJoin(PdfLineJoinStyle lineJoin);
}
public static class DevExpress.Pdf.Drawing.GDI.GDIRenderingUtils : object {
    public static PixelFormat ConvertPixelFormat(PdfPixelFormat pixelFormat);
    public static ImageAttributes GetImageOpacityAttributes(double alphaConstant);
    public static ImageAttributes GetImageAttributes(double alphaConstant);
    public static Color ConvertToGDIPlusColor(PdfColor color, double alphaConstant);
    public static Color ConvertToGDIPlusColor(PdfColor color);
    public static bool IsFlatPath(IList`1<PdfGraphicsPath> paths, bool forFilling);
    public static GraphicsPath ConvertPath(IList`1<PdfGraphicsPath> paths, bool nonZero);
    public static Pen CreateStrokingPen(PdfGraphicsState graphicsState, Brush brush);
    public static SmoothingMode GetSmoothingMode(PdfTransformationMatrix matrix, IList`1<PdfGraphicsPath> path, bool forFilling);
}
internal class DevExpress.Pdf.Drawing.GDI.GDITextRenderer : object {
    private static int textRenderingPrecision;
    private static PdfTransformationMatrix precisionCompensationMatrix;
    private int currentTextColor;
    private GDIFont currentFont;
    private IntPtr currentFontHandle;
    private IntPtr defaultFontHandle;
    private GraphicsMode initalGraphicsMode;
    private TextAlign initalTextAlign;
    private BackgroundMode initalBackgroundMode;
    private int initalTextColor;
    private Graphics graphics;
    private Region clipRegion;
    private IntPtr hdc;
    private IntPtr clipHrgn;
    private FontQuality fontQuality;
    public GDIFont Font { get; public set; }
    public int TextColor { get; public set; }
    [SecuritySafeCriticalAttribute]
public GDITextRenderer(Graphics graphics, Region clipRegion, FontQuality fontQuality);
    private static GDITextRenderer();
    public GDIFont get_Font();
    public void set_Font(GDIFont value);
    public int get_TextColor();
    public void set_TextColor(int value);
    [SecuritySafeCriticalAttribute]
private void SetTextColor(int color);
    [SecuritySafeCriticalAttribute]
public GraphicsPath GetTextOutline(Int16[] str, Single[] positions, PdfTransformationMatrix transform, bool isIndices);
    [SecuritySafeCriticalAttribute]
public void ShowText(Int16[] str, Single[] positions, PdfTransformationMatrix transform, bool isIndices);
    [SecuritySafeCriticalAttribute]
private void DeleteCurrentFont();
    [SecuritySafeCriticalAttribute]
private bool EnsureCurrentFont();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.GdiPlusNativeRenderer : object {
    private Graphics graphics;
    public InterpolationMode InterpolationMode { get; public set; }
    public SmoothingMode SmoothingMode { get; public set; }
    public GdiPlusNativeRenderer(Graphics graphics);
    public sealed virtual InterpolationMode get_InterpolationMode();
    public sealed virtual void set_InterpolationMode(InterpolationMode value);
    public sealed virtual SmoothingMode get_SmoothingMode();
    public sealed virtual void set_SmoothingMode(SmoothingMode value);
    public sealed virtual void Clear(Color color);
    public sealed virtual void FillPath(Color color, GraphicsPath graphicsPath);
    public sealed virtual void FillRectangle(Color color, Rectangle rectangle);
    public sealed virtual void PerformIsolatedOperation(Action action);
    public sealed virtual void RotateTransform(float value);
    public sealed virtual void TranslateTransform(float locationX, float locationY);
    [SecuritySafeCriticalAttribute]
public sealed virtual void DrawImage(Byte[] bitmapData, int bitmapWidth, int bitmapHeight, int stride, Point offset);
    public sealed virtual void DrawCircle(Color color, float x, float y, float diameter);
    public sealed virtual void DrawWithPalette(int bitmapWidth, int bitmapHeight, Color[] palette, Action`1<INativeRenderer> action);
    [SecuritySafeCriticalAttribute]
public sealed virtual void DrawNonlinearGradientLine(Byte[] brushBitmapData, int brushBitmapWidth, int stride, PdfTransformationMatrix brushMatrix, PointF startPoint, PointF endPoint, float gradientBrushPenWidth);
    public sealed virtual void FillTriangles(PdfRenderingTriangle[] triangles);
    public sealed virtual void DrawGradient(ColorBlend blend, PointF centerPoint, float radius);
    public sealed virtual void FillPatches(IList`1<PdfTensorProductBezierSurfaceInfo> patches, PdfRectangle bbox);
    private void DrawGradientLine(PointF startPoint, PointF endPoint, Color startColor, Color endColor);
}
internal class DevExpress.Pdf.Drawing.GraphicsAdapter : object {
    private Graphics graphics;
    public RectangleF ClipBounds { get; }
    public SmoothingMode SmoothingMode { get; public set; }
    public GraphicsAdapter(Graphics graphics);
    public sealed virtual RectangleF get_ClipBounds();
    public sealed virtual SmoothingMode get_SmoothingMode();
    public sealed virtual void set_SmoothingMode(SmoothingMode value);
    public sealed virtual void DrawImage(DXBitmap image, RectangleF rect);
    public sealed virtual void DrawImageUnscaled(DXBitmap image, Point point);
    public sealed virtual void DrawPath(Pen pen, GraphicsPath path);
    public sealed virtual void FillPath(Brush brush, GraphicsPath path);
}
public class DevExpress.Pdf.Drawing.GroupCollection`1 : object {
    private IPdfDocumentCommentViewModelCollection documentComments;
    private Func`2<IPdfDocumentCommentViewModel, TKey> keySelector;
    private string keyPropertyName;
    private Func`2<TKey, string> keyToViewConverter;
    private IComparer`1<TKey> comparer;
    private int lockChange;
    private int lockSourceCollectionRemove;
    [CompilerGeneratedAttribute]
private BindingList`1<IGroupWrapper> <Replies>k__BackingField;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public int Count { get; }
    public BindingList`1<IGroupWrapper> Replies { get; }
    public GroupCollection`1(IPdfDocumentCommentViewModelCollection collection, Expression`1<Func`2<IPdfDocumentCommentViewModel, TKey>> keyPropertyExcepression, Func`2<TKey, string> keyToViewConverter, IComparer`1<TKey> comparer);
    private static int BinarySearch(BindingList`1<IGroupWrapper> list, TKey value, IComparer`1<TKey> comparer);
    private static string GetKeyPropertyName(Expression expression);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual BindingList`1<IGroupWrapper> get_Replies();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void Remove(IPdfDocumentCommentViewModel item);
    private void ItemPropertyChanged(object sender, PropertyChangedEventArgs e);
    private void RemoveItem(IPdfDocumentCommentViewModel item);
    private bool RemoveFromSourceCollection(IPdfDocumentCommentViewModel item, bool lockChangeOnCallback);
    private void AddItem(IPdfDocumentCommentViewModel item);
    private void SourceCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.GroupWrapper`1 : object {
    private Func`2<TKey, string> keyToViewConverter;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private ObservableCollection`1<IPdfDocumentCommentViewModel> <Replies>k__BackingField;
    public TKey Key { get; }
    public ObservableCollection`1<IPdfDocumentCommentViewModel> Replies { get; }
    private object DevExpress.Pdf.Drawing.IGroupWrapper.Key { get; }
    public GroupWrapper`1(TKey key, ObservableCollection`1<IPdfDocumentCommentViewModel> comments, Func`2<TKey, string> keyToViewConverter);
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual ObservableCollection`1<IPdfDocumentCommentViewModel> get_Replies();
    private sealed virtual override object DevExpress.Pdf.Drawing.IGroupWrapper.get_Key();
    public virtual string ToString();
    public sealed virtual void OnItemChanged(IPdfDocumentCommentViewModel changedObject);
}
public interface DevExpress.Pdf.Drawing.IGroupCollection {
    public int Count { get; }
    public BindingList`1<IGroupWrapper> Replies { get; }
    public abstract virtual int get_Count();
    public abstract virtual BindingList`1<IGroupWrapper> get_Replies();
    public abstract virtual void Remove(IPdfDocumentCommentViewModel item);
}
public interface DevExpress.Pdf.Drawing.IGroupWrapper {
    public object Key { get; }
    public ObservableCollection`1<IPdfDocumentCommentViewModel> Replies { get; }
    public abstract virtual object get_Key();
    public abstract virtual ObservableCollection`1<IPdfDocumentCommentViewModel> get_Replies();
    public abstract virtual void OnItemChanged(IPdfDocumentCommentViewModel changedObject);
}
public interface DevExpress.Pdf.Drawing.INativeRenderer {
    public InterpolationMode InterpolationMode { get; public set; }
    public SmoothingMode SmoothingMode { get; public set; }
    public abstract virtual InterpolationMode get_InterpolationMode();
    public abstract virtual void set_InterpolationMode(InterpolationMode value);
    public abstract virtual SmoothingMode get_SmoothingMode();
    public abstract virtual void set_SmoothingMode(SmoothingMode value);
    public abstract virtual void Clear(Color color);
    public abstract virtual void TranslateTransform(float locationX, float locationY);
    public abstract virtual void RotateTransform(float value);
    public abstract virtual void PerformIsolatedOperation(Action action);
    public abstract virtual void FillRectangle(Color color, Rectangle rectangle);
    public abstract virtual void DrawCircle(Color color, float x, float y, float diameter);
    public abstract virtual void FillPath(Color color, GraphicsPath graphicsPath);
    public abstract virtual void DrawImage(Byte[] bitmapData, int bitmapWidth, int bitmapHeight, int stride, Point offset);
    public abstract virtual void DrawWithPalette(int bitmapWidth, int bitmapHeight, Color[] pallete, Action`1<INativeRenderer> action);
    public abstract virtual void DrawNonlinearGradientLine(Byte[] brushBitmapData, int brushBitmapWidth, int stride, PdfTransformationMatrix brushMatrix, PointF startPoint, PointF endPoint, float gradientBrushPenWidth);
    public abstract virtual void FillTriangles(PdfRenderingTriangle[] triangles);
    public abstract virtual void FillPatches(IList`1<PdfTensorProductBezierSurfaceInfo> patches, PdfRectangle bbox);
    public abstract virtual void DrawGradient(ColorBlend blend, PointF centerPoint, float radius);
}
public interface DevExpress.Pdf.Drawing.IPdfAnnotationController {
    public bool CanFocus { get; }
    public bool Focused { get; }
    public bool CanSelect { get; }
    public bool Selected { get; }
    public bool AcceptTabStop { get; }
    public bool PaintFocusRect { get; }
    public int PageIndex { get; }
    public PdfRectangle Bounds { get; }
    public IPdfAnnotationState AnnotationState { get; }
    public abstract virtual bool get_CanFocus();
    public abstract virtual bool get_Focused();
    public abstract virtual bool get_CanSelect();
    public abstract virtual bool get_Selected();
    public abstract virtual bool get_AcceptTabStop();
    public abstract virtual bool get_PaintFocusRect();
    public abstract virtual int get_PageIndex();
    public abstract virtual PdfRectangle get_Bounds();
    public abstract virtual IPdfAnnotationState get_AnnotationState();
    public abstract virtual bool HitTest(PdfPoint point, PdfViewerTool tool);
    public abstract virtual bool Focus();
    public abstract virtual bool Select();
    public abstract virtual IList`1<PdfPoint[]> GetSelectionPolygon();
    public abstract virtual void RemoveFromPage();
    public abstract virtual void Enter();
    public abstract virtual void GotFocus();
    public abstract virtual void LostFocus();
    public abstract virtual void MouseDown(PdfMouseAction action);
    public abstract virtual void MouseMove(PdfMouseAction action);
    public abstract virtual void MouseUp(PdfMouseAction action);
    public abstract virtual void MouseEnter();
    public abstract virtual void MouseLeave();
}
public interface DevExpress.Pdf.Drawing.IPdfCommentTreeViewModel {
    public IPdfDocumentCommentViewModel SelectedComment { get; public set; }
    public PdfCommentTreeFilterItems FilterItems { get; }
    public abstract virtual IPdfDocumentCommentViewModel get_SelectedComment();
    public abstract virtual void set_SelectedComment(IPdfDocumentCommentViewModel value);
    public abstract virtual PdfCommentTreeFilterItems get_FilterItems();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SelectedCommentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SelectedCommentChanged(EventHandler value);
    public abstract virtual IGroupCollection GetGroupCollection(PdfCommentSortMode sort, IPdfViewerLocalizationProvider provider, Action`1<int> progressChanged);
}
public interface DevExpress.Pdf.Drawing.IPdfDirectXVerticesListBuilder {
    public abstract virtual void AppendTriangle(PdfTensorProductBezierSurfacePoint p1, PdfTensorProductBezierSurfacePoint p2, PdfTensorProductBezierSurfacePoint p3, int patchId);
}
public interface DevExpress.Pdf.Drawing.IPdfDocumentCommentController {
    public PdfDocumentState DocumentState { get; }
    public IPdfViewerController ViewerController { get; }
    public abstract virtual PdfDocumentState get_DocumentState();
    public abstract virtual IPdfViewerController get_ViewerController();
    public abstract virtual void NotifySelectedCommentChanged(IPdfAnnotationStateComment comment);
}
public interface DevExpress.Pdf.Drawing.IPdfDocumentController {
    public IReadOnlyList`1<IPdfPageController> Pages { get; }
    public PdfDocumentState DocumentState { get; }
    public PdfSelectionState SelectionState { get; }
    public IPdfViewerController ViewerController { get; }
    public PdfCursor CurrentCursor { get; }
    public IPdfAnnotationController FocusedAnnotation { get; public set; }
    public IPdfAnnotationController SelectedAnnotation { get; public set; }
    public PdfTabNavigationController TabNavigationController { get; }
    public PdfTextSearch TextSearch { get; }
    public abstract virtual IReadOnlyList`1<IPdfPageController> get_Pages();
    public abstract virtual PdfDocumentState get_DocumentState();
    public abstract virtual PdfSelectionState get_SelectionState();
    public abstract virtual IPdfViewerController get_ViewerController();
    public abstract virtual PdfCursor get_CurrentCursor();
    public abstract virtual IPdfAnnotationController get_FocusedAnnotation();
    public abstract virtual void set_FocusedAnnotation(IPdfAnnotationController value);
    public abstract virtual IPdfAnnotationController get_SelectedAnnotation();
    public abstract virtual void set_SelectedAnnotation(IPdfAnnotationController value);
    public abstract virtual PdfTabNavigationController get_TabNavigationController();
    public abstract virtual PdfTextSearch get_TextSearch();
    public abstract virtual void AddTextMarkupAnnotation(PdfTextMarkupAnnotationType type);
    public abstract virtual void AddStickyNoteAnnotation(PdfDocumentPosition position);
    public abstract virtual void ShowToolTip(object owner, PdfToolTipSettings toolTipSettings, int delay);
    public abstract virtual void HideToolTip(object owner);
    public abstract virtual void ExecuteInteractiveOperation(PdfInteractiveOperation interactiveOperation);
    public abstract virtual void SelectAnnotation(int pageIndex, string annotationName);
    public abstract virtual void ClearContentSelection();
}
public interface DevExpress.Pdf.Drawing.IPdfDocumentEditHistoryItem {
    public abstract virtual void Redo();
    public abstract virtual void Undo();
}
public interface DevExpress.Pdf.Drawing.IPdfMarkupAnnotationController {
    public IPdfMarkupAnnotationState MarkupAnnotationState { get; }
    public abstract virtual IPdfMarkupAnnotationState get_MarkupAnnotationState();
    public abstract virtual PdfMarkupAnnotationPropertiesFormViewModel CreatePropertiesForm();
}
public interface DevExpress.Pdf.Drawing.IPdfPageController {
    public PdfDocumentController DocumentController { get; }
    public IReadOnlyList`1<IPdfAnnotationController> Annotations { get; }
    public abstract virtual PdfDocumentController get_DocumentController();
    public abstract virtual IReadOnlyList`1<IPdfAnnotationController> get_Annotations();
    public abstract virtual IPdfAnnotationController AddTextMarkupAnnotation(IPdfTextMarkupAnnotationBuilder builder);
    public abstract virtual IPdfAnnotationController AddStickyNoteAnnotation(IPdfTextAnnotationBuilder builder);
}
public interface DevExpress.Pdf.Drawing.IPdfPrintingCallbackProvider {
    public abstract virtual void RaisePrintPageEvent(PdfPrintPageEventArgs e);
    public abstract virtual void RaiseQueryPageSettingsEvent(PdfQueryPageSettingsEventArgs e);
}
public interface DevExpress.Pdf.Drawing.IPdfViewerController {
    public bool ReadOnly { get; }
    public bool SupportsRotatedEditors { get; }
    public bool SupportsSemiTransparentEditors { get; }
    public bool ResetSearchOnPageChange { get; }
    public int CurrentPageIndex { get; }
    public PdfViewerTool ViewerTool { get; }
    public SynchronizationContext SynchronizationContext { get; }
    public string DocumentFilePath { get; }
    public bool ShowPrintStatusDialog { get; }
    public Color SelectionColor { get; }
    public float DpiScale { get; }
    public float ZoomFactor { get; }
    public abstract virtual bool get_ReadOnly();
    public abstract virtual bool get_SupportsRotatedEditors();
    public abstract virtual bool get_SupportsSemiTransparentEditors();
    public abstract virtual bool get_ResetSearchOnPageChange();
    public abstract virtual int get_CurrentPageIndex();
    public abstract virtual PdfViewerTool get_ViewerTool();
    public abstract virtual SynchronizationContext get_SynchronizationContext();
    public abstract virtual string get_DocumentFilePath();
    public abstract virtual bool get_ShowPrintStatusDialog();
    public abstract virtual Color get_SelectionColor();
    public abstract virtual float get_DpiScale();
    public abstract virtual float get_ZoomFactor();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentPageIndexChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentPageIndexChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_EnsureVisibleCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EnsureVisibleCompleted(EventHandler value);
    public abstract virtual PdfPoint GetClientPoint(PdfDocumentPosition position);
    public abstract virtual void EnsureVisible(int pageIndex, PdfRectangle bounds, bool inCenter);
    public abstract virtual void SynchronizeWithMousePosition();
    public abstract virtual void ResetCursorToLastCommonCursor();
    public abstract virtual void CloseEditor();
    public abstract virtual void CommitEditor();
    public abstract virtual void RaiseSelectionStartedEvent(PdfDocumentPosition position);
    public abstract virtual void RaiseSelectionContinuedEvent(PdfDocumentPosition position);
    public abstract virtual void RaiseSelectionEndedEvent(PdfDocumentPosition position);
    public abstract virtual bool RaiseAnnotationCreatingEvent(IPdfViewerAnnotationBuilder builder);
    public abstract virtual void RaiseAnnotationCreatedEvent(IPdfViewerAnnotation info);
    public abstract virtual void RaiseAnnotationChangedEvent(IPdfViewerAnnotation info);
    public abstract virtual bool RaiseAnnotationChangingEvent(IPdfViewerAnnotation oldState, IPdfViewerAnnotation newState);
    public abstract virtual void RaiseAnnotationGotFocusEvent(IPdfViewerAnnotation info);
    public abstract virtual void RaiseAnnotationLostFocusEvent(IPdfViewerAnnotation info);
    public abstract virtual bool RaiseAnnotationDeletingEvent(IPdfViewerAnnotation info);
    public abstract virtual void RaiseAnnotationDeletedEvent(IPdfViewerAnnotation info);
    public abstract virtual void RaiseFormFieldGotFocus(string fieldName);
    public abstract virtual void RaiseFormFieldLostFocus(string fieldName);
    public abstract virtual bool RaiseFormFieldEditorShowing(string fieldName, object fieldValue);
    public abstract virtual void RaiseFormFieldEditorShown(string fieldName, object fieldValue);
    public abstract virtual void RaiseReplyCreatedEvent(IPdfViewerReply info);
    public abstract virtual void RaiseReplyChangedEvent(IPdfViewerReply info);
    public abstract virtual void RaiseReplyDeletedEvent(IPdfViewerReply info);
    public abstract virtual void ShowDocumentPosition(PdfTarget target);
    public abstract virtual void GoToPreviousPage();
    public abstract virtual void GoToNextPage();
    public abstract virtual void GoToFirstPage();
    public abstract virtual void GoToLastPage();
    public abstract virtual void ShowTooltip(PdfToolTipSettings tooltipSettings);
    public abstract virtual void HideTooltip();
    public abstract virtual Bitmap GetEditorBitmap(PdfEditorSettings settings);
    public abstract virtual bool ShellExecute(string filePath, string defaultDictionary, string parameters);
    public abstract virtual bool OpenDocument(string documentPath, PdfTarget target, bool openInNewWindow);
    public abstract virtual bool PromptURIConfirmation(Uri uri);
    public abstract virtual bool PromptFileAttachmentConfirmation(PdfFileAttachment attachment);
    public abstract virtual void StartTrustedProcess(string appName);
    public abstract virtual string SaveFileAttachment(PdfFileAttachment attachment);
    public abstract virtual PdfMarkupAnnotationDefaultSettings GetTextMarkupAnnotationSettings(PdfTextMarkupAnnotationType type);
    public abstract virtual PdfStickyNoteDefaultSettings GetStickyNoteAnnotationSettings();
    public abstract virtual void ShowPopupMenu(PdfPopupMenuContext context);
    public abstract virtual void ShowEditor(PdfEditorSettings editorSettings, IPdfViewerValueEditingCallBack editorCallback);
    public abstract virtual void ShowCommentEditor(IPdfDocumentCommentViewModel comment);
    public abstract virtual void ShowPrintDialog();
    public abstract virtual bool ShowMarkupAnnotationPropertiesDialog(IPdfMarkupAnnotationPropertiesFormViewModel viewModel);
    public abstract virtual void InvalidateView();
    public abstract virtual void InvalidateThumbnailsPage(int pageIndex);
    public abstract virtual void UpdateSelection();
}
public interface DevExpress.Pdf.Drawing.IPdfViewerGraphics {
    public RectangleF ClipBounds { get; }
    public SmoothingMode SmoothingMode { get; public set; }
    public abstract virtual RectangleF get_ClipBounds();
    public abstract virtual SmoothingMode get_SmoothingMode();
    public abstract virtual void set_SmoothingMode(SmoothingMode value);
    public abstract virtual void DrawImage(DXBitmap image, RectangleF rect);
    public abstract virtual void DrawImageUnscaled(DXBitmap image, Point point);
    public abstract virtual void DrawPath(Pen pen, GraphicsPath path);
    public abstract virtual void FillPath(Brush brush, GraphicsPath path);
}
public interface DevExpress.Pdf.Drawing.IPdfViewerLocalizationProvider {
    public abstract virtual string GetString(PdfViewerStringId stringId);
    public abstract virtual string GetString(PdfFilterAnnotationType type);
}
public interface DevExpress.Pdf.Drawing.IPdfViewerValueEditingCallBack {
    public abstract virtual void PostEditor(object value);
    public abstract virtual string ValidateEditor(object value);
    public abstract virtual void HideEditor();
}
public interface DevExpress.Pdf.Drawing.IRenderGlyphRunFont`1 {
    public bool IsSubstituted { get; }
    public abstract virtual bool get_IsSubstituted();
    public abstract virtual Double[] GetGlyphWidths(Int16[] str, double fontSize);
    public abstract virtual Int16[] GetGlyphIndices(PdfStringData data);
    public abstract virtual TRun CreateGlyphRun(Int16[] glyphIndices, Single[] glyphAdvances, PdfTransformationMatrix textTransform);
}
public interface DevExpress.Pdf.Drawing.IShadingColorConverter {
    public abstract virtual Color Convert(Double[] colorComponents);
}
public interface DevExpress.Pdf.Drawing.IShadingCoordsConverter {
    public abstract virtual PointF Convert(PdfPoint point);
}
public class DevExpress.Pdf.Drawing.PdfAlphaMaskBlender : PdfMaskBlender {
    private PdfAlphaMaskBlender(Bitmap targetBitmap, Bitmap sourceBitmap, PdfFunction transferFunction);
    public static void Blend(Bitmap targetBitmap, Bitmap sourceBitmap, PdfFunction transferFunction);
    protected virtual double GetSourceAlpha(Byte[] sourceData, int sourceOffset);
}
public class DevExpress.Pdf.Drawing.PdfAnnotationController`1 : PdfInteractiveElementController {
    private static PdfAnnotationFlags invisibilityFlags;
    [CompilerGeneratedAttribute]
private IPdfPageController <PageController>k__BackingField;
    [CompilerGeneratedAttribute]
private TState <AnnotationState>k__BackingField;
    private PdfDocumentPosition dragPosition;
    private bool dragStarted;
    private PdfCursor currentCursor;
    public bool CanFocus { get; }
    public bool CanSelect { get; }
    protected bool Selectable { get; }
    public bool PaintFocusRect { get; }
    public int PageIndex { get; }
    public PdfRectangle Bounds { get; }
    public bool AcceptTabStop { get; }
    public bool Focused { get; }
    public bool Selected { get; }
    protected IPdfPageController PageController { get; }
    protected PdfToolTipSettings ToolTip { get; }
    protected int ToolTipDelay { get; }
    protected bool CanDrag { get; }
    public TState AnnotationState { get; }
    private bool HiddenUsingFlags { get; }
    private IPdfAnnotationState DevExpress.Pdf.Drawing.IPdfAnnotationController.AnnotationState { get; }
    protected PdfAnnotationController`1(IPdfPageController pageController, TState state);
    private static PdfAnnotationController`1();
    public virtual bool get_CanFocus();
    public sealed virtual bool get_CanSelect();
    protected virtual bool get_Selectable();
    public virtual bool get_PaintFocusRect();
    public sealed virtual int get_PageIndex();
    public sealed virtual PdfRectangle get_Bounds();
    public virtual bool get_AcceptTabStop();
    public sealed virtual bool get_Focused();
    public sealed virtual bool get_Selected();
    [CompilerGeneratedAttribute]
protected IPdfPageController get_PageController();
    protected virtual PdfToolTipSettings get_ToolTip();
    protected virtual int get_ToolTipDelay();
    protected virtual bool get_CanDrag();
    [CompilerGeneratedAttribute]
public TState get_AnnotationState();
    private bool get_HiddenUsingFlags();
    private sealed virtual override IPdfAnnotationState DevExpress.Pdf.Drawing.IPdfAnnotationController.get_AnnotationState();
    protected virtual void OnAnnotationStateChanging(object sender, PdfAnnotationPropertyChangingEventArgs e);
    protected virtual void OnAnnotationStateChanged(object sender, PropertyChangedEventArgs e);
    protected void ClearSelectionAndFocus();
    public sealed virtual bool Focus();
    public sealed virtual bool Select();
    public sealed virtual void RemoveFromPage();
    protected virtual void OnGotFocus();
    protected virtual void OnLostFocus();
    protected virtual void OnMouseEnter();
    protected virtual void OnMouseLeave();
    protected virtual void OnMouseDown(PdfMouseAction action);
    protected virtual void OnMouseMove(PdfMouseAction action);
    protected virtual void OnMouseUp(PdfMouseAction action);
    protected virtual void OnClick();
    public sealed virtual bool HitTest(PdfPoint point, PdfViewerTool tool);
    protected virtual bool SupportsTool(PdfViewerTool tool);
    protected virtual bool Contains(PdfPoint point);
    private sealed virtual override IList`1<PdfPoint[]> DevExpress.Pdf.Drawing.IPdfAnnotationController.GetSelectionPolygon();
    private sealed virtual override void DevExpress.Pdf.Drawing.IPdfAnnotationController.GotFocus();
    private sealed virtual override void DevExpress.Pdf.Drawing.IPdfAnnotationController.LostFocus();
    private sealed virtual override void DevExpress.Pdf.Drawing.IPdfAnnotationController.Enter();
    public virtual PdfCursor GetCursor(PdfMouseAction action);
}
public class DevExpress.Pdf.Drawing.PdfAnnotationControllerFactory : PdfVisitorBasedFactory`2<IPdfAnnotationState, IPdfAnnotationController> {
    private IPdfPageController pageController;
    public PdfAnnotationControllerFactory(IPdfPageController pageController);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfCommonAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfLinkAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfWidgetAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(IPdfMarkupAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfTextMarkupAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfTextAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfFreeTextAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfRubberStampAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfSquareAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfCircleAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfPolygonAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfPolyLineAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfLineAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfSoundAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfFileAttachmentAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfInkAnnotationState state);
    protected virtual void Visit(IPdfAnnotationState input);
}
public abstract class DevExpress.Pdf.Drawing.PdfAnnotationPainter : object {
    private PdfRenderMode renderMode;
    private PdfOptionalContentViewState viewState;
    protected PdfRenderMode RenderMode { get; }
    protected PdfAnnotationPainter(PdfRenderMode renderMode, PdfOptionalContentViewState viewState);
    protected PdfRenderMode get_RenderMode();
    public void DrawAnnotationState(IPdfAnnotationState annotationState, PdfRgbaColor highlightedFormFieldColor);
    public void DrawComboBox(PdfWidgetAnnotationState state, IPdfViewerController controller, PdfRgbaColor highlightedFormFieldColor);
    protected abstract virtual void DrawBitmap(PdfTransformationMatrix matrix, PdfEditorSettings settings, IPdfViewerController controller, PdfRectangle annotationRect);
    protected abstract virtual void DrawForm(PdfTransformationMatrix matrix, PdfForm form);
}
public class DevExpress.Pdf.Drawing.PdfAnnotationStatePainter : object {
    private PdfAnnotationPainter painter;
    private IPdfViewerController controller;
    private PdfRgbaColor highlightedFormFieldColor;
    private PdfRenderMode renderMode;
    public PdfAnnotationStatePainter(PdfAnnotationPainter painter, PdfRenderMode renderMode, IPdfViewerController controller, PdfRgbaColor highlightedFormFieldColor);
    public void DrawAnnotationState(IPdfAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfWidgetAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfLinkAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfCommonAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(IPdfMarkupAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfTextAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfTextMarkupAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfFreeTextAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfRubberStampAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfSquareAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfCircleAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfPolygonAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfPolyLineAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfLineAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfSoundAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfFileAttachmentAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfInkAnnotationState state);
    private void DrawMarkupAnnotationState(IPdfMarkupAnnotationState state);
}
public class DevExpress.Pdf.Drawing.PdfAxialShadingPainter : PdfShadingPainter {
    private static double halfPI;
    private PdfAxialShading shading;
    private float axisStartX;
    private float axisStartY;
    private float axisEndX;
    private float axisEndY;
    private double axisAngle;
    private float locationX;
    private float locationY;
    private int shadingRasterizationWidth;
    private float shadingRasterizationScale;
    private float gradientBrushPenWidth;
    private int rotatedBitmapWidth;
    private int rotatedBitmapHeight;
    public PdfAxialShadingPainter(PdfAxialShading shading, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfTransformationMatrix matrix, int bitmapWidth, int bitmapHeight);
    private static Range CalculateRange(float value1, float value2, float value3, float value4);
    [SecuritySafeCriticalAttribute]
protected virtual void Paint(INativeRenderer renderer);
}
public static class DevExpress.Pdf.Drawing.PdfBackdropBitmapExtractor : object {
    private static string backingImageFieldName;
    private static FieldInfo backingImageFieldInfo;
    private static PdfBackdropBitmapExtractor();
    [SecuritySafeCriticalAttribute]
public static Bitmap GetBackdropBitmap(Graphics graphics, int x, int y, int width, int height);
}
public abstract class DevExpress.Pdf.Drawing.PdfBackdropImageBlender : PdfImageBlender {
    protected PdfBackdropImageBlender(Bitmap bitmap, Bitmap backdropBitmap);
    public static bool IsSupported(PdfBlendMode blendMode);
    public static void Blend(PdfBlendMode blendMode, Bitmap bitmap, Bitmap backdropBitmap);
    public static void Blend(PdfViewerCommandInterpreter interpreter, PdfRectangle boundingBox, Bitmap bitmap);
}
public class DevExpress.Pdf.Drawing.PdfBackdropMatrixCalculator : object {
    private static int rowsCount;
    private static int columnsCount;
    private Double[][] rows;
    private PdfBackdropMatrixCalculator(int x, int y, Int32[] destinationCoordinates, PointF[] points);
    public static Matrix CalculateTransformationMatrix(int x, int y, PointF[] points, Int32[] destinationCoordinates);
    private void Swap(int rowIndex);
    private Matrix Solve();
}
public class DevExpress.Pdf.Drawing.PdfBitmapShadingCoordsConverter : object {
    private PdfShading shading;
    private int bitmapWidth;
    private int bitmapHeight;
    public PdfBitmapShadingCoordsConverter(PdfShading shading, int bitmapWidth, int bitmapHeight);
    private sealed virtual override PointF DevExpress.Pdf.Drawing.IShadingCoordsConverter.Convert(PdfPoint point);
}
public class DevExpress.Pdf.Drawing.PdfButtonAnnotationController : PdfWidgetAnnotationController {
    public PdfButtonAnnotationController(IPdfPageController pageController, PdfWidgetAnnotationState widgetState);
    protected virtual void OnClick();
    protected virtual void OnMouseUp(PdfMouseAction action);
    private void Click();
    private void ChangeCheckBoxState();
    private void ChangeRadioButtonState();
}
public class DevExpress.Pdf.Drawing.PdfCommentTreeFilterItems : object {
    private Dictionary`2<string, int> authors;
    private IReadOnlyCollection`1<string> readonlyAuthors;
    [CompilerGeneratedAttribute]
private Dictionary`2<PdfFilterAnnotationType, int> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<PdfAnnotationReviewStatus, int> <Status>k__BackingField;
    public Dictionary`2<PdfFilterAnnotationType, int> Types { get; }
    public IReadOnlyCollection`1<string> Authors { get; }
    public Dictionary`2<PdfAnnotationReviewStatus, int> Status { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<PdfFilterAnnotationType, int> get_Types();
    public IReadOnlyCollection`1<string> get_Authors();
    [CompilerGeneratedAttribute]
public Dictionary`2<PdfAnnotationReviewStatus, int> get_Status();
    public void Clear();
    public void Add(IPdfDocumentCommentViewModel comment);
    public void Remove(IPdfDocumentCommentViewModel comment);
    private void Add(IPdfDocumentCommentViewModel comment, bool subscribeOnEvents);
    private void RepliesCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void AddReview(IPdfDocumentCommentViewModelReview review);
    private void RemoveReview(IPdfDocumentCommentViewModelReview review);
    private void ReviewsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void Remove(IPdfDocumentCommentViewModel comment, bool unsubscribeFromEvents);
    private void CommentPropertyChanging(object sender, PropertyChangingEventArgs e);
    private void CommentPropertyChanged(object sender, PropertyChangedEventArgs e);
    private void Add(Dictionary`2<T, int> d, T value);
    private void Remove(Dictionary`2<T, int> d, T value);
}
public class DevExpress.Pdf.Drawing.PdfCommentTreeViewModel : object {
    private IPdfDocumentCommentController commentController;
    private Lazy`1<PdfDocumentCommentViewModelCollection> comments;
    private IPdfAnnotationStateComment selectedComment;
    private Action`1<int> progressChanged;
    [CompilerGeneratedAttribute]
private EventHandler SelectedCommentChanged;
    public IPdfDocumentCommentViewModel SelectedComment { get; public set; }
    public PdfCommentTreeFilterItems FilterItems { get; }
    public PdfCommentTreeViewModel(IPdfDocumentCommentController commentController);
    public sealed virtual IPdfDocumentCommentViewModel get_SelectedComment();
    public sealed virtual void set_SelectedComment(IPdfDocumentCommentViewModel value);
    public sealed virtual PdfCommentTreeFilterItems get_FilterItems();
    [CompilerGeneratedAttribute]
public sealed virtual void add_SelectedCommentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SelectedCommentChanged(EventHandler value);
    private void CreateLazyComments();
    private IPdfDocumentCommentViewModel GetViewModel(IPdfAnnotationStateComment comment);
    public void ShowEditor(IPdfAnnotationStateComment comment);
    public void NotifySelectedAnnotationChanged(IPdfAnnotationStateComment comment);
    public sealed virtual IGroupCollection GetGroupCollection(PdfCommentSortMode sort, IPdfViewerLocalizationProvider provider, Action`1<int> progressChanged);
    public PdfDocumentCommentViewModelCollection GetComments();
    private void ProgressChanged(int pageIndex);
    [CompilerGeneratedAttribute]
private PdfDocumentCommentViewModelCollection <CreateLazyComments>b__13_0();
}
public class DevExpress.Pdf.Drawing.PdfCommonAnnotationController : PdfAnnotationController`1<IPdfAnnotationState> {
    public PdfCommonAnnotationController(IPdfPageController pageController, IPdfAnnotationState state);
}
public class DevExpress.Pdf.Drawing.PdfCoonsPatchPainter : PdfPatchMeshPainter {
    [CompilerGeneratedAttribute]
private IList`1<PdfTensorProductBezierSurfaceInfo> <Patches>k__BackingField;
    protected IList`1<PdfTensorProductBezierSurfaceInfo> Patches { get; }
    public PdfCoonsPatchPainter(PdfCoonsPatchMesh shading, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfTransformationMatrix matrix, int bitmapWidth, int bitmapHeight, PdfRectangle bbox);
    [CompilerGeneratedAttribute]
protected virtual IList`1<PdfTensorProductBezierSurfaceInfo> get_Patches();
}
public class DevExpress.Pdf.Drawing.PdfDirectXDocumentRenderer : PdfDocumentRenderer {
    private PdfGDIRenderingContext gdiContext;
    private PdfDirectXRenderingContext context;
    private bool isRenderStarting;
    public bool IsGdiPlusOnly { get; }
    public long ImageCacheSize { get; public set; }
    public IPdfRenderingFontInfoProvider GlyphWidthProvider { get; }
    public PdfDirectXDocumentRenderer(PdfDirectXRendererOptions options);
    public virtual bool get_IsGdiPlusOnly();
    public virtual long get_ImageCacheSize();
    public virtual void set_ImageCacheSize(long value);
    public virtual IPdfRenderingFontInfoProvider get_GlyphWidthProvider();
    public virtual void Dispose();
    public virtual void InvalidateFont(PdfFont font);
    public virtual DXBitmap CreateSelectionBitmap(PdfDocumentState documentState, PdfImageSelection imageSelection, float imageResolution);
    public virtual void ClearCaches();
    public virtual void RenderToBitmap(PdfPagePrintingInfo info, DXBitmap destinationBitmap);
    public virtual void InvalidateContentStreamCache(PdfPage page);
    protected virtual void RenderPageContent(PdfPageRenderingInfo rendereringInfo, IPdfViewerController controller);
    public virtual INativeDocumentPrinter CreateNativePrinter(DocumentPrinter printer, string documentName, bool showPrintStatusDialog);
    protected virtual IPolygonBooleanOperationProvider CreatePolygonBooleanOperationProvider();
}
[FlagsAttribute]
public enum DevExpress.Pdf.Drawing.PdfDirectXRendererFlags : Enum {
    public int value__;
    public static PdfDirectXRendererFlags None;
    public static PdfDirectXRendererFlags SupportsCaching;
    public static PdfDirectXRendererFlags ForceSoftwareRendering;
}
public class DevExpress.Pdf.Drawing.PdfDirectXRendererOptions : ValueType {
    [CompilerGeneratedAttribute]
private PdfDirectXRendererFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ImageCacheSizeInBytes>k__BackingField;
    public PdfDirectXRendererFlags Flags { get; }
    public long ImageCacheSizeInBytes { get; }
    public PdfDirectXRendererOptions(long imageCacheSizeInBytes, PdfDirectXRendererFlags flags);
    [CompilerGeneratedAttribute]
public PdfDirectXRendererFlags get_Flags();
    [CompilerGeneratedAttribute]
public long get_ImageCacheSizeInBytes();
}
public class DevExpress.Pdf.Drawing.PdfDirectXRenderingContext : object {
    private static int pageCacheLimit;
    private PdfDirectXRendererFlags flags;
    private PdfDirectXPageCache pageCache;
    private D3D11Context d3dContext;
    private D2D1Factory1 d2d1Factory;
    private D2D1Device d2d1Device;
    private D2D1DeviceContext d2d1Context;
    private WICImagingFactory wicFactory;
    private DirectWriteFontStorage fontCache;
    private PdfDirectXImageCache imageCache;
    private long imageCacheSizeInBytes;
    private bool disposed;
    public D3D11Context D3DContext { get; }
    public D2D1Factory1 D2D1Factory { get; }
    public D2D1Device D2D1Device { get; }
    public D2D1DeviceContext D2D1Context { get; }
    public WICImagingFactory WicFactory { get; }
    public PdfDirectXImageCache ImageCache { get; }
    internal DirectWriteFontStorage FontCache { get; }
    public long ImageCacheSize { get; public set; }
    private bool SupportsCaching { get; }
    private bool ForceSoftwareRendering { get; }
    public PdfDirectXRenderingContext(PdfDirectXRendererOptions options);
    [SecuritySafeCriticalAttribute]
private static void CopyToTiles(D3D11_MAPPED_SUBRESOURCE mappedSubresource, PdfPageTileInfoList tiles, PdfTransformationMatrix userToDeviceMatrix, Size viewportSize);
    [SecuritySafeCriticalAttribute]
private static void CopyToTiles(D3D11_MAPPED_SUBRESOURCE mappedSubresource, PdfPageTileInfoList tiles, PdfTransformationMatrix userToDeviceMatrix, int chunkTop, int chunkBottom);
    public D3D11Context get_D3DContext();
    public D2D1Factory1 get_D2D1Factory();
    public D2D1Device get_D2D1Device();
    public D2D1DeviceContext get_D2D1Context();
    public WICImagingFactory get_WicFactory();
    public PdfDirectXImageCache get_ImageCache();
    internal DirectWriteFontStorage get_FontCache();
    public long get_ImageCacheSize();
    public void set_ImageCacheSize(long value);
    private bool get_SupportsCaching();
    private bool get_ForceSoftwareRendering();
    private void Initialize();
    public void ClearCache();
    public PdfDirectXPage GetPage(PdfPage page, PdfOptionalContentViewState viewState);
    public IList`1<PdfDirectXObjectList> GetAnnotations(PdfPageRenderingInfoBase info, IPdfViewerController controller, PdfRgbaColor highlightedFormFieldColor);
    public void Reinitialize();
    public sealed virtual void Dispose();
    public void InvalidatePage(PdfPage page);
    public void InvalidateFont(PdfFont font);
    public D2D1PrintControl CreatePrintControl(PrintDocumentPackageTarget documentPackageTarget, D2D1_PRINT_CONTROL_PROPERTIES properties);
    [SecuritySafeCriticalAttribute]
public void Render(PdfPageRenderingInfo renderingInfo, IPdfViewerController controller);
    private static void CopyTextureToTiles(D3D11Context d3dContext, D3D11Texture2D texture, PdfPageTileInfoList tiles, PdfTransformationMatrix userToDeviceMatrix, int maxChunkSize);
    private void RenderToBitmap(PdfDirectXPageRenderingContext pageContext, D2D1Bitmap targetBitmap, PdfDirectXRenderTargetView viewInfo, PdfDirectXPage page, IList`1<PdfDirectXObjectList> annotations);
    public D2D1CommandList CreatePrintingCommandList(PdfPagePrintingInfo printingPageInfo, PdfDirectXPrintingProperties printProperties);
}
public class DevExpress.Pdf.Drawing.PdfDocumentController : object {
    private ToolStorage toolStorage;
    private PdfDataSelector dataSelector;
    private PdfTabNavigationController tabNavigationController;
    private IPdfAnnotationController focusedAnnotation;
    private IPdfAnnotationController selectedAnnotation;
    private PdfInteractiveElementController capturedElement;
    private bool mouseCaptured;
    [CompilerGeneratedAttribute]
private PdfMouseScrollSynchronizationController <ScrollController>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfCursor <CurrentCursor>k__BackingField;
    public static string SaveAttachmentPathKey;
    private PdfPageControllerStorage pages;
    private PdfToolTipController toolTipController;
    private PdfViewerLayoutInfoProvider layoutInfoProvider;
    private PdfInteractiveOperationController interactiveOperationController;
    private PdfCommentTreeViewModel commentTreeViewModel;
    private bool searchInProgress;
    private bool lockAnnotationChangeEvents;
    [CompilerGeneratedAttribute]
private PdfDocumentState <DocumentState>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfSelectionState <SelectionState>k__BackingField;
    [CompilerGeneratedAttribute]
private IPdfViewerController <ViewerController>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfDocumentEditHistory <History>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfTextSearch <TextSearch>k__BackingField;
    public PdfMouseScrollSynchronizationController ScrollController { get; }
    public PdfDataSelector DataSelector { get; }
    public PdfTabNavigationController TabNavigationController { get; }
    public IPdfAnnotationController FocusedAnnotation { get; public set; }
    public IPdfAnnotationController SelectedAnnotation { get; public set; }
    private PdfMouseToolController CurrentTool { get; }
    public PdfCursor CurrentCursor { get; private set; }
    public PdfDocumentState DocumentState { get; }
    public PdfSelectionState SelectionState { get; }
    public IReadOnlyList`1<IPdfPageController> Pages { get; }
    public IPdfViewerController ViewerController { get; }
    public IReadOnlyCollection`1<string> DestinationNames { get; }
    public IReadOnlyList`1<PdfViewerBookmark> Bookmarks { get; }
    public PdfDocumentEditHistory History { get; }
    public PdfTextSearch TextSearch { get; }
    public IPdfCommentTreeViewModel CommentTreeViewModel { get; }
    public bool CanShowAnnotationPropertiesDialog { get; }
    public PdfDocumentController(IPdfViewerController viewerController, PdfDocumentState documentState, IPdfRenderingFontInfoProvider widthProvider);
    [CompilerGeneratedAttribute]
public PdfMouseScrollSynchronizationController get_ScrollController();
    public PdfDataSelector get_DataSelector();
    public sealed virtual PdfTabNavigationController get_TabNavigationController();
    public sealed virtual IPdfAnnotationController get_FocusedAnnotation();
    public sealed virtual void set_FocusedAnnotation(IPdfAnnotationController value);
    public sealed virtual IPdfAnnotationController get_SelectedAnnotation();
    public sealed virtual void set_SelectedAnnotation(IPdfAnnotationController value);
    private PdfMouseToolController get_CurrentTool();
    [CompilerGeneratedAttribute]
public sealed virtual PdfCursor get_CurrentCursor();
    [CompilerGeneratedAttribute]
private void set_CurrentCursor(PdfCursor value);
    public void MouseDown(PdfMouseAction action);
    public void MouseMove(PdfMouseAction action);
    public void MouseUp(PdfMouseAction action);
    private IPdfAnnotationController GetAnnotation(PdfMouseAction action);
    private void UpdateHandler(PdfMouseAction action, bool mouseDown);
    private void UpdateCursor(PdfMouseAction action);
    public void MouseEnter();
    public void MouseLeave();
    public void TabForward();
    public void TabBackward();
    private bool SetFocus(IPdfAnnotationController annotation);
    [CompilerGeneratedAttribute]
public sealed virtual PdfDocumentState get_DocumentState();
    [CompilerGeneratedAttribute]
public sealed virtual PdfSelectionState get_SelectionState();
    public sealed virtual IReadOnlyList`1<IPdfPageController> get_Pages();
    [CompilerGeneratedAttribute]
public sealed virtual IPdfViewerController get_ViewerController();
    public IReadOnlyCollection`1<string> get_DestinationNames();
    public IReadOnlyList`1<PdfViewerBookmark> get_Bookmarks();
    [CompilerGeneratedAttribute]
public PdfDocumentEditHistory get_History();
    [CompilerGeneratedAttribute]
public sealed virtual PdfTextSearch get_TextSearch();
    public IPdfCommentTreeViewModel get_CommentTreeViewModel();
    public bool get_CanShowAnnotationPropertiesDialog();
    private void OnSelectionChanged(object sender, EventArgs e);
    private void OnPageInvalidate(object sender, PdfPageStateInvalidateEventArgs e);
    private void OnViewerPageIndexChanged(object sender, EventArgs e);
    private void OnViewerEnsureVisibilityCompleted(object sender, EventArgs e);
    private void OnSelectionStarted(object sender, PdfDataSelectionEventArgs e);
    private void OnSelectionContinued(object sender, PdfDataSelectionEventArgs e);
    private void OnSelectionEnded(object sender, PdfDataSelectionEventArgs e);
    public void AddStickyNoteAnnotation(PdfDocumentPosition position, string comment, Color color);
    public void AddStickyNoteAnnotation(PdfDocumentPosition position, string comment);
    public sealed virtual void AddStickyNoteAnnotation(PdfDocumentPosition position);
    private void AddStickyNoteAnnotation(PdfTextAnnotationSettings settings);
    public sealed virtual void AddTextMarkupAnnotation(PdfTextMarkupAnnotationType type);
    public void AddTextMarkupAnnotation(PdfTextMarkupAnnotationType type, string comment);
    public void AddTextMarkupAnnotation(PdfTextMarkupAnnotationType type, string comment, Color color);
    private void AddTextMarkupAnnotation(PdfTextMarkupAnnotationSettings settings);
    public PdfTextSearchResults FindText(string text, PdfTextSearchParameters parameters, int newSearchStartPage, Func`2<int, bool> terminate);
    public sealed virtual void ClearContentSelection();
    public void ClearSelection();
    public void RemoveSelectedAnnotation();
    public void SubmitFocus();
    public void ShowCommentEditor(IPdfAnnotationStateComment comment);
    public sealed virtual void Dispose();
    public sealed virtual void HideToolTip(object owner);
    public sealed virtual void ShowToolTip(object owner, PdfToolTipSettings toolTipSettings, int delayInMilliseconds);
    public sealed virtual void SelectAnnotation(int pageIndex, string annotationName);
    public void OpenFileAttachment(PdfFileAttachment attachment);
    public void SaveFileAttachment(PdfFileAttachment attachment);
    private void SaveFileAttachment(string path, PdfFileAttachment attachment);
    public void CommitCurrentEditor();
    public sealed virtual void ExecuteInteractiveOperation(PdfInteractiveOperation interactiveOperation);
    public void ShowAnnotationPropertiesDialog();
    public void AnnotationChanged(IPdfViewerAnnotation annotation);
    public bool AnnotationChanging(IPdfViewerAnnotation oldState, IPdfViewerAnnotation newState);
    public void ReplyChanged(IPdfViewerReply reply);
    public void ReplyDeleted(IPdfViewerReply reply);
    public void ReplyCreated(IPdfViewerReply reply);
    public void ShowAnnotationPropertiesDialog(PdfMarkupAnnotationPropertiesFormViewModel form);
    public PdfDocumentContent GetContentInfo(PdfDocumentPosition position);
    public void GoToBookmark(PdfViewerBookmark bookmark);
    public bool GoToDestination(string destinationName);
    private sealed virtual override void DevExpress.Pdf.Drawing.IPdfDocumentCommentController.NotifySelectedCommentChanged(IPdfAnnotationStateComment comment);
}
public class DevExpress.Pdf.Drawing.PdfDocumentEditHistory : object {
    private static int maxItemCount;
    private Stack`1<IPdfDocumentEditHistoryItem> undoStack;
    private Stack`1<IPdfDocumentEditHistoryItem> redoStack;
    public bool CanUndo { get; }
    public bool CanRedo { get; }
    public bool get_CanUndo();
    public bool get_CanRedo();
    public void Register(IPdfDocumentEditHistoryItem item);
    public void Redo();
    public void Undo();
    public void Clear();
}
public abstract class DevExpress.Pdf.Drawing.PdfDocumentEditHistoryItem : object {
    public abstract virtual void Redo();
    public abstract virtual void Undo();
}
public abstract class DevExpress.Pdf.Drawing.PdfDocumentRenderer : object {
    private PdfPageTextureCache`1<DXBitmap> pageCache;
    private Lazy`1<IPolygonBooleanOperationProvider> polygonBooleanOperationProvider;
    public long ImageCacheSize { get; public set; }
    public bool IsGdiPlusOnly { get; }
    public IPdfRenderingFontInfoProvider GlyphWidthProvider { get; }
    public IPolygonBooleanOperationProvider PolygonBooleanOperationProvider { get; }
    protected PdfPageTextureCache`1<DXBitmap> PageCache { get; }
    private static RectangleF ConvertToDeviceRectangle(PdfTransformationMatrix matrix, PdfRectangle rectangle);
    private static int Round(double value);
    public abstract virtual long get_ImageCacheSize();
    public abstract virtual void set_ImageCacheSize(long value);
    public abstract virtual bool get_IsGdiPlusOnly();
    public abstract virtual IPdfRenderingFontInfoProvider get_GlyphWidthProvider();
    public IPolygonBooleanOperationProvider get_PolygonBooleanOperationProvider();
    protected PdfPageTextureCache`1<DXBitmap> get_PageCache();
    public abstract virtual DXBitmap CreateSelectionBitmap(PdfDocumentState documentState, PdfImageSelection selection, float imageResolution);
    public abstract virtual void InvalidateFont(PdfFont font);
    public abstract virtual INativeDocumentPrinter CreateNativePrinter(DocumentPrinter printer, string documentName, bool showPrintStatusDialog);
    protected abstract virtual void RenderPageContent(PdfPageRenderingInfo rendereringInfo, IPdfViewerController controller);
    public abstract virtual void RenderToBitmap(PdfPagePrintingInfo info, DXBitmap destinationBitmap);
    public virtual void InvalidateContentStreamCache(PdfPage page);
    public void InvalidateBitmapCache(int pageIndex, PdfRectangle rect);
    public virtual void ClearCaches();
    public virtual void Dispose();
    protected abstract virtual IPolygonBooleanOperationProvider CreatePolygonBooleanOperationProvider();
    public void RenderPage(PdfPageState pageState, Graphics graphics, PointF offset, float scale, IPdfViewerController viewerController);
    public void RenderPage(PdfPageState pageState, IPdfViewerGraphics graphics, PointF offset, float scale, IPdfViewerController viewerController);
    public void BeginDrawing();
    public void EndRenderPages();
    public void ClearPageCache();
    [CompilerGeneratedAttribute]
private IPolygonBooleanOperationProvider <.ctor>b__15_0();
}
public class DevExpress.Pdf.Drawing.PdfDocumentState : PdfDocumentStateBase {
    public IReadOnlyCollection`1<string> DestinationNames { get; }
    public IDictionary`2<string, PdfDestination> NamedDestinations { get; }
    public PdfDocumentState(PdfDocument document, IPdfPlatformServiceProvider serviceProvider);
    public IReadOnlyCollection`1<string> get_DestinationNames();
    public IDictionary`2<string, PdfDestination> get_NamedDestinations();
    public void SetFilter(PdfCommentFilter filter);
}
public static class DevExpress.Pdf.Drawing.PdfDocumentWritingHelper : object {
    private static Stream GetUnderlyingStream(Stream stream);
    private static void DeleteFile(string path);
    private static FileStream WriteUsingTempFile(string path, PdfDocument document, PdfSaveOptions options, bool detachStream, Stream previousDocumentStream, Action`1<int> progressChanged);
    private static FileStream WriteDirect(string path, PdfDocument document, PdfSaveOptions options, bool detachStream, Stream previousDocumentStream, Action`1<int> progressChanged);
    public static FileStream Write(string path, PdfDocument document, PdfSaveOptions options, bool detachStream, Stream previousDocumentStream, Action`1<int> progressChanged);
    private static PdfObjectCollection WriteDocument(FileStream stream, PdfDocument document, PdfSaveOptions options, bool detachStream, Stream previousDocumentStream, Action`1<int> progressChanged);
    private static FileStream FinishWrite(string path, PdfDocument document, PdfObjectCollection objects, bool detachStream);
    public static void Write(Stream stream, PdfDocument document, PdfSaveOptions options, bool detachStream, Action`1<int> progressChanged);
}
public class DevExpress.Pdf.Drawing.PdfFileAttachmentAnnotationController : PdfMarkupAnnotationController`1<PdfFileAttachmentAnnotationState> {
    protected int ToolTipDelay { get; }
    public bool AcceptTabStop { get; }
    protected PdfToolTipSettings ToolTip { get; }
    public PdfFileAttachmentAnnotationController(IPdfPageController page, PdfFileAttachmentAnnotationState annotationState);
    protected virtual int get_ToolTipDelay();
    public virtual bool get_AcceptTabStop();
    protected virtual PdfToolTipSettings get_ToolTip();
    protected virtual void OnMouseUp(PdfMouseAction action);
    protected virtual void OnClick();
}
public class DevExpress.Pdf.Drawing.PdfFileOverwriteException : Exception {
    public PdfFileOverwriteException(Exception e);
}
public class DevExpress.Pdf.Drawing.PdfFillPathInfo : object {
    private GraphicsPath graphicsPath;
    private GraphicsPath strokePath;
    public GraphicsPath GraphicsPath { get; }
    public GraphicsPath StrokePath { get; }
    public PdfFillPathInfo(GraphicsPath graphicsPath, GraphicsPath strokePath);
    public GraphicsPath get_GraphicsPath();
    public GraphicsPath get_StrokePath();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.PdfFunctionDomainConverter : object {
    private double domainMin;
    private double domainMax;
    private double domainSize;
    public PdfFunctionDomainConverter(PdfRange functionDomain);
    private sealed virtual override Color DevExpress.Pdf.Drawing.IShadingColorConverter.Convert(Double[] colorComponents);
}
public class DevExpress.Pdf.Drawing.PdfGDIAnnotationPainter : PdfAnnotationPainter {
    private PdfViewerCommandInterpreter interpreter;
    private IEnumerable`1<IPdfAnnotationState> annotationsStates;
    public PdfGDIAnnotationPainter(PdfViewerCommandInterpreter interpreter, PdfRenderMode renderMode, IEnumerable`1<IPdfAnnotationState> annotationsStates, PdfOptionalContentViewState viewState);
    public void DrawAnnotations();
    public void DrawViewerAnnotations(PdfRgbaColor highlightColor, IPdfViewerController controller);
    protected virtual void DrawBitmap(PdfTransformationMatrix matrix, PdfEditorSettings settings, IPdfViewerController controller, PdfRectangle annotationRect);
    protected virtual void DrawForm(PdfTransformationMatrix matrix, PdfForm form);
}
public class DevExpress.Pdf.Drawing.PdfGdiBrush : PdfDisposableObject {
    private Bitmap bitmap;
    private Brush brush;
    public Brush Brush { get; }
    private PdfGdiBrush(Bitmap bitmap, Brush brush);
    public PdfGdiBrush(PdfViewerCommandInterpreter interpreter, PdfColor color, double alphaConstant);
    public Brush get_Brush();
    private TextureBrush CreateTextureBrush(double alphaConstant);
    public PdfGdiBrush Clone();
    protected virtual void Dispose(bool disposing);
}
public class DevExpress.Pdf.Drawing.PdfGDIDocumentRenderer : PdfDocumentRenderer {
    private PdfGDIRenderingContext context;
    public bool IsGdiPlusOnly { get; }
    public long ImageCacheSize { get; public set; }
    public IPdfRenderingFontInfoProvider GlyphWidthProvider { get; }
    public PdfGDIDocumentRenderer(long cacheCapacity);
    public virtual bool get_IsGdiPlusOnly();
    public virtual long get_ImageCacheSize();
    public virtual void set_ImageCacheSize(long value);
    public virtual IPdfRenderingFontInfoProvider get_GlyphWidthProvider();
    public virtual void Dispose();
    public virtual void InvalidateFont(PdfFont font);
    public void RenderPageContentBuffered(PdfPageRenderingInfoBase info, PointF offset, Graphics graphics, Rectangle targetRectangle);
    public void RenderPageContentDirect(PdfPageRenderingInfoBase info, PointF offset, Graphics graphics, Rectangle targetRectangle);
    protected virtual void RenderPageContent(PdfPageRenderingInfo renderingInfo, IPdfViewerController controller);
    public virtual DXBitmap CreateSelectionBitmap(PdfDocumentState documentState, PdfImageSelection imageSelection, float imageResolution);
    public virtual void ClearCaches();
    public virtual INativeDocumentPrinter CreateNativePrinter(DocumentPrinter printer, string documentName, bool showPrintStatusDialog);
    public virtual void RenderToBitmap(PdfPagePrintingInfo info, DXBitmap destinationBitmap);
    protected virtual IPolygonBooleanOperationProvider CreatePolygonBooleanOperationProvider();
}
public class DevExpress.Pdf.Drawing.PdfGDIRenderingContext : object {
    [CompilerGeneratedAttribute]
private GDIImageCache <ImageCache>k__BackingField;
    [CompilerGeneratedAttribute]
private GDIFontStorage <FontStorage>k__BackingField;
    internal GDIImageCache ImageCache { get; }
    internal GDIFontStorage FontStorage { get; }
    public PdfGDIRenderingContext(long imageCacheSizeInBytes);
    [SecuritySafeCriticalAttribute]
private static void RenderToTiles(PdfPageRenderingInfo rendereringInfo, BufferedGraphics bufferedGraphics);
    [CompilerGeneratedAttribute]
internal GDIImageCache get_ImageCache();
    [CompilerGeneratedAttribute]
internal GDIFontStorage get_FontStorage();
    public sealed virtual void Dispose();
    public void RenderPageContentBuffered(PdfPageRenderingInfoBase info, PointF offset, Graphics graphics, Rectangle targetRectangle);
    public void RenderPageContentDirect(PdfPageRenderingInfoBase info, PointF offset, Graphics graphics, Rectangle targetRectangle);
    private void RenderInteractiveLayer(PdfPageRenderingInfoBase info, Graphics graphics, PointF offset, PdfRgbaColor actualHighlightColor, IPdfViewerController viewerController);
    public void RenderViewerPage(PdfPageRenderingInfo renderingInfo, IPdfViewerController controller);
    private void RenderPageContentBuffered(PdfPageRenderingInfoBase info, PointF offset, Rectangle targetRectangle, bool drawAnnotations, Action`1<BufferedGraphics> graphicsAction);
    private void DrawContent(PdfPageRenderingInfoBase info, Graphics graphics, PointF offset, bool drawAnnotations);
}
public class DevExpress.Pdf.Drawing.PdfGouraudShadedTriangleMeshPainter : PdfMeshShadingPainter {
    private PdfRenderingTriangle[] triangles;
    public PdfGouraudShadedTriangleMeshPainter(PdfGouraudShadedTriangleMesh shading, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfTransformationMatrix matrix, int bitmapWidth, int bitmapHeight);
    protected virtual void DrawMesh(INativeRenderer renderer);
}
public class DevExpress.Pdf.Drawing.PdfGraphicsPathBuilder : object {
    private PdfViewerCommandInterpreter interpreter;
    private bool shouldUseRectangularGraphicsPath;
    public PdfGraphicsPathBuilder(PdfViewerCommandInterpreter interpreter);
    private static bool ComparePoints(PointF p1, PointF p2);
    public PdfFillPathInfo CreateFillPath(IEnumerable`1<PdfGraphicsPath> paths);
    public GraphicsPath CreatePath(PdfGraphicsPath path, double extendSize);
    public RectangleF CreateRectangle(PdfGraphicsPath path);
    private void AppendBezier(GraphicsPath graphicsPath, PointF startPoint, PointF endPoint, PdfBezierGraphicsPathSegment segment);
    private void AppendLine(GraphicsPath strokePath, PointF startPoint, PointF endPoint);
    private void AppendPath(GraphicsPath graphicsPath, PdfGraphicsPath path, GraphicsPath strokePath);
    private void AppendExtendLine(GraphicsPath graphicsPath, PdfPoint startPoint, PdfPoint endPoint, double size, bool fromLeft);
}
public class DevExpress.Pdf.Drawing.PdfHandToolController : PdfMouseToolController {
    public PdfHandToolController(PdfDocumentController documentController);
    public virtual PdfCursor GetCursor(PdfMouseAction action);
}
public abstract class DevExpress.Pdf.Drawing.PdfImageBlender : PdfDisposableObject {
    private static int componentsCount;
    private Bitmap targetBitmap;
    private Bitmap sourceBitmap;
    private int bitmapWidth;
    private int bitmapHeight;
    private int targetBitmapStride;
    private int targetDataLength;
    private Byte[] targetData;
    private int sourceBitmapStride;
    private int sourceDataLength;
    private Byte[] sourceData;
    private BitmapData targetBitmapData;
    private BitmapData sourceBitmapData;
    [SecuritySafeCriticalAttribute]
protected PdfImageBlender(Bitmap targetBitmap, Bitmap sourceBitmap);
    [SecuritySafeCriticalAttribute]
protected void Blend();
    [SecuritySafeCriticalAttribute]
private void ReleaseBitmaps();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void BlendPixel(Byte[] targetData, Byte[] sourceData, int targetOffset, int sourceOffset);
}
public static class DevExpress.Pdf.Drawing.PdfImageSelectionBitmapCreator : object {
    private static PdfTransformationMatrix imageSpaceInversionMatrix;
    private static PdfPoint[] imagePoints;
    private static PdfImageSelectionBitmapCreator();
    private static PdfTransformationMatrix CreateImageFullTransform(PdfTransformationMatrix imageTransform, PdfTransformationMatrix deviceTransform);
    private static PdfTransformationMatrix CreateDeviceTransform(PdfPage page, int rotationAngle, double scale, PdfRectangle targetUserSpaceRect);
    public static DXBitmap GetGdiSelectionBitmap(PdfGDIRenderingContext context, PdfPage page, PdfImageSelection imageSelection, int rotationAngle, float dpi);
}
public class DevExpress.Pdf.Drawing.PdfInplaceEditWidgetAnnotationController : PdfWidgetAnnotationController {
    public bool PaintFocusRect { get; }
    private bool CanOpenEditorInReadOnlyMode { get; }
    public PdfInplaceEditWidgetAnnotationController(IPdfPageController pageController, PdfWidgetAnnotationState widgetState);
    public virtual bool get_PaintFocusRect();
    private bool get_CanOpenEditorInReadOnlyMode();
    private void OnWidgetStatePropertyChanged(object sender, PropertyChangedEventArgs e);
    private void OnDocumentStateChanged(object sender, PropertyChangedEventArgs e);
    private void ShowEditor();
    protected virtual void OnGotFocus();
    protected virtual void OnLostFocus();
    protected virtual void OnMouseDown(PdfMouseAction action);
    protected virtual void OnClick();
    private void CloseEditor();
    private sealed virtual override void DevExpress.Pdf.Drawing.IPdfViewerValueEditingCallBack.PostEditor(object value);
    private sealed virtual override void DevExpress.Pdf.Drawing.IPdfViewerValueEditingCallBack.HideEditor();
    private sealed virtual override string DevExpress.Pdf.Drawing.IPdfViewerValueEditingCallBack.ValidateEditor(object value);
}
public class DevExpress.Pdf.Drawing.PdfInteractiveElementController : object {
    [CompilerGeneratedAttribute]
private PdfDocumentController <DocumentController>k__BackingField;
    protected PdfDocumentController DocumentController { get; }
    protected PdfInteractiveElementController(PdfDocumentController documentController);
    [CompilerGeneratedAttribute]
protected PdfDocumentController get_DocumentController();
    public sealed virtual void MouseDown(PdfMouseAction action);
    public sealed virtual void MouseMove(PdfMouseAction action);
    public sealed virtual void MouseUp(PdfMouseAction action);
    public sealed virtual void MouseEnter();
    public sealed virtual void MouseLeave();
    protected virtual void OnMouseDown(PdfMouseAction action);
    protected virtual void OnMouseMove(PdfMouseAction action);
    protected virtual void OnMouseUp(PdfMouseAction action);
    protected virtual void OnMouseEnter();
    protected virtual void OnMouseLeave();
    public virtual PdfCursor GetCursor(PdfMouseAction action);
    protected virtual PdfPopupMenuContext GetPopupMenuContext(PdfMouseAction action);
}
public class DevExpress.Pdf.Drawing.PdfInteractiveOperationController : object {
    private IPdfDocumentController documentController;
    private bool isContinueExecuting;
    private IPdfViewerController ViewerController { get; }
    private int CurrentPageIndex { get; }
    public PdfInteractiveOperationController(IPdfDocumentController documentController);
    private IPdfViewerController get_ViewerController();
    private int get_CurrentPageIndex();
    public sealed virtual void ShowDocumentPosition(PdfTarget target);
    public void ExecuteInteractiveOperation(PdfInteractiveOperation interactiveOperation);
    private void ExecuteAllActions(PdfAction action, List`1<PdfAction> executedAction);
    private void UpdateTabNavigationPage();
    private void ResetField(IPdfFormFieldProvider state);
    private bool ContainsField(IEnumerable`1<PdfInteractiveFormField> fields, PdfInteractiveFormField interactiveFormField);
    private void PerformResetFields(Action`1<IPdfFormFieldProvider> action);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.GoToPreviousPage();
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.GoToNextPage();
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.GoToFirstPage();
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.GoToLastPage();
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.OpenUri(string uriValue);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.OpenDocument(string documentPath, PdfTarget target, bool openInNewWindow);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.ShellExecute(string filePath, string defaultDirectory, string parameters);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.ShowPrintDialog();
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.ResetFormFields(IEnumerable`1<PdfInteractiveFormField> fields);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.ResetFormExcludingFields(IEnumerable`1<PdfInteractiveFormField> fields);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfInteractiveOperationController.ResetForm();
    [CompilerGeneratedAttribute]
private void <DevExpress.Pdf.Native.IPdfInteractiveOperationController.ResetForm>b__24_0(IPdfFormFieldProvider controller);
}
public class DevExpress.Pdf.Drawing.PdfInteractiveOperationProviderFactory : PdfVisitorBasedFactory`2<IPdfAnnotationState, IPdfFormFieldProvider> {
    protected virtual void Visit(IPdfAnnotationState input);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfWidgetAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(IPdfMarkupAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfTextMarkupAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfLinkAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfCommonAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfTextAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfFreeTextAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfRubberStampAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfSquareAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfCircleAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfPolygonAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfPolyLineAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfLineAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfSoundAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfFileAttachmentAnnotationState state);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfAnnotationStateVisitor.Visit(PdfInkAnnotationState state);
}
public class DevExpress.Pdf.Drawing.PdfLineAnnotationController : PdfMarkupAnnotationController`1<PdfLineAnnotationState> {
    public PdfLineAnnotationController(IPdfPageController page, PdfLineAnnotationState annotationState);
}
public class DevExpress.Pdf.Drawing.PdfLinkAnnotationController : PdfAnnotationController`1<PdfLinkAnnotationState> {
    protected int ToolTipDelay { get; }
    public bool AcceptTabStop { get; }
    protected PdfToolTipSettings ToolTip { get; }
    public PdfLinkAnnotationController(IPdfPageController page, PdfLinkAnnotationState annotationState);
    protected virtual int get_ToolTipDelay();
    public virtual bool get_AcceptTabStop();
    protected virtual PdfToolTipSettings get_ToolTip();
    protected virtual void OnMouseUp(PdfMouseAction action);
    protected virtual void OnClick();
}
public class DevExpress.Pdf.Drawing.PdfLuminosityMaskBlender : PdfMaskBlender {
    private PdfLuminosityMaskBlender(Bitmap targetBitmap, Bitmap sourceBitmap, PdfFunction transferFunction);
    public static void Blend(Bitmap targetBitmap, Bitmap sourceBitmap, PdfFunction transferFunction);
    protected virtual double GetSourceAlpha(Byte[] sourceData, int sourceOffset);
}
public class DevExpress.Pdf.Drawing.PdfMarkupAnnotationController : PdfMarkupAnnotationController`1<IPdfMarkupAnnotationState> {
    protected internal PdfMarkupAnnotationController(IPdfPageController page, IPdfMarkupAnnotationState annotationState, bool canDrag);
}
public class DevExpress.Pdf.Drawing.PdfMarkupAnnotationController`1 : PdfAnnotationController`1<T> {
    private bool canDrag;
    private List`1<PdfReplyController> replyControllers;
    protected bool Selectable { get; }
    protected bool CanDrag { get; }
    private IPdfMarkupAnnotationState DevExpress.Pdf.Drawing.IPdfMarkupAnnotationController.MarkupAnnotationState { get; }
    public bool AcceptTabStop { get; }
    protected PdfToolTipSettings ToolTip { get; }
    protected internal PdfMarkupAnnotationController`1(IPdfPageController page, T annotationState, bool canDrag);
    protected virtual bool get_Selectable();
    protected virtual bool get_CanDrag();
    private sealed virtual override IPdfMarkupAnnotationState DevExpress.Pdf.Drawing.IPdfMarkupAnnotationController.get_MarkupAnnotationState();
    public virtual bool get_AcceptTabStop();
    protected virtual PdfToolTipSettings get_ToolTip();
    private void OnReviewsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnRepliesChanged(object sender, NotifyCollectionChangedEventArgs e);
    public sealed virtual PdfMarkupAnnotationPropertiesFormViewModel CreatePropertiesForm();
    protected virtual void OnAnnotationStateChanged(object sender, PropertyChangedEventArgs e);
    protected virtual void OnMouseDown(PdfMouseAction action);
    protected virtual void OnClick();
    protected virtual bool SupportsTool(PdfViewerTool tool);
    protected virtual PdfPopupMenuContext GetPopupMenuContext(PdfMouseAction action);
    private void ShowCommentEditor();
    [CompilerGeneratedAttribute]
private PdfReplyController <.ctor>b__12_0(IPdfAnnotationStateComment r);
}
public static class DevExpress.Pdf.Drawing.PdfMarkupAnnotationControllerFactory : object {
    public static IPdfAnnotationController Create(IPdfPageController page, PdfTextAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfTextMarkupAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfRubberStampAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfCircleAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfSquareAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfInkAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfLineAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfSoundAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfFileAttachmentAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfPolyLineAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, PdfPolygonAnnotationState state);
    public static IPdfAnnotationController Create(IPdfPageController page, IPdfMarkupAnnotationState state);
}
public class DevExpress.Pdf.Drawing.PdfMarkupAnnotationDefaultSettings : object {
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    public Color Color { get; }
    public string Author { get; }
    public string Subject { get; }
    public PdfMarkupAnnotationDefaultSettings(Color color, string author, string subject);
    [CompilerGeneratedAttribute]
public Color get_Color();
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public string get_Subject();
}
public class DevExpress.Pdf.Drawing.PdfMarkupAnnotationPropertiesFormViewModel : object {
    private IPdfMarkupAnnotationState state;
    private PdfDocumentState documentState;
    private bool previousIsDocumentModified;
    private PdfRGBColor previousColor;
    private double previousOpacity;
    private string previousAuthor;
    private string previousSubject;
    private Nullable`1<DateTimeOffset> previousModificationDate;
    private string previousComment;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public PdfAnnotationType AnnotationType { get; }
    public bool IsReply { get; }
    public Color Color { get; public set; }
    public int Opacity { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public string Comment { get; public set; }
    public string Name { get; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; }
    public Nullable`1<DateTimeOffset> CreationDate { get; }
    public PdfViewerMarkupAnnotation Info { get; }
    protected PdfMarkupAnnotationPropertiesFormViewModel(IPdfMarkupAnnotationState state, PdfDocumentState documentState);
    public static PdfMarkupAnnotationPropertiesFormViewModel Create(PdfDocumentState documentState, IPdfMarkupAnnotationState state);
    public sealed virtual PdfAnnotationType get_AnnotationType();
    public bool get_IsReply();
    public sealed virtual Color get_Color();
    public sealed virtual void set_Color(Color value);
    public sealed virtual int get_Opacity();
    public sealed virtual void set_Opacity(int value);
    public sealed virtual string get_Author();
    public sealed virtual void set_Author(string value);
    public sealed virtual string get_Subject();
    public sealed virtual void set_Subject(string value);
    public sealed virtual string get_Comment();
    public sealed virtual void set_Comment(string value);
    public sealed virtual string get_Name();
    public sealed virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    public sealed virtual Nullable`1<DateTimeOffset> get_CreationDate();
    public virtual PdfViewerMarkupAnnotation get_Info();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void RollbackProperties();
    public virtual PdfViewerMarkupAnnotationChangingInfoState CreateOldInfo();
    public void RollbackChanges();
    protected void SetValue(T fieldValue, T value, Action setNewValue);
    protected void RaisePropertyChanged(string propertyName);
    protected virtual void OnStatePropertyChanged(object sender, PropertyChangedEventArgs e);
}
public class DevExpress.Pdf.Drawing.PdfMarqueeZoomToolController : PdfScrollableToolController {
    public PdfMarqueeZoomToolController(PdfDocumentController documentController);
    public virtual PdfCursor GetCursor(PdfMouseAction action);
    protected virtual PdfPopupMenuContext GetPopupMenuContext(PdfMouseAction action);
}
public abstract class DevExpress.Pdf.Drawing.PdfMaskBlender : PdfImageBlender {
    private PdfFunction transferFunction;
    protected PdfMaskBlender(Bitmap targetBitmap, Bitmap sourceBitmap, PdfFunction transferFunction);
    protected virtual void BlendPixel(Byte[] targetData, Byte[] sourceData, int targetOffset, int sourceOffset);
    protected abstract virtual double GetSourceAlpha(Byte[] sourceData, int sourceOffset);
}
public abstract class DevExpress.Pdf.Drawing.PdfMeshShadingPainter : PdfShadingPainter {
    private static int colorPaletteSize;
    private Color[] colorPalette;
    private int bitmapWidth;
    private int bitmapHeight;
    private PdfMeshShading shading;
    protected PdfMeshShadingPainter(PdfMeshShading shading, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfTransformationMatrix matrix, int bitmapWidth, int bitmapHeight);
    protected virtual void Paint(INativeRenderer renderer);
    protected abstract virtual void DrawMesh(INativeRenderer renderer);
    [CompilerGeneratedAttribute]
private void <Paint>b__6_1(INativeRenderer imageRenderer);
}
public class DevExpress.Pdf.Drawing.PdfMouseScrollSynchronizationController : object {
    private static int scrollTimeInterval;
    private IPdfViewerController viewerController;
    private Timer scrollTimer;
    public PdfMouseScrollSynchronizationController(IPdfViewerController viewerController);
    private static void SynchronizeWithMousePosition(object controller);
    private static void OnTimerClick(object controller);
    public void Start();
    public void Stop();
    public sealed virtual void Dispose();
}
public abstract class DevExpress.Pdf.Drawing.PdfMouseToolController : PdfInteractiveElementController {
    protected PdfMouseToolController(PdfDocumentController documentController);
    public virtual void NotifyToolChanged();
}
public class DevExpress.Pdf.Drawing.PdfMultiplyImageBlender : PdfBackdropImageBlender {
    public PdfMultiplyImageBlender(Bitmap bitmap, Bitmap backdropBitmap);
    protected virtual void BlendPixel(Byte[] targetData, Byte[] sourceData, int targetOffset, int sourceOffset);
}
public class DevExpress.Pdf.Drawing.PdfPageController : object {
    private PdfPageState pageState;
    private Lazy`1<PdfPageAnnotationControllerCollection> annotations;
    [CompilerGeneratedAttribute]
private PdfDocumentController <DocumentController>k__BackingField;
    public PdfDocumentController DocumentController { get; }
    public IReadOnlyList`1<IPdfAnnotationController> Annotations { get; }
    public PdfPageController(PdfDocumentController document, PdfPageState pageState);
    [CompilerGeneratedAttribute]
public sealed virtual PdfDocumentController get_DocumentController();
    public sealed virtual IReadOnlyList`1<IPdfAnnotationController> get_Annotations();
    public sealed virtual IPdfAnnotationController AddTextMarkupAnnotation(IPdfTextMarkupAnnotationBuilder builder);
    public sealed virtual IPdfAnnotationController AddStickyNoteAnnotation(IPdfTextAnnotationBuilder builder);
}
public class DevExpress.Pdf.Drawing.PdfPagePrintingInfo : PdfPageRenderingInfoBase {
    [CompilerGeneratedAttribute]
private PdfRectangle <UnscaledDeviceBBox>k__BackingField;
    [CompilerGeneratedAttribute]
private PointF <Offset>k__BackingField;
    public PdfRectangle UnscaledDeviceBBox { get; }
    public PointF Offset { get; }
    public PdfPagePrintingInfo(float scale, PdfRenderMode renderMode, PdfPageState pageState, PointF offset);
    [CompilerGeneratedAttribute]
public PdfRectangle get_UnscaledDeviceBBox();
    [CompilerGeneratedAttribute]
public PointF get_Offset();
}
public class DevExpress.Pdf.Drawing.PdfPageRenderingInfo : PdfPageRenderingInfoBase {
    [CompilerGeneratedAttribute]
private PdfPageTileInfoList <Tiles>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRgbaColor <ActualHighlightColor>k__BackingField;
    public PdfPageTileInfoList Tiles { get; }
    public PdfRgbaColor ActualHighlightColor { get; }
    public PdfPageRenderingInfo(PdfPageState pageState, float scale, PdfRenderMode renderMode, PdfPageTileInfoList tiles, PdfRgbaColor actualHighlightColor);
    [CompilerGeneratedAttribute]
public PdfPageTileInfoList get_Tiles();
    [CompilerGeneratedAttribute]
public PdfRgbaColor get_ActualHighlightColor();
}
public abstract class DevExpress.Pdf.Drawing.PdfPageRenderingInfoBase : object {
    private PdfTransformationMatrix userToPageMatrix;
    private PdfTransformationMatrix userToDeviceMatrix;
    private PdfRectangle unscaledRotatedDeviceBBox;
    private float scale;
    private PdfPageState pageState;
    private PdfRenderMode renderMode;
    private PdfRectangle requestedRectangle;
    private PdfTransformationMatrix pageToDeviceMatrix;
    [CompilerGeneratedAttribute]
private bool <RenderStickyNotes>k__BackingField;
    public PdfTransformationMatrix UserToDeviceMatrix { get; }
    public PdfTransformationMatrix UserToPageMatrix { get; }
    public PdfTransformationMatrix PageToDeviceMatrix { get; protected set; }
    public PdfRectangle UnscaledRotatedDeviceBBox { get; }
    public float Scale { get; }
    public PdfPage Page { get; }
    public PdfPageState PageState { get; }
    public PdfRenderMode RenderMode { get; }
    public int RotationAngle { get; }
    public IEnumerable`1<IPdfAnnotationState> AnnotationStates { get; }
    public bool RenderStickyNotes { get; public set; }
    protected PdfPageRenderingInfoBase(PdfPageState pageState, float scale, PdfRenderMode renderMode, PdfRectangle requestedRectangle);
    public PdfTransformationMatrix get_UserToDeviceMatrix();
    public PdfTransformationMatrix get_UserToPageMatrix();
    public PdfTransformationMatrix get_PageToDeviceMatrix();
    protected void set_PageToDeviceMatrix(PdfTransformationMatrix value);
    public PdfRectangle get_UnscaledRotatedDeviceBBox();
    public float get_Scale();
    public PdfPage get_Page();
    public PdfPageState get_PageState();
    public PdfRenderMode get_RenderMode();
    public int get_RotationAngle();
    public IEnumerable`1<IPdfAnnotationState> get_AnnotationStates();
    [CompilerGeneratedAttribute]
public bool get_RenderStickyNotes();
    [CompilerGeneratedAttribute]
public void set_RenderStickyNotes(bool value);
    [CompilerGeneratedAttribute]
private bool <get_AnnotationStates>b__28_0(IPdfAnnotationState annotation);
}
public class DevExpress.Pdf.Drawing.PdfPageTextureCache`1 : object {
    private static int tileSize;
    private static int overlapPixelCount;
    private IDictionary`2<PdfPageTile, TBitmap> dictionary;
    private List`1<PdfPageTile> lastUsedTiles;
    private IDictionary`2<int, IList`1<PdfPageTile>> tilesDictionary;
    public void BeginDrawing();
    public void EndDrawing();
    public void Invalidate(int pageIndex, PdfRectangle rectangle);
    public TBitmap GetBitmap(PdfPageTile key);
    public IEnumerable`1<PdfPageTile> GetTiles(PdfPageState state, float scale, PdfRectangle requestedRectangle);
    public void AddBitmap(PdfPageTile key, TBitmap bitmap);
    public void Clear();
    public sealed virtual void Dispose();
    private IList`1<PdfPageTile> RebuildGrid(PdfPageState pageState, float scale);
    private void RemoveImages(IEnumerable`1<PdfPageTile> tiles);
    private void RemoveImage(PdfPageTile tile);
}
public class DevExpress.Pdf.Drawing.PdfPageTile : object {
    private float scale;
    private PdfRectangle userSpaceBBox;
    public float Scale { get; }
    public PdfRectangle UserSpaceBBox { get; }
    public PdfPageTile(float scale, PdfRectangle userSpaceBBox);
    public float get_Scale();
    public PdfRectangle get_UserSpaceBBox();
}
public class DevExpress.Pdf.Drawing.PdfPageTileInfo : object {
    private PdfPageTile tile;
    private DXBitmap bitmap;
    public PdfPageTile Tile { get; }
    public DXBitmap Bitmap { get; }
    public PdfPageTileInfo(PdfPageTile tile, DXBitmap bitmap);
    public PdfPageTile get_Tile();
    public DXBitmap get_Bitmap();
}
public class DevExpress.Pdf.Drawing.PdfPageTileInfoList : object {
    private IList`1<PdfPageTileInfo> tiles;
    private PdfRectangle requestedRectangle;
    public PdfRectangle RequestedRectangle { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public PdfRectangle get_RequestedRectangle();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(PdfPageTileInfo info);
    public sealed virtual IEnumerator`1<PdfPageTileInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PdfPageTileInfo item);
    public sealed virtual void CopyTo(PdfPageTileInfo[] array, int arrayIndex);
    public sealed virtual bool Remove(PdfPageTileInfo item);
}
public abstract class DevExpress.Pdf.Drawing.PdfPatchMeshPainter : PdfMeshShadingPainter {
    private PdfRectangle bbox;
    protected IList`1<PdfTensorProductBezierSurfaceInfo> Patches { get; }
    protected PdfPatchMeshPainter(PdfMeshShading shading, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfTransformationMatrix matrix, int bitmapWidth, int bitmapHeight, PdfRectangle bbox);
    protected abstract virtual IList`1<PdfTensorProductBezierSurfaceInfo> get_Patches();
    protected virtual void DrawMesh(INativeRenderer renderer);
}
public class DevExpress.Pdf.Drawing.PdfPolygonAnnotationController : PdfMarkupAnnotationController`1<PdfPolygonAnnotationState> {
    public PdfPolygonAnnotationController(IPdfPageController page, PdfPolygonAnnotationState annotationState);
}
public class DevExpress.Pdf.Drawing.PdfPolyLineAnnotationController : PdfMarkupAnnotationController`1<PdfPolyLineAnnotationState> {
    public PdfPolyLineAnnotationController(IPdfPageController page, PdfPolyLineAnnotationState annotationState);
}
[FlagsAttribute]
public enum DevExpress.Pdf.Drawing.PdfPopupMenuContext : Enum {
    public int value__;
    public static PdfPopupMenuContext None;
    public static PdfPopupMenuContext Selection;
    public static PdfPopupMenuContext TextMarkup;
    public static PdfPopupMenuContext AnnotationProperties;
}
public class DevExpress.Pdf.Drawing.PdfPrintDialogPreview : PdfDisposableObject {
    private PdfProcessingBackend backend;
    private PdfPrintPreviewCalculator calculator;
    private DXImage previewImage;
    private int pageIndex;
    private Color previewPrintAreaBorderColor;
    public DXImage PreviewImage { get; }
    public int PageIndex { get; public set; }
    public PdfPrinterSettings PrinterSettings { get; public set; }
    public Size PreviewSize { get; public set; }
    public Color PreviewPrintAreaBorderColor { get; public set; }
    internal float Scale { get; }
    internal bool HasException { get; }
    public PdfPrintDialogPreview(PdfProcessingBackend backend, PdfPrinterSettings settings, int pageIndex, Size previewSize);
    public DXImage get_PreviewImage();
    public int get_PageIndex();
    public void set_PageIndex(int value);
    public PdfPrinterSettings get_PrinterSettings();
    public void set_PrinterSettings(PdfPrinterSettings value);
    public Size get_PreviewSize();
    public void set_PreviewSize(Size value);
    public Color get_PreviewPrintAreaBorderColor();
    public void set_PreviewPrintAreaBorderColor(Color value);
    internal float get_Scale();
    internal bool get_HasException();
    public void DisposePreviewImage();
    protected virtual void Dispose(bool disposing);
    private void MarkUnprintableArea(IDXGraphics g);
}
public class DevExpress.Pdf.Drawing.PdfPrintDialogViewModel : PdfDisposableObject {
    internal static string PrinterIndexPropertyName;
    internal static string PrinterStatusPropertyName;
    internal static string PrinterLocationPropertyName;
    internal static string PrinterCommentPropertyName;
    internal static string PrinterDocumentsInQueuePropertyName;
    internal static string PrintingDpiPropertyName;
    internal static string MaxDpiPropertyName;
    internal static string CopiesPropertyName;
    internal static string AllowCollatePropertyName;
    internal static string CollatePropertyName;
    internal static string PrintRangePropertyName;
    internal static string PageRangeTextPropertyName;
    internal static string AllowSomePagesPropertyName;
    internal static string PageNumbersPropertyName;
    internal static string EnablePageNumberPreviewPropertyName;
    internal static string ScaleModePropertyName;
    internal static string AllowCustomScalePropertyName;
    internal static string ScalePropertyName;
    internal static string ShowFitScaleTextPropertyName;
    internal static string FitScalePropertyName;
    internal static string PageOrientationPropertyName;
    internal static string PaperSourcesPropertyName;
    internal static string PaperSourceIndexPropertyName;
    internal static string PrintToFilePropertyName;
    internal static string PrintFileNamePropertyName;
    internal static string PagePreviewIndexPropertyName;
    internal static string CurrentPreviewPageNumberPropertyName;
    internal static string PreviewImagePropertyName;
    internal static string PreviewImageBytesPropertyName;
    internal static string EnableToPrintPropertyName;
    private IPrintingBridge provider;
    private int currentPageNumber;
    private int maxPrintingDpi;
    private int documentPageCount;
    private Func`2<string, bool> showFileReplacingRequest;
    private IReadOnlyList`1<IPrinterItem> printerItems;
    private PdfPrintDialogPreview dialogPreview;
    private PdfPrinterSettings pdfPrinterSettings;
    private PdfCachedPrinterSettings printerSettings;
    private int printerIndex;
    private Nullable`1<int> maxDpi;
    private Nullable`1<bool> collate;
    private Nullable`1<short> copies;
    private string pageRangeText;
    private IList`1<PaperSource> nativePaperSources;
    private IList`1<string> paperSources;
    private int paperSourceIndex;
    private string printFileName;
    private int pagePreviewIndex;
    private int currentPreviewPageNumber;
    private Byte[] previewImageBytes;
    private bool hasPrinterException;
    private bool enableToPrint;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public IReadOnlyList`1<IPrinterItem> PrinterItems { get; }
    public PdfPrinterSettings PrinterSettings { get; }
    public string PrinterStatus { get; }
    public string PrinterLocation { get; }
    public string PrinterComment { get; }
    public string PrinterDocumentsInQueue { get; }
    public int PrinterIndex { get; public set; }
    public int MaxDpi { get; }
    public int PrintingDpi { get; public set; }
    public short Copies { get; public set; }
    public bool AllowCollate { get; }
    public bool Collate { get; public set; }
    public PrintRange PrintRange { get; public set; }
    public bool AllowSomePages { get; public set; }
    public string PageRangeText { get; public set; }
    public PdfPrintScaleMode ScaleMode { get; public set; }
    public bool ShowFitScaleText { get; }
    public float FitScale { get; }
    public bool AllowCustomScale { get; }
    public float Scale { get; public set; }
    public PdfPrintPageOrientation PageOrientation { get; public set; }
    public IList`1<string> PaperSources { get; }
    public int PaperSourceIndex { get; public set; }
    public string DefaultPaperSourceName { get; }
    public bool PrintToFile { get; public set; }
    public string PrintFileName { get; public set; }
    public int PagePreviewIndex { get; public set; }
    public int CurrentPreviewPageNumber { get; public set; }
    public Int32[] PageNumbers { get; }
    public int PageCount { get; }
    public bool EnablePageNumberPreview { get; }
    private DXImage PreviewDXImage { get; }
    public Image PreviewImage { get; }
    public Byte[] PreviewImageBytes { get; }
    public Color PreviewPrintAreaBorderColor { get; public set; }
    public bool HasException { get; }
    public bool EnableToPrint { get; public set; }
    private IPrinterItem CurrentPrinterItem { get; }
    private int CurrentPageNumber { get; }
    private string InvalidPageRangeMessage { get; }
    private bool IsValidPrintToFile { get; }
    private string InvalidFilePathMessage { get; }
    private string System.ComponentModel.IDataErrorInfo.Error { get; }
    private string System.ComponentModel.IDataErrorInfo.Item { get; }
    public PdfPrintDialogViewModel(PdfProcessingBackend backend, IPrintingBridge provider, Size previewSize, int currentPageNumber, int maxPrintingDpi, Func`2<string, bool> showFileReplacingRequest, PdfPrinterSettings pdfPrinterSettings);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public IReadOnlyList`1<IPrinterItem> get_PrinterItems();
    public PdfPrinterSettings get_PrinterSettings();
    public string get_PrinterStatus();
    public string get_PrinterLocation();
    public string get_PrinterComment();
    public string get_PrinterDocumentsInQueue();
    public int get_PrinterIndex();
    public void set_PrinterIndex(int value);
    public int get_MaxDpi();
    public int get_PrintingDpi();
    public void set_PrintingDpi(int value);
    public short get_Copies();
    public void set_Copies(short value);
    public bool get_AllowCollate();
    public bool get_Collate();
    public void set_Collate(bool value);
    public PrintRange get_PrintRange();
    public void set_PrintRange(PrintRange value);
    public bool get_AllowSomePages();
    public void set_AllowSomePages(bool value);
    public string get_PageRangeText();
    public void set_PageRangeText(string value);
    public PdfPrintScaleMode get_ScaleMode();
    public void set_ScaleMode(PdfPrintScaleMode value);
    public bool get_ShowFitScaleText();
    public float get_FitScale();
    public bool get_AllowCustomScale();
    public float get_Scale();
    public void set_Scale(float value);
    public PdfPrintPageOrientation get_PageOrientation();
    public void set_PageOrientation(PdfPrintPageOrientation value);
    public IList`1<string> get_PaperSources();
    public int get_PaperSourceIndex();
    public void set_PaperSourceIndex(int value);
    public string get_DefaultPaperSourceName();
    public bool get_PrintToFile();
    public void set_PrintToFile(bool value);
    public string get_PrintFileName();
    public void set_PrintFileName(string value);
    public int get_PagePreviewIndex();
    public void set_PagePreviewIndex(int value);
    public int get_CurrentPreviewPageNumber();
    public void set_CurrentPreviewPageNumber(int value);
    public Int32[] get_PageNumbers();
    public int get_PageCount();
    public bool get_EnablePageNumberPreview();
    private DXImage get_PreviewDXImage();
    public Image get_PreviewImage();
    public Byte[] get_PreviewImageBytes();
    public Color get_PreviewPrintAreaBorderColor();
    public void set_PreviewPrintAreaBorderColor(Color value);
    public bool get_HasException();
    public bool get_EnableToPrint();
    public void set_EnableToPrint(bool value);
    private IPrinterItem get_CurrentPrinterItem();
    private int get_CurrentPageNumber();
    private string get_InvalidPageRangeMessage();
    private bool get_IsValidPrintToFile();
    private string get_InvalidFilePathMessage();
    private sealed virtual override string System.ComponentModel.IDataErrorInfo.get_Error();
    private sealed virtual override string System.ComponentModel.IDataErrorInfo.get_Item(string columnName);
    public void UpdatePreviewSize(int width, int height);
    public void ShowPreferences(IntPtr handle);
    public void ShowPrinterPropertiesDialog(IntPtr handle);
    public void RefreshAfterHidePrinterPropertiesDialog();
    protected virtual void Dispose(bool disposing);
    private void RaisePropertyChanged(string propertyName);
    private void RaiseCopiesPropertyChanged();
    private bool SetProperty(T& storage, T value, string propertyName, Action changedCallback);
    private void RefreshPreviewImage();
    private void SetCurrentPreviewPage();
    private void UpdateMaxDpi();
    private void UpdatePaperSources();
    private bool UpdateCopies(short copies);
    private bool UpdateCollate(bool collate);
    private bool UpdatePrintFileName(string printFileName);
    private void UpdatePageNumbers();
    private void UpdatePreview();
    private void SetPrintRange(PrintRange printRange);
    private void UpdatePrinterSettingsPrintFileName();
    private void OnPrinterIndexChanged();
    [CompilerGeneratedAttribute]
private void <set_PrinterIndex>b__70_0();
    [CompilerGeneratedAttribute]
private void <set_PageRangeText>b__92_0();
    [CompilerGeneratedAttribute]
private void <set_PagePreviewIndex>b__123_0();
}
public class DevExpress.Pdf.Drawing.PdfProcessingBackend : object {
    private static long defaultCacheSizeInMegabytes;
    private IPdfPrintingCallbackProvider callbackProvider;
    private Lazy`1<IPdfFileIconService> iconService;
    private PdfDocumentRenderer renderer;
    private long imageCacheSizeInMegabytes;
    private int maxPrintingDpi;
    private PdfRenderingEngine renderingEngine;
    private PdfDocumentState documentState;
    private string fullTextCache;
    public PdfDocumentState DocumentState { get; }
    public PdfDocument Document { get; }
    public long ImageCacheSize { get; public set; }
    private long ImageCacheSizeInBytes { get; }
    public PdfRenderingEngine RenderingEngine { get; public set; }
    public int MaxPrintingDpi { get; public set; }
    public string FullText { get; }
    protected PdfDocumentRenderer Renderer { get; }
    protected bool SupportsCaching { get; }
    public PdfProcessingBackend(IPdfPrintingCallbackProvider callbackProvider);
    private static void ValidateDpiValue(float imageDpi);
    public PdfDocumentState get_DocumentState();
    public PdfDocument get_Document();
    public long get_ImageCacheSize();
    public void set_ImageCacheSize(long value);
    private long get_ImageCacheSizeInBytes();
    public PdfRenderingEngine get_RenderingEngine();
    public void set_RenderingEngine(PdfRenderingEngine value);
    public int get_MaxPrintingDpi();
    public void set_MaxPrintingDpi(int value);
    public string get_FullText();
    protected PdfDocumentRenderer get_Renderer();
    protected virtual bool get_SupportsCaching();
    protected virtual void OnSetDocumentState(PdfDocumentState documentState);
    protected virtual void ClearCaches();
    private void DisposeDocumentState();
    public void SetDocument(PdfDocument document);
    protected void Print(PdfPrinterSettings printerSettings, Func`2<PdfPrinterSettings, PdfDocumentPrinter> createPrinter);
    public virtual void Print(PdfPrinterSettings printerSettings);
    public DXBitmap CreateImageSelectionBitmap(PdfImageSelection selection, float imageResolution);
    public DXBitmap CreatePrintPreviewBitmap(int pageNumber, int largestEdgeLength, bool printStickyNotes);
    public DXBitmap CreateBitmap(int pageNumber, PdfPageRenderingParameters options);
    public DXBitmap CreateBitmap(int pageNumber, int largestEdgeLength);
    public DXBitmap CreateBitmap(int pageNumber, int largestEdgeLength, PdfRenderMode renderMode);
    private DXBitmap CreateBitmap(int pageNumber, int largestEdgeLength, PdfRenderMode renderMode, bool renderStickyNotes);
    private DXBitmap CreateBitmapCore(int pageWidth, int pageHeight);
    public void CreateTiff(Stream stream, int largestEdgeLength);
    public void CreateTiff(Stream stream, IEnumerable`1<int> pageNumbers, float imageDpi);
    public void CreateTiff(Stream stream, int largestEdgeLength, IEnumerable`1<int> pageNumbers);
    public virtual void Dispose();
    public string GetFullTextNoCache(PdfTextExtractionOptions options);
    private void UpdateRenderer();
    private PdfDirectXRendererFlags GetDirectXRendererFlags();
    private PdfDocumentRenderer CreateRenderer(PdfRenderingEngine engine);
    private PdfDocumentRenderer CreateDefaultRender();
    private PdfDocumentRenderer CreateSkiaRenderer();
    private void OnPageInvalidate(object sender, PdfPageStateInvalidateEventArgs e);
    private void OnPagesChanged(object sender, EventArgs e);
    private void CheckPageNumber(int pageNumber);
    private void CreateTiff(Stream stream, IEnumerable`1<int> pageNumbers, Nullable`1<float> dpi, Func`2<int, int> calcLargestEdgeLength);
    private IMultiPageTiffBuilder CreateTiffBuilder(Stream stream);
    private sealed virtual override double DevExpress.Pdf.Native.IPdfRenderingFontInfoProvider.GetWidth(PdfFont font, int charCode);
    private sealed virtual override PdfFontMetricsMetadata DevExpress.Pdf.Native.IPdfRenderingFontInfoProvider.GetMetrics(PdfFont font);
    private void DisposeRenderer();
    public void CheckPlatformOperation(bool isGdiMethod, string crossplatformMethodName);
    private int ValidatePageNumberAndCalculateLargestEdgeLength(int pageNumber, float imageDpi);
    private sealed virtual override IPdfFileIconService DevExpress.Pdf.Native.IPdfPlatformServiceProvider.GetIconService();
    private sealed virtual override IPdfRenderFontStorage DevExpress.Pdf.Native.IPdfPlatformServiceProvider.GetRenderFontStorage();
    private sealed virtual override IPolygonBooleanOperationProvider DevExpress.Pdf.Native.IPdfPlatformServiceProvider.GetPolygonBooleanOperationProvider();
    private sealed virtual override void DevExpress.Pdf.Native.IPdfRenderFontStorage.NotifyFontChanged(PdfFont font);
    [CompilerGeneratedAttribute]
private PdfDocumentPrinter <Print>b__37_0(PdfPrinterSettings actualSettings);
}
public class DevExpress.Pdf.Drawing.PdfRadialShadingPainter : PdfShadingPainter {
    private static int degree90;
    private static int degree360;
    private PdfRadialShading shading;
    private float startingCircleCenterX;
    private float startingCircleCenterY;
    private int startingCircleRadius;
    private float endingCircleCenterX;
    private float endingCircleCenterY;
    private int endingCircleRadius;
    private int maxShadingSide;
    private float DistanceBetweenCircleCenters { get; }
    private float TangentAngle { get; }
    private float StartingOuterSpaceDistance { get; }
    private float EndingOuterSpaceDistance { get; }
    public PdfRadialShadingPainter(PdfRadialShading shading, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfTransformationMatrix matrix, int bitmapWidth, int bitmapHeight);
    private static double GetDistance(PointF p1, PointF p2);
    private float get_DistanceBetweenCircleCenters();
    private float get_TangentAngle();
    private float get_StartingOuterSpaceDistance();
    private float get_EndingOuterSpaceDistance();
    private GraphicsPath CreateStartingOuterSpaceGraphicsPath();
    private GraphicsPath CreateEndingOuterSpaceGraphicsPath();
    private void PaintGraphicsPath(INativeRenderer renderer, GraphicsPath graphicsPath, Color color, float x, float y);
    protected virtual void Paint(INativeRenderer renderer);
}
public class DevExpress.Pdf.Drawing.PdfReadOnlyCollection : object {
    private ICollection`1<string> source;
    public int Count { get; }
    public PdfReadOnlyCollection(ICollection`1<string> source);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class DevExpress.Pdf.Drawing.PdfRenderImageAtlas : object {
    [CompilerGeneratedAttribute]
private bool <IsMaskAtlas>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<PdfImage, Rectangle> <AtlasMap>k__BackingField;
    public bool IsMaskAtlas { get; }
    public int Width { get; private set; }
    public int Height { get; private set; }
    public IDictionary`2<PdfImage, Rectangle> AtlasMap { get; private set; }
    public PdfRenderImageAtlas(int width, int height, IDictionary`2<PdfImage, Rectangle> atlasMap, bool isMaskAtlas);
    [CompilerGeneratedAttribute]
public bool get_IsMaskAtlas();
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
private void set_Height(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<PdfImage, Rectangle> get_AtlasMap();
    [CompilerGeneratedAttribute]
private void set_AtlasMap(IDictionary`2<PdfImage, Rectangle> value);
    public Nullable`1<Rectangle> GetImageLocation(PdfImage image);
}
public static class DevExpress.Pdf.Drawing.PdfRenderImageAtlasFactory : object {
    internal static PdfRenderImageAtlasMapping CreateAtlases(ISet`1<PdfImage> images, Size binSize, int padding, int maxAtlasSize);
    private static PdfRenderImageAtlasMapping Pack(ISet`1<PdfImage> images, Size binSize, int padding, int maxAtlasSize, bool isMask);
}
public class DevExpress.Pdf.Drawing.PdfRenderImageAtlasMapping : object {
    [CompilerGeneratedAttribute]
private IList`1<PdfRenderImageAtlas> <Atlases>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<PdfImage, PdfRenderImageAtlas> <ImageToAtlasMap>k__BackingField;
    public IList`1<PdfRenderImageAtlas> Atlases { get; private set; }
    public IDictionary`2<PdfImage, PdfRenderImageAtlas> ImageToAtlasMap { get; private set; }
    public PdfRenderImageAtlasMapping(IList`1<PdfRenderImageAtlas> atlases, IDictionary`2<PdfImage, PdfRenderImageAtlas> imageToAtlasMap);
    [CompilerGeneratedAttribute]
public IList`1<PdfRenderImageAtlas> get_Atlases();
    [CompilerGeneratedAttribute]
private void set_Atlases(IList`1<PdfRenderImageAtlas> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<PdfImage, PdfRenderImageAtlas> get_ImageToAtlasMap();
    [CompilerGeneratedAttribute]
private void set_ImageToAtlasMap(IDictionary`2<PdfImage, PdfRenderImageAtlas> value);
    public PdfRenderImageAtlas GetAtlas(PdfImage image);
}
public class DevExpress.Pdf.Drawing.PdfRenderingOutOfMemoryException : Exception {
    internal PdfRenderingOutOfMemoryException(Exception innerException);
}
public class DevExpress.Pdf.Drawing.PdfRenderingTriangle : object {
    private PdfRenderingVertex vertex1;
    private PdfRenderingVertex vertex2;
    private PdfRenderingVertex vertex3;
    public PdfRenderingVertex Vertex1 { get; }
    public PdfRenderingVertex Vertex2 { get; }
    public PdfRenderingVertex Vertex3 { get; }
    public PdfRenderingTriangle(PdfRenderingVertex vertex1, PdfRenderingVertex vertex2, PdfRenderingVertex vertex3);
    public PdfRenderingVertex get_Vertex1();
    public PdfRenderingVertex get_Vertex2();
    public PdfRenderingVertex get_Vertex3();
}
public static class DevExpress.Pdf.Drawing.PdfRenderingUtils : object {
    public static double CalcDistance(PointF point1, PointF point2);
    public static PdfTransformationMatrix CreatePageTransformationMatrix(PdfPage page, int rotationAngle);
}
public class DevExpress.Pdf.Drawing.PdfRenderingVertex : object {
    private PointF point;
    private Color color;
    public PointF Point { get; }
    public Color Color { get; }
    public PdfRenderingVertex(PointF point, Color color);
    public PointF get_Point();
    public Color get_Color();
}
public enum DevExpress.Pdf.Drawing.PdfRenderMode : Enum {
    public int value__;
    public static PdfRenderMode View;
    public static PdfRenderMode Print;
}
public class DevExpress.Pdf.Drawing.PdfReplyController : object {
    private List`1<PdfReplyController> replyControllers;
    private PdfDocumentController documentController;
    private IPdfAnnotationStateComment comment;
    public PdfReplyController(PdfDocumentController documentController, IPdfAnnotationStateComment comment);
    private void Comment_PropertyChanged(object sender, PropertyChangedEventArgs e);
    private void Reviews_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void Replies_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
}
public class DevExpress.Pdf.Drawing.PdfRubberStampAnnotationController : PdfMarkupAnnotationController {
    protected internal PdfRubberStampAnnotationController(IPdfPageController page, IPdfMarkupAnnotationState annotationState, bool canDrag);
}
public class DevExpress.Pdf.Drawing.PdfScrollableToolController : PdfMouseToolController {
    private PdfMouseScrollSynchronizationController scrollController;
    protected bool ShouldStartScroll { get; }
    public PdfScrollableToolController(PdfDocumentController documentController);
    protected virtual bool get_ShouldStartScroll();
    protected virtual void OnMouseDown(PdfMouseAction action);
    protected virtual void OnMouseMove(PdfMouseAction action);
    protected virtual void OnMouseUp(PdfMouseAction action);
    public virtual void NotifyToolChanged();
}
public class DevExpress.Pdf.Drawing.PdfSelectionToolController : PdfScrollableToolController {
    private PdfDataSelector dataSelector;
    private bool forceTextSelection;
    protected bool ShouldStartScroll { get; }
    public PdfSelectionToolController(PdfDocumentController documentController);
    protected PdfSelectionToolController(PdfDocumentController documentController, bool forceTextSelection);
    protected virtual bool get_ShouldStartScroll();
    protected virtual void OnMouseDown(PdfMouseAction action);
    protected virtual void OnMouseMove(PdfMouseAction action);
    protected virtual void OnMouseUp(PdfMouseAction action);
    public virtual PdfCursor GetCursor(PdfMouseAction action);
    protected virtual PdfPopupMenuContext GetPopupMenuContext(PdfMouseAction action);
}
public class DevExpress.Pdf.Drawing.PdfShadingColorConverter : object {
    private PdfShadingPainter shadingPainter;
    public PdfShadingColorConverter(PdfShadingPainter shadingPainter);
    private sealed virtual override Color DevExpress.Pdf.Drawing.IShadingColorConverter.Convert(Double[] colorComponents);
}
public abstract class DevExpress.Pdf.Drawing.PdfShadingPainter : object {
    protected static int Degree180;
    protected static double RadianToDegreeFactor;
    private PdfShading shading;
    private bool shouldDrawBackground;
    private bool shouldUseTransparentBackgroundColor;
    private IShadingCoordsConverter coordsConverter;
    private IShadingColorConverter colorConverter;
    protected IShadingCoordsConverter CoordsConverter { get; }
    protected IShadingColorConverter ColorConverter { get; protected set; }
    protected PdfShadingPainter(PdfShading shading, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfTransformationMatrix matrix, int bitmapWidth, int bitmapHeight);
    private static PdfShadingPainter CreatePainter(int bitmapWidth, int bitmapHeight, PdfShading shading, PdfTransformationMatrix matrix, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfTransformationMatrix deviceTransformationMatrix);
    private static PdfShadingPainter CreatePainter(int bitmapWidth, int bitmapHeight, PdfShading shading, PdfTransformationMatrix matrix, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfRectangle boundingBox);
    private static Bitmap CreateBitmap(PdfViewerCommandInterpreter interpreter, PdfShading shading, int width, int height, PdfTransformationMatrix matrix, bool shouldUseTransparentBackgroundColor);
    public static Bitmap CreateBitmap(PdfViewerCommandInterpreter interpreter, PdfShading shading);
    public static Bitmap CreateBitmap(PdfViewerCommandInterpreter interpreter, PdfShadingPattern pattern);
    public static void Draw(PdfViewerCommandInterpreter interpreter, Graphics graphics, PdfShading shading);
    public static void DrawShading(int bitmapWidth, int bitmapHeight, PdfShading shading, PdfTransformationMatrix matrix, INativeRenderer renderer, bool shouldDrawBackground, PdfRectangle boundingBox);
    protected IShadingCoordsConverter get_CoordsConverter();
    protected IShadingColorConverter get_ColorConverter();
    protected void set_ColorConverter(IShadingColorConverter value);
    public Color ConvertColor(Double[] colorComponents);
    protected virtual void Paint(INativeRenderer renderer);
}
public class DevExpress.Pdf.Drawing.PdfStickyNoteDefaultSettings : PdfMarkupAnnotationDefaultSettings {
    [CompilerGeneratedAttribute]
private string <IconName>k__BackingField;
    public string IconName { get; }
    public PdfStickyNoteDefaultSettings(Color color, string author, string subject, string iconName);
    [CompilerGeneratedAttribute]
public string get_IconName();
}
public class DevExpress.Pdf.Drawing.PdfStickyNoteToolController : PdfMouseToolController {
    public PdfStickyNoteToolController(PdfDocumentController documentController);
    protected virtual void OnMouseDown(PdfMouseAction action);
    public virtual PdfCursor GetCursor(PdfMouseAction action);
}
public class DevExpress.Pdf.Drawing.PdfTabBackwardNavigationStrategy : PdfTabNavigationStrategy {
    protected int StartPageIndex { get; }
    protected int Step { get; }
    public PdfTabBackwardNavigationStrategy(PdfTabNavigationController tabNavigationController, IPdfDocumentController documentController);
    protected virtual IPdfAnnotationController GetPageFirstAnnotationStateController(IReadOnlyList`1<IPdfAnnotationController> page);
    protected virtual int get_StartPageIndex();
    protected virtual int get_Step();
}
public class DevExpress.Pdf.Drawing.PdfTabForwardNavigationStrategy : PdfTabNavigationStrategy {
    protected int StartPageIndex { get; }
    protected int Step { get; }
    public PdfTabForwardNavigationStrategy(PdfTabNavigationController tabNavigationController, IPdfDocumentController documentController);
    protected virtual IPdfAnnotationController GetPageFirstAnnotationStateController(IReadOnlyList`1<IPdfAnnotationController> page);
    protected virtual int get_StartPageIndex();
    protected virtual int get_Step();
}
public class DevExpress.Pdf.Drawing.PdfTabNavigationController : object {
    private PdfTabNavigationStrategy tabForwardStrategy;
    private PdfTabNavigationStrategy tabBackwardStrategy;
    private int lastPageIndex;
    public int LastPageIndex { get; public set; }
    public PdfTabNavigationController(IPdfDocumentController documentController);
    public int get_LastPageIndex();
    public void set_LastPageIndex(int value);
    public void TabForward();
    public void TabBackward();
}
public abstract class DevExpress.Pdf.Drawing.PdfTabNavigationStrategy : object {
    private IPdfDocumentController documentController;
    private PdfTabNavigationController tabNavigationController;
    protected int Step { get; }
    protected int StartPageIndex { get; }
    protected int PageCount { get; }
    protected IPdfAnnotationController FirstAnnotationStateController { get; }
    protected PdfTabNavigationStrategy(PdfTabNavigationController tabNavigationController, IPdfDocumentController documentController);
    private static int IndexOf(IReadOnlyList`1<IPdfAnnotationController> page, IPdfAnnotationController element);
    protected abstract virtual int get_Step();
    protected abstract virtual int get_StartPageIndex();
    protected int get_PageCount();
    protected IPdfAnnotationController get_FirstAnnotationStateController();
    protected IPdfAnnotationController GetNextAnnotationStateController(IPdfAnnotationController current);
    public void TabNext(int lastPageIndex);
    protected abstract virtual IPdfAnnotationController GetPageFirstAnnotationStateController(IReadOnlyList`1<IPdfAnnotationController> page);
    protected IReadOnlyList`1<IPdfAnnotationController> GetNextPageWithAnnotations(int currentPageIndex);
    protected IPdfAnnotationController GetFirstAnnotationStateController(int lastPageIndex);
}
public static class DevExpress.Pdf.Drawing.PdfTempFolder : object {
    private static string tempPath;
    private static PdfTempFolder();
    public static string Create();
}
public class DevExpress.Pdf.Drawing.PdfTensorProductBezierSurface : object {
    private PointF[0...,0...] points;
    [CompilerGeneratedAttribute]
private PdfTensorProductBezierSurfaceEdge <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfTensorProductBezierSurfaceEdge <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfTensorProductBezierSurfaceEdge <Bottom>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfTensorProductBezierSurfaceEdge <Top>k__BackingField;
    public PointF[0...,0...] Points { get; }
    public PdfTensorProductBezierSurfaceEdge Left { get; }
    public PdfTensorProductBezierSurfaceEdge Right { get; }
    public PdfTensorProductBezierSurfaceEdge Bottom { get; }
    public PdfTensorProductBezierSurfaceEdge Top { get; }
    public PdfTensorProductBezierSurface(PointF[0...,0...] points);
    public PdfTensorProductBezierSurface(PointF[0...,0...] points, PdfTensorProductBezierSurfaceEdge left, PdfTensorProductBezierSurfaceEdge right, PdfTensorProductBezierSurfaceEdge bottom, PdfTensorProductBezierSurfaceEdge top);
    private static bool TestFlatness(PointF p0, PointF p1, PointF p2, PointF p3, float flatnessTolerance);
    private static PointF CalcSegmentPoint(PointF segmentPoint1, PointF segmentPoint2, float t);
    private static Tuple`2<PointF[], PointF[]> DeCasteljau(PointF[] bezierPoints, float splitFactor);
    public PointF[0...,0...] get_Points();
    [CompilerGeneratedAttribute]
public PdfTensorProductBezierSurfaceEdge get_Left();
    [CompilerGeneratedAttribute]
public PdfTensorProductBezierSurfaceEdge get_Right();
    [CompilerGeneratedAttribute]
public PdfTensorProductBezierSurfaceEdge get_Bottom();
    [CompilerGeneratedAttribute]
public PdfTensorProductBezierSurfaceEdge get_Top();
    public bool IsHorizontalFlat();
    public bool IsVerticalFlat();
    public Tuple`2<PdfTensorProductBezierSurface, PdfTensorProductBezierSurface> SplitHorizontal();
    public Tuple`2<PdfTensorProductBezierSurface, PdfTensorProductBezierSurface> SplitVertical();
}
public class DevExpress.Pdf.Drawing.PdfTensorProductBezierSurfaceCoordinateEdge : object {
    [CompilerGeneratedAttribute]
private PointF <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private PointF <End>k__BackingField;
    private PdfTensorProductBezierSurfaceCoordinateEdge Left;
    private PdfTensorProductBezierSurfaceCoordinateEdge Right;
    public PointF Start { get; }
    public PointF End { get; }
    public PdfTensorProductBezierSurfaceCoordinateEdge(PointF start, PointF end);
    [CompilerGeneratedAttribute]
public PointF get_Start();
    [CompilerGeneratedAttribute]
public PointF get_End();
    public Tuple`2<PdfTensorProductBezierSurfaceCoordinateEdge, PdfTensorProductBezierSurfaceCoordinateEdge> Split(PointF midPoint);
    public IEnumerable`1<PdfTensorProductBezierSurfacePoint> GetPoints(PointF startUV, PointF endUV);
    private void AppendPoints(IList`1<PdfTensorProductBezierSurfacePoint> points, PointF startUV, PointF endUV);
    public virtual string ToString();
}
public class DevExpress.Pdf.Drawing.PdfTensorProductBezierSurfaceEdge : object {
    private PdfTensorProductBezierSurfaceCoordinateEdge edge;
    private PointF startUV;
    private PointF endUV;
    public PdfTensorProductBezierSurfacePoint Start { get; }
    public PdfTensorProductBezierSurfacePoint End { get; }
    public PdfTensorProductBezierSurfaceEdge(PdfTensorProductBezierSurfaceCoordinateEdge edge, PointF startUV, PointF endUV);
    public PdfTensorProductBezierSurfaceEdge(PdfTensorProductBezierSurfacePoint startPoint, PdfTensorProductBezierSurfacePoint endPoint);
    public PdfTensorProductBezierSurfacePoint get_Start();
    public PdfTensorProductBezierSurfacePoint get_End();
    public Tuple`2<PdfTensorProductBezierSurfaceEdge, PdfTensorProductBezierSurfaceEdge> Split(PointF midPoint);
    public IEnumerable`1<PdfTensorProductBezierSurfacePoint> GetPoints();
    public virtual string ToString();
}
public class DevExpress.Pdf.Drawing.PdfTensorProductBezierSurfaceInfo : object {
    [CompilerGeneratedAttribute]
private PointF[0...,0...] <Points>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <LeftBottom>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <LeftTop>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <RightTop>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <RightBottom>k__BackingField;
    public PointF[0...,0...] Points { get; }
    public Color LeftBottom { get; }
    public Color LeftTop { get; }
    public Color RightTop { get; }
    public Color RightBottom { get; }
    public PdfTensorProductBezierSurfaceInfo(PointF[0...,0...] points, Color leftBottom, Color leftTop, Color rightTop, Color rightBottom);
    public static PdfTensorProductBezierSurfaceInfo Create(PdfPoint[0...,0...] points, PdfColor[] colors, IShadingCoordsConverter coordsConverter, IShadingColorConverter colorConverter);
    [CompilerGeneratedAttribute]
public PointF[0...,0...] get_Points();
    [CompilerGeneratedAttribute]
public Color get_LeftBottom();
    [CompilerGeneratedAttribute]
public Color get_LeftTop();
    [CompilerGeneratedAttribute]
public Color get_RightTop();
    [CompilerGeneratedAttribute]
public Color get_RightBottom();
}
public class DevExpress.Pdf.Drawing.PdfTensorProductBezierSurfacePoint : ValueType {
    [CompilerGeneratedAttribute]
private PointF <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private PointF <UV>k__BackingField;
    public PointF Point { get; }
    public PointF UV { get; }
    public float X { get; }
    public float Y { get; }
    public float U { get; }
    public float V { get; }
    public PdfTensorProductBezierSurfacePoint(PointF point, PointF uV);
    [CompilerGeneratedAttribute]
public PointF get_Point();
    [CompilerGeneratedAttribute]
public PointF get_UV();
    public float get_X();
    public float get_Y();
    public float get_U();
    public float get_V();
    public virtual string ToString();
}
public class DevExpress.Pdf.Drawing.PdfTensorProductBezierSurfaceRenderer : object {
    private PdfTensorProductBezierSurfaceInfo info;
    public double Width { get; }
    public double Height { get; }
    public PdfTensorProductBezierSurfaceRenderer(PdfTensorProductBezierSurfaceInfo info);
    private static RectangleF CreateBoundingRectangle(PointF[] points);
    private static double CalculateB0(double t);
    private static double CalculateB1(double t);
    private static double CalculateB2(double t);
    private static double CalculateB3(double t);
    private static float GetX(PointF point);
    private static float GetY(PointF point);
    private static double CalcBezierLength(PointF point1, PointF point2, PointF point3, PointF point4);
    public static RectangleF CreateBoundingRectangle(PdfTensorProductBezierSurfaceInfo info);
    public double get_Width();
    public double get_Height();
    private int CalculateCoord(double u, double v, Func`2<PointF, float> getCoord);
    public Point CalculatePoint(double u, double v);
    public Color CalculateColor(double u, double v);
}
public class DevExpress.Pdf.Drawing.PdfTensorProductBezierSurfaceTriangulator : object {
    private IPdfDirectXVerticesListBuilder verticesBuilder;
    private PdfRectangle bbox;
    private IList`1<Tuple`2<PdfTensorProductBezierSurface, int>> outSurfaces;
    private IDictionary`2<BezierCurvePoints, PdfTensorProductBezierSurfaceCoordinateEdge> edges;
    private int patchId;
    public float DepthFactor { get; }
    public PdfTensorProductBezierSurfaceTriangulator(IPdfDirectXVerticesListBuilder verticesBuilder, PdfRectangle bbox);
    public float get_DepthFactor();
    public void AppendSurface(PointF[0...,0...] points);
    public void BuildTriangles();
    private PdfTensorProductBezierSurfaceEdge GetEdge(BezierCurvePoints key, PointF startUV, PointF endUV);
    private bool IntersectsWithBBox(PdfTensorProductBezierSurface surface);
    private void TriangulateSurface(PdfTensorProductBezierSurface surface, int patchId);
    private void AddTriangle(PdfTensorProductBezierSurfacePoint p1, PdfTensorProductBezierSurfacePoint p2, PdfTensorProductBezierSurfacePoint p3, int patchId);
}
public class DevExpress.Pdf.Drawing.PdfTensorProductPatchPainter : PdfPatchMeshPainter {
    [CompilerGeneratedAttribute]
private IList`1<PdfTensorProductBezierSurfaceInfo> <Patches>k__BackingField;
    protected IList`1<PdfTensorProductBezierSurfaceInfo> Patches { get; }
    public PdfTensorProductPatchPainter(PdfTensorProductPatchMesh shading, bool shouldDrawBackground, bool shouldUseTransparentBackgroundColor, PdfTransformationMatrix matrix, int bitmapWidth, int bitmapHeight, PdfRectangle bbox);
    [CompilerGeneratedAttribute]
protected virtual IList`1<PdfTensorProductBezierSurfaceInfo> get_Patches();
}
public class DevExpress.Pdf.Drawing.PdfTextAnnotationPropertiesFormViewModel : PdfMarkupAnnotationPropertiesFormViewModel {
    private PdfTextAnnotationState state;
    private string previousIconName;
    public string IconName { get; public set; }
    public PdfViewerMarkupAnnotation Info { get; }
    public PdfTextAnnotationPropertiesFormViewModel(PdfTextAnnotationState state, PdfDocumentState documentState);
    public sealed virtual string get_IconName();
    public sealed virtual void set_IconName(string value);
    public virtual PdfViewerMarkupAnnotation get_Info();
    protected virtual void RollbackProperties();
    protected virtual void OnStatePropertyChanged(object sender, PropertyChangedEventArgs e);
    public virtual PdfViewerMarkupAnnotationChangingInfoState CreateOldInfo();
}
public class DevExpress.Pdf.Drawing.PdfTextAnnotationSettings : ValueType {
    [CompilerGeneratedAttribute]
private int <PageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    public int PageNumber { get; public set; }
    public PdfRectangle Bounds { get; public set; }
    public string IconName { get; public set; }
    public string Comment { get; public set; }
    public Color Color { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    [CompilerGeneratedAttribute]
public int get_PageNumber();
    [CompilerGeneratedAttribute]
public void set_PageNumber(int value);
    [CompilerGeneratedAttribute]
public PdfRectangle get_Bounds();
    [CompilerGeneratedAttribute]
public void set_Bounds(PdfRectangle value);
    [CompilerGeneratedAttribute]
public string get_IconName();
    [CompilerGeneratedAttribute]
public void set_IconName(string value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public Color get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Color value);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
}
public static class DevExpress.Pdf.Drawing.PdfTextHighlightColorRectanglePainter : object {
    private static Rectangle smallGlyphColorRectangle;
    private static Rectangle largeGlyphColorRectangle;
    private static PdfTextHighlightColorRectanglePainter();
    private static Image DrawColorRectangle(Image baseImage, Color fillColor, Rectangle rectangle);
    public static Image DrawSmallImageColorRectangle(Image baseImage, Color fillColor);
    public static Image DrawLargeImageColorRectangle(Image baseImage, Color fillColor);
}
public class DevExpress.Pdf.Drawing.PdfTextMarkupAnnotationPropertiesFormViewModel : PdfMarkupAnnotationPropertiesFormViewModel {
    private PdfTextMarkupAnnotationState state;
    private PdfTextMarkupAnnotationType previousMarkupType;
    public PdfTextMarkupAnnotationType MarkupType { get; public set; }
    public PdfViewerMarkupAnnotation Info { get; }
    public PdfTextMarkupAnnotationPropertiesFormViewModel(PdfTextMarkupAnnotationState state, PdfDocumentState documentState);
    public sealed virtual PdfTextMarkupAnnotationType get_MarkupType();
    public sealed virtual void set_MarkupType(PdfTextMarkupAnnotationType value);
    public virtual PdfViewerMarkupAnnotation get_Info();
    protected virtual void RollbackProperties();
    protected virtual void OnStatePropertyChanged(object sender, PropertyChangedEventArgs e);
    public virtual PdfViewerMarkupAnnotationChangingInfoState CreateOldInfo();
}
public class DevExpress.Pdf.Drawing.PdfTextMarkupAnnotationSettings : ValueType {
    [CompilerGeneratedAttribute]
private PdfTextMarkupAnnotationType <TextMarkupType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    public PdfTextMarkupAnnotationType TextMarkupType { get; public set; }
    public string Comment { get; public set; }
    public Color Color { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    [CompilerGeneratedAttribute]
public PdfTextMarkupAnnotationType get_TextMarkupType();
    [CompilerGeneratedAttribute]
public void set_TextMarkupType(PdfTextMarkupAnnotationType value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public Color get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(Color value);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
}
public class DevExpress.Pdf.Drawing.PdfTextMarkupToolController : PdfSelectionToolController {
    private PdfDocumentController documentController;
    private PdfTextMarkupAnnotationType ToolKind { get; }
    public PdfTextMarkupToolController(PdfDocumentController documentController);
    private PdfTextMarkupAnnotationType get_ToolKind();
    public virtual PdfCursor GetCursor(PdfMouseAction action);
    protected virtual void OnMouseUp(PdfMouseAction action);
}
public class DevExpress.Pdf.Drawing.PdfToolTipController : object {
    private IPdfViewerController viewerController;
    private object toolTipOwner;
    private IToolTip toolTip;
    public PdfToolTipController(IPdfViewerController viewerController);
    public void ShowToolTip(object owner, PdfToolTipSettings settings, int delayInMilliseconds);
    public void ShowToolTip(object owner, PdfToolTipSettings settings);
    public void HideToolTip(object owner);
    public void HideToolTips();
    private void HideToolTip();
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.PdfType3FontGlyphsCache`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    public TValue GetItem(TKey key);
    public void UpdateValue(TKey key, TValue value);
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Drawing.PdfType3FontGlyphsCacheKey : object {
    private PdfFont font;
    private PdfCommandList charProc;
    private int nonStrokingColor;
    private int a;
    private int b;
    private int c;
    private int d;
    public PdfType3FontGlyphsCacheKey(PdfFont font, PdfCommandList charProc, int nonStrokingColor, PdfTransformationMatrix matrix);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class DevExpress.Pdf.Drawing.PdfUserSpaceShadingCoordsConverter : object {
    private PdfTransformationMatrix matrix;
    public PdfUserSpaceShadingCoordsConverter(PdfTransformationMatrix matrix);
    private sealed virtual override PointF DevExpress.Pdf.Drawing.IShadingCoordsConverter.Convert(PdfPoint point);
}
public class DevExpress.Pdf.Drawing.PdfViewerBackend : PdfProcessingBackend {
    private IPdfViewerController viewerController;
    private PdfDocumentController documentController;
    private int rotationAngle;
    public int RotationAngle { get; public set; }
    protected bool SupportsCaching { get; }
    public PdfDocumentController DocumentController { get; }
    public PdfViewerBackend(IPdfViewerController viewerController);
    public int get_RotationAngle();
    public void set_RotationAngle(int value);
    protected virtual bool get_SupportsCaching();
    public PdfDocumentController get_DocumentController();
    public virtual void Dispose();
    protected virtual void OnSetDocumentState(PdfDocumentState documentState);
    protected virtual void ClearCaches();
    public void BeginRenderPages();
    public void EndRenderPages();
    public void ClearPageCache();
    public void RenderPage(int pageIndex, Graphics graphics, PointF location, float scale);
    public void RenderPage(int pageIndex, IPdfViewerGraphics graphics, PointF location, float scale);
    public DXBitmap CreateImageSelectionBitmap();
    public void Print(PdfPrinterSettings printerSettings, int currentPageNumber, bool showPrintStatus);
    public virtual void Print(PdfPrinterSettings printerSettings);
    [SecuritySafeCriticalAttribute]
private static GraphicsPath CreatePathOutline(GraphicsPath path);
    private void DrawSelection(int pageIndex, float scale, PointF position, IPdfViewerGraphics graphics);
    private static void AddUserSpacePolygonToGraphicsPath(GraphicsPath path, IList`1<PdfPoint> vertices, PdfPage page, float scale, PointF position, int rotationAngle);
    private static void AddPolygonToGraphicsPath(GraphicsPath path, IList`1<PdfPoint> vertices, PdfPage page, float scale, PointF position, int rotationAngle);
    [SecuritySafeCriticalAttribute]
private static void DrawSelectionRegion(GraphicsPath path, Color selectionColor, float dpiScale, IPdfViewerGraphics graphics);
    [CompilerGeneratedAttribute]
private PdfDocumentPrinter <Print>b__21_0(PdfPrinterSettings actualSettings);
}
public class DevExpress.Pdf.Drawing.PdfViewerCommandInterpreter : PdfLegacyCommandInterpreter {
    private static double degreeToRadianFactor;
    protected static float DefaultPageDpi;
    public static float DefaultDpi;
    public static float DpiFactor;
    private PdfGDIRenderingContext context;
    private int width;
    private int height;
    private float scale;
    private GraphicsState graphicsState;
    private double offsetX;
    private double offsetY;
    private double initialOffsetY;
    private double rotateAngle;
    private Stack`1<GDIPlusGraphicsState> graphicsStateStack;
    private PdfPoint[] transformedBoundingBox;
    private PdfType3FontGlyphsCache`2<PdfType3FontGlyphsCacheKey, Bitmap> type3GlyphCache;
    private PdfOptionalContentViewState viewState;
    private Graphics graphics;
    private FontQuality fontQuality;
    private GDITextRenderer textRenderer;
    private GDIPlusGraphicsState currentState;
    [CompilerGeneratedAttribute]
private int <RotationAngle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrinting>k__BackingField;
    private static PdfTransformationMatrix imageSpaceInversionMatrix;
    private static PdfPoint[] imagePoints;
    public int Width { get; }
    public int Height { get; }
    public PointF Location { get; }
    public PdfTransformationMatrix DeviceTransformationMatrix { get; }
    public PdfGDIRenderingContext Context { get; }
    protected IPdfRenderingFontInfoProvider RenderingFontInfoProvider { get; }
    public bool ShouldUseRectangularGraphicsPath { get; }
    public int RotationAngle { get; }
    private bool IsInTextRendering { get; }
    protected bool IsPrinting { get; }
    private PdfViewerCommandInterpreter(PdfGDIRenderingContext context, PdfPage page, Graphics graphics, float scale, int rotateAngle, PdfRectangle boundingBox, PointF position, bool isPrinting, PdfOptionalContentViewState viewState);
    private PdfViewerCommandInterpreter(PdfGDIRenderingContext context, PdfPage page, Graphics graphics, Size bitmapSize, bool isPrinting, PdfOptionalContentViewState viewState);
    public PdfViewerCommandInterpreter(PdfGDIRenderingContext context, PdfPage page, int rotationAngle, Graphics graphics, float scale, PointF position, bool isPrinting, PdfOptionalContentViewState viewState);
    private static PdfViewerCommandInterpreter();
    public static Bitmap GetTilingPatternKeyCellBitmap(PdfViewerCommandInterpreter baseInterpreter, PdfTilingPattern pattern, Size bitmapSize, Size keyBitmapSize, PdfColor color);
    public static double CalcAngle(PdfPoint startPoint, PdfPoint endPoint);
    private static void DrawTillingPatternKeyCell(PdfViewerCommandInterpreter baseInterpreter, Bitmap bitmap, PdfTilingPattern pattern, Size keyBitmapSize, PdfColor color);
    private static PdfTransformationMatrix CalculateBitmapTransformationMatrix(int bitmapWidth, int bitmapHeight, PdfRectangle boundingBox);
    private static void ApplySoftMask(PdfCustomSoftMask softMask, Bitmap bitmap, Bitmap softMaskBitmap);
    private static double CalculateDistanceSquare(PointF point1, PointF point2);
    public int get_Width();
    public int get_Height();
    public PointF get_Location();
    public PdfTransformationMatrix get_DeviceTransformationMatrix();
    public PdfGDIRenderingContext get_Context();
    protected virtual IPdfRenderingFontInfoProvider get_RenderingFontInfoProvider();
    public bool get_ShouldUseRectangularGraphicsPath();
    [CompilerGeneratedAttribute]
public int get_RotationAngle();
    private bool get_IsInTextRendering();
    [CompilerGeneratedAttribute]
protected virtual bool get_IsPrinting();
    public PointF TransformPoint(PdfPoint point);
    public Size CalculateSize(PdfTransformationMatrix matrix, PdfRectangle boundingBox);
    private Matrix GetImageMatrix(PointF location);
    public Bitmap GetBackdropBitmap(PdfRectangle boundingBox, int bitmapWidth, int bitmapHeight);
    public void DrawContent();
    private void PerformGraphicsOperation(Action action);
    private bool IsFlatPath(bool forFilling);
    private void UpdateSmoothingMode(bool forFilling);
    private void EnsureEndText();
    [SecuritySafeCriticalAttribute]
private void DoBeginText();
    [SecuritySafeCriticalAttribute]
private void DoEndText();
    private void UpdateCurrentFont();
    private void UpdateTextColor();
    [SecuritySafeCriticalAttribute]
private void DrawString(Int16[] stringData, Double[] glyphOffsets);
    private void FillStringPath(GraphicsPath stringPath);
    private void StrokeStringPath(GraphicsPath stringPath);
    private void DrawStringPath(GraphicsPath stringPath);
    private void UpdateStrokingBrush();
    private void UpdateNonStrokingBrush();
    private void UpdateBrushes();
    private double CalcFinalAngle(PdfPoint startPoint, PdfPoint endPoint);
    private double CalcLength(PdfPoint direction);
    private double CalcLineExtendFactor(PdfPoint startPoint, PdfPoint endPoint);
    private double GetLineWidth(PdfPoint startPoint, PdfPoint endPoint);
    private float GetPenWidth(PdfPoint startPoint, PdfPoint endPoint);
    private void UpdatePenProperties(Pen pen, PdfPoint startPoint, PdfPoint endPoint);
    private bool StrokeRectangle(Pen pen, PdfGraphicsPath path);
    private void DrawTilingPatternKeyCell(PdfTilingPattern pattern, PdfColor color);
    private PdfRectangle TrimBoundingBox(PdfRectangle boundingBox);
    private Bitmap CreateTransparencyGroupBitmap(PdfGroupForm form, Size bitmapSize, PdfTransformationMatrix transformationMatrix, PdfRectangle clipRectangle);
    private Bitmap CreateTransparencyGroupBitmap(PdfGroupForm form, PdfRectangle boundingBox, PdfRectangle clipRectangle);
    public void DrawBitmap(Bitmap bitmap, PdfRectangle boundingBox);
    private void PerformRendering(RectangleF bounds, Action drawAction);
    protected virtual void Dispose(bool disposing);
    protected virtual void UpdateGraphicsState(PdfGraphicsStateChange change);
    protected virtual void DrawType3Glyph(PdfType3FontGlyph glyph);
    protected virtual void DrawString(PdfStringData data);
    public virtual void SaveGraphicsState();
    public virtual void RestoreGraphicsState();
    public virtual void SetColorForStrokingOperations(PdfColor color);
    public virtual void SetColorForNonStrokingOperations(PdfColor color);
    public virtual void EndText();
    public virtual void SetFont(PdfFont font, double fontSize);
    private static int CalculateDistance(PointF point1, PointF point2);
    private static RectangleF CreateBoundingRectangle(IList`1<PointF> points);
    public virtual void DrawImage(PdfImage image);
    public virtual void DrawShading(PdfShading shading);
    protected virtual void StrokePaths();
    protected virtual void FillPaths(bool useNonzeroWindingRule);
    protected virtual void ClipPaths();
    public virtual void DrawTransparencyGroup(PdfGroupForm form);
    public virtual void DrawForm(PdfForm form);
    public virtual void DrawMarkedContent(IEnumerable`1<PdfCommand> commands, PdfProperties properties, string tag);
    [CompilerGeneratedAttribute]
private void <RestoreGraphicsState>b__91_0();
    [CompilerGeneratedAttribute]
private void <StrokePaths>b__102_0();
}
public class DevExpress.Pdf.Drawing.PdfViewerLayoutInfoProvider : object {
    private IPdfViewerController viewerController;
    private float DevExpress.Pdf.Native.IPdfViewerLayoutInfoProvider.ZoomFactor { get; }
    public PdfViewerLayoutInfoProvider(IPdfViewerController viewerController);
    private sealed virtual override float DevExpress.Pdf.Native.IPdfViewerLayoutInfoProvider.get_ZoomFactor();
    private sealed virtual override PdfPoint DevExpress.Pdf.Native.IPdfViewerLayoutInfoProvider.GetClientPoint(PdfDocumentPosition position);
    private sealed virtual override void DevExpress.Pdf.Native.IPdfViewerLayoutInfoProvider.EnsureVisible(int pageIndex, PdfRectangle bounds, bool inCenter);
}
public abstract class DevExpress.Pdf.Drawing.PdfViewerMarkupAnnotationBuilder`1 : object {
    [CompilerGeneratedAttribute]
private bool <IsSelected>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfAnnotationType <AnnotationType>k__BackingField;
    [CompilerGeneratedAttribute]
private TBuilder <Builder>k__BackingField;
    public bool IsSelected { get; public set; }
    public int PageNumber { get; }
    public PdfAnnotationType AnnotationType { get; }
    public PdfRectangle Bounds { get; }
    public string Name { get; public set; }
    public PdfRGBColor Color { get; public set; }
    public double Opacity { get; public set; }
    public Nullable`1<DateTimeOffset> CreationDate { get; public set; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public string Contents { get; public set; }
    protected TBuilder Builder { get; }
    protected PdfViewerMarkupAnnotationBuilder`1(TBuilder builder, PdfAnnotationType annotationType, int pageNumber);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSelected();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsSelected(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_PageNumber();
    [CompilerGeneratedAttribute]
public sealed virtual PdfAnnotationType get_AnnotationType();
    public sealed virtual PdfRectangle get_Bounds();
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public sealed virtual PdfRGBColor get_Color();
    public sealed virtual void set_Color(PdfRGBColor value);
    public sealed virtual double get_Opacity();
    public sealed virtual void set_Opacity(double value);
    public sealed virtual Nullable`1<DateTimeOffset> get_CreationDate();
    public sealed virtual void set_CreationDate(Nullable`1<DateTimeOffset> value);
    public sealed virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    public sealed virtual void set_ModificationDate(Nullable`1<DateTimeOffset> value);
    public sealed virtual string get_Author();
    public sealed virtual void set_Author(string value);
    public sealed virtual string get_Subject();
    public sealed virtual void set_Subject(string value);
    public sealed virtual string get_Contents();
    public sealed virtual void set_Contents(string value);
    [CompilerGeneratedAttribute]
protected TBuilder get_Builder();
}
public enum DevExpress.Pdf.Drawing.PdfViewerStringId : Enum {
    public int value__;
    public static PdfViewerStringId SortCommentsByDateCaption;
    public static PdfViewerStringId SortCommentsByAuthorCaption;
    public static PdfViewerStringId SortCommentsCheckedStatusCaption;
    public static PdfViewerStringId SortCommentsUncheckedStatusCaption;
    public static PdfViewerStringId SortCommentsByPageCaption;
    public static PdfViewerStringId SortCommentsByTypeCaption;
}
public class DevExpress.Pdf.Drawing.PdfViewerTextAnnotationBuilder : PdfViewerMarkupAnnotationBuilder`1<PdfTextAnnotationBuilder> {
    public string IconName { get; public set; }
    internal PdfViewerTextAnnotationBuilder(PdfTextAnnotationBuilder builder, int pageNumber);
    public sealed virtual string get_IconName();
    public sealed virtual void set_IconName(string value);
}
public class DevExpress.Pdf.Drawing.PdfViewerTextMarkupAnnotationBuilder : PdfViewerMarkupAnnotationBuilder`1<PdfTextMarkupAnnotationBuilder> {
    [CompilerGeneratedAttribute]
private string <SelectedText>k__BackingField;
    public PdfTextMarkupAnnotationType Style { get; public set; }
    public IList`1<PdfQuadrilateral> Quads { get; }
    public string SelectedText { get; }
    internal PdfViewerTextMarkupAnnotationBuilder(PdfTextMarkupAnnotationBuilder builder, int pageNumber, string selectedText);
    public sealed virtual PdfTextMarkupAnnotationType get_Style();
    public sealed virtual void set_Style(PdfTextMarkupAnnotationType value);
    public sealed virtual IList`1<PdfQuadrilateral> get_Quads();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SelectedText();
}
public class DevExpress.Pdf.Drawing.PdfWidgetAnnotationController : PdfAnnotationController`1<PdfWidgetAnnotationState> {
    public bool AcceptTabStop { get; }
    protected bool ReadOnly { get; }
    public PdfWidgetAnnotationController(IPdfPageController pageController, PdfWidgetAnnotationState widgetState);
    public virtual bool get_AcceptTabStop();
    protected bool get_ReadOnly();
    protected virtual void OnMouseUp(PdfMouseAction action);
    protected virtual void OnClick();
    protected virtual void OnGotFocus();
    protected virtual void OnLostFocus();
}
public class DevExpress.Pdf.Drawing.Printing.DocumentPrinter : object {
    private IList`1<int> pageIndices;
    private PdfPrintDocumentCalculator calculator;
    private PdfDocumentState documentState;
    private IPdfPrintingCallbackProvider callbackProvider;
    private int currentPageIndex;
    private bool printInGrayscale;
    public int CurrentPrintingPageIndex { get; }
    public PdfPrintDocumentCalculator Calculator { get; }
    public bool PrintInGrayscale { get; }
    public PdfDocumentState DocumentState { get; }
    public PdfPrinterSettings PrinterSettings { get; }
    private DocumentPrinter(IList`1<int> pageIndices, PdfDocumentState documentState, PdfPrinterSettings printerSettings, IPdfPrintingCallbackProvider callbackProvider);
    public static DocumentPrinter Create(PdfDocumentState documentState, PdfPrinterSettings printerSettings, int currentPageNumber, IPdfPrintingCallbackProvider callbackProvider);
    public int get_CurrentPrintingPageIndex();
    public PdfPrintDocumentCalculator get_Calculator();
    public bool get_PrintInGrayscale();
    public PdfDocumentState get_DocumentState();
    public PdfPrinterSettings get_PrinterSettings();
    public PrintPageResult PrintPage(IPagePrinter pagePrinter);
    public bool QueryPageSettings(PageSettings pageSettings);
    public void RaisePrintPage(PrintPageEventArgs args);
}
public interface DevExpress.Pdf.Drawing.Printing.INativeDocumentPrinter {
    public abstract virtual void Print();
    public abstract virtual void StopPrinting();
}
public interface DevExpress.Pdf.Drawing.Printing.IPagePrinter {
    public abstract virtual PrintPageResult PrintPage(bool hasMorePages);
}
public interface DevExpress.Pdf.Drawing.Printing.IPdfValueWrapper`1 {
    public T Value { get; public set; }
    public bool IsChanged { get; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
    public abstract virtual bool get_IsChanged();
    public abstract virtual void Refresh();
}
public class DevExpress.Pdf.Drawing.Printing.PdfBufferedPrintDocumentPage : PdfPrintDocumentPage {
    private PdfGDIDocumentRenderer renderer;
    public PdfBufferedPrintDocumentPage(PdfGDIDocumentRenderer renderer, PdfPageState pageState, PdfPrintDocumentCalculator calculator);
    public virtual void DrawPage(Graphics graphics);
}
public class DevExpress.Pdf.Drawing.Printing.PdfCachedPageSettings : object {
    private static string printerResolutionFieldName;
    private static string paperSourceFieldName;
    private static string landscapeFieldName;
    private PageSettings settings;
    private IPdfValueWrapper`1<PrinterResolution> printerResolution;
    private IPdfValueWrapper`1<bool> landscape;
    private IPdfValueWrapper`1<PaperSource> paperSource;
    private IPdfValueWrapper`1<PaperSize> paperSize;
    private PdfPrinterSettingsCache cache;
    private PrinterSettings prevoiusPrinterSettings;
    public PageSettings NativeSettings { get; }
    public float HardMarginX { get; }
    public float HardMarginY { get; }
    public RectangleF PrintableArea { get; }
    public PaperSize PaperSize { get; }
    public PrinterResolution PrinterResolution { get; public set; }
    public PaperSource PaperSource { get; public set; }
    public bool Landscape { get; public set; }
    public PdfCachedPageSettings(PageSettings settings);
    public PdfCachedPageSettings(PageSettings settings, PdfPrinterSettingsCache cache);
    public PageSettings get_NativeSettings();
    public float get_HardMarginX();
    public float get_HardMarginY();
    public RectangleF get_PrintableArea();
    public PaperSize get_PaperSize();
    public PrinterResolution get_PrinterResolution();
    public void set_PrinterResolution(PrinterResolution value);
    public PaperSource get_PaperSource();
    public void set_PaperSource(PaperSource value);
    public bool get_Landscape();
    public void set_Landscape(bool value);
    public void Refresh(bool refreshInfo);
    public void RefreshIfChanged();
    private void Refresh();
}
public class DevExpress.Pdf.Drawing.Printing.PdfCachedPrinterSettings : object {
    private static string printerNameFieldName;
    private static string copiesFieldName;
    private static string collateFieldName;
    private PrinterSettings settings;
    private PdfCachedPageSettings pageSettings;
    private IPdfValueWrapper`1<short> copies;
    private IPdfValueWrapper`1<bool> collate;
    private IPdfValueWrapper`1<string> printerName;
    private PdfPrinterSettingsCache info;
    public bool IsXPSDriver { get; }
    public PrinterResolutionCollection PrinterResolutions { get; }
    public PdfCachedPageSettings DefaultPageSettings { get; }
    public int MaximumCopies { get; }
    public PrinterSettings NativeSettings { get; }
    public bool IsValid { get; }
    public PaperSourceCollection PaperSources { get; }
    public bool SupportCollate { get; }
    public PrintRange PrintRange { get; public set; }
    public int FromPage { get; public set; }
    public int ToPage { get; public set; }
    public short Copies { get; public set; }
    public bool Collate { get; public set; }
    public bool PrintToFile { get; public set; }
    public string PrintFileName { get; public set; }
    public string PrinterName { get; public set; }
    public PdfCachedPrinterSettings(PrinterSettings settings);
    public bool get_IsXPSDriver();
    public PrinterResolutionCollection get_PrinterResolutions();
    public PdfCachedPageSettings get_DefaultPageSettings();
    public int get_MaximumCopies();
    public PrinterSettings get_NativeSettings();
    public bool get_IsValid();
    public PaperSourceCollection get_PaperSources();
    public bool get_SupportCollate();
    public PrintRange get_PrintRange();
    public void set_PrintRange(PrintRange value);
    public int get_FromPage();
    public void set_FromPage(int value);
    public int get_ToPage();
    public void set_ToPage(int value);
    public short get_Copies();
    public void set_Copies(short value);
    public bool get_Collate();
    public void set_Collate(bool value);
    public bool get_PrintToFile();
    public void set_PrintToFile(bool value);
    public string get_PrintFileName();
    public void set_PrintFileName(string value);
    public string get_PrinterName();
    public void set_PrinterName(string value);
    [CompilerGeneratedAttribute]
private string <.ctor>b__49_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__49_1(string value);
    [CompilerGeneratedAttribute]
private short <.ctor>b__49_2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__49_3(short value);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__49_4();
    [CompilerGeneratedAttribute]
private void <.ctor>b__49_5(bool value);
}
public class DevExpress.Pdf.Drawing.Printing.PdfColorTilePrintDocumentPage : PdfTilePrintDocumentPage {
    public PdfColorTilePrintDocumentPage(PdfDocumentRenderer renderer, PdfPageState pageState, PdfPrintDocumentCalculator calculator, int divisionCount);
    protected virtual void DrawTile(Graphics graphics, Bitmap pagePart, Rectangle graphicsRect);
}
public class DevExpress.Pdf.Drawing.Printing.PdfDirectXMetafileBuilder : object {
    private IntPtr printerHdc;
    public PdfDirectXMetafileBuilder(string printerName, HDevModeHandle hdevMode);
    [SecuritySafeCriticalAttribute]
private static IntPtr CreateDC(string printerName, IntPtr devmode);
    [SecuritySafeCriticalAttribute]
private static void DeleteDC(IntPtr printerHdc);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public Byte[] CreateMetafile(Action`1<Graphics> paintCallback, RectangleF InchOverlayRect);
}
public class DevExpress.Pdf.Drawing.Printing.PdfDirectXNativePrinter : object {
    private DocumentPrinter printer;
    private PrintController printController;
    private PdfDirectXRenderingContext context;
    private string documentName;
    private PrintDocument stubPrintDocument;
    public PdfDirectXNativePrinter(PdfDirectXRenderingContext context, DocumentPrinter printer, string documentName, bool showPrintStatusDialog);
    public sealed virtual void Print();
    public sealed virtual void StopPrinting();
    public sealed virtual void Dispose();
    private bool EndPrint();
    private bool EndPage();
    private bool StartPage();
}
public class DevExpress.Pdf.Drawing.Printing.PdfDirectXPagePrinter : object {
    private DocumentPrinter printer;
    private NativeStream pageTicketStream;
    private D2D1PrintControl printControl;
    private PdfDirectXRenderingContext context;
    private PdfDirectXMetafileBuilder metafileBuilder;
    private Byte[] emptyNativeMetafile;
    private bool isXPSPrinting;
    private RectangleF InchOverlayRect { get; }
    public PdfDirectXPagePrinter(DocumentPrinter printer, NativeStream pageTicketStream, D2D1PrintControl printControl, PdfDirectXRenderingContext context, PdfDirectXMetafileBuilder metafileBuilder);
    private static bool CompareArrays(Byte[] array1, Byte[] array2);
    private RectangleF get_InchOverlayRect();
    public sealed virtual PrintPageResult PrintPage(bool hasMorePages);
    private PrintPageResult RaisePrintPage(bool hasMorePages, Graphics graphics);
}
public class DevExpress.Pdf.Drawing.Printing.PdfDirectXPrintDocumentPageFactory : PdfPrintDocumentPageFactory {
    private PdfDirectXDocumentRenderer renderer;
    public PdfDirectXPrintDocumentPageFactory(PdfDirectXDocumentRenderer renderer);
    public virtual PdfPrintDocumentPage Create(DocumentPrinter printer);
}
public class DevExpress.Pdf.Drawing.Printing.PdfDocumentPrinter : object {
    private PdfDocumentState documentState;
    private PdfPrinterSettings printerSettings;
    private int currentPageNumber;
    private string documentFilePath;
    private bool showPrintStatusDialog;
    private PdfDocumentRenderer renderer;
    private IPdfPrintingCallbackProvider callbackProvider;
    public IPdfPrintingCallbackProvider CallbackProvider { get; public set; }
    public PdfDocumentPrinter(PdfDocumentRenderer renderer, PdfDocumentState documentState, PdfPrinterSettings printerSettings, int currentPageNumber, string documentFilePath, bool showPrintStatusDialog);
    public PdfDocumentPrinter(PdfDocumentRenderer renderer, PdfDocumentState documentState, PdfPrinterSettings printerSettings, IPdfViewerController viewerController);
    public PdfDocumentPrinter(PdfDocumentRenderer renderer, PdfDocumentState state, PdfPrinterSettings settings);
    public IPdfPrintingCallbackProvider get_CallbackProvider();
    public void set_CallbackProvider(IPdfPrintingCallbackProvider value);
    public void Print();
}
public class DevExpress.Pdf.Drawing.Printing.PdfGDINativePagePrinter : object {
    private PrintPageEventArgs args;
    private DocumentPrinter printer;
    private PdfPrintDocumentPageFactory pageFactory;
    public PdfGDINativePagePrinter(PrintPageEventArgs args, DocumentPrinter printer, PdfPrintDocumentPageFactory pageFactory);
    public sealed virtual PrintPageResult PrintPage(bool hasMorePages);
}
[ToolboxItemAttribute("False")]
public class DevExpress.Pdf.Drawing.Printing.PdfGDINativePrinter : PrintDocument {
    private DocumentPrinter printer;
    private PdfPrintDocumentPageFactory pageFactory;
    public PdfGDINativePrinter(DocumentPrinter printer, PdfPrintDocumentPageFactory pageFactory, string documentName, bool showPrintStatusDialog);
    public sealed virtual void StopPrinting();
    protected virtual void OnPrintPage(PrintPageEventArgs e);
    protected virtual void OnQueryPageSettings(QueryPageSettingsEventArgs e);
    private sealed virtual override void DevExpress.Pdf.Drawing.Printing.INativeDocumentPrinter.Print();
}
public class DevExpress.Pdf.Drawing.Printing.PdfGDIPrintDocumentPageFactory : PdfPrintDocumentPageFactory {
    private PdfGDIDocumentRenderer renderer;
    public PdfGDIPrintDocumentPageFactory(PdfGDIDocumentRenderer renderer);
    public virtual PdfPrintDocumentPage Create(DocumentPrinter printer);
}
public class DevExpress.Pdf.Drawing.Printing.PdfGrayscaleTilePrintDocumentPage : PdfTilePrintDocumentPage {
    private ImageAttributes grayscaleAttributes;
    public PdfGrayscaleTilePrintDocumentPage(PdfDocumentRenderer renderer, PdfPageState pageState, PdfPrintDocumentCalculator calculator, int divisionCount);
    protected virtual void DrawTile(Graphics graphics, Bitmap pagePart, Rectangle graphicsRect);
    protected virtual void Dispose(bool disposing);
}
public class DevExpress.Pdf.Drawing.Printing.PdfNativePrintDocumentPage : PdfPrintDocumentPage {
    private PdfGDIDocumentRenderer renderer;
    public PdfNativePrintDocumentPage(PdfGDIDocumentRenderer renderer, PdfPageState pageState, PdfPrintDocumentCalculator calculator);
    public virtual void DrawPage(Graphics graphics);
}
internal class DevExpress.Pdf.Drawing.Printing.PdfPaperSizeValueWrapper : PdfReflectionValueWrapper`1<PaperSize> {
    private static string fieldName;
    private PdfPrinterSettingsCache cache;
    private PdfPaperSizeValueWrapper(PageSettings source, FieldInfo fieldInfo, Func`1<PaperSize> getValueAction, Action`1<PaperSize> setValueAction, PdfPrinterSettingsCache cache);
    public static PdfValueWrapper`1<PaperSize> Create(PageSettings settings, PdfPrinterSettingsCache cache);
    protected virtual PaperSize ValidateValue(PaperSize value);
}
public abstract class DevExpress.Pdf.Drawing.Printing.PdfPrintCalculator : object {
    public static float UnitsPerDot;
    private static int defaultPageWidth;
    private static int defaultPageHeight;
    private int pageRotationAngle;
    private PdfPrinterSettings printerSettings;
    private PdfPage page;
    private PdfCachedPageSettings pageSettings;
    private float scale;
    private Size paperSize;
    private SizeF pageSize;
    private Nullable`1<PointF> pageOffset;
    private bool hasException;
    private bool recalculateLandscape;
    private Nullable`1<SizeF> printableAreaSize;
    public PdfCachedPageSettings PageSettings { get; }
    public PdfPrinterSettings PrinterSettings { get; public set; }
    public PdfPage Page { get; public set; }
    public Size PaperSize { get; }
    public SizeF PageSize { get; }
    public float Scale { get; }
    public PointF PageOffset { get; }
    public bool RecalculateLandscape { get; public set; }
    internal bool HasException { get; }
    protected SizeF PrintableAreaSize { get; }
    private PaperSize PrintPaperSize { get; }
    protected PdfPrintCalculator(PdfPrinterSettings printerSettings, PdfPage page, int pageRotationAngle);
    public PdfCachedPageSettings get_PageSettings();
    public PdfPrinterSettings get_PrinterSettings();
    public void set_PrinterSettings(PdfPrinterSettings value);
    public PdfPage get_Page();
    public void set_Page(PdfPage value);
    public Size get_PaperSize();
    public SizeF get_PageSize();
    public float get_Scale();
    public PointF get_PageOffset();
    public bool get_RecalculateLandscape();
    public void set_RecalculateLandscape(bool value);
    internal bool get_HasException();
    protected SizeF get_PrintableAreaSize();
    private PaperSize get_PrintPaperSize();
    protected SizeF GetCurrentPageSize();
    protected virtual void CalculateAll();
    public virtual void Update();
    public void SetPageSettings(PageSettings value);
    private void CalculatePageOffset();
    private void CalculatePageLandscape();
    private float CalculateScale();
    private void CalculatePageSize();
}
public class DevExpress.Pdf.Drawing.Printing.PdfPrintDocumentCalculator : PdfPrintCalculator {
    private int printerResolution;
    private float printingDpi;
    private Nullable`1<Rectangle> rectangle;
    private bool isDrawOnGraphics;
    public Rectangle Rectangle { get; }
    public float PrintingDpi { get; }
    public float PrintScale { get; }
    public bool IsDrawOnGraphics { get; }
    public SizeF PrintingPaperSize { get; }
    private PointF PrintOffset { get; }
    public PdfPrintDocumentCalculator(PdfPrinterSettings printerSettings, PdfPage page, int pageRotationAngle);
    public Rectangle get_Rectangle();
    public float get_PrintingDpi();
    public float get_PrintScale();
    public bool get_IsDrawOnGraphics();
    public SizeF get_PrintingPaperSize();
    private PointF get_PrintOffset();
    public PointF GetOffset(Rectangle rect);
    public void CalculatePrintingDpi(float printerGraphicsDpi);
    public virtual void Update();
    protected virtual void CalculateAll();
}
public abstract class DevExpress.Pdf.Drawing.Printing.PdfPrintDocumentPage : PdfDisposableObject {
    [CompilerGeneratedAttribute]
private PdfPrintDocumentCalculator <Calculator>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfPageState <PageState>k__BackingField;
    protected PdfPrintDocumentCalculator Calculator { get; }
    protected PdfPageState PageState { get; }
    protected PdfPrintDocumentPage(PdfPageState pageState, PdfPrintDocumentCalculator calculator);
    [CompilerGeneratedAttribute]
protected PdfPrintDocumentCalculator get_Calculator();
    [CompilerGeneratedAttribute]
protected PdfPageState get_PageState();
    public abstract virtual void DrawPage(Graphics graphics);
    protected virtual void Dispose(bool disposing);
}
public abstract class DevExpress.Pdf.Drawing.Printing.PdfPrintDocumentPageFactory : object {
    private static double colorMByteSize;
    private static double maxImageSize;
    [SecuritySafeCriticalAttribute]
protected static int GetDivisionCount(Rectangle rectangle);
    public abstract virtual PdfPrintDocumentPage Create(DocumentPrinter printer);
}
public class DevExpress.Pdf.Drawing.Printing.PdfPrinterSettingsCache : object {
    private static int DC_COPIES;
    private static int DC_ENUMRESOLUTIONS;
    private static int DC_BINNAMES;
    private static int DC_BINS;
    private static int DC_PAPERNAMES;
    private static int DC_PAPERS;
    private static int DC_PAPERSIZE;
    private static int DC_COLLATE;
    private static int DM_DEFAULTSOURCE;
    private static int DM_PAPERSIZE;
    private static int DM_PRINTQUALITY;
    private static int DM_YRESOLUTION;
    private static int binNameStringBufferSize;
    private static int paperSizeNameStringBufferSize;
    private static int DMCOLLATE_TRUE;
    private static int DMORIENT_LANDSCAPE;
    private static int HORZRES;
    private static int VERTRES;
    private static int LOGPIXELSX;
    private static int LOGPIXELSY;
    private static int PHYSICALOFFSETX;
    private static int PHYSICALOFFSETY;
    private static int PD_RETURNDEFAULT;
    private static int GETTECHNOLOGY;
    private PageSettings sourceSettings;
    private bool isXPSDriver;
    private short copies;
    private bool collate;
    private bool landscape;
    private RectangleF printableArea;
    private float hardMarginX;
    private float hardMarginY;
    private PrinterResolution printerResolution;
    private PaperSize paperSize;
    private PaperSource paperSource;
    private int maximumCopies;
    private bool isValid;
    private PrinterResolutionCollection printerResolutions;
    private PaperSourceCollection paperSources;
    private PaperSizeCollection paperSizes;
    private bool supportCollate;
    private string printerName;
    private PdfPrinterSettingsCacheRefreshFlags flags;
    private Exception lastException;
    public short Copies { get; public set; }
    public bool Collate { get; public set; }
    public PrinterResolution PrinterResolution { get; public set; }
    public bool Landscape { get; public set; }
    public PaperSize PaperSize { get; public set; }
    public PaperSource PaperSource { get; public set; }
    public bool IsXPSDriver { get; }
    public int MaximumCopies { get; }
    public RectangleF PrintableArea { get; }
    public float HardMarginX { get; }
    public float HardMarginY { get; }
    public PrinterResolutionCollection PrinterResolutions { get; }
    public bool IsValid { get; }
    public PaperSourceCollection PaperSources { get; }
    public PaperSizeCollection PaperSizes { get; }
    public bool SupportCollate { get; }
    public string PrinterName { get; public set; }
    private PrinterSettings PrinterSettings { get; }
    public PdfPrinterSettingsCache(PageSettings sourceSettings);
    [SecuritySafeCriticalAttribute]
private static string ReadNameFromBuffer(IntPtr pointer, int stringBufferSize);
    [SecuritySafeCriticalAttribute]
private static string ReadOutputPort(IntPtr hDevNames);
    [SecuritySafeCriticalAttribute]
private static string GetOutputPort();
    [SecuritySafeCriticalAttribute]
private static int DeviceCapabilities(string printerName, string outputPort, short capability, IntPtr pointerToBuffer, int defaultValue);
    private static PrinterResolution CreatePrinterResolution(PrinterResolutionKind kind, int x, int y);
    [SecuritySafeCriticalAttribute]
private static PrinterResolution[] GetPrinterResolutions(string printerName, string outputPort);
    [SecuritySafeCriticalAttribute]
private static PaperSource[] GetPaperSources(string printerName, string outputPort);
    [SecuritySafeCriticalAttribute]
private static PaperSize[] GetPaperSizes(string printerName, string outputPort);
    private static PrinterResolution ReadPrinterResolution(DEVMODE mode, PrinterResolutionCollection printerResolutions);
    private static PaperSize ReadPaperSize(DEVMODE mode, PaperSizeCollection paperSizes);
    private static PaperSource ReadPaperSource(DEVMODE mode, PaperSourceCollection paperSources);
    [SecuritySafeCriticalAttribute]
private static bool CheckXPSDriver(IntPtr hdc);
    public short get_Copies();
    public void set_Copies(short value);
    public bool get_Collate();
    public void set_Collate(bool value);
    public PrinterResolution get_PrinterResolution();
    public void set_PrinterResolution(PrinterResolution value);
    public bool get_Landscape();
    public void set_Landscape(bool value);
    public PaperSize get_PaperSize();
    public void set_PaperSize(PaperSize value);
    public PaperSource get_PaperSource();
    public void set_PaperSource(PaperSource value);
    public bool get_IsXPSDriver();
    public int get_MaximumCopies();
    public RectangleF get_PrintableArea();
    public float get_HardMarginX();
    public float get_HardMarginY();
    public PrinterResolutionCollection get_PrinterResolutions();
    public bool get_IsValid();
    public PaperSourceCollection get_PaperSources();
    public PaperSizeCollection get_PaperSizes();
    public bool get_SupportCollate();
    public string get_PrinterName();
    public void set_PrinterName(string value);
    private PrinterSettings get_PrinterSettings();
    public void Refresh(PdfPrinterSettingsCacheRefreshFlags flags);
    public PaperSize GetValidPaperSize(PaperSize paperSize);
    private T GetProperty(Func`1<T> getPropertyAction, bool suppressException);
    [SecuritySafeCriticalAttribute]
private void UpdateInfo(PdfPrinterSettingsCacheRefreshFlags flags);
    [CompilerGeneratedAttribute]
private short <get_Copies>b__57_0();
    [CompilerGeneratedAttribute]
private bool <get_Collate>b__60_0();
    [CompilerGeneratedAttribute]
private PrinterResolution <get_PrinterResolution>b__63_0();
    [CompilerGeneratedAttribute]
private bool <get_Landscape>b__66_0();
    [CompilerGeneratedAttribute]
private PaperSize <get_PaperSize>b__69_0();
    [CompilerGeneratedAttribute]
private PaperSource <get_PaperSource>b__72_0();
    [CompilerGeneratedAttribute]
private bool <get_IsXPSDriver>b__75_0();
    [CompilerGeneratedAttribute]
private int <get_MaximumCopies>b__77_0();
    [CompilerGeneratedAttribute]
private RectangleF <get_PrintableArea>b__79_0();
    [CompilerGeneratedAttribute]
private float <get_HardMarginX>b__81_0();
    [CompilerGeneratedAttribute]
private float <get_HardMarginY>b__83_0();
    [CompilerGeneratedAttribute]
private PrinterResolutionCollection <get_PrinterResolutions>b__85_0();
    [CompilerGeneratedAttribute]
private bool <get_IsValid>b__87_0();
    [CompilerGeneratedAttribute]
private PaperSourceCollection <get_PaperSources>b__89_0();
    [CompilerGeneratedAttribute]
private PaperSizeCollection <get_PaperSizes>b__91_0();
    [CompilerGeneratedAttribute]
private bool <get_SupportCollate>b__93_0();
    [CompilerGeneratedAttribute]
private string <get_PrinterName>b__95_0();
    [CompilerGeneratedAttribute]
private PaperSizeCollection <GetValidPaperSize>b__101_0();
}
[FlagsAttribute]
public enum DevExpress.Pdf.Drawing.Printing.PdfPrinterSettingsCacheRefreshFlags : Enum {
    public int value__;
    public static PdfPrinterSettingsCacheRefreshFlags None;
    public static PdfPrinterSettingsCacheRefreshFlags PageSettings;
    public static PdfPrinterSettingsCacheRefreshFlags PrinterSettings;
    public static PdfPrinterSettingsCacheRefreshFlags All;
}
public class DevExpress.Pdf.Drawing.Printing.PdfPrintPreviewCalculator : PdfPrintCalculator {
    private static int border;
    private int largestEdgeLength;
    private Nullable`1<Point> pagePosition;
    private Rectangle paperRectangle;
    private Size previewSize;
    private PointF[] unprintableArea;
    private Rectangle printablePageArea;
    private Rectangle printablePaperArea;
    private Nullable`1<bool> isDrawPageRectangle;
    public int LargestEdgeLength { get; }
    public Point PagePosition { get; }
    public Rectangle PaperRectangle { get; }
    public bool IsDrawPageRectangle { get; }
    public Size PreviewSize { get; public set; }
    public Rectangle PrintablePageArea { get; }
    public PointF[] UnprintableArea { get; }
    public PdfPrintPreviewCalculator(PdfPrinterSettings printerSettings, PdfPage page, Size previewSize, int pageRotationAngle);
    private static int ToInt(float value);
    public int get_LargestEdgeLength();
    public Point get_PagePosition();
    public Rectangle get_PaperRectangle();
    public bool get_IsDrawPageRectangle();
    public Size get_PreviewSize();
    public void set_PreviewSize(Size value);
    public Rectangle get_PrintablePageArea();
    public PointF[] get_UnprintableArea();
    public virtual void Update();
    protected virtual void CalculateAll();
    private void CalculateUnprintableArea();
    private void CalculatePreviewPositions();
    private void CalculatePrintablePaperArea(float scaleFactor);
    private Size GetCurrentPageSize(float scaleFactor);
}
internal class DevExpress.Pdf.Drawing.Printing.PdfReflectionValueWrapper`1 : PdfValueWrapper`1<T> {
    private object source;
    private FieldInfo fieldInfo;
    private object defaultValue;
    private MethodInfo convertMethod;
    private object previousValue;
    public T Value { get; public set; }
    public bool IsChanged { get; }
    protected PdfReflectionValueWrapper`1(object source, FieldInfo fieldInfo, object defaultFieldValue, Func`1<T> getValueAction, Action`1<T> setValueAction);
    protected static FieldInfo GetFieldInfo(object source, string fieldName);
    public static PdfValueWrapper`1<T> Create(object source, string fieldName, Func`1<T> getValueAction, Action`1<T> setValueAction);
    public static PdfValueWrapper`1<T> Create(object source, string fieldName, object defaultFieldValue, Func`1<T> getValueAction, Action`1<T> setValueAction);
    public virtual T get_Value();
    public virtual void set_Value(T value);
    public virtual bool get_IsChanged();
    public virtual void Refresh();
    protected virtual T ValidateValue(T value);
}
public abstract class DevExpress.Pdf.Drawing.Printing.PdfTilePrintDocumentPage : PdfPrintDocumentPage {
    private int divisionCount;
    private PdfDocumentRenderer renderer;
    protected PdfTilePrintDocumentPage(PdfDocumentRenderer renderer, PdfPageState pageState, PdfPrintDocumentCalculator calculator, int divisionCount);
    private static IEnumerable`1<Rectangle> GetTileRectangles(Rectangle visibleRect, int divisionCount);
    public virtual void DrawPage(Graphics graphics);
    protected abstract virtual void DrawTile(Graphics graphics, Bitmap pagePart, Rectangle graphicsRect);
    protected Bitmap GetTile(Rectangle pageRect, Rectangle tileRect);
}
public class DevExpress.Pdf.Drawing.Printing.PdfValueWrapper`1 : object {
    private Func`1<T> getValueAction;
    private Action`1<T> setValueAction;
    private T actualValue;
    private bool isValueSet;
    public T Value { get; public set; }
    public bool IsChanged { get; }
    public PdfValueWrapper`1(Func`1<T> getValueAction, Action`1<T> setValueAction);
    public virtual T get_Value();
    public virtual void set_Value(T value);
    public virtual bool get_IsChanged();
    public virtual void Refresh();
}
public class DevExpress.Pdf.Drawing.Printing.PrintPageResult : ValueType {
    private bool canceled;
    private bool hasMorePages;
    public bool HasMorePages { get; public set; }
    public bool Canceled { get; }
    public PrintPageResult(bool hasMorePages, bool canceled);
    public bool get_HasMorePages();
    public void set_HasMorePages(bool value);
    public bool get_Canceled();
}
public static class DevExpress.Pdf.Drawing.Printing.PrintStatusDialogHelper : object {
    public static PrintController CreatePrintControllerWithStatusDialog(PrintController controller);
}
public static class DevExpress.Pdf.Drawing.RenderGlyphRunFactory : object {
    private static PdfTransformationMatrix textSpaceInversionMatrix;
    private static RenderGlyphRunFactory();
    private static IList`1<TRun> CreateVerticalGlyphRuns(IRenderGlyphRunFont`1<TRun> renderFont, Int16[] str, Double[] glyphAdvances, PdfTextState textState);
    public static IList`1<TRun> CreateGlyphRuns(IRenderGlyphRunFont`1<TRun> renderFont, PdfStringData stringData, PdfTextState textState);
    private static PdfTransformationMatrix GetMatrix(PdfTransformationMatrix textSpaceMatrix, PdfTextState textState, double scaleX, double advance);
    private static T[] GetArraySegment(T[] array, int fromIndex, int toIndex);
}
internal class DevExpress.Pdf.Drawing.Win32IconService : PdfFileIconService {
    [SecuritySafeCriticalAttribute]
private static int GetIconIndex(string pszFile);
    private static int GetIconSize(int dimension);
    [SecuritySafeCriticalAttribute]
private IntPtr GetIconHandle(string extension, int iconSize);
    [SecuritySafeCriticalAttribute]
protected virtual Byte[] GetIconData(string extension, int dimension);
}
internal class DevExpress.Pdf.Drawing.Win32PolygonBoolOperationProvider : object {
    private D2D1Factory1 d2dFactory;
    private Win32PolygonBoolOperationProvider(D2D1Factory1 factory);
    public static IPolygonBooleanOperationProvider Create();
    private static D2D_POINT_2F ConvertPoint(PdfPoint pt);
    private static PdfPoint ConvertPoint(D2D_POINT_2F pt);
    private D2D1PathGeometry CreateGeometry(PdfGraphicsPolygon polygon);
    public sealed virtual PdfGraphicsPolygon Difference(PdfGraphicsPolygon subjectPolygon, PdfGraphicsPolygon clipPolygon);
    public sealed virtual void Dispose();
}
public class DevExpress.Pdf.Interop.ABCFLOAT : ValueType {
    private float abcfA;
    private float abcfB;
    private float abcfC;
    public float A { get; }
    public float B { get; }
    public float C { get; }
    public float get_A();
    public float get_B();
    public float get_C();
}
internal enum DevExpress.Pdf.Interop.BackgroundMode : Enum {
    public int value__;
    public static BackgroundMode TRANSPARENT;
}
internal static class DevExpress.Pdf.Interop.Comdlg32Interop : object {
    public static bool PrintDlg(PRINTDLG lppd);
    public static bool PrintDlg(PRINTDLGX86 lppd);
}
internal class DevExpress.Pdf.Interop.DEVMODE : object {
    private string dmDeviceName;
    private short dmSpecVersion;
    private short dmDriverVersion;
    private short dmSize;
    private short dmDriverExtra;
    private int dmFields;
    private short dmOrientation;
    private short dmPaperSize;
    private short dmPaperLength;
    private short dmPaperWidth;
    private short dmScale;
    private short dmCopies;
    private short dmDefaultSource;
    private short dmPrintQuality;
    private short dmColor;
    private short dmDuplex;
    private short dmYResolution;
    private short dmTTOption;
    private short dmCollate;
    private string dmFormName;
    private short dmLogPixels;
    private int dmBitsPerPel;
    private int dmPelsWidth;
    private int dmPelsHeight;
    private int dmDisplayFlags;
    private int dmDisplayFrequency;
    private int dmICMMethod;
    private int dmICMIntent;
    private int dmMediaType;
    private int dmDitherType;
    private int dmICCManufacturer;
    private int dmICCModel;
    private int dmPanningWidth;
    private int dmPanningHeight;
    public string DmDeviceName { get; }
    public short DmSpecVersion { get; }
    public short DmDriverVersion { get; }
    public short DmSize { get; }
    public short DmDriverExtra { get; }
    public int DmFields { get; }
    public short DmOrientation { get; }
    public short DmPaperSize { get; }
    public short DmPaperLength { get; }
    public short DmPaperWidth { get; }
    public short DmScale { get; }
    public short DmCopies { get; }
    public short DmDefaultSource { get; }
    public short DmPrintQuality { get; }
    public short DmColor { get; }
    public short DmDuplex { get; }
    public short DmYResolution { get; }
    public short DmTTOption { get; }
    public short DmCollate { get; }
    public string DmFormName { get; }
    public short DmLogPixels { get; }
    public int DmBitsPerPel { get; }
    public int DmPelsWidth { get; }
    public int DmPelsHeight { get; }
    public int DmDisplayFlags { get; }
    public int DmDisplayFrequency { get; }
    public int DmICMMethod { get; }
    public int DmICMIntent { get; }
    public int DmMediaType { get; }
    public int DmDitherType { get; }
    public int DmICCManufacturer { get; }
    public int DmICCModel { get; }
    public int DmPanningWidth { get; }
    public int DmPanningHeight { get; }
    public string get_DmDeviceName();
    public short get_DmSpecVersion();
    public short get_DmDriverVersion();
    public short get_DmSize();
    public short get_DmDriverExtra();
    public int get_DmFields();
    public short get_DmOrientation();
    public short get_DmPaperSize();
    public short get_DmPaperLength();
    public short get_DmPaperWidth();
    public short get_DmScale();
    public short get_DmCopies();
    public short get_DmDefaultSource();
    public short get_DmPrintQuality();
    public short get_DmColor();
    public short get_DmDuplex();
    public short get_DmYResolution();
    public short get_DmTTOption();
    public short get_DmCollate();
    public string get_DmFormName();
    public short get_DmLogPixels();
    public int get_DmBitsPerPel();
    public int get_DmPelsWidth();
    public int get_DmPelsHeight();
    public int get_DmDisplayFlags();
    public int get_DmDisplayFrequency();
    public int get_DmICMMethod();
    public int get_DmICMIntent();
    public int get_DmMediaType();
    public int get_DmDitherType();
    public int get_DmICCManufacturer();
    public int get_DmICCModel();
    public int get_DmPanningWidth();
    public int get_DmPanningHeight();
}
internal enum DevExpress.Pdf.Interop.EPrintTicketScope : Enum {
    public int value__;
    public static EPrintTicketScope kPTPageScope;
    public static EPrintTicketScope kPTDocumentScope;
    public static EPrintTicketScope kPTJobScope;
}
[FlagsAttribute]
internal enum DevExpress.Pdf.Interop.FontCharacteristics : Enum {
    public int value__;
    public static FontCharacteristics FR_PRIVATE;
}
internal enum DevExpress.Pdf.Interop.FontCharSet : Enum {
    public int value__;
    public static FontCharSet DEFAULT_CHARSET;
}
internal enum DevExpress.Pdf.Interop.FontClipPrecision : Enum {
    public int value__;
    public static FontClipPrecision CLIP_DEFAULT_PRECIS;
}
internal enum DevExpress.Pdf.Interop.FontOutputPrecision : Enum {
    public int value__;
    public static FontOutputPrecision OUT_DEFAULT_PRECIS;
}
[FlagsAttribute]
public enum DevExpress.Pdf.Interop.FontPitchAndFamily : Enum {
    public int value__;
    public static FontPitchAndFamily DEFAULT_PITCH;
    public static FontPitchAndFamily FIXED_PITCH;
    public static FontPitchAndFamily VARIABLE_PITCH;
    public static FontPitchAndFamily FF_DONTCARE;
    public static FontPitchAndFamily FF_ROMAN;
    public static FontPitchAndFamily FF_SCRIPT;
}
internal enum DevExpress.Pdf.Interop.FontQuality : Enum {
    public int value__;
    public static FontQuality DEFAULT_QUALITY;
    public static FontQuality NONANTIALIASED_QUALITY;
}
internal enum DevExpress.Pdf.Interop.FontWeight : Enum {
    public int value__;
    public static FontWeight FW_DONTCARE;
    public static FontWeight FW_THIN;
    public static FontWeight FW_EXTRALIGHT;
    public static FontWeight FW_LIGHT;
    public static FontWeight FW_NORMAL;
    public static FontWeight FW_MEDIUM;
    public static FontWeight FW_SEMIBOLD;
    public static FontWeight FW_BOLD;
    public static FontWeight FW_EXTRABOLD;
    public static FontWeight FW_HEAVY;
}
internal static class DevExpress.Pdf.Interop.Gdi32Interop : object {
    public static int AddFontResourceEx(string fileName, FontCharacteristics characteristics, IntPtr reserved);
    public static bool RemoveFontResourceEx(string fileName, FontCharacteristics characteristics, IntPtr reserved);
    public static IntPtr AddFontMemResourceEx(Byte[] fontData, int fontDataLength, IntPtr reserved, Int32& fontCount);
    public static bool RemoveFontMemResourceEx(IntPtr fontHandle);
    public static IntPtr CreateFont(int height, int width, int escapement, int orientation, int weight, bool italic, bool underline, bool strikeOut, FontCharSet charSet, FontOutputPrecision outputPrecision, FontClipPrecision clipPrecision, FontQuality quality, FontPitchAndFamily pitchAndFamily, string name);
    public static bool GetTextMetrics(IntPtr hdc, TEXTMETRIC& metric);
    public static IntPtr SelectObject(IntPtr hdc, IntPtr hgdiobj);
    public static bool DeleteObject(IntPtr hObject);
    public static int SelectClipRgn(IntPtr hdc, IntPtr hrgn);
    public static BackgroundMode SetBkMode(IntPtr hdc, BackgroundMode mode);
    public static GraphicsMode SetGraphicsMode(IntPtr hdc, GraphicsMode mode);
    public static bool SetWorldTransform(IntPtr hdc, XFORM& xform);
    public static MappingMode SetMapMode(IntPtr hdc, MappingMode fnMapMode);
    public static bool SetWindowExtEx(IntPtr hDC, int nExtentX, int nExtentY, SIZE& prevSize);
    public static bool SetViewportExtEx(IntPtr hDC, int nExtentX, int nExtentY, SIZE& prevSize);
    public static bool ModifyWorldTransform(IntPtr hdc, XFORM& xForm, ModifyWorldTransformMode mode);
    public static int SetTextColor(IntPtr hdc, int color);
    public static TextAlign SetTextAlign(IntPtr hdc, TextAlign textAlign);
    public static int ExtTextOut(IntPtr hdc, int x, int y, TextOutOptions options, RECT& dimensions, Int16[] indices, int count, Int32[] spacing);
    public static bool BitBlt(IntPtr hdcDest, int xDest, int yDest, int width, int height, IntPtr hdcSrc, int xSrc, int ySrc, RasterOperationCode rasterOperation);
    public static bool FrameRgn(IntPtr hdc, IntPtr hrgn, IntPtr hbr, int nWidth, int nHeight);
    public static IntPtr CreateSolidBrush(int crColor);
    public static bool DeleteDC(IntPtr hDC);
    public static int GetDeviceCaps(IntPtr hDC, int nIndex);
    public static IntPtr CreateIC(string lpszDriverName, string lpszDeviceName, string lpszOutput, IntPtr lpdvmInit);
    public static IntPtr CreateDC(string lpszDriverName, string lpszDeviceName, string lpszOutput, IntPtr lpInitData);
    public static int ExtEscape(IntPtr hdc, int iEscape, int cjInput, string lpInData, int cjOutput, IntPtr lpOutData);
    private static int GetCharABCWidthsFloatW(IntPtr hDC, int iFirst, int iLast, ABCFLOAT& lpABC);
    [SecuritySafeCriticalAttribute]
public static int GetCharABCWidthsFloat(IntPtr hDC, int charCode, ABCFLOAT& lpABC);
    public static bool BeginPath(IntPtr hdc);
    public static bool EndPath(IntPtr hdc);
    public static int GetPath(IntPtr hdc, POINT[] lpPoints, Byte[] lpTypes, int nSize);
}
internal static class DevExpress.Pdf.Interop.GdiplusInterop : object {
    public static int GdipWindingModeOutline(IntPtr path, IntPtr matrix, float flatness);
}
internal enum DevExpress.Pdf.Interop.GraphicsMode : Enum {
    public int value__;
    public static GraphicsMode GM_ADVANCED;
}
public class DevExpress.Pdf.Interop.HDevModeHandle : object {
    private IntPtr hDevmode;
    public HDevModeHandle(IntPtr hDevmode);
    protected virtual override void Finalize();
    [SecuritySafeCriticalAttribute]
public T PerformDevModeFunction(Func`2<IntPtr, T> devmodeFunction);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
private void Dispose(bool disposing);
}
[GuidAttribute("46EB5926-582E-4017-9FDF-E8998DAA0950")]
[InterfaceTypeAttribute("1")]
internal interface DevExpress.Pdf.Interop.IImageList {
    public abstract virtual int Add();
    public abstract virtual int ReplaceIcon();
    public abstract virtual int SetOverlayImage();
    public abstract virtual int Replace();
    public abstract virtual int AddMasked();
    public abstract virtual int Draw();
    public abstract virtual int Remove();
    public abstract virtual int GetIcon(int i, int flags, IntPtr& picon);
    public abstract virtual int GetImageInfo();
    public abstract virtual int Copy();
    public abstract virtual int Merge();
    public abstract virtual int Clone();
    public abstract virtual int GetImageRect();
    public abstract virtual int GetIconSize();
    public abstract virtual int SetIconSize();
    public abstract virtual int GetImageCount();
    public abstract virtual int SetImageCount();
    public abstract virtual int SetBkColor();
    public abstract virtual int GetBkColor();
    public abstract virtual int BeginDrag();
    public abstract virtual int EndDrag();
    public abstract virtual int DragEnter();
    public abstract virtual int DragLeave();
    public abstract virtual int DragMove();
    public abstract virtual int SetDragCursorImage();
    public abstract virtual int DragShowNolock();
    public abstract virtual int GetDragImage();
    public abstract virtual int GetItemFlags();
    public abstract virtual int GetOverlayImage();
}
internal enum DevExpress.Pdf.Interop.MappingMode : Enum {
    public int value__;
    public static MappingMode MM_TEXT;
    public static MappingMode MM_LOMETRIC;
    public static MappingMode MM_HIMETRIC;
    public static MappingMode MM_LOENGLISH;
    public static MappingMode MM_HIENGLISH;
    public static MappingMode MM_TWIPS;
    public static MappingMode MM_ISOTROPIC;
    public static MappingMode MM_ANISOTROPIC;
}
internal enum DevExpress.Pdf.Interop.ModifyWorldTransformMode : Enum {
    public int value__;
    public static ModifyWorldTransformMode MWT_IDENTITY;
}
internal static class DevExpress.Pdf.Interop.MsvcrtInterop : object {
    private static IntPtr memcpy(IntPtr dest, IntPtr src, UIntPtr count);
    [SecuritySafeCriticalAttribute]
public static IntPtr Memcpy(IntPtr dest, IntPtr src, UIntPtr count);
}
internal class DevExpress.Pdf.Interop.POINT : ValueType {
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    public int X { get; public set; }
    public int Y { get; public set; }
    [CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public void set_X(int value);
    [CompilerGeneratedAttribute]
public int get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(int value);
}
internal class DevExpress.Pdf.Interop.PRINTDLG : object {
    private int lStructSize;
    private IntPtr hwndOwner;
    private IntPtr hDevMode;
    private IntPtr hDevNames;
    private IntPtr hDC;
    private int flags;
    private short nFromPage;
    private short nToPage;
    private short nMinPage;
    private short nMaxPage;
    private short nCopies;
    private IntPtr hInstance;
    private IntPtr lCustData;
    private IntPtr lpfnPrintHook;
    private IntPtr lpfnSetupHook;
    private string lpPrintTemplateName;
    private string lpSetupTemplateName;
    private IntPtr hPrintTemplate;
    private IntPtr hSetupTemplate;
    public IntPtr HDevMode { get; }
    public IntPtr HDevNames { get; }
    public int Flags { get; public set; }
    public IntPtr get_HDevMode();
    public IntPtr get_HDevNames();
    public int get_Flags();
    public void set_Flags(int value);
}
internal class DevExpress.Pdf.Interop.PRINTDLGX86 : object {
    private int lStructSize;
    private IntPtr hwndOwner;
    private IntPtr hDevMode;
    private IntPtr hDevNames;
    private IntPtr hDC;
    private int flags;
    private short nFromPage;
    private short nToPage;
    private short nMinPage;
    private short nMaxPage;
    private short nCopies;
    private IntPtr hInstance;
    private IntPtr lCustData;
    private IntPtr lpfnPrintHook;
    private IntPtr lpfnSetupHook;
    private string lpPrintTemplateName;
    private string lpSetupTemplateName;
    private IntPtr hPrintTemplate;
    private IntPtr hSetupTemplate;
    public IntPtr HDevMode { get; }
    public IntPtr HDevNames { get; }
    public int Flags { get; public set; }
    public IntPtr get_HDevMode();
    public IntPtr get_HDevNames();
    public int get_Flags();
    public void set_Flags(int value);
}
internal static class DevExpress.Pdf.Interop.PrntvptInterop : object {
    public static int PTConvertDevModeToPrintTicket(IntPtr handle, UInt32 dmSize, IntPtr devMode, UInt32 scope, IntPtr printTicket);
    public static int PTOpenProviderEx(string deviceName, int maxVersion, int prefVersion, IntPtr& handle, Int32& usedVersion);
    public static int PTCloseProvider(IntPtr phProvider);
}
internal class DevExpress.Pdf.Interop.PTProvider : object {
    private IntPtr handle;
    private PTProvider(IntPtr handle);
    [SecuritySafeCriticalAttribute]
public static PTProvider Create(string deviceName);
    [SecuritySafeCriticalAttribute]
private static void CheckHResult(int hresult);
    [SecuritySafeCriticalAttribute]
private static NativeStream ConvertDevModeToPrintTicket(IntPtr handle, IntPtr devmodePtr, EPrintTicketScope scope);
    protected virtual override void Finalize();
    public NativeStream ConvertDevModeToPrintTicket(HDevModeHandle devmode, EPrintTicketScope scope);
    public sealed virtual void Dispose();
    [SecuritySafeCriticalAttribute]
private void DisposeCore();
}
internal enum DevExpress.Pdf.Interop.RasterOperationCode : Enum {
    public int value__;
    public static RasterOperationCode SRCCOPY;
}
public class DevExpress.Pdf.Interop.RECT : ValueType {
    private int left;
    private int top;
    private int right;
    private int bottom;
    public RECT(int left, int top, int right, int bottom);
}
internal static class DevExpress.Pdf.Interop.Shell32Interop : object {
    public static Guid IID_IImageList;
    public static Guid IID_IImageList2;
    public static int SHIL_LARGE;
    public static int SHIL_SMALL;
    public static int SHIL_EXTRALARGE;
    public static int SHIL_SYSSMALL;
    public static int SHIL_JUMBO;
    public static int SHIL_LAST;
    public static int ILD_TRANSPARENT;
    public static int ILD_IMAGE;
    private static Shell32Interop();
    public static IntPtr SHGetFileInfo(string path, ShellFileAttributes fileAttributes, SHFILEINFO& fileInfo, int fileInfoSize, SHGFI flags);
    public static int SHGetImageList(int iImageList, Guid& riid, IImageList& ppv);
    public static UInt32 SHGetIDListFromObject(object iUnknown, IntPtr& ppidl);
}
internal enum DevExpress.Pdf.Interop.ShellFileAttributes : Enum {
    public int value__;
    public static ShellFileAttributes FILE_ATTRIBUTE_NORMAL;
}
internal class DevExpress.Pdf.Interop.SHFILEINFO : ValueType {
    public IntPtr hIcon;
    public int iIcon;
    private UInt32 dwAttributes;
    public string szDisplayName;
    public string szTypeName;
}
[FlagsAttribute]
internal enum DevExpress.Pdf.Interop.SHGFI : Enum {
    public UInt32 value__;
    public static SHGFI Icon;
    public static SHGFI DisplayName;
    public static SHGFI TypeName;
    public static SHGFI Attributes;
    public static SHGFI IconLocation;
    public static SHGFI ExeType;
    public static SHGFI SysIconIndex;
    public static SHGFI LinkOverlay;
    public static SHGFI Selected;
    public static SHGFI Attr_Specified;
    public static SHGFI LargeIcon;
    public static SHGFI SmallIcon;
    public static SHGFI OpenIcon;
    public static SHGFI ShellIconSize;
    public static SHGFI PIDL;
    public static SHGFI UseFileAttributes;
    public static SHGFI AddOverlays;
    public static SHGFI OverlayIndex;
}
internal class DevExpress.Pdf.Interop.SIZE : ValueType {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public int Width { get; public set; }
    public int Height { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
}
internal enum DevExpress.Pdf.Interop.TextAlign : Enum {
    public int value__;
    public static TextAlign TA_BASELINE;
}
internal class DevExpress.Pdf.Interop.TEXTMETRIC : ValueType {
    private int height;
    private int ascent;
    private int descent;
    private int internalLeading;
    private int externalLeading;
    private int aveCharWidth;
    private int maxCharWidth;
    public int Weight;
    private int overhang;
    private int digitazedAspectX;
    private int digitizedAspectY;
    private ushort firstChar;
    private ushort lastChar;
    private ushort defaultChar;
    private ushort breakChar;
    private bool italic;
    private bool underlined;
    private bool struckOut;
    private byte pitchAndFamily;
    private byte charSet;
    public int AveCharWidth { get; }
    public int Ascent { get; }
    public int Descent { get; }
    public int get_AveCharWidth();
    public int get_Ascent();
    public int get_Descent();
}
internal enum DevExpress.Pdf.Interop.TextOutOptions : Enum {
    public int value__;
    public static TextOutOptions ETO_GLYPH_INDEX;
    public static TextOutOptions ETO_IGNORELANGUAGE;
}
internal static class DevExpress.Pdf.Interop.User32Interop : object {
    public static int DestroyIcon(IntPtr hIcon);
}
internal static class DevExpress.Pdf.Interop.WinspoolInterop : object {
    public static int DeviceCapabilities(string pDevice, string pPort, short fwCapabilities, IntPtr pOutput, IntPtr pDevMode);
}
internal class DevExpress.Pdf.Interop.XFORM : ValueType {
    private float m11;
    private float m12;
    private float m21;
    private float m22;
    private float dx;
    private float dy;
    public XFORM(float m11, float m12, float m21, float m22, float dx, float dy);
    public XFORM(PdfTransformationMatrix matrix);
}
public interface DevExpress.Pdf.IPdfViewerAnnotation {
    public string Name { get; }
    public int PageNumber { get; }
    public PdfAnnotationType Type { get; }
    public PdfRectangle Bounds { get; }
    public PdfRGBColor Color { get; }
    public abstract virtual string get_Name();
    public abstract virtual int get_PageNumber();
    public abstract virtual PdfAnnotationType get_Type();
    public abstract virtual PdfRectangle get_Bounds();
    public abstract virtual PdfRGBColor get_Color();
}
public interface DevExpress.Pdf.IPdfViewerAnnotationBase {
    public string Author { get; }
    public string Contents { get; }
    public IReadOnlyList`1<PdfViewerReview> Reviews { get; }
    public IReadOnlyList`1<IPdfViewerReply> Replies { get; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; }
    public abstract virtual string get_Author();
    public abstract virtual string get_Contents();
    public abstract virtual IReadOnlyList`1<PdfViewerReview> get_Reviews();
    public abstract virtual IReadOnlyList`1<IPdfViewerReply> get_Replies();
    public abstract virtual Nullable`1<DateTimeOffset> get_ModificationDate();
}
public interface DevExpress.Pdf.IPdfViewerAnnotationBuilder {
    public int PageNumber { get; }
    public PdfAnnotationType AnnotationType { get; }
    public PdfRectangle Bounds { get; }
    public string Name { get; public set; }
    public string Contents { get; public set; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; public set; }
    public PdfRGBColor Color { get; public set; }
    public bool IsSelected { get; public set; }
    public abstract virtual int get_PageNumber();
    public abstract virtual PdfAnnotationType get_AnnotationType();
    public abstract virtual PdfRectangle get_Bounds();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_Contents();
    public abstract virtual void set_Contents(string value);
    public abstract virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    public abstract virtual void set_ModificationDate(Nullable`1<DateTimeOffset> value);
    public abstract virtual PdfRGBColor get_Color();
    public abstract virtual void set_Color(PdfRGBColor value);
    public abstract virtual bool get_IsSelected();
    public abstract virtual void set_IsSelected(bool value);
}
public interface DevExpress.Pdf.IPdfViewerMarkupAnnotation {
    public Nullable`1<DateTimeOffset> CreationDate { get; }
    public double Opacity { get; }
    public string Subject { get; }
    public abstract virtual Nullable`1<DateTimeOffset> get_CreationDate();
    public abstract virtual double get_Opacity();
    public abstract virtual string get_Subject();
}
public interface DevExpress.Pdf.IPdfViewerMarkupAnnotationBuilder {
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public double Opacity { get; public set; }
    public Nullable`1<DateTimeOffset> CreationDate { get; public set; }
    public abstract virtual string get_Author();
    public abstract virtual void set_Author(string value);
    public abstract virtual string get_Subject();
    public abstract virtual void set_Subject(string value);
    public abstract virtual double get_Opacity();
    public abstract virtual void set_Opacity(double value);
    public abstract virtual Nullable`1<DateTimeOffset> get_CreationDate();
    public abstract virtual void set_CreationDate(Nullable`1<DateTimeOffset> value);
}
public interface DevExpress.Pdf.IPdfViewerReply {
    public IPdfViewerAnnotationBase Parent { get; }
    public abstract virtual IPdfViewerAnnotationBase get_Parent();
}
public interface DevExpress.Pdf.IPdfViewerTextAnnotation {
    public string IconName { get; }
    public abstract virtual string get_IconName();
}
public interface DevExpress.Pdf.IPdfViewerTextAnnotationBuilder {
    public string IconName { get; public set; }
    public abstract virtual string get_IconName();
    public abstract virtual void set_IconName(string value);
}
public interface DevExpress.Pdf.IPdfViewerTextMarkupAnnotation {
    public IList`1<PdfQuadrilateral> Quads { get; }
    public PdfTextMarkupAnnotationType Style { get; }
    public abstract virtual IList`1<PdfQuadrilateral> get_Quads();
    public abstract virtual PdfTextMarkupAnnotationType get_Style();
}
public interface DevExpress.Pdf.IPdfViewerTextMarkupAnnotationBuilder {
    public string SelectedText { get; }
    public PdfTextMarkupAnnotationType Style { get; public set; }
    public IList`1<PdfQuadrilateral> Quads { get; }
    public abstract virtual string get_SelectedText();
    public abstract virtual PdfTextMarkupAnnotationType get_Style();
    public abstract virtual void set_Style(PdfTextMarkupAnnotationType value);
    public abstract virtual IList`1<PdfQuadrilateral> get_Quads();
}
public interface DevExpress.Pdf.Native.IPdfDocumentCommentViewModel {
    public IPdfDocumentCommentViewModel Parent { get; }
    public string Author { get; }
    public string Contents { get; public set; }
    public bool Marked { get; public set; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; }
    public int PageNumber { get; }
    public IPdfDocumentCommentViewModelCollection Replies { get; }
    public IPdfDocumentCommentViewModelReviewCollection Reviews { get; }
    public string Subject { get; }
    public PdfFilterAnnotationType FilterType { get; }
    public bool Hidden { get; }
    public abstract virtual IPdfDocumentCommentViewModel get_Parent();
    public abstract virtual string get_Author();
    public abstract virtual string get_Contents();
    public abstract virtual void set_Contents(string value);
    public abstract virtual bool get_Marked();
    public abstract virtual void set_Marked(bool value);
    public abstract virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    public abstract virtual int get_PageNumber();
    public abstract virtual IPdfDocumentCommentViewModelCollection get_Replies();
    public abstract virtual IPdfDocumentCommentViewModelReviewCollection get_Reviews();
    public abstract virtual string get_Subject();
    public abstract virtual PdfFilterAnnotationType get_FilterType();
    public abstract virtual bool get_Hidden();
    public abstract virtual void AddReply(string author, string contents);
    public abstract virtual void AddReview(string author, PdfAnnotationReviewStatus status);
}
public interface DevExpress.Pdf.Native.IPdfDocumentCommentViewModelCollection {
}
public interface DevExpress.Pdf.Native.IPdfDocumentCommentViewModelReview {
    public string Author { get; }
    public PdfAnnotationReviewStatus Status { get; }
    public abstract virtual string get_Author();
    public abstract virtual PdfAnnotationReviewStatus get_Status();
}
public interface DevExpress.Pdf.Native.IPdfDocumentCommentViewModelReviewCollection {
}
public abstract class DevExpress.Pdf.Native.PdfChoiceEditorSettings : PdfEditorSettings {
    private IList`1<PdfOptionsFormFieldOption> options;
    private int topIndex;
    public IList`1<PdfOptionsFormFieldOption> Values { get; }
    public int TopIndex { get; }
    public PdfEditorType EditorType { get; }
    protected PdfChoiceEditorSettings(PdfExportFontInfo fontInfo, PdfDocumentArea area, PdfChoiceFormField formField, int rotationAngle, bool readOnly);
    public IList`1<PdfOptionsFormFieldOption> get_Values();
    public int get_TopIndex();
    public virtual PdfEditorType get_EditorType();
}
public class DevExpress.Pdf.Native.PdfComboBoxSettings : PdfChoiceEditorSettings {
    private bool editable;
    private string selectedValue;
    public bool Editable { get; }
    public object EditValue { get; }
    public PdfEditorType EditorType { get; }
    public PdfComboBoxSettings(PdfExportFontInfo fontInfo, PdfDocumentArea documentArea, PdfChoiceFormField field, int rotationAngle, bool readOnly);
    public bool get_Editable();
    public virtual object get_EditValue();
    public virtual PdfEditorType get_EditorType();
}
public class DevExpress.Pdf.Native.PdfDocumentCommentViewModel : object {
    private IPdfViewerController viewer;
    private int version;
    [CompilerGeneratedAttribute]
private IPdfAnnotationStateComment <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private IPdfDocumentCommentViewModel <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private IPdfDocumentCommentViewModelReviewCollection <Reviews>k__BackingField;
    [CompilerGeneratedAttribute]
private IPdfDocumentCommentViewModelCollection <Replies>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    internal IPdfAnnotationStateComment Comment { get; }
    public IPdfDocumentCommentViewModel Parent { get; }
    public PdfFilterAnnotationType FilterType { get; }
    public string Subject { get; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; }
    public int PageNumber { get; }
    public string Author { get; }
    public bool Hidden { get; }
    public string Contents { get; public set; }
    public bool Marked { get; public set; }
    public IPdfDocumentCommentViewModelReviewCollection Reviews { get; }
    public IPdfDocumentCommentViewModelCollection Replies { get; }
    internal PdfDocumentCommentViewModel(IPdfAnnotationStateComment comment, IPdfViewerController viewer, PdfDocumentCommentViewModel parent);
    [CompilerGeneratedAttribute]
internal IPdfAnnotationStateComment get_Comment();
    [CompilerGeneratedAttribute]
public sealed virtual IPdfDocumentCommentViewModel get_Parent();
    public sealed virtual PdfFilterAnnotationType get_FilterType();
    public sealed virtual string get_Subject();
    public sealed virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    public sealed virtual int get_PageNumber();
    public sealed virtual string get_Author();
    public sealed virtual bool get_Hidden();
    public sealed virtual string get_Contents();
    public sealed virtual void set_Contents(string value);
    public sealed virtual bool get_Marked();
    public sealed virtual void set_Marked(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IPdfDocumentCommentViewModelReviewCollection get_Reviews();
    [CompilerGeneratedAttribute]
public sealed virtual IPdfDocumentCommentViewModelCollection get_Replies();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    private void OnPropertyEvent(string propertyName, Action`1<string> action);
    private void OnStatePropertyChanging(object sender, PropertyChangingEventArgs e);
    private void OnStatePropertyChanged(object sender, PropertyChangedEventArgs e);
    private void RaisePropertyChaning(string propertyName);
    private void RaisePropertyChanged(string propertyName);
    public sealed virtual void AddReply(string author, string contents);
    public sealed virtual void AddReview(string author, PdfAnnotationReviewStatus status);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Pdf.Native.PdfDocumentCommentViewModelCollection : object {
    private IPdfViewerController viewerController;
    private List`1<PdfDocumentCommentViewModel> comments;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfCommentTreeFilterItems <FilterItems>k__BackingField;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    internal IEnumerable`1<PdfDocumentCommentViewModel> Comments { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    private object System.Collections.IList.Item { get; private set; }
    public IPdfDocumentCommentViewModel Item { get; public set; }
    public PdfCommentTreeFilterItems FilterItems { get; }
    public PdfDocumentCommentViewModelCollection(IPdfViewerController viewerController, PdfDocumentStateBase documentState, Action`1<int> progress);
    internal IEnumerable`1<PdfDocumentCommentViewModel> get_Comments();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    [CompilerGeneratedAttribute]
public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual IPdfDocumentCommentViewModel get_Item(int index);
    public sealed virtual void set_Item(int index, IPdfDocumentCommentViewModel value);
    [CompilerGeneratedAttribute]
public PdfCommentTreeFilterItems get_FilterItems();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void OnAnnotationsChanged(IPdfAnnotationState state, bool removed);
    [IteratorStateMachineAttribute("DevExpress.Pdf.Native.PdfDocumentCommentViewModelCollection/<GetEnumerator>d__29")]
public sealed virtual IEnumerator`1<IPdfDocumentCommentViewModel> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(IPdfDocumentCommentViewModel item);
    public sealed virtual void RemoveAt(int index);
    private bool RemoveAtIndex(int index);
    public sealed virtual bool Remove(IPdfDocumentCommentViewModel item);
    public sealed virtual bool Contains(IPdfDocumentCommentViewModel item);
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Remove(object value);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Pdf.Native.IPdfDocumentCommentViewModel>.Add(IPdfDocumentCommentViewModel item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.Generic.IList<DevExpress.Pdf.Native.IPdfDocumentCommentViewModel>.Insert(int index, IPdfDocumentCommentViewModel item);
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Pdf.Native.IPdfDocumentCommentViewModel>.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<DevExpress.Pdf.Native.IPdfDocumentCommentViewModel>.CopyTo(IPdfDocumentCommentViewModel[] array, int arrayIndex);
}
[DefaultMemberAttribute("Item")]
public class DevExpress.Pdf.Native.PdfDocumentCommentViewModelReplyCollection : object {
    private IPdfAnnotationStateCommentReplies replies;
    private List`1<PdfDocumentCommentViewModel> viewModels;
    private IPdfViewerController viewer;
    private PdfDocumentCommentViewModel parent;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    private object System.Collections.IList.Item { get; private set; }
    public IPdfDocumentCommentViewModel Item { get; public set; }
    internal PdfDocumentCommentViewModelReplyCollection(IPdfAnnotationStateCommentReplies replies, IPdfViewerController viewer, PdfDocumentCommentViewModel parent);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    [CompilerGeneratedAttribute]
public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual IPdfDocumentCommentViewModel get_Item(int index);
    public sealed virtual void set_Item(int index, IPdfDocumentCommentViewModel value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void OnRepliesChanged(object sender, NotifyCollectionChangedEventArgs e);
    [IteratorStateMachineAttribute("DevExpress.Pdf.Native.PdfDocumentCommentViewModelReplyCollection/<GetEnumerator>d__26")]
public sealed virtual IEnumerator`1<IPdfDocumentCommentViewModel> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(IPdfDocumentCommentViewModel item);
    public sealed virtual void Insert(int index, IPdfDocumentCommentViewModel item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(IPdfDocumentCommentViewModel item);
    public sealed virtual void Add(IPdfDocumentCommentViewModel item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IPdfDocumentCommentViewModel item);
    public sealed virtual void CopyTo(IPdfDocumentCommentViewModel[] array, int arrayIndex);
    public sealed virtual int Add(object value);
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual void Remove(object value);
    public sealed virtual void CopyTo(Array array, int index);
}
public class DevExpress.Pdf.Native.PdfDocumentCommentViewModelReview : ValueType {
    private IPdfAnnotationStateCommentReview review;
    public string Author { get; }
    public PdfAnnotationReviewStatus Status { get; }
    public PdfDocumentCommentViewModelReview(IPdfAnnotationStateCommentReview review);
    public sealed virtual string get_Author();
    public sealed virtual PdfAnnotationReviewStatus get_Status();
}
public class DevExpress.Pdf.Native.PdfDocumentCommentViewModelReviewCollection : object {
    private IPdfAnnotationStateCommentReviews reviews;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public int Count { get; }
    internal PdfDocumentCommentViewModelReviewCollection(IPdfAnnotationStateCommentReviews reviews);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual int get_Count();
    private void OnReviewsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private static PdfDocumentCommentViewModelReview[] ConvertItems(IList items);
    [IteratorStateMachineAttribute("DevExpress.Pdf.Native.PdfDocumentCommentViewModelReviewCollection/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<IPdfDocumentCommentViewModelReview> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class DevExpress.Pdf.Native.PdfEditorBorder : object {
    private PdfEditorBorderStyle borderStyle;
    private PdfColor color;
    private double borderWidth;
    private double horizontalRadius;
    private double verticalRadius;
    private Double[] dashPattern;
    private double dashPhase;
    public PdfEditorBorderStyle BorderStyle { get; }
    public PdfColor Color { get; }
    public double BorderWidth { get; }
    public double HorizontalRadius { get; }
    public double VerticalRadius { get; }
    public Double[] DashPattern { get; }
    public double DashPhase { get; }
    public PdfEditorBorder(PdfWidgetAnnotation widget);
    public PdfEditorBorderStyle get_BorderStyle();
    public PdfColor get_Color();
    public double get_BorderWidth();
    public double get_HorizontalRadius();
    public double get_VerticalRadius();
    public Double[] get_DashPattern();
    public double get_DashPhase();
}
public enum DevExpress.Pdf.Native.PdfEditorBorderStyle : Enum {
    public int value__;
    public static PdfEditorBorderStyle Solid;
    public static PdfEditorBorderStyle Dashed;
    public static PdfEditorBorderStyle Beveled;
    public static PdfEditorBorderStyle Inset;
    public static PdfEditorBorderStyle Underline;
}
public abstract class DevExpress.Pdf.Native.PdfEditorSettings : object {
    private PdfExportFont fontData;
    private PdfDocumentArea documentArea;
    private bool readOnly;
    private bool usePasswordChar;
    private PdfEditorBorder border;
    private PdfTextJustification textJustification;
    private PdfRGBColor fontColor;
    private double rotationAngle;
    private string fieldName;
    private PdfRgbaColor backgroundColor;
    private double fontSize;
    [CompilerGeneratedAttribute]
private EventHandler OnFontSizeChanged;
    public PdfExportFont FontData { get; }
    public double FontSize { get; protected set; }
    public PdfDocumentArea DocumentArea { get; }
    public bool ReadOnly { get; }
    public bool UsePasswordChar { get; }
    public PdfRgbaColor BackgroundColor { get; public set; }
    public PdfEditorBorder Border { get; }
    public PdfTextJustification TextJustification { get; }
    public PdfRGBColor FontColor { get; }
    public double RotationAngle { get; }
    public string FieldName { get; }
    public PdfEditorType EditorType { get; }
    public object EditValue { get; }
    protected PdfEditorSettings(PdfExportFontInfo fontInfo, PdfDocumentArea area, PdfInteractiveFormField formField, int rotationAngle, bool readOnly);
    public static PdfEditorSettings Create(PdfWidgetAnnotationState widget, bool readOnly);
    public PdfExportFont get_FontData();
    public double get_FontSize();
    protected void set_FontSize(double value);
    public PdfDocumentArea get_DocumentArea();
    public bool get_ReadOnly();
    public bool get_UsePasswordChar();
    public PdfRgbaColor get_BackgroundColor();
    public void set_BackgroundColor(PdfRgbaColor value);
    public PdfEditorBorder get_Border();
    public PdfTextJustification get_TextJustification();
    public PdfRGBColor get_FontColor();
    public double get_RotationAngle();
    public string get_FieldName();
    public abstract virtual PdfEditorType get_EditorType();
    public abstract virtual object get_EditValue();
    [CompilerGeneratedAttribute]
public void add_OnFontSizeChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnFontSizeChanged(EventHandler value);
}
public enum DevExpress.Pdf.Native.PdfEditorType : Enum {
    public int value__;
    public static PdfEditorType TextEdit;
    public static PdfEditorType ComboBox;
    public static PdfEditorType ListBox;
}
public class DevExpress.Pdf.Native.PdfListBoxSettings : PdfChoiceEditorSettings {
    private bool multiselect;
    private IList`1<string> selectedValues;
    private IList`1<int> selectedIndices;
    public bool Multiselect { get; }
    public IList`1<int> SelectedIndices { get; }
    public PdfEditorType EditorType { get; }
    public object EditValue { get; }
    public PdfListBoxSettings(PdfExportFontInfo fontInfo, PdfDocumentArea area, PdfChoiceFormField field, int rotationAngle, bool readOnly);
    public bool get_Multiselect();
    public IList`1<int> get_SelectedIndices();
    public virtual PdfEditorType get_EditorType();
    public virtual object get_EditValue();
}
public class DevExpress.Pdf.Native.PdfTextEditSettings : PdfEditorSettings {
    private static string separator;
    private string initialText;
    private bool multiline;
    private int maxLen;
    private bool autoTextSize;
    private PdfTextFieldMeasurer measurer;
    [CompilerGeneratedAttribute]
private bool <DoNotScroll>k__BackingField;
    public string InitialText { get; }
    public bool Multiline { get; }
    public int MaxLen { get; }
    public bool DoNotScroll { get; }
    public PdfEditorType EditorType { get; }
    public object EditValue { get; }
    public PdfTextEditSettings(PdfExportFontInfo fontInfo, PdfDocumentArea area, PdfTextFormField formField, int rotationAngle, bool readOnly);
    public string get_InitialText();
    public bool get_Multiline();
    public int get_MaxLen();
    [CompilerGeneratedAttribute]
public bool get_DoNotScroll();
    public virtual PdfEditorType get_EditorType();
    public virtual object get_EditValue();
    public bool OnEditValueChanging(string newValue);
}
public class DevExpress.Pdf.Native.PdfViewerAnnotation : object {
    private static PdfAnnotationInfoFactory factory;
    [CompilerGeneratedAttribute]
private IPdfAnnotationState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PdfViewerReview> <Reviews>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IPdfViewerReply> <Replies>k__BackingField;
    internal IPdfAnnotationState State { get; }
    public PdfRectangle Bounds { get; }
    public int PageNumber { get; }
    public string Name { get; }
    public PdfRGBColor Color { get; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; }
    public string Contents { get; }
    public PdfAnnotationType Type { get; }
    public string Author { get; }
    public IReadOnlyList`1<PdfViewerReview> Reviews { get; }
    public IReadOnlyList`1<IPdfViewerReply> Replies { get; }
    internal PdfViewerAnnotation(IPdfAnnotationState state);
    private static PdfViewerAnnotation();
    internal static PdfViewerAnnotation Create(IPdfAnnotationState state);
    [CompilerGeneratedAttribute]
internal IPdfAnnotationState get_State();
    public sealed virtual PdfRectangle get_Bounds();
    public sealed virtual int get_PageNumber();
    public sealed virtual string get_Name();
    public sealed virtual PdfRGBColor get_Color();
    public sealed virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    public sealed virtual string get_Contents();
    public sealed virtual PdfAnnotationType get_Type();
    public virtual string get_Author();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<PdfViewerReview> get_Reviews();
    [CompilerGeneratedAttribute]
public virtual IReadOnlyList`1<IPdfViewerReply> get_Replies();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void CreateReplies(PdfViewerReply child);
    public PdfRectangle TransformBounds(PdfRectangle rect);
}
public class DevExpress.Pdf.Native.PdfViewerAnnotationChangingInfo : object {
    private IPdfViewerAnnotation viewerAnnotation;
    protected IPdfViewerAnnotation ViewerAnnotation { get; }
    public string Name { get; }
    public int PageNumber { get; }
    public PdfAnnotationType Type { get; }
    public PdfRectangle Bounds { get; }
    public PdfRGBColor Color { get; }
    public string Author { get; }
    public string Contents { get; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; }
    public IReadOnlyList`1<PdfViewerReview> Reviews { get; }
    public IReadOnlyList`1<IPdfViewerReply> Replies { get; }
    protected PdfViewerAnnotationChangingInfo(IPdfViewerAnnotation state);
    internal static PdfViewerAnnotationChangingInfo Create(IPdfViewerAnnotation state);
    protected IPdfViewerAnnotation get_ViewerAnnotation();
    public sealed virtual string get_Name();
    public sealed virtual int get_PageNumber();
    public sealed virtual PdfAnnotationType get_Type();
    public sealed virtual PdfRectangle get_Bounds();
    public sealed virtual PdfRGBColor get_Color();
    public sealed virtual string get_Author();
    public sealed virtual string get_Contents();
    public sealed virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    public sealed virtual IReadOnlyList`1<PdfViewerReview> get_Reviews();
    public sealed virtual IReadOnlyList`1<IPdfViewerReply> get_Replies();
    internal void ChangeState(IPdfViewerAnnotation state);
}
public class DevExpress.Pdf.Native.PdfViewerAnnotationChangingInfoState : object {
    private PdfViewerAnnotation viewerAnnotation;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfAnnotationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRectangle <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfRGBColor <Color>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Contents>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ModificationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PdfViewerReview> <Reviews>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IPdfViewerReply> <Replies>k__BackingField;
    public string Name { get; public set; }
    public int PageNumber { get; public set; }
    public PdfAnnotationType Type { get; public set; }
    public PdfRectangle Bounds { get; public set; }
    public PdfRGBColor Color { get; public set; }
    public string Author { get; public set; }
    public string Contents { get; public set; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; public set; }
    public IReadOnlyList`1<PdfViewerReview> Reviews { get; public set; }
    public IReadOnlyList`1<IPdfViewerReply> Replies { get; public set; }
    public PdfViewerAnnotationChangingInfoState(PdfViewerAnnotation viewerAnnotation);
    internal static PdfViewerAnnotationChangingInfoState Create(PdfViewerAnnotation state);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_PageNumber();
    [CompilerGeneratedAttribute]
public void set_PageNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual PdfAnnotationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PdfAnnotationType value);
    [CompilerGeneratedAttribute]
public sealed virtual PdfRectangle get_Bounds();
    [CompilerGeneratedAttribute]
public void set_Bounds(PdfRectangle value);
    [CompilerGeneratedAttribute]
public sealed virtual PdfRGBColor get_Color();
    [CompilerGeneratedAttribute]
public void set_Color(PdfRGBColor value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Contents();
    [CompilerGeneratedAttribute]
public void set_Contents(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    [CompilerGeneratedAttribute]
public void set_ModificationDate(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<PdfViewerReview> get_Reviews();
    [CompilerGeneratedAttribute]
public void set_Reviews(IReadOnlyList`1<PdfViewerReview> value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<IPdfViewerReply> get_Replies();
    [CompilerGeneratedAttribute]
public void set_Replies(IReadOnlyList`1<IPdfViewerReply> value);
    public void SetProperty(string propertyName, object alternativeValue);
}
public class DevExpress.Pdf.Native.PdfViewerMarkupAnnotation : PdfViewerAnnotation {
    private IPdfMarkupAnnotationState state;
    private List`1<PdfViewerReview> reviews;
    private List`1<IPdfViewerReply> replies;
    public double Opacity { get; }
    public Nullable`1<DateTimeOffset> CreationDate { get; }
    public string Author { get; }
    public string Subject { get; }
    public IReadOnlyList`1<PdfViewerReview> Reviews { get; }
    public IReadOnlyList`1<IPdfViewerReply> Replies { get; }
    internal PdfViewerMarkupAnnotation(IPdfMarkupAnnotationState state);
    public sealed virtual double get_Opacity();
    public sealed virtual Nullable`1<DateTimeOffset> get_CreationDate();
    public virtual string get_Author();
    public sealed virtual string get_Subject();
    public virtual IReadOnlyList`1<PdfViewerReview> get_Reviews();
    public virtual IReadOnlyList`1<IPdfViewerReply> get_Replies();
    public virtual void CreateReplies(PdfViewerReply child);
}
public class DevExpress.Pdf.Native.PdfViewerMarkupAnnotationChangingInfo : PdfViewerAnnotationChangingInfo {
    private IPdfViewerMarkupAnnotation MarkupAnnotation { get; }
    public double Opacity { get; }
    public Nullable`1<DateTimeOffset> CreationDate { get; }
    public string Subject { get; }
    internal PdfViewerMarkupAnnotationChangingInfo(IPdfViewerMarkupAnnotation viewerAnnotation);
    private IPdfViewerMarkupAnnotation get_MarkupAnnotation();
    public sealed virtual double get_Opacity();
    public sealed virtual Nullable`1<DateTimeOffset> get_CreationDate();
    public sealed virtual string get_Subject();
}
public class DevExpress.Pdf.Native.PdfViewerMarkupAnnotationChangingInfoState : PdfViewerAnnotationChangingInfoState {
    [CompilerGeneratedAttribute]
private double <Opacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <CreationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    public double Opacity { get; public set; }
    public Nullable`1<DateTimeOffset> CreationDate { get; public set; }
    public string Subject { get; public set; }
    internal PdfViewerMarkupAnnotationChangingInfoState(PdfViewerMarkupAnnotation viewerAnnotation);
    [CompilerGeneratedAttribute]
public sealed virtual double get_Opacity();
    [CompilerGeneratedAttribute]
public void set_Opacity(double value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_CreationDate();
    [CompilerGeneratedAttribute]
public void set_CreationDate(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
}
public class DevExpress.Pdf.Native.PdfViewerReply : object {
    private IPdfAnnotationStateComment comment;
    private List`1<PdfViewerReview> reviews;
    private List`1<IPdfViewerReply> replies;
    public IPdfViewerAnnotationBase Parent { get; }
    public string Author { get; }
    public string Contents { get; }
    public IReadOnlyList`1<PdfViewerReview> Reviews { get; }
    public IReadOnlyList`1<IPdfViewerReply> Replies { get; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; }
    internal IPdfAnnotationStateComment Comment { get; }
    public PdfViewerReply(IPdfAnnotationStateComment comment, PdfViewerReply child);
    public sealed virtual IPdfViewerAnnotationBase get_Parent();
    public sealed virtual string get_Author();
    public sealed virtual string get_Contents();
    public sealed virtual IReadOnlyList`1<PdfViewerReview> get_Reviews();
    public sealed virtual IReadOnlyList`1<IPdfViewerReply> get_Replies();
    public sealed virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    internal IPdfAnnotationStateComment get_Comment();
}
public class DevExpress.Pdf.Native.PdfViewerTextAnnotation : PdfViewerMarkupAnnotation {
    private PdfTextAnnotationState state;
    public string IconName { get; }
    internal PdfViewerTextAnnotation(PdfTextAnnotationState state);
    public sealed virtual string get_IconName();
}
public class DevExpress.Pdf.Native.PdfViewerTextAnnotationChangingInfo : PdfViewerMarkupAnnotationChangingInfo {
    private IPdfViewerTextAnnotation TextAnnotation { get; }
    public string IconName { get; }
    internal PdfViewerTextAnnotationChangingInfo(IPdfViewerTextAnnotation state);
    private IPdfViewerTextAnnotation get_TextAnnotation();
    public sealed virtual string get_IconName();
}
internal class DevExpress.Pdf.Native.PdfViewerTextAnnotationChangingInfoState : PdfViewerMarkupAnnotationChangingInfoState {
    [CompilerGeneratedAttribute]
private string <IconName>k__BackingField;
    public string IconName { get; public set; }
    internal PdfViewerTextAnnotationChangingInfoState(PdfViewerTextAnnotation state);
    [CompilerGeneratedAttribute]
public sealed virtual string get_IconName();
    [CompilerGeneratedAttribute]
public void set_IconName(string value);
}
public class DevExpress.Pdf.Native.PdfViewerTextMarkupAnnotation : PdfViewerMarkupAnnotation {
    private ReadOnlyCollection`1<PdfQuadrilateral> quads;
    [CompilerGeneratedAttribute]
private PdfTextMarkupAnnotationType <Style>k__BackingField;
    public PdfTextMarkupAnnotationType Style { get; }
    public IList`1<PdfQuadrilateral> Quads { get; }
    internal PdfViewerTextMarkupAnnotation(PdfTextMarkupAnnotationState state);
    [CompilerGeneratedAttribute]
public sealed virtual PdfTextMarkupAnnotationType get_Style();
    public sealed virtual IList`1<PdfQuadrilateral> get_Quads();
}
public class DevExpress.Pdf.Native.PdfViewerTextMarkupAnnotationChangingInfo : PdfViewerMarkupAnnotationChangingInfo {
    private PdfViewerTextMarkupAnnotation TextAnnotation { get; }
    public PdfTextMarkupAnnotationType Style { get; }
    public IList`1<PdfQuadrilateral> Quads { get; }
    internal PdfViewerTextMarkupAnnotationChangingInfo(IPdfViewerTextMarkupAnnotation state);
    private PdfViewerTextMarkupAnnotation get_TextAnnotation();
    public sealed virtual PdfTextMarkupAnnotationType get_Style();
    public sealed virtual IList`1<PdfQuadrilateral> get_Quads();
}
internal class DevExpress.Pdf.Native.PdfViewerTextMarkupAnnotationChangingInfoState : PdfViewerMarkupAnnotationChangingInfoState {
    [CompilerGeneratedAttribute]
private PdfTextMarkupAnnotationType <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PdfQuadrilateral> <Quads>k__BackingField;
    public PdfTextMarkupAnnotationType Style { get; public set; }
    public IList`1<PdfQuadrilateral> Quads { get; public set; }
    internal PdfViewerTextMarkupAnnotationChangingInfoState(PdfViewerTextMarkupAnnotation state);
    [CompilerGeneratedAttribute]
public sealed virtual PdfTextMarkupAnnotationType get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(PdfTextMarkupAnnotationType value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<PdfQuadrilateral> get_Quads();
    [CompilerGeneratedAttribute]
public void set_Quads(IList`1<PdfQuadrilateral> value);
}
public class DevExpress.Pdf.PdfCommentFilter : object {
    private FilterCollection`1<string> authors;
    private FilterCollection`1<PdfFilterAnnotationType> types;
    private Nullable`1<bool> checkStatus;
    private FilterCollection`1<PdfAnnotationReviewStatus> statuses;
    private string searchText;
    private bool hideAll;
    private bool locked;
    private bool noneStatus;
    [CompilerGeneratedAttribute]
private EventHandler FilterChanged;
    public bool HideAll { get; public set; }
    public ISet`1<string> Authors { get; }
    public ISet`1<PdfFilterAnnotationType> Types { get; }
    public Nullable`1<bool> Checked { get; public set; }
    public ISet`1<PdfAnnotationReviewStatus> Statuses { get; }
    public bool NoneStatus { get; public set; }
    public string SearchText { get; public set; }
    [CompilerGeneratedAttribute]
public void add_FilterChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FilterChanged(EventHandler value);
    public bool get_HideAll();
    public void set_HideAll(bool value);
    public ISet`1<string> get_Authors();
    public ISet`1<PdfFilterAnnotationType> get_Types();
    public Nullable`1<bool> get_Checked();
    public void set_Checked(Nullable`1<bool> value);
    public ISet`1<PdfAnnotationReviewStatus> get_Statuses();
    public bool get_NoneStatus();
    public void set_NoneStatus(bool value);
    public string get_SearchText();
    public void set_SearchText(string value);
    private void RaiseFilterChanged();
    public void ClearWithoutNotification();
    public void Clear();
    internal bool Check(IPdfAnnotationStateComment item);
    private bool CheckItem(IPdfAnnotationStateComment item);
    [CompilerGeneratedAttribute]
private void <.ctor>b__30_0(object d, EventArgs e);
    [CompilerGeneratedAttribute]
private void <.ctor>b__30_1(object d, EventArgs e);
    [CompilerGeneratedAttribute]
private void <.ctor>b__30_2(object d, EventArgs e);
    [CompilerGeneratedAttribute]
private bool <CheckItem>b__35_0(IPdfAnnotationStateCommentReview r);
}
public enum DevExpress.Pdf.PdfCommentSortMode : Enum {
    public int value__;
    public static PdfCommentSortMode Page;
    public static PdfCommentSortMode Author;
    public static PdfCommentSortMode Date;
    public static PdfCommentSortMode Checked;
    public static PdfCommentSortMode Type;
}
public class DevExpress.Pdf.PdfGraphics : PdfDisposableObject {
    public static float DefaultDpi;
    private static float defaultPageDpi;
    private IList`1<PdfGraphicsCommand> exportCommands;
    private IList`1<PdfGraphicsAcroFormField> formFields;
    private PdfGraphicsDocument graphicsDocument;
    private PdfDocumentStateBase documentState;
    private bool useKerning;
    private PdfGraphicsTextOrigin textOrigin;
    public bool UseKerning { get; public set; }
    public bool ConvertImagesToJpeg { get; public set; }
    public PdfGraphicsTextOrigin TextOrigin { get; public set; }
    public PdfGraphicsJpegImageQuality JpegImageQuality { get; public set; }
    internal PdfGraphics(PdfDocumentStateBase documentState, PdfGraphicsDocument graphicsDocument);
    internal static void CheckDpiValue(float value, string parameterName);
    internal static void CheckDpiValues(float dpiX, float dpiY);
    public bool get_UseKerning();
    public void set_UseKerning(bool value);
    public bool get_ConvertImagesToJpeg();
    public void set_ConvertImagesToJpeg(bool value);
    public PdfGraphicsTextOrigin get_TextOrigin();
    public void set_TextOrigin(PdfGraphicsTextOrigin value);
    public PdfGraphicsJpegImageQuality get_JpegImageQuality();
    public void set_JpegImageQuality(PdfGraphicsJpegImageQuality value);
    public void RotateTransform(float degree);
    public void TranslateTransform(float x, float y);
    public void ScaleTransform(float sx, float sy);
    public void IntersectClip(RectangleF rect);
    public void SaveGraphicsState();
    public void RestoreGraphicsState();
    public void DrawRectangle(Pen pen, RectangleF bounds);
    public void FillRectangle(Brush brush, RectangleF bounds);
    public SizeF MeasureString(string text, Font font);
    public SizeF MeasureString(string text, Font font, PdfStringFormat format);
    public SizeF MeasureString(string text, Font font, PdfStringFormat format, float dpiX, float dpiY);
    public SizeF MeasureString(string text, Font font, SizeF layoutSize);
    public SizeF MeasureString(string text, Font font, SizeF layoutSize, PdfStringFormat format);
    public SizeF MeasureString(string text, Font font, SizeF layoutSize, PdfStringFormat format, float dpiX, float dpiY);
    public SizeF MeasureString(string text, Font font, SizeF layoutSize, PdfStringFormat format, float dpiX, float dpiY, Int32& charactersFitted, Int32& linesFilled);
    public void DrawString(string text, Font font, SolidBrush brush, PointF point);
    public void DrawString(string text, Font font, SolidBrush brush, PointF point, PdfStringFormat format);
    public void DrawString(string text, Font font, SolidBrush brush, float x, float y);
    public void DrawString(string text, Font font, SolidBrush brush, float x, float y, PdfStringFormat format);
    public void DrawString(string text, Font font, SolidBrush brush, RectangleF layout, PdfStringFormat format);
    public void DrawString(string text, Font font, SolidBrush brush, RectangleF layout);
    public void DrawImage(Image image, PointF location);
    public void DrawImage(Image image, RectangleF bounds);
    public void DrawImage(Image image, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit);
    public void DrawLine(Pen pen, float x1, float y1, float x2, float y2);
    public void DrawLines(Pen pen, PointF[] points);
    public void DrawPath(Pen pen, GraphicsPath path);
    public void FillPath(Brush brush, GraphicsPath path);
    public void DrawPolygon(Pen pen, PointF[] points);
    public void FillPolygon(Brush brush, PointF[] points);
    public void DrawEllipse(Pen pen, RectangleF rect);
    public void FillEllipse(Brush brush, RectangleF rect);
    public void DrawBezier(Pen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4);
    public void DrawBeziers(Pen pen, PointF[] points);
    private SizeF MeasureString(string text, Nullable`1<SizeF> layoutWidth, Font font, PdfStringFormat format, float dpiX, float dpiY, Int32& charactersFitted, Int32& linesFilled);
    private PdfExportFontInfo GetExportFontInfo(Font font);
    public void DrawRectangle(DXPen pen, RectangleF bounds);
    public void FillRectangle(DXBrush brush, RectangleF bounds);
    public SizeF MeasureString(string text, DXFont font);
    public SizeF MeasureString(string text, DXFont font, PdfStringFormat format);
    public SizeF MeasureString(string text, DXFont font, PdfStringFormat format, float dpiX, float dpiY);
    public SizeF MeasureString(string text, DXFont font, SizeF layoutSize);
    public SizeF MeasureString(string text, DXFont font, SizeF layoutSize, PdfStringFormat format);
    public SizeF MeasureString(string text, DXFont font, SizeF layoutSize, PdfStringFormat format, float dpiX, float dpiY);
    public SizeF MeasureString(string text, DXFont font, SizeF layoutSize, PdfStringFormat format, float dpiX, float dpiY, Int32& charactersFitted, Int32& linesFilled);
    public void DrawString(string text, DXFont font, DXSolidBrush brush, PointF point);
    public void DrawString(string text, DXFont font, DXSolidBrush brush, PointF point, PdfStringFormat format);
    public void DrawString(string text, DXFont font, DXSolidBrush brush, float x, float y);
    public void DrawString(string text, DXFont font, DXSolidBrush brush, float x, float y, PdfStringFormat format);
    public void DrawString(string text, DXFont font, DXSolidBrush brush, RectangleF layout, PdfStringFormat format);
    public void DrawString(string text, DXFont font, DXSolidBrush brush, RectangleF layout);
    public void DrawImage(DXImage image, PointF location);
    public void DrawImage(DXImage image, RectangleF bounds);
    public void DrawImage(DXImage image, RectangleF destRect, RectangleF srcRect, DXGraphicsUnit srcUnit);
    public void DrawLine(DXPen pen, float x1, float y1, float x2, float y2);
    public void DrawLines(DXPen pen, PointF[] points);
    public void DrawPath(DXPen pen, DXGraphicsPath path);
    public void FillPath(DXBrush brush, DXGraphicsPath path);
    public void DrawPolygon(DXPen pen, PointF[] points);
    public void FillPolygon(DXBrush brush, PointF[] points);
    public void DrawEllipse(DXPen pen, RectangleF rect);
    public void FillEllipse(DXBrush brush, RectangleF rect);
    public void DrawBezier(DXPen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4);
    public void DrawBeziers(DXPen pen, PointF[] points);
    private PdfExportFontInfo GetExportFontInfo(DXFont font);
    private SizeF MeasureString(string text, Nullable`1<SizeF> layoutWidth, DXFont font, PdfStringFormat format, float dpiX, float dpiY, Int32& charactersFitted, Int32& linesFilled);
    private SizeF MeasureStringCore(string text, Nullable`1<SizeF> layoutWidth, PdfStringFormat format, float dpiX, float dpiY, Int32& charactersFitted, Int32& linesFilled, PdfExportFontInfo fontInfo);
    public void DrawImage(Byte[] data, PointF location);
    public void DrawImage(Stream data, PointF location);
    public void DrawImage(Byte[] data, RectangleF bounds);
    public void DrawImage(Stream data, RectangleF bounds);
    public void DrawPageContent(PdfPage source);
    public void AddLinkToUri(RectangleF linkArea, Uri uri);
    public void AddLinkToPage(RectangleF linkArea, int pageNumber);
    public void AddLinkToPage(RectangleF linkArea, int pageNumber, float zoom);
    public void AddLinkToPage(RectangleF linkArea, int pageNumber, float destinationX, float destinationY);
    public void AddLinkToPage(RectangleF linkArea, int pageNumber, float destinationX, float destinationY, float zoom);
    public void AddFormField(PdfGraphicsAcroFormField field);
    public void AddToPageBackground(PdfPage page);
    public void AddToPageBackground(PdfPage page, float dpiX, float dpiY);
    public void AddToPageForeground(PdfPage page);
    public void AddToPageForeground(PdfPage page, float dpiX, float dpiY);
    public void ClearFormFields();
    internal void Validate(PdfDocumentCatalog target);
    private Byte[] GeneratePageContents(PdfPage page, float dpiX, float dpiY);
    private void AddIsolatedCommand(PdfGraphicsCommand command);
    private void DrawImage(PdfXObjectCachedResource resource, RectangleF bounds);
    private void DrawImage(PdfXObjectCachedResource resource, PointF location);
    protected virtual void Dispose(bool disposing);
}
public class DevExpress.Pdf.PdfGraphicsAcroFormBorderAppearance : object {
    private PdfAcroFormBorderStyle style;
    private double width;
    private Color color;
    public PdfAcroFormBorderStyle Style { get; public set; }
    public double Width { get; public set; }
    public Color Color { get; public set; }
    public PdfAcroFormBorderStyle get_Style();
    public void set_Style(PdfAcroFormBorderStyle value);
    public double get_Width();
    public void set_Width(double value);
    public Color get_Color();
    public void set_Color(Color value);
    internal PdfAcroFormBorderAppearance CreateBorderAppearance(PdfGraphicsCommandConstructor constructor);
}
public class DevExpress.Pdf.PdfGraphicsAcroFormCheckBoxField : PdfGraphicsAcroFormCommonField {
    private PdfAcroFormButtonStyle buttonStyle;
    private string exportValue;
    private bool isChecked;
    private bool shouldGeneratePressedAppearance;
    public bool IsChecked { get; public set; }
    public PdfAcroFormButtonStyle ButtonStyle { get; public set; }
    public bool ShouldGeneratePressedAppearance { get; public set; }
    public string ExportValue { get; public set; }
    public PdfGraphicsAcroFormCheckBoxField(string name, RectangleF rectangle);
    public bool get_IsChecked();
    public void set_IsChecked(bool value);
    public PdfAcroFormButtonStyle get_ButtonStyle();
    public void set_ButtonStyle(PdfAcroFormButtonStyle value);
    public bool get_ShouldGeneratePressedAppearance();
    public void set_ShouldGeneratePressedAppearance(bool value);
    public string get_ExportValue();
    public void set_ExportValue(string value);
    protected internal virtual PdfAcroFormCommonVisualField CreateCommonAcroFormVisualField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
}
public abstract class DevExpress.Pdf.PdfGraphicsAcroFormChoiceField : PdfGraphicsAcroFormCommonField {
    private PdfAcroFormChoiceFieldController controller;
    protected PdfAcroFormChoiceFieldController Controller { get; }
    protected PdfGraphicsAcroFormChoiceField(string name, RectangleF rectangle);
    protected PdfAcroFormChoiceFieldController get_Controller();
    public void AddValue(string displayValue, string exportValue);
    public void AddValue(string displayValue);
    public void ClearValues();
    public void SetSelected(int index, bool value);
    public bool SelectValue(string exportValue);
    public void ClearSelection();
    protected internal abstract virtual PdfAcroFormChoiceField CreateAcroFormChoiceField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
    protected internal virtual PdfAcroFormCommonVisualField CreateCommonAcroFormVisualField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
}
public class DevExpress.Pdf.PdfGraphicsAcroFormComboBoxField : PdfGraphicsAcroFormChoiceField {
    [CompilerGeneratedAttribute]
private PdfAcroFormValueFormat <ValueFormat>k__BackingField;
    public bool Editable { get; public set; }
    public PdfAcroFormValueFormat ValueFormat { get; public set; }
    public PdfGraphicsAcroFormComboBoxField(string name, RectangleF rectangle);
    public bool get_Editable();
    public void set_Editable(bool value);
    [CompilerGeneratedAttribute]
public PdfAcroFormValueFormat get_ValueFormat();
    [CompilerGeneratedAttribute]
public void set_ValueFormat(PdfAcroFormValueFormat value);
    protected internal virtual PdfAcroFormChoiceField CreateAcroFormChoiceField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
}
public abstract class DevExpress.Pdf.PdfGraphicsAcroFormCommonField : PdfGraphicsAcroFormField {
    private RectangleF rectangle;
    private PdfAcroFormStringAlignment textAlignment;
    public RectangleF Rectangle { get; public set; }
    public PdfAcroFormStringAlignment TextAlignment { get; public set; }
    protected PdfGraphicsAcroFormCommonField(string name, RectangleF rectangle);
    public RectangleF get_Rectangle();
    public void set_Rectangle(RectangleF value);
    public PdfAcroFormStringAlignment get_TextAlignment();
    public void set_TextAlignment(PdfAcroFormStringAlignment value);
    protected internal abstract virtual PdfAcroFormCommonVisualField CreateCommonAcroFormVisualField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
    protected internal virtual PdfAcroFormVisualField CreateAcroFormVisualField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
}
public abstract class DevExpress.Pdf.PdfGraphicsAcroFormField : object {
    private string name;
    private PdfGraphicsAcroFormFieldAppearance appearance;
    private bool readOnly;
    private bool required;
    private bool visible;
    private bool print;
    [CompilerGeneratedAttribute]
private string <ToolTip>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfAcroFormFieldRotation <Rotation>k__BackingField;
    public string Name { get; public set; }
    public PdfGraphicsAcroFormFieldAppearance Appearance { get; public set; }
    public bool ReadOnly { get; public set; }
    public bool Required { get; public set; }
    public bool Visible { get; public set; }
    public bool Print { get; public set; }
    public string ToolTip { get; public set; }
    public PdfAcroFormFieldRotation Rotation { get; public set; }
    protected PdfGraphicsAcroFormField(string name);
    public static PdfGraphicsAcroFormTextBoxField CreateTextBox(string name, RectangleF rect);
    public static PdfGraphicsAcroFormListBoxField CreateListBox(string name, RectangleF rect);
    public static PdfGraphicsAcroFormComboBoxField CreateComboBox(string name, RectangleF rect);
    public static PdfGraphicsAcroFormRadioGroupField CreateRadioGroup(string name);
    public static PdfGraphicsAcroFormSignatureField CreateSignature(string name, RectangleF rect);
    public string get_Name();
    public void set_Name(string value);
    public PdfGraphicsAcroFormFieldAppearance get_Appearance();
    public void set_Appearance(PdfGraphicsAcroFormFieldAppearance value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public bool get_Required();
    public void set_Required(bool value);
    public bool get_Visible();
    public void set_Visible(bool value);
    public bool get_Print();
    public void set_Print(bool value);
    [CompilerGeneratedAttribute]
public string get_ToolTip();
    [CompilerGeneratedAttribute]
public void set_ToolTip(string value);
    [CompilerGeneratedAttribute]
public PdfAcroFormFieldRotation get_Rotation();
    [CompilerGeneratedAttribute]
public void set_Rotation(PdfAcroFormFieldRotation value);
    protected internal abstract virtual PdfAcroFormVisualField CreateAcroFormVisualField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
    internal PdfAcroFormField CreateAcroFormField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
}
public class DevExpress.Pdf.PdfGraphicsAcroFormFieldAppearance : object {
    private Color backgroundColor;
    private Color foreColor;
    private string fontFamily;
    private FontStyle fontStyle;
    private double fontSize;
    private PdfGraphicsAcroFormBorderAppearance borderAppearance;
    public Color BackgroundColor { get; public set; }
    public Color ForeColor { get; public set; }
    public string FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public double FontSize { get; public set; }
    public PdfGraphicsAcroFormBorderAppearance BorderAppearance { get; public set; }
    internal static PdfRGBColor ToPdfColor(Color color);
    public Color get_BackgroundColor();
    public void set_BackgroundColor(Color value);
    public Color get_ForeColor();
    public void set_ForeColor(Color value);
    public string get_FontFamily();
    public void set_FontFamily(string value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public PdfGraphicsAcroFormBorderAppearance get_BorderAppearance();
    public void set_BorderAppearance(PdfGraphicsAcroFormBorderAppearance value);
    internal PdfAcroFormFieldAppearance CreateAppearance(PdfGraphicsCommandConstructor constructor);
}
public class DevExpress.Pdf.PdfGraphicsAcroFormListBoxField : PdfGraphicsAcroFormChoiceField {
    private int topIndex;
    public int TopIndex { get; public set; }
    public bool MultiSelect { get; public set; }
    public PdfGraphicsAcroFormListBoxField(string name, RectangleF rectangle);
    public int get_TopIndex();
    public void set_TopIndex(int value);
    public bool get_MultiSelect();
    public void set_MultiSelect(bool value);
    protected internal virtual PdfAcroFormChoiceField CreateAcroFormChoiceField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
}
public class DevExpress.Pdf.PdfGraphicsAcroFormRadioGroupField : PdfGraphicsAcroFormField {
    private PdfAcroFormRadioGroupFieldController`1<RectangleF> buttonController;
    private PdfAcroFormButtonStyle buttonStyle;
    private bool shouldGeneratePressedAppearance;
    public PdfAcroFormButtonStyle ButtonStyle { get; public set; }
    public int SelectedIndex { get; public set; }
    public int RadioButtonCount { get; }
    public bool ShouldGeneratePressedAppearance { get; public set; }
    public PdfGraphicsAcroFormRadioGroupField(string name);
    public PdfAcroFormButtonStyle get_ButtonStyle();
    public void set_ButtonStyle(PdfAcroFormButtonStyle value);
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    public int get_RadioButtonCount();
    public bool get_ShouldGeneratePressedAppearance();
    public void set_ShouldGeneratePressedAppearance(bool value);
    public void AddButton(string name, RectangleF rect);
    public void ClearButtons();
    protected internal virtual PdfAcroFormVisualField CreateAcroFormVisualField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
}
public class DevExpress.Pdf.PdfGraphicsAcroFormSignatureField : PdfGraphicsAcroFormCommonField {
    private bool stretchContentImage;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfAcroFormStringAlignment <LineAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private DXImage <ContentDXImage>k__BackingField;
    public string Text { get; public set; }
    public PdfAcroFormStringAlignment LineAlignment { get; public set; }
    public Image ContentImage { get; public set; }
    public DXImage ContentDXImage { get; public set; }
    public bool StretchContentImage { get; public set; }
    public PdfGraphicsAcroFormSignatureField(string name, RectangleF rectangle);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public PdfAcroFormStringAlignment get_LineAlignment();
    [CompilerGeneratedAttribute]
public void set_LineAlignment(PdfAcroFormStringAlignment value);
    public Image get_ContentImage();
    public void set_ContentImage(Image value);
    [CompilerGeneratedAttribute]
public DXImage get_ContentDXImage();
    [CompilerGeneratedAttribute]
public void set_ContentDXImage(DXImage value);
    public bool get_StretchContentImage();
    public void set_StretchContentImage(bool value);
    protected internal virtual PdfAcroFormCommonVisualField CreateCommonAcroFormVisualField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
}
public class DevExpress.Pdf.PdfGraphicsAcroFormTextBoxField : PdfGraphicsAcroFormCommonField {
    private int maxLength;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Multiline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Scrollable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpellCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfAcroFormTextFieldType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PdfAcroFormValueFormat <ValueFormat>k__BackingField;
    public string Text { get; public set; }
    public bool Multiline { get; public set; }
    public bool Scrollable { get; public set; }
    public bool SpellCheck { get; public set; }
    public PdfAcroFormTextFieldType Type { get; public set; }
    public int MaxLength { get; public set; }
    public PdfAcroFormValueFormat ValueFormat { get; public set; }
    public PdfGraphicsAcroFormTextBoxField(string name, RectangleF rectangle);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public bool get_Multiline();
    [CompilerGeneratedAttribute]
public void set_Multiline(bool value);
    [CompilerGeneratedAttribute]
public bool get_Scrollable();
    [CompilerGeneratedAttribute]
public void set_Scrollable(bool value);
    [CompilerGeneratedAttribute]
public bool get_SpellCheck();
    [CompilerGeneratedAttribute]
public void set_SpellCheck(bool value);
    [CompilerGeneratedAttribute]
public PdfAcroFormTextFieldType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PdfAcroFormTextFieldType value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    [CompilerGeneratedAttribute]
public PdfAcroFormValueFormat get_ValueFormat();
    [CompilerGeneratedAttribute]
public void set_ValueFormat(PdfAcroFormValueFormat value);
    protected internal virtual PdfAcroFormCommonVisualField CreateCommonAcroFormVisualField(PdfDocumentStateBase documentState, int pageNumber, PdfGraphicsCommandConstructor constructor);
}
public enum DevExpress.Pdf.PdfGraphicsJpegImageQuality : Enum {
    public int value__;
    public static PdfGraphicsJpegImageQuality Lowest;
    public static PdfGraphicsJpegImageQuality Low;
    public static PdfGraphicsJpegImageQuality Medium;
    public static PdfGraphicsJpegImageQuality High;
    public static PdfGraphicsJpegImageQuality Highest;
}
public class DevExpress.Pdf.PdfPageRenderingParameters : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LargestEdgeLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <Dpi>k__BackingField;
    public Nullable`1<int> LargestEdgeLength { get; }
    public Nullable`1<float> Dpi { get; }
    private PdfPageRenderingParameters(Nullable`1<int> largestEdgeLength, Nullable`1<float> dpi);
    public static PdfPageRenderingParameters CreateWithResolution(float dpi);
    public static PdfPageRenderingParameters Create(int largestEdgeLength);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LargestEdgeLength();
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_Dpi();
}
public class DevExpress.Pdf.PdfPrinterSettings : object {
    internal static int DefaultPrintingDpi;
    private PdfCachedPrinterSettings settings;
    private Int32[] pageNumbers;
    private PdfPrintScaleMode scaleMode;
    private float scale;
    private PdfPrintPageOrientation pageOrientation;
    private int maxDpi;
    private bool printInGrayscale;
    private bool enableLegacyPrinting;
    [CompilerGeneratedAttribute]
private bool <PrintStickyNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintTextAsOutlines>k__BackingField;
    private int SupportedMaxDpi { get; }
    internal int MaxDpi { get; internal set; }
    public PrinterSettings Settings { get; }
    public Int32[] PageNumbers { get; public set; }
    public PdfPrintScaleMode ScaleMode { get; public set; }
    public float Scale { get; public set; }
    public PdfPrintPageOrientation PageOrientation { get; public set; }
    public int PrintingDpi { get; public set; }
    [DefaultValueAttribute("True")]
public bool PrintInGrayscale { get; public set; }
    [DefaultValueAttribute("False")]
public bool EnableLegacyPrinting { get; public set; }
    [DefaultValueAttribute("True")]
public bool PrintStickyNotes { get; public set; }
    [DefaultValueAttribute("False")]
public bool PrintTextAsOutlines { get; public set; }
    internal PdfCachedPrinterSettings CachedSettings { get; }
    internal PdfPrinterSettings(PrinterSettings newPrinterSettings, PdfPrinterSettings pdfPrinterSettings);
    internal PdfPrinterSettings(PrinterSettings settings, Int32[] pageNumbers, PdfPrintPageOrientation pageOrientation, float scale, PdfPrintScaleMode scaleMode);
    public PdfPrinterSettings(PrinterSettings settings);
    internal static int GetResolutionDpi(PrinterResolution resolution);
    private int get_SupportedMaxDpi();
    internal int get_MaxDpi();
    internal void set_MaxDpi(int value);
    public PrinterSettings get_Settings();
    public Int32[] get_PageNumbers();
    public void set_PageNumbers(Int32[] value);
    public PdfPrintScaleMode get_ScaleMode();
    public void set_ScaleMode(PdfPrintScaleMode value);
    public float get_Scale();
    public void set_Scale(float value);
    public PdfPrintPageOrientation get_PageOrientation();
    public void set_PageOrientation(PdfPrintPageOrientation value);
    public int get_PrintingDpi();
    public void set_PrintingDpi(int value);
    public bool get_PrintInGrayscale();
    public void set_PrintInGrayscale(bool value);
    public bool get_EnableLegacyPrinting();
    public void set_EnableLegacyPrinting(bool value);
    [CompilerGeneratedAttribute]
public bool get_PrintStickyNotes();
    [CompilerGeneratedAttribute]
public void set_PrintStickyNotes(bool value);
    [CompilerGeneratedAttribute]
public bool get_PrintTextAsOutlines();
    [CompilerGeneratedAttribute]
public void set_PrintTextAsOutlines(bool value);
    internal PdfCachedPrinterSettings get_CachedSettings();
    internal Int32[] GetPageNumbers(int currentPageNumber, int pageCount, string pageRangeText);
    internal void SetPageNumbers(int currentPageNumber, int pageCount, string pageRangeText);
    private Int32[] CreatePageNumbersArray(int from, int to);
    private Int32[] ParsePageNumbers(string pageRangeText, int maxPageNumber);
}
public class DevExpress.Pdf.PdfPrintPageEventArgs : PrintPageEventArgs {
    private int pageNumber;
    private int pageCount;
    public int PageNumber { get; }
    public int PageCount { get; }
    internal PdfPrintPageEventArgs(PrintPageEventArgs args, int pageNumber, int pageCount);
    public int get_PageNumber();
    public int get_PageCount();
}
public class DevExpress.Pdf.PdfPrintPageEventHandler : MulticastDelegate {
    public PdfPrintPageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PdfPrintPageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PdfPrintPageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum DevExpress.Pdf.PdfPrintPageOrientation : Enum {
    public int value__;
    public static PdfPrintPageOrientation Auto;
    public static PdfPrintPageOrientation Portrait;
    public static PdfPrintPageOrientation Landscape;
}
public enum DevExpress.Pdf.PdfPrintScaleMode : Enum {
    public int value__;
    public static PdfPrintScaleMode Fit;
    public static PdfPrintScaleMode ActualSize;
    public static PdfPrintScaleMode CustomScale;
}
public class DevExpress.Pdf.PdfQueryPageSettingsEventArgs : QueryPageSettingsEventArgs {
    private int pageNumber;
    private SizeF pageSize;
    private bool printInGrayscale;
    public int PageNumber { get; }
    public SizeF PageSize { get; }
    public bool PrintInGrayscale { get; public set; }
    internal PdfQueryPageSettingsEventArgs(QueryPageSettingsEventArgs args, int pageNumber, SizeF pageSize, bool printInGrayscale);
    public int get_PageNumber();
    public SizeF get_PageSize();
    public bool get_PrintInGrayscale();
    public void set_PrintInGrayscale(bool value);
}
public class DevExpress.Pdf.PdfQueryPageSettingsEventHandler : MulticastDelegate {
    public PdfQueryPageSettingsEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PdfQueryPageSettingsEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PdfQueryPageSettingsEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum DevExpress.Pdf.PdfRenderingEngine : Enum {
    public int value__;
    public static PdfRenderingEngine Default;
    public static PdfRenderingEngine GdiPlus;
    public static PdfRenderingEngine DirectX;
    public static PdfRenderingEngine Skia;
    public static PdfRenderingEngine DirectXSoftware;
}
[ExtensionAttribute]
public static class DevExpress.Pdf.PdfViewerAnnotationBuilderExtensions : object {
    [ExtensionAttribute]
public static IPdfViewerMarkupAnnotationBuilder AsMarkupAnnotationBuilder(IPdfViewerAnnotationBuilder builder);
    [ExtensionAttribute]
public static IPdfViewerTextMarkupAnnotationBuilder AsTextMarkupAnnotationBuilder(IPdfViewerAnnotationBuilder builder);
    [ExtensionAttribute]
public static IPdfViewerTextAnnotationBuilder AsTextAnnotationBuilder(IPdfViewerAnnotationBuilder builder);
    [ExtensionAttribute]
public static IPdfViewerTextMarkupAnnotationBuilder AsTextMarkupAnnotationBuilder(IPdfViewerMarkupAnnotationBuilder builder);
    [ExtensionAttribute]
public static IPdfViewerTextAnnotationBuilder AsTextAnnotationBuilder(IPdfViewerMarkupAnnotationBuilder builder);
}
[ExtensionAttribute]
public static class DevExpress.Pdf.PdfViewerAnnotationExtensions : object {
    [ExtensionAttribute]
public static IPdfViewerMarkupAnnotation AsMarkupAnnotation(IPdfViewerAnnotation annotation);
    [ExtensionAttribute]
public static IPdfViewerTextMarkupAnnotation AsTextMarkupAnnotation(IPdfViewerAnnotation annotation);
    [ExtensionAttribute]
public static IPdfViewerTextAnnotation AsTextAnnotation(IPdfViewerAnnotation annotation);
    [ExtensionAttribute]
public static IPdfViewerTextMarkupAnnotation AsTextMarkupAnnotation(IPdfViewerMarkupAnnotation annotation);
    [ExtensionAttribute]
public static IPdfViewerTextAnnotation AsTextAnnotation(IPdfViewerMarkupAnnotation annotation);
}
public class DevExpress.Pdf.PdfViewerReview : object {
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    public string Author { get; }
    public string Status { get; }
    internal PdfViewerReview(string author, string status);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public string get_Status();
}
public interface DevExpress.Pdf.ViewModel.IPdfMarkupAnnotationPropertiesFormViewModel {
    public PdfAnnotationType AnnotationType { get; }
    public Color Color { get; public set; }
    public int Opacity { get; public set; }
    public string Author { get; public set; }
    public string Subject { get; public set; }
    public string Comment { get; public set; }
    public string Name { get; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; }
    public Nullable`1<DateTimeOffset> CreationDate { get; }
    public abstract virtual PdfAnnotationType get_AnnotationType();
    public abstract virtual Color get_Color();
    public abstract virtual void set_Color(Color value);
    public abstract virtual int get_Opacity();
    public abstract virtual void set_Opacity(int value);
    public abstract virtual string get_Author();
    public abstract virtual void set_Author(string value);
    public abstract virtual string get_Subject();
    public abstract virtual void set_Subject(string value);
    public abstract virtual string get_Comment();
    public abstract virtual void set_Comment(string value);
    public abstract virtual string get_Name();
    public abstract virtual Nullable`1<DateTimeOffset> get_ModificationDate();
    public abstract virtual Nullable`1<DateTimeOffset> get_CreationDate();
}
public interface DevExpress.Pdf.ViewModel.IPdfTextAnnotationPropertiesFormViewModel {
    public string IconName { get; public set; }
    public abstract virtual string get_IconName();
    public abstract virtual void set_IconName(string value);
}
public interface DevExpress.Pdf.ViewModel.IPdfTextMarkupAnnotationPropertiesFormViewModel {
    public PdfTextMarkupAnnotationType MarkupType { get; public set; }
    public abstract virtual PdfTextMarkupAnnotationType get_MarkupType();
    public abstract virtual void set_MarkupType(PdfTextMarkupAnnotationType value);
}
