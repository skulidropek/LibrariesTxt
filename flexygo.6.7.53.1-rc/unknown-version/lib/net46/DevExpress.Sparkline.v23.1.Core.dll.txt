public class DevExpress.ChartRangeControlClient.Core.BindingSource : object {
    private SparklineScaleType scaleType;
    private Dictionary`2<string, DataBrowser> dataBrowserCache;
    private DataContextBase dataContext;
    private IBindingSourceDelegate sourceDelegate;
    private List`1<IClientSeries> seriesCache;
    private bool isDisposed;
    private object itemsSource;
    private string valueDataMember;
    private string seriesDataMember;
    private string argumentDataMember;
    private bool IsBindingPossible { get; }
    public bool IsDisposed { get; }
    public DataContextBase DataContext { get; }
    public object ItemsSource { get; public set; }
    public string SeriesDataMember { get; public set; }
    public string ArgumentDataMember { get; public set; }
    public string ValueDataMember { get; public set; }
    public SparklineScaleType ScaleType { get; }
    public BindingSource(SparklineScaleType scaleType, IBindingSourceDelegate sourceDelegate);
    private static bool IsNumericType(Type type);
    private static bool IsDateTimeType(Type type);
    private static bool IsTimeSpanType(Type type);
    private static bool IsNull(object value);
    private static PropertyDescriptor GetPropertyDescriptor(DataBrowser browser, string dataMember);
    internal static double MapDateTimeValue(DateTime value);
    private bool get_IsBindingPossible();
    public bool get_IsDisposed();
    public DataContextBase get_DataContext();
    public object get_ItemsSource();
    public void set_ItemsSource(object value);
    public string get_SeriesDataMember();
    public void set_SeriesDataMember(string value);
    public string get_ArgumentDataMember();
    public void set_ArgumentDataMember(string value);
    public string get_ValueDataMember();
    public void set_ValueDataMember(string value);
    public SparklineScaleType get_ScaleType();
    public sealed virtual void Dispose();
    private void ItemsSourceCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void ItemsSourceBindingListChanged(object sender, ListChangedEventArgs e);
    private void ItemsSourceDataSetCollectionChanged(object sender, CollectionChangeEventArgs e);
    private void ItemsSourceDataSetColumnChanged(object sender, DataColumnChangeEventArgs e);
    private void ItemsSourceDataSetTableCleared(object sender, DataTableClearEventArgs e);
    private void ItemsSourceDataSetRowDeleted(object sender, DataRowChangeEventArgs e);
    private void ItemsSourceDataSetRowChanged(object sender, DataRowChangeEventArgs e);
    private void RaiseBindingChanged();
    private void SubscribeDataTable(DataTable table);
    private void UnsubscribeDataTable(DataTable table);
    private void SubscribeSource();
    private void UnsubscribeSource();
    private void ClearContext();
    private DataBrowser GetDataBrowser(string dataMember);
    private DataBrowser CreateDataBrowser(string dataMember);
    private bool CheckArgumentCompatibility(DataBrowser rootBrowser);
    private bool CheckValueCompatibility(DataBrowser rootBrowser);
    private bool CheckItemsSourceCompatibility(DataBrowser rootBrowser);
    private void AdjustSeries(object dataSourceValue, BindingSourceClientSeries series, int seriesCounter);
    private void ReadSource();
    public IList`1<IClientSeries> GetSeries();
    public void RefreshData();
}
public class DevExpress.ChartRangeControlClient.Core.BindingSourceClientSeries : object {
    private List`1<SparklinePoint> points;
    private SparklineRange range;
    private SparklineViewBase view;
    [CompilerGeneratedAttribute]
private PaddingInfo <Padding>k__BackingField;
    public PaddingInfo Padding { get; public set; }
    public SparklineViewBase View { get; public set; }
    public List`1<SparklinePoint> Points { get; }
    private SparklineViewBase DevExpress.Sparkline.Core.ISparklineSettings.View { get; }
    private PaddingInfo DevExpress.Sparkline.Core.ISparklineSettings.Padding { get; }
    private SparklineRange DevExpress.Sparkline.Core.ISparklineSettings.ValueRange { get; }
    private IList`1<SparklinePoint> DevExpress.Sparkline.Core.ISparklineExtendedData.Points { get; }
    [CompilerGeneratedAttribute]
public PaddingInfo get_Padding();
    [CompilerGeneratedAttribute]
public void set_Padding(PaddingInfo value);
    public SparklineViewBase get_View();
    public void set_View(SparklineViewBase value);
    public List`1<SparklinePoint> get_Points();
    private sealed virtual override SparklineViewBase DevExpress.Sparkline.Core.ISparklineSettings.get_View();
    private sealed virtual override PaddingInfo DevExpress.Sparkline.Core.ISparklineSettings.get_Padding();
    private sealed virtual override SparklineRange DevExpress.Sparkline.Core.ISparklineSettings.get_ValueRange();
    private sealed virtual override IList`1<SparklinePoint> DevExpress.Sparkline.Core.ISparklineExtendedData.get_Points();
}
public class DevExpress.ChartRangeControlClient.Core.ChartCoreClient : object {
    private SeriesInteraction interaction;
    private SparklinePaintersCache sparklinePaintersCache;
    private IClientDataProvider dataProvider;
    private IChartCoreClientDelegate clientDelegate;
    public IClientDataProvider DataProvider { get; public set; }
    public bool HasDataToPresent { get; }
    public SeriesInteraction Interaction { get; }
    public IChartCoreClientDelegate Delegate { get; public set; }
    public IClientDataProvider get_DataProvider();
    public void set_DataProvider(IClientDataProvider value);
    public bool get_HasDataToPresent();
    public SeriesInteraction get_Interaction();
    public IChartCoreClientDelegate get_Delegate();
    public void set_Delegate(IChartCoreClientDelegate value);
    private void DataProviderDataChanged(IClientDataProvider provider);
    private void UpdateInteraction();
    private GridUnit GetAutoGridUnit(double min, double max, double width, IChartCoreClientGridOptions gridOptions);
    private double RoundNormalValue(double normalizedValue, GridUnit unit, IChartCoreClientGridMapping gridMapping);
    private double FloorNormalValue(double normalizedValue, GridUnit unit, IChartCoreClientGridMapping gridMapping);
    private double CeilNormalValue(double normalizedValue, GridUnit unit, IChartCoreClientGridMapping gridMapping);
    private double ShiftNormalValue(double normalizedValue, GridUnit unit, IChartCoreClientGridMapping gridMapping, double offset);
    public void DrawContent(IGraphicsCache cache, Rectangle bounds, Matrix normalTransform);
    public void DrawContent(Graphics graphics, Rectangle bounds, Matrix normalTransform);
    public double Normalize(double value);
    public double GetValue(double normalizedValue);
    public List`1<object> GenerateGrid(double min, double max, double width, IChartCoreClientGridOptions gridOptions);
    public void SnapNormalRange(SparklineRangeData range, SnapBounds changedBounds, IChartCoreClientGridOptions gridOptions);
    public void SetCustomArgumentRange(SparklineRangeData range);
}
public class DevExpress.ChartRangeControlClient.Core.DataChangedDelegate : MulticastDelegate {
    public DataChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(IClientDataProvider provider);
    public virtual IAsyncResult BeginInvoke(IClientDataProvider provider, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class DevExpress.ChartRangeControlClient.Core.GridUnit : object {
    [CompilerGeneratedAttribute]
private double <Spacing>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Unit>k__BackingField;
    public double Spacing { get; public set; }
    public double Unit { get; public set; }
    public double Step { get; }
    public GridUnit(double unit, double spacing);
    [CompilerGeneratedAttribute]
public double get_Spacing();
    [CompilerGeneratedAttribute]
public void set_Spacing(double value);
    [CompilerGeneratedAttribute]
public double get_Unit();
    [CompilerGeneratedAttribute]
public void set_Unit(double value);
    public double get_Step();
}
public interface DevExpress.ChartRangeControlClient.Core.IBindingSourceDelegate {
    public abstract virtual void BindingChanged();
    public abstract virtual void AdjustSeries(object dataSourceValue, BindingSourceClientSeries series, int seriesCounter);
}
public interface DevExpress.ChartRangeControlClient.Core.IChartCoreClientDelegate {
    public abstract virtual void InteractionUpdated();
}
public interface DevExpress.ChartRangeControlClient.Core.IChartCoreClientGridMapping {
    public abstract virtual GridUnit SelectGridUnit(double unit);
    public abstract virtual double CeilValue(GridUnit unit, double value);
    public abstract virtual double FloorValue(GridUnit unit, double value);
    public abstract virtual double GetGridValue(GridUnit unit, double index);
}
public interface DevExpress.ChartRangeControlClient.Core.IChartCoreClientGridOptions {
    public bool Auto { get; }
    public GridUnit GridUnit { get; }
    public GridUnit SnapUnit { get; }
    public double PixelPerUnit { get; }
    public IChartCoreClientGridMapping GridMapping { get; }
    public abstract virtual bool get_Auto();
    public abstract virtual GridUnit get_GridUnit();
    public abstract virtual GridUnit get_SnapUnit();
    public abstract virtual double get_PixelPerUnit();
    public abstract virtual IChartCoreClientGridMapping get_GridMapping();
}
public interface DevExpress.ChartRangeControlClient.Core.IClientDataProvider {
    public IList`1<IClientSeries> Series { get; }
    public abstract virtual IList`1<IClientSeries> get_Series();
    public abstract virtual void SetDataChangedDelegate(DataChangedDelegate dataChangedDelegate);
}
public interface DevExpress.ChartRangeControlClient.Core.IClientSeries {
}
[DefaultMemberAttribute("Item")]
public class DevExpress.ChartRangeControlClient.Core.SeriesInteraction : object {
    private List`1<SeriesProviderPair> dataProviders;
    private SparklineInteractionRanges interactionRanges;
    public int Count { get; }
    public bool HasDataToPresent { get; }
    public SparklineInteractionRanges Ranges { get; }
    public SeriesProviderPair Item { get; }
    public int get_Count();
    public bool get_HasDataToPresent();
    public SparklineInteractionRanges get_Ranges();
    private void UpdateRanges(SparklineDataProvider provider);
    public void Clear();
    public void Add(IClientSeries series);
    public SeriesProviderPair get_Item(int index);
    public double NormalizeArgument(double argument);
    public double GetArgument(double normalizedArgument);
}
public class DevExpress.ChartRangeControlClient.Core.SeriesProviderPair : object {
    private IClientSeries series;
    private SparklineDataProvider dataProvider;
    public IClientSeries Series { get; }
    public SparklineDataProvider DataProvider { get; }
    public SeriesProviderPair(IClientSeries series, SparklineDataProvider provider);
    public IClientSeries get_Series();
    public SparklineDataProvider get_DataProvider();
}
public enum DevExpress.ChartRangeControlClient.Core.SnapBounds : Enum {
    public int value__;
    public static SnapBounds None;
    public static SnapBounds Minimum;
    public static SnapBounds Maximum;
    public static SnapBounds Both;
}
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.AreaSparklineView")]
public class DevExpress.Sparkline.AreaSparklineView : LineSparklineView {
    private static byte defaultAreaOpacity;
    private byte areaOpacity;
    [DescriptionAttribute("Specifies the opacity (0-255) of the area sparkline.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.AreaSparklineView.AreaOpacity")]
public byte AreaOpacity { get; public set; }
    [DescriptionAttribute("Gets the type of the sparkline view.")]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.AreaSparklineView.Type")]
public SparklineViewType Type { get; }
    private ExportSparklineType DevExpress.Data.Export.ISparklineInfo.SparklineType { get; }
    private bool DevExpress.Data.Export.ISparklineInfo.SpecificSparklineType { get; }
    public sealed virtual byte get_AreaOpacity();
    public void set_AreaOpacity(byte value);
    public virtual SparklineViewType get_Type();
    private bool ShouldSerializeAreaOpacity();
    protected virtual bool XtraShouldSerialize(string propertyName);
    private void ResetAreaOpacity();
    private sealed virtual override ExportSparklineType DevExpress.Data.Export.ISparklineInfo.get_SparklineType();
    private sealed virtual override bool DevExpress.Data.Export.ISparklineInfo.get_SpecificSparklineType();
    protected virtual string GetViewName();
    public virtual void Assign(SparklineViewBase view);
    public virtual void Visit(ISparklineViewVisitor visitor);
}
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.BarSparklineView")]
public class DevExpress.Sparkline.BarSparklineView : BarSparklineViewBase {
    protected bool DefaultHighlightNegativePoints { get; }
    [DescriptionAttribute("Gets the type of the sparkline view.")]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.BarSparklineView.Type")]
public SparklineViewType Type { get; }
    private ExportSparklineType DevExpress.Data.Export.ISparklineInfo.SparklineType { get; }
    protected virtual bool get_DefaultHighlightNegativePoints();
    public virtual SparklineViewType get_Type();
    private sealed virtual override ExportSparklineType DevExpress.Data.Export.ISparklineInfo.get_SparklineType();
    protected virtual string GetViewName();
    public virtual void Visit(ISparklineViewVisitor visitor);
}
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.BarSparklineViewBase")]
public abstract class DevExpress.Sparkline.BarSparklineViewBase : SparklineViewBase {
    private static int defaultBarDistance;
    private int barDistance;
    [DescriptionAttribute("Specifies the distance between two bars of a bar sparkline.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.BarSparklineViewBase.BarDistance")]
public int BarDistance { get; public set; }
    public sealed virtual int get_BarDistance();
    public void set_BarDistance(int value);
    private bool ShouldSerializeBarDistance();
    protected virtual bool XtraShouldSerialize(string propertyName);
    private void ResetBarDistance();
    public virtual void Assign(SparklineViewBase view);
}
public class DevExpress.Sparkline.Core.AreaSparklinePainter : LineSparklinePainter {
    private AreaSparklineView AreaView { get; }
    public SparklineViewType SparklineType { get; }
    private AreaSparklineView get_AreaView();
    public virtual SparklineViewType get_SparklineType();
    protected virtual void DrawWholeGeometry(ISparklineRenderer renderer, Color color, List`1<PointF> points);
}
public class DevExpress.Sparkline.Core.BarSparklineMapping : SparklineMappingBase {
    protected internal BarSparklineMapping(Rectangle bounds);
    protected virtual SparklineRangeData CorrectValueRange(SparklineRangeData range);
    protected virtual SparklineRangeData CorrectArgumentRange(double minPointDistance, SparklineRangeData range);
}
public class DevExpress.Sparkline.Core.BarSparklinePainter : BaseSparklinePainter {
    private BarSparklineViewBase BarView { get; }
    protected bool EnableAntialiasing { get; }
    public SparklineViewType SparklineType { get; }
    private BarSparklineViewBase get_BarView();
    protected virtual bool get_EnableAntialiasing();
    public virtual SparklineViewType get_SparklineType();
    private void DrawBar(ISparklineRenderer renderer, int barWidth, int halfBarWidth, int i, PointF screenPoint);
    protected virtual PaddingInfo GetMarkersPadding();
    protected virtual void DrawInternal(ISparklineRenderer renderer);
    public virtual List`1<SparklineMappedPointInfo> GetMappedPoints();
}
public abstract class DevExpress.Sparkline.Core.BaseSparklinePainter : object {
    private Rectangle clippingBounds;
    private SparklineDataProvider dataProvider;
    private SparklineMappingBase mapping;
    private SparklineViewBase view;
    [CompilerGeneratedAttribute]
private List`1<SparklineMappedPointInfo> <MappedPoints>k__BackingField;
    protected SparklineDataProvider DataProvider { get; }
    protected SparklineViewBase View { get; }
    protected bool EnableAntialiasing { get; }
    internal SparklineMappingBase Mapping { get; }
    public SparklineViewType SparklineType { get; }
    public List`1<SparklineMappedPointInfo> MappedPoints { get; public set; }
    protected SparklineDataProvider get_DataProvider();
    protected SparklineViewBase get_View();
    protected abstract virtual bool get_EnableAntialiasing();
    internal SparklineMappingBase get_Mapping();
    public abstract virtual SparklineViewType get_SparklineType();
    [CompilerGeneratedAttribute]
public List`1<SparklineMappedPointInfo> get_MappedPoints();
    [CompilerGeneratedAttribute]
public void set_MappedPoints(List`1<SparklineMappedPointInfo> value);
    internal void DrawContent(ISparklineRenderer renderer);
    private ISparklineRenderer CreateRenderer(Graphics graphics, IGraphicsCache cache);
    private Rectangle InflateRelatively(Rectangle rect, SparklineRangeData range);
    private PaddingInfo DeterminePadding(ISparklineSettings settings);
    protected int GetIndexOfFirstPointForDrawing();
    protected int GetIndexOfLastPointForDrawing();
    protected internal PointPresentationType GetPointPresentationType(int index);
    protected internal virtual Color GetPointColor(PointPresentationType pointType);
    protected abstract virtual void DrawInternal(ISparklineRenderer renderer);
    protected abstract virtual PaddingInfo GetMarkersPadding();
    public abstract virtual List`1<SparklineMappedPointInfo> GetMappedPoints();
    public void Initialize(ISparklineData data, ISparklineSettings settings, Rectangle bounds);
    public void Initialize(SparklineDataProvider dataProvider, ISparklineSettings settings, Rectangle bounds, SparklineInteractionRanges interactionRanges, Matrix normalTransform);
    public void Draw(Graphics graphics, IGraphicsCache cache);
    public void Draw(IDXGraphics graphics);
    public EmfMetafile ExportToMetafileModel(Rectangle bounds);
}
public class DevExpress.Sparkline.Core.CohenSutherlandLineClipAlgorithm : object {
    private static int LEFT;
    private static int RIGHT;
    private static int TOP;
    private static int BOTTOM;
    private Rectangle bounds;
    public CohenSutherlandLineClipAlgorithm(Rectangle bounds);
    private int CalculateOutCode(PointF point);
    public Tuple`2<PointF, PointF> GetCutLine(PointF p1, PointF p2);
}
public class DevExpress.Sparkline.Core.CommonSparklineRenderer : object {
    private IDXGraphics dxGraphics;
    private Stack`1<DXSmoothingMode> antialiasingStack;
    private Stack`1<DXRegion> clippingCache;
    public CommonSparklineRenderer(IDXGraphics dxGraphics);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.DrawLine(PointF point1, PointF point2, Color color, int thickness);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.DrawLines(PointF[] points, Color color, int thickness);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.FillEllipse(float x, float y, float width, float height, Color color);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.FillPolygon(PointF[] points, Color color);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.FillRectangle(float x, float y, float width, float height, Color color);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.RestoreAntialiasingMode();
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.RestoreClip();
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.SetAntialiasingMode(SmoothingMode mode);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.SetClip(Rectangle rect);
    private sealed virtual override void System.IDisposable.Dispose();
}
public enum DevExpress.Sparkline.Core.DateTimeMeasureUnit : Enum {
    public int value__;
    public static DateTimeMeasureUnit Millisecond;
    public static DateTimeMeasureUnit Second;
    public static DateTimeMeasureUnit Minute;
    public static DateTimeMeasureUnit Hour;
    public static DateTimeMeasureUnit Day;
    public static DateTimeMeasureUnit Week;
    public static DateTimeMeasureUnit Month;
    public static DateTimeMeasureUnit Quarter;
    public static DateTimeMeasureUnit Year;
}
public class DevExpress.Sparkline.Core.DirectXSparklineRenderer : object {
    private Stack`1<IGraphicsClipState> clippingCache;
    [CompilerGeneratedAttribute]
private IGraphicsCache <Cache>k__BackingField;
    protected IGraphicsCache Cache { get; private set; }
    public DirectXSparklineRenderer(IGraphicsCache cache);
    [CompilerGeneratedAttribute]
protected IGraphicsCache get_Cache();
    [CompilerGeneratedAttribute]
private void set_Cache(IGraphicsCache value);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.SetAntialiasingMode(SmoothingMode mode);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.RestoreAntialiasingMode();
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.SetClip(Rectangle rect);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.RestoreClip();
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.FillPolygon(PointF[] points, Color color);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.FillEllipse(float x, float y, float width, float height, Color color);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.FillRectangle(float x, float y, float width, float height, Color color);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.DrawLine(PointF point1, PointF point2, Color color, int thickness);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.DrawLines(PointF[] points, Color color, int thickness);
    private sealed virtual override void System.IDisposable.Dispose();
}
public class DevExpress.Sparkline.Core.EmfPlusSparklineRenderer : EmfPlusRenderer {
    public EmfPlusSparklineRenderer(IEmfMetafileBuilder builder);
    public sealed virtual void SetAntialiasingMode(SmoothingMode mode);
    public sealed virtual void RestoreAntialiasingMode();
    public sealed virtual void SetClip(Rectangle rect);
    public sealed virtual void FillPolygon(PointF[] points, Color color);
    public sealed virtual void FillEllipse(float x, float y, float width, float height, Color color);
    public sealed virtual void FillRectangle(float x, float y, float width, float height, Color color);
    public sealed virtual void DrawLine(PointF point1, PointF point2, Color color, int thickness);
    public sealed virtual void DrawLines(PointF[] points, Color color, int thickness);
    protected virtual void RemoveLastClipPath();
    public sealed virtual void Dispose();
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.RestoreClip();
}
public class DevExpress.Sparkline.Core.GdiPlusSparklineRenderer : object {
    private Stack`1<SmoothingMode> antialiasingStack;
    private Stack`1<Region> clippingCache;
    private Graphics graphics;
    private IGraphicsCache cache;
    private SparklineDrawingCache localCache;
    public GdiPlusSparklineRenderer(Graphics graphics, IGraphicsCache cache);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.SetAntialiasingMode(SmoothingMode mode);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.RestoreAntialiasingMode();
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.SetClip(Rectangle rect);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.RestoreClip();
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.FillPolygon(PointF[] points, Color color);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.DrawLine(PointF point1, PointF point2, Color color, int thickness);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.DrawLines(PointF[] points, Color color, int thickness);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.FillEllipse(float x, float y, float width, float height, Color color);
    private sealed virtual override void DevExpress.Sparkline.Core.ISparklineRenderer.FillRectangle(float x, float y, float width, float height, Color color);
    private sealed virtual override void System.IDisposable.Dispose();
    private SolidBrush GetSolidBrush(Color color);
    private Pen GetPen(Color color, int width);
}
public interface DevExpress.Sparkline.Core.ISparklineAppearanceProvider {
    public Color Color { get; }
    public Color MarkerColor { get; }
    public Color MaxPointColor { get; }
    public Color MinPointColor { get; }
    public Color StartPointColor { get; }
    public Color EndPointColor { get; }
    public Color NegativePointColor { get; }
    public abstract virtual Color get_Color();
    public abstract virtual Color get_MarkerColor();
    public abstract virtual Color get_MaxPointColor();
    public abstract virtual Color get_MinPointColor();
    public abstract virtual Color get_StartPointColor();
    public abstract virtual Color get_EndPointColor();
    public abstract virtual Color get_NegativePointColor();
}
public interface DevExpress.Sparkline.Core.ISparklineData {
    public IList`1<double> Values { get; }
    public abstract virtual IList`1<double> get_Values();
}
public interface DevExpress.Sparkline.Core.ISparklineExtendedData {
    public IList`1<SparklinePoint> Points { get; }
    public abstract virtual IList`1<SparklinePoint> get_Points();
}
public interface DevExpress.Sparkline.Core.ISparklineRenderer {
    public abstract virtual void SetAntialiasingMode(SmoothingMode mode);
    public abstract virtual void RestoreAntialiasingMode();
    public abstract virtual void SetClip(Rectangle rect);
    public abstract virtual void RestoreClip();
    public abstract virtual void FillPolygon(PointF[] points, Color color);
    public abstract virtual void FillEllipse(float x, float y, float width, float height, Color color);
    public abstract virtual void FillRectangle(float x, float y, float width, float height, Color color);
    public abstract virtual void DrawLine(PointF point1, PointF point2, Color color, int thickness);
    public abstract virtual void DrawLines(PointF[] points, Color color, int thickness);
}
public interface DevExpress.Sparkline.Core.ISparklineSettings {
    public PaddingInfo Padding { get; }
    public SparklineViewBase View { get; }
    public SparklineRange ValueRange { get; }
    public abstract virtual PaddingInfo get_Padding();
    public abstract virtual SparklineViewBase get_View();
    public abstract virtual SparklineRange get_ValueRange();
}
public class DevExpress.Sparkline.Core.LineSparklineMapping : SparklineMappingBase {
    protected internal LineSparklineMapping(Rectangle bounds);
}
public class DevExpress.Sparkline.Core.LineSparklinePainter : BaseSparklinePainter {
    private static int GDIErrorCriteria;
    private LineSparklineView LineView { get; }
    protected bool EnableAntialiasing { get; }
    public SparklineViewType SparklineType { get; }
    private static bool IsPointVisible(Rectangle bounds, PointF point);
    private static void AddIntersection(List`1<PointF> segment, CohenSutherlandLineClipAlgorithm algorithm, PointF point1, PointF point2);
    private LineSparklineView get_LineView();
    protected virtual bool get_EnableAntialiasing();
    public virtual SparklineViewType get_SparklineType();
    private void DrawMarkers(ISparklineRenderer renderer, List`1<PointF> points, List`1<int> pointsIndexes);
    private void DrawLineSegment(ISparklineRenderer renderer, Color color, List`1<PointF> segment);
    protected virtual PaddingInfo GetMarkersPadding();
    protected virtual void DrawWholeGeometry(ISparklineRenderer renderer, Color color, List`1<PointF> points);
    public virtual List`1<SparklineMappedPointInfo> GetMappedPoints();
    protected virtual void DrawInternal(ISparklineRenderer renderer);
    protected internal float GetMarkerSize(PointPresentationType pointType);
    protected internal virtual Color GetPointColor(PointPresentationType pointType);
}
public enum DevExpress.Sparkline.Core.PointPresentationType : Enum {
    public int value__;
    public static PointPresentationType HighPoint;
    public static PointPresentationType LowPoint;
    public static PointPresentationType StartPoint;
    public static PointPresentationType EndPoint;
    public static PointPresentationType NegativePoint;
    public static PointPresentationType SimplePoint;
}
public class DevExpress.Sparkline.Core.RuntimeObjectAttribute : Attribute {
}
public static class DevExpress.Sparkline.Core.SparklineAppearanceHelper : object {
    public static void SetSparklineAppearanceProvider(SparklineViewBase view, ISparklineAppearanceProvider appearanceProvider);
    public static ISparklineAppearanceProvider GetSparklineAppearanceProvider(SparklineViewBase view);
}
public class DevExpress.Sparkline.Core.SparklineDataProvider : object {
    private ISparklineExtendedData data;
    private List`1<SparklinePoint> sortedPoints;
    private SparklineRangeData filterRange;
    private bool allowPaddingCorrection;
    private SparklineIndexRange filteredPointRange;
    private SparklineRangeData dataValueRange;
    private SparklineRangeData originalValueRange;
    private SparklineRangeData dataArgumentRange;
    public ISparklineExtendedData Data { get; }
    public List`1<SparklinePoint> SortedPoints { get; }
    public SparklineIndexRange FilteredPointRange { get; }
    public SparklineRangeData DataArgumentRange { get; }
    public SparklineRangeData FilterRange { get; }
    public SparklineRangeData OriginalValueRange { get; }
    public SparklineRangeData DataValueRange { get; public set; }
    public bool AllowPaddingCorrection { get; public set; }
    public SparklineDataProvider(ISparklineExtendedData data);
    public SparklineDataProvider(ISparklineExtendedData data, SparklineRangeData filterRange);
    public ISparklineExtendedData get_Data();
    public List`1<SparklinePoint> get_SortedPoints();
    public SparklineIndexRange get_FilteredPointRange();
    public SparklineRangeData get_DataArgumentRange();
    public SparklineRangeData get_FilterRange();
    public SparklineRangeData get_OriginalValueRange();
    public SparklineRangeData get_DataValueRange();
    public void set_DataValueRange(SparklineRangeData value);
    public bool get_AllowPaddingCorrection();
    public void set_AllowPaddingCorrection(bool value);
    private void FindValueRange();
    private void FilterPointsWithRange();
    private List`1<SparklinePoint> FilterValidPoints(IList`1<SparklinePoint> points);
}
public class DevExpress.Sparkline.Core.SparklineDataWrapper : object {
    private List`1<SparklinePoint> points;
    private SparklineRangeData range;
    public IList`1<SparklinePoint> Points { get; }
    public SparklineRangeData Range { get; public set; }
    public SparklineDataWrapper(ISparklineData data);
    public SparklineDataWrapper(IList`1<double> values);
    public sealed virtual IList`1<SparklinePoint> get_Points();
    public SparklineRangeData get_Range();
    public void set_Range(SparklineRangeData value);
}
public static class DevExpress.Sparkline.Core.SparklineDateTimeUtils : object {
    private static int HoursInDay;
    private static int MinutesInDay;
    private static int SecondsInDay;
    private static int MillisecondsInDay;
    private static DayOfWeek FirstDayOfWeek { get; }
    private static int GetActualDayOfWeek(DateTime dateTime);
    private static DayOfWeek get_FirstDayOfWeek();
    private static double TotalFloorMonths(DateTime dateTime);
    private static DateTime AddMonths(DateTimeMeasureUnit measureUnit, DateTime date, double range, double factor);
    public static DateTime Floor(DateTime dateTime, DateTimeMeasureUnit measureUnit);
    public static TimeSpan Floor(TimeSpan timeSpan, TimeSpanMeasureUnit measureUnit);
    public static DateTime Add(DateTime dateTime, DateTimeMeasureUnit measureUnit, double range);
    public static TimeSpan Add(TimeSpan value, TimeSpanMeasureUnit measureUnit, int range);
    public static double Difference(DateTime fromDate, DateTime toDate, DateTimeMeasureUnit measureUnit);
    public static double Difference(TimeSpan from, TimeSpan to, TimeSpanMeasureUnit measureUnit);
    public static DateTime Round(DateTime dateTime, DateTimeMeasureUnit measureUnit);
    public static TimeSpan Round(TimeSpan timeSpan, TimeSpanMeasureUnit measureUnit);
    public static double SizeOfMeasureUnit(TimeSpanMeasureUnit measureUnit);
    public static double SizeOfMeasureUnit(DateTimeMeasureUnit measureUnit);
}
public class DevExpress.Sparkline.Core.SparklineDrawingCache : object {
    private Dictionary`2<Color, SolidBrush> brushes;
    private Dictionary`2<Color, Pen> pens;
    private bool disposed;
    private Color ToUnknownColor(Color color);
    protected virtual void Dispose(bool disposing);
    public SolidBrush GetSolidBrush(Color color);
    public Pen GetPen(Color color);
    public sealed virtual void Dispose();
}
public class DevExpress.Sparkline.Core.SparklineIndexRange : object {
    private int min;
    private int max;
    public int Min { get; public set; }
    public int Max { get; public set; }
    public bool IsValid { get; }
    internal SparklineIndexRange(int start, int end);
    public int get_Min();
    public void set_Min(int value);
    public int get_Max();
    public void set_Max(int value);
    public bool get_IsValid();
    public virtual string ToString();
}
public class DevExpress.Sparkline.Core.SparklineInteractionRanges : object {
    private SparklineRangeData dataArgumentRange;
    private SparklineRangeData dataValueRange;
    private SparklineRangeData visualArgumentRange;
    private SparklineRangeData customDataArgumentRange;
    private double minPointDistance;
    public SparklineRangeData ActualDataArgumentRange { get; }
    public SparklineRangeData DataArgumentRange { get; }
    public SparklineRangeData DataValueRange { get; }
    public SparklineRangeData VisualArgumentRange { get; }
    public SparklineRangeData CustomDataArgumentRange { get; }
    public double MinPointDistance { get; }
    public SparklineRangeData get_ActualDataArgumentRange();
    public SparklineRangeData get_DataArgumentRange();
    public SparklineRangeData get_DataValueRange();
    public SparklineRangeData get_VisualArgumentRange();
    public SparklineRangeData get_CustomDataArgumentRange();
    public double get_MinPointDistance();
    internal void Invalidate();
    internal void UpdateMinPointDistance(double value);
}
public class DevExpress.Sparkline.Core.SparklineMappedPointInfo : object {
    [CompilerGeneratedAttribute]
private PointF <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public PointF Point { get; public set; }
    public int Index { get; public set; }
    [CompilerGeneratedAttribute]
public PointF get_Point();
    [CompilerGeneratedAttribute]
public void set_Point(PointF value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
}
public abstract class DevExpress.Sparkline.Core.SparklineMappingBase : object {
    private Rectangle bounds;
    private double scaleX;
    private double yZeroValue;
    private double minPointsDistancePx;
    private int screenYZeroValue;
    private SparklineRangeData argumentRange;
    private SparklineRangeData valueRange;
    private SparklineRangeData originalArgumentRange;
    private SparklineRangeData originalValueRange;
    private Matrix normalTransform;
    public int ScreenYZeroValue { get; }
    public double MinPointsDistancePx { get; }
    public double ScaleX { get; }
    public Rectangle Bounds { get; }
    public SparklineRangeData ValueRange { get; }
    protected SparklineMappingBase(Rectangle bounds);
    private static SparklineMappingBase Create(SparklineViewType viewType, Rectangle bounds);
    public static SparklineMappingBase Create(SparklineViewType viewType, Rectangle bounds, SparklineDataProvider dataProvider);
    public static SparklineMappingBase Create(SparklineViewType viewType, Rectangle bounds, SparklineDataProvider dataProvider, SparklineInteractionRanges ranges, Matrix normalTransform);
    public int get_ScreenYZeroValue();
    public double get_MinPointsDistancePx();
    public double get_ScaleX();
    public Rectangle get_Bounds();
    public SparklineRangeData get_ValueRange();
    private void Initialize(SparklineDataProvider dataProvider);
    private void Initialize(SparklineDataProvider dataProvider, SparklineInteractionRanges ranges, Matrix normalTransform);
    private double GetMinInternalArgumentDistance(IList`1<SparklinePoint> points, SparklineRangeData argumentRange);
    private double CalculateScaleX();
    protected virtual SparklineRangeData CorrectArgumentRange(double minPointDistance, SparklineRangeData range);
    protected virtual SparklineRangeData CorrectValueRange(SparklineRangeData range);
    protected virtual double CorrectValue(double value);
    protected virtual double CalculateZeroValue();
    public bool IsMinValuePoint(double value);
    public bool IsMaxValuePoint(double value);
    public bool IsStartPoint(double argument);
    public bool IsEndPoint(double argument);
    public int MapYValueToScreen(double value);
    public int MapXValueToScreen(double value);
    public Point MapPoint(double argument, double value);
    public PointF MapPointF(double argument, double value);
}
public static class DevExpress.Sparkline.Core.SparklineMathUtils : object {
    public static bool IsValidDouble(double value);
    public static int Round(double value);
    public static bool AreDoublesEqual(double a, double b);
}
public class DevExpress.Sparkline.Core.SparklinePaintersCache : object {
    private Dictionary`2<SparklineViewType, BaseSparklinePainter> painters;
    public BaseSparklinePainter GetPainter(SparklineViewBase view);
}
public class DevExpress.Sparkline.Core.SparklinePointArgumentAndIndexComparer : object {
    public sealed virtual int Compare(SparklinePoint x, SparklinePoint y);
}
public class DevExpress.Sparkline.Core.SparklinePointArgumentComparer : object {
    public sealed virtual int Compare(SparklinePoint x, SparklinePoint y);
}
public class DevExpress.Sparkline.Core.SparklineRangeData : object {
    private double min;
    private double max;
    public double Min { get; }
    public double Max { get; }
    public double Delta { get; }
    public bool IsValid { get; }
    public SparklineRangeData(double min, double max);
    public double get_Min();
    public double get_Max();
    public double get_Delta();
    public bool get_IsValid();
    internal void Extend(double value);
    internal void Invalidate();
    public void Set(double min, double max);
    public bool InRange(double value);
    public virtual string ToString();
}
public enum DevExpress.Sparkline.Core.SparklineScaleType : Enum {
    public int value__;
    public static SparklineScaleType Numeric;
    public static SparklineScaleType DateTime;
    public static SparklineScaleType TimeSpan;
    public static SparklineScaleType Unknown;
}
public class DevExpress.Sparkline.Core.SparklineViewPainterFactory : object {
    [CompilerGeneratedAttribute]
private BaseSparklinePainter <Result>k__BackingField;
    private BaseSparklinePainter Result { get; private set; }
    [CompilerGeneratedAttribute]
private BaseSparklinePainter get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(BaseSparklinePainter value);
    public static BaseSparklinePainter Create(SparklineViewBase view);
    public sealed virtual void Visit(LineSparklineView view);
    public sealed virtual void Visit(AreaSparklineView view);
    public sealed virtual void Visit(BarSparklineView view);
    public sealed virtual void Visit(WinLossSparklineView view);
}
public enum DevExpress.Sparkline.Core.TimeSpanMeasureUnit : Enum {
    public int value__;
    public static TimeSpanMeasureUnit Millisecond;
    public static TimeSpanMeasureUnit Second;
    public static TimeSpanMeasureUnit Minute;
    public static TimeSpanMeasureUnit Hour;
    public static TimeSpanMeasureUnit Day;
}
public class DevExpress.Sparkline.Core.WinLossSparklineMapping : BarSparklineMapping {
    protected internal WinLossSparklineMapping(Rectangle bounds);
    protected virtual double CalculateZeroValue();
    protected virtual SparklineRangeData CorrectValueRange(SparklineRangeData range);
    protected virtual double CorrectValue(double value);
}
public class DevExpress.Sparkline.Core.WinLossSparklinePainter : BarSparklinePainter {
    public SparklineViewType SparklineType { get; }
    public virtual SparklineViewType get_SparklineType();
}
public interface DevExpress.Sparkline.ISparklineViewVisitor {
    public abstract virtual void Visit(LineSparklineView view);
    public abstract virtual void Visit(AreaSparklineView view);
    public abstract virtual void Visit(BarSparklineView view);
    public abstract virtual void Visit(WinLossSparklineView view);
}
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.LineSparklineView")]
public class DevExpress.Sparkline.LineSparklineView : SparklineViewBase {
    private static bool defaultShowMarkers;
    private static bool defaultEnableAntialiasing;
    private static int defaultLineWidth;
    private static int defaultMarkerSize;
    private static int defaultMaxPointMarkerSize;
    private static int defaultMinPointMarkerSize;
    private static int defaultStartPointMarkerSize;
    private static int defaultEndPointMarkerSize;
    private static int defaultNegativePointMarkerSize;
    private bool showMarkers;
    private bool enableAntialiasing;
    private float scaleFactor;
    private int lineWidth;
    private int markerSize;
    private int maxPointMarkerSize;
    private int minPointMarkerSize;
    private int startPointMarkerSize;
    private int endPointMarkerSize;
    private int negativePointMarkerSize;
    private Color markerColor;
    protected bool DefaultHighlightNegativePoints { get; }
    [BrowsableAttribute("False")]
public Color ActualMarkerColor { get; }
    [BrowsableAttribute("False")]
public int ActualMarkerSize { get; }
    [BrowsableAttribute("False")]
public int ActualMinPointMarkerSize { get; }
    [BrowsableAttribute("False")]
public int ActualEndPointMarkerSize { get; }
    [BrowsableAttribute("False")]
public int ActualMaxPointMarkerSize { get; }
    [BrowsableAttribute("False")]
public int ActualNegativePointMarkerSize { get; }
    [BrowsableAttribute("False")]
public int ActualStartPointMarkerSize { get; }
    [BrowsableAttribute("False")]
public int ActualLineWidth { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public float ScaleFactor { get; public set; }
    [DescriptionAttribute("Specifies the width of a line in a LineSparklineView.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.LineWidth")]
public int LineWidth { get; public set; }
    [DescriptionAttribute("Gets or sets a value specifying the visibility of point markers on a sparkline.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.ShowMarkers")]
[TypeConverterAttribute("DevExpress.Utils.Design.BooleanTypeConverter")]
public bool ShowMarkers { get; public set; }
    [DescriptionAttribute("Gets or sets the size of markers for data points in a line sparkline.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.MarkerSize")]
public int MarkerSize { get; public set; }
    [DescriptionAttribute("Gets or sets the marker size of a data point that has the maximum value among all data points.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.MaxPointMarkerSize")]
public int MaxPointMarkerSize { get; public set; }
    [DescriptionAttribute("Gets or sets the marker size of a data point that has the minimum value among all data points.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.MinPointMarkerSize")]
public int MinPointMarkerSize { get; public set; }
    [DescriptionAttribute("Gets or sets the size of a start point’s marker.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.StartPointMarkerSize")]
public int StartPointMarkerSize { get; public set; }
    [DescriptionAttribute("Gets or sets the size of an end point’s marker.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.EndPointMarkerSize")]
public int EndPointMarkerSize { get; public set; }
    [DescriptionAttribute("Gets or sets the marker size of all data points that have negative values (less than 0).")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.NegativePointMarkerSize")]
public int NegativePointMarkerSize { get; public set; }
    [DescriptionAttribute("Gets or sets the color to draw line markers.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.MarkerColor")]
public Color MarkerColor { get; public set; }
    [DescriptionAttribute("Gets or sets whether anti-aliasing (smoothing) is applied to the line view.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.LineSparklineView.EnableAntialiasing")]
[TypeConverterAttribute("DevExpress.Utils.Design.BooleanTypeConverter")]
public bool EnableAntialiasing { get; public set; }
    [DescriptionAttribute("Gets the type of the sparkline view.")]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.LineSparklineView.Type")]
public SparklineViewType Type { get; }
    private Color DevExpress.Data.Export.ISparklineInfo.ColorMarker { get; }
    private double DevExpress.Data.Export.ISparklineInfo.LineWeight { get; }
    private bool DevExpress.Data.Export.ISparklineInfo.DisplayMarkers { get; }
    private ExportSparklineType DevExpress.Data.Export.ISparklineInfo.SparklineType { get; }
    protected virtual bool get_DefaultHighlightNegativePoints();
    public Color get_ActualMarkerColor();
    public int get_ActualMarkerSize();
    public int get_ActualMinPointMarkerSize();
    public int get_ActualEndPointMarkerSize();
    public int get_ActualMaxPointMarkerSize();
    public int get_ActualNegativePointMarkerSize();
    public int get_ActualStartPointMarkerSize();
    public int get_ActualLineWidth();
    public float get_ScaleFactor();
    public void set_ScaleFactor(float value);
    public int get_LineWidth();
    public void set_LineWidth(int value);
    public bool get_ShowMarkers();
    public void set_ShowMarkers(bool value);
    public sealed virtual int get_MarkerSize();
    public void set_MarkerSize(int value);
    public sealed virtual int get_MaxPointMarkerSize();
    public void set_MaxPointMarkerSize(int value);
    public sealed virtual int get_MinPointMarkerSize();
    public void set_MinPointMarkerSize(int value);
    public sealed virtual int get_StartPointMarkerSize();
    public void set_StartPointMarkerSize(int value);
    public sealed virtual int get_EndPointMarkerSize();
    public void set_EndPointMarkerSize(int value);
    public sealed virtual int get_NegativePointMarkerSize();
    public void set_NegativePointMarkerSize(int value);
    public Color get_MarkerColor();
    public void set_MarkerColor(Color value);
    public sealed virtual bool get_EnableAntialiasing();
    public void set_EnableAntialiasing(bool value);
    public virtual SparklineViewType get_Type();
    private bool ShouldSerializeLineWidth();
    private bool ShouldSerializeShowMarkers();
    private bool ShouldSerializeMarkerSize();
    private bool ShouldSerializeMaxPointMarkerSize();
    private bool ShouldSerializeMinPointMarkerSize();
    private bool ShouldSerializeStartPointMarkerSize();
    private bool ShouldSerializeEndPointMarkerSize();
    private bool ShouldSerializeNegativePointMarkerSize();
    private bool ShouldSerializeMarkerColor();
    private bool ShouldSerializeEnableAntialiasing();
    protected virtual bool XtraShouldSerialize(string propertyName);
    private void ResetLineWidth();
    private void ResetShowMarkers();
    private void ResetMarkerSize();
    private void ResetMaxPointMarkerSize();
    private void ResetMinPointMarkerSize();
    private void ResetStartPointMarkerSize();
    private void ResetEndPointMarkerSize();
    private void ResetNegativePointMarkerSize();
    private void ResetMarkerColor();
    private void ResetEnableAntialiasing();
    private sealed virtual override Color DevExpress.Data.Export.ISparklineInfo.get_ColorMarker();
    private sealed virtual override double DevExpress.Data.Export.ISparklineInfo.get_LineWeight();
    private sealed virtual override bool DevExpress.Data.Export.ISparklineInfo.get_DisplayMarkers();
    private sealed virtual override ExportSparklineType DevExpress.Data.Export.ISparklineInfo.get_SparklineType();
    protected virtual string GetViewName();
    public void SetSizeForAllMarkers(int markerSize);
    public virtual void Assign(SparklineViewBase view);
    public virtual void Visit(ISparklineViewVisitor visitor);
}
public static class DevExpress.Sparkline.Localization.SparklineLocalizationHelper : object {
    public static string GetSparklineViewName(SparklineViewType type);
}
public class DevExpress.Sparkline.Localization.SparklineLocalizer : XtraLocalizer`1<SparklineStringId> {
    public static XtraLocalizer`1<SparklineStringId> Active { get; public set; }
    private static SparklineLocalizer();
    public static XtraLocalizer`1<SparklineStringId> get_Active();
    public static void set_Active(XtraLocalizer`1<SparklineStringId> value);
    public static XtraLocalizer`1<SparklineStringId> CreateDefaultLocalizer();
    public static string GetString(SparklineStringId id);
    protected virtual void PopulateStringTable();
    public virtual XtraLocalizer`1<SparklineStringId> CreateResXLocalizer();
}
public class DevExpress.Sparkline.Localization.SparklineResLocalizer : XtraResXLocalizer`1<SparklineStringId> {
    protected virtual ResourceManager CreateResourceManagerCore();
}
public enum DevExpress.Sparkline.Localization.SparklineStringId : Enum {
    public int value__;
    public static SparklineStringId viewLine;
    public static SparklineStringId viewArea;
    public static SparklineStringId viewBar;
    public static SparklineStringId viewWinLoss;
}
internal class DevExpress.Sparkline.ResFinder : object {
}
[RuntimeObjectAttribute]
public class DevExpress.Sparkline.SparklinePoint : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    internal int Index { get; internal set; }
    public double Argument { get; public set; }
    public double Value { get; public set; }
    public SparklinePoint(double argument, double value);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [CompilerGeneratedAttribute]
public double get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(double value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    public virtual string ToString();
}
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.SparklineRange")]
public class DevExpress.Sparkline.SparklineRange : object {
    private static double DefaultLimit1;
    private static double DefaultLimit2;
    private static bool DefaultAuto;
    private double limit1;
    private double limit2;
    private bool isAuto;
    [CompilerGeneratedAttribute]
private EventHandler PropertiesChanged;
    internal double Min { get; }
    internal double Max { get; }
    [DescriptionAttribute("Gets or sets a value specifying the first limit of the range.")]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.SparklineRange.Limit1")]
[DefaultValueAttribute("0")]
[XtraSerializableProperty]
public double Limit1 { get; public set; }
    [DescriptionAttribute("Gets or sets a value specifying the second limit of the range.")]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.SparklineRange.Limit2")]
[DefaultValueAttribute("1")]
[XtraSerializableProperty]
public double Limit2 { get; public set; }
    [DescriptionAttribute("Gets or sets a value indicating whether or not range limits should be calculated automatically.")]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.SparklineRange.IsAuto")]
[TypeConverterAttribute("DevExpress.Utils.Design.BooleanTypeConverter")]
[DefaultValueAttribute("True")]
[XtraSerializableProperty]
public bool IsAuto { get; public set; }
    public SparklineRange(double min, double max);
    [CompilerGeneratedAttribute]
public void add_PropertiesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertiesChanged(EventHandler value);
    internal double get_Min();
    internal double get_Max();
    public double get_Limit1();
    public void set_Limit1(double value);
    public double get_Limit2();
    public void set_Limit2(double value);
    public bool get_IsAuto();
    public void set_IsAuto(bool value);
    private void OnPropertiesChanged();
    public virtual string ToString();
}
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.SparklineViewBase")]
public abstract class DevExpress.Sparkline.SparklineViewBase : object {
    private static bool defaultHighlightMaxPoint;
    private static bool defaultHighlightMinPoint;
    private static bool defaultHighlightStartPoint;
    private static bool defaultHighlightEndPoint;
    private bool highlightMaxPoint;
    private bool highlightMinPoint;
    private bool highlightStartPoint;
    private bool highlightEndPoint;
    private bool highlightNegativePoints;
    private Color color;
    private Color maxPointColor;
    private Color minPointColor;
    private Color startPointColor;
    private Color endPointColor;
    private Color negativePointColor;
    private ISparklineAppearanceProvider appearanceProvider;
    [CompilerGeneratedAttribute]
private EventHandler PropertiesChanged;
    protected bool DefaultHighlightNegativePoints { get; }
    protected internal ISparklineAppearanceProvider AppearanceProvider { get; protected internal set; }
    [BrowsableAttribute("False")]
public Color ActualColor { get; }
    [BrowsableAttribute("False")]
public Color ActualMaxPointColor { get; }
    [BrowsableAttribute("False")]
public Color ActualMinPointColor { get; }
    [BrowsableAttribute("False")]
public Color ActualStartPointColor { get; }
    [BrowsableAttribute("False")]
public Color ActualEndPointColor { get; }
    [BrowsableAttribute("False")]
public Color ActualNegativePointColor { get; }
    [XtraSerializableProperty]
[BrowsableAttribute("False")]
public SparklineViewType Type { get; }
    [DescriptionAttribute("")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.HighlightNegativePoints")]
[TypeConverterAttribute("DevExpress.Utils.Design.BooleanTypeConverter")]
public bool HighlightNegativePoints { get; public set; }
    [DescriptionAttribute("Gets or sets a value specifying whether or not to highlight a sparkline point that has the highest value among all points.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.HighlightMaxPoint")]
[TypeConverterAttribute("DevExpress.Utils.Design.BooleanTypeConverter")]
public bool HighlightMaxPoint { get; public set; }
    [DescriptionAttribute("Gets or sets a value specifying whether or not to highlight a sparkline point that has the lowest value among all points.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.HighlightMinPoint")]
[TypeConverterAttribute("DevExpress.Utils.Design.BooleanTypeConverter")]
public bool HighlightMinPoint { get; public set; }
    [DescriptionAttribute("Gets or sets a value specifying whether or not to highlight the start point of a sparkline.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.HighlightStartPoint")]
[TypeConverterAttribute("DevExpress.Utils.Design.BooleanTypeConverter")]
public bool HighlightStartPoint { get; public set; }
    [DescriptionAttribute("Gets or sets a value specifying whether or not to highlight the end point of a sparkline.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.HighlightEndPoint")]
[TypeConverterAttribute("DevExpress.Utils.Design.BooleanTypeConverter")]
public bool HighlightEndPoint { get; public set; }
    [DescriptionAttribute("Gets or sets the color to draw a sparkline.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.Color")]
public Color Color { get; public set; }
    [DescriptionAttribute("Gets or sets the color to draw a sparkline point that has the highest value among all data points.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.MaxPointColor")]
public Color MaxPointColor { get; public set; }
    [DescriptionAttribute("Gets or sets the color to draw a sparkline point that has the lowest value among all data points.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.MinPointColor")]
public Color MinPointColor { get; public set; }
    [DescriptionAttribute("Gets or sets the color to draw the start point of a sparkline.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.StartPointColor")]
public Color StartPointColor { get; public set; }
    [DescriptionAttribute("Gets or sets the color to draw the end point of a sparkline.")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.EndPointColor")]
public Color EndPointColor { get; public set; }
    [DescriptionAttribute("Gets or sets the color to draw sparkline points that have negative values (less than 0).")]
[XtraSerializableProperty]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "PropertyNamesRes", "DevExpress.Sparkline.SparklineViewBase.NegativePointColor")]
public Color NegativePointColor { get; public set; }
    private Color DevExpress.Data.Export.ISparklineInfo.ColorSeries { get; }
    private Color DevExpress.Data.Export.ISparklineInfo.ColorNegative { get; }
    private Color DevExpress.Data.Export.ISparklineInfo.ColorMarker { get; }
    private double DevExpress.Data.Export.ISparklineInfo.LineWeight { get; }
    private bool DevExpress.Data.Export.ISparklineInfo.DisplayMarkers { get; }
    private ExportSparklineType DevExpress.Data.Export.ISparklineInfo.SparklineType { get; }
    private Color DevExpress.Data.Export.ISparklineInfo.ColorFirst { get; }
    private Color DevExpress.Data.Export.ISparklineInfo.ColorLast { get; }
    private Color DevExpress.Data.Export.ISparklineInfo.ColorHigh { get; }
    private Color DevExpress.Data.Export.ISparklineInfo.ColorLow { get; }
    private bool DevExpress.Data.Export.ISparklineInfo.HighlightNegative { get; }
    private bool DevExpress.Data.Export.ISparklineInfo.HighlightFirst { get; }
    private bool DevExpress.Data.Export.ISparklineInfo.HighlightLast { get; }
    private bool DevExpress.Data.Export.ISparklineInfo.HighlightHighest { get; }
    private bool DevExpress.Data.Export.ISparklineInfo.HighlightLowest { get; }
    private bool DevExpress.Data.Export.ISparklineInfo.SpecificSparklineType { get; }
    public static SparklineViewBase CreateView(SparklineViewType viewType);
    [CompilerGeneratedAttribute]
public void add_PropertiesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertiesChanged(EventHandler value);
    protected abstract virtual bool get_DefaultHighlightNegativePoints();
    protected internal ISparklineAppearanceProvider get_AppearanceProvider();
    protected internal void set_AppearanceProvider(ISparklineAppearanceProvider value);
    public Color get_ActualColor();
    public Color get_ActualMaxPointColor();
    public Color get_ActualMinPointColor();
    public Color get_ActualStartPointColor();
    public Color get_ActualEndPointColor();
    public Color get_ActualNegativePointColor();
    public abstract virtual SparklineViewType get_Type();
    public bool get_HighlightNegativePoints();
    public void set_HighlightNegativePoints(bool value);
    public bool get_HighlightMaxPoint();
    public void set_HighlightMaxPoint(bool value);
    public bool get_HighlightMinPoint();
    public void set_HighlightMinPoint(bool value);
    public bool get_HighlightStartPoint();
    public void set_HighlightStartPoint(bool value);
    public bool get_HighlightEndPoint();
    public void set_HighlightEndPoint(bool value);
    public Color get_Color();
    public void set_Color(Color value);
    public Color get_MaxPointColor();
    public void set_MaxPointColor(Color value);
    public Color get_MinPointColor();
    public void set_MinPointColor(Color value);
    public Color get_StartPointColor();
    public void set_StartPointColor(Color value);
    public Color get_EndPointColor();
    public void set_EndPointColor(Color value);
    public Color get_NegativePointColor();
    public void set_NegativePointColor(Color value);
    private bool ShouldSerializeHighlightMaxPoint();
    private bool ShouldSerializeHighlightMinPoint();
    private bool ShouldSerializeHighlightStartPoint();
    private bool ShouldSerializeHighlightEndPoint();
    private bool ShouldSerializeColor();
    private bool ShouldSerializeMaxPointColor();
    private bool ShouldSerializeMinPointColor();
    private bool ShouldSerializeStartPointColor();
    private bool ShouldSerializeEndPointColor();
    private bool ShouldSerializeNegativePointColor();
    private bool ShouldSerializeHighlightNegativePoints();
    protected virtual bool XtraShouldSerialize(string propertyName);
    private void ResetHighlightMaxPoint();
    private void ResetHighlightMinPoint();
    private void ResetHighlightStartPoint();
    private void ResetHighlightEndPoint();
    private void ResetColor();
    private void ResetMaxPointColor();
    private void ResetMinPointColor();
    private void ResetStartPointColor();
    private void ResetEndPointColor();
    private void ResetNegativePointColor();
    private void ResetHighlightNegativePoints();
    private sealed virtual override bool DevExpress.Utils.Serializing.Helpers.IXtraSupportShouldSerialize.ShouldSerialize(string propertyName);
    private sealed virtual override Color DevExpress.Data.Export.ISparklineInfo.get_ColorSeries();
    private sealed virtual override Color DevExpress.Data.Export.ISparklineInfo.get_ColorNegative();
    private sealed virtual override Color DevExpress.Data.Export.ISparklineInfo.get_ColorMarker();
    private sealed virtual override double DevExpress.Data.Export.ISparklineInfo.get_LineWeight();
    private sealed virtual override bool DevExpress.Data.Export.ISparklineInfo.get_DisplayMarkers();
    private sealed virtual override ExportSparklineType DevExpress.Data.Export.ISparklineInfo.get_SparklineType();
    private sealed virtual override Color DevExpress.Data.Export.ISparklineInfo.get_ColorFirst();
    private sealed virtual override Color DevExpress.Data.Export.ISparklineInfo.get_ColorLast();
    private sealed virtual override Color DevExpress.Data.Export.ISparklineInfo.get_ColorHigh();
    private sealed virtual override Color DevExpress.Data.Export.ISparklineInfo.get_ColorLow();
    private sealed virtual override bool DevExpress.Data.Export.ISparklineInfo.get_HighlightNegative();
    private sealed virtual override bool DevExpress.Data.Export.ISparklineInfo.get_HighlightFirst();
    private sealed virtual override bool DevExpress.Data.Export.ISparklineInfo.get_HighlightLast();
    private sealed virtual override bool DevExpress.Data.Export.ISparklineInfo.get_HighlightHighest();
    private sealed virtual override bool DevExpress.Data.Export.ISparklineInfo.get_HighlightLowest();
    private sealed virtual override bool DevExpress.Data.Export.ISparklineInfo.get_SpecificSparklineType();
    protected void OnPropertiesChanged();
    protected abstract virtual string GetViewName();
    protected internal virtual BaseSparklinePainter CreatePainter();
    public virtual void Assign(SparklineViewBase view);
    public virtual string ToString();
    public abstract virtual void Visit(ISparklineViewVisitor visitor);
}
[TypeConverterAttribute("DevExpress.Utils.Design.EnumTypeConverter")]
[ResourceFinderAttribute("DevExpress.Data.ResFinder", "PropertyNamesRes")]
public enum DevExpress.Sparkline.SparklineViewType : Enum {
    public int value__;
    public static SparklineViewType Line;
    public static SparklineViewType Area;
    public static SparklineViewType Bar;
    public static SparklineViewType WinLoss;
}
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.WinLossSparklineView")]
public class DevExpress.Sparkline.WinLossSparklineView : BarSparklineViewBase {
    protected bool DefaultHighlightNegativePoints { get; }
    [DescriptionAttribute("Gets the type of the sparkline view.")]
[DXDisplayNameAttribute("DevExpress.Sparkline.ResFinder", "DevExpress.Sparkline.WinLossSparklineView.Type")]
public SparklineViewType Type { get; }
    private ExportSparklineType DevExpress.Data.Export.ISparklineInfo.SparklineType { get; }
    protected virtual bool get_DefaultHighlightNegativePoints();
    public virtual SparklineViewType get_Type();
    protected virtual string GetViewName();
    public virtual void Visit(ISparklineViewVisitor visitor);
    private sealed virtual override ExportSparklineType DevExpress.Data.Export.ISparklineInfo.get_SparklineType();
}
