public class Microsoft.Rest.BasicAuthenticationCredentials : ServiceClientCredentials {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Password>k__BackingField;
    public string UserName { get; public set; }
    public string Password { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    public virtual Task ProcessHttpRequestAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class Microsoft.Rest.CertificateCredentials : ServiceClientCredentials {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private X509Certificate2 <ManagementCertificate>k__BackingField;
    public X509Certificate2 ManagementCertificate { get; private set; }
    public CertificateCredentials(X509Certificate2 managementCertificate);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_ManagementCertificate();
    [CompilerGeneratedAttribute]
private void set_ManagementCertificate(X509Certificate2 value);
    public virtual void InitializeServiceClient(ServiceClient`1<T> client);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Rest.ClientRuntime.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentCannotBeGreaterThanBaseline { get; }
    internal static string ArgumentCannotBeNegative { get; }
    internal static string DefaultHttpOperationExceptionMessage { get; }
    internal static string DefaultRetryStrategyMappingNotFound { get; }
    internal static string DefaultRetryStrategyNotFound { get; }
    internal static string ExceptionRetryHandlerMissing { get; }
    internal static string ExceptionRetryManagerAlreadySet { get; }
    internal static string ExceptionRetryManagerNotSet { get; }
    internal static string ITransientErrorDetectionStrategyNotImplemented { get; }
    internal static string ResponseStatusCodeError { get; }
    internal static string RetryStrategyNotFound { get; }
    internal static string StringCannotBeEmpty { get; }
    internal static string TaskCannotBeNull { get; }
    internal static string TaskMustBeScheduled { get; }
    internal static string TokenProviderCannotBeNull { get; }
    internal static string ValidationCannotBeNull { get; }
    internal static string ValidationEnum { get; }
    internal static string ValidationExclusiveMaximum { get; }
    internal static string ValidationExclusiveMinimum { get; }
    internal static string ValidationMaximum { get; }
    internal static string ValidationMaximumItems { get; }
    internal static string ValidationMaximumLength { get; }
    internal static string ValidationMinimum { get; }
    internal static string ValidationMinimumItems { get; }
    internal static string ValidationMinimumLength { get; }
    internal static string ValidationMultipleOf { get; }
    internal static string ValidationPattern { get; }
    internal static string ValidationUniqueItems { get; }
    internal static string WebRequestHandlerNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentCannotBeGreaterThanBaseline();
    internal static string get_ArgumentCannotBeNegative();
    internal static string get_DefaultHttpOperationExceptionMessage();
    internal static string get_DefaultRetryStrategyMappingNotFound();
    internal static string get_DefaultRetryStrategyNotFound();
    internal static string get_ExceptionRetryHandlerMissing();
    internal static string get_ExceptionRetryManagerAlreadySet();
    internal static string get_ExceptionRetryManagerNotSet();
    internal static string get_ITransientErrorDetectionStrategyNotImplemented();
    internal static string get_ResponseStatusCodeError();
    internal static string get_RetryStrategyNotFound();
    internal static string get_StringCannotBeEmpty();
    internal static string get_TaskCannotBeNull();
    internal static string get_TaskMustBeScheduled();
    internal static string get_TokenProviderCannotBeNull();
    internal static string get_ValidationCannotBeNull();
    internal static string get_ValidationEnum();
    internal static string get_ValidationExclusiveMaximum();
    internal static string get_ValidationExclusiveMinimum();
    internal static string get_ValidationMaximum();
    internal static string get_ValidationMaximumItems();
    internal static string get_ValidationMaximumLength();
    internal static string get_ValidationMinimum();
    internal static string get_ValidationMinimumItems();
    internal static string get_ValidationMinimumLength();
    internal static string get_ValidationMultipleOf();
    internal static string get_ValidationPattern();
    internal static string get_ValidationUniqueItems();
    internal static string get_WebRequestHandlerNotFound();
}
[ExtensionAttribute]
public static class Microsoft.Rest.HttpExtensions : object {
    [ExtensionAttribute]
public static string AsString(HttpContent content);
    [ExtensionAttribute]
public static HttpHeaders GetContentHeaders(HttpRequestMessage request);
    [ExtensionAttribute]
public static HttpHeaders GetContentHeaders(HttpResponseMessage response);
    [ExtensionAttribute]
public static string AsFormattedString(HttpRequestMessage httpRequest);
    [ExtensionAttribute]
public static string AsFormattedString(HttpResponseMessage httpResponse);
    [ExtensionAttribute]
public static string AsFormattedString(IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static JObject ToJson(HttpHeaders headers);
    [ExtensionAttribute]
public static JObject ToJson(IDictionary`2<string, IEnumerable`1<string>> headers);
    [ExtensionAttribute]
public static JObject GetHeadersAsJson(HttpResponseMessage message);
}
public abstract class Microsoft.Rest.HttpMessageWrapper : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IDictionary`2<string, IEnumerable`1<string>> <Headers>k__BackingField;
    public string Content { get; public set; }
    public IDictionary`2<string, IEnumerable`1<string>> Headers { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IEnumerable`1<string>> get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(IDictionary`2<string, IEnumerable`1<string>> value);
    protected void CopyHeaders(HttpHeaders headers);
}
public class Microsoft.Rest.HttpOperationException : RestException {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpRequestMessageWrapper <Request>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpResponseMessageWrapper <Response>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private object <Body>k__BackingField;
    public HttpRequestMessageWrapper Request { get; public set; }
    public HttpResponseMessageWrapper Response { get; public set; }
    public object Body { get; public set; }
    public HttpOperationException(string message);
    public HttpOperationException(string message, Exception innerException);
    protected HttpOperationException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public HttpRequestMessageWrapper get_Request();
    [CompilerGeneratedAttribute]
public void set_Request(HttpRequestMessageWrapper value);
    [CompilerGeneratedAttribute]
public HttpResponseMessageWrapper get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(HttpResponseMessageWrapper value);
    [CompilerGeneratedAttribute]
public object get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(object value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Rest.HttpOperationHeaderResponse`1 : HttpOperationResponse {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private THeader <Headers>k__BackingField;
    public THeader Headers { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual THeader get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Headers(THeader value);
}
public class Microsoft.Rest.HttpOperationResponse : object {
    private bool _disposed;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpRequestMessage <Request>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpResponseMessage <Response>k__BackingField;
    public HttpRequestMessage Request { get; public set; }
    public HttpResponseMessage Response { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual HttpRequestMessage get_Request();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Request(HttpRequestMessage value);
    [CompilerGeneratedAttribute]
public sealed virtual HttpResponseMessage get_Response();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Response(HttpResponseMessage value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.Rest.HttpOperationResponse`1 : HttpOperationResponse {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private T <Body>k__BackingField;
    public T Body { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual T get_Body();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Body(T value);
}
public class Microsoft.Rest.HttpOperationResponse`2 : HttpOperationResponse`1<TBody> {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private THeader <Headers>k__BackingField;
    public THeader Headers { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual THeader get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Headers(THeader value);
}
public class Microsoft.Rest.HttpRequestMessageWrapper : HttpMessageWrapper {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Uri <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IDictionary`2<string, object> <Properties>k__BackingField;
    public HttpMethod Method { get; protected set; }
    public Uri RequestUri { get; protected set; }
    public IDictionary`2<string, object> Properties { get; private set; }
    public HttpRequestMessageWrapper(HttpRequestMessage httpRequest, string content);
    [CompilerGeneratedAttribute]
public HttpMethod get_Method();
    [CompilerGeneratedAttribute]
protected void set_Method(HttpMethod value);
    [CompilerGeneratedAttribute]
public Uri get_RequestUri();
    [CompilerGeneratedAttribute]
protected void set_RequestUri(Uri value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, object> value);
}
public class Microsoft.Rest.HttpResponseMessageWrapper : HttpMessageWrapper {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <ReasonPhrase>k__BackingField;
    public HttpStatusCode StatusCode { get; protected set; }
    public string ReasonPhrase { get; protected set; }
    public HttpResponseMessageWrapper(HttpResponseMessage httpResponse, string content);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
protected void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public string get_ReasonPhrase();
    [CompilerGeneratedAttribute]
protected void set_ReasonPhrase(string value);
}
public interface Microsoft.Rest.IHttpOperationHeaderResponse`1 {
    public T Headers { get; public set; }
    public abstract virtual T get_Headers();
    public abstract virtual void set_Headers(T value);
}
public interface Microsoft.Rest.IHttpOperationResponse {
    public HttpRequestMessage Request { get; public set; }
    public HttpResponseMessage Response { get; public set; }
    public abstract virtual HttpRequestMessage get_Request();
    public abstract virtual void set_Request(HttpRequestMessage value);
    public abstract virtual HttpResponseMessage get_Response();
    public abstract virtual void set_Response(HttpResponseMessage value);
}
public interface Microsoft.Rest.IHttpOperationResponse`1 {
    public T Body { get; public set; }
    public abstract virtual T get_Body();
    public abstract virtual void set_Body(T value);
}
public interface Microsoft.Rest.IHttpOperationResponse`2 {
}
public interface Microsoft.Rest.IServiceClientTracingInterceptor {
    public abstract virtual void Configuration(string source, string name, string value);
    public abstract virtual void EnterMethod(string invocationId, object instance, string method, IDictionary`2<string, object> parameters);
    public abstract virtual void ExitMethod(string invocationId, object returnValue);
    public abstract virtual void Information(string message);
    public abstract virtual void ReceiveResponse(string invocationId, HttpResponseMessage response);
    public abstract virtual void SendRequest(string invocationId, HttpRequestMessage request);
    public abstract virtual void TraceError(string invocationId, Exception exception);
}
public interface Microsoft.Rest.IServiceOperations`1 {
    public TClient Client { get; }
    public abstract virtual TClient get_Client();
}
public interface Microsoft.Rest.ITokenProvider {
    public abstract virtual Task`1<AuthenticationHeaderValue> GetAuthenticationHeaderAsync(CancellationToken cancellationToken);
}
internal class Microsoft.Rest.OsInfo : object {
    private static string WIN_OS_NAME;
    private static string LINUX_OS_NAME;
    private static string MAC_OSX_OS_NAME;
    private string _osName;
    private bool _isOsWindows;
    public string OsName { get; }
    public string OsVersion { get; }
    public bool IsOsWindows { get; }
    public string get_OsName();
    public string get_OsVersion();
    public bool get_IsOsWindows();
    private string GetOsVersion();
    private string GetOsName();
    private string GetOsNameBackup();
    private string GetOsVersionBackup();
    private string ReadHKLMRegistry(string path, string key);
}
internal class Microsoft.Rest.PlatformInfo : object {
    private OsInfo _osInfo;
    public OsInfo OsInfo { get; }
    public OsInfo get_OsInfo();
}
public class Microsoft.Rest.RestException : Exception {
    public RestException(string message);
    public RestException(string message, Exception innerException);
    protected RestException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Rest.RetryAfterDelegatingHandler : DelegatingHandler {
    public RetryAfterDelegatingHandler(DelegatingHandler innerHandler);
    public RetryAfterDelegatingHandler(HttpMessageHandler innerHandler);
    [AsyncStateMachineAttribute("Microsoft.Rest.RetryAfterDelegatingHandler/<SendAsync>d__3")]
[DebuggerStepThroughAttribute]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class Microsoft.Rest.RetryDelegatingHandler : DelegatingHandler {
    private static int DefaultNumberOfAttempts;
    private TimeSpan DefaultBackoffDelta;
    private TimeSpan DefaultMaxBackoff;
    private TimeSpan DefaultMinBackoff;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RetryPolicy <RetryPolicy>k__BackingField;
    public RetryPolicy RetryPolicy { get; public set; }
    public int EventCallbackCount { get; }
    public RetryDelegatingHandler(DelegatingHandler innerHandler);
    public RetryDelegatingHandler(HttpMessageHandler innerHandler);
    public RetryDelegatingHandler(RetryPolicy retryPolicy, HttpMessageHandler innerHandler);
    private void Init();
    [CompilerGeneratedAttribute]
public RetryPolicy get_RetryPolicy();
    [CompilerGeneratedAttribute]
public void set_RetryPolicy(RetryPolicy value);
    public int get_EventCallbackCount();
    [AsyncStateMachineAttribute("Microsoft.Rest.RetryDelegatingHandler/<SendAsync>d__15")]
[DebuggerStepThroughAttribute]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class Microsoft.Rest.Serialization.Base64UrlJsonConverter : JsonConverter {
    private static string ToBase64UrlString(Byte[] input);
    private static Byte[] FromBase64UrlString(string input);
    private static string Pad(string input);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Microsoft.Rest.Serialization.DateJsonConverter : IsoDateTimeConverter {
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Microsoft.Rest.Serialization.DateTimeRfc1123JsonConverter : IsoDateTimeConverter {
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Microsoft.Rest.Serialization.Iso8601TimeSpanConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[ExtensionAttribute]
public static class Microsoft.Rest.Serialization.JsonConverterHelper : object {
    public static void SerializeProperties(JsonWriter writer, object value, JsonSerializer serializer);
    public static void SerializeProperties(JsonWriter writer, object value, JsonSerializer serializer, Predicate`1<JsonProperty> filter);
    [ExtensionAttribute]
public static string GetPropertyName(JsonProperty property, String[]& parentPath);
    [ExtensionAttribute]
public static bool IsJsonExtensionData(JsonProperty property);
}
[AttributeUsageAttribute("4")]
public class Microsoft.Rest.Serialization.JsonTransformationAttribute : Attribute {
}
public class Microsoft.Rest.Serialization.PolymorphicDeserializeJsonConverter`1 : PolymorphicJsonConverter {
    public bool CanWrite { get; }
    public PolymorphicDeserializeJsonConverter`1(string discriminatorField);
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    private JToken SelectTokenCaseInsensitive(JObject obj, string path);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public abstract class Microsoft.Rest.Serialization.PolymorphicJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Discriminator>k__BackingField;
    public string Discriminator { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Discriminator();
    [CompilerGeneratedAttribute]
protected void set_Discriminator(string value);
    public static Type GetDerivedType(Type baseType, string name);
}
public class Microsoft.Rest.Serialization.PolymorphicSerializeJsonConverter`1 : PolymorphicJsonConverter {
    public bool CanRead { get; }
    public PolymorphicSerializeJsonConverter`1(string discriminatorField);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Microsoft.Rest.Serialization.ReadOnlyJsonContractResolver : DefaultContractResolver {
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
}
public static class Microsoft.Rest.Serialization.SafeJsonConvert : object {
    public static T DeserializeObject(string json, JsonSerializerSettings settings);
    public static T DeserializeObject(string json, JsonConverter[] converters);
    public static string SerializeObject(object obj, JsonSerializerSettings settings);
    public static string SerializeObject(object obj, JsonConverter[] converters);
    private static JsonSerializerSettings SettingsFromConverters(JsonConverter[] converters);
}
public class Microsoft.Rest.Serialization.TransformationJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Microsoft.Rest.Serialization.UnixTimeJsonConverter : JsonConverter {
    public static DateTime EpochDate;
    private static UnixTimeJsonConverter();
    private static Nullable`1<long> ToUnixTime(DateTime dateTime);
    private static Nullable`1<DateTime> FromUnixTime(Nullable`1<long> seconds);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Microsoft.Rest.SerializationException : RestException {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Content>k__BackingField;
    public string Content { get; public set; }
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
    public SerializationException(string message, string content, Exception innerException);
    protected SerializationException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class Microsoft.Rest.ServiceClient`1 : object {
    private static string FXVERSION;
    private static string OSNAME;
    private static string OSVERSION;
    private object lockUserAgent;
    private PlatformInfo _platformInfo;
    private string _osName;
    private string _osVersion;
    private bool _disposed;
    private bool _disposeHttpClient;
    private string _clientVersion;
    private string _fxVersion;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpMessageHandler <FirstMessageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpClientHandler <HttpClientHandler>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpClient <HttpClient>k__BackingField;
    private bool IsOsWindows { get; }
    private PlatformInfo PlatformInfo { get; }
    private string OsName { get; }
    private string OsVersion { get; }
    private string ClientVersion { get; }
    private string FrameworkVersion { get; }
    protected HttpMessageHandler FirstMessageHandler { get; protected set; }
    protected HttpClientHandler HttpClientHandler { get; protected set; }
    public HttpClient HttpClient { get; protected set; }
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> UserAgent { get; }
    public IEnumerable`1<HttpMessageHandler> HttpMessageHandlers { get; }
    protected ServiceClient`1(HttpClient httpClient, bool disposeHttpClient);
    protected ServiceClient`1(DelegatingHandler[] handlers);
    protected ServiceClient`1(HttpClientHandler rootHandler, DelegatingHandler[] handlers);
    private ServiceClient`1(HttpClient httpClient, HttpClientHandler rootHandler, DelegatingHandler[] handlers);
    private ServiceClient`1(HttpClient serviceHttpClient, HttpClientHandler rootHandler, bool disposeHttpClient, DelegatingHandler[] delHandlers);
    private bool get_IsOsWindows();
    private PlatformInfo get_PlatformInfo();
    private string get_OsName();
    private string get_OsVersion();
    private string get_ClientVersion();
    private string get_FrameworkVersion();
    [CompilerGeneratedAttribute]
protected HttpMessageHandler get_FirstMessageHandler();
    [CompilerGeneratedAttribute]
protected void set_FirstMessageHandler(HttpMessageHandler value);
    [CompilerGeneratedAttribute]
protected HttpClientHandler get_HttpClientHandler();
    [CompilerGeneratedAttribute]
protected void set_HttpClientHandler(HttpClientHandler value);
    protected void InitializeHttpClient(HttpClientHandler httpClientHandler, DelegatingHandler[] handlers);
    protected void InitializeHttpClient(HttpClient httpClient, HttpClientHandler httpClientHandler, DelegatingHandler[] handlers);
    protected virtual DelegatingHandler CreateHttpHandlerPipeline(HttpClientHandler httpClientHandler, DelegatingHandler[] handlers);
    protected static HttpClientHandler CreateRootHandler();
    [CompilerGeneratedAttribute]
public HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
protected void set_HttpClient(HttpClient value);
    public virtual HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_UserAgent();
    [IteratorStateMachineAttribute("Microsoft.Rest.ServiceClient`1/<get_HttpMessageHandlers>d__48")]
public virtual IEnumerable`1<HttpMessageHandler> get_HttpMessageHandlers();
    public virtual void SetRetryPolicy(RetryPolicy retryPolicy);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public bool SetUserAgent(string productName);
    public bool SetUserAgent(string productName, string version);
    private string CleanUserAgentInfoEntry(string infoEntry);
    private void AddUserAgentEntry(ProductInfoHeaderValue pInfoHeaderValue);
    private void SetDefaultAgentInfo();
}
public abstract class Microsoft.Rest.ServiceClientCredentials : object {
    public virtual void InitializeServiceClient(ServiceClient`1<T> client);
    public virtual Task ProcessHttpRequestAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
public static class Microsoft.Rest.ServiceClientTracing : object {
    private static List`1<IServiceClientTracingInterceptor> _interceptors;
    private static List`1<IServiceClientTracingInterceptor> _threadSafeInterceptors;
    private static object _lock;
    private static long _nextInvocationId;
    private static bool _isEnabled;
    public static bool IsEnabled { get; public set; }
    internal static IEnumerable`1<IServiceClientTracingInterceptor> TracingInterceptors { get; }
    public static long NextInvocationId { get; }
    private static ServiceClientTracing();
    public static bool get_IsEnabled();
    public static void set_IsEnabled(bool value);
    internal static IEnumerable`1<IServiceClientTracingInterceptor> get_TracingInterceptors();
    public static long get_NextInvocationId();
    public static void AddTracingInterceptor(IServiceClientTracingInterceptor interceptor);
    public static bool RemoveTracingInterceptor(IServiceClientTracingInterceptor interceptor);
    public static void Information(string message, Object[] parameters);
    public static void Configuration(string source, string name, string value);
    public static void Information(string message);
    public static void Enter(string invocationId, object instance, string method, IDictionary`2<string, object> parameters);
    public static void SendRequest(string invocationId, HttpRequestMessage request);
    public static void ReceiveResponse(string invocationId, HttpResponseMessage response);
    public static void Error(string invocationId, Exception ex);
    public static void Exit(string invocationId, object result);
}
public class Microsoft.Rest.StringTokenProvider : object {
    private string _accessToken;
    private string _type;
    public string TokenType { get; }
    public StringTokenProvider(string accessToken, string tokenType);
    public string get_TokenType();
    public sealed virtual Task`1<AuthenticationHeaderValue> GetAuthenticationHeaderAsync(CancellationToken cancellationToken);
}
public class Microsoft.Rest.TokenCredentials : ServiceClientCredentials {
    private static string BearerTokenType;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ITokenProvider <TokenProvider>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <CallerId>k__BackingField;
    protected ITokenProvider TokenProvider { get; private set; }
    public string TenantId { get; private set; }
    public string CallerId { get; private set; }
    public TokenCredentials(string token);
    public TokenCredentials(string token, string tokenType);
    public TokenCredentials(ITokenProvider tokenProvider);
    public TokenCredentials(ITokenProvider tokenProvider, string tenantId, string callerId);
    [CompilerGeneratedAttribute]
protected ITokenProvider get_TokenProvider();
    [CompilerGeneratedAttribute]
private void set_TokenProvider(ITokenProvider value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
private void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_CallerId();
    [CompilerGeneratedAttribute]
private void set_CallerId(string value);
    [AsyncStateMachineAttribute("Microsoft.Rest.TokenCredentials/<ProcessHttpRequestAsync>d__17")]
[DebuggerStepThroughAttribute]
public virtual Task ProcessHttpRequestAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal class Microsoft.Rest.TransientFaultHandling.AsyncExecution : AsyncExecution`1<bool> {
    private static Task`1<bool> _cachedBoolTask;
    public AsyncExecution(Func`1<Task> taskAction, ShouldRetryHandler shouldRetryHandler, Func`2<Exception, bool> isTransient, Action`3<int, Exception, TimeSpan> onRetrying, bool fastFirstRetry, CancellationToken cancellationToken);
    private static Task`1<bool> GetCachedTask();
    private static Task`1<bool> StartAsGenericTask(Func`1<Task> taskAction);
}
internal class Microsoft.Rest.TransientFaultHandling.AsyncExecution`1 : object {
    private CancellationToken _cancellationToken;
    private bool _fastFirstRetry;
    private Func`2<Exception, bool> _isTransient;
    private Action`3<int, Exception, TimeSpan> _onRetrying;
    private ShouldRetryHandler _shouldRetryHandler;
    private Func`1<Task`1<TResult>> _taskFunc;
    private Task`1<TResult> _previousTask;
    private int _retryCount;
    public AsyncExecution`1(Func`1<Task`1<TResult>> taskFunc, ShouldRetryHandler shouldRetryHandler, Func`2<Exception, bool> isTransient, Action`3<int, Exception, TimeSpan> onRetrying, bool fastFirstRetry, CancellationToken cancellationToken);
    internal Task`1<TResult> ExecuteAsync();
    private Task`1<TResult> ExecuteAsyncImpl(Task ignore);
    private Task`1<TResult> ExecuteAsyncContinueWith(Task`1<TResult> runningTask);
}
public class Microsoft.Rest.TransientFaultHandling.ExponentialBackoffRetryStrategy : RetryStrategy {
    public static TimeSpan DefaultClientBackoff;
    public static TimeSpan DefaultMaxBackoff;
    public static TimeSpan DefaultMinBackoff;
    private TimeSpan _deltaBackoff;
    private TimeSpan _maxBackoff;
    private TimeSpan _minBackoff;
    private int _retryCount;
    public ExponentialBackoffRetryStrategy(int retryCount, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff);
    public ExponentialBackoffRetryStrategy(string name, int retryCount, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff);
    public ExponentialBackoffRetryStrategy(string name, int retryCount, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff, bool firstFastRetry);
    private static ExponentialBackoffRetryStrategy();
    public virtual ShouldRetryHandler GetShouldRetryHandler();
    [CompilerGeneratedAttribute]
private RetryCondition <GetShouldRetryHandler>b__11_0(int currentRetryCount, Exception lastException);
}
public class Microsoft.Rest.TransientFaultHandling.FixedIntervalRetryStrategy : RetryStrategy {
    private int _retryCount;
    private TimeSpan _retryInterval;
    public FixedIntervalRetryStrategy(int retryCount);
    public FixedIntervalRetryStrategy(int retryCount, TimeSpan retryInterval);
    public FixedIntervalRetryStrategy(string name, int retryCount, TimeSpan retryInterval);
    public FixedIntervalRetryStrategy(string name, int retryCount, TimeSpan retryInterval, bool firstFastRetry);
    public virtual ShouldRetryHandler GetShouldRetryHandler();
    [CompilerGeneratedAttribute]
private RetryCondition <GetShouldRetryHandler>b__7_1(int currentRetryCount, Exception lastException);
}
internal static class Microsoft.Rest.TransientFaultHandling.Guard : object {
    public static bool ArgumentNotNull(object argumentValue, string argumentName);
    public static void ArgumentNotNegativeValue(int argumentValue, string argumentName);
    public static void ArgumentNotNegativeValue(long argumentValue, string argumentName);
    public static void ArgumentNotGreaterThan(double argumentValue, double ceilingValue, string argumentName);
}
public class Microsoft.Rest.TransientFaultHandling.HttpRequestWithStatusException : HttpRequestException {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private HttpStatusCode <StatusCode>k__BackingField;
    public HttpStatusCode StatusCode { get; public set; }
    public HttpRequestWithStatusException(string message);
    public HttpRequestWithStatusException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
}
public class Microsoft.Rest.TransientFaultHandling.HttpStatusCodeErrorDetectionStrategy : object {
    public sealed virtual bool IsTransient(Exception ex);
}
public class Microsoft.Rest.TransientFaultHandling.IncrementalRetryStrategy : RetryStrategy {
    public static TimeSpan DefaultRetryIncrement;
    private TimeSpan _increment;
    private TimeSpan _initialInterval;
    private int _retryCount;
    public IncrementalRetryStrategy(int retryCount, TimeSpan initialInterval, TimeSpan increment);
    public IncrementalRetryStrategy(string name, int retryCount, TimeSpan initialInterval, TimeSpan increment);
    public IncrementalRetryStrategy(string name, int retryCount, TimeSpan initialInterval, TimeSpan increment, bool firstFastRetry);
    private static IncrementalRetryStrategy();
    public virtual ShouldRetryHandler GetShouldRetryHandler();
    [CompilerGeneratedAttribute]
private RetryCondition <GetShouldRetryHandler>b__8_0(int currentRetryCount, Exception lastException);
}
public interface Microsoft.Rest.TransientFaultHandling.ITransientErrorDetectionStrategy {
    public abstract virtual bool IsTransient(Exception ex);
}
public class Microsoft.Rest.TransientFaultHandling.RetryCondition : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TimeSpan <DelayBeforeRetry>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <RetryAllowed>k__BackingField;
    public TimeSpan DelayBeforeRetry { get; public set; }
    public bool RetryAllowed { get; public set; }
    public RetryCondition(bool retryAllowed, TimeSpan delay);
    [CompilerGeneratedAttribute]
public TimeSpan get_DelayBeforeRetry();
    [CompilerGeneratedAttribute]
public void set_DelayBeforeRetry(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_RetryAllowed();
    [CompilerGeneratedAttribute]
public void set_RetryAllowed(bool value);
}
public class Microsoft.Rest.TransientFaultHandling.RetryingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <CurrentRetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private TimeSpan <Delay>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Exception <LastException>k__BackingField;
    public int CurrentRetryCount { get; private set; }
    public TimeSpan Delay { get; private set; }
    public Exception LastException { get; private set; }
    public RetryingEventArgs(int currentRetryCount, TimeSpan delay, Exception lastException);
    [CompilerGeneratedAttribute]
public int get_CurrentRetryCount();
    [CompilerGeneratedAttribute]
private void set_CurrentRetryCount(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Delay();
    [CompilerGeneratedAttribute]
private void set_Delay(TimeSpan value);
    [CompilerGeneratedAttribute]
public Exception get_LastException();
    [CompilerGeneratedAttribute]
private void set_LastException(Exception value);
}
public class Microsoft.Rest.TransientFaultHandling.RetryManager : object {
    private static RetryManager _defaultRetryManager;
    private IDictionary`2<string, RetryStrategy> _defaultRetryStrategiesMap;
    private IDictionary`2<string, RetryStrategy> _retryStrategies;
    private string _defaultRetryStrategyName;
    private RetryStrategy _defaultStrategy;
    public static RetryManager Instance { get; }
    public string DefaultRetryStrategyName { get; public set; }
    public RetryManager(IEnumerable`1<RetryStrategy> retryStrategies);
    public RetryManager(IEnumerable`1<RetryStrategy> retryStrategies, string defaultRetryStrategyName);
    public RetryManager(IEnumerable`1<RetryStrategy> retryStrategies, string defaultRetryStrategyName, IDictionary`2<string, string> defaultRetryStrategyNamesMap);
    public static RetryManager get_Instance();
    public string get_DefaultRetryStrategyName();
    public void set_DefaultRetryStrategyName(string value);
    public static void SetDefault(RetryManager retryManager);
    public static void SetDefault(RetryManager retryManager, bool throwIfSet);
    public virtual RetryPolicy`1<T> GetRetryPolicy();
    public virtual RetryPolicy`1<T> GetRetryPolicy(string retryStrategyName);
    public virtual RetryStrategy GetRetryStrategy();
    public virtual RetryStrategy GetRetryStrategy(string retryStrategyName);
    public virtual RetryStrategy GetDefaultRetryStrategy(string technology);
}
public class Microsoft.Rest.TransientFaultHandling.RetryPolicy : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private EventHandler`1<RetryingEventArgs> Retrying;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private RetryStrategy <RetryStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ITransientErrorDetectionStrategy <ErrorDetectionStrategy>k__BackingField;
    public int EventCallbackCount { get; }
    public RetryStrategy RetryStrategy { get; private set; }
    public ITransientErrorDetectionStrategy ErrorDetectionStrategy { get; private set; }
    public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, RetryStrategy retryStrategy);
    public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, int retryCount);
    public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, int retryCount, TimeSpan retryInterval);
    public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, int retryCount, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff);
    public RetryPolicy(ITransientErrorDetectionStrategy errorDetectionStrategy, int retryCount, TimeSpan initialInterval, TimeSpan increment);
    [CompilerGeneratedAttribute]
public void add_Retrying(EventHandler`1<RetryingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Retrying(EventHandler`1<RetryingEventArgs> value);
    public int get_EventCallbackCount();
    [CompilerGeneratedAttribute]
public RetryStrategy get_RetryStrategy();
    [CompilerGeneratedAttribute]
private void set_RetryStrategy(RetryStrategy value);
    [CompilerGeneratedAttribute]
public ITransientErrorDetectionStrategy get_ErrorDetectionStrategy();
    [CompilerGeneratedAttribute]
private void set_ErrorDetectionStrategy(ITransientErrorDetectionStrategy value);
    public virtual void ExecuteAction(Action action);
    public virtual TResult ExecuteAction(Func`1<TResult> func);
    public Task ExecuteAsync(Func`1<Task> taskAction);
    public Task ExecuteAsync(Func`1<Task> taskAction, CancellationToken cancellationToken);
    public Task`1<TResult> ExecuteAsync(Func`1<Task`1<TResult>> taskFunc);
    public Task`1<TResult> ExecuteAsync(Func`1<Task`1<TResult>> taskFunc, CancellationToken cancellationToken);
    protected virtual void OnRetrying(int retryCount, Exception lastError, TimeSpan delay);
}
public class Microsoft.Rest.TransientFaultHandling.RetryPolicy`1 : RetryPolicy {
    public RetryPolicy`1(RetryStrategy retryStrategy);
    public RetryPolicy`1(int retryCount);
    public RetryPolicy`1(int retryCount, TimeSpan retryInterval);
    public RetryPolicy`1(int retryCount, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff);
    public RetryPolicy`1(int retryCount, TimeSpan initialInterval, TimeSpan increment);
}
public abstract class Microsoft.Rest.TransientFaultHandling.RetryStrategy : object {
    public static int DefaultClientRetryCount;
    public static TimeSpan DefaultRetryInterval;
    public static bool DefaultFirstFastRetry;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <FastFirstRetry>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    public bool FastFirstRetry { get; public set; }
    public string Name { get; private set; }
    protected RetryStrategy(string name, bool firstFastRetry);
    private static RetryStrategy();
    [CompilerGeneratedAttribute]
public bool get_FastFirstRetry();
    [CompilerGeneratedAttribute]
public void set_FastFirstRetry(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public abstract virtual ShouldRetryHandler GetShouldRetryHandler();
}
public class Microsoft.Rest.TransientFaultHandling.ShouldRetryHandler : MulticastDelegate {
    public ShouldRetryHandler(object object, IntPtr method);
    public virtual RetryCondition Invoke(int retryCount, Exception lastException);
    public virtual IAsyncResult BeginInvoke(int retryCount, Exception lastException, AsyncCallback callback, object object);
    public virtual RetryCondition EndInvoke(IAsyncResult result);
}
public class Microsoft.Rest.TransientFaultHandling.TransientErrorIgnoreStrategy : object {
    public sealed virtual bool IsTransient(Exception ex);
}
public static class Microsoft.Rest.TypeConversion : object {
    public static string FromBase64String(string value);
    public static Uri TryParseUri(string value);
}
internal class Microsoft.Rest.Utilities.ObjectComparer`1 : object {
    private Func`3<T, T, bool> objectComparerDelegate;
    private Func`2<T, int> hashComputeDelegate;
    public ObjectComparer`1(Func`3<T, T, bool> comparisonDelegate);
    public ObjectComparer`1(Func`3<T, T, bool> comparisonDelegate, Func`2<T, int> hashComputeDelegate);
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
public class Microsoft.Rest.ValidationException : RestException {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private object <Details>k__BackingField;
    public string Rule { get; private set; }
    public string Target { get; private set; }
    public object Details { get; private set; }
    public ValidationException(string message);
    public ValidationException(string rule, string target);
    public ValidationException(string rule, string target, object details);
    public ValidationException(string message, Exception innerException);
    protected ValidationException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_Rule();
    [CompilerGeneratedAttribute]
private void set_Rule(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(string value);
    [CompilerGeneratedAttribute]
public object get_Details();
    [CompilerGeneratedAttribute]
private void set_Details(object value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public static class Microsoft.Rest.ValidationRules : object {
    public static string CannotBeNull;
    public static string InclusiveMaximum;
    public static string ExclusiveMaximum;
    public static string MaxLength;
    public static string MinLength;
    public static string Pattern;
    public static string MaxItems;
    public static string MinItems;
    public static string UniqueItems;
    public static string Enum;
    public static string MultipleOf;
    public static string InclusiveMinimum;
    public static string ExclusiveMinimum;
    private static ValidationRules();
}
