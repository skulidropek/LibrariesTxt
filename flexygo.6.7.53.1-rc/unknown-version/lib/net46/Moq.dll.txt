internal class __ProtectAttribute : Attribute {
}
internal class Moq.AddActualInvocation : object {
    private InterceptorContext ctx;
    private EventInfo GetEventFromName(string eventName);
    private EventInfo GetEventFromName(string eventName, BindingFlags bindingAttr);
    private static IEnumerable`1<Type> GetAncestorTypes(Type initialType);
    public sealed virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localctx);
}
[AttributeUsageAttribute("64")]
internal class Moq.AdvancedMatcherAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Type <MatcherType>k__BackingField;
    public Type MatcherType { get; private set; }
    public AdvancedMatcherAttribute(Type matcherType);
    [CompilerGeneratedAttribute]
public Type get_MatcherType();
    [CompilerGeneratedAttribute]
private void set_MatcherType(Type value);
    public IMatcher CreateMatcher();
}
internal class Moq.AsInterface`1 : Mock`1<TInterface> {
    private Mock owner;
    internal ConcurrentDictionary`2<MethodInfo, Mock> InnerMocks { get; }
    internal Interceptor Interceptor { get; internal set; }
    internal Type MockedType { get; }
    public MockBehavior Behavior { get; internal set; }
    public bool CallBase { get; public set; }
    public DefaultValue DefaultValue { get; public set; }
    public TInterface Object { get; }
    public AsInterface`1(Mock owner);
    internal virtual ConcurrentDictionary`2<MethodInfo, Mock> get_InnerMocks();
    internal virtual Interceptor get_Interceptor();
    internal virtual void set_Interceptor(Interceptor value);
    internal virtual Type get_MockedType();
    public virtual MockBehavior get_Behavior();
    internal virtual void set_Behavior(MockBehavior value);
    public virtual bool get_CallBase();
    public virtual void set_CallBase(bool value);
    public virtual DefaultValue get_DefaultValue();
    public virtual void set_DefaultValue(DefaultValue value);
    public virtual TInterface get_Object();
    public virtual Mock`1<TNewInterface> As();
}
public static class Moq.Capture : object {
    public static T In(ICollection`1<T> collection);
    public static T In(IList`1<T> collection, Expression`1<Func`2<T, bool>> predicate);
    public static T With(CaptureMatch`1<T> match);
}
public class Moq.CaptureMatch`1 : Match`1<T> {
    public CaptureMatch`1(Action`1<T> captureCallback);
    public CaptureMatch`1(Action`1<T> captureCallback, Expression`1<Func`2<T, bool>> predicate);
    private static Predicate`1<T> CreatePredicate(Action`1<T> captureCallback);
    private static Predicate`1<T> CreatePredicate(Action`1<T> captureCallback, Expression`1<Func`2<T, bool>> predicate);
}
internal class Moq.Condition : object {
    private Func`1<bool> condition;
    private Action success;
    public bool IsTrue { get; }
    public Condition(Func`1<bool> condition, Action success);
    public bool get_IsTrue();
    public void EvaluatedSuccessfully();
}
internal class Moq.ConditionalContext`1 : object {
    private Mock`1<T> mock;
    private Condition condition;
    public ConditionalContext`1(Mock`1<T> mock, Condition condition);
    public sealed virtual ISetup`1<T> Setup(Expression`1<Action`1<T>> expression);
    public sealed virtual ISetup`2<T, TResult> Setup(Expression`1<Func`2<T, TResult>> expression);
    public sealed virtual ISetupGetter`2<T, TProperty> SetupGet(Expression`1<Func`2<T, TProperty>> expression);
    public sealed virtual ISetupSetter`2<T, TProperty> SetupSet(Action`1<T> setterExpression);
    public sealed virtual ISetup`1<T> SetupSet(Action`1<T> setterExpression);
}
internal class Moq.CurrentInterceptContext : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private IProxyCall <Call>k__BackingField;
    public IProxyCall Call { get; public set; }
    [CompilerGeneratedAttribute]
public IProxyCall get_Call();
    [CompilerGeneratedAttribute]
public void set_Call(IProxyCall value);
}
public enum Moq.DefaultValue : Enum {
    public int value__;
    public static DefaultValue Empty;
    public static DefaultValue Mock;
}
internal class Moq.EmptyDefaultValueProvider : object {
    private Dictionary`2<Type, object> defaultValues;
    public virtual void DefineDefault(T value);
    public virtual object ProvideDefault(MethodInfo member);
    private static object GetReferenceTypeDefault(Type valueType);
    private static object GetValueTypeDefault(Type valueType);
    private static Task GetCompletedTaskForType(Type type);
}
internal static class Moq.Evaluator : object {
    public static Expression PartialEval(Expression expression, Func`2<Expression, bool> fnCanBeEvaluated);
    public static Expression PartialEval(Expression expression);
}
internal class Moq.ExecuteCall : object {
    private InterceptorContext ctx;
    public sealed virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localctx);
    private void ThrowIfReturnValueRequired(IProxyCall call, ICallContext invocation);
}
[ExtensionAttribute]
internal static class Moq.ExpressionExtensions : object {
    [ExtensionAttribute]
public static LambdaExpression ToLambda(Expression expression);
    [ExtensionAttribute]
public static MethodCallExpression ToMethodCall(LambdaExpression expression);
    [ExtensionAttribute]
public static PropertyInfo ToPropertyInfo(LambdaExpression expression);
    [ExtensionAttribute]
public static bool IsProperty(LambdaExpression expression);
    [ExtensionAttribute]
public static bool IsProperty(Expression expression);
    [ExtensionAttribute]
public static bool IsPropertyIndexer(LambdaExpression expression);
    [ExtensionAttribute]
public static bool IsPropertyIndexer(Expression expression);
    [ExtensionAttribute]
public static Expression StripQuotes(Expression expression);
    [ExtensionAttribute]
public static Expression PartialEval(Expression expression);
    [ExtensionAttribute]
public static Expression PartialMatcherAwareEval(Expression expression);
    private static bool ReturnsMatch(MethodCallExpression expression);
    [ExtensionAttribute]
public static Expression CastTo(Expression expression);
    [ExtensionAttribute]
public static string ToStringFixed(Expression expression);
    [ExtensionAttribute]
internal static string ToStringFixed(Expression expression, bool useFullTypeName);
    [ExtensionAttribute]
internal static CallInfo GetCallInfo(LambdaExpression expression, Mock mock);
}
internal class Moq.ExpressionStringBuilder : object {
    private Expression expression;
    private StringBuilder builder;
    private Func`2<Type, string> getTypeName;
    public ExpressionStringBuilder(Func`2<Type, string> getTypeName, Expression expression);
    internal static string GetString(Expression expression);
    internal static string GetString(Expression expression, Func`2<Type, string> getTypeName);
    public virtual string ToString();
    public void ToString(Expression exp);
    private void ToStringBinding(MemberBinding binding);
    private void ToStringElementInitializer(ElementInit initializer);
    private void ToStringUnary(UnaryExpression u);
    private void ToStringBinary(BinaryExpression b);
    private static bool NeedEncloseInParen(Expression operand);
    private void ToStringTypeIs(TypeBinaryExpression b);
    private void ToStringConstant(ConstantExpression c);
    private void ToStringConditional(ConditionalExpression c);
    private void ToStringParameter(ParameterExpression p);
    private void ToStringMemberAccess(MemberExpression m);
    private void ToStringMethodCall(MethodCallExpression node);
    private void ToStringExpressionList(ReadOnlyCollection`1<Expression> original);
    private void ToStringMemberAssignment(MemberAssignment assignment);
    private void ToStringMemberMemberBinding(MemberMemberBinding binding);
    private void ToStringMemberListBinding(MemberListBinding binding);
    private void ToStringBindingList(IEnumerable`1<MemberBinding> original);
    private void ToStringElementInitializerList(ReadOnlyCollection`1<ElementInit> original);
    private void ToStringLambda(LambdaExpression lambda);
    private void ToStringNew(NewExpression nex);
    private void ToStringMemberInit(MemberInitExpression init);
    private void ToStringListInit(ListInitExpression init);
    private void ToStringNewArray(NewArrayExpression na);
    private void AsCommaSeparatedValues(IEnumerable`1<T> source, Action`1<T> toStringAction);
    private void ToStringInvocation(InvocationExpression iv);
    internal static string ToStringOperator(ExpressionType nodeType);
    [CompilerGeneratedAttribute]
private string <ToStringMethodCall>b__18_0(Type s);
}
[ExtensionAttribute]
internal static class Moq.Extensions : object {
    private static FieldInfo remoteStackTraceString;
    private static Extensions();
    [ExtensionAttribute]
public static string Format(ICallContext invocation);
    public static string GetValue(object value);
    [ExtensionAttribute]
public static object InvokePreserveStack(Delegate del, Object[] args);
    [ExtensionAttribute]
public static void SetStackTrace(Exception exception, string stackTrace);
    [ExtensionAttribute]
public static bool IsDelegate(Type t);
    [ExtensionAttribute]
public static void ThrowIfNotMockeable(Type typeToMock);
    [ExtensionAttribute]
public static void ThrowIfNotMockeable(MemberExpression memberAccess);
    [ExtensionAttribute]
public static void ThrowIfNoGetter(PropertyInfo property);
    [ExtensionAttribute]
public static void ThrowIfNoSetter(PropertyInfo property);
    [ExtensionAttribute]
public static bool IsMockeable(Type typeToMock);
    [ExtensionAttribute]
public static bool IsSerializableMockable(Type typeToMock);
    [ExtensionAttribute]
private static bool IsGetObjectDataVirtual(Type typeToMock);
    [ExtensionAttribute]
private static bool ContainsDeserializationConstructor(Type typeToMock);
    [ExtensionAttribute]
public static bool CanOverride(MethodBase method);
    [ExtensionAttribute]
public static bool CanOverrideGet(PropertyInfo property);
    [ExtensionAttribute]
public static bool CanOverrideSet(PropertyInfo property);
    [ExtensionAttribute]
public static EventInfo GetEvent(Action`1<TMock> eventExpression, TMock mock);
    [ExtensionAttribute]
public static TAttribute GetCustomAttribute(ICustomAttributeProvider source, bool inherit);
    [ExtensionAttribute]
public static bool HasCompatibleParameterTypes(MethodInfo method, Type[] paramTypes);
    [ExtensionAttribute]
public static bool HasCompatibleParameterList(Delegate function, ParameterInfo[] expectedParams);
    private static bool HasCompatibleParameterList(ParameterInfo[] expectedParams, MethodInfo method);
    private static MethodInfo GetInvokeMethodFromUntypedDelegateCallback(Delegate callback);
}
internal class Moq.ExtractProxyCall : object {
    public sealed virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localctx);
}
internal class Moq.FluentMockContext : object {
    [ThreadStaticAttribute]
private static FluentMockContext current;
    private List`1<MockInvocation> invocations;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Match <LastMatch>k__BackingField;
    public static FluentMockContext Current { get; }
    public static bool IsActive { get; }
    public MockInvocation LastInvocation { get; }
    public Match LastMatch { get; public set; }
    public static FluentMockContext get_Current();
    public static bool get_IsActive();
    public void Add(Mock mock, ICallContext invocation);
    public MockInvocation get_LastInvocation();
    [CompilerGeneratedAttribute]
public Match get_LastMatch();
    [CompilerGeneratedAttribute]
public void set_LastMatch(Match value);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Moq.GeneratedReturnsExtensions : object {
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`2<T, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`3<T1, T2, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`4<T1, T2, T3, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`5<T1, T2, T3, T4, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`6<T1, T2, T3, T4, T5, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`7<T1, T2, T3, T4, T5, T6, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`8<T1, T2, T3, T4, T5, T6, T7, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFunction);
}
[DebuggerStepThroughAttribute]
internal static class Moq.Guard : object {
    public static void NotNull(Expression`1<Func`1<T>> reference, T value);
    public static void NotNullOrEmpty(Expression`1<Func`1<string>> reference, string value);
    public static void NotOutOfRangeInclusive(Expression`1<Func`1<T>> reference, T value, T from, T to);
    public static void NotOutOfRangeExclusive(Expression`1<Func`1<T>> reference, T value, T from, T to);
    public static void CanBeAssigned(Expression`1<Func`1<object>> reference, Type typeToAssign, Type targetType);
    private static string GetParameterName(LambdaExpression reference);
}
internal class Moq.HandleDestructor : object {
    public sealed virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localctx);
}
internal class Moq.HandleMockRecursion : object {
    public sealed virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localctx);
}
internal class Moq.HandleTracking : object {
    public sealed virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localctx);
}
[EditorBrowsableAttribute("2")]
internal interface Moq.IDefaultValueProvider {
    public abstract virtual void DefineDefault(T value);
    public abstract virtual object ProvideDefault(MethodInfo member);
}
[EditorBrowsableAttribute("1")]
public interface Moq.IFluentInterface {
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object obj);
}
internal interface Moq.IInterceptStrategy {
    public abstract virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localCtx);
}
internal interface Moq.IMatcher {
    public abstract virtual void Initialize(Expression matcherExpression);
    public abstract virtual bool Matches(object value);
}
public interface Moq.IMock`1 {
    [SuppressMessageAttribute("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
[SuppressMessageAttribute("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods")]
public T Object { get; }
    public MockBehavior Behavior { get; }
    public bool CallBase { get; public set; }
    public DefaultValue DefaultValue { get; public set; }
    public abstract virtual T get_Object();
    public abstract virtual MockBehavior get_Behavior();
    public abstract virtual bool get_CallBase();
    public abstract virtual void set_CallBase(bool value);
    public abstract virtual DefaultValue get_DefaultValue();
    public abstract virtual void set_DefaultValue(DefaultValue value);
}
[EditorBrowsableAttribute("1")]
public interface Moq.IMocked {
    public Mock Mock { get; }
    public abstract virtual Mock get_Mock();
}
[EditorBrowsableAttribute("1")]
public interface Moq.IMocked`1 {
    public Mock`1<T> Mock { get; }
    public abstract virtual Mock`1<T> get_Mock();
}
internal enum Moq.InterceptionAction : Enum {
    public int value__;
    public static InterceptionAction Continue;
    public static InterceptionAction Stop;
}
internal class Moq.InterceptMockPropertyMixin : object {
    public sealed virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localctx);
}
internal class Moq.InterceptObjectMethodsMixin : object {
    public sealed virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localctx);
    protected bool IsObjectMethod(MethodInfo method, string name);
    [CompilerGeneratedAttribute]
private bool <HandleIntercept>b__0_0(IProxyCall c);
    [CompilerGeneratedAttribute]
private bool <HandleIntercept>b__0_1(IProxyCall c);
    [CompilerGeneratedAttribute]
private bool <HandleIntercept>b__0_2(IProxyCall c);
}
internal class Moq.Interceptor : object {
    private Dictionary`2<ExpressionKey, IProxyCall> calls;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private InterceptorContext <InterceptionContext>k__BackingField;
    internal InterceptorContext InterceptionContext { get; private set; }
    public Interceptor(MockBehavior behavior, Type targetType, Mock mock);
    [CompilerGeneratedAttribute]
internal InterceptorContext get_InterceptionContext();
    [CompilerGeneratedAttribute]
private void set_InterceptionContext(InterceptorContext value);
    internal void Verify();
    internal void VerifyAll();
    private void VerifyOrThrow(Func`2<IProxyCall, bool> match);
    public void AddCall(IProxyCall call, SetupKind kind);
    internal void ClearCalls();
    [IteratorStateMachineAttribute("Moq.Interceptor/<InterceptionStrategies>d__11")]
private IEnumerable`1<IInterceptStrategy> InterceptionStrategies();
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
public sealed virtual void Intercept(ICallContext invocation);
}
internal class Moq.InterceptorContext : object {
    private Dictionary`2<string, List`1<Delegate>> invocationLists;
    private List`1<ICallContext> actualInvocations;
    private List`1<IProxyCall> orderedCalls;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Mock <Mock>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MockBehavior <Behavior>k__BackingField;
    public Mock Mock { get; private set; }
    public Type TargetType { get; private set; }
    public MockBehavior Behavior { get; private set; }
    internal IEnumerable`1<ICallContext> ActualInvocations { get; }
    internal IEnumerable`1<IProxyCall> OrderedCalls { get; }
    public InterceptorContext(Mock Mock, Type targetType, MockBehavior behavior);
    [CompilerGeneratedAttribute]
public Mock get_Mock();
    [CompilerGeneratedAttribute]
private void set_Mock(Mock value);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
public MockBehavior get_Behavior();
    [CompilerGeneratedAttribute]
private void set_Behavior(MockBehavior value);
    internal IEnumerable`1<Delegate> GetInvocationList(EventInfo ev);
    internal void AddEventHandler(EventInfo ev, Delegate handler);
    internal void RemoveEventHandler(EventInfo ev, Delegate handler);
    internal void ClearEventHandlers();
    internal void AddInvocation(ICallContext invocation);
    internal IEnumerable`1<ICallContext> get_ActualInvocations();
    internal void ClearInvocations();
    internal void AddOrderedCall(IProxyCall call);
    internal void RemoveOrderedCall(IProxyCall call);
    internal void ClearOrderedCalls();
    internal IEnumerable`1<IProxyCall> get_OrderedCalls();
}
internal class Moq.InvokeBase : object {
    public sealed virtual InterceptionAction HandleIntercept(ICallContext invocation, InterceptorContext ctx, CurrentInterceptContext localctx);
}
internal interface Moq.IProxyCall {
    public int CallCount { get; }
    public bool IsConditional { get; }
    public string FailMessage { get; public set; }
    public bool Invoked { get; public set; }
    public bool IsVerifiable { get; public set; }
    public Expression SetupExpression { get; }
    public MethodInfo Method { get; }
    public string FileName { get; }
    public int FileLine { get; }
    public MethodBase TestMethod { get; }
    public abstract virtual int get_CallCount();
    public abstract virtual bool get_IsConditional();
    public abstract virtual string get_FailMessage();
    public abstract virtual void set_FailMessage(string value);
    public abstract virtual bool get_Invoked();
    public abstract virtual void set_Invoked(bool value);
    public abstract virtual bool get_IsVerifiable();
    public abstract virtual void set_IsVerifiable(bool value);
    public abstract virtual Expression get_SetupExpression();
    public abstract virtual MethodInfo get_Method();
    public abstract virtual void EvaluatedSuccessfully();
    public abstract virtual bool Matches(ICallContext call);
    public abstract virtual void Execute(ICallContext call);
    public abstract virtual void SetOutParameters(ICallContext call);
    public abstract virtual string get_FileName();
    public abstract virtual int get_FileLine();
    public abstract virtual MethodBase get_TestMethod();
}
public static class Moq.It : object {
    public static TValue IsAny();
    public static TValue IsNotNull();
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static TValue Is(Expression`1<Func`2<TValue, bool>> match);
    public static TValue IsInRange(TValue from, TValue to, Range rangeKind);
    public static TValue IsIn(IEnumerable`1<TValue> items);
    public static TValue IsIn(TValue[] items);
    public static TValue IsNotIn(IEnumerable`1<TValue> items);
    public static TValue IsNotIn(TValue[] items);
    public static string IsRegex(string regex);
    public static string IsRegex(string regex, RegexOptions options);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ICallbackResult {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.IReturnsResult`1 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.IReturnsThrows`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.IReturnsThrowsGetter`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ISetup`1 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ISetup`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ISetupGetter`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ISetupSetter`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.IThrowsResult {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ICallback {
    public abstract virtual ICallbackResult Callback(Action action);
    public abstract virtual ICallbackResult Callback(Action`1<T> action);
    public abstract virtual ICallbackResult Callback(Action`2<T1, T2> action);
    public abstract virtual ICallbackResult Callback(Action`3<T1, T2, T3> action);
    public abstract virtual ICallbackResult Callback(Action`4<T1, T2, T3, T4> action);
    public abstract virtual ICallbackResult Callback(Action`5<T1, T2, T3, T4, T5> action);
    public abstract virtual ICallbackResult Callback(Action`6<T1, T2, T3, T4, T5, T6> action);
    public abstract virtual ICallbackResult Callback(Action`7<T1, T2, T3, T4, T5, T6, T7> action);
    public abstract virtual ICallbackResult Callback(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> action);
    public abstract virtual ICallbackResult Callback(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> action);
    public abstract virtual ICallbackResult Callback(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> action);
    public abstract virtual ICallbackResult Callback(Action`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> action);
    public abstract virtual ICallbackResult Callback(Action`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> action);
    public abstract virtual ICallbackResult Callback(Action`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> action);
    public abstract virtual ICallbackResult Callback(Action`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> action);
    public abstract virtual ICallbackResult Callback(Action`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> action);
    public abstract virtual ICallbackResult Callback(Action`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> action);
}
public interface Moq.Language.ICallback`2 {
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`1<T> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`2<T1, T2> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`3<T1, T2, T3> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`4<T1, T2, T3, T4> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`5<T1, T2, T3, T4, T5> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`6<T1, T2, T3, T4, T5, T6> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`7<T1, T2, T3, T4, T5, T6, T7> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> action);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ICallbackGetter`2 {
    public abstract virtual IReturnsThrowsGetter`2<TMock, TProperty> Callback(Action action);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ICallbackSetter`1 {
    public abstract virtual ICallbackResult Callback(Action`1<TProperty> action);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IOccurrence {
    [ObsoleteAttribute("To verify this condition, use the overload to Verify that receives Times.AtMostOnce().")]
[EditorBrowsableAttribute("1")]
public abstract virtual IVerifies AtMostOnce();
    [ObsoleteAttribute("To verify this condition, use the overload to Verify that receives Times.AtMost(callCount).")]
[EditorBrowsableAttribute("1")]
public abstract virtual IVerifies AtMost(int callCount);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IRaise`1 {
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, EventArgs args);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`1<EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Object[] args);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`2<T1, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`3<T1, T2, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`4<T1, T2, T3, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`5<T1, T2, T3, T4, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`6<T1, T2, T3, T4, T5, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`7<T1, T2, T3, T4, T5, T6, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`8<T1, T2, T3, T4, T5, T6, T7, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, EventArgs> func);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IReturns`2 {
    public abstract virtual IReturnsResult`1<TMock> Returns(TResult value);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`1<TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`2<T, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> CallBase();
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`3<T1, T2, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`4<T1, T2, T3, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`5<T1, T2, T3, T4, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`6<T1, T2, T3, T4, T5, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`7<T1, T2, T3, T4, T5, T6, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`8<T1, T2, T3, T4, T5, T6, T7, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> valueFunction);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IReturnsGetter`2 {
    public abstract virtual IReturnsResult`1<TMock> Returns(TProperty value);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`1<TProperty> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> CallBase();
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ISetupConditionResult`1 {
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public abstract virtual ISetup`1<T> Setup(Expression`1<Action`1<T>> expression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public abstract virtual ISetup`2<T, TResult> Setup(Expression`1<Func`2<T, TResult>> expression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public abstract virtual ISetupGetter`2<T, TProperty> SetupGet(Expression`1<Func`2<T, TProperty>> expression);
    public abstract virtual ISetupSetter`2<T, TProperty> SetupSet(Action`1<T> setterExpression);
    public abstract virtual ISetup`1<T> SetupSet(Action`1<T> setterExpression);
}
public interface Moq.Language.ISetupSequentialResult`1 {
    public abstract virtual ISetupSequentialResult`1<TResult> Returns(TResult value);
    public abstract virtual ISetupSequentialResult`1<TResult> Throws(Exception exception);
    [SuppressMessageAttribute("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
public abstract virtual ISetupSequentialResult`1<TResult> Throws();
    public abstract virtual ISetupSequentialResult`1<TResult> CallBase();
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IThrows {
    public abstract virtual IThrowsResult Throws(Exception exception);
    [SuppressMessageAttribute("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
public abstract virtual IThrowsResult Throws();
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IVerifies {
    public abstract virtual void Verifiable();
    public abstract virtual void Verifiable(string failMessage);
}
internal class Moq.Linq.FluentMockVisitor : ExpressionVisitor {
    private static MethodInfo fluentMockGenericMethod;
    private static MethodInfo mockGetGenericMethod;
    private Expression expression;
    private bool isFirst;
    public FluentMockVisitor(Expression expression);
    private static FluentMockVisitor();
    public static Expression Accept(Expression expression);
    public Expression Accept();
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    private static Expression TranslateFluent(Type objectType, Type returnType, MethodInfo targetMethod, Expression instance, ParameterExpression lambdaParam, Expression lambdaBody);
    private MethodInfo GetTargetMethod(Type objectType, Type returnType);
    private static MethodInfo GetSetupMethod(Type objectType, Type returnType);
}
internal class Moq.Linq.MockQueryable`1 : object {
    private MethodCallExpression underlyingCreateMocks;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Expression <Expression>k__BackingField;
    public Type ElementType { get; }
    public Expression Expression { get; private set; }
    public IQueryProvider Provider { get; }
    public MockQueryable`1(MethodCallExpression underlyingCreateMocks);
    public MockQueryable`1(MethodCallExpression underlyingCreateMocks, Expression expression);
    public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Expression();
    [CompilerGeneratedAttribute]
private void set_Expression(Expression value);
    public sealed virtual IQueryProvider get_Provider();
    public sealed virtual IQueryable CreateQuery(Expression expression);
    public sealed virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public sealed virtual object Execute(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
internal class Moq.Linq.MockSetupsBuilder : ExpressionVisitor {
    private static String[] queryableMethods;
    private static String[] unsupportedMethods;
    private int stackIndex;
    private MethodCallExpression underlyingCreateMocks;
    public MockSetupsBuilder(MethodCallExpression underlyingCreateMocks);
    private static MockSetupsBuilder();
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    private static Expression ConvertToSetup(Expression left, Expression right);
    private static Expression ConvertToSetupProperty(Expression targetObject, Expression left, Expression right);
    private static Expression ConvertToSetup(Expression targetObject, Expression left, Expression right);
}
public abstract class Moq.Match : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Expression <RenderExpression>k__BackingField;
    internal Expression RenderExpression { get; internal set; }
    internal static TValue Matcher();
    internal abstract virtual bool Matches(object value);
    [CompilerGeneratedAttribute]
internal Expression get_RenderExpression();
    [CompilerGeneratedAttribute]
internal void set_RenderExpression(Expression value);
    public static T Create(Predicate`1<T> condition);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static T Create(Predicate`1<T> condition, Expression`1<Func`1<T>> renderExpression);
    internal static T Create(Match`1<T> match);
    private static Match`1<TValue> SetLastMatch(Match`1<TValue> match);
}
public class Moq.Match`1 : Match {
    private static Expression`1<Func`1<T>> defaultRender;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Predicate`1<T> <Condition>k__BackingField;
    internal Predicate`1<T> Condition { get; internal set; }
    internal Match`1(Predicate`1<T> condition, Expression`1<Func`1<T>> renderExpression);
    internal Match`1(Predicate`1<T> condition);
    private static Match`1();
    [CompilerGeneratedAttribute]
internal Predicate`1<T> get_Condition();
    [CompilerGeneratedAttribute]
internal void set_Condition(Predicate`1<T> value);
    internal virtual bool Matches(object value);
}
[AttributeUsageAttribute("64")]
public class Moq.MatcherAttribute : Attribute {
}
internal static class Moq.MatcherFactory : object {
    public static IMatcher CreateMatcher(Expression expression, bool isParams);
}
internal class Moq.Matchers.ConstantMatcher : object {
    private object constantValue;
    public ConstantMatcher(object constantValue);
    public sealed virtual void Initialize(Expression matcherExpression);
    public sealed virtual bool Matches(object value);
    private bool MatchesEnumerable(object value);
}
internal class Moq.Matchers.ExpressionComparer : object {
    public static ExpressionComparer Default;
    private static ExpressionComparer();
    public sealed virtual bool Equals(Expression x, Expression y);
    public sealed virtual int GetHashCode(Expression obj);
    private static bool Equals(ReadOnlyCollection`1<T> x, ReadOnlyCollection`1<T> y, Func`3<T, T, bool> comparer);
    private bool EqualsBinary(BinaryExpression x, BinaryExpression y);
    private bool EqualsConditional(ConditionalExpression x, ConditionalExpression y);
    private static bool EqualsConstant(ConstantExpression x, ConstantExpression y);
    private bool EqualsElementInit(ElementInit x, ElementInit y);
    private bool EqualsInvocation(InvocationExpression x, InvocationExpression y);
    private bool EqualsLambda(LambdaExpression x, LambdaExpression y);
    private bool EqualsListInit(ListInitExpression x, ListInitExpression y);
    private bool EqualsMemberAssignment(MemberAssignment x, MemberAssignment y);
    private bool EqualsMemberBinding(MemberBinding x, MemberBinding y);
    private bool EqualsMember(MemberExpression x, MemberExpression y);
    private bool EqualsMemberInit(MemberInitExpression x, MemberInitExpression y);
    private bool EqualsMemberListBinding(MemberListBinding x, MemberListBinding y);
    private bool EqualsMemberMemberBinding(MemberMemberBinding x, MemberMemberBinding y);
    private bool EqualsMethodCall(MethodCallExpression x, MethodCallExpression y);
    private bool EqualsNewArray(NewArrayExpression x, NewArrayExpression y);
    private bool EqualsNew(NewExpression x, NewExpression y);
    private bool EqualsParameter(ParameterExpression x, ParameterExpression y);
    private bool EqualsTypeBinary(TypeBinaryExpression x, TypeBinaryExpression y);
    private bool EqualsUnary(UnaryExpression x, UnaryExpression y);
}
internal class Moq.Matchers.ExpressionMatcher : object {
    private Expression expression;
    public ExpressionMatcher(Expression matcherExpression);
    private sealed virtual override void Moq.IMatcher.Initialize(Expression matcherExpression);
    public sealed virtual bool Matches(object value);
}
internal class Moq.Matchers.LazyEvalMatcher : object {
    private Expression expression;
    public sealed virtual void Initialize(Expression matcherExpression);
    public sealed virtual bool Matches(object value);
}
internal class Moq.Matchers.Matcher : object {
    private Match match;
    public Matcher(Match match);
    public sealed virtual void Initialize(Expression matcherExpression);
    public sealed virtual bool Matches(object value);
}
internal class Moq.Matchers.MatcherAttributeMatcher : object {
    private MethodInfo validatorMethod;
    private Expression matcherExpression;
    public sealed virtual void Initialize(Expression matchExpression);
    private static MethodInfo ResolveValidatorMethod(Expression expression);
    public sealed virtual bool Matches(object value);
}
internal class Moq.Matchers.ParamArrayMatcher : object {
    private NewArrayExpression arrayInitExpression;
    private IMatcher[] matchers;
    internal ParamArrayMatcher(NewArrayExpression matcherExpression);
    public sealed virtual bool Matches(object value);
    private sealed virtual override void Moq.IMatcher.Initialize(Expression matcherExpression);
    private void Initialize();
}
internal class Moq.Matchers.PredicateMatcher : object {
    private Delegate predicate;
    private Type matcherType;
    public sealed virtual void Initialize(Expression matcherExpression);
    public sealed virtual bool Matches(object value);
}
internal class Moq.Matchers.RefMatcher : object {
    private Func`2<object, bool> equals;
    public RefMatcher(object reference);
    public sealed virtual bool Matches(object value);
    public sealed virtual void Initialize(Expression matcherExpression);
}
internal class Moq.MatchExpression : Expression {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Match <Match>k__BackingField;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Match Match { get; private set; }
    public MatchExpression(Match match);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    [CompilerGeneratedAttribute]
public Match get_Match();
    [CompilerGeneratedAttribute]
private void set_Match(Match value);
}
[ExtensionAttribute]
internal static class Moq.MemberInfoExtensions : object {
    [ExtensionAttribute]
public static string GetFullName(MethodBase method);
    [ExtensionAttribute]
public static string GetFullName(Type type);
    [ExtensionAttribute]
public static string GetName(MethodBase method);
    [ExtensionAttribute]
public static string GetName(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetParameterTypes(MethodBase method);
    [ExtensionAttribute]
public static bool IsDestructor(MethodInfo method);
    [ExtensionAttribute]
public static bool IsEventAttach(MethodBase method);
    [ExtensionAttribute]
public static bool IsEventDetach(MethodBase method);
    [ExtensionAttribute]
public static bool IsPropertyGetter(MethodBase method);
    [ExtensionAttribute]
public static bool IsPropertyIndexerGetter(MethodBase method);
    [ExtensionAttribute]
public static bool IsPropertyIndexerSetter(MethodBase method);
    [ExtensionAttribute]
public static bool IsPropertySetter(MethodBase method);
    [ExtensionAttribute]
public static bool IsRefArgument(ParameterInfo parameter);
    [ExtensionAttribute]
public static bool IsOutArgument(ParameterInfo parameter);
    private static string GetGenericArguments(IEnumerable`1<Type> types, Func`2<Type, string> typeGetter);
}
internal class Moq.MethodCall : object {
    private Expression originalExpression;
    private Exception thrownException;
    private Action`1<Object[]> setupCallback;
    private List`1<IMatcher> argumentMatchers;
    private bool isOnce;
    private EventInfo mockEvent;
    private Delegate mockEventArgsFunc;
    private Object[] mockEventArgsParams;
    private Nullable`1<int> expectedCallCount;
    protected Condition condition;
    private List`1<KeyValuePair`2<int, object>> outValues;
    private static IEqualityComparer`1<Type> typesComparer;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <FailMessage>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <IsVerifiable>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <Invoked>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <FileLine>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MethodBase <TestMethod>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <CallCount>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Mock <Mock>k__BackingField;
    public string FailMessage { get; public set; }
    public bool IsConditional { get; }
    public bool IsVerifiable { get; public set; }
    public bool Invoked { get; public set; }
    public MethodInfo Method { get; private set; }
    public string FileName { get; private set; }
    public int FileLine { get; private set; }
    public MethodBase TestMethod { get; private set; }
    public Expression SetupExpression { get; }
    public int CallCount { get; private set; }
    protected internal Mock Mock { get; private set; }
    public MethodCall(Mock mock, Condition condition, Expression originalExpression, MethodInfo method, Expression[] arguments);
    private static MethodCall();
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`1<T> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`2<T1, T2> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`3<T1, T2, T3> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`4<T1, T2, T3, T4> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`5<T1, T2, T3, T4, T5> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`6<T1, T2, T3, T4, T5, T6> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`7<T1, T2, T3, T4, T5, T6, T7> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> callback);
    [SuppressMessageAttribute("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
public sealed virtual ICallbackResult Callback(Action`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> callback);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FailMessage();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailMessage(string value);
    public sealed virtual bool get_IsConditional();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVerifiable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsVerifiable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Invoked();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Invoked(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_FileLine();
    [CompilerGeneratedAttribute]
private void set_FileLine(int value);
    [CompilerGeneratedAttribute]
public sealed virtual MethodBase get_TestMethod();
    [CompilerGeneratedAttribute]
private void set_TestMethod(MethodBase value);
    public sealed virtual Expression get_SetupExpression();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CallCount();
    [CompilerGeneratedAttribute]
private void set_CallCount(int value);
    [CompilerGeneratedAttribute]
protected internal Mock get_Mock();
    [CompilerGeneratedAttribute]
private void set_Mock(Mock value);
    [ConditionalAttribute("DESKTOP")]
[SuppressMessageAttribute("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
private void SetFileInfo();
    public sealed virtual void SetOutParameters(ICallContext call);
    public virtual bool Matches(ICallContext call);
    public sealed virtual void EvaluatedSuccessfully();
    public virtual void Execute(ICallContext call);
    public sealed virtual IThrowsResult Throws(Exception exception);
    public sealed virtual IThrowsResult Throws();
    public sealed virtual ICallbackResult Callback(Action callback);
    protected virtual void SetCallbackWithoutArguments(Action callback);
    protected virtual void SetCallbackWithArguments(Delegate callback);
    private static void ThrowParameterMismatch(ParameterInfo[] expected, ParameterInfo[] actual);
    public sealed virtual void Verifiable();
    public sealed virtual void Verifiable(string failMessage);
    private bool IsEqualMethodOrOverride(ICallContext call);
    public sealed virtual IVerifies AtMostOnce();
    public sealed virtual IVerifies AtMost(int callCount);
    protected IVerifies RaisesImpl(Action`1<TMock> eventExpression, Delegate func);
    protected IVerifies RaisesImpl(Action`1<TMock> eventExpression, Object[] args);
    public virtual string ToString();
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
internal class Moq.MethodCall`1 : MethodCall {
    public MethodCall`1(Mock mock, Condition condition, Expression originalExpression, MethodInfo method, Expression[] arguments);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`2<T, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`3<T1, T2, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`4<T1, T2, T3, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`5<T1, T2, T3, T4, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`6<T1, T2, T3, T4, T5, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`7<T1, T2, T3, T4, T5, T6, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`8<T1, T2, T3, T4, T5, T6, T7, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, EventArgs args);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`1<EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Object[] args);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
internal class Moq.MethodCallReturn : MethodCall {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <HasReturnValue>k__BackingField;
    public bool HasReturnValue { get; protected set; }
    public MethodCallReturn(Mock mock, Condition condition, Expression originalExpression, MethodInfo method, Expression[] arguments);
    [CompilerGeneratedAttribute]
public bool get_HasReturnValue();
    [CompilerGeneratedAttribute]
protected void set_HasReturnValue(bool value);
}
internal class Moq.MethodCallReturn`2 : MethodCallReturn {
    private Delegate valueDel;
    private Action`1<Object[]> afterReturnCallback;
    private bool callBase;
    public MethodCallReturn`2(Mock mock, Condition condition, Expression originalExpression, MethodInfo method, Expression[] arguments);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`2<T, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`2<T, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`1<T> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`3<T1, T2, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`3<T1, T2, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`2<T1, T2> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`4<T1, T2, T3, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`4<T1, T2, T3, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`3<T1, T2, T3> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`5<T1, T2, T3, T4, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`5<T1, T2, T3, T4, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`4<T1, T2, T3, T4> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`6<T1, T2, T3, T4, T5, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`6<T1, T2, T3, T4, T5, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`5<T1, T2, T3, T4, T5> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`7<T1, T2, T3, T4, T5, T6, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`7<T1, T2, T3, T4, T5, T6, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`6<T1, T2, T3, T4, T5, T6> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`8<T1, T2, T3, T4, T5, T6, T7, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`8<T1, T2, T3, T4, T5, T6, T7, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`7<T1, T2, T3, T4, T5, T6, T7> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, EventArgs> func);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> valueExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1061:DoNotHideBaseClassMethods")]
public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> callback);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, EventArgs args);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Func`1<EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<TMock> eventExpression, Object[] args);
    public sealed virtual IReturnsResult`1<TMock> Returns(Func`1<TResult> valueExpression);
    public sealed virtual IReturnsResult`1<TMock> Returns(TResult value);
    public sealed virtual IReturnsResult`1<TMock> CallBase();
    private sealed virtual override IReturnsThrowsGetter`2<TMock, TResult> Moq.Language.ICallbackGetter<TMock,TResult>.Callback(Action callback);
    public sealed virtual IReturnsThrows`2<TMock, TResult> Callback(Action callback);
    private void SetReturnDelegate(Delegate value);
    protected virtual void SetCallbackWithoutArguments(Action callback);
    protected virtual void SetCallbackWithArguments(Delegate callback);
    public virtual void Execute(ICallContext call);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
public abstract class Moq.Mock : object {
    private bool isInitialized;
    private DefaultValue defaultValue;
    private IDefaultValueProvider defaultValueProvider;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private MockBehavior <Behavior>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <CallBase>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private Interceptor <Interceptor>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private ConcurrentDictionary`2<MethodInfo, Mock> <InnerMocks>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private List`1<Type> <ImplementedInterfaces>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private int <InternallyImplementedInterfaceCount>k__BackingField;
    public MockBehavior Behavior { get; internal set; }
    public bool CallBase { get; public set; }
    public DefaultValue DefaultValue { get; public set; }
    [SuppressMessageAttribute("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
[SuppressMessageAttribute("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods")]
public object Object { get; }
    internal Interceptor Interceptor { get; internal set; }
    internal ConcurrentDictionary`2<MethodInfo, Mock> InnerMocks { get; private set; }
    internal Type MockedType { get; }
    internal MethodInfo DelegateInterfaceMethod { get; }
    internal bool IsDelegateMock { get; }
    internal IDefaultValueProvider DefaultValueProvider { get; }
    internal List`1<Type> ImplementedInterfaces { get; private set; }
    protected internal int InternallyImplementedInterfaceCount { get; protected set; }
    public static T Of();
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static T Of(Expression`1<Func`2<T, bool>> predicate);
    [ObsoleteAttribute]
internal static SetterMethodCall`2<T, TProperty> SetupSet(Mock mock, Expression`1<Func`2<T, TProperty>> expression, TProperty value);
    [ObsoleteAttribute]
internal static void VerifySet(Mock mock, Expression`1<Func`2<T, TProperty>> expression, Times times, string failMessage);
    [ObsoleteAttribute]
internal static void VerifySet(Mock mock, Expression`1<Func`2<T, TProperty>> expression, TProperty value, Times times, string failMessage);
    public static Mock`1<T> Get(T mocked);
    public static void Verify(Mock[] mocks);
    public static void VerifyAll(Mock[] mocks);
    [CompilerGeneratedAttribute]
public virtual MockBehavior get_Behavior();
    [CompilerGeneratedAttribute]
internal virtual void set_Behavior(MockBehavior value);
    [CompilerGeneratedAttribute]
public virtual bool get_CallBase();
    [CompilerGeneratedAttribute]
public virtual void set_CallBase(bool value);
    public virtual DefaultValue get_DefaultValue();
    public virtual void set_DefaultValue(DefaultValue value);
    private void SetDefaultValue(DefaultValue value);
    public object get_Object();
    private object GetObject();
    [CompilerGeneratedAttribute]
internal virtual Interceptor get_Interceptor();
    [CompilerGeneratedAttribute]
internal virtual void set_Interceptor(Interceptor value);
    [CompilerGeneratedAttribute]
internal virtual ConcurrentDictionary`2<MethodInfo, Mock> get_InnerMocks();
    [CompilerGeneratedAttribute]
private void set_InnerMocks(ConcurrentDictionary`2<MethodInfo, Mock> value);
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
protected abstract virtual object OnGetObject();
    internal abstract virtual Type get_MockedType();
    internal abstract virtual MethodInfo get_DelegateInterfaceMethod();
    internal abstract virtual bool get_IsDelegateMock();
    internal IDefaultValueProvider get_DefaultValueProvider();
    [CompilerGeneratedAttribute]
internal List`1<Type> get_ImplementedInterfaces();
    [CompilerGeneratedAttribute]
private void set_ImplementedInterfaces(List`1<Type> value);
    [CompilerGeneratedAttribute]
protected internal int get_InternallyImplementedInterfaceCount();
    [CompilerGeneratedAttribute]
protected void set_InternallyImplementedInterfaceCount(int value);
    [SuppressMessageAttribute("Microsoft.Usage", "CA2200:RethrowToPreserveStackDetails")]
public void Verify();
    [SuppressMessageAttribute("Microsoft.Usage", "CA2200:RethrowToPreserveStackDetails")]
public void VerifyAll();
    internal static void Verify(Mock`1<T> mock, Expression`1<Action`1<T>> expression, Times times, string failMessage);
    internal static void Verify(Mock`1<T> mock, Expression`1<Func`2<T, TResult>> expression, Times times, string failMessage);
    internal static void VerifyGet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, Times times, string failMessage);
    internal static void VerifySet(Mock`1<T> mock, Action`1<T> setterExpression, Times times, string failMessage);
    private static bool AreSameMethod(Expression left, Expression right);
    private static void VerifyCalls(Interceptor targetInterceptor, MethodCall expected, Expression expression, Times times);
    private static void ThrowVerifyException(MethodCall expected, IEnumerable`1<IProxyCall> setups, IEnumerable`1<ICallContext> actualCalls, Expression expression, Times times, int callCount);
    private static string FormatSetupsInfo(IEnumerable`1<IProxyCall> setups);
    private static string FormatCallCount(int callCount);
    private static string FormatInvocations(IEnumerable`1<ICallContext> invocations);
    internal static MethodCall`1<T> Setup(Mock`1<T> mock, Expression`1<Action`1<T>> expression, Condition condition);
    internal static MethodCallReturn`2<T, TResult> Setup(Mock`1<T> mock, Expression`1<Func`2<T, TResult>> expression, Condition condition);
    internal static MethodCallReturn`2<T, TProperty> SetupGet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, Condition condition);
    internal static SetterMethodCall`2<T, TProperty> SetupSet(Mock`1<T> mock, Action`1<T> setterExpression, Condition condition);
    internal static MethodCall`1<T> SetupSet(Mock`1<T> mock, Action`1<T> setterExpression, Condition condition);
    internal static SetterMethodCall`2<T, TProperty> SetupSet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression);
    private static TCall SetupSetImpl(Mock`1<T> mock, Action`1<T> setterExpression, Func`5<Mock, Expression, MethodInfo, Expression[], TCall> callFactory);
    private static Expression GetValueExpression(object value, Type type);
    internal static void SetupAllProperties(Mock mock);
    private static void SetupAllProperties(Mock mock, Stack`1<Type> mockedTypesStack);
    private static object GetInitialValue(IDefaultValueProvider valueProvider, Stack`1<Type> mockedTypesStack, PropertyInfo property);
    private static Expression GetPropertyExpression(Type mockType, PropertyInfo property);
    private static Interceptor GetInterceptor(Expression fluentExpression, Mock mock);
    [SuppressMessageAttribute("Microsoft.Usage", "CA2208:InstantiateArgumentExceptionsCorrectly")]
private static void ThrowIfPropertyNotWritable(PropertyInfo prop);
    private static void ThrowIfPropertyNotReadable(PropertyInfo prop);
    private static void ThrowIfCantOverride(Expression setup, MethodInfo method);
    private static void ThrowIfVerifyNonVirtual(Expression verify, MethodInfo method);
    private static void ThrowIfNotMember(Expression setup, MethodInfo method);
    private static void ThrowIfCantOverride(MethodBase setter);
    internal void DoRaise(EventInfo ev, EventArgs args);
    internal void DoRaise(EventInfo ev, Object[] args);
    [SuppressMessageAttribute("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
public virtual Mock`1<TInterface> As();
    public void SetReturnsDefault(TReturn value);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
public class Moq.Mock`1 : Mock {
    private static IProxyFactory proxyFactory;
    private T instance;
    private Object[] constructorArguments;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private string <Name>k__BackingField;
    private MethodInfo delegateInterfaceMethod;
    [SuppressMessageAttribute("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
[SuppressMessageAttribute("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods")]
public T Object { get; }
    public string Name { get; public set; }
    internal bool IsDelegateMock { get; }
    internal MethodInfo DelegateInterfaceMethod { get; }
    internal Type MockedType { get; }
    [SuppressMessageAttribute("Microsoft.Usage", "CA1801:ReviewUnusedParameters")]
internal Mock`1(bool skipInitialize);
    [SuppressMessageAttribute("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
public Mock`1(Object[] args);
    [SuppressMessageAttribute("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
public Mock`1(MockBehavior behavior);
    [SuppressMessageAttribute("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]
public Mock`1(MockBehavior behavior, Object[] args);
    private static Mock`1();
    [ObsoleteAttribute("Expect has been renamed to Setup.", "False")]
[EditorBrowsableAttribute("1")]
public ISetup`1<T> Expect(Expression`1<Action`1<T>> expression);
    [ObsoleteAttribute("Expect has been renamed to Setup.", "False")]
[EditorBrowsableAttribute("1")]
public ISetup`2<T, TResult> Expect(Expression`1<Func`2<T, TResult>> expression);
    [ObsoleteAttribute("ExpectGet has been renamed to SetupGet.", "False")]
[EditorBrowsableAttribute("1")]
public ISetupGetter`2<T, TProperty> ExpectGet(Expression`1<Func`2<T, TProperty>> expression);
    [ObsoleteAttribute("ExpectSet has been renamed to SetupSet.", "False")]
[EditorBrowsableAttribute("1")]
public ISetupSetter`2<T, TProperty> ExpectSet(Expression`1<Func`2<T, TProperty>> expression);
    [ObsoleteAttribute("ExpectSet has been renamed to SetupSet, and the new syntax allows you to pass the value in the expression itself, like f => f.Value = 25.", "True")]
[EditorBrowsableAttribute("1")]
public ISetupSetter`2<T, TProperty> ExpectSet(Expression`1<Func`2<T, TProperty>> expression, TProperty value);
    private string GenerateMockName();
    private void CheckParameters();
    public virtual T get_Object();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public virtual string ToString();
    internal virtual bool get_IsDelegateMock();
    private void InitializeInstance();
    internal virtual MethodInfo get_DelegateInterfaceMethod();
    [SuppressMessageAttribute("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
protected virtual object OnGetObject();
    internal virtual Type get_MockedType();
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public ISetup`1<T> Setup(Expression`1<Action`1<T>> expression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public ISetup`2<T, TResult> Setup(Expression`1<Func`2<T, TResult>> expression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public ISetupGetter`2<T, TProperty> SetupGet(Expression`1<Func`2<T, TProperty>> expression);
    public ISetupSetter`2<T, TProperty> SetupSet(Action`1<T> setterExpression);
    public ISetup`1<T> SetupSet(Action`1<T> setterExpression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
[SuppressMessageAttribute("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
public Mock`1<T> SetupProperty(Expression`1<Func`2<T, TProperty>> property);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
[SuppressMessageAttribute("Microsoft.Naming", "CA1716:IdentifiersShouldNotMatchKeywords")]
public Mock`1<T> SetupProperty(Expression`1<Func`2<T, TProperty>> property, TProperty initialValue);
    public Mock`1<T> SetupAllProperties();
    public ISetupConditionResult`1<T> When(Func`1<bool> condition);
    internal ISetupConditionResult`1<T> When(Condition condition);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Action`1<T>> expression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Action`1<T>> expression, Times times);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Action`1<T>> expression, Func`1<Times> times);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Action`1<T>> expression, string failMessage);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Action`1<T>> expression, Times times, string failMessage);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Action`1<T>> expression, Func`1<Times> times, string failMessage);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Func`2<T, TResult>> expression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Func`2<T, TResult>> expression, Times times);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Func`2<T, TResult>> expression, Func`1<Times> times);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Func`2<T, TResult>> expression, string failMessage);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void Verify(Expression`1<Func`2<T, TResult>> expression, Times times, string failMessage);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, Times times);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, Func`1<Times> times);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, string failMessage);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, Times times, string failMessage);
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, Func`1<Times> times, string failMessage);
    public void VerifySet(Action`1<T> setterExpression);
    public void VerifySet(Action`1<T> setterExpression, Times times);
    public void VerifySet(Action`1<T> setterExpression, Func`1<Times> times);
    public void VerifySet(Action`1<T> setterExpression, string failMessage);
    public void VerifySet(Action`1<T> setterExpression, Times times, string failMessage);
    public void VerifySet(Action`1<T> setterExpression, Func`1<Times> times, string failMessage);
    [SuppressMessageAttribute("Microsoft.Design", "CA1030:UseEventsWhereAppropriate")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2200:RethrowToPreserveStackDetails")]
public void Raise(Action`1<T> eventExpression, EventArgs args);
    [SuppressMessageAttribute("Microsoft.Design", "CA1030:UseEventsWhereAppropriate")]
[SuppressMessageAttribute("Microsoft.Usage", "CA2200:RethrowToPreserveStackDetails")]
public void Raise(Action`1<T> eventExpression, Object[] args);
    [CompilerGeneratedAttribute]
private void <InitializeInstance>b__24_0();
}
public enum Moq.MockBehavior : Enum {
    public int value__;
    public static MockBehavior Strict;
    public static MockBehavior Loose;
    public static MockBehavior Default;
}
internal class Moq.MockDefaultValueProvider : EmptyDefaultValueProvider {
    private Mock owner;
    public MockDefaultValueProvider(Mock owner);
    public virtual object ProvideDefault(MethodInfo member);
    [CompilerGeneratedAttribute]
private Mock <ProvideDefault>b__2_0(MethodInfo info);
}
[SuppressMessageAttribute("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors")]
public class Moq.MockException : Exception {
    private ExceptionReason reason;
    internal ExceptionReason Reason { get; }
    public bool IsVerificationError { get; }
    internal MockException(ExceptionReason reason, MockBehavior behavior, ICallContext invocation);
    internal MockException(ExceptionReason reason, MockBehavior behavior, ICallContext invocation, string message);
    internal MockException(ExceptionReason reason, string exceptionMessage);
    protected MockException(SerializationInfo info, StreamingContext context);
    internal ExceptionReason get_Reason();
    public bool get_IsVerificationError();
    private static string GetMessage(MockBehavior behavior, ICallContext invocation, string message);
    [SecurityCriticalAttribute]
[SuppressMessageAttribute("Microsoft.Security", "CA2123:OverrideLinkDemandsShouldBeIdenticalToBase")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class Moq.MockExtensions : object {
    [ExtensionAttribute]
public static void ResetCalls(Mock mock);
    [ExtensionAttribute]
public static void Reset(Mock mock);
}
[ObsoleteAttribute("This class has been renamed to MockRepository. MockFactory will be retired in v5.", "False")]
public class Moq.MockFactory : object {
    private List`1<Mock> mocks;
    private MockBehavior defaultBehavior;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <CallBase>k__BackingField;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private DefaultValue <DefaultValue>k__BackingField;
    public bool CallBase { get; public set; }
    public DefaultValue DefaultValue { get; public set; }
    protected internal IEnumerable`1<Mock> Mocks { get; }
    public MockFactory(MockBehavior defaultBehavior);
    [CompilerGeneratedAttribute]
public bool get_CallBase();
    [CompilerGeneratedAttribute]
public void set_CallBase(bool value);
    [CompilerGeneratedAttribute]
public DefaultValue get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(DefaultValue value);
    protected internal IEnumerable`1<Mock> get_Mocks();
    public Mock`1<T> Create();
    public Mock`1<T> Create(Object[] args);
    public Mock`1<T> Create(MockBehavior behavior);
    public Mock`1<T> Create(MockBehavior behavior, Object[] args);
    protected virtual Mock`1<T> CreateMock(MockBehavior behavior, Object[] args);
    public virtual void Verify();
    public virtual void VerifyAll();
    protected virtual void VerifyMocks(Action`1<Mock> verifyAction);
}
[ExtensionAttribute]
public static class Moq.MockLegacyExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The new syntax allows you to pass the value in the expression itself, like f => f.Value = 25.", "True")]
public static ISetupSetter`2<T, TProperty> SetupSet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, TProperty value);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use the new syntax, which allows you to pass the value in the expression itself, mock.VerifySet(m => m.Value = 25);", "True")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, TProperty value);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use the new syntax, which allows you to pass the value in the expression itself, mock.VerifySet(m => m.Value = 25, failMessage);", "True")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, TProperty value, string failMessage);
}
public class Moq.MockRepository : MockFactory {
    public MockRepository(MockBehavior defaultBehavior);
    public IQueryable`1<T> Of();
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public IQueryable`1<T> Of(Expression`1<Func`2<T, bool>> specification);
    [EditorBrowsableAttribute("1")]
public T OneOf();
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
[EditorBrowsableAttribute("1")]
public T OneOf(Expression`1<Func`2<T, bool>> specification);
    internal IQueryable`1<T> CreateMockQuery();
    internal IQueryable`1<T> CreateQueryable();
    [IteratorStateMachineAttribute("Moq.MockRepository/<CreateMocks>d__6`1")]
private IEnumerable`1<T> CreateMocks();
}
public static class Moq.Mocks : object {
    public static IQueryable`1<T> Of();
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static IQueryable`1<T> Of(Expression`1<Func`2<T, bool>> specification);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Moved to Mock.Of<T>, as it's a single one, so no reason to be on Mocks.", "True")]
public static T OneOf();
    [SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Moved to Mock.Of<T>, as it's a single one, so no reason to be on Mocks.", "True")]
public static T OneOf(Expression`1<Func`2<T, bool>> specification);
    internal static IQueryable`1<T> CreateMockQuery();
    internal static IQueryable`1<T> CreateQueryable();
    [IteratorStateMachineAttribute("Moq.Mocks/<CreateMocks>d__6`1")]
private static IEnumerable`1<T> CreateMocks();
    internal static bool SetPropery(Mock`1<T> target, Expression`1<Func`2<T, TResult>> propertyReference, TResult value);
}
public class Moq.MockSequence : object {
    private int sequenceStep;
    private int sequenceLength;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
private bool <Cyclic>k__BackingField;
    public bool Cyclic { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Cyclic();
    [CompilerGeneratedAttribute]
public void set_Cyclic(bool value);
    private void NextStep();
    internal ISetupConditionResult`1<TMock> For(Mock`1<TMock> mock);
}
[ExtensionAttribute]
public static class Moq.MockSequenceHelper : object {
    [ExtensionAttribute]
public static ISetupConditionResult`1<TMock> InSequence(Mock`1<TMock> mock, MockSequence sequence);
}
internal class Moq.MockVerificationException : MockException {
    private IProxyCall[] failedSetups;
    public MockVerificationException(IProxyCall[] failedSetups);
    protected MockVerificationException(SerializationInfo info, StreamingContext context);
    private static string GetMessage(IProxyCall[] failedSetups);
    private static string GetRawSetups(IProxyCall[] failedSetups);
    internal string GetRawSetups();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Moq.ObsoleteMockExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by SetupSet(Action)")]
public static ISetupSetter`2<T, TProperty> SetupSet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by VerifySet(Action)")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by  VerifySet(Action, string)")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, string failMessage);
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by  VerifySet(Action, Times)")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, Times times);
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by  VerifySet(Action, Times, string)")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, Times times, string failMessage);
}
[__ProtectAttribute]
[DebuggerStepThroughAttribute]
internal static class Moq.PexProtector : object {
    public static void Invoke(Action action);
    public static T Invoke(Func`1<T> function);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Moq.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AlreadyInitialized { get; }
    internal static string ArgumentCannotBeEmpty { get; }
    internal static string AsMustBeInterface { get; }
    internal static string CantSetReturnValueForVoid { get; }
    internal static string ConstructorArgsForDelegate { get; }
    internal static string ConstructorArgsForInterface { get; }
    internal static string ConstructorNotFound { get; }
    internal static string EventNofFound { get; }
    internal static string FieldsNotSupported { get; }
    internal static string InvalidMockClass { get; }
    internal static string InvalidMockGetType { get; }
    internal static string LinqBinaryOperatorNotSupported { get; }
    internal static string LinqMethodNotSupported { get; }
    internal static string LinqMethodNotVirtual { get; }
    internal static string MemberMissing { get; }
    internal static string MethodIsPublic { get; }
    internal static string MockExceptionMessage { get; }
    internal static string MoreThanNCalls { get; }
    internal static string MoreThanOneCall { get; }
    internal static string NoMatchingCallsAtLeast { get; }
    internal static string NoMatchingCallsAtLeastOnce { get; }
    internal static string NoMatchingCallsAtMost { get; }
    internal static string NoMatchingCallsAtMostOnce { get; }
    internal static string NoMatchingCallsBetweenExclusive { get; }
    internal static string NoMatchingCallsBetweenInclusive { get; }
    internal static string NoMatchingCallsExactly { get; }
    internal static string NoMatchingCallsNever { get; }
    internal static string NoMatchingCallsOnce { get; }
    internal static string NoSetup { get; }
    internal static string ObjectInstanceNotMock { get; }
    internal static string OutExpressionMustBeConstantValue { get; }
    internal static string PropertyGetNotFound { get; }
    internal static string PropertyMissing { get; }
    internal static string PropertyNotReadable { get; }
    internal static string PropertyNotWritable { get; }
    internal static string PropertySetNotFound { get; }
    internal static string RaisedUnassociatedEvent { get; }
    internal static string RefExpressionMustBeConstantValue { get; }
    internal static string ReturnValueRequired { get; }
    internal static string SetupLambda { get; }
    internal static string SetupNever { get; }
    internal static string SetupNotMethod { get; }
    internal static string SetupNotProperty { get; }
    internal static string SetupNotSetter { get; }
    internal static string SetupOnNonMemberMethod { get; }
    internal static string SetupOnNonOverridableMember { get; }
    internal static string TypeNotImplementInterface { get; }
    internal static string TypeNotInheritFromType { get; }
    internal static string UnexpectedPublicProperty { get; }
    internal static string UnsupportedExpression { get; }
    internal static string UnsupportedIntermediateExpression { get; }
    internal static string UnsupportedIntermediateType { get; }
    internal static string UnsupportedMatcherParamsForSetter { get; }
    internal static string UnsupportedMember { get; }
    internal static string UnsupportedNonStaticMatcherForSetter { get; }
    internal static string VerficationFailed { get; }
    internal static string VerifyOnNonVirtualMember { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AlreadyInitialized();
    internal static string get_ArgumentCannotBeEmpty();
    internal static string get_AsMustBeInterface();
    internal static string get_CantSetReturnValueForVoid();
    internal static string get_ConstructorArgsForDelegate();
    internal static string get_ConstructorArgsForInterface();
    internal static string get_ConstructorNotFound();
    internal static string get_EventNofFound();
    internal static string get_FieldsNotSupported();
    internal static string get_InvalidMockClass();
    internal static string get_InvalidMockGetType();
    internal static string get_LinqBinaryOperatorNotSupported();
    internal static string get_LinqMethodNotSupported();
    internal static string get_LinqMethodNotVirtual();
    internal static string get_MemberMissing();
    internal static string get_MethodIsPublic();
    internal static string get_MockExceptionMessage();
    internal static string get_MoreThanNCalls();
    internal static string get_MoreThanOneCall();
    internal static string get_NoMatchingCallsAtLeast();
    internal static string get_NoMatchingCallsAtLeastOnce();
    internal static string get_NoMatchingCallsAtMost();
    internal static string get_NoMatchingCallsAtMostOnce();
    internal static string get_NoMatchingCallsBetweenExclusive();
    internal static string get_NoMatchingCallsBetweenInclusive();
    internal static string get_NoMatchingCallsExactly();
    internal static string get_NoMatchingCallsNever();
    internal static string get_NoMatchingCallsOnce();
    internal static string get_NoSetup();
    internal static string get_ObjectInstanceNotMock();
    internal static string get_OutExpressionMustBeConstantValue();
    internal static string get_PropertyGetNotFound();
    internal static string get_PropertyMissing();
    internal static string get_PropertyNotReadable();
    internal static string get_PropertyNotWritable();
    internal static string get_PropertySetNotFound();
    internal static string get_RaisedUnassociatedEvent();
    internal static string get_RefExpressionMustBeConstantValue();
    internal static string get_ReturnValueRequired();
    internal static string get_SetupLambda();
    internal static string get_SetupNever();
    internal static string get_SetupNotMethod();
    internal static string get_SetupNotProperty();
    internal static string get_SetupNotSetter();
    internal static string get_SetupOnNonMemberMethod();
    internal static string get_SetupOnNonOverridableMember();
    internal static string get_TypeNotImplementInterface();
    internal static string get_TypeNotInheritFromType();
    internal static string get_UnexpectedPublicProperty();
    internal static string get_UnsupportedExpression();
    internal static string get_UnsupportedIntermediateExpression();
    internal static string get_UnsupportedIntermediateType();
    internal static string get_UnsupportedMatcherParamsForSetter();
    internal static string get_UnsupportedMember();
    internal static string get_UnsupportedNonStaticMatcherForSetter();
    internal static string get_VerficationFailed();
    internal static string get_VerifyOnNonVirtualMember();
}
public interface Moq.Protected.IProtectedMock`1 {
    public abstract virtual ISetup`1<TMock> Setup(string voidMethodName, Object[] args);
    public abstract virtual ISetup`2<TMock, TResult> Setup(string methodOrPropertyName, Object[] args);
    public abstract virtual ISetupGetter`2<TMock, TProperty> SetupGet(string propertyName);
    public abstract virtual ISetupSetter`2<TMock, TProperty> SetupSet(string propertyName, object value);
    public abstract virtual void Verify(string methodName, Times times, Object[] args);
    [SuppressMessageAttribute("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
public abstract virtual void Verify(string methodName, Times times, Object[] args);
    [SuppressMessageAttribute("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
public abstract virtual void VerifyGet(string propertyName, Times times);
    [SuppressMessageAttribute("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
public abstract virtual void VerifySet(string propertyName, Times times, object value);
}
[SuppressMessageAttribute("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly")]
public static class Moq.Protected.ItExpr : object {
    [SuppressMessageAttribute("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
[SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static Expression IsNull();
    [SuppressMessageAttribute("Microsoft.Design", "CA1004:GenericMethodsShouldProvideTypeParameter")]
[SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static Expression IsAny();
    [AdvancedMatcherAttribute("Moq.Matchers.PredicateMatcher")]
[SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static Expression Is(Expression`1<Func`2<TValue, bool>> match);
    public static Expression IsInRange(TValue from, TValue to, Range rangeKind);
    public static Expression IsRegex(string regex);
    public static Expression IsRegex(string regex, RegexOptions options);
}
[ExtensionAttribute]
public static class Moq.Protected.ProtectedExtension : object {
    [ExtensionAttribute]
public static IProtectedMock`1<T> Protected(Mock`1<T> mock);
}
internal class Moq.Protected.ProtectedMock`1 : object {
    private Mock`1<T> mock;
    public ProtectedMock`1(Mock`1<T> mock);
    public sealed virtual ISetup`1<T> Setup(string methodName, Object[] args);
    public sealed virtual ISetup`2<T, TResult> Setup(string methodName, Object[] args);
    public sealed virtual ISetupGetter`2<T, TProperty> SetupGet(string propertyName);
    public sealed virtual ISetupSetter`2<T, TProperty> SetupSet(string propertyName, object value);
    public sealed virtual void Verify(string methodName, Times times, Object[] args);
    public sealed virtual void Verify(string methodName, Times times, Object[] args);
    public sealed virtual void VerifyGet(string propertyName, Times times);
    public sealed virtual void VerifySet(string propertyName, Times times, object value);
    private static Expression`1<Func`2<T, TResult>> GetMemberAccess(PropertyInfo property);
    private static MethodInfo GetMethod(string methodName, Object[] args);
    private static Expression`1<Func`2<T, TResult>> GetMethodCall(MethodInfo method, Object[] args);
    private static Expression`1<Action`1<T>> GetMethodCall(MethodInfo method, Object[] args);
    private static PropertyInfo GetProperty(string propertyName);
    private static Action`1<T> GetSetterExpression(PropertyInfo property, Expression value);
    private static void ThrowIfNonVirtual(MethodInfo method, string reflectedTypeName);
    private static void ThrowIfMemberMissing(string memberName, MemberInfo member);
    private static void ThrowIfPublicMethod(MethodInfo method, string reflectedTypeName);
    private static void ThrowIfPublicGetter(PropertyInfo property, string reflectedTypeName);
    private static void ThrowIfPublicSetter(PropertyInfo property, string reflectedTypeName);
    private static void ThrowIfVoidMethod(MethodInfo method);
    private static Type[] ToArgTypes(Object[] args);
    private static Expression ToExpressionArg(ParameterInfo paramInfo, object arg);
    [IteratorStateMachineAttribute("Moq.Protected.ProtectedMock`1/<ToExpressionArgs>d__24")]
private static IEnumerable`1<Expression> ToExpressionArgs(MethodInfo method, Object[] args);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
internal class Moq.Proxy.CastleProxyFactory : object {
    private static ProxyGenerator generator;
    private static Dictionary`2<Type, Type> delegateInterfaceCache;
    private static ProxyGenerationOptions proxyOptions;
    private static int delegateInterfaceSuffix;
    [SuppressMessageAttribute("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
private static CastleProxyFactory();
    public sealed virtual object CreateProxy(Type mockType, ICallInterceptor interceptor, Type[] interfaces, Object[] arguments);
    public sealed virtual Type GetDelegateProxyInterface(Type delegateType, MethodInfo& delegateInterfaceMethod);
    private static ProxyGenerator CreateProxyGenerator();
}
internal interface Moq.Proxy.ICallContext {
    public Object[] Arguments { get; }
    public MethodInfo Method { get; }
    public object ReturnValue { get; public set; }
    public abstract virtual Object[] get_Arguments();
    public abstract virtual MethodInfo get_Method();
    public abstract virtual object get_ReturnValue();
    public abstract virtual void set_ReturnValue(object value);
    public abstract virtual void InvokeBase();
    public abstract virtual void SetArgumentValue(int index, object value);
}
internal interface Moq.Proxy.ICallInterceptor {
    public abstract virtual void Intercept(ICallContext context);
}
internal interface Moq.Proxy.IProxyFactory {
    public abstract virtual object CreateProxy(Type mockType, ICallInterceptor interceptor, Type[] interfaces, Object[] arguments);
    public abstract virtual Type GetDelegateProxyInterface(Type delegateType, MethodInfo& delegateInterfaceMethod);
}
internal class Moq.Proxy.ProxyMethodHook : AllMethodsHook {
    protected static HashSet`1<Tuple`2<Type, string>> GrantedMethods;
    private static ProxyMethodHook();
    public virtual bool ShouldInterceptMethod(Type type, MethodInfo methodInfo);
}
[ExtensionAttribute]
internal static class Moq.QueryableMockExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static Mock`1<TResult> FluentMock(Mock`1<T> mock, Expression`1<Func`2<T, TResult>> setup);
}
public enum Moq.Range : Enum {
    public int value__;
    public static Range Inclusive;
    public static Range Exclusive;
}
[ExtensionAttribute]
public static class Moq.ReturnsExtensions : object {
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, TResult value);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`1<TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Exception exception);
}
[ExtensionAttribute]
public static class Moq.SequenceExtensions : object {
    [ExtensionAttribute]
[SuppressMessageAttribute("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
public static ISetupSequentialResult`1<TResult> SetupSequence(Mock`1<TMock> mock, Expression`1<Func`2<TMock, TResult>> expression);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<Task`1<TResult>> ReturnsAsync(ISetupSequentialResult`1<Task`1<TResult>> setup, TResult value);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<Task`1<TResult>> ThrowsAsync(ISetupSequentialResult`1<Task`1<TResult>> setup, Exception exception);
}
internal class Moq.SerializableTypesValueProvider : object {
    private IDefaultValueProvider decorated;
    private EmptyDefaultValueProvider emptyDefaultValueProvider;
    public SerializableTypesValueProvider(IDefaultValueProvider decorated);
    public sealed virtual void DefineDefault(T value);
    public sealed virtual object ProvideDefault(MethodInfo member);
}
internal class Moq.SetterMethodCall`2 : MethodCall`1<TMock> {
    public SetterMethodCall`2(Mock mock, Expression originalExpression, MethodInfo method);
    public SetterMethodCall`2(Mock mock, Expression originalExpression, MethodInfo method, TProperty value);
    public SetterMethodCall`2(Mock mock, Condition condition, Expression originalExpression, MethodInfo method, Expression value);
    public sealed virtual ICallbackResult Callback(Action`1<TProperty> callback);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
internal enum Moq.SetupKind : Enum {
    public int value__;
    public static SetupKind PropertySet;
    public static SetupKind Other;
}
internal class Moq.SetupSequentialContext`2 : object {
    private int currentStep;
    private int expectationsCount;
    private Mock`1<TMock> mock;
    private Expression`1<Func`2<TMock, TResult>> expression;
    private Action callbackAction;
    public SetupSequentialContext`2(Mock`1<TMock> mock, Expression`1<Func`2<TMock, TResult>> expression);
    public sealed virtual ISetupSequentialResult`1<TResult> CallBase();
    private ISetup`2<TMock, TResult> GetSetup();
    private void EndSetup(ICallback callback);
    private void EndSetup(ICallback`2<TMock, TResult> callback);
    public sealed virtual ISetupSequentialResult`1<TResult> Returns(TResult value);
    public sealed virtual ISetupSequentialResult`1<TResult> Throws(Exception exception);
    public sealed virtual ISetupSequentialResult`1<TResult> Throws();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0();
}
[ExtensionAttribute]
internal static class Moq.StringExtensions : object {
    [ExtensionAttribute]
public static String[] Lines(string source);
    [ExtensionAttribute]
public static string AsCommaSeparatedValues(IEnumerable`1<string> source);
}
public class Moq.Times : ValueType {
    private Func`2<int, bool> evaluator;
    private string messageFormat;
    private int from;
    private int to;
    private Times(Func`2<int, bool> evaluator, int from, int to, string messageFormat);
    public static Times AtLeast(int callCount);
    public static Times AtLeastOnce();
    public static Times AtMost(int callCount);
    public static Times AtMostOnce();
    public static Times Between(int callCountFrom, int callCountTo, Range rangeKind);
    public static Times Exactly(int callCount);
    public static Times Never();
    public static Times Once();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Times left, Times right);
    public static bool op_Inequality(Times left, Times right);
    internal string GetExceptionMessage(string failMessage, string expression, int callCount);
    internal bool Verify(int callCount);
}
internal class Moq.TypeEqualityComparer : object {
    public sealed virtual bool Equals(Type x, Type y);
    public sealed virtual int GetHashCode(Type obj);
}
[ExtensionAttribute]
internal static class Moq.TypeExtensions : object {
    [ExtensionAttribute]
public static string DisplayName(Type source, Func`2<Type, string> getName);
}
internal static class ThisAssembly : object {
}
