internal class SharpYaml.CharacterAnalyzer`1 : object {
    private TBuffer buffer;
    public TBuffer Buffer { get; }
    public bool EndOfInput { get; }
    public CharacterAnalyzer`1(TBuffer buffer);
    public TBuffer get_Buffer();
    public bool get_EndOfInput();
    public char Peek(int offset);
    public void Skip(int length);
    public bool IsAlpha(int offset);
    public bool IsAlpha();
    public bool IsAscii(int offset);
    public bool IsAscii();
    public bool IsPrintable(int offset);
    public bool IsPrintable();
    public bool IsDigit(int offset);
    public bool IsDigit();
    public int AsDigit(int offset);
    public int AsDigit();
    public bool IsHex(int offset);
    public int AsHex(int offset);
    public bool IsSpace(int offset);
    public bool IsSpace();
    public bool IsZero(int offset);
    public bool IsZero();
    public bool IsTab(int offset);
    public bool IsTab();
    public bool IsBlank(int offset);
    public bool IsBlank();
    public bool IsBreak(int offset);
    public bool IsBreak();
    public bool IsCrLf(int offset);
    public bool IsCrLf();
    public bool IsBreakOrZero(int offset);
    public bool IsBreakOrZero();
    public bool IsBlankOrBreakOrZero(int offset);
    public bool IsBlankOrBreakOrZero();
    public bool Check(char expected);
    public bool Check(char expected, int offset);
    public bool Check(string expectedCharacters);
    public bool Check(string expectedCharacters, int offset);
}
internal static class SharpYaml.CharHelper : object {
    internal static char HIGH_SURROGATE_START;
    internal static char HIGH_SURROGATE_END;
    internal static char LOW_SURROGATE_START;
    internal static char LOW_SURROGATE_END;
    internal static int UNICODE_PLANE01_START;
    internal static int UNICODE_PLANE00_END;
    internal static int UNICODE_PLANE16_END;
    public static bool IsHighSurrogate(char c);
    public static bool IsLowSurrogate(char c);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static string ConvertFromUtf32(int utf32);
}
internal static class SharpYaml.Constants : object {
    public static TagDirective[] DefaultTagDirectives;
    public static int MajorVersion;
    public static int MinorVersion;
    public static char HandleCharacter;
    public static string DefaultHandle;
    private static Constants();
}
public class SharpYaml.Emitter : object {
    private TextWriter output;
    private bool isCanonical;
    private int bestIndent;
    private int bestWidth;
    private EmitterState state;
    private Stack`1<EmitterState> states;
    private Queue`1<ParsingEvent> events;
    private Stack`1<int> indents;
    private TagDirectiveCollection tagDirectives;
    private int indent;
    private int flowLevel;
    private bool isMappingContext;
    private bool isSimpleKeyContext;
    private bool isRootContext;
    private int line;
    private int column;
    private bool isWhitespace;
    private bool isIndentation;
    private bool forceIndentLess;
    private bool isOpenEnded;
    private AnchorData anchorData;
    private TagData tagData;
    private bool isUnicode;
    private ScalarData scalarData;
    internal static int MinBestIndent;
    internal static int MaxBestIndent;
    private static Regex uriReplacer;
    private static int MaxAliasLength;
    public bool ForceIndentLess { get; public set; }
    public Emitter(TextWriter output, int bestIndent, int bestWidth, bool isCanonical, bool forceIndentLess);
    private static Emitter();
    public bool get_ForceIndentLess();
    public void set_ForceIndentLess(bool value);
    private void Write(char value);
    private void Write(string value);
    private void WriteBreak();
    public sealed virtual void Emit(ParsingEvent event);
    private bool NeedMoreEvents();
    private void AnalyzeAnchor(string anchor, bool isAlias);
    private void AnalyzeEvent(ParsingEvent evt);
    private void AnalyzeScalar(string value);
    private void AnalyzeTag(string tag);
    private void StateMachine(ParsingEvent evt);
    private void EmitStreamStart(ParsingEvent evt);
    private void EmitDocumentStart(ParsingEvent evt, bool isFirst);
    private bool CheckEmptyDocument();
    private void WriteTagHandle(string value);
    private static string UrlEncode(string text);
    private void WriteTagContent(string value, bool needsWhitespace);
    private void AppendTagDirective(TagDirective value, bool allowDuplicates);
    private static void AnalyzeVersionDirective(VersionDirective versionDirective);
    private void WriteIndicator(string indicator, bool needWhitespace, bool whitespace, bool indentation);
    private void WriteIndent();
    private void EmitDocumentContent(ParsingEvent evt);
    private void EmitNode(ParsingEvent evt, bool isRoot, bool isMapping, bool isSimpleKey);
    private void EmitSequenceStart(ParsingEvent evt);
    private bool CheckEmptySequence();
    private bool CheckEmptyMapping();
    private void ProcessTag();
    private void EmitMappingStart(ParsingEvent evt);
    private void EmitScalar(ParsingEvent evt);
    private void ProcessScalar();
    private static bool IsBreak(char character);
    private static bool IsBlank(char character);
    private static bool IsSpace(char character);
    internal static bool IsPrintable(char character);
    private void WriteFoldedScalar(string value);
    private void WriteLiteralScalar(string value);
    private void WriteDoubleQuotedScalar(string value, bool allowBreaks);
    private void WriteSingleQuotedScalar(string value, bool allowBreaks);
    private void WritePlainScalar(string value, bool allowBreaks);
    private void IncreaseIndent(bool isFlow, bool isIndentless);
    private void SelectScalarStyle(ParsingEvent evt);
    private void EmitAlias();
    private void ProcessAnchor();
    private void WriteAnchor(string value);
    private void EmitDocumentEnd(ParsingEvent evt);
    private void EmitFlowSequenceItem(ParsingEvent evt, bool isFirst);
    private void EmitFlowMappingKey(ParsingEvent evt, bool isFirst);
    private static int SafeStringLength(string value);
    private bool CheckSimpleKey();
    private void EmitFlowMappingValue(ParsingEvent evt, bool isSimple);
    private void EmitBlockSequenceItem(ParsingEvent evt, bool isFirst);
    private void EmitBlockMappingKey(ParsingEvent evt, bool isFirst);
    private void EmitBlockMappingValue(ParsingEvent evt, bool isSimple);
    private void WriteBlockScalarHints(string value);
}
internal enum SharpYaml.EmitterState : Enum {
    public int value__;
    public static EmitterState YAML_EMIT_STREAM_START_STATE;
    public static EmitterState YAML_EMIT_FIRST_DOCUMENT_START_STATE;
    public static EmitterState YAML_EMIT_DOCUMENT_START_STATE;
    public static EmitterState YAML_EMIT_DOCUMENT_CONTENT_STATE;
    public static EmitterState YAML_EMIT_DOCUMENT_END_STATE;
    public static EmitterState YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE;
    public static EmitterState YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE;
    public static EmitterState YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE;
    public static EmitterState YAML_EMIT_FLOW_MAPPING_KEY_STATE;
    public static EmitterState YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE;
    public static EmitterState YAML_EMIT_FLOW_MAPPING_VALUE_STATE;
    public static EmitterState YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE;
    public static EmitterState YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE;
    public static EmitterState YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE;
    public static EmitterState YAML_EMIT_BLOCK_MAPPING_KEY_STATE;
    public static EmitterState YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE;
    public static EmitterState YAML_EMIT_BLOCK_MAPPING_VALUE_STATE;
    public static EmitterState YAML_EMIT_END_STATE;
}
public class SharpYaml.EventReader : object {
    private IParser parser;
    private bool endOfStream;
    private int currentDepth;
    public IParser Parser { get; }
    public int CurrentDepth { get; }
    public EventReader(IParser parser);
    public IParser get_Parser();
    public int get_CurrentDepth();
    public T Expect();
    private void MoveNext();
    public bool Accept();
    public T Allow();
    public T Peek();
    public void Skip();
    public void Skip(int untilDepth);
    private void EnsureNotAtEndOfStream();
}
public class SharpYaml.Events.AnchorAlias : ParsingEvent {
    private string value;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public string Value { get; }
    public AnchorAlias(string value, Mark start, Mark end);
    public AnchorAlias(string value);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public string get_Value();
    public virtual string ToString();
}
public class SharpYaml.Events.DocumentEnd : ParsingEvent {
    private bool isImplicit;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public bool IsImplicit { get; }
    public DocumentEnd(bool isImplicit, Mark start, Mark end);
    public DocumentEnd(bool isImplicit);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public bool get_IsImplicit();
    public virtual string ToString();
}
public class SharpYaml.Events.DocumentStart : ParsingEvent {
    private TagDirectiveCollection tags;
    private VersionDirective version;
    private bool isImplicit;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public TagDirectiveCollection Tags { get; }
    public VersionDirective Version { get; }
    public bool IsImplicit { get; }
    public DocumentStart(VersionDirective version, TagDirectiveCollection tags, bool isImplicit, Mark start, Mark end);
    public DocumentStart(VersionDirective version, TagDirectiveCollection tags, bool isImplicit);
    public DocumentStart(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public TagDirectiveCollection get_Tags();
    public VersionDirective get_Version();
    public bool get_IsImplicit();
    public virtual string ToString();
}
internal enum SharpYaml.Events.EventType : Enum {
    public int value__;
    public static EventType YAML_NO_EVENT;
    public static EventType YAML_STREAM_START_EVENT;
    public static EventType YAML_STREAM_END_EVENT;
    public static EventType YAML_DOCUMENT_START_EVENT;
    public static EventType YAML_DOCUMENT_END_EVENT;
    public static EventType YAML_ALIAS_EVENT;
    public static EventType YAML_SCALAR_EVENT;
    public static EventType YAML_SEQUENCE_START_EVENT;
    public static EventType YAML_SEQUENCE_END_EVENT;
    public static EventType YAML_MAPPING_START_EVENT;
    public static EventType YAML_MAPPING_END_EVENT;
}
public class SharpYaml.Events.MappingEnd : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public MappingEnd(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
}
public class SharpYaml.Events.MappingStart : NodeEvent {
    private bool isImplicit;
    private YamlStyle style;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public bool IsImplicit { get; }
    public bool IsCanonical { get; }
    public YamlStyle Style { get; }
    public MappingStart(string anchor, string tag, bool isImplicit, YamlStyle style, Mark start, Mark end);
    public MappingStart(string anchor, string tag, bool isImplicit, YamlStyle style);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public bool get_IsImplicit();
    public virtual bool get_IsCanonical();
    public YamlStyle get_Style();
    public virtual string ToString();
}
public abstract class SharpYaml.Events.NodeEvent : ParsingEvent {
    internal static Regex anchorValidator;
    private string anchor;
    private string tag;
    public string Anchor { get; }
    public string Tag { get; }
    public bool IsCanonical { get; }
    protected NodeEvent(string anchor, string tag, Mark start, Mark end);
    protected NodeEvent(string anchor, string tag);
    private static NodeEvent();
    public string get_Anchor();
    public string get_Tag();
    public abstract virtual bool get_IsCanonical();
}
public abstract class SharpYaml.Events.ParsingEvent : object {
    private Mark start;
    private Mark end;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public Mark Start { get; }
    public Mark End { get; }
    internal ParsingEvent(Mark start, Mark end);
    public abstract virtual int get_NestingIncrease();
    internal abstract virtual EventType get_Type();
    public Mark get_Start();
    public Mark get_End();
}
public class SharpYaml.Events.Scalar : NodeEvent {
    private string value;
    private ScalarStyle style;
    private bool isPlainImplicit;
    private bool isQuotedImplicit;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public string Value { get; public set; }
    public ScalarStyle Style { get; }
    public bool IsPlainImplicit { get; }
    public bool IsQuotedImplicit { get; }
    public bool IsCanonical { get; }
    public Scalar(string anchor, string tag, string value, ScalarStyle style, bool isPlainImplicit, bool isQuotedImplicit, Mark start, Mark end);
    public Scalar(string anchor, string tag, string value, ScalarStyle style, bool isPlainImplicit, bool isQuotedImplicit);
    public Scalar(string value);
    public Scalar(string value, ScalarStyle style);
    public Scalar(string tag, string value);
    public Scalar(string anchor, string tag, string value);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public string get_Value();
    public void set_Value(string value);
    public ScalarStyle get_Style();
    public bool get_IsPlainImplicit();
    public bool get_IsQuotedImplicit();
    public virtual bool get_IsCanonical();
    public virtual string ToString();
}
public class SharpYaml.Events.SequenceEnd : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public SequenceEnd(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
}
public class SharpYaml.Events.SequenceStart : NodeEvent {
    private bool isImplicit;
    private YamlStyle style;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public bool IsImplicit { get; }
    public bool IsCanonical { get; }
    public YamlStyle Style { get; }
    public SequenceStart(string anchor, string tag, bool isImplicit, YamlStyle style, Mark start, Mark end);
    public SequenceStart(string anchor, string tag, bool isImplicit, YamlStyle style);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public bool get_IsImplicit();
    public virtual bool get_IsCanonical();
    public YamlStyle get_Style();
    public virtual string ToString();
}
public class SharpYaml.Events.StreamEnd : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public StreamEnd(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
}
public class SharpYaml.Events.StreamStart : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public StreamStart(Mark start, Mark end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class SharpYaml.FakeList`1 : object {
    private IEnumerator`1<T> collection;
    private int currentIndex;
    public T Item { get; }
    public FakeList`1(IEnumerator`1<T> collection);
    public FakeList`1(IEnumerable`1<T> collection);
    public T get_Item(int index);
}
public interface SharpYaml.IEmitter {
    public abstract virtual void Emit(ParsingEvent event);
}
internal interface SharpYaml.ILookAheadBuffer {
    public bool EndOfInput { get; }
    public abstract virtual bool get_EndOfInput();
    public abstract virtual char Peek(int offset);
    public abstract virtual void Skip(int length);
}
public class SharpYaml.InsertionQueue`1 : object {
    private IList`1<T> items;
    public int Count { get; }
    public int get_Count();
    public void Enqueue(T item);
    public T Dequeue();
    public void Insert(int index, T item);
}
public interface SharpYaml.IParser {
    public ParsingEvent Current { get; }
    public abstract virtual ParsingEvent get_Current();
    public abstract virtual bool MoveNext();
}
public class SharpYaml.LookAheadBuffer : object {
    private TextReader input;
    private Char[] buffer;
    private int firstIndex;
    private int count;
    private bool endOfInput;
    public bool EndOfInput { get; }
    public LookAheadBuffer(TextReader input, int capacity);
    public sealed virtual bool get_EndOfInput();
    private int GetIndexForOffset(int offset);
    public sealed virtual char Peek(int offset);
    public void Cache(int length);
    public sealed virtual void Skip(int length);
}
public class SharpYaml.Mark : ValueType {
    private int index;
    private int line;
    private int column;
    public static Mark Empty;
    public int Index { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public int get_Index();
    public void set_Index(int value);
    public int get_Line();
    public void set_Line(int value);
    public int get_Column();
    public void set_Column(int value);
    public virtual string ToString();
}
public class SharpYaml.MemoryParser : object {
    private IEnumerator`1<ParsingEvent> parsingEvents;
    public ParsingEvent Current { get; }
    public MemoryParser(IEnumerable`1<ParsingEvent> parsingEvents);
    public sealed virtual ParsingEvent get_Current();
    public sealed virtual bool MoveNext();
}
public class SharpYaml.Parser : object {
    private Stack`1<ParserState> states;
    private TagDirectiveCollection tagDirectives;
    private ParserState state;
    private Scanner scanner;
    private ParsingEvent current;
    private Token currentToken;
    public ParsingEvent Current { get; }
    public Parser(TextReader input);
    private Token GetCurrentToken();
    public sealed virtual ParsingEvent get_Current();
    public sealed virtual bool MoveNext();
    private ParsingEvent StateMachine();
    private void Skip();
    private ParsingEvent ParseStreamStart();
    private ParsingEvent ParseDocumentStart(bool isImplicit);
    private VersionDirective ProcessDirectives(TagDirectiveCollection tags);
    private static void AddDefaultTagDirectives(TagDirectiveCollection directives);
    private ParsingEvent ParseDocumentContent();
    private static ParsingEvent ProcessEmptyScalar(Mark position);
    private ParsingEvent ParseNode(bool isBlock, bool isIndentlessSequence);
    private ParsingEvent ParseDocumentEnd();
    private ParsingEvent ParseBlockSequenceEntry(bool isFirst);
    private ParsingEvent ParseIndentlessSequenceEntry();
    private ParsingEvent ParseBlockMappingKey(bool isFirst);
    private ParsingEvent ParseBlockMappingValue();
    private ParsingEvent ParseFlowSequenceEntry(bool isFirst);
    private ParsingEvent ParseFlowSequenceEntryMappingKey();
    private ParsingEvent ParseFlowSequenceEntryMappingValue();
    private ParsingEvent ParseFlowSequenceEntryMappingEnd();
    private ParsingEvent ParseFlowMappingKey(bool isFirst);
    private ParsingEvent ParseFlowMappingValue(bool isEmpty);
}
internal enum SharpYaml.ParserState : Enum {
    public int value__;
    public static ParserState YAML_PARSE_STREAM_START_STATE;
    public static ParserState YAML_PARSE_IMPLICIT_DOCUMENT_START_STATE;
    public static ParserState YAML_PARSE_DOCUMENT_START_STATE;
    public static ParserState YAML_PARSE_DOCUMENT_CONTENT_STATE;
    public static ParserState YAML_PARSE_DOCUMENT_END_STATE;
    public static ParserState YAML_PARSE_BLOCK_NODE_STATE;
    public static ParserState YAML_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE;
    public static ParserState YAML_PARSE_FLOW_NODE_STATE;
    public static ParserState YAML_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE;
    public static ParserState YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE;
    public static ParserState YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE;
    public static ParserState YAML_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE;
    public static ParserState YAML_PARSE_BLOCK_MAPPING_KEY_STATE;
    public static ParserState YAML_PARSE_BLOCK_MAPPING_VALUE_STATE;
    public static ParserState YAML_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE;
    public static ParserState YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE;
    public static ParserState YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE;
    public static ParserState YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE;
    public static ParserState YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE;
    public static ParserState YAML_PARSE_FLOW_MAPPING_FIRST_KEY_STATE;
    public static ParserState YAML_PARSE_FLOW_MAPPING_KEY_STATE;
    public static ParserState YAML_PARSE_FLOW_MAPPING_VALUE_STATE;
    public static ParserState YAML_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE;
    public static ParserState YAML_PARSE_END_STATE;
}
public enum SharpYaml.ScalarStyle : Enum {
    public int value__;
    public static ScalarStyle Any;
    public static ScalarStyle Plain;
    public static ScalarStyle SingleQuoted;
    public static ScalarStyle DoubleQuoted;
    public static ScalarStyle Literal;
    public static ScalarStyle Folded;
}
public class SharpYaml.Scanner : object {
    private static int MaxVersionNumberLength;
    private Stack`1<int> indents;
    private InsertionQueue`1<Token> tokens;
    private Stack`1<SimpleKey> simpleKeys;
    private StringBuilder scanScalarValue;
    private StringBuilder scanScalarWhitespaces;
    private StringBuilder scanScalarLeadingBreak;
    private StringBuilder scanScalarTrailingBreaks;
    private bool streamStartProduced;
    private bool streamEndProduced;
    private int indent;
    private bool simpleKeyAllowed;
    private Mark mark;
    private int flowLevel;
    private int tokensParsed;
    private static int MaxBufferLength;
    private CharacterAnalyzer`1<LookAheadBuffer> analyzer;
    private bool tokenAvailable;
    private static IDictionary`2<char, char> simpleEscapeCodes;
    private Token current;
    public Mark CurrentPosition { get; }
    public Token Current { get; }
    public Scanner(TextReader input);
    private static Scanner();
    public Mark get_CurrentPosition();
    private static IDictionary`2<char, char> InitializeSimpleEscapeCodes();
    private char ReadCurrentCharacter();
    private char ReadLine();
    public Token get_Current();
    public bool MoveNext();
    internal bool InternalMoveNext();
    internal void ConsumeCurrent();
    private void FetchMoreTokens();
    private static bool StartsWith(StringBuilder what, char start);
    private void StaleSimpleKeys();
    private void FetchNextToken();
    private bool CheckWhiteSpace();
    private bool IsDocumentIndicator();
    private void Skip();
    private void SkipLine();
    private void ScanToNextToken();
    private void FetchStreamStart();
    private void UnrollIndent(int column);
    private void FetchStreamEnd();
    private void FetchDirective();
    private Token ScanDirective();
    private void FetchDocumentIndicator(bool isStartToken);
    private void FetchFlowCollectionStart(bool isSequenceToken);
    private void IncreaseFlowLevel();
    private void FetchFlowCollectionEnd(bool isSequenceToken);
    private void DecreaseFlowLevel();
    private void FetchFlowEntry();
    private void FetchBlockEntry();
    private void FetchKey();
    private void FetchValue();
    private void RollIndent(int column, int number, bool isSequence, Mark position);
    private void FetchAnchor(bool isAlias);
    private Token ScanAnchor(bool isAlias);
    private void FetchTag();
    private Token ScanTag();
    private void FetchBlockScalar(bool isLiteral);
    private Token ScanBlockScalar(bool isLiteral);
    private int ScanBlockScalarBreaks(int currentIndent, StringBuilder breaks, Mark start, Mark& end);
    private void FetchFlowScalar(bool isSingleQuoted);
    private Token ScanFlowScalar(bool isSingleQuoted);
    private void FetchPlainScalar();
    private Token ScanPlainScalar();
    private void RemoveSimpleKey();
    private string ScanDirectiveName(Mark start);
    private void SkipWhitespaces();
    private Token ScanVersionDirectiveValue(Mark start);
    private Token ScanTagDirectiveValue(Mark start);
    private string ScanTagUri(string head, Mark start);
    private string ScanUriEscapes(Mark start);
    private string ScanTagHandle(bool isDirective, Mark start);
    private int ScanVersionDirectiveNumber(Mark start);
    private void SaveSimpleKey();
}
public class SharpYaml.Schemas.CoreSchema : JsonSchema {
    protected virtual void PrepareScalarRules();
}
public class SharpYaml.Schemas.ExtendedSchema : CoreSchema {
    public static string TimestampShortTag;
    public static string TimestampLongTag;
    public static string MergeShortTag;
    public static string MergeLongTag;
    protected virtual void PrepareScalarRules();
    protected virtual void RegisterDefaultTagMappings();
}
public class SharpYaml.Schemas.FailsafeSchema : SchemaBase {
    public static string MapShortTag;
    public static string MapLongTag;
    public static string SeqShortTag;
    public static string SeqLongTag;
    [CompilerGeneratedAttribute]
private bool <AllowFailsafeString>k__BackingField;
    protected bool AllowFailsafeString { get; protected set; }
    [CompilerGeneratedAttribute]
protected bool get_AllowFailsafeString();
    [CompilerGeneratedAttribute]
protected void set_AllowFailsafeString(bool value);
    protected virtual string GetDefaultTag(MappingStart nodeEvent);
    protected virtual string GetDefaultTag(SequenceStart nodeEvent);
    public virtual bool TryParse(Scalar scalar, bool parseValue, String& defaultTag, Object& value);
}
public interface SharpYaml.Schemas.IYamlSchema {
    public abstract virtual string ExpandTag(string shortTag);
    public abstract virtual string ShortenTag(string tag);
    public abstract virtual string GetDefaultTag(NodeEvent nodeEvent);
    public abstract virtual string GetDefaultTag(Type type);
    public abstract virtual bool IsTagImplicit(string tag);
    public abstract virtual bool TryParse(Scalar scalar, bool decodeValue, String& defaultTag, Object& value);
    public abstract virtual bool TryParse(Scalar scalar, Type type, Object& value);
    public abstract virtual Type GetTypeForDefaultTag(string tag);
    public abstract virtual void RegisterTag(string shortTag, string longTag);
}
public class SharpYaml.Schemas.JsonSchema : FailsafeSchema {
    public static string NullShortTag;
    public static string NullLongTag;
    public static string BoolShortTag;
    public static string BoolLongTag;
    public static string IntShortTag;
    public static string IntLongTag;
    public static string FloatShortTag;
    public static string FloatLongTag;
    protected virtual void PrepareScalarRules();
    protected object DecodeInteger(Match m);
    protected virtual void RegisterDefaultTagMappings();
}
public abstract class SharpYaml.Schemas.SchemaBase : object {
    private Dictionary`2<string, string> shortTagToLongTag;
    private Dictionary`2<string, string> longTagToShortTag;
    private List`1<ScalarResolutionRule> scalarTagResolutionRules;
    private Dictionary`2<string, Regex> algorithms;
    private Dictionary`2<string, List`1<ScalarResolutionRule>> mapTagToScalarResolutionRuleList;
    private Dictionary`2<Type, List`1<ScalarResolutionRule>> mapTypeToScalarResolutionRuleList;
    private Dictionary`2<Type, string> mapTypeToShortTag;
    private Dictionary`2<string, Type> mapShortTagToType;
    private int updateCountter;
    private bool needFirstUpdate;
    public static string StrShortTag;
    public static string StrLongTag;
    public sealed virtual string ExpandTag(string shortTag);
    public sealed virtual string ShortenTag(string longTag);
    public sealed virtual string GetDefaultTag(NodeEvent nodeEvent);
    public sealed virtual string GetDefaultTag(Type type);
    public sealed virtual bool IsTagImplicit(string tag);
    public sealed virtual void RegisterTag(string shortTag, string longTag);
    protected abstract virtual string GetDefaultTag(MappingStart nodeEvent);
    protected abstract virtual string GetDefaultTag(SequenceStart nodeEvent);
    public virtual bool TryParse(Scalar scalar, bool parseValue, String& defaultTag, Object& value);
    public sealed virtual bool TryParse(Scalar scalar, Type type, Object& value);
    public sealed virtual Type GetTypeForDefaultTag(string shortTag);
    protected virtual void PrepareScalarRules();
    protected void AddScalarRule(string tag, string regex, Func`2<Match, T> decode, Func`2<T, string> encode);
    protected void AddScalarRule(Type[] types, string tag, string regex, Func`2<Match, object> decode, Func`2<object, string> encode);
    protected void RegisterDefaultTagMapping(string tag, bool isDefault);
    protected void RegisterDefaultTagMapping(string tag, Type type, bool isDefault);
    protected virtual void RegisterDefaultTagMappings();
    private void EnsureScalarRules();
    private void Update();
}
public class SharpYaml.SemanticErrorException : YamlException {
    public SemanticErrorException(string message);
    public SemanticErrorException(Mark start, Mark end, string message);
    public SemanticErrorException(string message, Exception inner);
}
public class SharpYaml.Serialization.AliasEventInfo : EventInfo {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Alias { get; public set; }
    public AliasEventInfo(object sourceValue, Type sourceType);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
}
internal class SharpYaml.Serialization.AnchorEventEmitter : ChainedEventEmitter {
    private List`1<object> events;
    private HashSet`1<string> alias;
    public AnchorEventEmitter(IEventEmitter nextEmitter);
    public virtual void Emit(AliasEventInfo eventInfo);
    public virtual void Emit(ScalarEventInfo eventInfo);
    public virtual void Emit(MappingStartEventInfo eventInfo);
    public virtual void Emit(MappingEndEventInfo eventInfo);
    public virtual void Emit(SequenceStartEventInfo eventInfo);
    public virtual void Emit(SequenceEndEventInfo eventInfo);
    public virtual void Emit(ParsingEvent parsingEvent);
    public virtual void DocumentEnd();
}
public class SharpYaml.Serialization.AnchorNotFoundException : YamlException {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Alias { get; private set; }
    public AnchorNotFoundException(string anchorAlias);
    public AnchorNotFoundException(string anchorAlias, string message);
    public AnchorNotFoundException(string anchorAlias, Mark start, Mark end, string message);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
private void set_Alias(string value);
}
internal class SharpYaml.Serialization.AssemblyRegistry : object {
    private IYamlSchema schema;
    private Dictionary`2<string, MappedType> tagToType;
    private Dictionary`2<Type, string> typeToTag;
    private List`1<Assembly> lookupAssemblies;
    private object lockCache;
    private static List`1<Assembly> DefaultLookupAssemblies;
    [CompilerGeneratedAttribute]
private List`1<IYamlSerializableFactory> <SerializableFactories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseShortTypeName>k__BackingField;
    public List`1<IYamlSerializableFactory> SerializableFactories { get; private set; }
    public bool UseShortTypeName { get; public set; }
    public AssemblyRegistry(IYamlSchema schema);
    private static AssemblyRegistry();
    [CompilerGeneratedAttribute]
public List`1<IYamlSerializableFactory> get_SerializableFactories();
    [CompilerGeneratedAttribute]
private void set_SerializableFactories(List`1<IYamlSerializableFactory> value);
    [CompilerGeneratedAttribute]
public bool get_UseShortTypeName();
    [CompilerGeneratedAttribute]
public void set_UseShortTypeName(bool value);
    public sealed virtual void RegisterAssembly(Assembly assembly, IAttributeRegistry attributeRegistry);
    public virtual void RegisterTagMapping(string tag, Type type, bool alias);
    public virtual Type TypeFromTag(string tag, Boolean& isAlias);
    public virtual string TagFromType(Type type);
    public virtual Type ResolveType(string typeName);
}
public class SharpYaml.Serialization.AttributeRegistry : object {
    private object globalLock;
    private Dictionary`2<MemberInfoKey, List`1<Attribute>> cachedAttributes;
    private Dictionary`2<MemberInfo, List`1<Attribute>> registeredAttributes;
    [CompilerGeneratedAttribute]
private Action`2<ObjectDescriptor, List`1<IMemberDescriptor>> <PrepareMembersCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Attribute, Attribute> <AttributeRemap>k__BackingField;
    public Action`2<ObjectDescriptor, List`1<IMemberDescriptor>> PrepareMembersCallback { get; public set; }
    public Func`2<Attribute, Attribute> AttributeRemap { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Action`2<ObjectDescriptor, List`1<IMemberDescriptor>> get_PrepareMembersCallback();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PrepareMembersCallback(Action`2<ObjectDescriptor, List`1<IMemberDescriptor>> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Attribute, Attribute> get_AttributeRemap();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AttributeRemap(Func`2<Attribute, Attribute> value);
    public virtual List`1<Attribute> GetAttributes(MemberInfo memberInfo, bool inherit);
    public sealed virtual void Register(MemberInfo memberInfo, Attribute attribute);
}
[ExtensionAttribute]
public static class SharpYaml.Serialization.AttributeRegistryExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAttributes(IAttributeRegistry attributeRegistry, MemberInfo memberInfo, bool inherit);
    [ExtensionAttribute]
public static T GetAttribute(IAttributeRegistry attributeRegistry, MemberInfo memberInfo, bool inherit);
}
internal abstract class SharpYaml.Serialization.ChainedEventEmitter : object {
    protected IEventEmitter nextEmitter;
    protected ChainedEventEmitter(IEventEmitter nextEmitter);
    public virtual void StreamStart();
    public virtual void DocumentStart();
    public virtual void Emit(AliasEventInfo eventInfo);
    public virtual void Emit(ScalarEventInfo eventInfo);
    public virtual void Emit(MappingStartEventInfo eventInfo);
    public virtual void Emit(MappingEndEventInfo eventInfo);
    public virtual void Emit(SequenceStartEventInfo eventInfo);
    public virtual void Emit(SequenceEndEventInfo eventInfo);
    public virtual void Emit(ParsingEvent parsingEvent);
    public virtual void DocumentEnd();
    public virtual void StreamEnd();
}
public class SharpYaml.Serialization.ChainedObjectFactory : object {
    private IObjectFactory nextFactory;
    public ChainedObjectFactory(IObjectFactory nextFactory);
    public virtual object Create(Type type);
}
public class SharpYaml.Serialization.DefaultNamingConvention : object {
    public StringComparer Comparer { get; }
    public sealed virtual StringComparer get_Comparer();
    public sealed virtual string Convert(string name);
}
public class SharpYaml.Serialization.DefaultObjectFactory : object {
    private static Type[] EmptyTypes;
    private static Dictionary`2<Type, Type> DefaultInterfaceImplementations;
    private static DefaultObjectFactory();
    public static Type GetDefaultImplementation(Type type);
    public sealed virtual object Create(Type type);
}
public enum SharpYaml.Serialization.DescriptorCategory : Enum {
    public int value__;
    public static DescriptorCategory Primitive;
    public static DescriptorCategory Collection;
    public static DescriptorCategory Array;
    public static DescriptorCategory Dictionary;
    public static DescriptorCategory Object;
    public static DescriptorCategory Nullable;
    public static DescriptorCategory Custom;
}
public class SharpYaml.Serialization.Descriptors.ArrayDescriptor : ObjectDescriptor {
    private Type elementType;
    private Type listType;
    private MethodInfo toArrayMethod;
    public DescriptorCategory Category { get; }
    public Type ElementType { get; }
    public ArrayDescriptor(IAttributeRegistry attributeRegistry, Type type, IMemberNamingConvention namingConvention);
    public virtual DescriptorCategory get_Category();
    public Type get_ElementType();
    public Array CreateArray(int dimension);
}
public class SharpYaml.Serialization.Descriptors.CollectionDescriptor : ObjectDescriptor {
    private static List`1<string> ListOfMembersToRemove;
    private Func`2<object, bool> IsReadOnlyFunction;
    private Func`2<object, int> GetCollectionCountFunction;
    private Action`2<object, object> CollectionAddFunction;
    private bool isKeyedCollection;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPureCollection>k__BackingField;
    public DescriptorCategory Category { get; }
    public Type ElementType { get; private set; }
    public bool IsPureCollection { get; private set; }
    public bool HasAdd { get; }
    public CollectionDescriptor(IAttributeRegistry attributeRegistry, Type type, bool emitDefaultValues, IMemberNamingConvention namingConvention);
    private static CollectionDescriptor();
    public virtual void Initialize();
    public virtual DescriptorCategory get_Category();
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
private void set_ElementType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsPureCollection();
    [CompilerGeneratedAttribute]
private void set_IsPureCollection(bool value);
    public bool get_HasAdd();
    public void CollectionAdd(object collection, object value);
    public bool IsReadOnly(object collection);
    public int GetCollectionCount(object collection);
    public static bool IsCollection(Type type);
    protected virtual bool PrepareMember(MemberDescriptorBase member);
}
public class SharpYaml.Serialization.Descriptors.DefaultKeyComparer : object {
    public virtual int Compare(object x, object y);
}
public class SharpYaml.Serialization.Descriptors.DictionaryDescriptor : ObjectDescriptor {
    private static List`1<string> ListOfMembersToRemove;
    private Type keyType;
    private Type valueType;
    private MethodInfo getEnumeratorGeneric;
    private MethodInfo addMethod;
    [CompilerGeneratedAttribute]
private bool <IsGenericDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPureDictionary>k__BackingField;
    public DescriptorCategory Category { get; }
    public bool IsGenericDictionary { get; private set; }
    public Type KeyType { get; }
    public Type ValueType { get; }
    public bool IsPureDictionary { get; private set; }
    public DictionaryDescriptor(IAttributeRegistry attributeRegistry, Type type, bool emitDefaultValues, IMemberNamingConvention namingConvention);
    private static DictionaryDescriptor();
    public virtual void Initialize();
    public virtual DescriptorCategory get_Category();
    [CompilerGeneratedAttribute]
public bool get_IsGenericDictionary();
    [CompilerGeneratedAttribute]
private void set_IsGenericDictionary(bool value);
    public Type get_KeyType();
    public Type get_ValueType();
    [CompilerGeneratedAttribute]
public bool get_IsPureDictionary();
    [CompilerGeneratedAttribute]
private void set_IsPureDictionary(bool value);
    public bool IsReadOnly(object thisObject);
    [IteratorStateMachineAttribute("SharpYaml.Serialization.Descriptors.DictionaryDescriptor/<GetEnumerator>d__22")]
public IEnumerable`1<KeyValuePair`2<object, object>> GetEnumerator(object dictionary);
    public void AddToDictionary(object dictionary, object key, object value);
    public static bool IsDictionary(Type type);
    public static IEnumerable`1<KeyValuePair`2<object, object>> GetGenericEnumerable(IDictionary`2<TKey, TValue> dictionary);
    protected virtual bool PrepareMember(MemberDescriptorBase member);
}
public class SharpYaml.Serialization.Descriptors.FieldDescriptor : MemberDescriptorBase {
    private FieldInfo fieldInfo;
    public FieldInfo FieldInfo { get; }
    public Type Type { get; }
    public bool HasSet { get; }
    public bool IsPublic { get; }
    public FieldDescriptor(FieldInfo fieldInfo, StringComparer defaultNameComparer);
    public FieldInfo get_FieldInfo();
    public virtual Type get_Type();
    public virtual object Get(object thisObject);
    public virtual void Set(object thisObject, object value);
    public virtual bool get_HasSet();
    public virtual bool get_IsPublic();
    public virtual string ToString();
}
public abstract class SharpYaml.Serialization.Descriptors.MemberDescriptorBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalName>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparer <DefaultNameComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializeMemberMode <SerializeMemberMode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Mask>k__BackingField;
    [CompilerGeneratedAttribute]
private YamlStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, bool> <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AlternativeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    public string Name { get; internal set; }
    public string OriginalName { get; private set; }
    public StringComparer DefaultNameComparer { get; private set; }
    public Type Type { get; }
    public Nullable`1<int> Order { get; internal set; }
    public Type DeclaringType { get; private set; }
    public SerializeMemberMode SerializeMemberMode { get; internal set; }
    public bool HasSet { get; }
    public bool IsPublic { get; }
    public UInt32 Mask { get; internal set; }
    public YamlStyle Style { get; internal set; }
    public Func`2<object, bool> ShouldSerialize { get; internal set; }
    public List`1<string> AlternativeNames { get; public set; }
    public object Tag { get; public set; }
    public MemberInfo MemberInfo { get; private set; }
    protected MemberDescriptorBase(MemberInfo memberInfo, StringComparer defaultNameComparer);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OriginalName();
    [CompilerGeneratedAttribute]
private void set_OriginalName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual StringComparer get_DefaultNameComparer();
    [CompilerGeneratedAttribute]
private void set_DefaultNameComparer(StringComparer value);
    public abstract virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
internal void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
private void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual SerializeMemberMode get_SerializeMemberMode();
    [CompilerGeneratedAttribute]
internal void set_SerializeMemberMode(SerializeMemberMode value);
    public abstract virtual object Get(object thisObject);
    public abstract virtual void Set(object thisObject, object value);
    public abstract virtual bool get_HasSet();
    public abstract virtual bool get_IsPublic();
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_Mask();
    [CompilerGeneratedAttribute]
internal void set_Mask(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual YamlStyle get_Style();
    [CompilerGeneratedAttribute]
internal void set_Style(YamlStyle value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<object, bool> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
internal void set_ShouldSerialize(Func`2<object, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<string> get_AlternativeNames();
    [CompilerGeneratedAttribute]
public void set_AlternativeNames(List`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Tag(object value);
    [CompilerGeneratedAttribute]
public MemberInfo get_MemberInfo();
    [CompilerGeneratedAttribute]
private void set_MemberInfo(MemberInfo value);
}
internal class SharpYaml.Serialization.Descriptors.NullableDescriptor : ObjectDescriptor {
    private static List`1<IMemberDescriptor> EmptyMembers;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    public DescriptorCategory Category { get; }
    public Type UnderlyingType { get; private set; }
    public NullableDescriptor(IAttributeRegistry attributeRegistry, Type type, IMemberNamingConvention namingConvention);
    private static NullableDescriptor();
    public virtual DescriptorCategory get_Category();
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
private void set_UnderlyingType(Type value);
    public static bool IsNullable(Type type);
    protected virtual List`1<IMemberDescriptor> PrepareMembers();
}
[DefaultMemberAttribute("Item")]
public class SharpYaml.Serialization.Descriptors.ObjectDescriptor : object {
    public static Func`2<object, bool> ShouldSerializeDefault;
    protected static string SystemCollectionsNamespace;
    private static Object[] EmptyObjectArray;
    private Type type;
    private List`1<IMemberDescriptor> members;
    private Dictionary`2<string, IMemberDescriptor> mapMembers;
    private bool emitDefaultValues;
    private YamlStyle style;
    private bool isSorted;
    private IMemberNamingConvention memberNamingConvention;
    private HashSet`1<string> remapMembers;
    private List`1<Attribute> attributes;
    [CompilerGeneratedAttribute]
private IAttributeRegistry <AttributeRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompilerGenerated>k__BackingField;
    public List`1<Attribute> Attributes { get; }
    public IMemberNamingConvention NamingConvention { get; }
    protected IAttributeRegistry AttributeRegistry { get; private set; }
    public Type Type { get; }
    public IEnumerable`1<IMemberDescriptor> Members { get; }
    public int Count { get; }
    public DescriptorCategory Category { get; }
    public bool HasMembers { get; }
    public YamlStyle Style { get; }
    public IMemberDescriptor Item { get; }
    public bool IsCompilerGenerated { get; private set; }
    public ObjectDescriptor(IAttributeRegistry attributeRegistry, Type type, bool emitDefaultValues, IMemberNamingConvention namingConvention);
    private static ObjectDescriptor();
    public List`1<Attribute> get_Attributes();
    public IMemberNamingConvention get_NamingConvention();
    public virtual void Initialize();
    [CompilerGeneratedAttribute]
protected IAttributeRegistry get_AttributeRegistry();
    [CompilerGeneratedAttribute]
private void set_AttributeRegistry(IAttributeRegistry value);
    public sealed virtual Type get_Type();
    public sealed virtual IEnumerable`1<IMemberDescriptor> get_Members();
    public sealed virtual int get_Count();
    public virtual DescriptorCategory get_Category();
    public sealed virtual bool get_HasMembers();
    public sealed virtual YamlStyle get_Style();
    public void SortMembers(IComparer`1<object> keyComparer);
    public sealed virtual IMemberDescriptor get_Item(string name);
    public sealed virtual bool IsMemberRemapped(string name);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompilerGenerated();
    [CompilerGeneratedAttribute]
private void set_IsCompilerGenerated(bool value);
    public sealed virtual bool Contains(string memberName);
    protected virtual List`1<IMemberDescriptor> PrepareMembers();
    protected virtual bool PrepareMember(MemberDescriptorBase member);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private PropertyDescriptor <PrepareMembers>b__43_1(PropertyInfo propertyInfo);
    [CompilerGeneratedAttribute]
private bool <PrepareMembers>b__43_2(PropertyDescriptor member);
    [CompilerGeneratedAttribute]
private FieldDescriptor <PrepareMembers>b__43_3(FieldInfo fieldInfo);
    [CompilerGeneratedAttribute]
private bool <PrepareMembers>b__43_4(FieldDescriptor member);
}
public class SharpYaml.Serialization.Descriptors.PrimitiveDescriptor : ObjectDescriptor {
    private static List`1<IMemberDescriptor> EmptyMembers;
    private Dictionary`2<string, object> enumRemap;
    public DescriptorCategory Category { get; }
    public PrimitiveDescriptor(IAttributeRegistry attributeRegistry, Type type, IMemberNamingConvention namingConvention);
    private static PrimitiveDescriptor();
    public virtual DescriptorCategory get_Category();
    public static bool IsPrimitive(Type type);
    public object ParseEnum(string enumAsText, Boolean& remapped);
    protected virtual List`1<IMemberDescriptor> PrepareMembers();
}
public class SharpYaml.Serialization.Descriptors.PropertyDescriptor : MemberDescriptorBase {
    private PropertyInfo propertyInfo;
    private MethodInfo getMethod;
    private MethodInfo setMethod;
    public PropertyInfo PropertyInfo { get; }
    public Type Type { get; }
    public bool HasSet { get; }
    public bool IsPublic { get; }
    public PropertyDescriptor(PropertyInfo propertyInfo, StringComparer defaultNameComparer);
    public PropertyInfo get_PropertyInfo();
    public virtual Type get_Type();
    public virtual object Get(object thisObject);
    public virtual void Set(object thisObject, object value);
    public virtual bool get_HasSet();
    public virtual bool get_IsPublic();
    public virtual string ToString();
}
internal class SharpYaml.Serialization.Descriptors.TypeDescriptorFactory : object {
    private IAttributeRegistry attributeRegistry;
    private Dictionary`2<Type, ITypeDescriptor> registeredDescriptors;
    private bool emitDefaultValues;
    private IMemberNamingConvention namingConvention;
    protected IAttributeRegistry AttributeRegistry { get; }
    public TypeDescriptorFactory(IAttributeRegistry attributeRegistry, bool emitDefaultValues, IMemberNamingConvention namingConvention);
    public sealed virtual ITypeDescriptor Find(Type type, IComparer`1<object> memberComparer);
    protected IAttributeRegistry get_AttributeRegistry();
    protected virtual ITypeDescriptor Create(Type type);
}
internal class SharpYaml.Serialization.DocumentLoadingState : object {
    private IDictionary`2<string, YamlNode> anchors;
    private IList`1<YamlNode> nodesWithUnresolvedAliases;
    public void AddAnchor(YamlNode node);
    public YamlNode GetNode(string anchor, bool throwException, Mark start, Mark end);
    public void AddNodeWithUnresolvedAliases(YamlNode node);
    public void ResolveAliases();
}
public class SharpYaml.Serialization.DuplicateAnchorException : YamlException {
    public DuplicateAnchorException(string message);
    public DuplicateAnchorException(Mark start, Mark end, string message);
    public DuplicateAnchorException(string message, Exception inner);
}
public abstract class SharpYaml.Serialization.DynamicMemberDescriptorBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalName>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparer <DefaultNameComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializeMemberMode <SerializeMemberMode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Mask>k__BackingField;
    [CompilerGeneratedAttribute]
private YamlStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, bool> <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AlternativeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    public string Name { get; public set; }
    public string OriginalName { get; public set; }
    public StringComparer DefaultNameComparer { get; public set; }
    public Type Type { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public SerializeMemberMode SerializeMemberMode { get; public set; }
    public bool HasSet { get; }
    public bool IsPublic { get; }
    public UInt32 Mask { get; public set; }
    public YamlStyle Style { get; public set; }
    public Func`2<object, bool> ShouldSerialize { get; public set; }
    public List`1<string> AlternativeNames { get; public set; }
    public object Tag { get; public set; }
    protected DynamicMemberDescriptorBase(string name, Type type);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OriginalName();
    [CompilerGeneratedAttribute]
public void set_OriginalName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual StringComparer get_DefaultNameComparer();
    [CompilerGeneratedAttribute]
public void set_DefaultNameComparer(StringComparer value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual SerializeMemberMode get_SerializeMemberMode();
    [CompilerGeneratedAttribute]
public void set_SerializeMemberMode(SerializeMemberMode value);
    public abstract virtual object Get(object thisObject);
    public abstract virtual void Set(object thisObject, object value);
    public abstract virtual bool get_HasSet();
    public sealed virtual bool get_IsPublic();
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_Mask();
    [CompilerGeneratedAttribute]
public void set_Mask(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual YamlStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(YamlStyle value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<object, bool> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Func`2<object, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<string> get_AlternativeNames();
    [CompilerGeneratedAttribute]
public void set_AlternativeNames(List`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Tag(object value);
}
internal class SharpYaml.Serialization.EmitterState : object {
    private HashSet`1<string> emittedAnchors;
    public HashSet`1<string> EmittedAnchors { get; }
    public HashSet`1<string> get_EmittedAnchors();
}
public abstract class SharpYaml.Serialization.EventInfo : object {
    [CompilerGeneratedAttribute]
private object <SourceValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    public object SourceValue { get; private set; }
    public Type SourceType { get; private set; }
    protected EventInfo(object sourceValue, Type sourceType);
    [CompilerGeneratedAttribute]
public object get_SourceValue();
    [CompilerGeneratedAttribute]
private void set_SourceValue(object value);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
private void set_SourceType(Type value);
}
public class SharpYaml.Serialization.FlatNamingConvention : object {
    private Regex regex1;
    private Regex regex2;
    public StringComparer Comparer { get; }
    public sealed virtual StringComparer get_Comparer();
    public sealed virtual string Convert(string name);
}
public interface SharpYaml.Serialization.IAttributeRegistry {
    public Func`2<Attribute, Attribute> AttributeRemap { get; public set; }
    public Action`2<ObjectDescriptor, List`1<IMemberDescriptor>> PrepareMembersCallback { get; public set; }
    public abstract virtual Func`2<Attribute, Attribute> get_AttributeRemap();
    public abstract virtual void set_AttributeRemap(Func`2<Attribute, Attribute> value);
    public abstract virtual List`1<Attribute> GetAttributes(MemberInfo memberInfo, bool inherit);
    public abstract virtual Action`2<ObjectDescriptor, List`1<IMemberDescriptor>> get_PrepareMembersCallback();
    public abstract virtual void set_PrepareMembersCallback(Action`2<ObjectDescriptor, List`1<IMemberDescriptor>> value);
    public abstract virtual void Register(MemberInfo memberInfo, Attribute attribute);
}
internal class SharpYaml.Serialization.IdentityEqualityComparer`1 : object {
    public sealed virtual bool Equals(T left, T right);
    public sealed virtual int GetHashCode(T value);
}
public interface SharpYaml.Serialization.IEventEmitter {
    public abstract virtual void StreamStart();
    public abstract virtual void DocumentStart();
    public abstract virtual void Emit(AliasEventInfo eventInfo);
    public abstract virtual void Emit(ScalarEventInfo eventInfo);
    public abstract virtual void Emit(MappingStartEventInfo eventInfo);
    public abstract virtual void Emit(MappingEndEventInfo eventInfo);
    public abstract virtual void Emit(SequenceStartEventInfo eventInfo);
    public abstract virtual void Emit(SequenceEndEventInfo eventInfo);
    public abstract virtual void Emit(ParsingEvent parsingEvent);
    public abstract virtual void DocumentEnd();
    public abstract virtual void StreamEnd();
}
public interface SharpYaml.Serialization.IMemberDescriptor {
    public string Name { get; }
    public string OriginalName { get; }
    public StringComparer DefaultNameComparer { get; }
    public Type Type { get; }
    public Nullable`1<int> Order { get; }
    public SerializeMemberMode SerializeMemberMode { get; }
    public bool HasSet { get; }
    public bool IsPublic { get; }
    public UInt32 Mask { get; }
    public YamlStyle Style { get; }
    public Func`2<object, bool> ShouldSerialize { get; }
    public List`1<string> AlternativeNames { get; }
    public object Tag { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual string get_OriginalName();
    public abstract virtual StringComparer get_DefaultNameComparer();
    public abstract virtual Type get_Type();
    public abstract virtual Nullable`1<int> get_Order();
    public abstract virtual SerializeMemberMode get_SerializeMemberMode();
    public abstract virtual object Get(object thisObject);
    public abstract virtual void Set(object thisObject, object value);
    public abstract virtual bool get_HasSet();
    public abstract virtual bool get_IsPublic();
    public abstract virtual UInt32 get_Mask();
    public abstract virtual YamlStyle get_Style();
    public abstract virtual Func`2<object, bool> get_ShouldSerialize();
    public abstract virtual List`1<string> get_AlternativeNames();
    public abstract virtual object get_Tag();
    public abstract virtual void set_Tag(object value);
}
public interface SharpYaml.Serialization.IMemberNamingConvention {
    public StringComparer Comparer { get; }
    public abstract virtual StringComparer get_Comparer();
    public abstract virtual string Convert(string name);
}
public interface SharpYaml.Serialization.IObjectFactory {
    public abstract virtual object Create(Type type);
}
public interface SharpYaml.Serialization.IObjectSerializerBackend {
    public abstract virtual YamlStyle GetStyle(ObjectContext& objectContext);
    public abstract virtual string ReadMemberName(ObjectContext& objectContext, string memberName, Boolean& skipMember);
    public abstract virtual object ReadMemberValue(ObjectContext& objectContext, IMemberDescriptor member, object memberValue, Type memberType);
    public abstract virtual object ReadCollectionItem(ObjectContext& objectContext, object value, Type itemType, int index);
    public abstract virtual KeyValuePair`2<object, object> ReadDictionaryItem(ObjectContext& objectContext, KeyValuePair`2<Type, Type> keyValueType);
    public abstract virtual void WriteMemberName(ObjectContext& objectContext, IMemberDescriptor member, string memberName);
    public abstract virtual void WriteMemberValue(ObjectContext& objectContext, IMemberDescriptor member, object memberValue, Type memberType);
    public abstract virtual void WriteCollectionItem(ObjectContext& objectContext, object item, Type itemType, int index);
    public abstract virtual void WriteDictionaryItem(ObjectContext& objectContext, KeyValuePair`2<object, object> keyValue, KeyValuePair`2<Type, Type> types);
}
[DefaultMemberAttribute("Item")]
public interface SharpYaml.Serialization.IOrderedDictionary`2 {
    public KeyValuePair`2<TKey, TValue> Item { get; public set; }
    public abstract virtual void Insert(int index, TKey key, TValue value);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual int IndexOf(TKey key);
    public abstract virtual KeyValuePair`2<TKey, TValue> get_Item(int index);
    public abstract virtual void set_Item(int index, KeyValuePair`2<TKey, TValue> value);
}
public interface SharpYaml.Serialization.ITagTypeRegistry {
    public abstract virtual void RegisterAssembly(Assembly assembly, IAttributeRegistry attributeRegistry);
    public abstract virtual void RegisterTagMapping(string tag, Type type, bool alias);
}
public interface SharpYaml.Serialization.ITagTypeResolver {
    public abstract virtual Type TypeFromTag(string tagName, Boolean& isAlias);
    public abstract virtual string TagFromType(Type type);
    public abstract virtual Type ResolveType(string typeName);
}
[DefaultMemberAttribute("Item")]
public interface SharpYaml.Serialization.ITypeDescriptor {
    public Type Type { get; }
    public IEnumerable`1<IMemberDescriptor> Members { get; }
    public int Count { get; }
    public DescriptorCategory Category { get; }
    public bool HasMembers { get; }
    public IMemberDescriptor Item { get; }
    public bool IsCompilerGenerated { get; }
    public YamlStyle Style { get; }
    public abstract virtual Type get_Type();
    public abstract virtual IEnumerable`1<IMemberDescriptor> get_Members();
    public abstract virtual int get_Count();
    public abstract virtual DescriptorCategory get_Category();
    public abstract virtual bool get_HasMembers();
    public abstract virtual IMemberDescriptor get_Item(string name);
    public abstract virtual bool IsMemberRemapped(string name);
    public abstract virtual bool get_IsCompilerGenerated();
    public abstract virtual YamlStyle get_Style();
    public abstract virtual bool Contains(string memberName);
}
internal interface SharpYaml.Serialization.ITypeDescriptorFactory {
    public abstract virtual ITypeDescriptor Find(Type type, IComparer`1<object> memberComparer);
}
public interface SharpYaml.Serialization.IYamlSerializable {
    public abstract virtual object ReadYaml(ObjectContext& objectContext);
    public abstract virtual void WriteYaml(ObjectContext& objectContext);
}
public interface SharpYaml.Serialization.IYamlSerializableFactory {
    public abstract virtual IYamlSerializable TryCreate(SerializerContext context, ITypeDescriptor typeDescriptor);
}
public interface SharpYaml.Serialization.IYamlVisitor {
    public abstract virtual void Visit(YamlStream stream);
    public abstract virtual void Visit(YamlDocument document);
    public abstract virtual void Visit(YamlScalarNode scalar);
    public abstract virtual void Visit(YamlSequenceNode sequence);
    public abstract virtual void Visit(YamlMappingNode mapping);
}
internal class SharpYaml.Serialization.JsonEventEmitter : ChainedEventEmitter {
    public JsonEventEmitter(IEventEmitter nextEmitter);
    public virtual void Emit(AliasEventInfo eventInfo);
    public virtual void Emit(ScalarEventInfo eventInfo);
    public virtual void Emit(MappingStartEventInfo eventInfo);
    public virtual void Emit(SequenceStartEventInfo eventInfo);
}
public class SharpYaml.Serialization.LambdaObjectFactory : ChainedObjectFactory {
    private Func`2<Type, object> factory;
    public LambdaObjectFactory(Func`2<Type, object> factory);
    public LambdaObjectFactory(Func`2<Type, object> factory, IObjectFactory nextFactory);
    public virtual object Create(Type type);
}
public interface SharpYaml.Serialization.Logging.ILogger {
    public abstract virtual void Log(LogLevel level, Exception ex, string message);
}
public enum SharpYaml.Serialization.Logging.LogLevel : Enum {
    public int value__;
    public static LogLevel Error;
    public static LogLevel Warning;
}
public class SharpYaml.Serialization.MappingEndEventInfo : EventInfo {
    public MappingEndEventInfo(object sourceValue, Type sourceType);
}
public class SharpYaml.Serialization.MappingStartEventInfo : ObjectEventInfo {
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private YamlStyle <Style>k__BackingField;
    public bool IsImplicit { get; public set; }
    public YamlStyle Style { get; public set; }
    public MappingStartEventInfo(object sourceValue, Type sourceType);
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public void set_IsImplicit(bool value);
    [CompilerGeneratedAttribute]
public YamlStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(YamlStyle value);
}
public class SharpYaml.Serialization.ObjectContext : ValueType {
    public SerializerContext SerializerContext;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
private YamlStyle <Style>k__BackingField;
    public EventReader Reader { get; }
    public IEventEmitter Writer { get; }
    public SerializerSettings Settings { get; }
    public IObjectSerializerBackend ObjectSerializerBackend { get; }
    public object Instance { get; public set; }
    public ITypeDescriptor Descriptor { get; public set; }
    public string Tag { get; public set; }
    public string Anchor { get; public set; }
    public YamlStyle Style { get; public set; }
    public ObjectContext(SerializerContext serializerContext, object instance, ITypeDescriptor descriptor);
    public EventReader get_Reader();
    public IEventEmitter get_Writer();
    public SerializerSettings get_Settings();
    public IObjectSerializerBackend get_ObjectSerializerBackend();
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(object value);
    [CompilerGeneratedAttribute]
public ITypeDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(ITypeDescriptor value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
    [CompilerGeneratedAttribute]
public string get_Anchor();
    [CompilerGeneratedAttribute]
public void set_Anchor(string value);
    [CompilerGeneratedAttribute]
public YamlStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(YamlStyle value);
}
public class SharpYaml.Serialization.ObjectEventInfo : EventInfo {
    [CompilerGeneratedAttribute]
private string <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    public string Anchor { get; public set; }
    public string Tag { get; public set; }
    protected ObjectEventInfo(object sourceValue, Type sourceType);
    [CompilerGeneratedAttribute]
public string get_Anchor();
    [CompilerGeneratedAttribute]
public void set_Anchor(string value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
}
[DefaultMemberAttribute("Item")]
internal class SharpYaml.Serialization.OrderedDictionary`2 : object {
    private KeyedCollection<TKey, TValue> items;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public KeyValuePair`2<TKey, TValue> Item { get; public set; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual void Insert(int index, TKey key, TValue value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual int IndexOf(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Insert(int index, KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int IndexOf(TKey key);
    public sealed virtual KeyValuePair`2<TKey, TValue> get_Item(int index);
    public sealed virtual void set_Item(int index, KeyValuePair`2<TKey, TValue> value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
}
public class SharpYaml.Serialization.ScalarEventInfo : ObjectEventInfo {
    [CompilerGeneratedAttribute]
private string <RenderedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ScalarStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPlainImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsQuotedImplicit>k__BackingField;
    public string RenderedValue { get; public set; }
    public ScalarStyle Style { get; public set; }
    public bool IsPlainImplicit { get; public set; }
    public bool IsQuotedImplicit { get; public set; }
    public ScalarEventInfo(object sourceValue, Type sourceType);
    [CompilerGeneratedAttribute]
public string get_RenderedValue();
    [CompilerGeneratedAttribute]
public void set_RenderedValue(string value);
    [CompilerGeneratedAttribute]
public ScalarStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(ScalarStyle value);
    [CompilerGeneratedAttribute]
public bool get_IsPlainImplicit();
    [CompilerGeneratedAttribute]
public void set_IsPlainImplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsQuotedImplicit();
    [CompilerGeneratedAttribute]
public void set_IsQuotedImplicit(bool value);
}
public class SharpYaml.Serialization.SequenceEndEventInfo : EventInfo {
    public SequenceEndEventInfo(object sourceValue, Type sourceType);
}
public class SharpYaml.Serialization.SequenceStartEventInfo : ObjectEventInfo {
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private YamlStyle <Style>k__BackingField;
    public bool IsImplicit { get; public set; }
    public YamlStyle Style { get; public set; }
    public SequenceStartEventInfo(object sourceValue, Type sourceType);
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public void set_IsImplicit(bool value);
    [CompilerGeneratedAttribute]
public YamlStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(YamlStyle value);
}
public enum SharpYaml.Serialization.SerializeMemberMode : Enum {
    public int value__;
    public static SerializeMemberMode Default;
    public static SerializeMemberMode Assign;
    public static SerializeMemberMode Content;
    public static SerializeMemberMode Binary;
    public static SerializeMemberMode Never;
}
public class SharpYaml.Serialization.Serializer : object {
    private SerializerSettings settings;
    internal IYamlSerializable ObjectSerializer;
    internal IYamlSerializable RoutingSerializer;
    internal ITypeDescriptorFactory TypeDescriptorFactory;
    private static IYamlSerializableFactory[] DefaultFactories;
    public SerializerSettings Settings { get; }
    public Serializer(SerializerSettings settings);
    private static Serializer();
    public SerializerSettings get_Settings();
    public string Serialize(object graph);
    public string Serialize(object graph, Type expectedType, SerializerContextSettings contextSettings);
    public void Serialize(Stream stream, object graph);
    public void Serialize(Stream stream, object graph, Type expectedType, SerializerContextSettings contextSettings);
    public void Serialize(TextWriter writer, object graph);
    public void Serialize(TextWriter writer, object graph, Type type, SerializerContextSettings contextSettings);
    public void Serialize(IEmitter emitter, object graph);
    public void Serialize(IEmitter emitter, object graph, Type type, SerializerContextSettings contextSettings);
    public object Deserialize(Stream stream);
    public object Deserialize(TextReader reader);
    public object Deserialize(Stream stream, Type expectedType, SerializerContextSettings contextSettings);
    public object Deserialize(Stream stream, Type expectedType, SerializerContextSettings contextSettings, SerializerContext& context);
    public T Deserialize(Stream stream);
    public object Deserialize(TextReader reader, Type expectedType, object existingObject, SerializerContextSettings contextSettings);
    public object Deserialize(TextReader reader, Type expectedType, object existingObject, SerializerContextSettings contextSettings, SerializerContext& context);
    public T Deserialize(TextReader reader, object existingObject);
    public object Deserialize(string fromText, object existingObject);
    public object Deserialize(string fromText, Type expectedType, object existingObject);
    public object Deserialize(string fromText, Type expectedType, object existingObject, SerializerContext& context);
    public T Deserialize(string fromText);
    public T Deserialize(EventReader reader);
    public T DeserializeInto(string fromText, T existingObject);
    public T DeserializeInto(EventReader reader, T existingObject);
    public T Deserialize(string fromText, SerializerContext& context);
    public T Deserialize(EventReader reader, SerializerContext& context);
    public T DeserializeInto(string fromText, T existingObject, SerializerContext& context);
    public T DeserializeInto(EventReader reader, T existingObject, SerializerContext& context);
    public object Deserialize(EventReader reader, Type expectedType, object existingObject, SerializerContextSettings contextSettings);
    public object Deserialize(EventReader reader, Type expectedType, object existingObject, SerializerContextSettings contextSettings, SerializerContext& context);
    private IYamlSerializable CreateProcessor(RoutingSerializer& routingSerializer);
    private ITypeDescriptorFactory CreateTypeDescriptorFactory();
    private IEventEmitter CreateEmitter(IEmitter emitter);
}
public class SharpYaml.Serialization.SerializerContext : object {
    private SerializerSettings settings;
    private ITagTypeRegistry tagTypeRegistry;
    private ITypeDescriptorFactory typeDescriptorFactory;
    private IEmitter emitter;
    private SerializerContextSettings contextSettings;
    internal int AnchorCount;
    [CompilerGeneratedAttribute]
private IYamlSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private Serializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private EventReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private IObjectSerializerBackend <ObjectSerializerBackend>k__BackingField;
    [CompilerGeneratedAttribute]
private IYamlSerializable <ObjectSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasRemapOccurred>k__BackingField;
    [CompilerGeneratedAttribute]
private IObjectFactory <ObjectFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IEventEmitter <Writer>k__BackingField;
    public bool IsSerializing { get; }
    public SerializerContextSettings ContextSettings { get; }
    public SerializerSettings Settings { get; }
    public IYamlSchema Schema { get; private set; }
    public Serializer Serializer { get; private set; }
    public EventReader Reader { get; public set; }
    public IObjectSerializerBackend ObjectSerializerBackend { get; private set; }
    private IYamlSerializable ObjectSerializer { get; private set; }
    public bool AllowErrors { get; public set; }
    public bool HasRemapOccurred { get; internal set; }
    public UInt32 MemberMask { get; }
    public IObjectFactory ObjectFactory { get; public set; }
    public IEventEmitter Writer { get; public set; }
    public IEmitter Emitter { get; internal set; }
    internal SerializerContext(Serializer serializer, SerializerContextSettings serializerContextSettings);
    public bool get_IsSerializing();
    public SerializerContextSettings get_ContextSettings();
    public SerializerSettings get_Settings();
    [CompilerGeneratedAttribute]
public IYamlSchema get_Schema();
    [CompilerGeneratedAttribute]
private void set_Schema(IYamlSchema value);
    [CompilerGeneratedAttribute]
public Serializer get_Serializer();
    [CompilerGeneratedAttribute]
private void set_Serializer(Serializer value);
    [CompilerGeneratedAttribute]
public EventReader get_Reader();
    [CompilerGeneratedAttribute]
public void set_Reader(EventReader value);
    [CompilerGeneratedAttribute]
public IObjectSerializerBackend get_ObjectSerializerBackend();
    [CompilerGeneratedAttribute]
private void set_ObjectSerializerBackend(IObjectSerializerBackend value);
    [CompilerGeneratedAttribute]
private IYamlSerializable get_ObjectSerializer();
    [CompilerGeneratedAttribute]
private void set_ObjectSerializer(IYamlSerializable value);
    [CompilerGeneratedAttribute]
public bool get_AllowErrors();
    [CompilerGeneratedAttribute]
public void set_AllowErrors(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasRemapOccurred();
    [CompilerGeneratedAttribute]
internal void set_HasRemapOccurred(bool value);
    public UInt32 get_MemberMask();
    public object ReadYaml(object value, Type expectedType);
    [CompilerGeneratedAttribute]
public IObjectFactory get_ObjectFactory();
    [CompilerGeneratedAttribute]
public void set_ObjectFactory(IObjectFactory value);
    [CompilerGeneratedAttribute]
public IEventEmitter get_Writer();
    [CompilerGeneratedAttribute]
public void set_Writer(IEventEmitter value);
    public IEmitter get_Emitter();
    internal void set_Emitter(IEmitter value);
    public void WriteYaml(object value, Type expectedType, YamlStyle style);
    public ITypeDescriptor FindTypeDescriptor(Type type);
    public sealed virtual Type TypeFromTag(string tagName, Boolean& isAlias);
    public sealed virtual string TagFromType(Type type);
    public sealed virtual Type ResolveType(string typeFullName);
    public bool TryParseScalar(Scalar scalar, String& defaultTag, Object& value);
}
public class SharpYaml.Serialization.SerializerContextSettings : object {
    public static SerializerContextSettings Default;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MemberMask>k__BackingField;
    public ILogger Logger { get; public set; }
    public UInt32 MemberMask { get; public set; }
    private static SerializerContextSettings();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public UInt32 get_MemberMask();
    [CompilerGeneratedAttribute]
public void set_MemberMask(UInt32 value);
}
internal class SharpYaml.Serialization.Serializers.AnchorSerializer : ChainedSerializer {
    private Dictionary`2<string, object> aliasToObject;
    private Dictionary`2<object, string> objectToAlias;
    public AnchorSerializer(IYamlSerializable next);
    public bool TryGetAliasValue(string alias, Object& value);
    public virtual object ReadYaml(ObjectContext& objectContext);
    public virtual void WriteYaml(ObjectContext& objectContext);
}
internal class SharpYaml.Serialization.Serializers.ArraySerializer : object {
    public sealed virtual IYamlSerializable TryCreate(SerializerContext context, ITypeDescriptor typeDescriptor);
    public virtual object ReadYaml(ObjectContext& objectContext);
    public sealed virtual void WriteYaml(ObjectContext& objectContext);
}
public class SharpYaml.Serialization.Serializers.ChainedSerializer : object {
    private IYamlSerializable next;
    public ChainedSerializer(IYamlSerializable next);
    public virtual object ReadYaml(ObjectContext& objectContext);
    public virtual void WriteYaml(ObjectContext& objectContext);
}
public class SharpYaml.Serialization.Serializers.CollectionSerializer : ObjectSerializer {
    public virtual IYamlSerializable TryCreate(SerializerContext context, ITypeDescriptor typeDescriptor);
    protected virtual bool CheckIsSequence(ObjectContext& objectContext);
    protected virtual void ReadMember(ObjectContext& objectContext);
    protected virtual void WriteMembers(ObjectContext& objectContext);
    protected virtual void ReadCollectionItems(ObjectContext& objectContext);
    protected virtual void ReadAddCollectionItem(ObjectContext& objectContext, Type elementType, CollectionDescriptor collectionDescriptor, object thisObject, int index);
    protected virtual object ReadCollectionItem(ObjectContext& objectContext, object value, Type itemType, int index);
    protected virtual void WriteCollectionItems(ObjectContext& objectContext);
    protected virtual void WriteCollectionItem(ObjectContext& objectContext, object item, Type itemType, int index);
}
public class SharpYaml.Serialization.Serializers.DefaultObjectSerializerBackend : object {
    public virtual YamlStyle GetStyle(ObjectContext& objectContext);
    public virtual string ReadMemberName(ObjectContext& objectContext, string memberName, Boolean& skipMember);
    public virtual object ReadMemberValue(ObjectContext& objectContext, IMemberDescriptor memberDescriptor, object memberValue, Type memberType);
    public virtual object ReadCollectionItem(ObjectContext& objectContext, object value, Type itemType, int index);
    public virtual KeyValuePair`2<object, object> ReadDictionaryItem(ObjectContext& objectContext, KeyValuePair`2<Type, Type> keyValueType);
    public virtual void WriteMemberName(ObjectContext& objectContext, IMemberDescriptor member, string name);
    public virtual void WriteMemberValue(ObjectContext& objectContext, IMemberDescriptor member, object memberValue, Type memberType);
    public virtual void WriteCollectionItem(ObjectContext& objectContext, object item, Type itemType, int index);
    public virtual void WriteDictionaryItem(ObjectContext& objectContext, KeyValuePair`2<object, object> keyValue, KeyValuePair`2<Type, Type> types);
}
public class SharpYaml.Serialization.Serializers.DictionarySerializer : ObjectSerializer {
    public virtual IYamlSerializable TryCreate(SerializerContext context, ITypeDescriptor typeDescriptor);
    protected virtual void ReadMember(ObjectContext& objectContext);
    protected virtual void WriteMembers(ObjectContext& objectContext);
    protected virtual void ReadDictionaryItems(ObjectContext& objectContext);
    protected virtual KeyValuePair`2<object, object> ReadDictionaryItem(ObjectContext& objectContext, KeyValuePair`2<Type, Type> keyValueType);
    protected virtual void WriteDictionaryItems(ObjectContext& objectContext);
    protected virtual void WriteDictionaryItem(ObjectContext& objectContext, KeyValuePair`2<object, object> keyValue, KeyValuePair`2<Type, Type> types);
}
public class SharpYaml.Serialization.Serializers.ObjectSerializer : object {
    public virtual IYamlSerializable TryCreate(SerializerContext context, ITypeDescriptor typeDescriptor);
    protected virtual bool CheckIsSequence(ObjectContext& objectContext);
    protected virtual YamlStyle GetStyle(ObjectContext& objectContext);
    public virtual object ReadYaml(ObjectContext& objectContext);
    private bool CreateOrTransformObjectInternal(ObjectContext& objectContext);
    protected virtual void CreateOrTransformObject(ObjectContext& objectContext);
    protected virtual void TransformObjectAfterRead(ObjectContext& objectContext);
    protected virtual void ReadMembers(ObjectContext& objectContext);
    protected virtual void ReadMember(ObjectContext& objectContext);
    protected bool TryReadMember(ObjectContext& objectContext, String& memberName);
    public virtual bool TryReadMember(ObjectContext& objectContext, Scalar& memberScalar, String& memberName);
    private ReadMemberState TryReadMemberCore(ObjectContext& objectContext, Scalar& memberScalar, String& memberName);
    protected virtual string ReadMemberName(ObjectContext& objectContext, string memberName, Boolean& skipMember);
    protected virtual object ReadMemberValue(ObjectContext& objectContext, IMemberDescriptor member, object memberValue, Type memberType);
    public virtual void WriteYaml(ObjectContext& objectContext);
    protected virtual void WriteMembers(ObjectContext& objectContext);
    protected virtual void WriteMember(ObjectContext& objectContext, IMemberDescriptor member);
    protected virtual void WriteMemberName(ObjectContext& objectContext, IMemberDescriptor member, string name);
    protected virtual void WriteMemberValue(ObjectContext& objectContext, IMemberDescriptor member, object memberValue, Type memberType);
}
internal class SharpYaml.Serialization.Serializers.PrimitiveSerializer : ScalarSerializerBase {
    public sealed virtual IYamlSerializable TryCreate(SerializerContext context, ITypeDescriptor typeDescriptor);
    public virtual object ConvertFrom(ObjectContext& context, Scalar scalar);
    private static string AppendDecimalPoint(string text, bool hasNaN);
    public virtual string ConvertTo(ObjectContext& objectContext);
}
internal class SharpYaml.Serialization.Serializers.RoutingSerializer : object {
    private Dictionary`2<Type, IYamlSerializable> serializers;
    private List`1<IYamlSerializableFactory> factories;
    public void AddSerializer(Type type, IYamlSerializable serializer);
    public void AddSerializerFactory(IYamlSerializableFactory factory);
    public sealed virtual object ReadYaml(ObjectContext& objectContext);
    public sealed virtual void WriteYaml(ObjectContext& objectContext);
    private IYamlSerializable GetSerializer(SerializerContext context, ITypeDescriptor typeDescriptor);
}
public abstract class SharpYaml.Serialization.Serializers.ScalarSerializerBase : object {
    public sealed virtual object ReadYaml(ObjectContext& objectContext);
    public abstract virtual object ConvertFrom(ObjectContext& context, Scalar fromScalar);
    public sealed virtual void WriteYaml(ObjectContext& objectContext);
    protected virtual void WriteScalar(ObjectContext& objectContext, ScalarEventInfo scalar);
    public abstract virtual string ConvertTo(ObjectContext& objectContext);
}
internal class SharpYaml.Serialization.Serializers.TagTypeSerializer : ChainedSerializer {
    public TagTypeSerializer(IYamlSerializable next);
    public virtual object ReadYaml(ObjectContext& objectContext);
    public virtual void WriteYaml(ObjectContext& objectContext);
}
public class SharpYaml.Serialization.SerializerSettings : object {
    internal Dictionary`2<Type, IYamlSerializable> serializers;
    internal AssemblyRegistry AssemblyRegistry;
    private IAttributeRegistry attributeRegistry;
    private IYamlSchema schema;
    private IObjectFactory objectFactory;
    private int preferredIndent;
    private string specialCollectionMember;
    private IObjectSerializerBackend objectSerializerBackend;
    private IMemberNamingConvention _namingConvention;
    [CompilerGeneratedAttribute]
private bool <EmitAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitTags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentLess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortKeyForMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitJsonComptible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitCapacityForList>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LimitPrimitiveFlowSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitDefaultValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer`1<object> <ComparerForKeySorting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeDictionaryItemsAsMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private YamlStyle <DefaultStyle>k__BackingField;
    public int PreferredIndent { get; public set; }
    public bool EmitAlias { get; public set; }
    public bool EmitTags { get; public set; }
    public bool IndentLess { get; public set; }
    public bool SortKeyForMapping { get; public set; }
    public bool EmitJsonComptible { get; public set; }
    public bool EmitCapacityForList { get; public set; }
    public int LimitPrimitiveFlowSequence { get; public set; }
    public bool EmitDefaultValues { get; public set; }
    public IComparer`1<object> ComparerForKeySorting { get; public set; }
    public bool SerializeDictionaryItemsAsMembers { get; public set; }
    public IMemberNamingConvention NamingConvention { get; public set; }
    public bool EmitShortTypeName { get; public set; }
    public ITagTypeRegistry TagTypeRegistry { get; }
    public YamlStyle DefaultStyle { get; public set; }
    public string SpecialCollectionMember { get; public set; }
    public IAttributeRegistry Attributes { get; public set; }
    public IObjectSerializerBackend ObjectSerializerBackend { get; public set; }
    public IObjectFactory ObjectFactory { get; public set; }
    public IYamlSchema Schema { get; }
    public SerializerSettings(IYamlSchema schema);
    public int get_PreferredIndent();
    public void set_PreferredIndent(int value);
    [CompilerGeneratedAttribute]
public bool get_EmitAlias();
    [CompilerGeneratedAttribute]
public void set_EmitAlias(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitTags();
    [CompilerGeneratedAttribute]
public void set_EmitTags(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentLess();
    [CompilerGeneratedAttribute]
public void set_IndentLess(bool value);
    [CompilerGeneratedAttribute]
public bool get_SortKeyForMapping();
    [CompilerGeneratedAttribute]
public void set_SortKeyForMapping(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitJsonComptible();
    [CompilerGeneratedAttribute]
public void set_EmitJsonComptible(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitCapacityForList();
    [CompilerGeneratedAttribute]
public void set_EmitCapacityForList(bool value);
    [CompilerGeneratedAttribute]
public int get_LimitPrimitiveFlowSequence();
    [CompilerGeneratedAttribute]
public void set_LimitPrimitiveFlowSequence(int value);
    [CompilerGeneratedAttribute]
public bool get_EmitDefaultValues();
    [CompilerGeneratedAttribute]
public void set_EmitDefaultValues(bool value);
    [CompilerGeneratedAttribute]
public IComparer`1<object> get_ComparerForKeySorting();
    [CompilerGeneratedAttribute]
public void set_ComparerForKeySorting(IComparer`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_SerializeDictionaryItemsAsMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeDictionaryItemsAsMembers(bool value);
    public IMemberNamingConvention get_NamingConvention();
    public void set_NamingConvention(IMemberNamingConvention value);
    public bool get_EmitShortTypeName();
    public void set_EmitShortTypeName(bool value);
    public ITagTypeRegistry get_TagTypeRegistry();
    [CompilerGeneratedAttribute]
public YamlStyle get_DefaultStyle();
    [CompilerGeneratedAttribute]
public void set_DefaultStyle(YamlStyle value);
    public string get_SpecialCollectionMember();
    public void set_SpecialCollectionMember(string value);
    public IAttributeRegistry get_Attributes();
    public void set_Attributes(IAttributeRegistry value);
    public IObjectSerializerBackend get_ObjectSerializerBackend();
    public void set_ObjectSerializerBackend(IObjectSerializerBackend value);
    public IObjectFactory get_ObjectFactory();
    public void set_ObjectFactory(IObjectFactory value);
    public IYamlSchema get_Schema();
    public void RegisterAssembly(Assembly assembly);
    public void RegisterTagMapping(string tagName, Type tagType, bool isAlias);
    public void RegisterSerializer(Type type, IYamlSerializable serializer);
    public void RegisterSerializerFactory(IYamlSerializableFactory factory);
}
internal class SharpYaml.Serialization.WriterEventEmitter : object {
    private IEmitter emitter;
    public WriterEventEmitter(IEmitter emitter);
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.StreamStart();
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.DocumentStart();
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.Emit(AliasEventInfo eventInfo);
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.Emit(ScalarEventInfo eventInfo);
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.Emit(MappingStartEventInfo eventInfo);
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.Emit(MappingEndEventInfo eventInfo);
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.Emit(SequenceStartEventInfo eventInfo);
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.Emit(SequenceEndEventInfo eventInfo);
    public sealed virtual void Emit(ParsingEvent parsingEvent);
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.DocumentEnd();
    private sealed virtual override void SharpYaml.Serialization.IEventEmitter.StreamEnd();
}
internal class SharpYaml.Serialization.YamlAliasNode : YamlNode {
    public IEnumerable`1<YamlNode> AllNodes { get; }
    internal YamlAliasNode(string anchor);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [IteratorStateMachineAttribute("SharpYaml.Serialization.YamlAliasNode/<get_AllNodes>d__8")]
public virtual IEnumerable`1<YamlNode> get_AllNodes();
}
public class SharpYaml.Serialization.YamlDocument : object {
    [CompilerGeneratedAttribute]
private YamlNode <RootNode>k__BackingField;
    public YamlNode RootNode { get; private set; }
    public IEnumerable`1<YamlNode> AllNodes { get; }
    public YamlDocument(YamlNode rootNode);
    public YamlDocument(string rootNode);
    internal YamlDocument(EventReader events);
    [CompilerGeneratedAttribute]
public YamlNode get_RootNode();
    [CompilerGeneratedAttribute]
private void set_RootNode(YamlNode value);
    private void AssignAnchors();
    internal void Save(IEmitter emitter, bool isDocumentEndImplicit);
    public void Accept(IYamlVisitor visitor);
    public IEnumerable`1<YamlNode> get_AllNodes();
}
[AttributeUsageAttribute("384")]
public class SharpYaml.Serialization.YamlIgnoreAttribute : Attribute {
}
public class SharpYaml.Serialization.YamlMappingNode : YamlNode {
    private IOrderedDictionary`2<YamlNode, YamlNode> children;
    [CompilerGeneratedAttribute]
private YamlStyle <Style>k__BackingField;
    public IOrderedDictionary`2<YamlNode, YamlNode> Children { get; }
    public YamlStyle Style { get; public set; }
    public IEnumerable`1<YamlNode> AllNodes { get; }
    internal YamlMappingNode(EventReader events, DocumentLoadingState state);
    public YamlMappingNode(KeyValuePair`2[] children);
    public YamlMappingNode(IEnumerable`1<KeyValuePair`2<YamlNode, YamlNode>> children);
    public YamlMappingNode(YamlNode[] children);
    public YamlMappingNode(IEnumerable`1<YamlNode> children);
    public IOrderedDictionary`2<YamlNode, YamlNode> get_Children();
    [CompilerGeneratedAttribute]
public YamlStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(YamlStyle value);
    public void Add(YamlNode key, YamlNode value);
    public void Add(string key, YamlNode value);
    public void Add(YamlNode key, string value);
    public void Add(string key, string value);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("SharpYaml.Serialization.YamlMappingNode/<get_AllNodes>d__23")]
public virtual IEnumerable`1<YamlNode> get_AllNodes();
    public virtual string ToString();
    public sealed virtual IEnumerator`1<KeyValuePair`2<YamlNode, YamlNode>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[AttributeUsageAttribute("384")]
public class SharpYaml.Serialization.YamlMemberAttribute : Attribute {
    public static UInt32 DefaultMask;
    private SerializeMemberMode serializeMethod;
    private string name;
    private UInt32 mask;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    public string Name { get; }
    public SerializeMemberMode SerializeMethod { get; }
    public Nullable`1<int> Order { get; public set; }
    public UInt32 Mask { get; public set; }
    public YamlMemberAttribute(int order);
    public YamlMemberAttribute(string name);
    public YamlMemberAttribute(string name, SerializeMemberMode serializeMethod);
    public YamlMemberAttribute(SerializeMemberMode serializeMethod);
    public string get_Name();
    public SerializeMemberMode get_SerializeMethod();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    public UInt32 get_Mask();
    public void set_Mask(UInt32 value);
}
public abstract class SharpYaml.Serialization.YamlNode : object {
    [CompilerGeneratedAttribute]
private string <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private Mark <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Mark <End>k__BackingField;
    public string Anchor { get; public set; }
    public string Tag { get; public set; }
    public Mark Start { get; private set; }
    public Mark End { get; private set; }
    public IEnumerable`1<YamlNode> AllNodes { get; }
    [CompilerGeneratedAttribute]
public string get_Anchor();
    [CompilerGeneratedAttribute]
public void set_Anchor(string value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
    [CompilerGeneratedAttribute]
public Mark get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(Mark value);
    [CompilerGeneratedAttribute]
public Mark get_End();
    [CompilerGeneratedAttribute]
private void set_End(Mark value);
    internal void Load(NodeEvent yamlEvent, DocumentLoadingState state);
    internal static YamlNode ParseNode(EventReader events, DocumentLoadingState state);
    internal abstract virtual void ResolveAliases(DocumentLoadingState state);
    internal void Save(IEmitter emitter, EmitterState state);
    internal abstract virtual void Emit(IEmitter emitter, EmitterState state);
    public abstract virtual void Accept(IYamlVisitor visitor);
    protected bool Equals(YamlNode other);
    protected static bool SafeEquals(object first, object second);
    public virtual int GetHashCode();
    protected static int GetHashCode(object value);
    protected static int CombineHashCodes(int h1, int h2);
    public abstract virtual IEnumerable`1<YamlNode> get_AllNodes();
}
public class SharpYaml.Serialization.YamlNodeIdentityEqualityComparer : object {
    public sealed virtual bool Equals(YamlNode x, YamlNode y);
    public sealed virtual int GetHashCode(YamlNode obj);
}
[AttributeUsageAttribute("412")]
public class SharpYaml.Serialization.YamlRemapAttribute : Attribute {
    private string name;
    public string Name { get; }
    public YamlRemapAttribute(string name);
    public string get_Name();
}
[DebuggerDisplayAttribute("{Value}")]
public class SharpYaml.Serialization.YamlScalarNode : YamlNode {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ScalarStyle <Style>k__BackingField;
    public string Value { get; public set; }
    public ScalarStyle Style { get; public set; }
    public IEnumerable`1<YamlNode> AllNodes { get; }
    internal YamlScalarNode(EventReader events, DocumentLoadingState state);
    public YamlScalarNode(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public ScalarStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(ScalarStyle value);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static YamlScalarNode op_Implicit(string value);
    public static string op_Explicit(YamlScalarNode value);
    public virtual string ToString();
    [IteratorStateMachineAttribute("SharpYaml.Serialization.YamlScalarNode/<get_AllNodes>d__20")]
public virtual IEnumerable`1<YamlNode> get_AllNodes();
}
[DebuggerDisplayAttribute("Count = {children.Count}")]
public class SharpYaml.Serialization.YamlSequenceNode : YamlNode {
    private IList`1<YamlNode> children;
    [CompilerGeneratedAttribute]
private YamlStyle <Style>k__BackingField;
    public IList`1<YamlNode> Children { get; }
    public YamlStyle Style { get; public set; }
    public IEnumerable`1<YamlNode> AllNodes { get; }
    internal YamlSequenceNode(EventReader events, DocumentLoadingState state);
    public YamlSequenceNode(YamlNode[] children);
    public YamlSequenceNode(IEnumerable`1<YamlNode> children);
    public IList`1<YamlNode> get_Children();
    [CompilerGeneratedAttribute]
public YamlStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(YamlStyle value);
    public void Add(YamlNode child);
    public void Add(string child);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("SharpYaml.Serialization.YamlSequenceNode/<get_AllNodes>d__19")]
public virtual IEnumerable`1<YamlNode> get_AllNodes();
    public virtual string ToString();
    public sealed virtual IEnumerator`1<YamlNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class SharpYaml.Serialization.YamlStream : object {
    private IList`1<YamlDocument> documents;
    public IList`1<YamlDocument> Documents { get; }
    public YamlStream(YamlDocument[] documents);
    public YamlStream(IEnumerable`1<YamlDocument> documents);
    public IList`1<YamlDocument> get_Documents();
    public void Add(YamlDocument document);
    public void Load(TextReader input);
    public void Save(TextWriter output, bool isLastDocumentEndImplicit, int bestIndent);
    public void Accept(IYamlVisitor visitor);
    public sealed virtual IEnumerator`1<YamlDocument> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[AttributeUsageAttribute("396")]
public class SharpYaml.Serialization.YamlStyleAttribute : Attribute {
    private YamlStyle style;
    public YamlStyle Style { get; }
    public YamlStyleAttribute(YamlStyle style);
    public YamlStyle get_Style();
}
[AttributeUsageAttribute("28")]
public class SharpYaml.Serialization.YamlTagAttribute : Attribute {
    private string tag;
    public string Tag { get; }
    public YamlTagAttribute(string tag);
    public string get_Tag();
}
public abstract class SharpYaml.Serialization.YamlVisitor : object {
    protected virtual void Visit(YamlStream stream);
    protected virtual void Visited(YamlStream stream);
    protected virtual void Visit(YamlDocument document);
    protected virtual void Visited(YamlDocument document);
    protected virtual void Visit(YamlScalarNode scalar);
    protected virtual void Visited(YamlScalarNode scalar);
    protected virtual void Visit(YamlSequenceNode sequence);
    protected virtual void Visited(YamlSequenceNode sequence);
    protected virtual void Visit(YamlMappingNode mapping);
    protected virtual void Visited(YamlMappingNode mapping);
    protected virtual void VisitChildren(YamlStream stream);
    protected virtual void VisitChildren(YamlDocument document);
    protected virtual void VisitChildren(YamlSequenceNode sequence);
    protected virtual void VisitChildren(YamlMappingNode mapping);
    private sealed virtual override void SharpYaml.Serialization.IYamlVisitor.Visit(YamlStream stream);
    private sealed virtual override void SharpYaml.Serialization.IYamlVisitor.Visit(YamlDocument document);
    private sealed virtual override void SharpYaml.Serialization.IYamlVisitor.Visit(YamlScalarNode scalar);
    private sealed virtual override void SharpYaml.Serialization.IYamlVisitor.Visit(YamlSequenceNode sequence);
    private sealed virtual override void SharpYaml.Serialization.IYamlVisitor.Visit(YamlMappingNode mapping);
}
internal class SharpYaml.SimpleKey : object {
    private bool isPossible;
    private bool isRequired;
    private int tokenNumber;
    private Mark mark;
    public bool IsPossible { get; public set; }
    public bool IsRequired { get; }
    public int TokenNumber { get; }
    public Mark Mark { get; }
    public SimpleKey(bool isPossible, bool isRequired, int tokenNumber, Mark mark);
    public bool get_IsPossible();
    public void set_IsPossible(bool value);
    public bool get_IsRequired();
    public int get_TokenNumber();
    public Mark get_Mark();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class SharpYaml.SortedDictionary`2 : object {
    private KeyCollection<TKey, TValue> keys;
    private ValueCollection<TKey, TValue> values;
    private TreeSet`1<KeyValuePair`2<TKey, TValue>> _set;
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public IComparer`1<TKey> Comparer { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SortedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IComparer`1<TKey> comparer);
    public SortedDictionary`2(IComparer`1<TKey> comparer);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public IComparer`1<TKey> get_Comparer();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private static void VerifyKey(object key);
    private static bool IsCompatibleKey(object key);
    private static void VerifyValueType(object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class SharpYaml.StringExtension : object {
    [ExtensionAttribute]
public static string DoFormat(string format, Object[] args);
}
internal class SharpYaml.StringLookAheadBuffer : object {
    private string value;
    private int currentIndex;
    public int Length { get; }
    public int Position { get; }
    public bool EndOfInput { get; }
    public StringLookAheadBuffer(string value);
    public int get_Length();
    public int get_Position();
    private bool IsOutside(int index);
    public sealed virtual bool get_EndOfInput();
    public sealed virtual char Peek(int offset);
    public sealed virtual void Skip(int length);
}
public class SharpYaml.SyntaxErrorException : YamlException {
    public SyntaxErrorException(string message);
    public SyntaxErrorException(Mark start, Mark end, string message);
    public SyntaxErrorException(string message, Exception inner);
}
public class SharpYaml.TagDirectiveCollection : KeyedCollection`2<string, TagDirective> {
    public TagDirectiveCollection(IEnumerable`1<TagDirective> tagDirectives);
    protected virtual string GetKeyForItem(TagDirective item);
    public bool Contains(TagDirective directive);
}
public class SharpYaml.Tokens.Anchor : Token {
    private string value;
    public string Value { get; }
    public Anchor(string value);
    public Anchor(string value, Mark start, Mark end);
    public string get_Value();
}
public class SharpYaml.Tokens.AnchorAlias : Token {
    private string value;
    public string Value { get; }
    public AnchorAlias(string value);
    public AnchorAlias(string value, Mark start, Mark end);
    public string get_Value();
}
public class SharpYaml.Tokens.BlockEnd : Token {
    public BlockEnd(Mark start, Mark end);
}
public class SharpYaml.Tokens.BlockEntry : Token {
    public BlockEntry(Mark start, Mark end);
}
public class SharpYaml.Tokens.BlockMappingStart : Token {
    public BlockMappingStart(Mark start, Mark end);
}
public class SharpYaml.Tokens.BlockSequenceStart : Token {
    public BlockSequenceStart(Mark start, Mark end);
}
public class SharpYaml.Tokens.DocumentEnd : Token {
    public DocumentEnd(Mark start, Mark end);
}
public class SharpYaml.Tokens.DocumentStart : Token {
    public DocumentStart(Mark start, Mark end);
}
public class SharpYaml.Tokens.FlowEntry : Token {
    public FlowEntry(Mark start, Mark end);
}
public class SharpYaml.Tokens.FlowMappingEnd : Token {
    public FlowMappingEnd(Mark start, Mark end);
}
public class SharpYaml.Tokens.FlowMappingStart : Token {
    public FlowMappingStart(Mark start, Mark end);
}
public class SharpYaml.Tokens.FlowSequenceEnd : Token {
    public FlowSequenceEnd(Mark start, Mark end);
}
public class SharpYaml.Tokens.FlowSequenceStart : Token {
    public FlowSequenceStart(Mark start, Mark end);
}
public class SharpYaml.Tokens.Key : Token {
    public Key(Mark start, Mark end);
}
public class SharpYaml.Tokens.Scalar : Token {
    private string value;
    private ScalarStyle style;
    public string Value { get; }
    public ScalarStyle Style { get; }
    public Scalar(string value);
    public Scalar(string value, ScalarStyle style);
    public Scalar(string value, ScalarStyle style, Mark start, Mark end);
    public string get_Value();
    public ScalarStyle get_Style();
}
public class SharpYaml.Tokens.StreamEnd : Token {
    public StreamEnd(Mark start, Mark end);
}
public class SharpYaml.Tokens.StreamStart : Token {
    public StreamStart(Mark start, Mark end);
}
public class SharpYaml.Tokens.Tag : Token {
    private string handle;
    private string suffix;
    public string Handle { get; }
    public string Suffix { get; }
    public Tag(string handle, string suffix);
    public Tag(string handle, string suffix, Mark start, Mark end);
    public string get_Handle();
    public string get_Suffix();
}
public class SharpYaml.Tokens.TagDirective : Token {
    private string handle;
    private string prefix;
    private static Regex tagHandleValidator;
    public string Handle { get; }
    public string Prefix { get; }
    public TagDirective(string handle, string prefix);
    public TagDirective(string handle, string prefix, Mark start, Mark end);
    private static TagDirective();
    public string get_Handle();
    public string get_Prefix();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class SharpYaml.Tokens.Token : object {
    private Mark start;
    private Mark end;
    public Mark Start { get; }
    public Mark End { get; }
    protected Token(Mark start, Mark end);
    public Mark get_Start();
    public Mark get_End();
}
public class SharpYaml.Tokens.Value : Token {
    public Value(Mark start, Mark end);
}
public class SharpYaml.Tokens.VersionDirective : Token {
    private Version version;
    public Version Version { get; }
    public VersionDirective(Version version);
    public VersionDirective(Version version, Mark start, Mark end);
    public Version get_Version();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum SharpYaml.TreeRotation : Enum {
    public int value__;
    public static TreeRotation LeftRotation;
    public static TreeRotation RightRotation;
    public static TreeRotation RightLeftRotation;
    public static TreeRotation LeftRightRotation;
}
internal class SharpYaml.TreeSet`1 : object {
    private Node<T> root;
    private IComparer`1<T> comparer;
    private int count;
    private int version;
    private object _syncRoot;
    private static string ComparerName;
    private static string CountName;
    private static string ItemsName;
    private static string VersionName;
    public int Count { get; }
    public IComparer`1<T> Comparer { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public TreeSet`1(IComparer`1<T> comparer);
    public sealed virtual int get_Count();
    public IComparer`1<T> get_Comparer();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    internal bool InOrderTreeWalk(TreeWalkAction`1<T> action);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Node<T> FindNode(T item);
    public sealed virtual bool Remove(T item);
    private static Node<T> GetSibling(Node<T> node, Node<T> parent);
    private void InsertionBalance(Node<T> current, Node& parent, Node<T> grandParent, Node<T> greatGrandParent);
    private static bool Is2Node(Node<T> node);
    private static bool Is4Node(Node<T> node);
    private static bool IsBlack(Node<T> node);
    private static bool IsNullOrBlack(Node<T> node);
    private static bool IsRed(Node<T> node);
    private static void Merge2Nodes(Node<T> parent, Node<T> child1, Node<T> child2);
    private void ReplaceChildOfNodeOrRoot(Node<T> parent, Node<T> child, Node<T> newChild);
    private void ReplaceNode(Node<T> match, Node<T> parentOfMatch, Node<T> succesor, Node<T> parentOfSuccesor);
    internal void UpdateVersion();
    private static Node<T> RotateLeft(Node<T> node);
    private static Node<T> RotateLeftRight(Node<T> node);
    private static Node<T> RotateRight(Node<T> node);
    private static Node<T> RotateRightLeft(Node<T> node);
    private static TreeRotation RotationNeeded(Node<T> parent, Node<T> current, Node<T> sibling);
    private static void Split4Node(Node<T> node);
}
internal class SharpYaml.TreeWalkAction`1 : MulticastDelegate {
    public TreeWalkAction`1(object object, IntPtr method);
    public virtual bool Invoke(Node<T> node);
    public virtual IAsyncResult BeginInvoke(Node<T> node, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class SharpYaml.TypeExtensions : object {
    private static Dictionary`2<Type, bool> anonymousTypes;
    private static TypeExtensions();
    [ExtensionAttribute]
public static Type GetTypeInfo(Type type);
    [ExtensionAttribute]
public static bool HasInterface(Type type, Type lookInterfaceType);
    [ExtensionAttribute]
public static bool ExtendsGeneric(Type type, Type genericType);
    [ExtensionAttribute]
public static Type GetInterface(Type type, Type lookInterfaceType);
    [ExtensionAttribute]
public static string GetShortAssemblyQualifiedName(Type type);
    private static void DoGetShortAssemblyQualifiedName(Type type, StringBuilder sb, bool appendAssemblyName);
    [ExtensionAttribute]
public static string GetShortAssemblyName(Assembly assembly);
    [ExtensionAttribute]
public static bool IsAnonymous(Type type);
    [ExtensionAttribute]
public static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool IsPureValueType(Type type);
    [ExtensionAttribute]
public static bool IsStruct(Type type);
    [ExtensionAttribute]
public static bool IsNumeric(Type type);
    public static bool AreEqual(object a, object b);
    [ExtensionAttribute]
public static object CastToNumericType(Type type, object obj);
    public static double CastToDouble(object obj);
}
public class SharpYaml.Version : object {
    private int major;
    private int minor;
    public int Major { get; }
    public int Minor { get; }
    public Version(int major, int minor);
    public int get_Major();
    public int get_Minor();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class SharpYaml.YamlException : Exception {
    [CompilerGeneratedAttribute]
private Mark <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Mark <End>k__BackingField;
    public Mark Start { get; private set; }
    public Mark End { get; private set; }
    public YamlException(string message);
    public YamlException(Mark start, Mark end, string message);
    public YamlException(Mark start, Mark end, string message, Exception innerException);
    public YamlException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public Mark get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(Mark value);
    [CompilerGeneratedAttribute]
public Mark get_End();
    [CompilerGeneratedAttribute]
private void set_End(Mark value);
}
public enum SharpYaml.YamlStyle : Enum {
    public int value__;
    public static YamlStyle Any;
    public static YamlStyle Block;
    public static YamlStyle Flow;
}
