internal class dotless.Core.Abstractions.Clock : object {
    public sealed virtual DateTime GetUtcNow();
}
public class dotless.Core.Abstractions.Http : object {
    private HttpContextWrapper _context;
    public HttpContextBase Context { get; }
    public sealed virtual HttpContextBase get_Context();
}
public interface dotless.Core.Abstractions.IClock {
    public abstract virtual DateTime GetUtcNow();
}
public interface dotless.Core.Abstractions.IHttp {
    public HttpContextBase Context { get; }
    public abstract virtual HttpContextBase get_Context();
}
public class dotless.Core.AspNetContainerFactory : ContainerFactory {
    protected virtual void RegisterServices(FluentRegistration pandora, DotlessConfiguration configuration);
    protected virtual void RegisterParameterSource(FluentRegistration pandora, DotlessConfiguration configuration);
    private void RegisterWebServices(FluentRegistration pandora, DotlessConfiguration configuration);
}
public class dotless.Core.AspNetHttpHandlerContainerFactory : AspNetContainerFactory {
    protected virtual void RegisterParameterSource(FluentRegistration pandora, DotlessConfiguration configuration);
}
public class dotless.Core.Cache.HttpCache : object {
    private IHttp _http;
    private IFileReader _reader;
    [CompilerGeneratedAttribute]
private IPathResolver <PathResolver>k__BackingField;
    public IPathResolver PathResolver { get; public set; }
    public HttpCache(IHttp http, IPathResolver pathResolver, IFileReader reader);
    [CompilerGeneratedAttribute]
public IPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public void set_PathResolver(IPathResolver value);
    public sealed virtual void Insert(string cacheKey, IEnumerable`1<string> fileDependancies, string css);
    public sealed virtual bool Exists(string filename);
    public sealed virtual string Retrieve(string filename);
    private Cache GetCache();
    [CompilerGeneratedAttribute]
private string <Insert>b__0(string f);
}
public interface dotless.Core.Cache.ICache {
    public abstract virtual void Insert(string cacheKey, IEnumerable`1<string> fileDependancies, string css);
    public abstract virtual bool Exists(string cacheKey);
    public abstract virtual string Retrieve(string cacheKey);
}
public class dotless.Core.Cache.InMemoryCache : object {
    private Dictionary`2<string, string> _cache;
    public sealed virtual void Insert(string fileName, IEnumerable`1<string> imports, string css);
    public sealed virtual bool Exists(string filename);
    public sealed virtual string Retrieve(string filename);
}
public class dotless.Core.CacheDecorator : object {
    public ILessEngine Underlying;
    public ICache Cache;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public ILogger Logger { get; public set; }
    public bool LastTransformationSuccessful { get; }
    public string CurrentDirectory { get; public set; }
    public CacheDecorator(ILessEngine underlying, ICache cache);
    public CacheDecorator(ILessEngine underlying, ICache cache, ILogger logger);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    public sealed virtual string TransformToCss(string source, string fileName);
    private string ComputeContentHash(string source);
    public sealed virtual IEnumerable`1<string> GetImports();
    public sealed virtual void ResetImports();
    public sealed virtual bool get_LastTransformationSuccessful();
    public sealed virtual string get_CurrentDirectory();
    public sealed virtual void set_CurrentDirectory(string value);
}
public class dotless.Core.configuration.ConfigurationManagerWrapper : object {
    public sealed virtual T GetSection(string sectionName);
}
public class dotless.Core.configuration.DotlessConfiguration : object {
    public static string DEFAULT_SESSION_QUERY_PARAM_NAME;
    public static int DefaultHttpExpiryInMinutes;
    internal static IConfigurationManager _configurationManager;
    [CompilerGeneratedAttribute]
private bool <KeepFirstSpecialComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableUrlRewriting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableVariableRedefines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableColorCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InlineCssFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImportAllFilesAsLess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MapPathsToWeb>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MinifyOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HttpExpiryInMinutes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <LessSource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Web>k__BackingField;
    [CompilerGeneratedAttribute]
private DotlessSessionStateMode <SessionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionQueryParamName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Optimization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HandleWebCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IPluginConfigurator> <Plugins>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictMath>k__BackingField;
    public static IConfigurationManager ConfigurationManager { get; public set; }
    public bool KeepFirstSpecialComment { get; public set; }
    public bool DisableParameters { get; public set; }
    public bool DisableUrlRewriting { get; public set; }
    public string RootPath { get; public set; }
    public bool DisableVariableRedefines { get; public set; }
    public bool DisableColorCompression { get; public set; }
    public bool InlineCssFiles { get; public set; }
    public bool ImportAllFilesAsLess { get; public set; }
    public bool MapPathsToWeb { get; public set; }
    public bool MinifyOutput { get; public set; }
    public bool Debug { get; public set; }
    public bool CacheEnabled { get; public set; }
    public int HttpExpiryInMinutes { get; public set; }
    public Type LessSource { get; public set; }
    public bool Web { get; public set; }
    public DotlessSessionStateMode SessionMode { get; public set; }
    public string SessionQueryParamName { get; public set; }
    public Type Logger { get; public set; }
    public LogLevel LogLevel { get; public set; }
    public int Optimization { get; public set; }
    public bool HandleWebCompression { get; public set; }
    public List`1<IPluginConfigurator> Plugins { get; private set; }
    public bool StrictMath { get; public set; }
    public DotlessConfiguration(DotlessConfiguration config);
    public static DotlessConfiguration GetDefault();
    public static DotlessConfiguration GetDefaultWeb();
    public static IConfigurationManager get_ConfigurationManager();
    public static void set_ConfigurationManager(IConfigurationManager value);
    [CompilerGeneratedAttribute]
public bool get_KeepFirstSpecialComment();
    [CompilerGeneratedAttribute]
public void set_KeepFirstSpecialComment(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableParameters();
    [CompilerGeneratedAttribute]
public void set_DisableParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableUrlRewriting();
    [CompilerGeneratedAttribute]
public void set_DisableUrlRewriting(bool value);
    [CompilerGeneratedAttribute]
public string get_RootPath();
    [CompilerGeneratedAttribute]
public void set_RootPath(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableVariableRedefines();
    [CompilerGeneratedAttribute]
public void set_DisableVariableRedefines(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableColorCompression();
    [CompilerGeneratedAttribute]
public void set_DisableColorCompression(bool value);
    [CompilerGeneratedAttribute]
public bool get_InlineCssFiles();
    [CompilerGeneratedAttribute]
public void set_InlineCssFiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_ImportAllFilesAsLess();
    [CompilerGeneratedAttribute]
public void set_ImportAllFilesAsLess(bool value);
    [CompilerGeneratedAttribute]
public bool get_MapPathsToWeb();
    [CompilerGeneratedAttribute]
public void set_MapPathsToWeb(bool value);
    [CompilerGeneratedAttribute]
public bool get_MinifyOutput();
    [CompilerGeneratedAttribute]
public void set_MinifyOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public bool get_CacheEnabled();
    [CompilerGeneratedAttribute]
public void set_CacheEnabled(bool value);
    [CompilerGeneratedAttribute]
public int get_HttpExpiryInMinutes();
    [CompilerGeneratedAttribute]
public void set_HttpExpiryInMinutes(int value);
    [CompilerGeneratedAttribute]
public Type get_LessSource();
    [CompilerGeneratedAttribute]
public void set_LessSource(Type value);
    [CompilerGeneratedAttribute]
public bool get_Web();
    [CompilerGeneratedAttribute]
public void set_Web(bool value);
    [CompilerGeneratedAttribute]
public DotlessSessionStateMode get_SessionMode();
    [CompilerGeneratedAttribute]
public void set_SessionMode(DotlessSessionStateMode value);
    [CompilerGeneratedAttribute]
public string get_SessionQueryParamName();
    [CompilerGeneratedAttribute]
public void set_SessionQueryParamName(string value);
    [CompilerGeneratedAttribute]
public Type get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(Type value);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public int get_Optimization();
    [CompilerGeneratedAttribute]
public void set_Optimization(int value);
    [CompilerGeneratedAttribute]
public bool get_HandleWebCompression();
    [CompilerGeneratedAttribute]
public void set_HandleWebCompression(bool value);
    [CompilerGeneratedAttribute]
public List`1<IPluginConfigurator> get_Plugins();
    [CompilerGeneratedAttribute]
private void set_Plugins(List`1<IPluginConfigurator> value);
    [CompilerGeneratedAttribute]
public bool get_StrictMath();
    [CompilerGeneratedAttribute]
public void set_StrictMath(bool value);
}
public class dotless.Core.configuration.DotlessConfigurationSectionHandler : object {
    public sealed virtual object Create(object parent, object configContext, XmlNode section);
}
public enum dotless.Core.configuration.DotlessSessionStateMode : Enum {
    public int value__;
    public static DotlessSessionStateMode Disabled;
    public static DotlessSessionStateMode Enabled;
    public static DotlessSessionStateMode QueryParam;
}
public interface dotless.Core.configuration.IConfigurationManager {
    public abstract virtual T GetSection(string sectionName);
}
public class dotless.Core.configuration.WebConfigConfigurationLoader : object {
    public DotlessConfiguration GetConfiguration();
}
public class dotless.Core.configuration.XmlConfigurationInterpreter : object {
    public DotlessConfiguration Process(XmlNode section);
    private static string GetStringValue(XmlNode section, string property);
    private static Nullable`1<int> GetIntValue(XmlNode section, string property);
    private static Nullable`1<bool> GetBoolValue(XmlNode section, string property);
    private static Type GetTypeValue(XmlNode section, string property);
    private static IEnumerable`1<IPluginConfigurator> GetPlugins(XmlNode section);
}
public class dotless.Core.ContainerFactory : object {
    [CompilerGeneratedAttribute]
private PandoraContainer <Container>k__BackingField;
    protected PandoraContainer Container { get; protected set; }
    [CompilerGeneratedAttribute]
protected PandoraContainer get_Container();
    [CompilerGeneratedAttribute]
protected void set_Container(PandoraContainer value);
    public IServiceLocator GetContainer(DotlessConfiguration configuration);
    protected virtual void RegisterServices(FluentRegistration pandora, DotlessConfiguration configuration);
    protected virtual void OverrideServices(FluentRegistration pandora, DotlessConfiguration configuration);
    protected virtual void RegisterLocalServices(FluentRegistration pandora);
    protected virtual void RegisterCoreServices(FluentRegistration pandora, DotlessConfiguration configuration);
}
public class dotless.Core.EngineFactory : object {
    [CompilerGeneratedAttribute]
private DotlessConfiguration <Configuration>k__BackingField;
    public DotlessConfiguration Configuration { get; public set; }
    public EngineFactory(DotlessConfiguration configuration);
    [CompilerGeneratedAttribute]
public DotlessConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(DotlessConfiguration value);
    public ILessEngine GetEngine();
    public ILessEngine GetEngine(ContainerFactory containerFactory);
}
public class dotless.Core.Exceptions.ParserException : Exception {
    [CompilerGeneratedAttribute]
private Zone <ErrorLocation>k__BackingField;
    public Zone ErrorLocation { get; public set; }
    public ParserException(string message);
    public ParserException(string message, Exception innerException);
    public ParserException(string message, Exception innerException, Zone errorLocation);
    [CompilerGeneratedAttribute]
public Zone get_ErrorLocation();
    [CompilerGeneratedAttribute]
public void set_ErrorLocation(Zone value);
}
public class dotless.Core.Exceptions.ParsingException : Exception {
    [CompilerGeneratedAttribute]
private NodeLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeLocation <CallLocation>k__BackingField;
    public NodeLocation Location { get; public set; }
    public NodeLocation CallLocation { get; public set; }
    public ParsingException(string message, NodeLocation location);
    public ParsingException(string message, NodeLocation location, NodeLocation callLocation);
    public ParsingException(Exception innerException, NodeLocation location);
    public ParsingException(Exception innerException, NodeLocation location, NodeLocation callLocation);
    public ParsingException(string message, Exception innerException, NodeLocation location);
    public ParsingException(string message, Exception innerException, NodeLocation location, NodeLocation callLocation);
    [CompilerGeneratedAttribute]
public NodeLocation get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(NodeLocation value);
    [CompilerGeneratedAttribute]
public NodeLocation get_CallLocation();
    [CompilerGeneratedAttribute]
public void set_CallLocation(NodeLocation value);
}
public class dotless.Core.HandlerImpl : object {
    public IHttp Http;
    public IResponse Response;
    public ILessEngine Engine;
    public IFileReader FileReader;
    public HandlerImpl(IHttp http, IResponse response, ILessEngine engine, IFileReader fileReader);
    public void Execute();
}
public interface dotless.Core.ILessEngine {
    public bool LastTransformationSuccessful { get; }
    public string CurrentDirectory { get; public set; }
    public abstract virtual string TransformToCss(string source, string fileName);
    public abstract virtual void ResetImports();
    public abstract virtual IEnumerable`1<string> GetImports();
    public abstract virtual bool get_LastTransformationSuccessful();
    public abstract virtual string get_CurrentDirectory();
    public abstract virtual void set_CurrentDirectory(string value);
}
public interface dotless.Core.Importers.IImporter {
    public List`1<string> Imports { get; }
    public Func`1<Parser> Parser { get; public set; }
    public string CurrentDirectory { get; public set; }
    public abstract virtual List`1<string> GetCurrentPathsClone();
    public abstract virtual ImportAction Import(Import import);
    public abstract virtual List`1<string> get_Imports();
    public abstract virtual Func`1<Parser> get_Parser();
    public abstract virtual void set_Parser(Func`1<Parser> value);
    public abstract virtual string AlterUrl(string url, List`1<string> pathList);
    public abstract virtual string get_CurrentDirectory();
    public abstract virtual void set_CurrentDirectory(string value);
    public abstract virtual IDisposable BeginScope(Import parent);
}
public enum dotless.Core.Importers.ImportAction : Enum {
    public int value__;
    public static ImportAction ImportLess;
    public static ImportAction ImportCss;
    public static ImportAction LeaveImport;
    public static ImportAction ImportNothing;
}
public class dotless.Core.Importers.Importer : object {
    private static Regex _embeddedResourceRegex;
    private List`1<string> _paths;
    protected List`1<string> _rawImports;
    private List`1<string> _referenceImports;
    [CompilerGeneratedAttribute]
private IFileReader <FileReader>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<Parser> <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUrlRewritingDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImportAllFilesAsLess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InlineCssFiles>k__BackingField;
    public static Regex EmbeddedResourceRegex { get; }
    public IFileReader FileReader { get; public set; }
    public List`1<string> Imports { get; public set; }
    public Func`1<Parser> Parser { get; public set; }
    public string CurrentDirectory { get; public set; }
    public bool IsUrlRewritingDisabled { get; public set; }
    public string RootPath { get; public set; }
    public bool ImportAllFilesAsLess { get; public set; }
    public bool InlineCssFiles { get; public set; }
    public Importer(IFileReader fileReader);
    public Importer(IFileReader fileReader, bool disableUrlReWriting, string rootPath, bool inlineCssFiles, bool importAllFilesAsLess);
    private static Importer();
    public static Regex get_EmbeddedResourceRegex();
    [CompilerGeneratedAttribute]
public IFileReader get_FileReader();
    [CompilerGeneratedAttribute]
public void set_FileReader(IFileReader value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<string> get_Imports();
    [CompilerGeneratedAttribute]
public void set_Imports(List`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`1<Parser> get_Parser();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parser(Func`1<Parser> value);
    [CompilerGeneratedAttribute]
public virtual string get_CurrentDirectory();
    [CompilerGeneratedAttribute]
public virtual void set_CurrentDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_IsUrlRewritingDisabled();
    [CompilerGeneratedAttribute]
public void set_IsUrlRewritingDisabled(bool value);
    [CompilerGeneratedAttribute]
public string get_RootPath();
    [CompilerGeneratedAttribute]
public void set_RootPath(string value);
    [CompilerGeneratedAttribute]
public bool get_ImportAllFilesAsLess();
    [CompilerGeneratedAttribute]
public void set_ImportAllFilesAsLess(bool value);
    [CompilerGeneratedAttribute]
public bool get_InlineCssFiles();
    [CompilerGeneratedAttribute]
public void set_InlineCssFiles(bool value);
    private static bool IsProtocolUrl(string url);
    private static bool IsNonRelativeUrl(string url);
    private static bool IsEmbeddedResource(string path);
    public sealed virtual List`1<string> GetCurrentPathsClone();
    protected bool CheckIgnoreImport(Import import);
    protected bool CheckIgnoreImport(Import import, string path);
    private bool CheckIgnoreImport(List`1<string> importList, string path);
    public virtual ImportAction Import(Import import);
    public sealed virtual IDisposable BeginScope(Import parentScope);
    protected string GetAdjustedFilePath(string path, IEnumerable`1<string> pathList);
    protected bool ImportLessFile(string lessPath, Import import);
    private bool ImportEmbeddedCssContents(string file, Import import);
    protected bool ImportCssFileContents(string file, Import import);
    public sealed virtual string AlterUrl(string url, List`1<string> pathList);
    private bool IsOptionSet(ImportOptions options, ImportOptions test);
}
internal class dotless.Core.Importers.ResourceLoader : MarshalByRefObject {
    private Byte[] _fileContents;
    private string _resourceName;
    private string _resourceContent;
    public static string GetResource(string file, IFileReader fileReader, String& fileDependency);
    private static void LoadFromCurrentAppDomain(ResourceLoader loader, string assemblyName);
    private static bool IsDynamicAssembly(Assembly assembly);
    private static void LoadFromNewAppDomain(ResourceLoader loader, IFileReader fileReader, string assemblyName);
    private void LoadResource();
}
public class dotless.Core.Input.AspRelativePathResolver : object {
    public sealed virtual string GetFullPath(string path);
}
public class dotless.Core.Input.AspServerPathResolver : object {
    public sealed virtual string GetFullPath(string path);
}
public class dotless.Core.Input.FileReader : object {
    [CompilerGeneratedAttribute]
private IPathResolver <PathResolver>k__BackingField;
    public IPathResolver PathResolver { get; public set; }
    public bool UseCacheDependencies { get; }
    public FileReader(IPathResolver pathResolver);
    [CompilerGeneratedAttribute]
public IPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public void set_PathResolver(IPathResolver value);
    public sealed virtual Byte[] GetBinaryFileContents(string fileName);
    public sealed virtual string GetFileContents(string fileName);
    public sealed virtual bool DoesFileExist(string fileName);
    public sealed virtual bool get_UseCacheDependencies();
}
public interface dotless.Core.Input.IFileReader {
    public bool UseCacheDependencies { get; }
    public abstract virtual Byte[] GetBinaryFileContents(string fileName);
    public abstract virtual string GetFileContents(string fileName);
    public abstract virtual bool DoesFileExist(string fileName);
    public abstract virtual bool get_UseCacheDependencies();
}
public interface dotless.Core.Input.IPathResolver {
    public abstract virtual string GetFullPath(string path);
}
public class dotless.Core.Input.RelativePathResolver : object {
    public sealed virtual string GetFullPath(string path);
}
public class dotless.Core.Input.VirtualFileReader : object {
    public bool UseCacheDependencies { get; }
    public sealed virtual Byte[] GetBinaryFileContents(string fileName);
    public sealed virtual string GetFileContents(string fileName);
    public sealed virtual bool DoesFileExist(string fileName);
    public sealed virtual bool get_UseCacheDependencies();
}
public static class dotless.Core.Less : object {
    public static string Parse(string less);
    public static string Parse(string less, DotlessConfiguration config);
}
public class dotless.Core.LessCssHttpHandler : LessCssHttpHandlerBase {
    public bool IsReusable { get; }
    public sealed virtual void ProcessRequest(HttpContext context);
    public sealed virtual bool get_IsReusable();
}
public abstract class dotless.Core.LessCssHttpHandlerBase : object {
    private DotlessConfiguration _config;
    private IServiceLocator _container;
    public DotlessConfiguration Config { get; public set; }
    public IServiceLocator Container { get; public set; }
    public DotlessConfiguration get_Config();
    public void set_Config(DotlessConfiguration value);
    public IServiceLocator get_Container();
    public void set_Container(IServiceLocator value);
    protected virtual ContainerFactory GetContainerFactory();
}
public class dotless.Core.LessCssHttpHandlerFactory : LessCssHttpHandlerBase {
    public IHttpHandler GetHandler();
    private sealed virtual override IHttpHandler System.Web.IHttpHandlerFactory.GetHandler(HttpContext context, string requestType, string url, string pathTranslated);
    private sealed virtual override void System.Web.IHttpHandlerFactory.ReleaseHandler(IHttpHandler handler);
}
public class dotless.Core.LessCssWithSessionHttpHandler : LessCssHttpHandler {
}
public class dotless.Core.LessEngine : object {
    [CompilerGeneratedAttribute]
private Parser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Compress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableVariableRedefines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableColorCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepFirstSpecialComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictMath>k__BackingField;
    [CompilerGeneratedAttribute]
private Env <Env>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPluginConfigurator> <Plugins>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LastTransformationSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private ParserException <LastTransformationError>k__BackingField;
    public Parser Parser { get; public set; }
    public ILogger Logger { get; public set; }
    public bool Compress { get; public set; }
    public bool Debug { get; public set; }
    public bool DisableVariableRedefines { get; public set; }
    public bool DisableColorCompression { get; public set; }
    public bool KeepFirstSpecialComment { get; public set; }
    public bool StrictMath { get; public set; }
    public Env Env { get; public set; }
    public IEnumerable`1<IPluginConfigurator> Plugins { get; public set; }
    public bool LastTransformationSuccessful { get; private set; }
    public string CurrentDirectory { get; public set; }
    public ParserException LastTransformationError { get; public set; }
    public LessEngine(Parser parser, ILogger logger, bool compress, bool debug, bool disableVariableRedefines, bool disableColorCompression, bool keepFirstSpecialComment, bool strictMath, IEnumerable`1<IPluginConfigurator> plugins);
    public LessEngine(Parser parser, ILogger logger, bool compress, bool debug, bool disableVariableRedefines, bool disableColorCompression, bool keepFirstSpecialComment, IEnumerable`1<IPluginConfigurator> plugins);
    public LessEngine(Parser parser, ILogger logger, bool compress, bool debug);
    public LessEngine(Parser parser, ILogger logger, bool compress, bool debug, bool disableVariableRedefines);
    public LessEngine(Parser parser);
    [CompilerGeneratedAttribute]
public Parser get_Parser();
    [CompilerGeneratedAttribute]
public void set_Parser(Parser value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public bool get_Compress();
    [CompilerGeneratedAttribute]
public void set_Compress(bool value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableVariableRedefines();
    [CompilerGeneratedAttribute]
public void set_DisableVariableRedefines(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableColorCompression();
    [CompilerGeneratedAttribute]
public void set_DisableColorCompression(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepFirstSpecialComment();
    [CompilerGeneratedAttribute]
public void set_KeepFirstSpecialComment(bool value);
    [CompilerGeneratedAttribute]
public bool get_StrictMath();
    [CompilerGeneratedAttribute]
public void set_StrictMath(bool value);
    [CompilerGeneratedAttribute]
public Env get_Env();
    [CompilerGeneratedAttribute]
public void set_Env(Env value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IPluginConfigurator> get_Plugins();
    [CompilerGeneratedAttribute]
public void set_Plugins(IEnumerable`1<IPluginConfigurator> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_LastTransformationSuccessful();
    [CompilerGeneratedAttribute]
private void set_LastTransformationSuccessful(bool value);
    public sealed virtual string get_CurrentDirectory();
    public sealed virtual void set_CurrentDirectory(string value);
    public sealed virtual string TransformToCss(string source, string fileName);
    [CompilerGeneratedAttribute]
public ParserException get_LastTransformationError();
    [CompilerGeneratedAttribute]
public void set_LastTransformationError(ParserException value);
    public sealed virtual IEnumerable`1<string> GetImports();
    public sealed virtual void ResetImports();
}
public static class dotless.Core.LessWeb : object {
    public static string Parse(string less, DotlessConfiguration config);
    public static ILessEngine GetEngine(DotlessConfiguration config);
}
public class dotless.Core.Loggers.AspNetTraceLogger : Logger {
    private IHttp http;
    public AspNetTraceLogger(LogLevel level, IHttp http);
    protected virtual void Log(string message);
}
public class dotless.Core.Loggers.AspResponseLogger : Logger {
    [CompilerGeneratedAttribute]
private IResponse <Response>k__BackingField;
    public IResponse Response { get; public set; }
    public AspResponseLogger(LogLevel level, IResponse response);
    [CompilerGeneratedAttribute]
public IResponse get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(IResponse value);
    protected virtual void Log(string message);
}
public class dotless.Core.Loggers.ConsoleLogger : Logger {
    public ConsoleLogger(LogLevel level);
    protected virtual void Log(string message);
}
public class dotless.Core.Loggers.DiagnosticsLogger : Logger {
    public DiagnosticsLogger(LogLevel level);
    protected virtual void Log(string message);
}
public interface dotless.Core.Loggers.ILogger {
    public abstract virtual void Log(LogLevel level, string message);
    public abstract virtual void Info(string message);
    public abstract virtual void Info(string message, Object[] args);
    public abstract virtual void Debug(string message);
    public abstract virtual void Debug(string message, Object[] args);
    public abstract virtual void Warn(string message);
    public abstract virtual void Warn(string message, Object[] args);
    public abstract virtual void Error(string message);
    public abstract virtual void Error(string message, Object[] args);
}
public abstract class dotless.Core.Loggers.Logger : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    public LogLevel Level { get; public set; }
    protected Logger(LogLevel level);
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(LogLevel value);
    public sealed virtual void Log(LogLevel level, string message);
    protected abstract virtual void Log(string message);
    public sealed virtual void Info(string message);
    public sealed virtual void Debug(string message);
    public sealed virtual void Warn(string message);
    public sealed virtual void Error(string message);
    public sealed virtual void Info(string message, Object[] args);
    public sealed virtual void Debug(string message, Object[] args);
    public sealed virtual void Warn(string message, Object[] args);
    public sealed virtual void Error(string message, Object[] args);
}
public enum dotless.Core.Loggers.LogLevel : Enum {
    public int value__;
    public static LogLevel Info;
    public static LogLevel Debug;
    public static LogLevel Warn;
    public static LogLevel Error;
}
public class dotless.Core.Loggers.NullLogger : Logger {
    private static NullLogger instance;
    public static NullLogger Instance { get; }
    public NullLogger(LogLevel level);
    private static NullLogger();
    protected virtual void Log(string message);
    public static NullLogger get_Instance();
}
public class dotless.Core.ParameterDecorator : object {
    public ILessEngine Underlying;
    private IParameterSource parameterSource;
    public bool LastTransformationSuccessful { get; }
    public string CurrentDirectory { get; public set; }
    public ParameterDecorator(ILessEngine underlying, IParameterSource parameterSource);
    public sealed virtual string TransformToCss(string source, string fileName);
    public sealed virtual IEnumerable`1<string> GetImports();
    public sealed virtual void ResetImports();
    public sealed virtual bool get_LastTransformationSuccessful();
    private static bool ValueIsNotNullOrEmpty(KeyValuePair`2<string, string> kvp);
    public sealed virtual string get_CurrentDirectory();
    public sealed virtual void set_CurrentDirectory(string value);
}
public class dotless.Core.Parameters.ConsoleArgumentParameterSource : object {
    public static IDictionary`2<string, string> ConsoleArguments;
    private static ConsoleArgumentParameterSource();
    public sealed virtual IDictionary`2<string, string> GetParameters();
}
public interface dotless.Core.Parameters.IParameterSource {
    public abstract virtual IDictionary`2<string, string> GetParameters();
}
public class dotless.Core.Parameters.NullParameterSource : object {
    public sealed virtual IDictionary`2<string, string> GetParameters();
}
public class dotless.Core.Parameters.QueryStringParameterSource : object {
    private IHttp http;
    private Regex _keyWhitelist;
    private Regex _valueWhitelist;
    public QueryStringParameterSource(IHttp http);
    public sealed virtual IDictionary`2<string, string> GetParameters();
}
public class dotless.Core.Parser.Extract : object {
    [CompilerGeneratedAttribute]
private string <After>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Line>k__BackingField;
    public string After { get; public set; }
    public string Before { get; public set; }
    public string Line { get; public set; }
    public Extract(String[] lines, int line);
    [CompilerGeneratedAttribute]
public string get_After();
    [CompilerGeneratedAttribute]
public void set_After(string value);
    [CompilerGeneratedAttribute]
public string get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(string value);
    [CompilerGeneratedAttribute]
public string get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(string value);
}
public class dotless.Core.Parser.Functions.AbsFunction : NumberFunctionBase {
    protected virtual Node Eval(Env env, Number number, Node[] args);
}
public class dotless.Core.Parser.Functions.AddFunction : Function {
    [CompilerGeneratedAttribute]
private static Func`2<Number, double> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`3<double, double, double> CS$<>9__CachedAnonymousMethodDelegate3;
    protected virtual Node Evaluate(Env env);
    [CompilerGeneratedAttribute]
private static double <Evaluate>b__0(Number d);
    [CompilerGeneratedAttribute]
private static double <Evaluate>b__1(double a, double b);
}
public class dotless.Core.Parser.Functions.AlphaFunction : FadeInFunction {
    protected virtual Node EditColor(Color color, Number number);
}
public class dotless.Core.Parser.Functions.ArgbFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.AverageFunction : ColorMixFunction {
    protected virtual double Operate(double a, double b);
}
public class dotless.Core.Parser.Functions.BlueFunction : ColorFunctionBase {
    protected virtual Node Eval(Color color);
    protected virtual Node EditColor(Color color, Number number);
}
public class dotless.Core.Parser.Functions.CeilFunction : NumberFunctionBase {
    protected virtual Node Eval(Env env, Number number, Node[] args);
}
public class dotless.Core.Parser.Functions.CFormatString : Function {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.ColorFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public abstract class dotless.Core.Parser.Functions.ColorFunctionBase : Function {
    protected virtual Node Evaluate(Env env);
    protected abstract virtual Node Eval(Color color);
    protected virtual Node EditColor(Color color, Number number);
}
public abstract class dotless.Core.Parser.Functions.ColorMixFunction : Function {
    [CompilerGeneratedAttribute]
private static Func`2<Color, double> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Color, double> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<Color, double> CS$<>9__CachedAnonymousMethodDelegate5;
    protected virtual Node Evaluate(Env env);
    private double Compose(Color backdrop, Color source, double ar, Func`2<Color, double> channel);
    protected abstract virtual double Operate(double a, double b);
    [CompilerGeneratedAttribute]
private static double <Evaluate>b__0(Color c);
    [CompilerGeneratedAttribute]
private static double <Evaluate>b__1(Color c);
    [CompilerGeneratedAttribute]
private static double <Evaluate>b__2(Color c);
}
public class dotless.Core.Parser.Functions.ComplementFunction : HslColorFunctionBase {
    protected virtual Node EvalHsl(HslColor color);
    protected virtual Node EditHsl(HslColor color, Number number);
}
public class dotless.Core.Parser.Functions.ContrastFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.DarkenFunction : LightenFunction {
    protected virtual Node EditHsl(HslColor color, Number number);
}
public class dotless.Core.Parser.Functions.DataUriFunction : Function {
    protected virtual Node Evaluate(Env env);
    private string GetDataUriFilename();
    private string ConvertFileToBase64(string filename);
    private string GetMimeType(string filename);
}
public class dotless.Core.Parser.Functions.DefaultFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.DesaturateFunction : SaturateFunction {
    protected virtual Node EditHsl(HslColor color, Number number);
}
public class dotless.Core.Parser.Functions.DifferenceFunction : ColorMixFunction {
    protected virtual double Operate(double a, double b);
}
public class dotless.Core.Parser.Functions.EFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.ExclusionFunction : ColorMixFunction {
    protected virtual double Operate(double a, double b);
}
public class dotless.Core.Parser.Functions.ExtractFunction : ListFunctionBase {
    protected virtual Node Eval(Env env, Node[] list, Node[] args);
}
public class dotless.Core.Parser.Functions.FadeFunction : AlphaFunction {
    protected virtual double ProcessAlpha(double originalAlpha, double newAlpha);
}
public class dotless.Core.Parser.Functions.FadeInFunction : ColorFunctionBase {
    protected virtual Node Eval(Color color);
    protected virtual Node EditColor(Color color, Number number);
    protected virtual double ProcessAlpha(double originalAlpha, double newAlpha);
}
public class dotless.Core.Parser.Functions.FadeOutFunction : AlphaFunction {
    protected virtual Node EditColor(Color color, Number number);
}
public class dotless.Core.Parser.Functions.FloorFunction : NumberFunctionBase {
    protected virtual Node Eval(Env env, Number number, Node[] args);
}
public class dotless.Core.Parser.Functions.FormatStringFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public abstract class dotless.Core.Parser.Functions.Function : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Node> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeLocation <Location>k__BackingField;
    public string Name { get; public set; }
    protected List`1<Node> Arguments { get; protected set; }
    public ILogger Logger { get; public set; }
    public NodeLocation Location { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
protected List`1<Node> get_Arguments();
    [CompilerGeneratedAttribute]
protected void set_Arguments(List`1<Node> value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public NodeLocation get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(NodeLocation value);
    public Node Call(Env env, IEnumerable`1<Node> arguments);
    protected abstract virtual Node Evaluate(Env env);
    public virtual string ToString();
    protected void WarnNotSupportedByLessJS(string functionPattern);
    protected void WarnNotSupportedByLessJS(string functionPattern, string replacementPattern);
    protected void WarnNotSupportedByLessJS(string functionPattern, string replacementPattern, string extraInfo);
}
public class dotless.Core.Parser.Functions.GradientImageFunction : Function {
    public static int DEFAULT_COLOR_OFFSET;
    private static int CACHE_LIMIT;
    private static ReaderWriterLockSlim _cacheLock;
    private static List`1<CacheItem> _cache;
    private static GradientImageFunction();
    protected virtual Node Evaluate(Env env);
    private Byte[] GetImageData(ColorPoint[] points);
    private ColorPoint[] GetColorPoints();
    private static string GetFromCache(string colorDefs);
    private static void AddToCache(string colorDefs, string imageUrl);
}
public class dotless.Core.Parser.Functions.GrayscaleFunction : GreyscaleFunction {
    protected virtual Node Eval(Color color);
}
public class dotless.Core.Parser.Functions.GreenFunction : ColorFunctionBase {
    protected virtual Node Eval(Color color);
    protected virtual Node EditColor(Color color, Number number);
}
public class dotless.Core.Parser.Functions.GreyscaleFunction : ColorFunctionBase {
    protected virtual Node Eval(Color color);
}
public class dotless.Core.Parser.Functions.HardlightFunction : ColorMixFunction {
    protected virtual double Operate(double a, double b);
}
public class dotless.Core.Parser.Functions.HexFunction : NumberFunctionBase {
    protected virtual Node Eval(Env env, Number number, Node[] args);
    private static double Clamp(double value, double max, double min);
}
public class dotless.Core.Parser.Functions.HslaFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public abstract class dotless.Core.Parser.Functions.HslColorFunctionBase : ColorFunctionBase {
    protected virtual Node Eval(Color color);
    protected virtual Node EditColor(Color color, Number number);
    protected abstract virtual Node EvalHsl(HslColor color);
    protected abstract virtual Node EditHsl(HslColor color, Number number);
}
public class dotless.Core.Parser.Functions.HslFunction : HslaFunction {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.HueFunction : HslColorFunctionBase {
    protected virtual Node EvalHsl(HslColor color);
    protected virtual Node EditHsl(HslColor color, Number number);
}
public class dotless.Core.Parser.Functions.IncrementFunction : NumberFunctionBase {
    protected virtual Node Eval(Env env, Number number, Node[] args);
}
public class dotless.Core.Parser.Functions.IsColorFunction : IsTypeFunction`1<Color> {
}
public abstract class dotless.Core.Parser.Functions.IsDimensionUnitFunction : IsTypeFunction`1<Number> {
    protected string Unit { get; }
    protected abstract virtual string get_Unit();
    protected virtual bool IsEvaluator(Node node);
}
public class dotless.Core.Parser.Functions.IsEm : IsDimensionUnitFunction {
    protected string Unit { get; }
    protected virtual string get_Unit();
}
public abstract class dotless.Core.Parser.Functions.IsFunction : Function {
    protected virtual Node Evaluate(Env env);
    protected abstract virtual bool IsEvaluator(Node node);
}
public class dotless.Core.Parser.Functions.IsKeyword : IsTypeFunction`1<Keyword> {
}
public class dotless.Core.Parser.Functions.IsNumber : IsTypeFunction`1<Number> {
}
public class dotless.Core.Parser.Functions.IsPercentage : IsDimensionUnitFunction {
    protected string Unit { get; }
    protected virtual string get_Unit();
}
public class dotless.Core.Parser.Functions.IsPixel : IsDimensionUnitFunction {
    protected string Unit { get; }
    protected virtual string get_Unit();
}
public class dotless.Core.Parser.Functions.IsString : IsTypeFunction`1<Quoted> {
}
public abstract class dotless.Core.Parser.Functions.IsTypeFunction`1 : IsFunction {
    protected virtual bool IsEvaluator(Node node);
}
public class dotless.Core.Parser.Functions.IsUrl : IsTypeFunction`1<Url> {
}
public class dotless.Core.Parser.Functions.LengthFunction : ListFunctionBase {
    protected virtual Node Eval(Env env, Node[] list, Node[] args);
}
public class dotless.Core.Parser.Functions.LightenFunction : HslColorFunctionBase {
    protected virtual Node EvalHsl(HslColor color);
    protected virtual Node EditHsl(HslColor color, Number number);
}
public class dotless.Core.Parser.Functions.LightnessFunction : LightenFunction {
    protected virtual Node EditHsl(HslColor color, Number number);
}
public abstract class dotless.Core.Parser.Functions.ListFunctionBase : Function {
    protected virtual Node Evaluate(Env env);
    protected abstract virtual Node Eval(Env env, Node[] list, Node[] args);
}
public class dotless.Core.Parser.Functions.MixFunction : Function {
    protected virtual Node Evaluate(Env env);
    protected Color Mix(Color color1, Color color2, double weight);
}
public class dotless.Core.Parser.Functions.MultiplyFunction : ColorMixFunction {
    protected virtual double Operate(double a, double b);
}
public class dotless.Core.Parser.Functions.NegationFunction : ColorMixFunction {
    protected virtual double Operate(double a, double b);
}
public abstract class dotless.Core.Parser.Functions.NumberFunctionBase : Function {
    protected virtual Node Evaluate(Env env);
    protected abstract virtual Node Eval(Env env, Number number, Node[] args);
}
public class dotless.Core.Parser.Functions.OverlayFunction : ColorMixFunction {
    protected virtual double Operate(double a, double b);
}
public class dotless.Core.Parser.Functions.PercentageFunction : NumberFunctionBase {
    protected virtual Node Eval(Env env, Number number, Node[] args);
}
public class dotless.Core.Parser.Functions.PowFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.RedFunction : ColorFunctionBase {
    protected virtual Node Eval(Color color);
    protected virtual Node EditColor(Color color, Number number);
}
public class dotless.Core.Parser.Functions.RgbaFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.RgbFunction : RgbaFunction {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.RoundFunction : NumberFunctionBase {
    protected virtual Node Eval(Env env, Number number, Node[] args);
}
public class dotless.Core.Parser.Functions.SaturateFunction : HslColorFunctionBase {
    protected virtual Node EvalHsl(HslColor color);
    protected virtual Node EditHsl(HslColor color, Number number);
}
public class dotless.Core.Parser.Functions.SaturationFunction : SaturateFunction {
    protected virtual Node EditHsl(HslColor color, Number number);
}
public class dotless.Core.Parser.Functions.ScreenFunction : ColorMixFunction {
    protected virtual double Operate(double a, double b);
}
public class dotless.Core.Parser.Functions.ShadeFunction : MixFunction {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.SoftlightFunction : ColorMixFunction {
    protected virtual double Operate(double a, double b);
}
public class dotless.Core.Parser.Functions.SpinFunction : HueFunction {
}
public class dotless.Core.Parser.Functions.TintFunction : MixFunction {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Functions.UnitFunction : Function {
    protected virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Infrastructure.Closure : object {
    [CompilerGeneratedAttribute]
private Ruleset <Ruleset>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Ruleset> <Context>k__BackingField;
    public Ruleset Ruleset { get; public set; }
    public List`1<Ruleset> Context { get; public set; }
    [CompilerGeneratedAttribute]
public Ruleset get_Ruleset();
    [CompilerGeneratedAttribute]
public void set_Ruleset(Ruleset value);
    [CompilerGeneratedAttribute]
public List`1<Ruleset> get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(List`1<Ruleset> value);
}
public class dotless.Core.Parser.Infrastructure.Context : object {
    private static Char[] LeaveUnmerged;
    [CompilerGeneratedAttribute]
private List`1<List`1<Selector>> <Paths>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Element, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<Element, Element> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<List`1<Selector>, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, bool> CS$<>9__CachedAnonymousMethodDelegate14;
    private List`1<List`1<Selector>> Paths { get; private set; }
    public int Count { get; }
    private static Context();
    [CompilerGeneratedAttribute]
private List`1<List`1<Selector>> get_Paths();
    [CompilerGeneratedAttribute]
private void set_Paths(List`1<List`1<Selector>> value);
    public Context Clone();
    public void AppendSelectors(Context context, IEnumerable`1<Selector> selectors);
    private void AppendSelector(Context context, Selector selector);
    private void MergeElementsOnToSelectors(NodeList`1<Element> elements, List`1<List`1<Selector>> selectors);
    private Selector MergeJoinedElements(Selector selector);
    public void AppendCSS(Env env);
    public string ToCss(Env env);
    public int get_Count();
    public sealed virtual IEnumerator`1<IEnumerable`1<Selector>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private static bool <AppendSelector>b__3(Element e);
    [CompilerGeneratedAttribute]
private List`1<Selector> <AppendSelector>b__5(List`1<Selector> sel);
    [CompilerGeneratedAttribute]
private static Element <MergeJoinedElements>b__b(Element e);
    [CompilerGeneratedAttribute]
private static bool <AppendCSS>b__d(List`1<Selector> p);
    [CompilerGeneratedAttribute]
private static bool <AppendCSS>b__e(Selector s);
}
public class dotless.Core.Parser.Infrastructure.DefaultNodeProvider : object {
    public sealed virtual Element Element(Combinator combinator, Node value, NodeLocation location);
    public sealed virtual Combinator Combinator(string value, NodeLocation location);
    public sealed virtual Selector Selector(NodeList`1<Element> elements, NodeLocation location);
    public sealed virtual Rule Rule(string name, Node value, NodeLocation location);
    public sealed virtual Rule Rule(string name, Node value, bool variadic, NodeLocation location);
    public sealed virtual Ruleset Ruleset(NodeList`1<Selector> selectors, NodeList rules, NodeLocation location);
    public sealed virtual CssFunction CssFunction(string name, Node value, NodeLocation location);
    public sealed virtual Alpha Alpha(Node value, NodeLocation location);
    public sealed virtual Call Call(string name, NodeList`1<Node> arguments, NodeLocation location);
    public sealed virtual Color Color(string rgb, NodeLocation location);
    public sealed virtual Keyword Keyword(string value, NodeLocation location);
    public sealed virtual Number Number(string value, string unit, NodeLocation location);
    public sealed virtual Shorthand Shorthand(Node first, Node second, NodeLocation location);
    public sealed virtual Variable Variable(string name, NodeLocation location);
    public sealed virtual Url Url(Node value, IImporter importer, NodeLocation location);
    public sealed virtual Script Script(string script, NodeLocation location);
    public sealed virtual GuardedRuleset GuardedRuleset(NodeList`1<Selector> selectors, NodeList rules, Condition condition, NodeLocation location);
    public sealed virtual MixinCall MixinCall(NodeList`1<Element> elements, List`1<NamedArgument> arguments, bool important, NodeLocation location);
    public sealed virtual MixinDefinition MixinDefinition(string name, NodeList`1<Rule> parameters, NodeList rules, Condition condition, bool variadic, NodeLocation location);
    public sealed virtual Import Import(Url path, Value features, ImportOptions option, NodeLocation location);
    public sealed virtual Import Import(Quoted path, Value features, ImportOptions option, NodeLocation location);
    public sealed virtual Directive Directive(string name, string identifier, NodeList rules, NodeLocation location);
    public sealed virtual Media Media(NodeList rules, Value features, NodeLocation location);
    public sealed virtual KeyFrame KeyFrame(NodeList identifier, NodeList rules, NodeLocation location);
    public sealed virtual Directive Directive(string name, Node value, NodeLocation location);
    public sealed virtual Expression Expression(NodeList expression, NodeLocation location);
    public sealed virtual Value Value(IEnumerable`1<Node> values, string important, NodeLocation location);
    public sealed virtual Operation Operation(string operation, Node left, Node right, NodeLocation location);
    public sealed virtual Assignment Assignment(string key, Node value, NodeLocation location);
    public sealed virtual Comment Comment(string value, NodeLocation location);
    public sealed virtual TextNode TextNode(string contents, NodeLocation location);
    public sealed virtual Quoted Quoted(string value, string contents, bool escaped, NodeLocation location);
    public sealed virtual Extend Extend(List`1<Selector> exact, List`1<Selector> partial, NodeLocation location);
    public sealed virtual Node Attribute(Node key, Node op, Node val, NodeLocation location);
    public sealed virtual Paren Paren(Node value, NodeLocation location);
    public sealed virtual Condition Condition(Node left, string operation, Node right, bool negate, NodeLocation location);
}
public class dotless.Core.Parser.Infrastructure.Env : object {
    private Dictionary`2<string, Type> _functionTypes;
    private List`1<IPlugin> _plugins;
    private List`1<Extender> _extensions;
    private static Dictionary`2<string, Type> CoreFunctions;
    [CompilerGeneratedAttribute]
private Stack`1<Ruleset> <Frames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Compress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private Output <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<Media> <MediaPath>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Media> <MediaBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableVariableRedefines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableColorCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepFirstSpecialComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFirstSpecialCommentOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private Parser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private Env <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EvaluatingVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private Env <ClosureEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<Media> <ExtendMediaScope>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, Type>, string> CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, Type>, Type> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<Extender, bool> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<ExactExtender, bool> CS$<>9__CachedAnonymousMethodDelegate24;
    [CompilerGeneratedAttribute]
private static Func`2<PartialExtender[], bool> CS$<>9__CachedAnonymousMethodDelegate2a;
    [CompilerGeneratedAttribute]
private static Func`2<PartialExtender[], bool> CS$<>9__CachedAnonymousMethodDelegate31;
    [CompilerGeneratedAttribute]
private static Func`2<Ruleset, string> CS$<>9__CachedAnonymousMethodDelegate35;
    public Stack`1<Ruleset> Frames { get; protected set; }
    public bool Compress { get; public set; }
    public bool Debug { get; public set; }
    public Node Rule { get; public set; }
    public ILogger Logger { get; public set; }
    public Output Output { get; private set; }
    public Stack`1<Media> MediaPath { get; private set; }
    public List`1<Media> MediaBlocks { get; private set; }
    public bool DisableVariableRedefines { get; public set; }
    public bool DisableColorCompression { get; public set; }
    public bool KeepFirstSpecialComment { get; public set; }
    public bool IsFirstSpecialCommentOutput { get; public set; }
    public Parser Parser { get; public set; }
    private Env Parent { get; private set; }
    private string EvaluatingVariable { get; private set; }
    private Env ClosureEnvironment { get; private set; }
    public IEnumerable`1<IVisitorPlugin> VisitorPlugins { get; }
    public Stack`1<Media> ExtendMediaScope { get; public set; }
    public Env(Parser parser);
    protected Env(Parser parser, Stack`1<Ruleset> frames, Dictionary`2<string, Type> functions);
    protected Env(Stack`1<Ruleset> frames, Dictionary`2<string, Type> functions);
    private static Env();
    [CompilerGeneratedAttribute]
public Stack`1<Ruleset> get_Frames();
    [CompilerGeneratedAttribute]
protected void set_Frames(Stack`1<Ruleset> value);
    [CompilerGeneratedAttribute]
public bool get_Compress();
    [CompilerGeneratedAttribute]
public void set_Compress(bool value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public Node get_Rule();
    [CompilerGeneratedAttribute]
public void set_Rule(Node value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public Output get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(Output value);
    [CompilerGeneratedAttribute]
public Stack`1<Media> get_MediaPath();
    [CompilerGeneratedAttribute]
private void set_MediaPath(Stack`1<Media> value);
    [CompilerGeneratedAttribute]
public List`1<Media> get_MediaBlocks();
    [CompilerGeneratedAttribute]
private void set_MediaBlocks(List`1<Media> value);
    [CompilerGeneratedAttribute]
public bool get_DisableVariableRedefines();
    [CompilerGeneratedAttribute]
public void set_DisableVariableRedefines(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableColorCompression();
    [CompilerGeneratedAttribute]
public void set_DisableColorCompression(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepFirstSpecialComment();
    [CompilerGeneratedAttribute]
public void set_KeepFirstSpecialComment(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFirstSpecialCommentOutput();
    [CompilerGeneratedAttribute]
public void set_IsFirstSpecialCommentOutput(bool value);
    [CompilerGeneratedAttribute]
public Parser get_Parser();
    [CompilerGeneratedAttribute]
public void set_Parser(Parser value);
    [ObsoleteAttribute("Argument is ignored as of version 1.4.3.0. Use the parameterless overload of CreateChildEnv instead.", "False")]
public virtual Env CreateChildEnv(Stack`1<Ruleset> ruleset);
    public virtual Env CreateChildEnv();
    [CompilerGeneratedAttribute]
private Env get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(Env value);
    public virtual Env CreateVariableEvaluationEnv(string variableName);
    [CompilerGeneratedAttribute]
private string get_EvaluatingVariable();
    [CompilerGeneratedAttribute]
private void set_EvaluatingVariable(string value);
    public bool IsEvaluatingVariable(string variableName);
    public virtual Env CreateChildEnvWithClosure(Closure closure);
    [CompilerGeneratedAttribute]
private Env get_ClosureEnvironment();
    [CompilerGeneratedAttribute]
private void set_ClosureEnvironment(Env value);
    public void AddPlugin(IPlugin plugin);
    public IEnumerable`1<IVisitorPlugin> get_VisitorPlugins();
    [CompilerGeneratedAttribute]
public Stack`1<Media> get_ExtendMediaScope();
    [CompilerGeneratedAttribute]
public void set_ExtendMediaScope(Stack`1<Media> value);
    public bool IsCommentSilent(bool isValidCss, bool isCssHack, bool isSpecialComment);
    public Rule FindVariable(string name);
    public Rule FindVariable(string name, Node rule);
    [ObsoleteAttribute("This method will be removed in a future release.", "False")]
public IEnumerable`1<Closure> FindRulesets(Selector selector);
    public IEnumerable`1<Closure> FindRulesets(Selector selector);
    public void AddFunction(string name, Type type);
    public void AddFunctionsFromAssembly(Assembly assembly);
    private void AddFunctionsToRegistry(IEnumerable`1<KeyValuePair`2<string, Type>> functions);
    private static Dictionary`2<string, Type> GetFunctionsFromAssembly(Assembly assembly);
    private static Dictionary`2<string, Type> GetCoreFunctions();
    private void AddCoreFunctions();
    public virtual Function GetFunction(string name);
    private static IEnumerable`1<KeyValuePair`2<string, Type>> GetFunctionNames(Type t);
    public void AddExtension(Selector selector, Extend extends, Env env);
    public void RegisterExtensionsFrom(Env child);
    public IEnumerable`1<Extender> FindUnmatchedExtensions();
    public ExactExtender FindExactExtension(string selection);
    public PartialExtender[] FindPartialExtensions(Context selection);
    [ObsoleteAttribute("This method doesn't return the correct results. Use FindPartialExtensions(Context) instead.", "False")]
public PartialExtender[] FindPartialExtensions(string selection);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static bool <FindRulesets>b__1(Closure c);
    [CompilerGeneratedAttribute]
private bool <FindRulesets>b__3(Closure matchedClosure);
    [CompilerGeneratedAttribute]
private static bool <GetFunctionsFromAssembly>b__a(Type t);
    [CompilerGeneratedAttribute]
private static string <GetFunctionsFromAssembly>b__b(KeyValuePair`2<string, Type> kvp);
    [CompilerGeneratedAttribute]
private static Type <GetFunctionsFromAssembly>b__c(KeyValuePair`2<string, Type> kvp);
    [CompilerGeneratedAttribute]
private static bool <FindUnmatchedExtensions>b__1e(Extender e);
    [CompilerGeneratedAttribute]
private static bool <FindExactExtension>b__21(ExactExtender result);
    [CompilerGeneratedAttribute]
private static bool <FindPartialExtensions>b__28(PartialExtender[] result);
    [CompilerGeneratedAttribute]
private static bool <FindPartialExtensions>b__2e(PartialExtender[] result);
    [CompilerGeneratedAttribute]
private static string <ToString>b__34(Ruleset f);
}
public class dotless.Core.Parser.Infrastructure.ExactExtender : Extender {
    [ObsoleteAttribute("Use the overload that accepts the Extend node")]
public ExactExtender(Selector baseSelector);
    public ExactExtender(Selector baseSelector, Extend extend);
}
public class dotless.Core.Parser.Infrastructure.Extender : object {
    [CompilerGeneratedAttribute]
private Selector <BaseSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Selector> <ExtendedBy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMatched>k__BackingField;
    [CompilerGeneratedAttribute]
private Extend <Extend>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Ruleset, IEnumerable`1<Selector>> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    public Selector BaseSelector { get; private set; }
    public List`1<Selector> ExtendedBy { get; private set; }
    public bool IsReference { get; public set; }
    public bool IsMatched { get; public set; }
    public Extend Extend { get; private set; }
    [ObsoleteAttribute("Use the overload that accepts the Extend node")]
public Extender(Selector baseSelector);
    public Extender(Selector baseSelector, Extend extend);
    [CompilerGeneratedAttribute]
public Selector get_BaseSelector();
    [CompilerGeneratedAttribute]
private void set_BaseSelector(Selector value);
    [CompilerGeneratedAttribute]
public List`1<Selector> get_ExtendedBy();
    [CompilerGeneratedAttribute]
private void set_ExtendedBy(List`1<Selector> value);
    [CompilerGeneratedAttribute]
public bool get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMatched();
    [CompilerGeneratedAttribute]
public void set_IsMatched(bool value);
    [CompilerGeneratedAttribute]
public Extend get_Extend();
    [CompilerGeneratedAttribute]
private void set_Extend(Extend value);
    public static string FullPathSelector();
    public void AddExtension(Selector selector, Env env);
    private Selector GenerateExtenderSelector(Env env, List`1<IEnumerable`1<Selector>> selectorPath);
    private Context GenerateExtenderSelector(List`1<IEnumerable`1<Selector>> selectorStack);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<Selector> <AddExtension>b__1(Ruleset f);
    [CompilerGeneratedAttribute]
private static bool <AddExtension>b__2(Selector partialSelector);
}
[ExtensionAttribute]
internal static class dotless.Core.Parser.Infrastructure.ExtenderMatcherExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<Selector>, IEnumerable`1<Element>> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, IEnumerable`1<Element>> CS$<>9__CachedAnonymousMethodDelegate6;
    [ExtensionAttribute]
internal static IEnumerable`1<PartialExtender> WhereExtenderMatches(IEnumerable`1<PartialExtender> extenders, Context selection);
    [ExtensionAttribute]
private static bool ElementListMatches(PartialExtender extender, IList`1<Element> list);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<Element> <WhereExtenderMatches>b__0(IEnumerable`1<Selector> selectors);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<Element> <WhereExtenderMatches>b__1(Selector s);
}
public interface dotless.Core.Parser.Infrastructure.INodeProvider {
    public abstract virtual Element Element(Combinator combinator, Node Value, NodeLocation location);
    public abstract virtual Combinator Combinator(string value, NodeLocation location);
    public abstract virtual Selector Selector(NodeList`1<Element> elements, NodeLocation location);
    public abstract virtual Rule Rule(string name, Node value, NodeLocation location);
    public abstract virtual Rule Rule(string name, Node value, bool variadic, NodeLocation location);
    public abstract virtual Ruleset Ruleset(NodeList`1<Selector> selectors, NodeList rules, NodeLocation location);
    public abstract virtual CssFunction CssFunction(string name, Node value, NodeLocation location);
    public abstract virtual Alpha Alpha(Node value, NodeLocation location);
    public abstract virtual Call Call(string name, NodeList`1<Node> arguments, NodeLocation location);
    public abstract virtual Color Color(string rgb, NodeLocation location);
    public abstract virtual Keyword Keyword(string value, NodeLocation location);
    public abstract virtual Number Number(string value, string unit, NodeLocation location);
    public abstract virtual Shorthand Shorthand(Node first, Node second, NodeLocation location);
    public abstract virtual Variable Variable(string name, NodeLocation location);
    public abstract virtual Url Url(Node value, IImporter importer, NodeLocation location);
    public abstract virtual Script Script(string script, NodeLocation location);
    public abstract virtual Paren Paren(Node node, NodeLocation location);
    public abstract virtual GuardedRuleset GuardedRuleset(NodeList`1<Selector> selectors, NodeList rules, Condition condition, NodeLocation location);
    public abstract virtual MixinCall MixinCall(NodeList`1<Element> elements, List`1<NamedArgument> arguments, bool important, NodeLocation location);
    public abstract virtual MixinDefinition MixinDefinition(string name, NodeList`1<Rule> parameters, NodeList rules, Condition condition, bool variadic, NodeLocation location);
    public abstract virtual Condition Condition(Node left, string operation, Node right, bool negate, NodeLocation location);
    public abstract virtual Import Import(Url path, Value features, ImportOptions option, NodeLocation location);
    public abstract virtual Import Import(Quoted path, Value features, ImportOptions option, NodeLocation location);
    public abstract virtual Directive Directive(string name, string identifier, NodeList rules, NodeLocation location);
    public abstract virtual Directive Directive(string name, Node value, NodeLocation location);
    public abstract virtual Media Media(NodeList rules, Value features, NodeLocation location);
    public abstract virtual KeyFrame KeyFrame(NodeList identifier, NodeList rules, NodeLocation location);
    public abstract virtual Expression Expression(NodeList expression, NodeLocation location);
    public abstract virtual Value Value(IEnumerable`1<Node> values, string important, NodeLocation location);
    public abstract virtual Operation Operation(string operation, Node left, Node right, NodeLocation location);
    public abstract virtual Assignment Assignment(string key, Node value, NodeLocation location);
    public abstract virtual Comment Comment(string value, NodeLocation location);
    public abstract virtual TextNode TextNode(string contents, NodeLocation location);
    public abstract virtual Quoted Quoted(string value, string contents, bool escaped, NodeLocation location);
    public abstract virtual Extend Extend(List`1<Selector> exact, List`1<Selector> partial, NodeLocation location);
    public abstract virtual Node Attribute(Node key, Node op, Node val, NodeLocation location);
}
public interface dotless.Core.Parser.Infrastructure.IOperable {
    public abstract virtual Node Operate(Operation op, Node other);
    public abstract virtual Color ToColor();
}
internal class dotless.Core.Parser.Infrastructure.MimeTypeLookup : object {
    private static Dictionary`2<string, string> _mappings;
    private static MimeTypeLookup();
    public string ByFilename(string filename);
}
public enum dotless.Core.Parser.Infrastructure.MixinMatch : Enum {
    public int value__;
    public static MixinMatch ArgumentMismatch;
    public static MixinMatch Pass;
    public static MixinMatch GuardFail;
    public static MixinMatch Default;
}
public class dotless.Core.Parser.Infrastructure.NamedArgument : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    public string Name { get; public set; }
    public Expression Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Expression get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Expression value);
}
public class dotless.Core.Parser.Infrastructure.Nodes.BooleanNode : Node {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; public set; }
    public BooleanNode(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(bool value);
    protected virtual Node CloneCore();
    public virtual string ToString();
}
public class dotless.Core.Parser.Infrastructure.Nodes.CharMatchResult : TextNode {
    [CompilerGeneratedAttribute]
private char <Char>k__BackingField;
    public char Char { get; public set; }
    public CharMatchResult(char c);
    [CompilerGeneratedAttribute]
public char get_Char();
    [CompilerGeneratedAttribute]
public void set_Char(char value);
}
public abstract class dotless.Core.Parser.Infrastructure.Nodes.Node : object {
    private bool isReference;
    [CompilerGeneratedAttribute]
private NodeLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeList <PreComments>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeList <PostComments>k__BackingField;
    public bool IsReference { get; public set; }
    public NodeLocation Location { get; public set; }
    public NodeList PreComments { get; public set; }
    public NodeList PostComments { get; public set; }
    public bool get_IsReference();
    public void set_IsReference(bool value);
    [CompilerGeneratedAttribute]
public NodeLocation get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(NodeLocation value);
    [CompilerGeneratedAttribute]
public NodeList get_PreComments();
    [CompilerGeneratedAttribute]
public void set_PreComments(NodeList value);
    [CompilerGeneratedAttribute]
public NodeList get_PostComments();
    [CompilerGeneratedAttribute]
public void set_PostComments(NodeList value);
    public static bool op_Implicit(Node node);
    public static bool op_True(Node n);
    public static bool op_False(Node n);
    public static bool op_LogicalNot(Node n);
    public static Node op_BitwiseAnd(Node n1, Node n2);
    public static Node op_BitwiseOr(Node n1, Node n2);
    public T ReducedFrom(Node[] nodes);
    public virtual Node Clone();
    protected abstract virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual string ToCSS(Env env);
    public virtual Node Evaluate(Env env);
    public virtual bool IgnoreOutput();
    public virtual void Accept(IVisitor visitor);
    public T VisitAndReplace(T nodeToVisit, IVisitor visitor);
    public T VisitAndReplace(T nodeToVisit, IVisitor visitor, bool allowNull);
}
public class dotless.Core.Parser.Infrastructure.Nodes.NodeList : NodeList`1<Node> {
    public NodeList(Node[] nodes);
    public NodeList(IEnumerable`1<Node> nodes);
    public NodeList(NodeList nodes);
}
[DefaultMemberAttribute("Item")]
public class dotless.Core.Parser.Infrastructure.Nodes.NodeList`1 : Node {
    protected List`1<TNode> Inner;
    [CompilerGeneratedAttribute]
private static Func`2<TNode, Node> CS$<>9__CachedAnonymousMethodDelegate1;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TNode Item { get; public set; }
    public NodeList`1(TNode[] nodes);
    public NodeList`1(IEnumerable`1<TNode> nodes);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual void Accept(IVisitor visitor);
    public void AddRange(IEnumerable`1<TNode> nodes);
    public sealed virtual IEnumerator`1<TNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void InsertRange(int index, IEnumerable`1<TNode> collection);
    public sealed virtual void Add(TNode item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TNode item);
    public sealed virtual void CopyTo(TNode[] array, int arrayIndex);
    public sealed virtual bool Remove(TNode item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(TNode item);
    public sealed virtual void Insert(int index, TNode item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual TNode get_Item(int index);
    public sealed virtual void set_Item(int index, TNode value);
    [CompilerGeneratedAttribute]
private static Node <CloneCore>b__0(TNode i);
}
[DefaultMemberAttribute("Item")]
public class dotless.Core.Parser.Infrastructure.Nodes.RegexMatchResult : TextNode {
    [CompilerGeneratedAttribute]
private Match <Match>k__BackingField;
    public Match Match { get; public set; }
    public string Item { get; }
    public RegexMatchResult(Match match);
    [CompilerGeneratedAttribute]
public Match get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(Match value);
    public string get_Item(int index);
}
public class dotless.Core.Parser.Infrastructure.Nodes.TextNode : Node {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; public set; }
    public TextNode(string contents);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public static TextNode op_BitwiseAnd(TextNode n1, TextNode n2);
    public static TextNode op_BitwiseOr(TextNode n1, TextNode n2);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual string ToString();
    public virtual int CompareTo(object obj);
}
public class dotless.Core.Parser.Infrastructure.Output : object {
    [CompilerGeneratedAttribute]
private Env <Env>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private Stack`1<StringBuilder> <BuilderStack>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`2<string, StringBuilder> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Action`2<StringBuilder, StringBuilder> CS$<>9__CachedAnonymousMethodDelegatea;
    private Env Env { get; private set; }
    private StringBuilder Builder { get; private set; }
    private Stack`1<StringBuilder> BuilderStack { get; private set; }
    public Output(Env env);
    [CompilerGeneratedAttribute]
private Env get_Env();
    [CompilerGeneratedAttribute]
private void set_Env(Env value);
    [CompilerGeneratedAttribute]
private StringBuilder get_Builder();
    [CompilerGeneratedAttribute]
private void set_Builder(StringBuilder value);
    [CompilerGeneratedAttribute]
private Stack`1<StringBuilder> get_BuilderStack();
    [CompilerGeneratedAttribute]
private void set_BuilderStack(Stack`1<StringBuilder> value);
    public Output Push();
    public StringBuilder Pop();
    public void Reset(string s);
    public Output PopAndAppend();
    public Output Append(Node node);
    public Output Append(string s);
    public Output Append(Nullable`1<char> s);
    public Output Append(StringBuilder sb);
    public Output AppendMany(IEnumerable`1<TNode> nodes);
    public Output AppendMany(IEnumerable`1<TNode> nodes, string join);
    public Output AppendMany(IEnumerable`1<string> list, string join);
    public Output AppendMany(IEnumerable`1<T> list, Func`2<T, string> toString, string join);
    public Output AppendMany(IEnumerable`1<T> list, Action`1<T> toString, string join);
    public Output AppendMany(IEnumerable`1<T> list, Action`2<T, StringBuilder> toString, string join);
    public Output AppendMany(IEnumerable`1<StringBuilder> buildersToAppend);
    public Output AppendMany(IEnumerable`1<StringBuilder> buildersToAppend, string join);
    public Output AppendFormat(IFormatProvider formatProvider, string format, Object[] values);
    public Output Indent(int amount);
    public Output Trim();
    public Output TrimLeft(Nullable`1<char> c);
    public Output TrimRight(Nullable`1<char> c);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <AppendMany>b__0(TNode n);
    [CompilerGeneratedAttribute]
private static void <AppendMany>b__1(string item, StringBuilder sb);
    [CompilerGeneratedAttribute]
private static void <AppendMany>b__9(StringBuilder b, StringBuilder output);
}
public class dotless.Core.Parser.Infrastructure.PartialExtender : Extender {
    [ObsoleteAttribute("Use the overload that accepts the Extend node")]
public PartialExtender(Selector baseSelector);
    public PartialExtender(Selector baseSelector, Extend extend);
    public IEnumerable`1<Selector> Replacements(string selection);
}
public class dotless.Core.Parser.Location : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentChunk>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentChunkIndex>k__BackingField;
    public int Index { get; public set; }
    public int CurrentChunk { get; public set; }
    public int CurrentChunkIndex { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentChunk();
    [CompilerGeneratedAttribute]
public void set_CurrentChunk(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentChunkIndex();
    [CompilerGeneratedAttribute]
public void set_CurrentChunkIndex(int value);
}
public class dotless.Core.Parser.NodeLocation : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public int Index { get; public set; }
    public string Source { get; public set; }
    public string FileName { get; public set; }
    public NodeLocation(int index, string source, string filename);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
}
public class dotless.Core.Parser.Parser : object {
    private static int defaultOptimization;
    private static bool defaultDebug;
    private INodeProvider _nodeProvider;
    private IImporter _importer;
    [CompilerGeneratedAttribute]
private Tokenizer <Tokenizer>k__BackingField;
    [CompilerGeneratedAttribute]
private IStylizer <Stylizer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrictMath>k__BackingField;
    public Tokenizer Tokenizer { get; public set; }
    public IStylizer Stylizer { get; public set; }
    public string FileName { get; public set; }
    public bool Debug { get; public set; }
    public string CurrentDirectory { get; public set; }
    public INodeProvider NodeProvider { get; public set; }
    public IImporter Importer { get; public set; }
    public bool StrictMath { get; public set; }
    public Parser(bool debug);
    public Parser(int optimization);
    public Parser(int optimization, bool debug);
    public Parser(IStylizer stylizer, IImporter importer);
    public Parser(IStylizer stylizer, IImporter importer, bool debug);
    public Parser(int optimization, IStylizer stylizer, IImporter importer);
    public Parser(int optimization, IStylizer stylizer, IImporter importer, bool debug);
    [CompilerGeneratedAttribute]
public Tokenizer get_Tokenizer();
    [CompilerGeneratedAttribute]
public void set_Tokenizer(Tokenizer value);
    [CompilerGeneratedAttribute]
public IStylizer get_Stylizer();
    [CompilerGeneratedAttribute]
public void set_Stylizer(IStylizer value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    public string get_CurrentDirectory();
    public void set_CurrentDirectory(string value);
    public INodeProvider get_NodeProvider();
    public void set_NodeProvider(INodeProvider value);
    public IImporter get_Importer();
    public void set_Importer(IImporter value);
    [CompilerGeneratedAttribute]
public bool get_StrictMath();
    [CompilerGeneratedAttribute]
public void set_StrictMath(bool value);
    public Ruleset Parse(string input, string fileName);
    private ParserException GenerateParserError(ParsingException parsingException);
    [CompilerGeneratedAttribute]
private Parser <set_Importer>b__1();
}
public class dotless.Core.Parser.Parsers : object {
    private Stack`1<NodeList> CommentsStack;
    private static ImportOptions[][] illegalOptionCombinations;
    [CompilerGeneratedAttribute]
private INodeProvider <NodeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeList <CurrentComments>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate5;
    public INodeProvider NodeProvider { get; public set; }
    private NodeList CurrentComments { get; private set; }
    public Parsers(INodeProvider nodeProvider);
    private static Parsers();
    [CompilerGeneratedAttribute]
public INodeProvider get_NodeProvider();
    [CompilerGeneratedAttribute]
public void set_NodeProvider(INodeProvider value);
    public NodeList Primary(Parser parser);
    [CompilerGeneratedAttribute]
private NodeList get_CurrentComments();
    [CompilerGeneratedAttribute]
private void set_CurrentComments(NodeList value);
    private void GatherComments(Parser parser);
    private NodeList PullComments();
    private NodeList GatherAndPullComments(Parser parser);
    private void PushComments();
    private void PopComments();
    public Comment Comment(Parser parser);
    public Quoted Quoted(Parser parser);
    public Keyword Keyword(Parser parser);
    public Call Call(Parser parser);
    public NodeList`1<Node> Arguments(Parser parser);
    public Assignment Assignment(Parser parser);
    public Node Literal(Parser parser);
    public Url Url(Parser parser);
    public Variable Variable(Parser parser);
    public Variable InterpolatedVariable(Parser parser);
    public Variable VariableCurly(Parser parser);
    public GuardedRuleset GuardedRuleset(Parser parser);
    public Extend ExtendRule(Parser parser);
    public Color Color(Parser parser);
    public Number Dimension(Parser parser);
    public Script Script(Parser parser);
    public string VariableName(Parser parser);
    public Shorthand Shorthand(Parser parser);
    public MixinCall MixinCall(Parser parser);
    private Expression Expression(Parser parser, bool allowList);
    public MixinDefinition MixinDefinition(Parser parser);
    public Condition Conditions(Parser parser);
    public Condition Condition(Parser parser);
    public Node Entity(Parser parser);
    private Expression ExpressionOrExpressionList(Parser parser);
    public bool End(Parser parser);
    public Alpha Alpha(Parser parser);
    public Element Element(Parser parser);
    private static RegexMatchResult PseudoClassSelector(Parser parser);
    private static RegexMatchResult PseudoElementSelector(Parser parser);
    private Node NonPseudoClassSelector(Parser parser);
    public Combinator Combinator(Parser parser);
    public Selector Selector(Parser parser);
    public Node Tag(Parser parser);
    public Node Attribute(Parser parser);
    public NodeList Block(Parser parser);
    public Ruleset Ruleset(Parser parser);
    public Rule Rule(Parser parser);
    private bool MatchesProperty(string expectedPropertyName, string actualPropertyName);
    private CssFunctionList FilterExpressionList(Parser parser);
    private Node FilterExpression(Parser parser);
    public Import Import(Parser parser);
    private static ImportOptions ParseOptions(Parser parser);
    private static void CheckForConflictingOptions(Parser parser, ImportOptions options, string allKeywords, int index);
    private static bool IsOptionSet(ImportOptions options, ImportOptions test);
    public Node Directive(Parser parser);
    public Expression MediaFeature(Parser parser);
    public Value MediaFeatures(Parser parser);
    public Media Media(Parser parser);
    public Directive KeyFrameBlock(Parser parser, string name, string identifier, int index);
    public Value Font(Parser parser);
    public Value Value(Parser parser);
    public string Important(Parser parser);
    public string IESlash9Hack(Parser parser);
    public Expression Sub(Parser parser);
    public Node Multiplication(Parser parser);
    public Node UnicodeRange(Parser parser);
    public Node Operation(Parser parser);
    public Node Operand(Parser parser);
    public Expression Expression(Parser parser);
    public string Property(Parser parser);
    public void Expect(Parser parser, char expectedString);
    public void Expect(Parser parser, char expectedString, string message);
    public T Expect(T node, string message, Parser parser);
    public ParserLocation Remember(Parser parser);
    public void Recall(Parser parser, ParserLocation location);
    [CompilerGeneratedAttribute]
private static string <ParseOptions>b__2(string kw);
    [CompilerGeneratedAttribute]
private static bool <Value>b__4(string x);
}
[DebuggerDisplayAttribute("{Remaining}")]
public class dotless.Core.Parser.Tokenizer : object {
    private string _input;
    private List`1<Chunk> _chunks;
    private int _i;
    private int _j;
    private int _current;
    private int _lastCommentStart;
    private int _lastCommentEnd;
    private int _inputLength;
    private string _commentRegEx;
    private string _quotedRegEx;
    private string _fileName;
    private IDictionary`2<string, Regex> regexCache;
    [CompilerGeneratedAttribute]
private int <Optimization>k__BackingField;
    public int Optimization { get; public set; }
    public char PreviousChar { get; }
    public char CurrentChar { get; }
    public char NextChar { get; }
    public Location Location { get; public set; }
    private string Remaining { get; }
    public Tokenizer(int optimization);
    [CompilerGeneratedAttribute]
public int get_Optimization();
    [CompilerGeneratedAttribute]
public void set_Optimization(int value);
    public void SetupInput(string input, string fileName);
    public string GetComment();
    public string GetQuotedString();
    public string MatchString(char tok);
    public string MatchString(string tok);
    public CharMatchResult Match(char tok);
    public RegexMatchResult Match(string tok);
    public RegexMatchResult Match(string tok, bool caseInsensitive);
    public RegexMatchResult MatchAny(string tok);
    public void Advance(int length);
    public bool Peek(char tok);
    public bool Peek(string tok);
    public bool PeekAfterComments(char tok);
    private Regex GetRegex(string pattern, RegexOptions options);
    public char GetPreviousCharIgnoringComments();
    public char get_PreviousChar();
    public char get_CurrentChar();
    public char get_NextChar();
    public bool HasCompletedParsing();
    public Location get_Location();
    public void set_Location(Location value);
    public NodeLocation GetNodeLocation(int index);
    public NodeLocation GetNodeLocation();
    private string get_Remaining();
}
public class dotless.Core.Parser.Tree.Alpha : Call {
    [CompilerGeneratedAttribute]
private Node <Value>k__BackingField;
    public Node Value { get; public set; }
    public Alpha(Node value);
    [CompilerGeneratedAttribute]
public Node get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Node value);
    public virtual Node Evaluate(Env env);
    public virtual void AppendCSS(Env env);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Assignment : Node {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Value>k__BackingField;
    public string Key { get; public set; }
    public Node Value { get; public set; }
    public Assignment(string key, Node value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public Node get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Node value);
    public virtual Node Evaluate(Env env);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Attribute : Node {
    [CompilerGeneratedAttribute]
private Node <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Op>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Value>k__BackingField;
    public Node Name { get; public set; }
    public Node Op { get; public set; }
    public Node Value { get; public set; }
    public Attribute(Node name, Node op, Node value);
    [CompilerGeneratedAttribute]
public Node get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(Node value);
    [CompilerGeneratedAttribute]
public Node get_Op();
    [CompilerGeneratedAttribute]
public void set_Op(Node value);
    [CompilerGeneratedAttribute]
public Node get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Node value);
    protected virtual Node CloneCore();
    public virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Tree.Call : Node {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeList`1<Node> <Arguments>k__BackingField;
    public string Name { get; public set; }
    public NodeList`1<Node> Arguments { get; public set; }
    public Call(string name, NodeList`1<Node> arguments);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public NodeList`1<Node> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(NodeList`1<Node> value);
    protected virtual Node CloneCore();
    public virtual Node Evaluate(Env env);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Color : Node {
    private static Dictionary`2<int, string> Html4ColorsReverse;
    private static Dictionary`2<string, int> Html4Colors;
    private bool isArgb;
    public Double[] RGB;
    public double Alpha;
    [CompilerGeneratedAttribute]
private static Func`2<Number, double> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<string, double> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<string, double> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<char, double> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<double, int> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<int, int> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<int, string> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<double, int> CS$<>9__CachedAnonymousMethodDelegate18;
    [CompilerGeneratedAttribute]
private static Func`2<int, int> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<int, string> CS$<>9__CachedAnonymousMethodDelegate1a;
    public double R { get; public set; }
    public double G { get; public set; }
    public double B { get; public set; }
    public double Luma { get; }
    private static Color();
    public Color(Double[] rgb);
    public Color(Double[] rgb, double alpha);
    public Color(IEnumerable`1<Number> rgb, Number alpha);
    public Color(string hex);
    public Color(double red, double green, double blue, double alpha);
    public Color(double red, double green, double blue);
    public Color(int color);
    public double get_R();
    public void set_R(double value);
    public double get_G();
    public void set_G(double value);
    public double get_B();
    public void set_B(double value);
    private double TransformLinearToSrbg(double linearChannel);
    public double get_Luma();
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public sealed virtual Node Operate(Operation op, Node other);
    public sealed virtual Color ToColor();
    public string GetKeyword(Int32[] rgb);
    public static Color GetColorFromKeyword(string keyword);
    public string ToArgb();
    public sealed virtual int CompareTo(object obj);
    public static Color op_Explicit(Color color);
    [CompilerGeneratedAttribute]
private static double <.ctor>b__1(Number d);
    [CompilerGeneratedAttribute]
private static double <.ctor>b__4(string s);
    [CompilerGeneratedAttribute]
private static double <.ctor>b__6(string s);
    [CompilerGeneratedAttribute]
private static double <.ctor>b__7(char c);
    [CompilerGeneratedAttribute]
private static int <AppendCSS>b__f(double d);
    [CompilerGeneratedAttribute]
private static int <AppendCSS>b__10(int i);
    [CompilerGeneratedAttribute]
private static string <AppendCSS>b__11(int i);
    [CompilerGeneratedAttribute]
private static int <ToArgb>b__15(double d);
    [CompilerGeneratedAttribute]
private static int <ToArgb>b__16(int i);
    [CompilerGeneratedAttribute]
private static string <ToArgb>b__17(int i);
}
public class dotless.Core.Parser.Tree.Combinator : Node {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; public set; }
    public Combinator(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    private string GetValue(Env env);
}
public class dotless.Core.Parser.Tree.Comment : Node {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValidCss>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSpecialCss>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreSelectorComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCSSHack>k__BackingField;
    public string Value { get; public set; }
    public bool IsValidCss { get; public set; }
    public bool IsSpecialCss { get; public set; }
    public bool IsPreSelectorComment { get; public set; }
    private bool IsCSSHack { get; private set; }
    public Comment(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_IsValidCss();
    [CompilerGeneratedAttribute]
public void set_IsValidCss(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSpecialCss();
    [CompilerGeneratedAttribute]
public void set_IsSpecialCss(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPreSelectorComment();
    [CompilerGeneratedAttribute]
public void set_IsPreSelectorComment(bool value);
    [CompilerGeneratedAttribute]
private bool get_IsCSSHack();
    [CompilerGeneratedAttribute]
private void set_IsCSSHack(bool value);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
}
public class dotless.Core.Parser.Tree.Condition : Node {
    [CompilerGeneratedAttribute]
private Node <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Negate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    public Node Left { get; public set; }
    public Node Right { get; public set; }
    public string Operation { get; public set; }
    public bool Negate { get; public set; }
    public bool IsDefault { get; private set; }
    public Condition(Node left, string operation, Node right, bool negate);
    [CompilerGeneratedAttribute]
public Node get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(Node value);
    [CompilerGeneratedAttribute]
public Node get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(Node value);
    [CompilerGeneratedAttribute]
public string get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(string value);
    [CompilerGeneratedAttribute]
public bool get_Negate();
    [CompilerGeneratedAttribute]
public void set_Negate(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
private void set_IsDefault(bool value);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual Node Evaluate(Env env);
    private bool Evaluate(Node lValue, string operation, Node rValue);
    public bool Passes(Env env);
    private static bool ToBool(Node node);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.CssFunction : Node {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Value>k__BackingField;
    public string Name { get; public set; }
    public Node Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Node get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Node value);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
}
public class dotless.Core.Parser.Tree.CssFunctionList : NodeList {
    public virtual void AppendCSS(Env env);
}
public class dotless.Core.Parser.Tree.Directive : Ruleset {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Value>k__BackingField;
    public string Name { get; public set; }
    public string Identifier { get; public set; }
    public Node Value { get; public set; }
    public Directive(string name, string identifier, NodeList rules);
    public Directive(string name, Node value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public void set_Identifier(string value);
    [CompilerGeneratedAttribute]
public Node get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Node value);
    protected virtual Node CloneCore();
    public virtual void Accept(IVisitor visitor);
    public virtual Node Evaluate(Env env);
    public virtual void AppendCSS(Env env, Context context);
}
public class dotless.Core.Parser.Tree.Element : Node {
    [CompilerGeneratedAttribute]
private Combinator <Combinator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <NodeValue>k__BackingField;
    public Combinator Combinator { get; public set; }
    public string Value { get; public set; }
    public Node NodeValue { get; public set; }
    public Element(Combinator combinator, string textValue);
    public Element(Combinator combinator, Node value);
    private Element(Combinator combinator);
    [CompilerGeneratedAttribute]
public Combinator get_Combinator();
    [CompilerGeneratedAttribute]
public void set_Combinator(Combinator value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public Node get_NodeValue();
    [CompilerGeneratedAttribute]
public void set_NodeValue(Node value);
    public virtual Node Evaluate(Env env);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual void Accept(IVisitor visitor);
    internal Element Clone();
}
public class dotless.Core.Parser.Tree.Expression : Node {
    [CompilerGeneratedAttribute]
private NodeList <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExpressionList>k__BackingField;
    public NodeList Value { get; public set; }
    private bool IsExpressionList { get; private set; }
    public Expression(IEnumerable`1<Node> value);
    public Expression(IEnumerable`1<Node> value, bool isExpressionList);
    [CompilerGeneratedAttribute]
public NodeList get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(NodeList value);
    [CompilerGeneratedAttribute]
private bool get_IsExpressionList();
    [CompilerGeneratedAttribute]
private void set_IsExpressionList(bool value);
    public virtual Node Evaluate(Env env);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Extend : Node {
    [CompilerGeneratedAttribute]
private List`1<Selector> <Exact>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Selector> <Partial>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, Selector> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, Selector> CS$<>9__CachedAnonymousMethodDelegate4;
    public List`1<Selector> Exact { get; public set; }
    public List`1<Selector> Partial { get; public set; }
    public Extend(List`1<Selector> exact, List`1<Selector> partial);
    [CompilerGeneratedAttribute]
public List`1<Selector> get_Exact();
    [CompilerGeneratedAttribute]
public void set_Exact(List`1<Selector> value);
    [CompilerGeneratedAttribute]
public List`1<Selector> get_Partial();
    [CompilerGeneratedAttribute]
public void set_Partial(List`1<Selector> value);
    public virtual Node Evaluate(Env env);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual bool IgnoreOutput();
    [CompilerGeneratedAttribute]
private static Selector <CloneCore>b__1(Selector e);
    [CompilerGeneratedAttribute]
private static Selector <CloneCore>b__2(Selector e);
}
public class dotless.Core.Parser.Tree.GuardedRuleset : Ruleset {
    [CompilerGeneratedAttribute]
private Condition <Condition>k__BackingField;
    public Condition Condition { get; public set; }
    public GuardedRuleset(NodeList`1<Selector> selectors, NodeList rules, Condition condition);
    [CompilerGeneratedAttribute]
public Condition get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(Condition value);
    public virtual Node Evaluate(Env env);
    public virtual void Accept(IVisitor visitor);
    public virtual void AppendCSS(Env env);
}
public class dotless.Core.Parser.Tree.Import : Directive {
    private ReferenceVisitor referenceVisitor;
    private Nullable`1<ImportAction> _importAction;
    [CompilerGeneratedAttribute]
private Node <OriginalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Ruleset <InnerRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InnerContent>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private ImportOptions <ImportOptions>k__BackingField;
    protected Node OriginalPath { get; protected set; }
    public string Path { get; public set; }
    public Ruleset InnerRoot { get; public set; }
    public string InnerContent { get; public set; }
    public Node Features { get; public set; }
    public ImportOptions ImportOptions { get; public set; }
    public Import(Quoted path, Value features, ImportOptions option);
    public Import(Url path, Value features, ImportOptions option);
    private Import(Node originalPath, Node features);
    private Import(Node path, Value features, ImportOptions option);
    [CompilerGeneratedAttribute]
protected Node get_OriginalPath();
    [CompilerGeneratedAttribute]
protected void set_OriginalPath(Node value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public Ruleset get_InnerRoot();
    [CompilerGeneratedAttribute]
public void set_InnerRoot(Ruleset value);
    [CompilerGeneratedAttribute]
public string get_InnerContent();
    [CompilerGeneratedAttribute]
public void set_InnerContent(string value);
    [CompilerGeneratedAttribute]
public Node get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(Node value);
    [CompilerGeneratedAttribute]
public ImportOptions get_ImportOptions();
    [CompilerGeneratedAttribute]
public void set_ImportOptions(ImportOptions value);
    private ImportAction GetImportAction(IImporter importer);
    public virtual void AppendCSS(Env env, Context context);
    public virtual void Accept(IVisitor visitor);
    public virtual Node Evaluate(Env env);
    private bool IsOptionSet(ImportOptions options, ImportOptions test);
}
[FlagsAttribute]
public enum dotless.Core.Parser.Tree.ImportOptions : Enum {
    public int value__;
    public static ImportOptions Once;
    public static ImportOptions Multiple;
    public static ImportOptions Optional;
    public static ImportOptions Css;
    public static ImportOptions Less;
    public static ImportOptions Inline;
    public static ImportOptions Reference;
}
public class dotless.Core.Parser.Tree.KeyFrame : Ruleset {
    [CompilerGeneratedAttribute]
private NodeList <Identifiers>k__BackingField;
    public NodeList Identifiers { get; public set; }
    public KeyFrame(NodeList identifiers, NodeList rules);
    [CompilerGeneratedAttribute]
public NodeList get_Identifiers();
    [CompilerGeneratedAttribute]
public void set_Identifiers(NodeList value);
    public virtual Node Evaluate(Env env);
    public virtual void Accept(IVisitor visitor);
    public virtual void AppendCSS(Env env, Context context);
}
public class dotless.Core.Parser.Tree.Keyword : Node {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; public set; }
    public Keyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public virtual Node Evaluate(Env env);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual string ToString();
    public sealed virtual int CompareTo(object obj);
}
public class dotless.Core.Parser.Tree.Media : Ruleset {
    [CompilerGeneratedAttribute]
private Node <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private Ruleset <Ruleset>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Extender> <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Node, bool> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<Extender, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    public Node Features { get; public set; }
    public Ruleset Ruleset { get; public set; }
    public List`1<Extender> Extensions { get; public set; }
    public Media(Node features, NodeList rules);
    public Media(Node features, Ruleset ruleset, List`1<Extender> extensions);
    [CompilerGeneratedAttribute]
public Node get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(Node value);
    [CompilerGeneratedAttribute]
public Ruleset get_Ruleset();
    [CompilerGeneratedAttribute]
public void set_Ruleset(Ruleset value);
    [CompilerGeneratedAttribute]
public List`1<Extender> get_Extensions();
    [CompilerGeneratedAttribute]
public void set_Extensions(List`1<Extender> value);
    protected virtual Node CloneCore();
    public static NodeList`1<Selector> GetEmptySelector();
    public virtual void Accept(IVisitor visitor);
    public virtual Node Evaluate(Env env);
    protected Node EvalTop(Env env);
    protected Node EvalNested(Env env, Node features, Ruleset ruleset);
    private NodeList Permute(NodeList`1<NodeList> arr);
    public void BubbleSelectors(NodeList`1<Selector> selectors);
    public virtual void AppendCSS(Env env, Context ctx);
    public void AddExtension(Selector selector, Extend extends, Env env);
    public IEnumerable`1<Extender> FindUnmatchedExtensions();
    public ExactExtender FindExactExtension(string selection);
    public PartialExtender[] FindPartialExtensions(Context selection);
    [ObsoleteAttribute("This method doesn't return the correct results. Use FindPartialExtensions(Context) instead.", "False")]
public PartialExtender[] FindPartialExtensions(string selection);
    [CompilerGeneratedAttribute]
private static bool <AppendCSS>b__6(Node r);
    [CompilerGeneratedAttribute]
private static bool <FindUnmatchedExtensions>b__10(Extender e);
}
public class dotless.Core.Parser.Tree.MixinCall : Node {
    [CompilerGeneratedAttribute]
private List`1<NamedArgument> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Selector <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Important>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Element, Element> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<Closure, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    public List`1<NamedArgument> Arguments { get; public set; }
    public Selector Selector { get; public set; }
    public bool Important { get; public set; }
    public MixinCall(NodeList`1<Element> elements, List`1<NamedArgument> arguments, bool important);
    [CompilerGeneratedAttribute]
public List`1<NamedArgument> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(List`1<NamedArgument> value);
    [CompilerGeneratedAttribute]
public Selector get_Selector();
    [CompilerGeneratedAttribute]
public void set_Selector(Selector value);
    [CompilerGeneratedAttribute]
public bool get_Important();
    [CompilerGeneratedAttribute]
public void set_Important(bool value);
    protected virtual Node CloneCore();
    public virtual Node Evaluate(Env env);
    public virtual void Accept(IVisitor visitor);
    private Ruleset MakeRulesetImportant(Ruleset ruleset);
    private NodeList MakeRulesImportant(NodeList rules);
    private Rule MakeRuleImportant(Rule rule);
    [CompilerGeneratedAttribute]
private static Element <CloneCore>b__0(Element e);
    [CompilerGeneratedAttribute]
private static bool <Evaluate>b__2(Closure c);
}
public class dotless.Core.Parser.Tree.MixinDefinition : Ruleset {
    private int _required;
    private int _arity;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeList`1<Rule> <Params>k__BackingField;
    [CompilerGeneratedAttribute]
private Condition <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Variadic>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Rule, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<Node, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    public string Name { get; public set; }
    public NodeList`1<Rule> Params { get; public set; }
    public Condition Condition { get; public set; }
    public bool Variadic { get; public set; }
    public MixinDefinition(string name, NodeList`1<Rule> parameters, NodeList rules, Condition condition, bool variadic);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public NodeList`1<Rule> get_Params();
    [CompilerGeneratedAttribute]
public void set_Params(NodeList`1<Rule> value);
    [CompilerGeneratedAttribute]
public Condition get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(Condition value);
    [CompilerGeneratedAttribute]
public bool get_Variadic();
    [CompilerGeneratedAttribute]
public void set_Variadic(bool value);
    public virtual Node Evaluate(Env env);
    public Ruleset EvaluateParams(Env env, List`1<NamedArgument> args);
    [ObsoleteAttribute("This method will be removed in a future release. Use Evaluate(List<NamedArgument>, Env) instead.", "False")]
public Ruleset Evaluate(List`1<NamedArgument> args, Env env, List`1<Ruleset> closureFrames);
    public Ruleset Evaluate(List`1<NamedArgument> args, Env env);
    public virtual MixinMatch MatchArguments(List`1<NamedArgument> arguments, Env env);
    public virtual void Accept(IVisitor visitor);
    public virtual void AppendCSS(Env env, Context context);
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__1(Rule r);
    [CompilerGeneratedAttribute]
private static bool <EvaluateParams>b__5(Node a);
}
public class dotless.Core.Parser.Tree.Number : Node {
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Unit>k__BackingField;
    public double Value { get; public set; }
    public string Unit { get; public set; }
    public Number(string value, string unit);
    public Number(double value, string unit);
    public Number(double value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    [CompilerGeneratedAttribute]
public string get_Unit();
    [CompilerGeneratedAttribute]
public void set_Unit(string value);
    private string FormatValue();
    private int GetPrecision();
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public sealed virtual Node Operate(Operation op, Node other);
    public sealed virtual Color ToColor();
    public double ToNumber();
    public double ToNumber(double max);
    public static Number op_UnaryNegation(Number n);
    public sealed virtual int CompareTo(object obj);
}
public class dotless.Core.Parser.Tree.Operation : Node {
    [CompilerGeneratedAttribute]
private Node <First>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Second>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Operator>k__BackingField;
    public Node First { get; public set; }
    public Node Second { get; public set; }
    public string Operator { get; public set; }
    public Operation(string op, Node first, Node second);
    [CompilerGeneratedAttribute]
public Node get_First();
    [CompilerGeneratedAttribute]
public void set_First(Node value);
    [CompilerGeneratedAttribute]
public Node get_Second();
    [CompilerGeneratedAttribute]
public void set_Second(Node value);
    [CompilerGeneratedAttribute]
public string get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(string value);
    protected virtual Node CloneCore();
    public virtual Node Evaluate(Env env);
    public static double Operate(string op, double first, double second);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Paren : Node {
    [CompilerGeneratedAttribute]
private Node <Value>k__BackingField;
    public Node Value { get; public set; }
    public Paren(Node value);
    [CompilerGeneratedAttribute]
public Node get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Node value);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual Node Evaluate(Env env);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Quoted : TextNode {
    private Regex _unescape;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <Quote>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Escaped>k__BackingField;
    public Nullable`1<char> Quote { get; public set; }
    public bool Escaped { get; public set; }
    public Quoted(string value, Nullable`1<char> quote);
    public Quoted(string value, Nullable`1<char> quote, bool escaped);
    public Quoted(string value, string contents, bool escaped);
    public Quoted(string value, bool escaped);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_Quote();
    [CompilerGeneratedAttribute]
public void set_Quote(Nullable`1<char> value);
    [CompilerGeneratedAttribute]
public bool get_Escaped();
    [CompilerGeneratedAttribute]
public void set_Escaped(bool value);
    public virtual void AppendCSS(Env env);
    public StringBuilder RenderString();
    public virtual string ToString();
    public virtual Node Evaluate(Env env);
    public string UnescapeContents();
}
public class dotless.Core.Parser.Tree.ReferenceVisitor : object {
    private bool isReference;
    public ReferenceVisitor(bool isReference);
    public sealed virtual Node Visit(Node node);
}
public class dotless.Core.Parser.Tree.Root : Ruleset {
    [CompilerGeneratedAttribute]
private Func`2<ParsingException, ParserException> <Error>k__BackingField;
    public Func`2<ParsingException, ParserException> Error { get; public set; }
    public Root(NodeList rules, Func`2<ParsingException, ParserException> error);
    protected Root(NodeList rules, Func`2<ParsingException, ParserException> error, Ruleset master);
    [CompilerGeneratedAttribute]
public Func`2<ParsingException, ParserException> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Func`2<ParsingException, ParserException> value);
    public virtual void AppendCSS(Env env);
    private IList`1<Import> CollectImports();
    private Root DoVisiting(Root node, Env env, VisitorPluginType pluginType);
    public virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Tree.Rule : Node {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeList <PostNameComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSemiColonRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Variadic>k__BackingField;
    public string Name { get; public set; }
    public Node Value { get; public set; }
    public bool Variable { get; public set; }
    public NodeList PostNameComments { get; public set; }
    public bool IsSemiColonRequired { get; public set; }
    public bool Variadic { get; public set; }
    public Rule(string name, Node value);
    public Rule(string name, Node value, bool variadic);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Node get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Node value);
    [CompilerGeneratedAttribute]
public bool get_Variable();
    [CompilerGeneratedAttribute]
public void set_Variable(bool value);
    [CompilerGeneratedAttribute]
public NodeList get_PostNameComments();
    [CompilerGeneratedAttribute]
public void set_PostNameComments(NodeList value);
    [CompilerGeneratedAttribute]
public bool get_IsSemiColonRequired();
    [CompilerGeneratedAttribute]
public void set_IsSemiColonRequired(bool value);
    [CompilerGeneratedAttribute]
public bool get_Variadic();
    [CompilerGeneratedAttribute]
public void set_Variadic(bool value);
    public virtual Node Evaluate(Env env);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Ruleset : Node {
    private Dictionary`2<string, List`1<Closure>> _lookups;
    [CompilerGeneratedAttribute]
private NodeList`1<Selector> <Selectors>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeList <Rules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Evaluated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MultiMedia>k__BackingField;
    [CompilerGeneratedAttribute]
private Ruleset <OriginalRuleset>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Rule, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<Selector>, Selector> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, int> CS$<>9__CachedAnonymousMethodDelegate10;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, IEnumerable`1<Element>> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Converter`2<StringBuilder, string> CS$<>9__CachedAnonymousMethodDelegate17;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, bool> CS$<>9__CachedAnonymousMethodDelegate1d;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, bool> CS$<>9__CachedAnonymousMethodDelegate1e;
    [CompilerGeneratedAttribute]
private static Func`2<PartialExtender, bool> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, bool> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<Selector, string> CS$<>9__CachedAnonymousMethodDelegate25;
    public NodeList`1<Selector> Selectors { get; public set; }
    public NodeList Rules { get; public set; }
    public bool Evaluated { get; protected set; }
    public bool IsRoot { get; public set; }
    public bool MultiMedia { get; public set; }
    public Ruleset OriginalRuleset { get; public set; }
    public Ruleset(NodeList`1<Selector> selectors, NodeList rules);
    protected Ruleset(NodeList`1<Selector> selectors, NodeList rules, Ruleset originalRuleset);
    [CompilerGeneratedAttribute]
public NodeList`1<Selector> get_Selectors();
    [CompilerGeneratedAttribute]
public void set_Selectors(NodeList`1<Selector> value);
    [CompilerGeneratedAttribute]
public NodeList get_Rules();
    [CompilerGeneratedAttribute]
public void set_Rules(NodeList value);
    [CompilerGeneratedAttribute]
public bool get_Evaluated();
    [CompilerGeneratedAttribute]
protected void set_Evaluated(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRoot();
    [CompilerGeneratedAttribute]
public void set_IsRoot(bool value);
    [CompilerGeneratedAttribute]
public bool get_MultiMedia();
    [CompilerGeneratedAttribute]
public void set_MultiMedia(bool value);
    [CompilerGeneratedAttribute]
public Ruleset get_OriginalRuleset();
    [CompilerGeneratedAttribute]
public void set_OriginalRuleset(Ruleset value);
    public bool IsEqualOrClonedFrom(Node node);
    public bool IsEqualOrClonedFrom(Ruleset ruleset);
    public Rule Variable(string name, Node startNode);
    public List`1<Ruleset> Rulesets();
    public List`1<Closure> Find(Env env, Selector selector, Ruleset self);
    private IEnumerable`1<Closure> FindInternal(Env env, Selector selector, Ruleset self, Context context);
    private static bool ElementValuesEqual(Element e1, Element e2);
    public virtual MixinMatch MatchArguments(List`1<NamedArgument> arguments, Env env);
    public virtual Node Evaluate(Env env);
    private Ruleset Clone();
    protected virtual Node CloneCore();
    public virtual void Accept(IVisitor visitor);
    protected void EvaluateRules(Env env);
    protected Ruleset EvaluateRulesForFrame(Ruleset frame, Env context);
    public virtual void AppendCSS(Env env);
    protected void AppendRules(Env env);
    public virtual void AppendCSS(Env env, Context context);
    private bool AddExtenders(Env env, Context context, Context paths);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static bool <Variable>b__1(Rule r);
    [CompilerGeneratedAttribute]
private static Selector <Find>b__6(IEnumerable`1<Selector> selectors);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<Element> <Find>b__7(Selector s);
    [CompilerGeneratedAttribute]
private static Selector <FindInternal>b__a(IEnumerable`1<Selector> selectors);
    [CompilerGeneratedAttribute]
private static int <FindInternal>b__d(Selector m);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<Element> <FindInternal>b__b(Selector s);
    [CompilerGeneratedAttribute]
private static string <AppendCSS>b__16(StringBuilder stringBuilder);
    [CompilerGeneratedAttribute]
private static bool <AddExtenders>b__18(Selector s);
    [CompilerGeneratedAttribute]
private static bool <AddExtenders>b__1a(Selector e);
    [CompilerGeneratedAttribute]
private static bool <AddExtenders>b__1b(PartialExtender p);
    [CompilerGeneratedAttribute]
private static bool <AddExtenders>b__1c(Selector e);
    [CompilerGeneratedAttribute]
private static string <ToString>b__24(Selector s);
}
public class dotless.Core.Parser.Tree.Script : Node {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    public string Expression { get; public set; }
    public Script(string script);
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(string value);
    protected virtual Node CloneCore();
    public virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Tree.Selector : Node {
    [ThreadStaticAttribute]
private static Parser parser;
    [ThreadStaticAttribute]
private static Parsers parsers;
    [CompilerGeneratedAttribute]
private NodeList`1<Element> <Elements>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Element, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<Element, Element> CS$<>9__CachedAnonymousMethodDelegate3;
    public NodeList`1<Element> Elements { get; public set; }
    private Parser Parser { get; }
    private Parsers Parsers { get; }
    public Selector(IEnumerable`1<Element> elements);
    [CompilerGeneratedAttribute]
public NodeList`1<Element> get_Elements();
    [CompilerGeneratedAttribute]
public void set_Elements(NodeList`1<Element> value);
    public bool Match(Selector other);
    private Parser get_Parser();
    private Parsers get_Parsers();
    public virtual Node Evaluate(Env env);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual void Accept(IVisitor visitor);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static bool <Evaluate>b__0(Element e);
    [CompilerGeneratedAttribute]
private static Element <CloneCore>b__2(Element e);
}
public class dotless.Core.Parser.Tree.Shorthand : Node {
    [CompilerGeneratedAttribute]
private Node <First>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Second>k__BackingField;
    public Node First { get; public set; }
    public Node Second { get; public set; }
    public Shorthand(Node first, Node second);
    [CompilerGeneratedAttribute]
public Node get_First();
    [CompilerGeneratedAttribute]
public void set_First(Node value);
    [CompilerGeneratedAttribute]
public Node get_Second();
    [CompilerGeneratedAttribute]
public void set_Second(Node value);
    public virtual Node Evaluate(Env env);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Url : Node {
    [CompilerGeneratedAttribute]
private Node <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ImportPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IImporter <Importer>k__BackingField;
    public Node Value { get; public set; }
    public List`1<string> ImportPaths { get; public set; }
    public IImporter Importer { get; public set; }
    public Url(Node value, IImporter importer);
    public Url(Node value);
    [CompilerGeneratedAttribute]
public Node get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Node value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ImportPaths();
    [CompilerGeneratedAttribute]
public void set_ImportPaths(List`1<string> value);
    [CompilerGeneratedAttribute]
public IImporter get_Importer();
    [CompilerGeneratedAttribute]
public void set_Importer(IImporter value);
    public string GetUnadjustedUrl();
    private Node AdjustUrlPath(Node value);
    private TextNode AdjustUrlPath(TextNode textValue);
    public virtual Node Evaluate(Env env);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Value : Node {
    [CompilerGeneratedAttribute]
private NodeList <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeList <PreImportantComments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Important>k__BackingField;
    public NodeList Values { get; public set; }
    public NodeList PreImportantComments { get; public set; }
    public string Important { get; public set; }
    public Value(IEnumerable`1<Node> values, string important);
    [CompilerGeneratedAttribute]
public NodeList get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(NodeList value);
    [CompilerGeneratedAttribute]
public NodeList get_PreImportantComments();
    [CompilerGeneratedAttribute]
public void set_PreImportantComments(NodeList value);
    [CompilerGeneratedAttribute]
public string get_Important();
    [CompilerGeneratedAttribute]
public void set_Important(string value);
    protected virtual Node CloneCore();
    public virtual void AppendCSS(Env env);
    public virtual string ToString();
    public virtual Node Evaluate(Env env);
    public virtual void Accept(IVisitor visitor);
}
public class dotless.Core.Parser.Tree.Variable : Node {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public Variable(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    protected virtual Node CloneCore();
    public virtual Node Evaluate(Env env);
}
public class dotless.Core.Parser.Zone : object {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Extract <Extract>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Zone <CallZone>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<char, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public int LineNumber { get; public set; }
    public int Position { get; public set; }
    public Extract Extract { get; public set; }
    public string Message { get; public set; }
    public string FileName { get; public set; }
    public Zone CallZone { get; public set; }
    public Zone(NodeLocation location);
    public Zone(NodeLocation location, string error, Zone callZone);
    public static int GetLineNumber(NodeLocation location);
    private static void GetLineNumber(NodeLocation location, Int32& lineNumber, Int32& position);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    [CompilerGeneratedAttribute]
public Extract get_Extract();
    [CompilerGeneratedAttribute]
public void set_Extract(Extract value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public Zone get_CallZone();
    [CompilerGeneratedAttribute]
public void set_CallZone(Zone value);
    [CompilerGeneratedAttribute]
private static bool <GetLineNumber>b__0(char c);
}
[DisplayNameAttribute("ColorSpin")]
[DescriptionAttribute("Automatically spins all colors in a less file")]
public class dotless.Core.Plugins.ColorSpinPlugin : VisitorPlugin {
    [CompilerGeneratedAttribute]
private double <Spin>k__BackingField;
    public double Spin { get; public set; }
    public VisitorPluginType AppliesTo { get; }
    public ColorSpinPlugin(double spin);
    [CompilerGeneratedAttribute]
public double get_Spin();
    [CompilerGeneratedAttribute]
public void set_Spin(double value);
    public virtual VisitorPluginType get_AppliesTo();
    public virtual Node Execute(Node node, Boolean& visitDeeper);
}
public class dotless.Core.Plugins.DelegateVisitor : object {
    private Func`2<Node, Node> visitor;
    public DelegateVisitor(Func`2<Node, Node> visitor);
    public sealed virtual Node Visit(Node node);
    public static IVisitor For(Func`2<TNode, Node> projection);
    public static IVisitor For(Action`1<TNode> action);
}
public class dotless.Core.Plugins.GenericPluginConfigurator`1 : object {
    private Func`1<IPlugin> _pluginCreator;
    [CompilerGeneratedAttribute]
private static Func`2<IPluginParameter, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, int> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<ConstructorInfo, bool> CS$<>9__CachedAnonymousMethodDelegate11;
    public string Name { get; }
    public string Description { get; }
    public Type Configurates { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Description();
    public sealed virtual Type get_Configurates();
    public sealed virtual void SetParameterValues(IEnumerable`1<IPluginParameter> pluginParameters);
    public sealed virtual IPlugin CreatePlugin();
    private void GetConstructorInfos(ConstructorInfo& parameterConstructor, ConstructorInfo& defaultConstructor);
    public sealed virtual IEnumerable`1<IPluginParameter> GetParameters();
    [CompilerGeneratedAttribute]
private static bool <SetParameterValues>b__0(IPluginParameter parameter);
    [CompilerGeneratedAttribute]
private static int <SetParameterValues>b__2(ParameterInfo parameter);
    [CompilerGeneratedAttribute]
private static bool <GetConstructorInfos>b__10(ConstructorInfo constructorInfo);
}
public interface dotless.Core.Plugins.IFunctionPlugin {
    public abstract virtual Dictionary`2<string, Type> GetFunctions();
}
public interface dotless.Core.Plugins.IPlugin {
}
public interface dotless.Core.Plugins.IPluginConfigurator {
    public string Name { get; }
    public string Description { get; }
    public Type Configurates { get; }
    public abstract virtual IPlugin CreatePlugin();
    public abstract virtual IEnumerable`1<IPluginParameter> GetParameters();
    public abstract virtual void SetParameterValues(IEnumerable`1<IPluginParameter> parameters);
    public abstract virtual string get_Name();
    public abstract virtual string get_Description();
    public abstract virtual Type get_Configurates();
}
public interface dotless.Core.Plugins.IPluginParameter {
    public string Name { get; }
    public bool IsMandatory { get; }
    public object Value { get; }
    public string TypeDescription { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_IsMandatory();
    public abstract virtual object get_Value();
    public abstract virtual string get_TypeDescription();
    public abstract virtual void SetValue(string value);
}
public interface dotless.Core.Plugins.IVisitor {
    public abstract virtual Node Visit(Node node);
}
public interface dotless.Core.Plugins.IVisitorPlugin {
    public VisitorPluginType AppliesTo { get; }
    public abstract virtual Root Apply(Root tree);
    public abstract virtual VisitorPluginType get_AppliesTo();
    public abstract virtual void OnPreVisiting(Env env);
    public abstract virtual void OnPostVisiting(Env env);
}
[ExtensionAttribute]
public static class dotless.Core.Plugins.PluginFinder : object {
    [CompilerGeneratedAttribute]
private static Func`3<IEnumerable`1<IPluginConfigurator>, IEnumerable`1<IPluginConfigurator>, IEnumerable`1<IPluginConfigurator>> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegatea;
    [CompilerGeneratedAttribute]
private static Func`2<Type, IPluginConfigurator> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Func`2<IPluginConfigurator, Type> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegated;
    [ExtensionAttribute]
public static string GetName(IPlugin plugin);
    [ExtensionAttribute]
public static string GetDescription(IPlugin plugin);
    public static string GetDescription(Type pluginType);
    public static string GetName(Type pluginType);
    public static IEnumerable`1<IPluginConfigurator> GetConfigurators(bool scanPluginsFolder);
    public static IEnumerable`1<IPluginConfigurator> GetConfigurators(Assembly assembly);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<IPluginConfigurator> <GetConfigurators>b__0(IEnumerable`1<IPluginConfigurator> group1, IEnumerable`1<IPluginConfigurator> group2);
    [CompilerGeneratedAttribute]
private static bool <GetConfigurators>b__2(Type type);
    [CompilerGeneratedAttribute]
private static bool <GetConfigurators>b__3(Type type);
    [CompilerGeneratedAttribute]
private static IPluginConfigurator <GetConfigurators>b__4(Type type);
    [CompilerGeneratedAttribute]
private static Type <GetConfigurators>b__5(IPluginConfigurator pluginConfigurator);
    [CompilerGeneratedAttribute]
private static bool <GetConfigurators>b__6(Type type);
}
public class dotless.Core.Plugins.PluginParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMandatory>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Name { get; private set; }
    public bool IsMandatory { get; private set; }
    public object Value { get; private set; }
    private Type Type { get; private set; }
    public string TypeDescription { get; }
    public PluginParameter(string name, Type type, bool isMandatory);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsMandatory();
    [CompilerGeneratedAttribute]
private void set_IsMandatory(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
private Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    public sealed virtual string get_TypeDescription();
    public sealed virtual void SetValue(string stringValue);
}
[DescriptionAttribute("Reverses some css when in rtl mode")]
[DisplayNameAttribute("Rtl")]
public class dotless.Core.Plugins.RtlPlugin : VisitorPlugin {
    [CompilerGeneratedAttribute]
private bool <OnlyReversePrefixedRules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceRtlTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <PropertiesToReverse>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Prefix> <PrefixesToProcess>k__BackingField;
    public bool OnlyReversePrefixedRules { get; public set; }
    public bool ForceRtlTransform { get; public set; }
    public IEnumerable`1<string> PropertiesToReverse { get; public set; }
    public VisitorPluginType AppliesTo { get; }
    private List`1<Prefix> PrefixesToProcess { get; private set; }
    public RtlPlugin(bool onlyReversePrefixedRules, bool forceRtlTransform);
    [CompilerGeneratedAttribute]
public bool get_OnlyReversePrefixedRules();
    [CompilerGeneratedAttribute]
public void set_OnlyReversePrefixedRules(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceRtlTransform();
    [CompilerGeneratedAttribute]
public void set_ForceRtlTransform(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_PropertiesToReverse();
    [CompilerGeneratedAttribute]
public void set_PropertiesToReverse(IEnumerable`1<string> value);
    public virtual VisitorPluginType get_AppliesTo();
    public virtual void OnPreVisiting(Env env);
    public virtual Node Execute(Node node, Boolean& visitDeeper);
    private string Replace(string haystack, string needle, string replacement, StringComparison comparisonType);
    [CompilerGeneratedAttribute]
private List`1<Prefix> get_PrefixesToProcess();
    [CompilerGeneratedAttribute]
private void set_PrefixesToProcess(List`1<Prefix> value);
}
public abstract class dotless.Core.Plugins.VisitorPlugin : object {
    public VisitorPluginType AppliesTo { get; }
    public sealed virtual Root Apply(Root tree);
    public abstract virtual VisitorPluginType get_AppliesTo();
    public sealed virtual Node Visit(Node node);
    public abstract virtual Node Execute(Node node, Boolean& visitDeeper);
    public virtual void OnPreVisiting(Env env);
    public virtual void OnPostVisiting(Env env);
}
public enum dotless.Core.Plugins.VisitorPluginType : Enum {
    public int value__;
    public static VisitorPluginType BeforeEvaluation;
    public static VisitorPluginType AfterEvaluation;
}
public class dotless.Core.Response.CachedCssResponse : CssResponse {
    private int _httpExpiryInMinutes;
    private IClock _clock;
    public CachedCssResponse(IHttp http, bool isCompressionHandledByResponse, int httpExpiryInMinutes);
    public CachedCssResponse(IHttp http, bool isCompressionHandledByResponse, int httpExpiryInMinutes, IClock clock);
    public virtual void WriteHeaders();
}
public class dotless.Core.Response.CssResponse : object {
    public IHttp Http;
    [CompilerGeneratedAttribute]
private bool <IsCompressionHandledByResponse>k__BackingField;
    public bool IsCompressionHandledByResponse { get; public set; }
    public CssResponse(IHttp http, bool isCompressionHandledByResponse);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompressionHandledByResponse();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsCompressionHandledByResponse(bool value);
    public virtual void WriteHeaders();
    public virtual void WriteCss(string css);
    protected void HandleCompression();
}
public interface dotless.Core.Response.IResponse {
    public bool IsCompressionHandledByResponse { get; public set; }
    public abstract virtual void WriteCss(string css);
    public abstract virtual void WriteHeaders();
    public abstract virtual bool get_IsCompressionHandledByResponse();
    public abstract virtual void set_IsCompressionHandledByResponse(bool value);
}
[DebuggerDisplayAttribute("QValue[{Name}, {Weight}]")]
public class dotless.Core.Response.QValue : ValueType {
    private static float defaultWeight;
    private static Char[] delimiters;
    private string _name;
    private float _weight;
    private int _ordinal;
    public string Name { get; }
    public float Weight { get; }
    public bool CanAccept { get; }
    public bool IsEmpty { get; }
    public QValue(string value);
    public QValue(string value, int ordinal);
    private static QValue();
    public string get_Name();
    public float get_Weight();
    public bool get_CanAccept();
    public bool get_IsEmpty();
    public static QValue Parse(string value);
    public static QValue Parse(string value, int ordinal);
    private static void ParseInternal(QValue& target, string value);
    public sealed virtual int CompareTo(QValue other);
    public static int CompareByWeightAsc(QValue x, QValue y);
    public static int CompareByWeightDesc(QValue x, QValue y);
}
[DebuggerDisplayAttribute("QValue[{Count}, {AcceptWildcard}]")]
[DefaultMemberAttribute("Item")]
public class dotless.Core.Response.QValueList : List`1<QValue> {
    private static Char[] delimiters;
    private bool _acceptWildcard;
    private bool _autoSort;
    public bool AcceptWildcard { get; }
    public bool AutoSort { get; public set; }
    public QValue Item { get; }
    public QValueList(string values);
    public QValueList(String[] values);
    private static QValueList();
    public bool get_AcceptWildcard();
    public bool get_AutoSort();
    public void set_AutoSort(bool value);
    public QValue get_Item(String[] candidates);
    public void Add(QValue item);
    public void AddRange(IEnumerable`1<QValue> collection);
    public QValue Find(string name);
    public QValue FindHighestWeight(String[] candidates);
    public QValue FindPreferred(String[] candidates);
    public void DefaultSort();
    private void applyAutoSort();
    private static bool isCandidate(string item, String[] candidates);
}
public class dotless.Core.Stylizers.ConsoleStylizer : object {
    private Dictionary`2<string, Int32[]> styles;
    private string Stylize(string str, string style);
    public sealed virtual string Stylize(Zone zone);
}
public class dotless.Core.Stylizers.HtmlStylizer : object {
    public sealed virtual string Stylize(Zone zone);
}
public interface dotless.Core.Stylizers.IStylizer {
    public abstract virtual string Stylize(Zone zone);
}
public class dotless.Core.Stylizers.PlainStylizer : object {
    public sealed virtual string Stylize(Zone zone);
}
[ExtensionAttribute]
internal static class dotless.Core.Utils.EnumerableExtensions : object {
    [ExtensionAttribute]
internal static bool IsSubsequenceOf(IList`1<TElement> subsequence, IList`1<TElement> sequence);
    [ExtensionAttribute]
internal static bool IsSubsequenceOf(IList`1<TElement> subsequence, IList`1<TElement> sequence, Func`3<TElement, TElement, bool> areEqual);
    [ExtensionAttribute]
internal static bool IsSubsequenceOf(IList`1<TElement> subsequence, IList`1<TElement> sequence, Func`5<int, TElement, int, TElement, bool> areEqual);
    [CompilerGeneratedAttribute]
private static bool <IsSubsequenceOf>b__0(TElement element1, TElement element2);
}
public static class dotless.Core.Utils.Guard : object {
    public static void Expect(string expected, string actual, object in, NodeLocation location);
    public static void Expect(Func`1<bool> condition, string message, NodeLocation location);
    public static void ExpectNode(Node actual, object in, NodeLocation location);
    public static void ExpectNodeToBeOneOf(Node actual, object in, NodeLocation location);
    public static void ExpectAllNodes(IEnumerable`1<Node> actual, object in, NodeLocation location);
    public static void ExpectNumArguments(int expected, int actual, object in, NodeLocation location);
    public static void ExpectMinArguments(int expected, int actual, object in, NodeLocation location);
    public static void ExpectMaxArguments(int expected, int actual, object in, NodeLocation location);
}
public class dotless.Core.Utils.HslColor : object {
    private double _hue;
    private double _saturation;
    private double _lightness;
    [CompilerGeneratedAttribute]
private double <Alpha>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<double, double> CS$<>9__CachedAnonymousMethodDelegate2;
    public double Hue { get; public set; }
    public double Saturation { get; public set; }
    public double Lightness { get; public set; }
    public double Alpha { get; public set; }
    public HslColor(double hue, double saturation, double lightness);
    public HslColor(double hue, double saturation, double lightness, double alpha);
    public HslColor(Number hue, Number saturation, Number lightness, Number alpha);
    public double get_Hue();
    public void set_Hue(double value);
    public double get_Saturation();
    public void set_Saturation(double value);
    public double get_Lightness();
    public void set_Lightness(double value);
    [CompilerGeneratedAttribute]
public double get_Alpha();
    [CompilerGeneratedAttribute]
public void set_Alpha(double value);
    public static HslColor FromRgbColor(Color color);
    public Color ToRgbColor();
    private static double Hue_2_RGB(double v1, double v2, double vH);
    public Number GetHueInDegrees();
    public Number GetSaturation();
    public Number GetLightness();
    [CompilerGeneratedAttribute]
private static double <FromRgbColor>b__0(double x);
}
internal class dotless.Core.Utils.NodeHelper : object {
    public static void ExpandNodes(Env env, NodeList rules);
    public static void RecursiveExpandNodes(Env env, Ruleset parentRuleset);
    public static IEnumerable`1<Node> NonDestructiveExpandNodes(Env env, NodeList rules);
}
[ExtensionAttribute]
public static class dotless.Core.Utils.NumberExtensions : object {
    [ExtensionAttribute]
public static double Normalize(Number value);
    [ExtensionAttribute]
public static double Normalize(Number value, double max);
    [ExtensionAttribute]
public static double Normalize(Number value, double min, double max);
    public static double Normalize(double value);
    public static double Normalize(double value, double max);
    public static double Normalize(double value, double min, double max);
}
[ExtensionAttribute]
public static class dotless.Core.Utils.ObjectExtensions : object {
    [ExtensionAttribute]
public static T Do(T obj, Action`1<T> action);
}
[ExtensionAttribute]
public static class dotless.Core.Utils.StringExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    [ExtensionAttribute]
public static string JoinStrings(IEnumerable`1<string> source, string separator);
    [ExtensionAttribute]
public static string AggregatePaths(IEnumerable`1<string> source, string currentDirectory);
    private static string CanonicalizePath(string path, string currentDirectory);
    [CompilerGeneratedAttribute]
private static bool <CanonicalizePath>b__0(string segment);
}
internal class Microsoft.Practices.ServiceLocation.ActivationException : Exception {
    public ActivationException(string message);
    public ActivationException(string message, Exception innerException);
    protected ActivationException(SerializationInfo info, StreamingContext context);
}
internal interface Microsoft.Practices.ServiceLocation.IServiceLocator {
    public abstract virtual object GetInstance(Type serviceType);
    public abstract virtual object GetInstance(Type serviceType, string key);
    public abstract virtual IEnumerable`1<object> GetAllInstances(Type serviceType);
    public abstract virtual TService GetInstance();
    public abstract virtual TService GetInstance(string key);
    public abstract virtual IEnumerable`1<TService> GetAllInstances();
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
internal class Microsoft.Practices.ServiceLocation.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ActivateAllExceptionMessage { get; }
    internal static string ActivationExceptionMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ActivateAllExceptionMessage();
    internal static string get_ActivationExceptionMessage();
}
internal static class Microsoft.Practices.ServiceLocation.ServiceLocator : object {
    private static ServiceLocatorProvider currentProvider;
    public static IServiceLocator Current { get; }
    public static IServiceLocator get_Current();
    public static void SetLocatorProvider(ServiceLocatorProvider newProvider);
}
internal abstract class Microsoft.Practices.ServiceLocation.ServiceLocatorImplBase : object {
    public virtual object GetService(Type serviceType);
    public virtual object GetInstance(Type serviceType);
    public virtual object GetInstance(Type serviceType, string key);
    public virtual IEnumerable`1<object> GetAllInstances(Type serviceType);
    public virtual TService GetInstance();
    public virtual TService GetInstance(string key);
    public virtual IEnumerable`1<TService> GetAllInstances();
    protected abstract virtual object DoGetInstance(Type serviceType, string key);
    protected abstract virtual IEnumerable`1<object> DoGetAllInstances(Type serviceType);
    protected virtual string FormatActivationExceptionMessage(Exception actualException, Type serviceType, string key);
    protected virtual string FormatActivateAllExceptionMessage(Exception actualException, Type serviceType);
}
internal class Microsoft.Practices.ServiceLocation.ServiceLocatorProvider : MulticastDelegate {
    public ServiceLocatorProvider(object object, IntPtr method);
    public virtual IServiceLocator Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IServiceLocator EndInvoke(IAsyncResult result);
}
internal class Pandora.BehaviorConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <EnableImplicitTypeInstantiation>k__BackingField;
    [CompilerGeneratedAttribute]
private ILifestyle <ImplicitTypeLifestyle>k__BackingField;
    public bool EnableImplicitTypeInstantiation { get; public set; }
    public ILifestyle ImplicitTypeLifestyle { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnableImplicitTypeInstantiation();
    [CompilerGeneratedAttribute]
public void set_EnableImplicitTypeInstantiation(bool value);
    [CompilerGeneratedAttribute]
public ILifestyle get_ImplicitTypeLifestyle();
    [CompilerGeneratedAttribute]
public void set_ImplicitTypeLifestyle(ILifestyle value);
}
internal class Pandora.CommonServiceLocatorAdapter : ServiceLocatorImplBase {
    private IPandoraContainer container;
    public CommonServiceLocatorAdapter(IPandoraContainer container);
    protected virtual object DoGetInstance(Type serviceType, string key);
    protected virtual IEnumerable`1<object> DoGetAllInstances(Type serviceType);
}
internal class Pandora.ComponentActivator : object {
    public virtual object CreateInstance(CreationContext context);
}
internal class Pandora.ComponentStore : object {
    private IList`1<IRegistration> registrations;
    public virtual IRegistration Add();
    public virtual IRegistration Add(string name);
    private IRegistration CreateRegistration(Type serviceType, Type implementor, string name);
    public sealed virtual void AddRegistration(IRegistration registration);
    public virtual IList`1<IRegistration> GetRegistrationsForService();
    public virtual IList`1<IRegistration> GetRegistrationsForService(Type type);
    public virtual void Register(Action`1<FluentRegistration> registrationClosure);
    public virtual IRegistration AddInstance(string name, T instance);
    public virtual IRegistration AddInstance(T instance);
}
internal class Pandora.ConcreteClassInstantiationLookupServiceDecorator : object {
    private IComponentLookup underlying;
    private ILifestyle lifestyle;
    private IDictionary`2<Type, IRegistration> createdRegistrations;
    public ConcreteClassInstantiationLookupServiceDecorator(IComponentLookup underlying, ILifestyle lifestyle);
    public sealed virtual IRegistration LookupType(Query targetType, ResolverContext context);
}
internal class Pandora.DependencyMissingException : ApplicationException {
    public DependencyMissingException(string name, string typeName);
}
internal class Pandora.Fluent.AssemblyAutoConfigOptions : object {
    public AssemblyAutoConfigOptions(AutoConfigCommand command, Assembly assembly);
}
internal class Pandora.Fluent.AutoConfigCommand : object {
    [CompilerGeneratedAttribute]
private Assembly <FromAssembly>k__BackingField;
    public Assembly FromAssembly { get; public set; }
    [CompilerGeneratedAttribute]
public Assembly get_FromAssembly();
    [CompilerGeneratedAttribute]
public void set_FromAssembly(Assembly value);
    public void Execute(FluentRegistration registration);
}
internal class Pandora.Fluent.AutoConfiguration : object {
    private FluentRegistration registration;
    private AutoConfigCommand command;
    public AutoConfiguration(FluentRegistration registration);
    public AssemblyAutoConfigOptions FromAssembly(Assembly assembly);
}
internal class Pandora.Fluent.FluentImplementorOptions`1 : object {
    private NormalRegistrationCommand command;
    public FluentLifestyleOptions`1<T> Lifestyle { get; }
    public FluentImplementorOptions`1(NormalRegistrationCommand command);
    public FluentLifestyleOptions`1<T> get_Lifestyle();
    public FluentParameterOptions`1<T> Parameters(string name);
}
internal class Pandora.Fluent.FluentLifestyleOptions`1 : object {
    private NormalRegistrationCommand command;
    private FluentImplementorOptions`1<T> parentOptions;
    public FluentLifestyleOptions`1(NormalRegistrationCommand command, FluentImplementorOptions`1<T> parentOptions);
    public FluentImplementorOptions`1<T> Singleton();
    public FluentImplementorOptions`1<T> Transient();
    public FluentImplementorOptions`1<T> Custom(ILifestyle lifestyle);
}
internal class Pandora.Fluent.FluentParameterOptions`1 : object {
    private NormalRegistrationCommand command;
    private FluentImplementorOptions`1<T> parentOptions;
    private string parameterName;
    public FluentParameterOptions`1(NormalRegistrationCommand command, FluentImplementorOptions`1<T> parentOptions, string parameterName);
    public FluentImplementorOptions`1<T> Set(string value);
}
internal class Pandora.Fluent.FluentRegistration : object {
    internal IComponentStore store;
    private IList`1<ICommand> commands;
    public AutoConfiguration AutoConfigure { get; }
    public FluentRegistration(IComponentStore store);
    public FluentServiceOptions`1<T> Service();
    public FluentServiceOptions`1<T> Service(string name);
    public AutoConfiguration get_AutoConfigure();
    public GenericServiceOptions Generic(Type generic, string name);
    public GenericServiceOptions Generic(Type generic);
    internal void Commit();
}
internal class Pandora.Fluent.FluentServiceOptions`1 : object {
    private NormalRegistrationCommand registration;
    public FluentServiceOptions`1(NormalRegistrationCommand registration);
    public FluentImplementorOptions`1<T> Implementor();
    public FluentImplementorOptions`1<T> Implementor(Type implementorType);
    public void Instance(S instance);
}
internal class Pandora.Fluent.GenericImplementorOptions : object {
    private GenericServiceCommand command;
    public GenericImplementorOptions(GenericServiceCommand command);
    public GenericImplementorOptions OnlyForTypes(Type[] types);
    public GenericImplementorOptions ForAllTypes();
}
internal class Pandora.Fluent.GenericServiceCommand : object {
    private Type service;
    private Type implementor;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <ForTypes>k__BackingField;
    public string Name { get; public set; }
    public Type Service { get; public set; }
    public Type Implementor { get; public set; }
    public Type[] ForTypes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public Type get_Service();
    public void set_Service(Type value);
    public Type get_Implementor();
    public void set_Implementor(Type value);
    [CompilerGeneratedAttribute]
public Type[] get_ForTypes();
    [CompilerGeneratedAttribute]
public void set_ForTypes(Type[] value);
    public sealed virtual void Execute(IComponentStore store);
}
internal class Pandora.Fluent.GenericServiceOptions : object {
    private GenericServiceCommand command;
    public GenericServiceOptions(GenericServiceCommand command);
    public GenericImplementorOptions Implementor(Type implementor);
}
internal interface Pandora.Fluent.ICommand {
    public abstract virtual void Execute(IComponentStore store);
}
internal class Pandora.Fluent.NormalRegistrationCommand : object {
    public IDictionary`2<string, string> Parameters;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Implementor>k__BackingField;
    [CompilerGeneratedAttribute]
private ILifestyle <Lifestyle>k__BackingField;
    public string Name { get; public set; }
    public Type Service { get; public set; }
    public Type Implementor { get; public set; }
    public ILifestyle Lifestyle { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_Service();
    [CompilerGeneratedAttribute]
public void set_Service(Type value);
    [CompilerGeneratedAttribute]
public Type get_Implementor();
    [CompilerGeneratedAttribute]
public void set_Implementor(Type value);
    [CompilerGeneratedAttribute]
public ILifestyle get_Lifestyle();
    [CompilerGeneratedAttribute]
public void set_Lifestyle(ILifestyle value);
    public sealed virtual void Execute(IComponentStore store);
    public void SetInstance(object instance);
}
internal interface Pandora.IComponentActivator {
    public abstract virtual object CreateInstance(CreationContext context);
}
internal interface Pandora.IComponentLookup {
    public abstract virtual IRegistration LookupType(Query targetType, ResolverContext context);
}
internal interface Pandora.IComponentStore {
    public abstract virtual IRegistration Add();
    public abstract virtual IRegistration Add(string name);
    public abstract virtual IList`1<IRegistration> GetRegistrationsForService();
    public abstract virtual IList`1<IRegistration> GetRegistrationsForService(Type type);
    public abstract virtual IRegistration AddInstance(string name, T instance);
    public abstract virtual IRegistration AddInstance(T instance);
    public abstract virtual void AddRegistration(IRegistration registration);
    public abstract virtual void Register(Action`1<FluentRegistration> registrationClosure);
}
internal interface Pandora.ILifestyle {
    public abstract virtual object Execute(Func`1<object> action);
}
internal interface Pandora.IPandoraContainer {
    public abstract virtual T Resolve();
    public abstract virtual object Resolve(Type type);
    public abstract virtual T Resolve(string name);
    public abstract virtual object Resolve(Type type, string name);
    public abstract virtual IEnumerable`1<T> ResolveAll();
    public abstract virtual IEnumerable`1<object> ResolveAll(Type serviceType);
    public abstract virtual void Register(Action`1<FluentRegistration> registrationClosure);
}
internal interface Pandora.IRegistration {
    public Guid Guid { get; }
    public Type Service { get; public set; }
    public Type Implementor { get; public set; }
    public string Name { get; public set; }
    public IDictionary`2<string, string> Parameters { get; public set; }
    public ILifestyle Lifestyle { get; public set; }
    public abstract virtual Guid get_Guid();
    public abstract virtual Type get_Service();
    public abstract virtual void set_Service(Type value);
    public abstract virtual Type get_Implementor();
    public abstract virtual void set_Implementor(Type value);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual IDictionary`2<string, string> get_Parameters();
    public abstract virtual void set_Parameters(IDictionary`2<string, string> value);
    public abstract virtual ILifestyle get_Lifestyle();
    public abstract virtual void set_Lifestyle(ILifestyle value);
}
internal static class Pandora.Lifestyles.ComponentLifestyles : object {
    public static ILifestyle Singleton { get; }
    public static ILifestyle Transient { get; }
    public static ILifestyle get_Singleton();
    public static ILifestyle get_Transient();
}
internal class Pandora.Lifestyles.InjectedInstanceLifestyle : SingletonLifestyle {
    public InjectedInstanceLifestyle(object instance);
}
internal class Pandora.Lifestyles.SingletonLifestyle : object {
    private object singleton;
    private object lockObject;
    public sealed virtual object Execute(Func`1<object> action);
    protected void SetSingleton(object instance);
}
internal class Pandora.Lifestyles.TransientLifestyle : object {
    public sealed virtual object Execute(Func`1<object> action);
}
internal class Pandora.LookupService : object {
    private IComponentStore componentStore;
    public LookupService(IComponentStore componentStore);
    private IRegistration SkipParents(IEnumerable`1<IRegistration> candidates, ICollection`1<IRegistration> parents);
    public virtual IRegistration LookupType(Query query, ResolverContext context);
}
internal class Pandora.Model.CreationContext : object {
    [CompilerGeneratedAttribute]
private Type <ConcreteType>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public Type ConcreteType { get; public set; }
    public Object[] Arguments { get; public set; }
    [CompilerGeneratedAttribute]
public virtual Type get_ConcreteType();
    [CompilerGeneratedAttribute]
public virtual void set_ConcreteType(Type value);
    [CompilerGeneratedAttribute]
public virtual Object[] get_Arguments();
    [CompilerGeneratedAttribute]
public virtual void set_Arguments(Object[] value);
}
internal class Pandora.NameAlreadyRegisteredException : ApplicationException {
    public NameAlreadyRegisteredException(string name);
}
internal class Pandora.PandoraContainer : object {
    private IComponentStore componentStore;
    private Resolver resolver;
    private IComponentLookup lookupService;
    public PandoraContainer(IComponentStore componentStore);
    public PandoraContainer(IComponentStore componentStore, BehaviorConfiguration configuration);
    public PandoraContainer(BehaviorConfiguration configuration);
    private IComponentLookup BuildLookupService(bool enableImplicitClassInstantiation, ILifestyle defaultLifestyle);
    public virtual T Resolve();
    public virtual object Resolve(Type type);
    public virtual T Resolve(string name);
    public virtual object Resolve(Type type, string name);
    public sealed virtual IEnumerable`1<T> ResolveAll();
    public sealed virtual IEnumerable`1<object> ResolveAll(Type serviceType);
    public sealed virtual void Register(Action`1<FluentRegistration> registrationClosure);
}
internal class Pandora.Query : object {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Type ServiceType { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public void set_ServiceType(Type value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal class Pandora.Registration : object {
    private ILifestyle lifestyle;
    private IDictionary`2<string, string> parameters;
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Implementor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Guid Guid { get; private set; }
    public Type Service { get; public set; }
    public Type Implementor { get; public set; }
    public string Name { get; public set; }
    public ILifestyle Lifestyle { get; public set; }
    public IDictionary`2<string, string> Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Guid();
    [CompilerGeneratedAttribute]
private void set_Guid(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Service();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Service(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Implementor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Implementor(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    public sealed virtual ILifestyle get_Lifestyle();
    public sealed virtual void set_Lifestyle(ILifestyle value);
    public sealed virtual IDictionary`2<string, string> get_Parameters();
    public sealed virtual void set_Parameters(IDictionary`2<string, string> value);
    private bool Equals(Registration other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Pandora.RegistrationException : ApplicationException {
    public RegistrationException(Type implementorType);
}
internal class Pandora.Resolver : object {
    private IComponentActivator activator;
    private IComponentLookup componentLookup;
    [CompilerGeneratedAttribute]
private static Func`2<ConstructorInfo, int> CS$<>9__CachedAnonymousMethodDelegate3;
    public Resolver(IComponentActivator activator, IComponentLookup componentLookup);
    private IRegistration FindSuitableImplementor(Query query, ResolverContext context);
    private CreationContext CreateReturnContext(Type type, Object[] parameters);
    public virtual CreationContext GenerateCreationContext(IRegistration registration, ResolverContext context);
    public virtual object CreateType(Query query, ResolverContext context);
    public virtual object CreateType(Query query);
    [CompilerGeneratedAttribute]
private static int <GenerateCreationContext>b__2(ConstructorInfo p);
}
internal class Pandora.ResolverContext : object {
    private IList`1<IRegistration> usedRegistrations;
    public IEnumerable`1<IRegistration> UsedRegistrations { get; }
    public IEnumerable`1<IRegistration> get_UsedRegistrations();
    public virtual void ConsumeRegistration(IRegistration registration);
    public static ResolverContext CreateContextFromContext(ResolverContext context);
}
internal class Pandora.ServiceNotFoundException : ApplicationException {
    public ServiceNotFoundException(Type type);
    public ServiceNotFoundException(Type type, string name);
}
