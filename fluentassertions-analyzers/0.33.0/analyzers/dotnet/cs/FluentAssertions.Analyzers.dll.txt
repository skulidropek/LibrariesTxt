[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class FluentAssertions.Analyzers.AssertAnalyzer : DiagnosticAnalyzer {
    public static string Message;
    public static DiagnosticDescriptor XunitRule;
    public static DiagnosticDescriptor MSTestsRule;
    public static DiagnosticDescriptor NUnitRule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AssertAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class FluentAssertions.Analyzers.AsyncVoidAnalyzer : DiagnosticAnalyzer {
    public static string DiagnosticId;
    public static string Title;
    public static string Message;
    public static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AsyncVoidAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private void AnalyzeCodeBlock(CodeBlockAnalysisContext context);
    protected virtual Diagnostic AnalyzeStatement(SemanticModel semanticModel, LocalDeclarationStatementSyntax statement);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class FluentAssertions.Analyzers.AsyncVoidCodeFix : CodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
public abstract class FluentAssertions.Analyzers.CodeFixProviderBase`1 : CodeFixProvider {
    protected string Title { get; }
    public sealed virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual string get_Title();
    [AsyncStateMachineAttribute("FluentAssertions.Analyzers.CodeFixProviderBase`1/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual TTestContext CreateTestContext(SemanticModel semanticModel);
    protected abstract virtual Func`2<CancellationToken, Task`1<Document>> TryComputeFix(IInvocationOperation invocation, CodeFixContext context, TTestContext t, Diagnostic diagnostic);
}
public enum FluentAssertions.Analyzers.CombineAssertionArgumentsStrategy : Enum {
    public int value__;
    public static CombineAssertionArgumentsStrategy FirstAssertionFirst;
    public static CombineAssertionArgumentsStrategy InsertFirstAssertionIntoIndex1OfSecondAssertion;
    public static CombineAssertionArgumentsStrategy InsertSecondAssertionIntoIndex1OfFirstAssertion;
}
public static class FluentAssertions.Analyzers.Constants : object {
}
public class FluentAssertions.Analyzers.CreateEquivalencyAssertionOptionsLambdaAction : object {
    [CompilerGeneratedAttribute]
private int <argumentIndex>P;
    public CreateEquivalencyAssertionOptionsLambdaAction(int argumentIndex);
    public sealed virtual void Apply(DocumentEditor editor, InvocationExpressionSyntax invocationExpression);
}
public class FluentAssertions.Analyzers.DiagnosticMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpLink>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotBeEmpty_AnyShouldBeTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldBeEmpty_AnyShouldBeFalse>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldContainProperty_AnyWithLambdaShouldBeTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotContainProperty_AnyLambdaShouldBeFalse>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldOnlyContainProperty_AllShouldBeTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldContainItem_ContainsShouldBeTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotContainItem_ContainsShouldBeFalse>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveCount_CountShouldBe>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveCount_LengthShouldBe>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveCountGreaterThan_CountShouldBeGreaterThan>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveCountGreaterOrEqualTo_CountShouldBeGreaterOrEqualTo>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveCountLessThan_CountShouldBeLessThan>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveCountLessOrEqualTo_CountShouldBeLessOrEqualTo>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotHaveCount_CountShouldNotBe>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldContainSingle_ShouldHaveCount1>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldContainSingle_CountShouldBe1>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldContainSingle_CountPropertyShouldBe1>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldBeEmpty_ShouldHaveCount0>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldBeEmpty_CountShouldBe0>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldBeEmpty_CountPropertyShouldBe0>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveSameCount_ShouldHaveCountOtherCollectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotHaveSameCount_CountShouldNotBeOtherCollectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldContainProperty_WhereShouldNotBeEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotContainProperty_WhereShouldBeEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldContainSingle_WhereShouldHaveCount1>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotContainProperty_ShouldOnlyContainNot>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotBeNullOrEmpty_ShouldNotBeNullAndNotBeEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotBeNullOrEmpty_ShouldNotBeEmptyAndNotBeNull>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveElementAt_ElementAtIndexShouldBe>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveElementAt_IndexerShouldBe>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldHaveElementAt_SkipFirstShouldBe>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldBeInAscendingOrder_OrderByShouldEqual>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldBeInDescendingOrder_OrderByDescendingShouldEqual>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldEqualOtherCollectionByComparer_SelectShouldEqualOtherCollectionSelect>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotIntersectWith_IntersectShouldBeEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldIntersectWith_IntersectShouldNotBeEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldNotContainNulls_SelectShouldNotContainNulls>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldOnlyHaveUniqueItems_ShouldHaveSameCountThisCollectionDistinct>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <CollectionShouldOnlyHaveUniqueItemsByComparer_SelectShouldOnlyHaveUniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <NumericShouldBePositive_ShouldBeGreaterThan>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <NumericShouldBeNegative_ShouldBeLessThan>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <NumericShouldBeInRange_BeGreaterOrEqualToAndBeLessOrEqualTo>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <NumericShouldBeInRange_BeLessOrEqualToAndBeGreaterOrEqualTo>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <NumericShouldBeApproximately_MathAbsShouldBeLessOrEqualTo>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <StringShouldStartWith_StartsWithShouldBeTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <StringShouldEndWith_EndsWithShouldBeTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <StringShouldNotBeNullOrEmpty_StringShouldNotBeNullAndNotBeEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <StringShouldNotBeNullOrEmpty_StringShouldNotBeEmptyAndNotBeNull>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <StringShouldBeNullOrEmpty_StringIsNullOrEmptyShouldBeTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <StringShouldNotBeNullOrEmpty_StringIsNullOrEmptyShouldBeFalse>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <StringShouldBeNullOrWhiteSpace_StringIsNullOrWhiteSpaceShouldBeTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <StringShouldNotBeNullOrWhiteSpace_StringShouldNotBeNullOrWhiteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticMetadata <StringShouldHaveLength_LengthShouldBe>k__BackingField;
    public static DiagnosticMetadata DictionaryShouldContainKey_ContainsKeyShouldBeTrue;
    public static DiagnosticMetadata DictionaryShouldNotContainKey_ContainsKeyShouldBeFalse;
    public static DiagnosticMetadata DictionaryShouldContainValue_ContainsValueShouldBeTrue;
    public static DiagnosticMetadata DictionaryShouldNotContainValue_ContainsValueShouldBeFalse;
    public static DiagnosticMetadata DictionaryShouldContainKeyAndValue_ShouldContainKeyAndContainValue;
    public static DiagnosticMetadata DictionaryShouldContainKeyAndValue_ShouldContainValueAndContainKey;
    public static DiagnosticMetadata DictionaryShouldContainPair_ShouldContainKeyAndContainValue;
    public static DiagnosticMetadata DictionaryShouldContainPair_ShouldContainValueAndContainKey;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithMessage_ShouldThrowExactlyAndMessageShouldBe;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithMessage_ShouldThrowExactlyWhichMessageShouldBe;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithMessage_ShouldThrowExactlyAndMessageShouldContain;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithMessage_ShouldThrowExactlyWhichMessageShouldContain;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithMessage_ShouldThrowExactlyAndMessageShouldEndWith;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithMessage_ShouldThrowExactlyWhichMessageShouldEndWith;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithMessage_ShouldThrowExactlyAndMessageShouldStartWith;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithMessage_ShouldThrowExactlyWhichMessageShouldStartWith;
    public static DiagnosticMetadata ExceptionShouldThrowWithMessage_ShouldThrowAndMessageShouldBe;
    public static DiagnosticMetadata ExceptionShouldThrowWithMessage_ShouldThrowWhichMessageShouldBe;
    public static DiagnosticMetadata ExceptionShouldThrowWithMessage_ShouldThrowAndMessageShouldContain;
    public static DiagnosticMetadata ExceptionShouldThrowWithMessage_ShouldThrowWhichMessageShouldContain;
    public static DiagnosticMetadata ExceptionShouldThrowWithMessage_ShouldThrowAndMessageShouldEndWith;
    public static DiagnosticMetadata ExceptionShouldThrowWithMessage_ShouldThrowWhichMessageShouldEndWith;
    public static DiagnosticMetadata ExceptionShouldThrowWithMessage_ShouldThrowAndMessageShouldStartWith;
    public static DiagnosticMetadata ExceptionShouldThrowWithMessage_ShouldThrowWhichMessageShouldStartWith;
    public static DiagnosticMetadata ExceptionShouldThrowWithInnerException_ShouldThrowAndInnerExceptionShouldBeOfType;
    public static DiagnosticMetadata ExceptionShouldThrowWithInnerException_ShouldThrowWhichInnerExceptionShouldBeOfType;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithInnerException_ShouldThrowExactlyAndInnerExceptionShouldBeOfType;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithInnerException_ShouldThrowExactlyWhichInnerExceptionShouldBeOfType;
    public static DiagnosticMetadata ExceptionShouldThrowWithInnerException_ShouldThrowAndInnerExceptionShouldBeAssignableTo;
    public static DiagnosticMetadata ExceptionShouldThrowWithInnerException_ShouldThrowWhichInnerExceptionShouldBeAssignableTo;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithInnerException_ShouldThrowExactlyAndInnerExceptionShouldBeAssignableTo;
    public static DiagnosticMetadata ExceptionShouldThrowExactlyWithInnerException_ShouldThrowExactlyWhichInnerExceptionShouldBeAssignableTo;
    public static DiagnosticMetadata StringShouldBe_StringShouldEquals;
    public static DiagnosticMetadata CollectionShouldEqual_CollectionShouldEquals;
    public static DiagnosticMetadata ShouldEquals;
    public static DiagnosticMetadata ShouldBe_ShouldEquals;
    public static DiagnosticMetadata NullConditionalMayNotExecute;
    public string Name { get; }
    public string Message { get; }
    public string HelpLink { get; }
    public static DiagnosticMetadata CollectionShouldNotBeEmpty_AnyShouldBeTrue { get; }
    public static DiagnosticMetadata CollectionShouldBeEmpty_AnyShouldBeFalse { get; }
    public static DiagnosticMetadata CollectionShouldContainProperty_AnyWithLambdaShouldBeTrue { get; }
    public static DiagnosticMetadata CollectionShouldNotContainProperty_AnyLambdaShouldBeFalse { get; }
    public static DiagnosticMetadata CollectionShouldOnlyContainProperty_AllShouldBeTrue { get; }
    public static DiagnosticMetadata CollectionShouldContainItem_ContainsShouldBeTrue { get; }
    public static DiagnosticMetadata CollectionShouldNotContainItem_ContainsShouldBeFalse { get; }
    public static DiagnosticMetadata CollectionShouldHaveCount_CountShouldBe { get; }
    public static DiagnosticMetadata CollectionShouldHaveCount_LengthShouldBe { get; }
    public static DiagnosticMetadata CollectionShouldHaveCountGreaterThan_CountShouldBeGreaterThan { get; }
    public static DiagnosticMetadata CollectionShouldHaveCountGreaterOrEqualTo_CountShouldBeGreaterOrEqualTo { get; }
    public static DiagnosticMetadata CollectionShouldHaveCountLessThan_CountShouldBeLessThan { get; }
    public static DiagnosticMetadata CollectionShouldHaveCountLessOrEqualTo_CountShouldBeLessOrEqualTo { get; }
    public static DiagnosticMetadata CollectionShouldNotHaveCount_CountShouldNotBe { get; }
    public static DiagnosticMetadata CollectionShouldContainSingle_ShouldHaveCount1 { get; }
    public static DiagnosticMetadata CollectionShouldContainSingle_CountShouldBe1 { get; }
    public static DiagnosticMetadata CollectionShouldContainSingle_CountPropertyShouldBe1 { get; }
    public static DiagnosticMetadata CollectionShouldBeEmpty_ShouldHaveCount0 { get; }
    public static DiagnosticMetadata CollectionShouldBeEmpty_CountShouldBe0 { get; }
    public static DiagnosticMetadata CollectionShouldBeEmpty_CountPropertyShouldBe0 { get; }
    public static DiagnosticMetadata CollectionShouldHaveSameCount_ShouldHaveCountOtherCollectionCount { get; }
    public static DiagnosticMetadata CollectionShouldNotHaveSameCount_CountShouldNotBeOtherCollectionCount { get; }
    public static DiagnosticMetadata CollectionShouldContainProperty_WhereShouldNotBeEmpty { get; }
    public static DiagnosticMetadata CollectionShouldNotContainProperty_WhereShouldBeEmpty { get; }
    public static DiagnosticMetadata CollectionShouldContainSingle_WhereShouldHaveCount1 { get; }
    public static DiagnosticMetadata CollectionShouldNotContainProperty_ShouldOnlyContainNot { get; }
    public static DiagnosticMetadata CollectionShouldNotBeNullOrEmpty_ShouldNotBeNullAndNotBeEmpty { get; }
    public static DiagnosticMetadata CollectionShouldNotBeNullOrEmpty_ShouldNotBeEmptyAndNotBeNull { get; }
    public static DiagnosticMetadata CollectionShouldHaveElementAt_ElementAtIndexShouldBe { get; }
    public static DiagnosticMetadata CollectionShouldHaveElementAt_IndexerShouldBe { get; }
    public static DiagnosticMetadata CollectionShouldHaveElementAt_SkipFirstShouldBe { get; }
    public static DiagnosticMetadata CollectionShouldBeInAscendingOrder_OrderByShouldEqual { get; }
    public static DiagnosticMetadata CollectionShouldBeInDescendingOrder_OrderByDescendingShouldEqual { get; }
    public static DiagnosticMetadata CollectionShouldEqualOtherCollectionByComparer_SelectShouldEqualOtherCollectionSelect { get; }
    public static DiagnosticMetadata CollectionShouldNotIntersectWith_IntersectShouldBeEmpty { get; }
    public static DiagnosticMetadata CollectionShouldIntersectWith_IntersectShouldNotBeEmpty { get; }
    public static DiagnosticMetadata CollectionShouldNotContainNulls_SelectShouldNotContainNulls { get; }
    public static DiagnosticMetadata CollectionShouldOnlyHaveUniqueItems_ShouldHaveSameCountThisCollectionDistinct { get; }
    public static DiagnosticMetadata CollectionShouldOnlyHaveUniqueItemsByComparer_SelectShouldOnlyHaveUniqueItems { get; }
    public static DiagnosticMetadata NumericShouldBePositive_ShouldBeGreaterThan { get; }
    public static DiagnosticMetadata NumericShouldBeNegative_ShouldBeLessThan { get; }
    public static DiagnosticMetadata NumericShouldBeInRange_BeGreaterOrEqualToAndBeLessOrEqualTo { get; }
    public static DiagnosticMetadata NumericShouldBeInRange_BeLessOrEqualToAndBeGreaterOrEqualTo { get; }
    public static DiagnosticMetadata NumericShouldBeApproximately_MathAbsShouldBeLessOrEqualTo { get; }
    public static DiagnosticMetadata StringShouldStartWith_StartsWithShouldBeTrue { get; }
    public static DiagnosticMetadata StringShouldEndWith_EndsWithShouldBeTrue { get; }
    public static DiagnosticMetadata StringShouldNotBeNullOrEmpty_StringShouldNotBeNullAndNotBeEmpty { get; }
    public static DiagnosticMetadata StringShouldNotBeNullOrEmpty_StringShouldNotBeEmptyAndNotBeNull { get; }
    public static DiagnosticMetadata StringShouldBeNullOrEmpty_StringIsNullOrEmptyShouldBeTrue { get; }
    public static DiagnosticMetadata StringShouldNotBeNullOrEmpty_StringIsNullOrEmptyShouldBeFalse { get; }
    public static DiagnosticMetadata StringShouldBeNullOrWhiteSpace_StringIsNullOrWhiteSpaceShouldBeTrue { get; }
    public static DiagnosticMetadata StringShouldNotBeNullOrWhiteSpace_StringShouldNotBeNullOrWhiteSpace { get; }
    public static DiagnosticMetadata StringShouldHaveLength_LengthShouldBe { get; }
    private DiagnosticMetadata(string message, string helpLink, string name);
    private static DiagnosticMetadata();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_HelpLink();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotBeEmpty_AnyShouldBeTrue();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldBeEmpty_AnyShouldBeFalse();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldContainProperty_AnyWithLambdaShouldBeTrue();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotContainProperty_AnyLambdaShouldBeFalse();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldOnlyContainProperty_AllShouldBeTrue();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldContainItem_ContainsShouldBeTrue();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotContainItem_ContainsShouldBeFalse();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveCount_CountShouldBe();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveCount_LengthShouldBe();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveCountGreaterThan_CountShouldBeGreaterThan();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveCountGreaterOrEqualTo_CountShouldBeGreaterOrEqualTo();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveCountLessThan_CountShouldBeLessThan();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveCountLessOrEqualTo_CountShouldBeLessOrEqualTo();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotHaveCount_CountShouldNotBe();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldContainSingle_ShouldHaveCount1();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldContainSingle_CountShouldBe1();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldContainSingle_CountPropertyShouldBe1();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldBeEmpty_ShouldHaveCount0();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldBeEmpty_CountShouldBe0();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldBeEmpty_CountPropertyShouldBe0();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveSameCount_ShouldHaveCountOtherCollectionCount();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotHaveSameCount_CountShouldNotBeOtherCollectionCount();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldContainProperty_WhereShouldNotBeEmpty();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotContainProperty_WhereShouldBeEmpty();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldContainSingle_WhereShouldHaveCount1();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotContainProperty_ShouldOnlyContainNot();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotBeNullOrEmpty_ShouldNotBeNullAndNotBeEmpty();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotBeNullOrEmpty_ShouldNotBeEmptyAndNotBeNull();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveElementAt_ElementAtIndexShouldBe();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveElementAt_IndexerShouldBe();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldHaveElementAt_SkipFirstShouldBe();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldBeInAscendingOrder_OrderByShouldEqual();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldBeInDescendingOrder_OrderByDescendingShouldEqual();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldEqualOtherCollectionByComparer_SelectShouldEqualOtherCollectionSelect();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotIntersectWith_IntersectShouldBeEmpty();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldIntersectWith_IntersectShouldNotBeEmpty();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldNotContainNulls_SelectShouldNotContainNulls();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldOnlyHaveUniqueItems_ShouldHaveSameCountThisCollectionDistinct();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_CollectionShouldOnlyHaveUniqueItemsByComparer_SelectShouldOnlyHaveUniqueItems();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_NumericShouldBePositive_ShouldBeGreaterThan();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_NumericShouldBeNegative_ShouldBeLessThan();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_NumericShouldBeInRange_BeGreaterOrEqualToAndBeLessOrEqualTo();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_NumericShouldBeInRange_BeLessOrEqualToAndBeGreaterOrEqualTo();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_NumericShouldBeApproximately_MathAbsShouldBeLessOrEqualTo();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_StringShouldStartWith_StartsWithShouldBeTrue();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_StringShouldEndWith_EndsWithShouldBeTrue();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_StringShouldNotBeNullOrEmpty_StringShouldNotBeNullAndNotBeEmpty();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_StringShouldNotBeNullOrEmpty_StringShouldNotBeEmptyAndNotBeNull();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_StringShouldBeNullOrEmpty_StringIsNullOrEmptyShouldBeTrue();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_StringShouldNotBeNullOrEmpty_StringIsNullOrEmptyShouldBeFalse();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_StringShouldBeNullOrWhiteSpace_StringIsNullOrWhiteSpaceShouldBeTrue();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_StringShouldNotBeNullOrWhiteSpace_StringShouldNotBeNullOrWhiteSpace();
    [CompilerGeneratedAttribute]
public static DiagnosticMetadata get_StringShouldHaveLength_LengthShouldBe();
    private static string GetHelpLink(string id);
}
public class FluentAssertions.Analyzers.DocumentEditorUtils : object {
    public static Func`2<CancellationToken, Task`1<Document>> RenameMethodToSubjectShouldAssertion(IInvocationOperation invocation, CodeFixContext context, string newName, int subjectIndex, Int32[] argumentsToRemove);
    public static Func`2<CancellationToken, Task`1<Document>> RenameGenericMethodToSubjectShouldGenericAssertion(IInvocationOperation invocation, CodeFixContext context, string newName, int subjectIndex, Int32[] argumentsToRemove);
    public static Func`2<CancellationToken, Task`1<Document>> RenameMethodToSubjectShouldGenericAssertion(IInvocationOperation invocation, ImmutableArray`1<ITypeSymbol> genericTypes, CodeFixContext context, string newName, int subjectIndex, Int32[] argumentsToRemove);
    public static Func`2<CancellationToken, Task`1<Document>> RenameMethodToSubjectShouldAssertionWithOptionsLambda(IInvocationOperation invocation, CodeFixContext context, string newName, int subjectIndex, int optionsIndex);
    public static Func`2<CancellationToken, Task`1<Document>> RewriteExpression(IInvocationOperation invocation, Action`1[] actions, CodeFixContext context);
    [AsyncStateMachineAttribute("FluentAssertions.Analyzers.DocumentEditorUtils/<RewriteExpressionCore>d__5")]
private static Task`1<Document> RewriteExpressionCore(IInvocationOperation invocation, Action`1[] actions, CodeFixContext context, CancellationToken cancellationToken);
}
public static class FluentAssertions.Analyzers.EditAction : object {
    public static Action`1<EditActionContext> RemoveNode(SyntaxNode node);
    public static Action`1<EditActionContext> RemoveInvocationArgument(int argumentIndex);
    public static Action`1<EditActionContext> SubjectShouldAssertion(int argumentIndex, string assertion);
    public static Action`1<EditActionContext> ReplaceAssertionArgument(int index, Func`2<SyntaxGenerator, SyntaxNode> expressionFactory);
    public static Action`1<EditActionContext> SubjectShouldGenericAssertion(int argumentIndex, string assertion, ImmutableArray`1<ITypeSymbol> genericTypes);
    public static Action`1<EditActionContext> CreateEquivalencyAssertionOptionsLambda(int optionsIndex);
    public static Action`1<EditActionContext> AddArgumentToAssertionArguments(int index, Func`2<SyntaxGenerator, SyntaxNode> expressionFactory);
}
public class FluentAssertions.Analyzers.EditActionContext : object {
    [CompilerGeneratedAttribute]
private DocumentEditor <Editor>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <InvocationExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <FluentAssertion>k__BackingField;
    public DocumentEditor Editor { get; }
    public InvocationExpressionSyntax InvocationExpression { get; }
    public InvocationExpressionSyntax FluentAssertion { get; public set; }
    public EditActionContext(DocumentEditor editor, InvocationExpressionSyntax invocationExpression);
    [CompilerGeneratedAttribute]
public DocumentEditor get_Editor();
    [CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_InvocationExpression();
    [CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_FluentAssertion();
    [CompilerGeneratedAttribute]
public void set_FluentAssertion(InvocationExpressionSyntax value);
}
public class FluentAssertions.Analyzers.FluentAssertionEditActionContext : ValueType {
    [CompilerGeneratedAttribute]
private IInvocationOperation <Assertion>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <AssertionExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IInvocationOperation <Should>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private IInvocationOperation <InvocationBeforeShould>k__BackingField;
    public IInvocationOperation Assertion { get; public set; }
    public InvocationExpressionSyntax AssertionExpression { get; public set; }
    public IInvocationOperation Should { get; public set; }
    public IOperation Subject { get; public set; }
    public IInvocationOperation InvocationBeforeShould { get; public set; }
    public FluentAssertionEditActionContext(IInvocationOperation Assertion, InvocationExpressionSyntax AssertionExpression, IInvocationOperation Should, IOperation Subject, IInvocationOperation InvocationBeforeShould);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IInvocationOperation get_Assertion();
    [CompilerGeneratedAttribute]
public void set_Assertion(IInvocationOperation value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_AssertionExpression();
    [CompilerGeneratedAttribute]
public void set_AssertionExpression(InvocationExpressionSyntax value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IInvocationOperation get_Should();
    [CompilerGeneratedAttribute]
public void set_Should(IInvocationOperation value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IOperation get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(IOperation value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IInvocationOperation get_InvocationBeforeShould();
    [CompilerGeneratedAttribute]
public void set_InvocationBeforeShould(IInvocationOperation value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FluentAssertionEditActionContext left, FluentAssertionEditActionContext right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FluentAssertionEditActionContext left, FluentAssertionEditActionContext right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FluentAssertionEditActionContext other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(IInvocationOperation& Assertion, InvocationExpressionSyntax& AssertionExpression, IInvocationOperation& Should, IOperation& Subject, IInvocationOperation& InvocationBeforeShould);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class FluentAssertions.Analyzers.FluentAssertionsAnalyzer : DiagnosticAnalyzer {
    public static string Title;
    public static string DiagnosticId;
    public static string Message;
    protected static DiagnosticDescriptor Rule;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FluentAssertionsAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInvocation(OperationAnalysisContext context, FluentAssertionsMetadata metadata);
    private static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticMetadata metadata);
    private static bool IsEnumerableMethodWithoutArguments(IInvocationOperation invocation, FluentAssertionsMetadata metadata);
    private static bool IsEnumerableMethodWithPredicate(IInvocationOperation invocation, FluentAssertionsMetadata metadata);
    private static bool TryGetExceptionPropertyAssertion(IInvocationOperation assertion, String& fluentAssertionProperty, String& exceptionProperty, IInvocationOperation& nextAssertion);
    private static bool HasConditionalAccessAncestor(IInvocationOperation invocation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class FluentAssertions.Analyzers.FluentAssertionsCodeFixProvider : CodeFixProviderBase`1<EmptyTestContext> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    protected string Title { get; }
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected virtual string get_Title();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Func`2<CancellationToken, Task`1<Document>> TryComputeFix(IInvocationOperation assertion, CodeFixContext context, EmptyTestContext t, Diagnostic diagnostic);
    protected virtual EmptyTestContext CreateTestContext(SemanticModel semanticModel);
    private static Func`2<CancellationToken, Task`1<Document>> RewriteFluentAssertion(IInvocationOperation assertion, CodeFixContext context, Action`2[] actions);
    private static Func`2<CancellationToken, Task`1<Document>> RewriteFluentChainedAssertion(IInvocationOperation assertionB, CodeFixContext context, Action`2[] actions);
    private Func`2<CancellationToken, Task`1<Document>> ReplaceShouldThrowWithInnerException(IInvocationOperation assertion, CodeFixContext context, string newName);
    private Func`2<CancellationToken, Task`1<Document>> ReplaceShouldThrowWithMessage(IInvocationOperation assertion, CodeFixContext context, string prefix, string postfix);
    [CompilerGeneratedAttribute]
internal static Func`2<CancellationToken, Task`1<Document>> <TryComputeFix>g__RemoveExpressionBeforeShouldAndRenameAssertion|5_0(string newName, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static Func`2<CancellationToken, Task`1<Document>> <TryComputeFix>g__RenameAssertionAndRemoveFirstAssertionArgument|5_1(string newName, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static Func`2<CancellationToken, Task`1<Document>> <TryComputeFix>g__RemoveMethodBeforeShouldAndRenameAssertionWithArgumentsFromRemoved|5_2(string newName, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static Func`2<CancellationToken, Task`1<Document>> <TryComputeFix>g__RemoveMethodBeforeShouldAndRenameAssertionWithoutFirstArgumentWithArgumentsFromRemoved|5_3(string newName, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static Func`2<CancellationToken, Task`1<Document>> <TryComputeFix>g__RemoveExpressionBeforeShouldAndRenameAssertionWithoutFirstArgumentWithArgumentsFromRemoved|5_4(string newName, <>c__DisplayClass5_0& );
}
public static class FluentAssertions.Analyzers.FluentAssertionsEditAction : object {
    public static Action`2<DocumentEditor, FluentAssertionEditActionContext> RenameAssertion(string newName);
    public static Action`2<DocumentEditor, FluentAssertionEditActionContext> SkipInvocationBeforeShould();
    public static Action`2<DocumentEditor, FluentAssertionEditActionContext> SkipExpressionBeforeShould();
    public static Action`2<DocumentEditor, FluentAssertionEditActionContext> RemoveAssertionArgument(int index);
    public static Action`2<DocumentEditor, FluentAssertionEditActionContext> PrependArgumentsFromInvocationBeforeShouldToAssertion(int skipAssertionArguments);
    public static Action`2<DocumentEditor, FluentAssertionEditActionContext> RemoveInvocationOnAssertionArgument(int assertionArgumentIndex, int invocationArgumentIndex);
    public static Action`2<DocumentEditor, FluentAssertionEditActionContext> UnwrapInvocationOnSubject(int argumentIndex);
}
public static class FluentAssertions.Analyzers.FluentChainedAssertionEditAction : object {
    public static Action`2<DocumentEditor, FluentChainedAssertionEditActionContext> CombineAssertionsWithNameAndArguments(string newName, CombineAssertionArgumentsStrategy strategy);
    public static Action`2<DocumentEditor, FluentChainedAssertionEditActionContext> CombineAssertionsWithName(string newName, Func`3<DocumentEditor, FluentChainedAssertionEditActionContext, ArgumentListSyntax> argumentsGenerator);
}
public class FluentAssertions.Analyzers.FluentChainedAssertionEditActionContext : ValueType {
    [CompilerGeneratedAttribute]
private IInvocationOperation <AssertionA>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <AssertionAExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertyReferenceOperation <AndOrWhich>k__BackingField;
    [CompilerGeneratedAttribute]
private IInvocationOperation <AssertionB>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <AssertionBExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IInvocationOperation <Should>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Subject>k__BackingField;
    public IInvocationOperation AssertionA { get; public set; }
    public InvocationExpressionSyntax AssertionAExpression { get; public set; }
    public IPropertyReferenceOperation AndOrWhich { get; public set; }
    public IInvocationOperation AssertionB { get; public set; }
    public InvocationExpressionSyntax AssertionBExpression { get; public set; }
    public IInvocationOperation Should { get; public set; }
    public IOperation Subject { get; public set; }
    public FluentChainedAssertionEditActionContext(IInvocationOperation AssertionA, InvocationExpressionSyntax AssertionAExpression, IPropertyReferenceOperation AndOrWhich, IInvocationOperation AssertionB, InvocationExpressionSyntax AssertionBExpression, IInvocationOperation Should, IOperation Subject);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IInvocationOperation get_AssertionA();
    [CompilerGeneratedAttribute]
public void set_AssertionA(IInvocationOperation value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_AssertionAExpression();
    [CompilerGeneratedAttribute]
public void set_AssertionAExpression(InvocationExpressionSyntax value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IPropertyReferenceOperation get_AndOrWhich();
    [CompilerGeneratedAttribute]
public void set_AndOrWhich(IPropertyReferenceOperation value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IInvocationOperation get_AssertionB();
    [CompilerGeneratedAttribute]
public void set_AssertionB(IInvocationOperation value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public InvocationExpressionSyntax get_AssertionBExpression();
    [CompilerGeneratedAttribute]
public void set_AssertionBExpression(InvocationExpressionSyntax value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IInvocationOperation get_Should();
    [CompilerGeneratedAttribute]
public void set_Should(IInvocationOperation value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IOperation get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(IOperation value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FluentChainedAssertionEditActionContext left, FluentChainedAssertionEditActionContext right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FluentChainedAssertionEditActionContext left, FluentChainedAssertionEditActionContext right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FluentChainedAssertionEditActionContext other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(IInvocationOperation& AssertionA, InvocationExpressionSyntax& AssertionAExpression, IPropertyReferenceOperation& AndOrWhich, IInvocationOperation& AssertionB, InvocationExpressionSyntax& AssertionBExpression, IInvocationOperation& Should, IOperation& Subject);
}
public interface FluentAssertions.Analyzers.IEditAction {
    public abstract virtual void Apply(DocumentEditor editor, InvocationExpressionSyntax invocationExpression);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class FluentAssertions.Analyzers.MsTestCodeFixProvider : TestingFrameworkCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Func`2<CancellationToken, Task`1<Document>> TryComputeFixCore(IInvocationOperation invocation, CodeFixContext context, TestingFrameworkCodeFixContext t, Diagnostic diagnostic);
    private Func`2<CancellationToken, Task`1<Document>> TryComputeFixForAssert(IInvocationOperation invocation, CodeFixContext context, TestingFrameworkCodeFixContext t);
    private Func`2<CancellationToken, Task`1<Document>> TryComputeFixForStringAssert(IInvocationOperation invocation, CodeFixContext context, TestingFrameworkCodeFixContext t);
    private Func`2<CancellationToken, Task`1<Document>> TryComputeFixForCollectionAssert(IInvocationOperation invocation, CodeFixContext context, TestingFrameworkCodeFixContext t);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class FluentAssertions.Analyzers.NunitCodeFixProvider : TestingFrameworkCodeFixProvider`1<NunitCodeFixContext> {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual NunitCodeFixContext CreateTestContext(SemanticModel semanticModel);
    protected virtual Func`2<CancellationToken, Task`1<Document>> TryComputeFixCore(IInvocationOperation invocation, CodeFixContext context, NunitCodeFixContext t, Diagnostic diagnostic);
    private Func`2<CancellationToken, Task`1<Document>> TryComputeFixForNunitClassicAssert(IInvocationOperation invocation, CodeFixContext context, NunitCodeFixContext t);
    private Func`2<CancellationToken, Task`1<Document>> TryComputeFixForCollectionAssert(IInvocationOperation invocation, CodeFixContext context, NunitCodeFixContext t);
    private Func`2<CancellationToken, Task`1<Document>> TryComputeFixForNunitThat(IInvocationOperation invocation, CodeFixContext context, NunitCodeFixContext t);
    private Func`2<CancellationToken, Task`1<Document>> RewriteContainsAssertion(IInvocationOperation invocation, CodeFixContext context, string assertion, IArgumentOperation subject, IArgumentOperation expectation);
    private static MethodInvocationMatcher Method(string name);
    private static GenericMethodInvocationMatcher GenericMethod(string name);
    private static PropertyReferenceMatcher Property(string name);
    private static bool IsArgumentTypeOfNonGenericEnumerable(IInvocationOperation invocation, int argumentIndex);
    private static bool IsArgumentTypeOf(IInvocationOperation invocation, int argumentIndex, SpecialType type);
    private static bool IsArgumentTypeOf(IInvocationOperation invocation, int argumentIndex, INamedTypeSymbol type);
}
[ExtensionAttribute]
internal static class FluentAssertions.Analyzers.OperartionExtensions : object {
    [ExtensionAttribute]
public static bool TryGetFirstDescendent(IOperation parent, TOperation& operation);
    [ExtensionAttribute]
public static TOperation GetFirstDescendent(IOperation parent);
    [ExtensionAttribute]
public static TOperation GetFirstAncestor(IOperation parent);
    [ExtensionAttribute]
public static bool HasFirstDescendentInvocation(IOperation parent, string invocationMethod);
    [ExtensionAttribute]
public static bool IsContainedInType(IPropertyReferenceOperation property, SpecialType type);
    [ExtensionAttribute]
public static bool IsContainedInType(IPropertyReferenceOperation property, INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool IsContainedInType(IInvocationOperation invocation, SpecialType type);
    [ExtensionAttribute]
public static bool IsContainedInType(IInvocationOperation invocation, INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool ImplementsOrIsInterface(IPropertyReferenceOperation property, SpecialType type);
    [ExtensionAttribute]
public static bool ImplementsOrIsInterface(IInvocationOperation invocation, SpecialType type);
    [ExtensionAttribute]
public static bool ImplementsOrIsInterface(IInvocationOperation invocation, INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool ImplementsOrIsInterface(IArgumentOperation argument, SpecialType type);
    [ExtensionAttribute]
public static bool ImplementsOrIsInterface(IArgumentOperation argument, INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool IsTypeof(IArgumentOperation argument, SpecialType type);
    [ExtensionAttribute]
public static bool IsTypeof(IArgumentOperation argument, INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool IsSameArgumentReference(IArgumentOperation argument1, IArgumentOperation argument2);
    [ExtensionAttribute]
public static bool IsSamePropertyReference(IPropertyReferenceOperation property1, IPropertyReferenceOperation property2);
    [ExtensionAttribute]
public static bool IsStaticPropertyReference(IArgumentOperation argument, INamedTypeSymbol type, string property);
    [ExtensionAttribute]
public static bool IsLiteralValue(IArgumentOperation argument);
    [ExtensionAttribute]
public static bool IsLiteralValue(IArgumentOperation argument, T value);
    [ExtensionAttribute]
public static bool IsLiteralNull(IArgumentOperation argument);
    [ExtensionAttribute]
public static bool IsLiteralValue(IArgumentOperation argument);
    [ExtensionAttribute]
public static bool TryGetLiteralValue(IArgumentOperation argument, T& value);
    [ExtensionAttribute]
public static bool IsReference(IArgumentOperation argument);
    [ExtensionAttribute]
public static bool IsReferenceOfType(IArgumentOperation argument, SpecialType type);
    [ExtensionAttribute]
public static bool IsLambda(IArgumentOperation argument);
    [ExtensionAttribute]
public static bool HasEmptyBecauseAndReasonArgs(IInvocationOperation invocation, int startingIndex);
    [ExtensionAttribute]
public static bool TryGetChainedInvocationAfterAndConstraint(IInvocationOperation invocation, string chainedMethod, IInvocationOperation& chainedInvocation);
    [ExtensionAttribute]
public static IOperation UnwrapConversion(IOperation operation);
    [ExtensionAttribute]
public static IOperation UnwrapParentConversion(IOperation operation);
}
public class FluentAssertions.Analyzers.SkipInvocationNodeAction : object {
    [CompilerGeneratedAttribute]
private InvocationExpressionSyntax <skipInvocation>P;
    public SkipInvocationNodeAction(InvocationExpressionSyntax skipInvocation);
    public sealed virtual void Apply(DocumentEditor editor, InvocationExpressionSyntax invocationExpression);
}
public class FluentAssertions.Analyzers.SkipMemberAccessNodeAction : object {
    [CompilerGeneratedAttribute]
private MemberAccessExpressionSyntax <skipMemberAccess>P;
    public SkipMemberAccessNodeAction(MemberAccessExpressionSyntax skipMemberAccess);
    public sealed virtual void Apply(DocumentEditor editor, InvocationExpressionSyntax invocationExpression);
}
public class FluentAssertions.Analyzers.SubjectShouldAssertionAction : object {
    private int _argumentIndex;
    protected string _assertion;
    public SubjectShouldAssertionAction(int argumentIndex, string assertion);
    public void Apply(EditActionContext context);
    protected virtual SyntaxNode GenerateAssertion(SyntaxGenerator generator);
}
public class FluentAssertions.Analyzers.SubjectShouldGenericAssertionAction : SubjectShouldAssertionAction {
    private ImmutableArray`1<ITypeSymbol> _types;
    public SubjectShouldGenericAssertionAction(int argumentIndex, string assertion, ImmutableArray`1<ITypeSymbol> types);
    protected virtual SyntaxNode GenerateAssertion(SyntaxGenerator generator);
}
public abstract class FluentAssertions.Analyzers.TestingFrameworkCodeFixProvider : TestingFrameworkCodeFixProvider`1<TestingFrameworkCodeFixContext> {
    protected virtual TestingFrameworkCodeFixContext CreateTestContext(SemanticModel semanticModel);
}
public abstract class FluentAssertions.Analyzers.TestingFrameworkCodeFixProvider`1 : CodeFixProviderBase`1<TTestContext> {
    protected string Title { get; }
    protected virtual string get_Title();
    protected virtual Func`2<CancellationToken, Task`1<Document>> TryComputeFix(IInvocationOperation invocation, CodeFixContext context, TTestContext t, Diagnostic diagnostic);
    protected abstract virtual Func`2<CancellationToken, Task`1<Document>> TryComputeFixCore(IInvocationOperation invocation, CodeFixContext context, TTestContext t, Diagnostic diagnostic);
    protected static bool ArgumentsAreTypeOf(IInvocationOperation invocation, ITypeSymbol[] types);
    protected static bool ArgumentsAreTypeOf(IInvocationOperation invocation, int startFromIndex, ITypeSymbol[] types);
    protected static bool ArgumentsAreGenericTypeOf(IInvocationOperation invocation, ITypeSymbol[] types);
    protected static bool ArgumentsCount(IInvocationOperation invocation, int arguments);
}
[ExtensionAttribute]
internal static class FluentAssertions.Analyzers.Utilities.TypesExtensions : object {
    [ExtensionAttribute]
public static bool IsTypeOrConstructedFromTypeOrImplementsType(INamedTypeSymbol type, INamedTypeSymbol other);
    [ExtensionAttribute]
public static bool IsTypeOrConstructedFromTypeOrImplementsType(ITypeSymbol type, SpecialType specialType);
    [ExtensionAttribute]
public static bool ConstructedFromType(INamedTypeSymbol type, INamedTypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool ConstructedFromType(INamedTypeSymbol type, SpecialType specialType);
    [ExtensionAttribute]
public static bool ImplementsOrIsInterface(ITypeSymbol type, INamedTypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool ImplementsOrIsInterface(ITypeSymbol type, SpecialType specialType);
    [ExtensionAttribute]
public static bool IsOrInheritsFrom(ITypeSymbol symbol, INamedTypeSymbol baseSymbol);
    [ExtensionAttribute]
public static bool EqualsSymbol(ISymbol type, ISymbol other);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class FluentAssertions.Analyzers.XunitCodeFixProvider : TestingFrameworkCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Func`2<CancellationToken, Task`1<Document>> TryComputeFixCore(IInvocationOperation invocation, CodeFixContext context, TestingFrameworkCodeFixContext t, Diagnostic diagnostic);
    [CompilerGeneratedAttribute]
internal static Func`2<CancellationToken, Task`1<Document>> <TryComputeFixCore>g__RewriteThrowArgumentExceptionAssertion|2_0(string newName, <>c__DisplayClass2_0& );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
