public class FluentAssertions.AggregateExceptionExtractor : object {
    public sealed virtual IEnumerable`1<T> OfType(Exception actualException);
    private static List`1<T> GetExtractedExceptions(Exception actualException);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.AndConstraint`1 : object {
    [CompilerGeneratedAttribute]
private T <And>k__BackingField;
    public T And { get; }
    public AndConstraint`1(T parentConstraint);
    [CompilerGeneratedAttribute]
public T get_And();
}
public class FluentAssertions.AndWhichConstraint`2 : AndConstraint`1<TParentConstraint> {
    private Lazy`1<TMatchedElement> matchedConstraint;
    public TMatchedElement Which { get; }
    public TMatchedElement Subject { get; }
    public AndWhichConstraint`2(TParentConstraint parentConstraint, TMatchedElement matchedConstraint);
    public AndWhichConstraint`2(TParentConstraint parentConstraint, IEnumerable`1<TMatchedElement> matchedConstraint);
    private static TMatchedElement SingleOrDefault(IEnumerable`1<TMatchedElement> matchedConstraint);
    public TMatchedElement get_Which();
    public TMatchedElement get_Subject();
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.AssertionExtensions : object {
    private static AggregateExceptionExtractor extractor;
    private static AssertionExtensions();
    [ExtensionAttribute]
[PureAttribute]
public static Action Invoking(T subject, Action`1<T> action);
    [ExtensionAttribute]
[PureAttribute]
public static Func`1<TResult> Invoking(T subject, Func`2<T, TResult> action);
    [ExtensionAttribute]
[PureAttribute]
public static Func`1<Task> Awaiting(T subject, Func`2<T, Task> action);
    [ExtensionAttribute]
[PureAttribute]
public static Func`1<Task`1<TResult>> Awaiting(T subject, Func`2<T, Task`1<TResult>> action);
    [ExtensionAttribute]
[PureAttribute]
public static Func`1<Task`1<TResult>> Awaiting(T subject, Func`2<T, ValueTask`1<TResult>> action);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static MemberExecutionTime`1<T> ExecutionTimeOf(T subject, Expression`1<Action`1<T>> action);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static ExecutionTime ExecutionTime(Action action);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
public static ExecutionTime ExecutionTime(Func`1<Task> action);
    [ExtensionAttribute]
[PureAttribute]
public static ExecutionTimeAssertions Should(ExecutionTime executionTime);
    [ExtensionAttribute]
[PureAttribute]
public static AssemblyAssertions Should(Assembly assembly);
    [ExtensionAttribute]
[PureAttribute]
public static XDocumentAssertions Should(XDocument actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static XElementAssertions Should(XElement actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static XAttributeAssertions Should(XAttribute actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static Action Enumerating(Func`1<IEnumerable> enumerable);
    [ExtensionAttribute]
[PureAttribute]
public static Action Enumerating(Func`1<IEnumerable`1<T>> enumerable);
    private static void ForceEnumeration(Func`1<IEnumerable> enumerable);
    [ExtensionAttribute]
[PureAttribute]
public static ObjectAssertions Should(object actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static BooleanAssertions Should(bool actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableBooleanAssertions Should(Nullable`1<bool> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static GuidAssertions Should(Guid actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableGuidAssertions Should(Nullable`1<Guid> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NonGenericCollectionAssertions Should(IEnumerable actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static GenericCollectionAssertions`1<T> Should(IEnumerable`1<T> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static StringCollectionAssertions Should(IEnumerable`1<string> this);
    [ExtensionAttribute]
[PureAttribute]
public static GenericDictionaryAssertions`2<TKey, TValue> Should(IDictionary`2<TKey, TValue> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static DateTimeAssertions Should(DateTime actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static DateTimeOffsetAssertions Should(DateTimeOffset actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableDateTimeAssertions Should(Nullable`1<DateTime> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableDateTimeOffsetAssertions Should(Nullable`1<DateTimeOffset> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static ComparableTypeAssertions`1<T> Should(IComparable`1<T> comparableValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<int> Should(int actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<int> Should(Nullable`1<int> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<UInt32> Should(UInt32 actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<UInt32> Should(Nullable`1<UInt32> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<decimal> Should(decimal actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<decimal> Should(Nullable`1<decimal> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<byte> Should(byte actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<byte> Should(Nullable`1<byte> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<sbyte> Should(sbyte actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<sbyte> Should(Nullable`1<sbyte> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<short> Should(short actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<short> Should(Nullable`1<short> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<ushort> Should(ushort actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<ushort> Should(Nullable`1<ushort> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<long> Should(long actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<long> Should(Nullable`1<long> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<ulong> Should(ulong actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<ulong> Should(Nullable`1<ulong> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<float> Should(float actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<float> Should(Nullable`1<float> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NumericAssertions`1<double> Should(double actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableNumericAssertions`1<double> Should(Nullable`1<double> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static StringAssertions Should(string actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static SimpleTimeSpanAssertions Should(TimeSpan actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static NullableSimpleTimeSpanAssertions Should(Nullable`1<TimeSpan> actualValue);
    [ExtensionAttribute]
[PureAttribute]
public static TypeAssertions Should(Type subject);
    [ExtensionAttribute]
[PureAttribute]
public static TypeSelectorAssertions Should(TypeSelector typeSelector);
    [ExtensionAttribute]
[PureAttribute]
public static ConstructorInfoAssertions Should(ConstructorInfo constructorInfo);
    [ExtensionAttribute]
[PureAttribute]
public static MethodInfoAssertions Should(MethodInfo methodInfo);
    [ExtensionAttribute]
[PureAttribute]
public static MethodInfoSelectorAssertions Should(MethodInfoSelector methodSelector);
    [ExtensionAttribute]
[PureAttribute]
public static PropertyInfoAssertions Should(PropertyInfo propertyInfo);
    [ExtensionAttribute]
[PureAttribute]
public static PropertyInfoSelectorAssertions Should(PropertyInfoSelector propertyInfoSelector);
    [ExtensionAttribute]
[PureAttribute]
public static ActionAssertions Should(Action action);
    [ExtensionAttribute]
[PureAttribute]
public static NonGenericAsyncFunctionAssertions Should(Func`1<Task> action);
    [ExtensionAttribute]
[PureAttribute]
public static GenericAsyncFunctionAssertions`1<T> Should(Func`1<Task`1<T>> action);
    [ExtensionAttribute]
[PureAttribute]
public static FunctionAssertions`1<T> Should(Func`1<T> func);
    [ExtensionAttribute]
public static IMonitor`1<T> Monitor(T eventSource, Func`1<DateTime> utcNow);
    [ExtensionAttribute]
[PureAttribute]
public static TTo As(object subject);
    [AsyncStateMachineAttribute("FluentAssertions.AssertionExtensions/<WithMessage>d__69`1")]
[ExtensionAttribute]
public static Task`1<ExceptionAssertions`1<TException>> WithMessage(Task`1<ExceptionAssertions`1<TException>> task, string expectedWildcardPattern, string because, Object[] becauseArgs);
}
public static class FluentAssertions.AssertionOptions : object {
    private static EquivalencyAssertionOptions defaults;
    [CompilerGeneratedAttribute]
private static EquivalencyStepCollection <EquivalencySteps>k__BackingField;
    public static EquivalencyStepCollection EquivalencySteps { get; private set; }
    private static AssertionOptions();
    public static EquivalencyAssertionOptions`1<T> CloneDefaults();
    public static void AssertEquivalencyUsing(Func`2<EquivalencyAssertionOptions, EquivalencyAssertionOptions> defaultsConfigurer);
    [CompilerGeneratedAttribute]
public static EquivalencyStepCollection get_EquivalencySteps();
    [CompilerGeneratedAttribute]
private static void set_EquivalencySteps(EquivalencyStepCollection value);
}
public static class FluentAssertions.AtLeast : object {
    public static OccurrenceConstraint Once();
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
public static class FluentAssertions.AtMost : object {
    public static OccurrenceConstraint Once();
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
public static class FluentAssertions.CallerIdentifier : object {
    public static Action`1<string> logger;
    private static CallerIdentifier();
    public static string DetermineCallerIdentity();
    private static bool IsCustomAssertion(StackFrame frame);
    private static bool IsDynamic(StackFrame frame);
    private static bool IsCurrentAssembly(StackFrame frame);
    private static bool IsDotNet(StackFrame frame);
    private static string ExtractVariableNameFrom(StackFrame frame);
    private static string GetSourceCodeLineFrom(StackFrame frame);
    private static bool UsesNewKeyword(string candidate);
    private static bool IsStringLiteral(string candidate);
    private static bool IsNumeric(string candidate);
    private static bool IsBooleanLiteral(string candidate);
}
public abstract class FluentAssertions.Collections.CollectionAssertions`2 : ReferenceTypeAssertions`2<TSubject, TAssertions> {
    protected string Identifier { get; }
    protected CollectionAssertions`2(TSubject subject);
    public AndConstraint`1<TAssertions> BeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNullOrEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNullOrEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> OnlyHaveUniqueItems(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainNulls(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Equal(Object[] elements);
    public AndConstraint`1<TAssertions> Equal(IEnumerable expected, string because, Object[] becauseArgs);
    protected void AssertSubjectEquality(IEnumerable expectation, Func`3<TActual, TExpected, bool> equalityComparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotEqual(IEnumerable unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(IEnumerable`1<TExpectation> expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(Object[] expectations);
    public AndConstraint`1<TAssertions> BeEquivalentTo(IEnumerable expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(IEnumerable expectation, Func`2<EquivalencyAssertionOptions`1<IEnumerable>, EquivalencyAssertionOptions`1<IEnumerable>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(IEnumerable`1<TExpectation> expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEquivalentTo(IEnumerable unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainEquivalentOf(TExpectation expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainEquivalentOf(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainItemsAssignableTo(string because, Object[] becauseArgs);
    private static List`1<T> GetMissingItems(IEnumerable`1<T> expectedItems, IEnumerable`1<T> actualItems);
    public AndConstraint`1<TAssertions> Contain(IEnumerable expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainInOrder(Object[] expected);
    public AndConstraint`1<TAssertions> ContainInOrder(IEnumerable expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeInAscendingOrder(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeInAscendingOrder(IComparer`1<object> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeInDescendingOrder(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeInDescendingOrder(IComparer`1<object> comparer, string because, Object[] becauseArgs);
    private AndConstraint`1<TAssertions> BeInOrder(IComparer`1<object> comparer, SortOrder expectedOrder, string because, Object[] becauseArgs);
    [ObsoleteAttribute("Use NotBeInAscendingOrder instead")]
[EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> NotBeAscendingInOrder(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInAscendingOrder(string because, Object[] becauseArgs);
    [ObsoleteAttribute("Use NotBeInAscendingOrder instead")]
[EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> NotBeAscendingInOrder(IComparer`1<object> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInAscendingOrder(IComparer`1<object> comparer, string because, Object[] becauseArgs);
    [ObsoleteAttribute("Use NotBeInDescendingOrder instead")]
[EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> NotBeDescendingInOrder(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInDescendingOrder(string because, Object[] becauseArgs);
    [ObsoleteAttribute("Use NotBeInDescendingOrder instead")]
[EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> NotBeDescendingInOrder(IComparer`1<object> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInDescendingOrder(IComparer`1<object> comparer, string because, Object[] becauseArgs);
    private AndConstraint`1<TAssertions> NotBeInOrder(IComparer`1<object> comparer, SortOrder order, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeSubsetOf(IEnumerable expectedSuperset, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeSubsetOf(IEnumerable unexpectedSuperset, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveSameCount(IEnumerable otherCollection, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveSameCount(IEnumerable otherCollection, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, object> HaveElementAt(int index, object element, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContain(IEnumerable unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> IntersectWith(IEnumerable otherCollection, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotIntersectWith(IEnumerable otherCollection, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> StartWith(object element, string because, Object[] becauseArgs);
    protected void AssertCollectionStartsWith(IEnumerable`1<TActual> actualItems, TExpected[] expected, Func`3<TActual, TExpected, bool> equalityComparison, string because, Object[] becauseArgs);
    protected void AssertCollectionStartsWith(IEnumerable`1<TActual> actualItems, ICollection`1<TExpected> expected, Func`3<TActual, TExpected, bool> equalityComparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> EndWith(object element, string because, Object[] becauseArgs);
    protected void AssertCollectionEndsWith(IEnumerable`1<TActual> actual, TExpected[] expected, Func`3<TActual, TExpected, bool> equalityComparison, string because, Object[] becauseArgs);
    protected void AssertCollectionEndsWith(IEnumerable`1<TActual> actual, ICollection`1<TExpected> expected, Func`3<TActual, TExpected, bool> equalityComparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveElementPreceding(object successor, object expectation, string because, Object[] becauseArgs);
    private bool HasPredecessor(object successor, IEnumerable`1<object> subject);
    private object PredecessorOf(object successor, IEnumerable`1<object> subject);
    public AndConstraint`1<TAssertions> HaveElementSucceeding(object predecessor, object expectation, string because, Object[] becauseArgs);
    private bool HasSuccessor(object predecessor, IEnumerable`1<object> subject);
    private object SuccessorOf(object predecessor, IEnumerable`1<object> subject);
    public AndConstraint`1<TAssertions> AllBeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllBeAssignableTo(Type expectedType, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllBeOfType(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllBeOfType(Type expectedType, string because, Object[] becauseArgs);
    private static Type GetType(object o);
    protected virtual string get_Identifier();
    [CompilerGeneratedAttribute]
private IEnumerable`1<object> <BeEmpty>b__2_0();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.GenericCollectionAssertions`1 : SelfReferencingCollectionAssertions`2<T, GenericCollectionAssertions`1<T>> {
    public GenericCollectionAssertions`1(IEnumerable`1<T> actualValue);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> NotContainNulls(Expression`1<Func`2<T, TKey>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> OnlyHaveUniqueItems(Expression`1<Func`2<T, TKey>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> BeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> NotBeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> BeInAscendingOrder(IComparer`1<T> comparer, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> NotBeInAscendingOrder(IComparer`1<T> comparer, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> BeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> NotBeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> BeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> NotBeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> BeInDescendingOrder(IComparer`1<T> comparer, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> NotBeInDescendingOrder(IComparer`1<T> comparer, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> BeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] args);
    public AndConstraint`1<GenericCollectionAssertions`1<T>> NotBeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] args);
    private AndConstraint`1<GenericCollectionAssertions`1<T>> BeOrderedBy(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, SortOrder direction, string because, Object[] args);
    private AndConstraint`1<GenericCollectionAssertions`1<T>> NotBeOrderedBy(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, SortOrder direction, string because, Object[] args);
    private bool IsValidProperty(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] args);
    private IOrderedEnumerable`1<T> ConvertToOrderedEnumerable(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, SortOrder direction, ICollection`1<T> unordered);
    private string GetExpressionOrderString(Expression`1<Func`2<T, TSelector>> propertyExpression);
    public void AllBeEquivalentTo(TExpectation expectation, string because, Object[] becauseArgs);
    public void AllBeEquivalentTo(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    private static IEnumerable`1<TExpectation> RepeatAsManyAs(TExpectation value, IEnumerable`1<T> enumerable);
    [IteratorStateMachineAttribute("FluentAssertions.Collections.GenericCollectionAssertions`1/<RepeatAsManyAsIterator>d__23`1")]
private static IEnumerable`1<TExpectation> RepeatAsManyAsIterator(TExpectation value, IEnumerable`1<T> enumerable);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.GenericDictionaryAssertions`2 : ReferenceTypeAssertions`2<IDictionary`2<TKey, TValue>, GenericDictionaryAssertions`2<TKey, TValue>> {
    protected string Identifier { get; }
    public GenericDictionaryAssertions`2(IDictionary`2<TKey, TValue> dictionary);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> HaveCount(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotHaveCount(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> HaveCountGreaterThan(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> HaveCountGreaterOrEqualTo(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> HaveCountLessThan(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> HaveCountLessOrEqualTo(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> HaveCount(Expression`1<Func`2<int, bool>> countPredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> HaveSameCount(IEnumerable otherCollection, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotHaveSameCount(IEnumerable otherCollection, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> BeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotBeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> Equal(IDictionary`2<TKey, TValue> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotEqual(IDictionary`2<TKey, TValue> unexpected, string because, Object[] becauseArgs);
    public void BeEquivalentTo(TExpectation expectation, string because, Object[] becauseArgs);
    public void BeEquivalentTo(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public WhichValueConstraint`2<TKey, TValue> ContainKey(TKey expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> ContainKeys(TKey[] expected);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> ContainKeys(IEnumerable`1<TKey> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContainKey(TKey unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContainKeys(TKey[] unexpected);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContainKeys(IEnumerable`1<TKey> unexpected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<GenericDictionaryAssertions`2<TKey, TValue>, TValue> ContainValue(TValue expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> ContainValues(TValue[] expected);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> ContainValues(IEnumerable`1<TValue> expected, string because, Object[] becauseArgs);
    private AndWhichConstraint`2<GenericDictionaryAssertions`2<TKey, TValue>, IEnumerable`1<TValue>> ContainValuesAndWhich(IEnumerable`1<TValue> expected, string because, Object[] becauseArgs);
    private static IEnumerable`1<TValue> RepetitionPreservingIntersect(IEnumerable`1<TValue> first, IEnumerable`1<TValue> second);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContainValue(TValue unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContainValues(TValue[] unexpected);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContainValues(IEnumerable`1<TValue> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> Contain(KeyValuePair`2[] expected);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> Contain(IEnumerable`1<KeyValuePair`2<TKey, TValue>> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> Contain(KeyValuePair`2<TKey, TValue> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> Contain(TKey key, TValue value, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContain(KeyValuePair`2[] items);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContain(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContain(KeyValuePair`2<TKey, TValue> item, string because, Object[] becauseArgs);
    public AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> NotContain(TKey key, TValue value, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
    [CompilerGeneratedAttribute]
private bool <ContainKeys>b__18_0(TKey key);
    [CompilerGeneratedAttribute]
private bool <Contain>b__31_1(TKey key);
    [CompilerGeneratedAttribute]
private bool <Contain>b__31_2(KeyValuePair`2<TKey, TValue> keyValuePair);
    [CompilerGeneratedAttribute]
private bool <NotContain>b__35_0(KeyValuePair`2<TKey, TValue> keyValuePair);
    [CompilerGeneratedAttribute]
private bool <NotContain>b__35_1(KeyValuePair`2<TKey, TValue> keyValuePair);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.NonGenericCollectionAssertions : CollectionAssertions`2<IEnumerable, NonGenericCollectionAssertions> {
    public NonGenericCollectionAssertions(IEnumerable collection);
    public AndConstraint`1<NonGenericCollectionAssertions> HaveCount(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NonGenericCollectionAssertions> NotHaveCount(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<NonGenericCollectionAssertions> HaveCountGreaterThan(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NonGenericCollectionAssertions> HaveCountGreaterOrEqualTo(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NonGenericCollectionAssertions> HaveCountLessThan(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NonGenericCollectionAssertions> HaveCountLessOrEqualTo(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NonGenericCollectionAssertions> HaveCount(Expression`1<Func`2<int, bool>> countPredicate, string because, Object[] becauseArgs);
    private int GetMostLocalCount();
    public AndConstraint`1<NonGenericCollectionAssertions> Contain(object expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NonGenericCollectionAssertions> NotContain(object unexpected, string because, Object[] becauseArgs);
}
public class FluentAssertions.Collections.SelfReferencingCollectionAssertions`2 : CollectionAssertions`2<IEnumerable`1<T>, TAssertions> {
    public SelfReferencingCollectionAssertions`2(IEnumerable`1<T> actualValue);
    public AndConstraint`1<TAssertions> HaveCount(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCount(Expression`1<Func`2<int, bool>> countPredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveCount(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCountGreaterThan(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCountGreaterOrEqualTo(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCountLessThan(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCountLessOrEqualTo(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Equal(T[] elements);
    private static Func`3<T, T, bool> GetComparer();
    public AndConstraint`1<TAssertions> Equal(IEnumerable`1<TExpected> expectation, Func`3<T, TExpected, bool> equalityComparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> StartWith(IEnumerable`1<T> expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> StartWith(IEnumerable`1<TExpected> expectation, Func`3<T, TExpected, bool> equalityComparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> EndWith(IEnumerable`1<T> expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> EndWith(IEnumerable`1<TExpected> expectation, Func`3<T, TExpected, bool> equalityComparison, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> Contain(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Contain(IEnumerable`1<T> expectedItemsList, T[] additionalExpectedItems);
    public AndWhichConstraint`2<TAssertions, T> Contain(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> OnlyContain(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> NotContain(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContain(IEnumerable`1<T> unexpectedItemsList, T[] additionalUnexpectedItems);
    public AndConstraint`1<TAssertions> NotContain(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> ContainSingle(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> ContainSingle(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> SatisfyRespectively(Action`1[] elementInspectors);
    public AndConstraint`1<TAssertions> SatisfyRespectively(IEnumerable`1<Action`1<T>> expected, string because, Object[] becauseArgs);
    private String[] CollectFailuresFromInspectors(IEnumerable`1<Action`1<T>> elementInspectors);
}
internal enum FluentAssertions.Collections.SortOrder : Enum {
    public int value__;
    public static SortOrder Ascending;
    public static SortOrder Descending;
}
public class FluentAssertions.Collections.StringCollectionAssertions : SelfReferencingCollectionAssertions`2<string, StringCollectionAssertions> {
    public StringCollectionAssertions(IEnumerable`1<string> actualValue);
    public AndConstraint`1<StringCollectionAssertions> Equal(String[] expected);
    public AndConstraint`1<StringCollectionAssertions> Equal(IEnumerable`1<string> expected);
    public AndConstraint`1<StringCollectionAssertions> BeEquivalentTo(String[] expectation);
    public AndConstraint`1<StringCollectionAssertions> BeEquivalentTo(IEnumerable`1<string> expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<StringCollectionAssertions> BeEquivalentTo(IEnumerable`1<string> expectation, Func`2<EquivalencyAssertionOptions`1<string>, EquivalencyAssertionOptions`1<string>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<StringCollectionAssertions> ContainInOrder(String[] expected);
    public AndConstraint`1<StringCollectionAssertions> ContainInOrder(IEnumerable`1<string> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringCollectionAssertions> Contain(IEnumerable`1<string> expected);
    public AndConstraint`1<StringCollectionAssertions> Contain(IEnumerable`1<string> expected, string because, object becauseArg, Object[] becauseArgs);
    public AndConstraint`1<StringCollectionAssertions> NotContain(IEnumerable`1<string> unexpected, string because, object becauseArg, Object[] becauseArgs);
    public AndWhichConstraint`2<StringCollectionAssertions, string> ContainMatch(string wildcardPattern, string because, Object[] becauseArgs);
    private bool ContainsMatch(string wildcardPattern);
    private IEnumerable`1<string> AllThatMatch(string wildcardPattern);
}
public class FluentAssertions.Collections.WhichValueConstraint`2 : AndConstraint`1<GenericDictionaryAssertions`2<TKey, TValue>> {
    [CompilerGeneratedAttribute]
private TValue <WhichValue>k__BackingField;
    public TValue WhichValue { get; private set; }
    public WhichValueConstraint`2(GenericDictionaryAssertions`2<TKey, TValue> parentConstraint, TValue value);
    [CompilerGeneratedAttribute]
public TValue get_WhichValue();
    [CompilerGeneratedAttribute]
private void set_WhichValue(TValue value);
}
internal class FluentAssertions.Common.AppSettingsConfigurationStore : object {
    public sealed virtual string GetSetting(string name);
}
internal class FluentAssertions.Common.Clock : object {
    public sealed virtual void Delay(TimeSpan timeToDelay);
    public sealed virtual Task DelayAsync(TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual bool Wait(Task task, TimeSpan timeout);
    public sealed virtual ITimer StartTimer();
}
public class FluentAssertions.Common.Configuration : object {
    private IConfigurationStore store;
    private string valueFormatterAssembly;
    private Nullable`1<ValueFormatterDetectionMode> valueFormatterDetectionMode;
    private string testFrameworkName;
    private object propertiesAccessLock;
    public static Configuration Current { get; }
    public ValueFormatterDetectionMode ValueFormatterDetectionMode { get; public set; }
    public string ValueFormatterAssembly { get; public set; }
    public string TestFrameworkName { get; public set; }
    public Configuration(IConfigurationStore store);
    public static Configuration get_Current();
    public ValueFormatterDetectionMode get_ValueFormatterDetectionMode();
    public void set_ValueFormatterDetectionMode(ValueFormatterDetectionMode value);
    private ValueFormatterDetectionMode DetermineFormatterDetectionMode();
    public string get_ValueFormatterAssembly();
    public void set_ValueFormatterAssembly(string value);
    public string get_TestFrameworkName();
    public void set_TestFrameworkName(string value);
}
internal class FluentAssertions.Common.ConfigurationStoreExceptionInterceptor : object {
    private bool underlyingStoreUnavailable;
    private IConfigurationStore configurationStore;
    public ConfigurationStoreExceptionInterceptor(IConfigurationStore configurationStore);
    public sealed virtual string GetSetting(string name);
}
public enum FluentAssertions.Common.CSharpAccessModifier : Enum {
    public int value__;
    public static CSharpAccessModifier Public;
    public static CSharpAccessModifier Private;
    public static CSharpAccessModifier Protected;
    public static CSharpAccessModifier Internal;
    public static CSharpAccessModifier ProtectedInternal;
    public static CSharpAccessModifier InvalidForCSharp;
    public static CSharpAccessModifier PrivateProtected;
}
[ExtensionAttribute]
public static class FluentAssertions.Common.CSharpAccessModifierExtensions : object {
    [ExtensionAttribute]
internal static CSharpAccessModifier GetCSharpAccessModifier(MethodBase methodBase);
    [ExtensionAttribute]
internal static CSharpAccessModifier GetCSharpAccessModifier(FieldInfo fieldInfo);
    [ExtensionAttribute]
internal static CSharpAccessModifier GetCSharpAccessModifier(Type type);
}
[ExtensionAttribute]
public static class FluentAssertions.Common.DateTimeExtensions : object {
    [ExtensionAttribute]
public static DateTimeOffset ToDateTimeOffset(DateTime dateTime);
    [ExtensionAttribute]
public static DateTimeOffset ToDateTimeOffset(DateTime dateTime, TimeSpan offset);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.EnumerableExtensions : object {
    [ExtensionAttribute]
public static ICollection`1<T> ConvertOrCastToCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ICollection`1<T> ConvertOrCastToCollection(IEnumerable source);
    [ExtensionAttribute]
public static IList`1<T> ConvertOrCastToList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IList`1<T> ConvertOrCastToList(IEnumerable source);
    [ExtensionAttribute]
public static int IndexOfFirstDifferenceWith(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, bool> equalityComparison);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.ExceptionExtensions : object {
    [ExtensionAttribute]
public static Exception Unwrap(TargetInvocationException exception);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.ExpressionExtensions : object {
    [ExtensionAttribute]
public static SelectedMemberInfo GetSelectedMemberInfo(Expression`1<Func`2<T, TValue>> expression);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyInfo(Expression`1<Func`2<T, TValue>> expression);
    private static MemberInfo AttemptToGetMemberInfoFromMemberExpression(Expression`1<Func`2<T, TValue>> expression);
    private static MemberInfo AttemptToGetMemberInfoFromCastExpression(Expression`1<Func`2<T, TValue>> expression);
    [ExtensionAttribute]
public static MemberPath GetMemberPath(Expression`1<Func`2<TDeclaringType, TPropertyType>> expression);
}
internal class FluentAssertions.Common.FullFrameworkReflector : object {
    public sealed virtual IEnumerable`1<Type> GetAllTypesFromAppDomain(Func`2<Assembly, bool> predicate);
    private bool IsRelevant(Assembly ass);
    private static bool IsDynamic(Assembly assembly);
    private static IEnumerable`1<Type> GetExportedTypes(Assembly assembly);
}
internal static class FluentAssertions.Common.Guard : object {
    public static void ThrowIfArgumentIsNull(T obj, string paramName);
    public static void ThrowIfArgumentIsNull(T obj, string paramName, string message);
    public static void ThrowIfArgumentIsNullOrEmpty(string str, string paramName);
    public static void ThrowIfArgumentIsNullOrEmpty(string str, string paramName, string message);
}
public interface FluentAssertions.Common.IClock {
    public abstract virtual void Delay(TimeSpan timeToDelay);
    public abstract virtual Task DelayAsync(TimeSpan delay, CancellationToken cancellationToken);
    public abstract virtual bool Wait(Task task, TimeSpan timeout);
    public abstract virtual ITimer StartTimer();
}
public interface FluentAssertions.Common.IConfigurationStore {
    public abstract virtual string GetSetting(string name);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.IntegerExtensions : object {
    [ExtensionAttribute]
public static string Times(int count);
}
public interface FluentAssertions.Common.IReflector {
    public abstract virtual IEnumerable`1<Type> GetAllTypesFromAppDomain(Func`2<Assembly, bool> predicate);
}
public interface FluentAssertions.Common.ITimer {
    public TimeSpan Elapsed { get; }
    public abstract virtual TimeSpan get_Elapsed();
}
internal class FluentAssertions.Common.MemberPath : object {
    private Type declaringType;
    private string dottedPath;
    private String[] segments;
    public MemberPath(Type declaringType, string dottedPath);
    public bool IsParentOrChildOf(MemberPath candidate);
    public bool IsSameAs(MemberPath candidate);
    private bool IsChild(MemberPath candidate);
    private bool IsParent(MemberPath candidate);
    private String[] GetSegments();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class FluentAssertions.Common.MethodInfoExtensions : object {
    private static Lazy`1<int> ImplementationOptionsMask;
    private static MethodInfoExtensions();
    [ExtensionAttribute]
internal static bool IsAsync(MethodInfo methodInfo);
    [ExtensionAttribute]
internal static IEnumerable`1<TAttribute> GetMatchingAttributes(MemberInfo memberInfo, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
internal static bool IsNonVirtual(MethodInfo method);
    private static ValueTuple`2<bool, MethodImplAttribute> RecreateMethodImplAttribute(MethodBase methodBase);
}
internal static class FluentAssertions.Common.NoSynchronizationContextScope : object {
    public static DisposingAction Enter();
}
[ExtensionAttribute]
public static class FluentAssertions.Common.ObjectExtensions : object {
    [ExtensionAttribute]
public static bool IsSameOrEqualTo(object actual, object expected);
    private static bool CanConvert(object source, object target, Type sourceType, Type targetType);
    [ExtensionAttribute]
private static object ConvertTo(object source, Type targetType);
    [ExtensionAttribute]
private static bool IsNumericType(object obj);
    [ExtensionAttribute]
private static bool IsEnumType(Type type);
}
[ExtensionAttribute]
public static class FluentAssertions.Common.PropertyInfoExtensions : object {
    [ExtensionAttribute]
internal static bool IsVirtual(PropertyInfo property);
}
public static class FluentAssertions.Common.Services : object {
    private static object lockable;
    private static Configuration configuration;
    [CompilerGeneratedAttribute]
private static IConfigurationStore <ConfigurationStore>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<string> <ThrowException>k__BackingField;
    [CompilerGeneratedAttribute]
private static IReflector <Reflector>k__BackingField;
    public static IConfigurationStore ConfigurationStore { get; public set; }
    public static Configuration Configuration { get; }
    public static Action`1<string> ThrowException { get; public set; }
    public static IReflector Reflector { get; public set; }
    private static Services();
    [CompilerGeneratedAttribute]
public static IConfigurationStore get_ConfigurationStore();
    [CompilerGeneratedAttribute]
public static void set_ConfigurationStore(IConfigurationStore value);
    public static Configuration get_Configuration();
    [CompilerGeneratedAttribute]
public static Action`1<string> get_ThrowException();
    [CompilerGeneratedAttribute]
public static void set_ThrowException(Action`1<string> value);
    [CompilerGeneratedAttribute]
public static IReflector get_Reflector();
    [CompilerGeneratedAttribute]
public static void set_Reflector(IReflector value);
    public static void ResetToDefaults();
}
internal class FluentAssertions.Common.StopwatchTimer : object {
    private Stopwatch stopwatch;
    public TimeSpan Elapsed { get; }
    public sealed virtual TimeSpan get_Elapsed();
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.StringExtensions : object {
    [ExtensionAttribute]
public static int IndexOfFirstMismatch(string value, string expected, StringComparison stringComparison);
    [ExtensionAttribute]
public static string IndexedSegmentAt(string value, int index);
    [ExtensionAttribute]
public static string EscapePlaceholders(string value);
    [ExtensionAttribute]
internal static string UnescapePlaceholders(string value);
    [ExtensionAttribute]
public static string Combine(string this, string other, string separator);
    [ExtensionAttribute]
public static string Capitalize(string this);
    [ExtensionAttribute]
public static string IndentLines(string this);
    [ExtensionAttribute]
public static string RemoveNewLines(string this);
    [ExtensionAttribute]
public static int CountSubstring(string this, string substring, StringComparison comparisonType);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.TaskExtensions : object {
    [ExtensionAttribute]
public static void ExecuteInDefaultSynchronizationContext(Action action);
    [ExtensionAttribute]
public static TResult ExecuteInDefaultSynchronizationContext(Func`1<TResult> action);
}
[ExtensionAttribute]
public static class FluentAssertions.Common.TypeExtensions : object {
    private static BindingFlags PublicMembersFlag;
    private static BindingFlags AllMembersFlag;
    [ExtensionAttribute]
[ObsoleteAttribute("This method is deprecated and will be removed on the next major version. Please use <IsDecoratedWithOrInherits> instead.")]
public static bool HasAttribute(MemberInfo method);
    [ExtensionAttribute]
[ObsoleteAttribute("This method is deprecated and will be removed on the next major version. Please use <IsDecoratedWith> instead.")]
public static bool HasMatchingAttribute(MemberInfo type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This method is deprecated and will be removed on the next major version. Please use <IsDecoratedWithOrInherits> or <IsDecoratedWith> instead.")]
public static bool HasMatchingAttribute(Type type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, bool inherit);
    [ExtensionAttribute]
public static bool IsDecoratedWith(Type type);
    [ExtensionAttribute]
public static bool IsDecoratedWith(TypeInfo type);
    [ExtensionAttribute]
public static bool IsDecoratedWith(MemberInfo type);
    [ExtensionAttribute]
public static bool IsDecoratedWithOrInherit(Type type);
    [ExtensionAttribute]
public static bool IsDecoratedWithOrInherit(TypeInfo type);
    [ExtensionAttribute]
public static bool IsDecoratedWithOrInherit(MemberInfo type);
    [ExtensionAttribute]
public static bool IsDecoratedWith(Type type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static bool IsDecoratedWith(TypeInfo type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static bool IsDecoratedWith(MemberInfo type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static bool IsDecoratedWithOrInherit(Type type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static bool IsDecoratedWithOrInherit(TypeInfo type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static bool IsDecoratedWithOrInherit(MemberInfo type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
[ObsoleteAttribute("This overload is deprecated and will be removed on the next major version. Please use <IsDecoratedWithOrInherits> or <IsDecoratedWith> instead.")]
public static bool IsDecoratedWith(Type type, bool inherit);
    private static IEnumerable`1<TAttribute> GetCustomAttributes(MemberInfo type, bool inherit);
    private static IEnumerable`1<TAttribute> GetCustomAttributes(Type type, bool inherit);
    private static IEnumerable`1<TAttribute> GetCustomAttributes(TypeInfo typeInfo, bool inherit);
    [ExtensionAttribute]
public static bool IsEquivalentTo(SelectedMemberInfo property, SelectedMemberInfo otherProperty);
    [ExtensionAttribute]
public static bool IsSameOrInherits(Type actualType, Type expectedType);
    [ExtensionAttribute]
public static bool Implements(Type type, Type expectedBaseType);
    internal static Type[] GetClosedGenericInterfaces(Type type, Type openGenericType);
    [ExtensionAttribute]
public static bool OverridesEquals(Type type);
    [ExtensionAttribute]
public static SelectedMemberInfo FindMember(Type type, string memberName, Type preferredType);
    [ExtensionAttribute]
public static PropertyInfo FindProperty(Type type, string propertyName, Type preferredType);
    [ExtensionAttribute]
public static FieldInfo FindField(Type type, string fieldName, Type preferredType);
    [ExtensionAttribute]
public static IEnumerable`1<SelectedMemberInfo> GetNonPrivateMembers(Type typeToReflect);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetNonPrivateProperties(Type typeToReflect, IEnumerable`1<string> filter);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetNonPrivateFields(Type typeToReflect);
    private static IEnumerable`1<FieldInfo> GetFieldsFromHierarchy(Type typeToReflect);
    private static IEnumerable`1<PropertyInfo> GetPropertiesFromHierarchy(Type typeToReflect);
    private static IEnumerable`1<TMemberInfo> GetMembersFromHierarchy(Type typeToReflect, Func`2<Type, IEnumerable`1<TMemberInfo>> getMembers);
    private static bool IsInterface(Type typeToReflect);
    private static Type[] GetInterfaces(Type type);
    private static PropertyInfo[] GetPublicProperties(Type type);
    private static FieldInfo[] GetPublicFields(Type type);
    private static bool HasNonPrivateGetter(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool IsCSharpAbstract(Type type);
    [ExtensionAttribute]
public static bool IsCSharpSealed(Type type);
    [ExtensionAttribute]
public static bool IsCSharpStatic(Type type);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string methodName, IEnumerable`1<Type> parameterTypes);
    [ExtensionAttribute]
public static bool HasMethod(Type type, string methodName, IEnumerable`1<Type> parameterTypes);
    [ExtensionAttribute]
public static MethodInfo GetParameterlessMethod(Type type, string methodName);
    [ExtensionAttribute]
public static bool HasParameterlessMethod(Type type, string methodName);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyByName(Type type, string propertyName);
    [ExtensionAttribute]
public static bool HasExplicitlyImplementedProperty(Type type, Type interfaceType, string propertyName);
    [ExtensionAttribute]
public static PropertyInfo GetIndexerByParameterTypes(Type type, IEnumerable`1<Type> parameterTypes);
    [ExtensionAttribute]
public static bool IsIndexer(PropertyInfo member);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructor(Type type, IEnumerable`1<Type> parameterTypes);
    [ExtensionAttribute]
public static MethodInfo GetImplicitConversionOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
public static MethodInfo GetExplicitConversionOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
private static IEnumerable`1<MethodInfo> GetConversionOperators(Type type, Type sourceType, Type targetType, Func`2<string, bool> predicate);
    [ExtensionAttribute]
public static bool HasValueSemantics(Type type);
    private static bool IsKeyValuePair(Type type);
    [ExtensionAttribute]
private static bool IsAnonymousType(Type type);
    [ExtensionAttribute]
private static bool IsTuple(Type type);
    [ExtensionAttribute]
internal static bool IsAssignableToOpenGeneric(Type type, Type definition);
    [ExtensionAttribute]
internal static bool IsImplementationOfOpenGeneric(Type type, Type definition);
    [ExtensionAttribute]
internal static bool IsDerivedFromOpenGeneric(Type type, Type definition);
    [ExtensionAttribute]
internal static bool IsUnderNamespace(Type type, string namespace);
    [CompilerGeneratedAttribute]
internal static bool <IsUnderNamespace>g__IsGlobalNamespace|62_0(<>c__DisplayClass62_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsUnderNamespace>g__IsExactNamespace|62_1(<>c__DisplayClass62_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsUnderNamespace>g__IsParentNamespace|62_2(<>c__DisplayClass62_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsUnderNamespace>g__IsNamespacePrefix|62_3(<>c__DisplayClass62_0& );
}
public enum FluentAssertions.Common.ValueFormatterDetectionMode : Enum {
    public int value__;
    public static ValueFormatterDetectionMode Disabled;
    public static ValueFormatterDetectionMode Specific;
    public static ValueFormatterDetectionMode Scan;
}
[AttributeUsageAttribute("64")]
public class FluentAssertions.CustomAssertionAttribute : Attribute {
}
internal class FluentAssertions.Disposable : object {
    private Action action;
    public Disposable(Action action);
    public sealed virtual void Dispose();
}
internal class FluentAssertions.Equivalency.AssertionContext`1 : object {
    [CompilerGeneratedAttribute]
private SelectedMemberInfo <SubjectProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private TSubject <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private TSubject <Expectation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Because>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <BecauseArgs>k__BackingField;
    public SelectedMemberInfo SubjectProperty { get; private set; }
    public TSubject Subject { get; private set; }
    public TSubject Expectation { get; private set; }
    public string Because { get; public set; }
    public Object[] BecauseArgs { get; public set; }
    public AssertionContext`1(SelectedMemberInfo subjectProperty, TSubject subject, TSubject expectation, string because, Object[] becauseArgs);
    [CompilerGeneratedAttribute]
public sealed virtual SelectedMemberInfo get_SubjectProperty();
    [CompilerGeneratedAttribute]
private void set_SubjectProperty(SelectedMemberInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual TSubject get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(TSubject value);
    [CompilerGeneratedAttribute]
public sealed virtual TSubject get_Expectation();
    [CompilerGeneratedAttribute]
private void set_Expectation(TSubject value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Because();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Because(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Object[] get_BecauseArgs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BecauseArgs(Object[] value);
    internal static AssertionContext`1<TSubject> CreateFromEquivalencyValidationContext(IEquivalencyValidationContext context);
}
internal class FluentAssertions.Equivalency.AssertionResultSet : object {
    private Dictionary`2<object, String[]> set;
    public void AddSet(object key, String[] failures);
    public String[] SelectClosestMatchFor(object key);
    private KeyValuePair`2[] GetBestResultSets();
    public bool ContainsSuccessfulSet();
}
internal class FluentAssertions.Equivalency.AssertionRule`1 : object {
    private Func`2<IMemberInfo, bool> predicate;
    private Action`1<IAssertionContext`1<TSubject>> action;
    private string description;
    public AssertionRule`1(Expression`1<Func`2<IMemberInfo, bool>> predicate, Action`1<IAssertionContext`1<TSubject>> action);
    public sealed virtual bool AssertEquality(IEquivalencyValidationContext context);
    public virtual string ToString();
}
public class FluentAssertions.Equivalency.AssertionRuleEquivalencyStep`1 : object {
    private Expression`1<Func`2<IMemberInfo, bool>> canHandle;
    private Action`1<IAssertionContext`1<TSubject>> handle;
    public AssertionRuleEquivalencyStep`1(Expression`1<Func`2<IMemberInfo, bool>> predicate, Action`1<IAssertionContext`1<TSubject>> action);
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.AssertionRuleEquivalencyStepAdapter : object {
    private IAssertionRule assertionRule;
    public AssertionRuleEquivalencyStepAdapter(IAssertionRule assertionRule);
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.CollectionMemberAssertionOptionsDecorator : object {
    private IEquivalencyAssertionOptions inner;
    public IEnumerable`1<IMemberSelectionRule> SelectionRules { get; }
    public IEnumerable`1<IMemberMatchingRule> MatchingRules { get; }
    public OrderingRuleCollection OrderingRules { get; }
    public ConversionSelector ConversionSelector { get; }
    public bool IsRecursive { get; }
    public bool AllowInfiniteRecursion { get; }
    public CyclicReferenceHandling CyclicReferenceHandling { get; }
    public EnumEquivalencyHandling EnumEquivalencyHandling { get; }
    public bool UseRuntimeTyping { get; }
    public bool IncludeProperties { get; }
    public bool IncludeFields { get; }
    public ITraceWriter TraceWriter { get; }
    public CollectionMemberAssertionOptionsDecorator(IEquivalencyAssertionOptions inner);
    public sealed virtual IEnumerable`1<IMemberSelectionRule> get_SelectionRules();
    public sealed virtual IEnumerable`1<IMemberMatchingRule> get_MatchingRules();
    public sealed virtual OrderingRuleCollection get_OrderingRules();
    public sealed virtual ConversionSelector get_ConversionSelector();
    public sealed virtual IEnumerable`1<IEquivalencyStep> GetUserEquivalencySteps(ConversionSelector conversionSelector);
    public sealed virtual bool get_IsRecursive();
    public sealed virtual bool get_AllowInfiniteRecursion();
    public sealed virtual CyclicReferenceHandling get_CyclicReferenceHandling();
    public sealed virtual EnumEquivalencyHandling get_EnumEquivalencyHandling();
    public sealed virtual bool get_UseRuntimeTyping();
    public sealed virtual bool get_IncludeProperties();
    public sealed virtual bool get_IncludeFields();
    public sealed virtual EqualityStrategy GetEqualityStrategy(Type type);
    public sealed virtual ITraceWriter get_TraceWriter();
}
internal class FluentAssertions.Equivalency.CollectionMemberAssertionRuleDecorator : object {
    private IEquivalencyStep equivalencyStep;
    public CollectionMemberAssertionRuleDecorator(IEquivalencyStep equivalencyStep);
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static EquivalencyValidationContext CreateAdjustedCopy(IEquivalencyValidationContext context);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.CollectionMemberMemberInfo : object {
    [CompilerGeneratedAttribute]
private SelectedMemberInfo <SelectedMemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedMemberPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedMemberDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CompileTimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RuntimeType>k__BackingField;
    public SelectedMemberInfo SelectedMemberInfo { get; private set; }
    public string SelectedMemberPath { get; private set; }
    public string SelectedMemberDescription { get; private set; }
    public Type CompileTimeType { get; private set; }
    public Type RuntimeType { get; private set; }
    public CollectionMemberMemberInfo(IMemberInfo memberInfo);
    internal static string GetAdjustedPropertyPath(string propertyPath);
    [CompilerGeneratedAttribute]
public sealed virtual SelectedMemberInfo get_SelectedMemberInfo();
    [CompilerGeneratedAttribute]
private void set_SelectedMemberInfo(SelectedMemberInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SelectedMemberPath();
    [CompilerGeneratedAttribute]
private void set_SelectedMemberPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SelectedMemberDescription();
    [CompilerGeneratedAttribute]
private void set_SelectedMemberDescription(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_CompileTimeType();
    [CompilerGeneratedAttribute]
private void set_CompileTimeType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_RuntimeType();
    [CompilerGeneratedAttribute]
private void set_RuntimeType(Type value);
}
public class FluentAssertions.Equivalency.ConversionSelector : object {
    private List`1<ConversionSelectorRule> inclusions;
    private List`1<ConversionSelectorRule> exclusions;
    public void IncludeAll();
    public void Include(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public void Exclude(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public bool RequiresConversion(IMemberInfo info);
    public virtual string ToString();
    public ConversionSelector Clone();
}
internal class FluentAssertions.Equivalency.CyclicReferenceDetector : object {
    private CyclicReferenceHandling handling;
    private List`1<ObjectReference> orderedReferences;
    public CyclicReferenceDetector(CyclicReferenceHandling handling);
    public bool IsCyclicReference(ObjectReference reference, string because, Object[] becauseArgs);
    public sealed virtual object Clone();
}
public enum FluentAssertions.Equivalency.CyclicReferenceHandling : Enum {
    public int value__;
    public static CyclicReferenceHandling Ignore;
    public static CyclicReferenceHandling ThrowException;
}
public class FluentAssertions.Equivalency.DictionaryEquivalencyStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static bool PreconditionsAreMet(IDictionary expectation, IDictionary subject);
    private static bool AssertEitherIsNotNull(IDictionary expectation, IDictionary subject);
    private static bool AssertIsDictionary(IDictionary subject);
    private static bool AssertSameLength(IDictionary expectation, IDictionary subject);
}
internal class FluentAssertions.Equivalency.Digit : object {
    private int length;
    private Digit nextDigit;
    private int index;
    public Digit(int length, Digit nextDigit);
    public Int32[] GetIndices();
    public bool Increment();
}
public class FluentAssertions.Equivalency.EnumEqualityStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static void HandleByValue(IEquivalencyValidationContext context);
    private static void HandleByName(IEquivalencyValidationContext context);
    private static string GetDisplayNameForEnumComparison(object o, Nullable`1<decimal> v);
    private static Nullable`1<decimal> ExtractDecimal(object o);
}
public enum FluentAssertions.Equivalency.EnumEquivalencyHandling : Enum {
    public int value__;
    public static EnumEquivalencyHandling ByValue;
    public static EnumEquivalencyHandling ByName;
}
public class FluentAssertions.Equivalency.EnumerableEquivalencyStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static bool AssertSubjectIsCollection(object subject);
    private static bool IsCollection(Type type);
    internal static Object[] ToArray(object value);
}
internal class FluentAssertions.Equivalency.EnumerableEquivalencyValidator : object {
    private static int FailedItemsFastFailThreshold;
    private IEquivalencyValidator parent;
    private IEquivalencyValidationContext context;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderingRuleCollection <OrderingRules>k__BackingField;
    private List`1<int> unmatchedSubjectIndexes;
    public bool Recursive { get; public set; }
    public OrderingRuleCollection OrderingRules { get; public set; }
    public EnumerableEquivalencyValidator(IEquivalencyValidator parent, IEquivalencyValidationContext context);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
public void set_Recursive(bool value);
    [CompilerGeneratedAttribute]
public OrderingRuleCollection get_OrderingRules();
    [CompilerGeneratedAttribute]
public void set_OrderingRules(OrderingRuleCollection value);
    public void Execute(Object[] subject, T[] expectation);
    private static bool AssertIsNotNull(object expectation, Object[] subject);
    private static Continuation AssertCollectionsHaveSameCount(ICollection`1<object> subject, ICollection`1<T> expectation);
    private void AssertElementGraphEquivalency(Object[] subjects, T[] expectations);
    private void AssertElementGraphEquivalencyWithStrictOrdering(Object[] subjects, T[] expectations);
    private void AssertElementGraphEquivalencyWithLooseOrdering(Object[] subjects, T[] expectations);
    private bool LooselyMatchAgainst(IList`1<object> subjects, T expectation, int expectationIndex);
    private String[] TryToMatch(object subject, T expectation, int expectationIndex);
    private bool StrictlyMatchAgainst(Object[] subjects, T expectation, int expectationIndex);
}
[ExtensionAttribute]
internal static class FluentAssertions.Equivalency.EnumerableEquivalencyValidatorExtensions : object {
    [ExtensionAttribute]
public static Continuation AssertEitherCollectionIsNotEmpty(IAssertionScope scope, ICollection`1<object> subject, ICollection`1<T> expectation);
    [ExtensionAttribute]
public static Continuation AssertCollectionHasEnoughItems(IAssertionScope scope, ICollection`1<object> subject, ICollection`1<T> expectation);
    [ExtensionAttribute]
public static Continuation AssertCollectionHasNotTooManyItems(IAssertionScope scope, ICollection`1<object> subject, ICollection`1<T> expectation);
}
public enum FluentAssertions.Equivalency.EqualityStrategy : Enum {
    public int value__;
    public static EqualityStrategy Equals;
    public static EqualityStrategy Members;
    public static EqualityStrategy ForceEquals;
    public static EqualityStrategy ForceMembers;
}
public class FluentAssertions.Equivalency.EquivalencyAssertionOptions : SelfReferenceEquivalencyAssertionOptions`1<EquivalencyAssertionOptions> {
}
public class FluentAssertions.Equivalency.EquivalencyAssertionOptions`1 : SelfReferenceEquivalencyAssertionOptions`1<EquivalencyAssertionOptions`1<TExpectation>> {
    internal EquivalencyAssertionOptions`1(IEquivalencyAssertionOptions defaults);
    public EquivalencyAssertionOptions`1<TExpectation> Excluding(Expression`1<Func`2<TExpectation, object>> expression);
    public EquivalencyAssertionOptions`1<TExpectation> Including(Expression`1<Func`2<TExpectation, object>> expression);
    public EquivalencyAssertionOptions`1<TExpectation> Including(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public EquivalencyAssertionOptions`1<TExpectation> WithStrictOrderingFor(Expression`1<Func`2<TExpectation, object>> expression);
    public EquivalencyAssertionOptions`1<IEnumerable`1<TExpectation>> AsCollection();
}
[ExtensionAttribute]
[ObsoleteAttribute("This class is deprecated and will be removed in version 6.X.")]
[EditorBrowsableAttribute("1")]
public static class FluentAssertions.Equivalency.EquivalencyAssertionOptionsExtentions : object {
    [ExtensionAttribute]
public static Type GetExpectationType(IEquivalencyAssertionOptions config, IMemberInfo context);
    private static Type NullableOrActualType(Type type);
}
public class FluentAssertions.Equivalency.EquivalencyValidationContext : object {
    private Type compileTimeType;
    [CompilerGeneratedAttribute]
private SelectedMemberInfo <SelectedMemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedMemberPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedMemberDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Expectation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Because>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <BecauseArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RootIsCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <Tracer>k__BackingField;
    public SelectedMemberInfo SelectedMemberInfo { get; public set; }
    public string SelectedMemberPath { get; public set; }
    public string SelectedMemberDescription { get; public set; }
    public object Subject { get; public set; }
    public object Expectation { get; public set; }
    public string Because { get; public set; }
    public Object[] BecauseArgs { get; public set; }
    public bool IsRoot { get; }
    public Type CompileTimeType { get; public set; }
    public Type RuntimeType { get; }
    public bool RootIsCollection { get; public set; }
    public ITraceWriter Tracer { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual SelectedMemberInfo get_SelectedMemberInfo();
    [CompilerGeneratedAttribute]
public void set_SelectedMemberInfo(SelectedMemberInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SelectedMemberPath();
    [CompilerGeneratedAttribute]
public void set_SelectedMemberPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SelectedMemberDescription();
    [CompilerGeneratedAttribute]
public void set_SelectedMemberDescription(string value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(object value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Expectation();
    [CompilerGeneratedAttribute]
public void set_Expectation(object value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Because();
    [CompilerGeneratedAttribute]
public void set_Because(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Object[] get_BecauseArgs();
    [CompilerGeneratedAttribute]
public void set_BecauseArgs(Object[] value);
    public sealed virtual bool get_IsRoot();
    public sealed virtual Type get_CompileTimeType();
    public void set_CompileTimeType(Type value);
    public sealed virtual Type get_RuntimeType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RootIsCollection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RootIsCollection(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ITraceWriter get_Tracer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Tracer(ITraceWriter value);
    public sealed virtual void TraceSingle(GetTraceMessage getTraceMessage);
    public sealed virtual IDisposable TraceBlock(GetTraceMessage getTraceMessage);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class FluentAssertions.Equivalency.EquivalencyValidationContextExtensions : object {
    [ExtensionAttribute]
internal static IEquivalencyValidationContext CreateForNestedMember(IEquivalencyValidationContext context, SelectedMemberInfo nestedMember, SelectedMemberInfo matchingProperty);
    [ExtensionAttribute]
internal static IEquivalencyValidationContext CreateForCollectionItem(IEquivalencyValidationContext context, string index, object subject, T expectation);
    [ExtensionAttribute]
internal static IEquivalencyValidationContext CreateForDictionaryItem(IEquivalencyValidationContext context, TKey key, object subject, TExpectation expectation);
    [ExtensionAttribute]
internal static IEquivalencyValidationContext CreateWithDifferentSubject(IEquivalencyValidationContext context, object convertedSubject, Type expectationType);
}
public class FluentAssertions.Equivalency.EquivalencyValidator : object {
    private static int MaxDepth;
    private IEquivalencyAssertionOptions config;
    private Dictionary`2<Type, bool> isComplexTypeMap;
    public EquivalencyValidator(IEquivalencyAssertionOptions config);
    public void AssertEquality(EquivalencyValidationContext context);
    public sealed virtual void AssertEqualityUsing(IEquivalencyValidationContext context);
    private bool ShouldCompareMembersThisDeep(string selectedMemberPath);
    private static void UpdateScopeWithReportableContext(IEquivalencyValidationContext context);
    private bool IsCyclicReference(IEquivalencyValidationContext context);
    private bool IsComplexType(object expectation);
    private void RunStepsUntilEquivalencyIsProven(IEquivalencyValidationContext context);
}
internal class FluentAssertions.Equivalency.FieldSelectedMemberInfo : MemberInfoSelectedMemberInfo {
    private FieldInfo fieldInfo;
    public Type MemberType { get; }
    public FieldSelectedMemberInfo(FieldInfo fieldInfo);
    public virtual object GetValue(object obj, Object[] index);
    public virtual Type get_MemberType();
    internal virtual CSharpAccessModifier GetGetAccessModifier();
    internal virtual CSharpAccessModifier GetSetAccessModifier();
}
public class FluentAssertions.Equivalency.GenericDictionaryEquivalencyStep : object {
    private static MethodInfo AssertSameLengthMethod;
    private static MethodInfo AssertDictionaryEquivalenceMethod;
    private static GenericDictionaryEquivalencyStep();
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static Type[] GetIDictionaryInterfaces(Type type);
    private static bool PreconditionsAreMet(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    private static bool AssertSubjectIsNotNull(object subject);
    private static bool AssertExpectationIsNotNull(object subject, object expectation);
    private static bool AssertImplementsOnlyOneDictionaryInterface(object expectation);
    private static bool AssertIsCompatiblyTypedDictionary(Type expectedType, object subject);
    private static Type GetDictionaryKeyType(Type expectedType);
    private static bool AssertSameLength(object subject, Type expectationType, object expectation);
    private static Type[] GetDictionaryTypeArguments(Type type);
    private static Type GetIDictionaryInterface(Type expectedType);
    private static bool AssertSameLength(IDictionary`2<TSubjectKey, TSubjectValue> subject, IDictionary`2<TExpectedKey, TExpectedValue> expectation);
    private static KeyDifference`2<TSubjectKey, TExpectedKey> CalculateKeyDifference(IDictionary`2<TSubjectKey, TSubjectValue> subject, IDictionary`2<TExpectedKey, TExpectedValue> expectation);
    private static void AssertDictionaryEquivalence(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static void AssertDictionaryEquivalence(EquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config, IDictionary`2<TSubjectKey, TSubjectValue> subject, IDictionary`2<TExpectedKey, TExpectedValue> expectation);
}
public class FluentAssertions.Equivalency.GenericEnumerableEquivalencyStep : object {
    private static MethodInfo HandleMethod;
    private static GenericEnumerableEquivalencyStep();
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static void HandleImpl(EnumerableEquivalencyValidator validator, Object[] subject, IEnumerable`1<T> expectation);
    private static bool AssertSubjectIsCollection(object subject);
    private static bool IsCollection(Type type);
    private static bool IsGenericCollection(Type type);
    private static Type[] GetIEnumerableInterfaces(Type type);
    private static Type GetTypeOfEnumeration(Type enumerableType);
}
public class FluentAssertions.Equivalency.GetTraceMessage : MulticastDelegate {
    public GetTraceMessage(object object, IntPtr method);
    public virtual string Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public interface FluentAssertions.Equivalency.IAssertionContext`1 {
    public SelectedMemberInfo SubjectProperty { get; }
    public TSubject Subject { get; }
    public TSubject Expectation { get; }
    public string Because { get; public set; }
    public Object[] BecauseArgs { get; public set; }
    public abstract virtual SelectedMemberInfo get_SubjectProperty();
    public abstract virtual TSubject get_Subject();
    public abstract virtual TSubject get_Expectation();
    public abstract virtual string get_Because();
    public abstract virtual void set_Because(string value);
    public abstract virtual Object[] get_BecauseArgs();
    public abstract virtual void set_BecauseArgs(Object[] value);
}
public interface FluentAssertions.Equivalency.IAssertionRule {
    public abstract virtual bool AssertEquality(IEquivalencyValidationContext context);
}
public interface FluentAssertions.Equivalency.IEquivalencyAssertionOptions {
    public IEnumerable`1<IMemberSelectionRule> SelectionRules { get; }
    public IEnumerable`1<IMemberMatchingRule> MatchingRules { get; }
    public bool IsRecursive { get; }
    public bool AllowInfiniteRecursion { get; }
    public CyclicReferenceHandling CyclicReferenceHandling { get; }
    public OrderingRuleCollection OrderingRules { get; }
    public ConversionSelector ConversionSelector { get; }
    public EnumEquivalencyHandling EnumEquivalencyHandling { get; }
    public bool UseRuntimeTyping { get; }
    public bool IncludeProperties { get; }
    public bool IncludeFields { get; }
    public ITraceWriter TraceWriter { get; }
    public abstract virtual IEnumerable`1<IMemberSelectionRule> get_SelectionRules();
    public abstract virtual IEnumerable`1<IMemberMatchingRule> get_MatchingRules();
    public abstract virtual bool get_IsRecursive();
    public abstract virtual bool get_AllowInfiniteRecursion();
    public abstract virtual CyclicReferenceHandling get_CyclicReferenceHandling();
    public abstract virtual OrderingRuleCollection get_OrderingRules();
    public abstract virtual ConversionSelector get_ConversionSelector();
    public abstract virtual EnumEquivalencyHandling get_EnumEquivalencyHandling();
    public abstract virtual IEnumerable`1<IEquivalencyStep> GetUserEquivalencySteps(ConversionSelector conversionSelector);
    public abstract virtual bool get_UseRuntimeTyping();
    public abstract virtual bool get_IncludeProperties();
    public abstract virtual bool get_IncludeFields();
    public abstract virtual ITraceWriter get_TraceWriter();
    public abstract virtual EqualityStrategy GetEqualityStrategy(Type type);
}
public interface FluentAssertions.Equivalency.IEquivalencyStep {
    public abstract virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public abstract virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
}
public interface FluentAssertions.Equivalency.IEquivalencyValidationContext {
    public object Expectation { get; }
    public string Because { get; }
    public Object[] BecauseArgs { get; }
    public bool IsRoot { get; }
    public object Subject { get; }
    public bool RootIsCollection { get; public set; }
    public ITraceWriter Tracer { get; public set; }
    public abstract virtual object get_Expectation();
    public abstract virtual string get_Because();
    public abstract virtual Object[] get_BecauseArgs();
    public abstract virtual bool get_IsRoot();
    public abstract virtual object get_Subject();
    public abstract virtual bool get_RootIsCollection();
    public abstract virtual void set_RootIsCollection(bool value);
    public abstract virtual ITraceWriter get_Tracer();
    public abstract virtual void set_Tracer(ITraceWriter value);
    public abstract virtual IDisposable TraceBlock(GetTraceMessage getMessage);
    public abstract virtual void TraceSingle(GetTraceMessage getMessage);
}
public interface FluentAssertions.Equivalency.IEquivalencyValidator {
    public abstract virtual void AssertEqualityUsing(IEquivalencyValidationContext context);
}
public interface FluentAssertions.Equivalency.IMemberInfo {
    public SelectedMemberInfo SelectedMemberInfo { get; }
    public string SelectedMemberPath { get; }
    public string SelectedMemberDescription { get; }
    public Type CompileTimeType { get; }
    public Type RuntimeType { get; }
    public abstract virtual SelectedMemberInfo get_SelectedMemberInfo();
    public abstract virtual string get_SelectedMemberPath();
    public abstract virtual string get_SelectedMemberDescription();
    public abstract virtual Type get_CompileTimeType();
    public abstract virtual Type get_RuntimeType();
}
public interface FluentAssertions.Equivalency.IMemberMatchingRule {
    public abstract virtual SelectedMemberInfo Match(SelectedMemberInfo expectedMember, object subject, string memberPath, IEquivalencyAssertionOptions config);
}
public interface FluentAssertions.Equivalency.IMemberSelectionRule {
    public bool IncludesMembers { get; }
    public abstract virtual bool get_IncludesMembers();
    public abstract virtual IEnumerable`1<SelectedMemberInfo> SelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, IMemberInfo context, IEquivalencyAssertionOptions config);
}
public interface FluentAssertions.Equivalency.IOrderingRule {
    public abstract virtual OrderStrictness Evaluate(IMemberInfo memberInfo);
}
public interface FluentAssertions.Equivalency.ITraceWriter {
    public abstract virtual void AddSingle(string trace);
    public abstract virtual IDisposable AddBlock(string trace);
    public abstract virtual string ToString();
}
internal class FluentAssertions.Equivalency.Matching.CollectionMemberMatchingRuleDecorator : object {
    private IMemberMatchingRule matchingRule;
    public CollectionMemberMatchingRuleDecorator(IMemberMatchingRule matchingRule);
    public sealed virtual SelectedMemberInfo Match(SelectedMemberInfo expectedMember, object subject, string memberPath, IEquivalencyAssertionOptions config);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Matching.MustMatchByNameRule : object {
    public sealed virtual SelectedMemberInfo Match(SelectedMemberInfo expectedMember, object subject, string memberPath, IEquivalencyAssertionOptions config);
    private static bool ExpectationImplementsMemberExplicitly(object expectation, SelectedMemberInfo subjectMember);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Matching.TryMatchByNameRule : object {
    public sealed virtual SelectedMemberInfo Match(SelectedMemberInfo expectedMember, object subject, string memberPath, IEquivalencyAssertionOptions config);
    public virtual string ToString();
}
internal abstract class FluentAssertions.Equivalency.MemberInfoSelectedMemberInfo : SelectedMemberInfo {
    private MemberInfo memberInfo;
    public string Name { get; }
    public Type DeclaringType { get; }
    protected MemberInfoSelectedMemberInfo(MemberInfo memberInfo);
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    protected bool Equals(MemberInfoSelectedMemberInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class FluentAssertions.Equivalency.MultiDimensionalArrayEquivalencyStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static Digit BuildDigitsRepresentingAllIndices(Array subjectAsArray);
    private static bool AreComparable(IEquivalencyValidationContext context, Array expectationAsArray);
    private static bool IsArray(object type);
    private static bool HaveSameDimensions(object subject, Array expectation);
    private static bool HaveSameRank(object subject, Array expectation);
}
internal class FluentAssertions.Equivalency.ObjectReference : object {
    private object object;
    private string path;
    private Nullable`1<bool> isComplexType;
    private String[] pathElements;
    public bool IsComplexType { get; }
    public ObjectReference(object object, string path, Nullable`1<bool> isComplexType);
    public virtual bool Equals(object obj);
    private String[] GetPathElements();
    private bool IsParentOf(ObjectReference other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool get_IsComplexType();
}
internal class FluentAssertions.Equivalency.Ordering.ByteArrayOrderingRule : object {
    public sealed virtual OrderStrictness Evaluate(IMemberInfo memberInfo);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Ordering.CollectionMemberOrderingRuleDecorator : object {
    private IOrderingRule orderingRule;
    public CollectionMemberOrderingRuleDecorator(IOrderingRule orderingRule);
    public sealed virtual OrderStrictness Evaluate(IMemberInfo memberInfo);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Ordering.MatchAllOrderingRule : object {
    public sealed virtual OrderStrictness Evaluate(IMemberInfo memberInfo);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule : object {
    private string path;
    public PathBasedOrderingRule(string path);
    public sealed virtual OrderStrictness Evaluate(IMemberInfo memberInfo);
    private static bool ContainsIndexingQualifiers(string path);
    private string RemoveInitialIndexQualifier(string sourcePath);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Ordering.PredicateBasedOrderingRule : object {
    private Func`2<IMemberInfo, bool> predicate;
    private string description;
    [CompilerGeneratedAttribute]
private bool <Invert>k__BackingField;
    public bool Invert { get; public set; }
    public PredicateBasedOrderingRule(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    [CompilerGeneratedAttribute]
public bool get_Invert();
    [CompilerGeneratedAttribute]
public void set_Invert(bool value);
    public sealed virtual OrderStrictness Evaluate(IMemberInfo memberInfo);
    public virtual string ToString();
}
public class FluentAssertions.Equivalency.OrderingRuleCollection : object {
    private List`1<IOrderingRule> rules;
    public OrderingRuleCollection(IEnumerable`1<IOrderingRule> orderingRules);
    public sealed virtual IEnumerator`1<IOrderingRule> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(IOrderingRule rule);
    internal void Clear();
    public bool IsOrderingStrictFor(IMemberInfo memberInfo);
}
public enum FluentAssertions.Equivalency.OrderStrictness : Enum {
    public int value__;
    public static OrderStrictness Strict;
    public static OrderStrictness NotStrict;
    public static OrderStrictness Irrelevant;
}
internal class FluentAssertions.Equivalency.PropertySelectedMemberInfo : MemberInfoSelectedMemberInfo {
    private PropertyInfo propertyInfo;
    public Type MemberType { get; }
    public PropertySelectedMemberInfo(PropertyInfo propertyInfo);
    public virtual Type get_MemberType();
    internal virtual CSharpAccessModifier GetGetAccessModifier();
    internal virtual CSharpAccessModifier GetSetAccessModifier();
    public virtual object GetValue(object obj, Object[] index);
}
public class FluentAssertions.Equivalency.ReferenceEqualityEquivalencyStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator structuralEqualityValidator, IEquivalencyAssertionOptions config);
}
public class FluentAssertions.Equivalency.RunAllUserStepsEquivalencyStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
}
public abstract class FluentAssertions.Equivalency.SelectedMemberInfo : object {
    public string Name { get; }
    public Type MemberType { get; }
    public Type DeclaringType { get; }
    public static SelectedMemberInfo Create(PropertyInfo propertyInfo);
    public static SelectedMemberInfo Create(FieldInfo fieldInfo);
    public abstract virtual string get_Name();
    public abstract virtual Type get_MemberType();
    public abstract virtual Type get_DeclaringType();
    internal abstract virtual CSharpAccessModifier GetGetAccessModifier();
    internal abstract virtual CSharpAccessModifier GetSetAccessModifier();
    public abstract virtual object GetValue(object obj, Object[] index);
}
internal class FluentAssertions.Equivalency.Selection.AllPublicFieldsSelectionRule : object {
    public bool IncludesMembers { get; }
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<SelectedMemberInfo> SelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, IMemberInfo context, IEquivalencyAssertionOptions config);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.AllPublicPropertiesSelectionRule : object {
    public bool IncludesMembers { get; }
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<SelectedMemberInfo> SelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, IMemberInfo context, IEquivalencyAssertionOptions config);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.CollectionMemberSelectionRuleDecorator : object {
    private IMemberSelectionRule selectionRule;
    public bool IncludesMembers { get; }
    public CollectionMemberSelectionRuleDecorator(IMemberSelectionRule selectionRule);
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<SelectedMemberInfo> SelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, IMemberInfo context, IEquivalencyAssertionOptions config);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.ExcludeMemberByPathSelectionRule : SelectMemberByPathSelectionRule {
    private MemberPath memberToExclude;
    public ExcludeMemberByPathSelectionRule(MemberPath pathToExclude);
    protected virtual IEnumerable`1<SelectedMemberInfo> OnSelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, string currentPath, IMemberInfo context);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.ExcludeMemberByPredicateSelectionRule : object {
    private Func`2<IMemberInfo, bool> predicate;
    private string description;
    public bool IncludesMembers { get; }
    public ExcludeMemberByPredicateSelectionRule(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<SelectedMemberInfo> SelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, IMemberInfo context, IEquivalencyAssertionOptions config);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.IncludeMemberByPathSelectionRule : SelectMemberByPathSelectionRule {
    private MemberPath memberToInclude;
    public bool IncludesMembers { get; }
    public IncludeMemberByPathSelectionRule(MemberPath pathToInclude);
    public virtual bool get_IncludesMembers();
    protected virtual IEnumerable`1<SelectedMemberInfo> OnSelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, string currentPath, IMemberInfo context);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.IncludeMemberByPredicateSelectionRule : object {
    private Func`2<IMemberInfo, bool> predicate;
    private string description;
    public bool IncludesMembers { get; }
    public IncludeMemberByPredicateSelectionRule(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<SelectedMemberInfo> SelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, IMemberInfo context, IEquivalencyAssertionOptions config);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.NestedSelectionContext : object {
    [CompilerGeneratedAttribute]
private SelectedMemberInfo <SelectedMemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedMemberPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelectedMemberDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CompileTimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RuntimeType>k__BackingField;
    public SelectedMemberInfo SelectedMemberInfo { get; private set; }
    public string SelectedMemberPath { get; private set; }
    public string SelectedMemberDescription { get; private set; }
    public Type CompileTimeType { get; private set; }
    public Type RuntimeType { get; private set; }
    public NestedSelectionContext(IMemberInfo context, SelectedMemberInfo selectedMemberInfo);
    [CompilerGeneratedAttribute]
public sealed virtual SelectedMemberInfo get_SelectedMemberInfo();
    [CompilerGeneratedAttribute]
private void set_SelectedMemberInfo(SelectedMemberInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SelectedMemberPath();
    [CompilerGeneratedAttribute]
private void set_SelectedMemberPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SelectedMemberDescription();
    [CompilerGeneratedAttribute]
private void set_SelectedMemberDescription(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_CompileTimeType();
    [CompilerGeneratedAttribute]
private void set_CompileTimeType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_RuntimeType();
    [CompilerGeneratedAttribute]
private void set_RuntimeType(Type value);
}
internal abstract class FluentAssertions.Equivalency.Selection.SelectMemberByPathSelectionRule : object {
    private string selectedPath;
    public bool IncludesMembers { get; }
    protected SelectMemberByPathSelectionRule(string selectedPath);
    public virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<SelectedMemberInfo> SelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, IMemberInfo context, IEquivalencyAssertionOptions config);
    protected abstract virtual IEnumerable`1<SelectedMemberInfo> OnSelectMembers(IEnumerable`1<SelectedMemberInfo> selectedMembers, string currentPath, IMemberInfo context);
    private static bool ContainsIndexingQualifiers(string path);
    private string RemoveInitialIndexQualifier(string propertyPath);
}
public abstract class FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1 : object {
    [DebuggerBrowsableAttribute("0")]
private List`1<IMemberSelectionRule> selectionRules;
    [DebuggerBrowsableAttribute("0")]
private List`1<IMemberMatchingRule> matchingRules;
    [DebuggerBrowsableAttribute("0")]
private List`1<IEquivalencyStep> userEquivalencySteps;
    [DebuggerBrowsableAttribute("0")]
private CyclicReferenceHandling cyclicReferenceHandling;
    [DebuggerBrowsableAttribute("0")]
protected OrderingRuleCollection orderingRules;
    [DebuggerBrowsableAttribute("0")]
private bool isRecursive;
    private bool allowInfiniteRecursion;
    private EnumEquivalencyHandling enumEquivalencyHandling;
    private bool useRuntimeTyping;
    private bool includeProperties;
    private bool includeFields;
    private ConcurrentDictionary`2<Type, bool> hasValueSemanticsMap;
    private List`1<Type> referenceTypes;
    private List`1<Type> valueTypes;
    private Func`2<Type, EqualityStrategy> getDefaultEqualityStrategy;
    [CompilerGeneratedAttribute]
private ConversionSelector <ConversionSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    private IEnumerable`1<IMemberSelectionRule> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.SelectionRules { get; }
    private IEnumerable`1<IMemberMatchingRule> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.MatchingRules { get; }
    public ConversionSelector ConversionSelector { get; }
    private OrderingRuleCollection FluentAssertions.Equivalency.IEquivalencyAssertionOptions.OrderingRules { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IsRecursive { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.AllowInfiniteRecursion { get; }
    private CyclicReferenceHandling FluentAssertions.Equivalency.IEquivalencyAssertionOptions.CyclicReferenceHandling { get; }
    private EnumEquivalencyHandling FluentAssertions.Equivalency.IEquivalencyAssertionOptions.EnumEquivalencyHandling { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.UseRuntimeTyping { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludeProperties { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludeFields { get; }
    public ITraceWriter TraceWriter { get; private set; }
    protected SelfReferenceEquivalencyAssertionOptions`1(IEquivalencyAssertionOptions defaults);
    [IteratorStateMachineAttribute("FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1/<FluentAssertions-Equivalency-IEquivalencyAssertionOptions-get_SelectionRules>d__18")]
private sealed virtual override IEnumerable`1<IMemberSelectionRule> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_SelectionRules();
    private sealed virtual override IEnumerable`1<IMemberMatchingRule> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_MatchingRules();
    private sealed virtual override IEnumerable`1<IEquivalencyStep> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.GetUserEquivalencySteps(ConversionSelector conversionSelector);
    [CompilerGeneratedAttribute]
public sealed virtual ConversionSelector get_ConversionSelector();
    private sealed virtual override OrderingRuleCollection FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_OrderingRules();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_IsRecursive();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_AllowInfiniteRecursion();
    private sealed virtual override CyclicReferenceHandling FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_CyclicReferenceHandling();
    private sealed virtual override EnumEquivalencyHandling FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_EnumEquivalencyHandling();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_UseRuntimeTyping();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_IncludeProperties();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_IncludeFields();
    private sealed virtual override EqualityStrategy FluentAssertions.Equivalency.IEquivalencyAssertionOptions.GetEqualityStrategy(Type type);
    [CompilerGeneratedAttribute]
public sealed virtual ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
private void set_TraceWriter(ITraceWriter value);
    public TSelf IncludingAllDeclaredProperties();
    public TSelf IncludingAllRuntimeProperties();
    public TSelf IncludingFields();
    public TSelf ExcludingFields();
    public TSelf IncludingProperties();
    public TSelf ExcludingProperties();
    public TSelf RespectingRuntimeTypes();
    public TSelf RespectingDeclaredTypes();
    public TSelf Excluding(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public TSelf ExcludingMissingMembers();
    public TSelf ThrowingOnMissingMembers();
    public Restriction`1<TSelf, TProperty> Using(Action`1<IAssertionContext`1<TProperty>> action);
    public TSelf IncludingNestedObjects();
    public TSelf ExcludingNestedObjects();
    public TSelf IgnoringCyclicReferences();
    public TSelf AllowingInfiniteRecursion();
    public void WithoutSelectionRules();
    public void WithoutMatchingRules();
    public TSelf Using(IMemberSelectionRule selectionRule);
    public TSelf Using(IMemberMatchingRule matchingRule);
    public TSelf Using(IAssertionRule assertionRule);
    public TSelf Using(IEquivalencyStep equivalencyStep);
    public TSelf WithStrictOrdering();
    public TSelf WithStrictOrderingFor(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public TSelf WithoutStrictOrdering();
    public TSelf WithoutStrictOrderingFor(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public TSelf ComparingEnumsByName();
    public TSelf ComparingEnumsByValue();
    public TSelf ComparingByMembers();
    public TSelf ComparingByValue();
    public TSelf WithTracing(ITraceWriter writer);
    public TSelf WithAutoConversion();
    public TSelf WithAutoConversionFor(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public TSelf WithoutAutoConversionFor(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public virtual string ToString();
    protected void RemoveSelectionRule();
    private void ClearMatchingRules();
    protected TSelf AddSelectionRule(IMemberSelectionRule selectionRule);
    private TSelf AddMatchingRule(IMemberMatchingRule matchingRule);
    private TSelf AddEquivalencyStep(IEquivalencyStep equivalencyStep);
}
public class FluentAssertions.Equivalency.SimpleEqualityEquivalencyStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator structuralEqualityValidator, IEquivalencyAssertionOptions config);
}
public class FluentAssertions.Equivalency.StringBuilderTraceWriter : object {
    private StringBuilder builder;
    private int depth;
    public sealed virtual void AddSingle(string trace);
    public sealed virtual IDisposable AddBlock(string trace);
    private void WriteLine(string trace);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <AddBlock>b__3_0();
}
public class FluentAssertions.Equivalency.StringEqualityEquivalencyStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static bool ValidateAgainstNulls(IEquivalencyValidationContext context);
    private static bool ValidateAgainstType(IEquivalencyValidationContext context);
    private static string GetSubjectDescription(IEquivalencyValidationContext context);
}
public class FluentAssertions.Equivalency.StructuralEqualityEquivalencyStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config);
    private static void AssertMemberEquality(IEquivalencyValidationContext context, IEquivalencyValidator parent, SelectedMemberInfo selectedMemberInfo, IEquivalencyAssertionOptions config);
    private static SelectedMemberInfo FindMatchFor(SelectedMemberInfo selectedMemberInfo, IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    internal IEnumerable`1<SelectedMemberInfo> GetSelectedMembers(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
}
[ExtensionAttribute]
public static class FluentAssertions.Equivalency.SubjectInfoExtensions : object {
    [ExtensionAttribute]
public static bool WhichSetterHas(IMemberInfo memberInfo, CSharpAccessModifier accessModifier);
    [ExtensionAttribute]
public static bool WhichSetterDoesNotHave(IMemberInfo memberInfo, CSharpAccessModifier accessModifier);
    [ExtensionAttribute]
public static bool WhichGetterHas(IMemberInfo memberInfo, CSharpAccessModifier accessModifier);
    [ExtensionAttribute]
public static bool WhichGetterDoesNotHave(IMemberInfo memberInfo, CSharpAccessModifier accessModifier);
}
public class FluentAssertions.Equivalency.TryConversionStep : object {
    private ConversionSelector selector;
    public TryConversionStep(ConversionSelector selector);
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator structuralEqualityValidator, IEquivalencyAssertionOptions config);
    private static bool TryChangeType(object subject, Type expectationType, Object& conversionResult);
    public virtual string ToString();
}
public class FluentAssertions.Equivalency.ValueTypeEquivalencyStep : object {
    public sealed virtual bool CanHandle(IEquivalencyValidationContext context, IEquivalencyAssertionOptions config);
    public sealed virtual bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator structuralEqualityValidator, IEquivalencyAssertionOptions config);
}
public class FluentAssertions.EquivalencyStepCollection : object {
    private List`1<IEquivalencyStep> steps;
    public sealed virtual IEnumerator`1<IEquivalencyStep> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add();
    public void AddAfter();
    public void Insert();
    public void InsertBefore();
    public void Remove();
    public void Clear();
    public void Reset();
    private static List`1<IEquivalencyStep> GetDefaultSteps();
}
[ExtensionAttribute]
public static class FluentAssertions.EventRaisingExtensions : object {
    [ExtensionAttribute]
public static IEventRecorder WithSender(IEventRecorder eventRecorder, object expectedSender);
    [ExtensionAttribute]
public static IEventRecorder WithArgs(IEventRecorder eventRecorder, Expression`1<Func`2<T, bool>> predicate);
    [ExtensionAttribute]
public static IEventRecorder WithArgs(IEventRecorder eventRecorder, Expression`1[] predicates);
}
public class FluentAssertions.Events.EventAssertions`1 : ReferenceTypeAssertions`2<T, EventAssertions`1<T>> {
    private IMonitor`1<T> monitor;
    private static string PropertyChangedEventName;
    protected string Identifier { get; }
    protected internal EventAssertions`1(IMonitor`1<T> monitor);
    public IEventRecorder Raise(string eventName, string because, Object[] becauseArgs);
    public void NotRaise(string eventName, string because, Object[] becauseArgs);
    public IEventRecorder RaisePropertyChangeFor(Expression`1<Func`2<T, object>> propertyExpression, string because, Object[] becauseArgs);
    public void NotRaisePropertyChangeFor(Expression`1<Func`2<T, object>> propertyExpression, string because, Object[] becauseArgs);
    private static string GetAffectedPropertyName(RecordedEvent event);
    protected virtual string get_Identifier();
}
internal static class FluentAssertions.Events.EventHandlerFactory : object {
    public static Delegate GenerateHandler(Type eventSignature, IEventRecorder recorder);
    private static Type GetDelegateReturnType(Type d);
    private static Type[] GetDelegateParameterTypes(Type d);
    private static Type[] AppendParameterListThisReference(Type[] parameters);
    private static bool TypeIsDelegate(Type d);
    private static MethodInfo DelegateInvokeMethod(Type d);
}
public class FluentAssertions.Events.EventMetadata : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HandlerType>k__BackingField;
    public string EventName { get; }
    public Type HandlerType { get; }
    public EventMetadata(string eventName, Type handlerType);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public Type get_HandlerType();
}
internal class FluentAssertions.Events.EventMonitor`1 : object {
    private WeakReference subject;
    private ConcurrentDictionary`2<string, IEventRecorder> recorderMap;
    public T Subject { get; }
    public EventMetadata[] MonitoredEvents { get; }
    public OccurredEvent[] OccurredEvents { get; }
    public EventMonitor`1(object eventSource, Func`1<DateTime> utcNow);
    public sealed virtual T get_Subject();
    public sealed virtual EventMetadata[] get_MonitoredEvents();
    public sealed virtual OccurredEvent[] get_OccurredEvents();
    public sealed virtual void Clear();
    public sealed virtual EventAssertions`1<T> Should();
    private void Attach(Type typeDefiningEventsToMonitor, Func`1<DateTime> utcNow);
    private EventInfo[] GetPublicEvents(Type type);
    public sealed virtual void Dispose();
    private void AttachEventHandler(EventInfo eventInfo, Func`1<DateTime> utcNow);
    public sealed virtual IEventRecorder GetEventRecorder(string eventName);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Events.EventRecorder : object {
    private Func`1<DateTime> utcNow;
    private BlockingCollection`1<RecordedEvent> raisedEvents;
    private object lockable;
    private WeakReference eventObject;
    private Action cleanup;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EventHandlerType>k__BackingField;
    public object EventObject { get; private set; }
    public string EventName { get; }
    public Type EventHandlerType { get; private set; }
    public EventRecorder(object eventRaiser, string eventName, Func`1<DateTime> utcNow);
    public sealed virtual object get_EventObject();
    private void set_EventObject(object value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EventName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventHandlerType();
    [CompilerGeneratedAttribute]
private void set_EventHandlerType(Type value);
    public void Attach(WeakReference subject, EventInfo eventInfo);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<RecordedEvent> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void RecordEvent(Object[] parameters);
    public sealed virtual void Reset();
}
public interface FluentAssertions.Events.IEventRecorder {
    public object EventObject { get; }
    public string EventName { get; }
    public Type EventHandlerType { get; }
    public abstract virtual void RecordEvent(Object[] parameters);
    public abstract virtual void Reset();
    public abstract virtual object get_EventObject();
    public abstract virtual string get_EventName();
    public abstract virtual Type get_EventHandlerType();
}
public interface FluentAssertions.Events.IMonitor`1 {
    public T Subject { get; }
    public EventMetadata[] MonitoredEvents { get; }
    public OccurredEvent[] OccurredEvents { get; }
    public abstract virtual T get_Subject();
    public abstract virtual void Clear();
    public abstract virtual EventAssertions`1<T> Should();
    public abstract virtual IEventRecorder GetEventRecorder(string eventName);
    public abstract virtual EventMetadata[] get_MonitoredEvents();
    public abstract virtual OccurredEvent[] get_OccurredEvents();
}
public class FluentAssertions.Events.OccurredEvent : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimestampUtc>k__BackingField;
    public string EventName { get; public set; }
    public Object[] Parameters { get; public set; }
    public DateTime TimestampUtc { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public void set_EventName(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(Object[] value);
    [CompilerGeneratedAttribute]
public DateTime get_TimestampUtc();
    [CompilerGeneratedAttribute]
public void set_TimestampUtc(DateTime value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Events.RecordedEvent : object {
    private Object[] parameters;
    [CompilerGeneratedAttribute]
private DateTime <TimestampUtc>k__BackingField;
    public DateTime TimestampUtc { get; public set; }
    public IEnumerable`1<object> Parameters { get; private set; }
    public RecordedEvent(DateTime utcNow, object monitoredObject, Object[] parameters);
    [CompilerGeneratedAttribute]
public DateTime get_TimestampUtc();
    [CompilerGeneratedAttribute]
public void set_TimestampUtc(DateTime value);
    public IEnumerable`1<object> get_Parameters();
    private void set_Parameters(IEnumerable`1<object> value);
}
public static class FluentAssertions.Exactly : object {
    public static OccurrenceConstraint Once();
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
public class FluentAssertions.Execution.AssertionFailedException : Exception {
    public AssertionFailedException(string message);
    protected AssertionFailedException(SerializationInfo info, StreamingContext context);
}
public class FluentAssertions.Execution.AssertionScope : object {
    private IAssertionStrategy assertionStrategy;
    private ContextDataItems contextData;
    private Func`1<string> reason;
    private bool useLineBreaks;
    private static AsyncLocal`1<AssertionScope> current;
    private AssertionScope parent;
    private Func`1<string> expectation;
    private string fallbackIdentifier;
    private Nullable`1<bool> succeeded;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    public string Context { get; public set; }
    public static AssertionScope Current { get; private set; }
    public AssertionScope UsingLineBreaks { get; }
    public bool Succeeded { get; }
    private IAssertionScope FluentAssertions.Execution.IAssertionScope.UsingLineBreaks { get; }
    internal AssertionScope(IAssertionStrategy assertionStrategy, AssertionScope parent);
    public AssertionScope(IAssertionStrategy assertionStrategy);
    public AssertionScope(string context);
    private static AssertionScope();
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    public static AssertionScope get_Current();
    private static void set_Current(AssertionScope value);
    public AssertionScope get_UsingLineBreaks();
    public sealed virtual bool get_Succeeded();
    public AssertionScope BecauseOf(string because, Object[] becauseArgs);
    public AssertionScope WithExpectation(string message, Object[] args);
    internal void TrackComparands(object subject, object expectation);
    public sealed virtual Continuation ClearExpectation();
    public sealed virtual GivenSelector`1<T> Given(Func`1<T> selector);
    public AssertionScope ForCondition(bool condition);
    public sealed virtual Continuation FailWith(Func`1<FailReason> failReasonFunc);
    internal Continuation FailWithPreFormatted(string formattedFailReason);
    private Continuation FailWith(Func`1<string> failReasonFunc);
    public sealed virtual Continuation FailWith(string message, Object[] args);
    private string GetIdentifier();
    public void AddPreFormattedFailure(string formattedFailureMessage);
    public void AddNonReportable(string key, object value);
    public void AddReportable(string key, string value);
    public sealed virtual String[] Discard();
    public bool HasFailures();
    public T Get(string key);
    public sealed virtual void Dispose();
    public AssertionScope WithDefaultIdentifier(string identifier);
    private static AssertionScope GetCurrentAssertionScope();
    private static void SetCurrentAssertionScope(AssertionScope scope);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.ForCondition(bool condition);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.BecauseOf(string because, Object[] becauseArgs);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.WithExpectation(string message, Object[] args);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.WithDefaultIdentifier(string identifier);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.get_UsingLineBreaks();
}
internal class FluentAssertions.Execution.CollectingAssertionStrategy : object {
    private List`1<string> failureMessages;
    public IEnumerable`1<string> FailureMessages { get; }
    public sealed virtual IEnumerable`1<string> get_FailureMessages();
    public sealed virtual IEnumerable`1<string> DiscardFailures();
    public sealed virtual void ThrowIfAny(IDictionary`2<string, object> context);
    public sealed virtual void HandleFailure(string message);
}
internal class FluentAssertions.Execution.ContextDataItems : object {
    private List`1<DataItem> items;
    public IDictionary`2<string, object> GetReportable();
    public string AsStringOrDefault(string key);
    public void Add(ContextDataItems contextDataItems);
    public void Add(DataItem item);
    public T Get(string key);
}
public class FluentAssertions.Execution.Continuation : object {
    private AssertionScope sourceScope;
    [CompilerGeneratedAttribute]
private bool <SourceSucceeded>k__BackingField;
    public IAssertionScope Then { get; }
    public bool SourceSucceeded { get; }
    public Continuation(AssertionScope sourceScope, bool sourceSucceeded);
    public IAssertionScope get_Then();
    [CompilerGeneratedAttribute]
public bool get_SourceSucceeded();
    public static bool op_Implicit(Continuation continuation);
}
public class FluentAssertions.Execution.ContinuationOfGiven`1 : object {
    private bool succeeded;
    [CompilerGeneratedAttribute]
private GivenSelector`1<TSubject> <Then>k__BackingField;
    public GivenSelector`1<TSubject> Then { get; }
    public ContinuationOfGiven`1(GivenSelector`1<TSubject> parent, bool succeeded);
    [CompilerGeneratedAttribute]
public GivenSelector`1<TSubject> get_Then();
    public static bool op_Implicit(ContinuationOfGiven`1<TSubject> continuationOfGiven);
}
public class FluentAssertions.Execution.ContinuedAssertionScope : object {
    private AssertionScope predecessor;
    private bool predecessorSucceeded;
    public IAssertionScope UsingLineBreaks { get; }
    public bool Succeeded { get; }
    public ContinuedAssertionScope(AssertionScope predecessor, bool predecessorSucceeded);
    public sealed virtual GivenSelector`1<T> Given(Func`1<T> selector);
    public sealed virtual IAssertionScope ForCondition(bool condition);
    public sealed virtual Continuation FailWith(Func`1<FailReason> failReasonFunc);
    public sealed virtual Continuation FailWith(string message, Object[] args);
    public sealed virtual IAssertionScope BecauseOf(string because, Object[] becauseArgs);
    public sealed virtual Continuation ClearExpectation();
    public sealed virtual IAssertionScope WithExpectation(string message, Object[] args);
    public sealed virtual IAssertionScope WithDefaultIdentifier(string identifier);
    public sealed virtual IAssertionScope get_UsingLineBreaks();
    public sealed virtual bool get_Succeeded();
    public sealed virtual String[] Discard();
    public sealed virtual void Dispose();
}
internal class FluentAssertions.Execution.DefaultAssertionStrategy : object {
    public IEnumerable`1<string> FailureMessages { get; }
    public sealed virtual IEnumerable`1<string> get_FailureMessages();
    public sealed virtual void HandleFailure(string message);
    public sealed virtual IEnumerable`1<string> DiscardFailures();
    public sealed virtual void ThrowIfAny(IDictionary`2<string, object> context);
}
public static class FluentAssertions.Execution.Execute : object {
    public static AssertionScope Assertion { get; }
    public static AssertionScope get_Assertion();
}
public class FluentAssertions.Execution.FailReason : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public string Message { get; }
    public Object[] Args { get; }
    public FailReason(string message, Object[] args);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Object[] get_Args();
}
internal class FluentAssertions.Execution.FallbackTestFramework : object {
    public bool IsAvailable { get; }
    public sealed virtual bool get_IsAvailable();
    public sealed virtual void Throw(string message);
}
internal class FluentAssertions.Execution.GallioTestFramework : object {
    private Assembly assembly;
    public bool IsAvailable { get; }
    private static string AssemblyName { get; }
    public sealed virtual void Throw(string message);
    public sealed virtual bool get_IsAvailable();
    private static string get_AssemblyName();
}
public class FluentAssertions.Execution.GivenSelector`1 : object {
    private T subject;
    private bool predecessorSucceeded;
    private AssertionScope predecessor;
    public GivenSelector`1(Func`1<T> selector, bool predecessorSucceeded, AssertionScope predecessor);
    public GivenSelector`1<T> ForCondition(Func`2<T, bool> predicate);
    public GivenSelector`1<TOut> Given(Func`2<T, TOut> selector);
    public ContinuationOfGiven`1<T> FailWith(string message);
    public ContinuationOfGiven`1<T> FailWith(string message, Func`2[] args);
    public ContinuationOfGiven`1<T> FailWith(string message, Object[] args);
    public ContinuationOfGiven`1<T> ClearExpectation();
    [CompilerGeneratedAttribute]
private object <FailWith>b__7_0(Func`2<T, object> a);
}
[ExtensionAttribute]
internal static class FluentAssertions.Execution.GivenSelectorExtensions : object {
    [ExtensionAttribute]
public static ContinuationOfGiven`1<IEnumerable`1<T>> AssertCollectionIsNotNull(GivenSelector`1<IEnumerable`1<T>> givenSelector);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertEitherCollectionIsNotEmpty(GivenSelector`1<ICollection`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertCollectionHasEnoughItems(GivenSelector`1<IEnumerable`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertCollectionHasEnoughItems(GivenSelector`1<ICollection`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertCollectionHasNotTooManyItems(GivenSelector`1<ICollection`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertCollectionsHaveSameCount(GivenSelector`1<ICollection`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<TActual>> AssertCollectionsHaveSameItems(GivenSelector`1<ICollection`1<TActual>> givenSelector, ICollection`1<TExpected> expected, Func`3<ICollection`1<TActual>, ICollection`1<TExpected>, int> findIndex);
}
public interface FluentAssertions.Execution.IAssertionScope {
    public IAssertionScope UsingLineBreaks { get; }
    public bool Succeeded { get; }
    public abstract virtual GivenSelector`1<T> Given(Func`1<T> selector);
    public abstract virtual IAssertionScope ForCondition(bool condition);
    public abstract virtual Continuation FailWith(Func`1<FailReason> failReasonFunc);
    public abstract virtual Continuation FailWith(string message, Object[] args);
    public abstract virtual IAssertionScope BecauseOf(string because, Object[] becauseArgs);
    public abstract virtual Continuation ClearExpectation();
    public abstract virtual IAssertionScope WithExpectation(string message, Object[] args);
    public abstract virtual IAssertionScope WithDefaultIdentifier(string identifier);
    public abstract virtual IAssertionScope get_UsingLineBreaks();
    public abstract virtual bool get_Succeeded();
    public abstract virtual String[] Discard();
}
public interface FluentAssertions.Execution.IAssertionStrategy {
    public IEnumerable`1<string> FailureMessages { get; }
    public abstract virtual IEnumerable`1<string> get_FailureMessages();
    public abstract virtual void HandleFailure(string message);
    public abstract virtual IEnumerable`1<string> DiscardFailures();
    public abstract virtual void ThrowIfAny(IDictionary`2<string, object> context);
}
public interface FluentAssertions.Execution.ICloneable2 {
    public abstract virtual object Clone();
}
internal interface FluentAssertions.Execution.ITestFramework {
    public bool IsAvailable { get; }
    public abstract virtual bool get_IsAvailable();
    public abstract virtual void Throw(string message);
}
internal abstract class FluentAssertions.Execution.LateBoundTestFramework : object {
    private Assembly assembly;
    public bool IsAvailable { get; }
    protected string AssemblyName { get; }
    protected string ExceptionFullName { get; }
    public sealed virtual void Throw(string message);
    public sealed virtual bool get_IsAvailable();
    protected abstract virtual string get_AssemblyName();
    protected abstract virtual string get_ExceptionFullName();
}
internal class FluentAssertions.Execution.MbUnitTestFramework : LateBoundTestFramework {
    protected string AssemblyName { get; }
    protected string ExceptionFullName { get; }
    protected virtual string get_AssemblyName();
    protected virtual string get_ExceptionFullName();
}
internal class FluentAssertions.Execution.MessageBuilder : object {
    private bool useLineBreaks;
    private Char[] blanks;
    public MessageBuilder(bool useLineBreaks);
    public string Build(string message, Object[] messageArgs, string reason, ContextDataItems contextData, string identifier, string fallbackIdentifier);
    private static string SubstituteIdentifier(string message, string identifier, string fallbackIdentifier);
    private static string SubstituteContextualTags(string message, ContextDataItems contextData);
    private string FormatArgumentPlaceholders(string failureMessage, Object[] failureArgs);
    private string SanitizeReason(string reason);
    private string EnsurePrefix(string prefix, string text);
    private string ExtractLeadingBlanksFrom(string text);
    private bool StartsWithBlank(string text);
    [CompilerGeneratedAttribute]
private string <FormatArgumentPlaceholders>b__6_0(object a);
}
internal class FluentAssertions.Execution.MSpecFramework : LateBoundTestFramework {
    protected string AssemblyName { get; }
    protected string ExceptionFullName { get; }
    protected virtual string get_AssemblyName();
    protected virtual string get_ExceptionFullName();
}
internal class FluentAssertions.Execution.MSTestFramework : LateBoundTestFramework {
    protected string ExceptionFullName { get; }
    protected string AssemblyName { get; }
    protected virtual string get_ExceptionFullName();
    protected virtual string get_AssemblyName();
}
internal class FluentAssertions.Execution.MSTestFrameworkV2 : LateBoundTestFramework {
    protected string ExceptionFullName { get; }
    protected string AssemblyName { get; }
    protected virtual string get_ExceptionFullName();
    protected virtual string get_AssemblyName();
}
internal class FluentAssertions.Execution.NSpec1Framework : object {
    private Assembly assembly;
    public bool IsAvailable { get; }
    public sealed virtual bool get_IsAvailable();
    public sealed virtual void Throw(string message);
}
internal class FluentAssertions.Execution.NSpecFramework : object {
    private Assembly assembly;
    public bool IsAvailable { get; }
    public sealed virtual bool get_IsAvailable();
    public sealed virtual void Throw(string message);
}
internal class FluentAssertions.Execution.NUnitTestFramework : LateBoundTestFramework {
    protected string AssemblyName { get; }
    protected string ExceptionFullName { get; }
    protected virtual string get_AssemblyName();
    protected virtual string get_ExceptionFullName();
}
internal static class FluentAssertions.Execution.TestFrameworkProvider : object {
    private static Dictionary`2<string, ITestFramework> frameworks;
    private static ITestFramework testFramework;
    private static TestFrameworkProvider();
    public static void Throw(string message);
    private static ITestFramework DetectFramework();
    private static ITestFramework AttemptToDetectUsingAppSetting();
    private static ITestFramework AttemptToDetectUsingDynamicScanning();
}
internal class FluentAssertions.Execution.XUnit2TestFramework : object {
    private Assembly assembly;
    public bool IsAvailable { get; }
    public sealed virtual bool get_IsAvailable();
    public sealed virtual void Throw(string message);
}
internal class FluentAssertions.Execution.XUnitTestFramework : LateBoundTestFramework {
    protected string AssemblyName { get; }
    protected string ExceptionFullName { get; }
    protected virtual string get_AssemblyName();
    protected virtual string get_ExceptionFullName();
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.Extensions.FluentDateTimeExtensions : object {
    [ExtensionAttribute]
public static DateTime January(int day, int year);
    [ExtensionAttribute]
public static DateTime February(int day, int year);
    [ExtensionAttribute]
public static DateTime March(int day, int year);
    [ExtensionAttribute]
public static DateTime April(int day, int year);
    [ExtensionAttribute]
public static DateTime May(int day, int year);
    [ExtensionAttribute]
public static DateTime June(int day, int year);
    [ExtensionAttribute]
public static DateTime July(int day, int year);
    [ExtensionAttribute]
public static DateTime August(int day, int year);
    [ExtensionAttribute]
public static DateTime September(int day, int year);
    [ExtensionAttribute]
public static DateTime October(int day, int year);
    [ExtensionAttribute]
public static DateTime November(int day, int year);
    [ExtensionAttribute]
public static DateTime December(int day, int year);
    [ExtensionAttribute]
public static DateTime At(DateTime date, TimeSpan time);
    [ExtensionAttribute]
public static DateTime At(DateTime date, int hours, int minutes, int seconds, int milliseconds, int microseconds, int nanoseconds);
    [ExtensionAttribute]
public static DateTimeOffset At(DateTimeOffset date, int hours, int minutes, int seconds, int milliseconds, int microseconds, int nanoseconds);
    [ExtensionAttribute]
public static DateTime AsUtc(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime AsLocal(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime Before(TimeSpan timeDifference, DateTime sourceDateTime);
    [ExtensionAttribute]
public static DateTime After(TimeSpan timeDifference, DateTime sourceDateTime);
    [ExtensionAttribute]
public static int Nanosecond(DateTime self);
    [ExtensionAttribute]
public static int Nanosecond(DateTimeOffset self);
    [ExtensionAttribute]
public static DateTime AddNanoseconds(DateTime self, long nanoseconds);
    [ExtensionAttribute]
public static DateTimeOffset AddNanoseconds(DateTimeOffset self, long nanoseconds);
    [ExtensionAttribute]
public static int Microsecond(DateTime self);
    [ExtensionAttribute]
public static int Microsecond(DateTimeOffset self);
    [ExtensionAttribute]
public static DateTime AddMicroseconds(DateTime self, long microseconds);
    [ExtensionAttribute]
public static DateTimeOffset AddMicroseconds(DateTimeOffset self, long microseconds);
}
[ExtensionAttribute]
public static class FluentAssertions.Extensions.FluentTimeSpanExtensions : object {
    public static long TicksPerMicrosecond;
    public static double TicksPerNanosecond;
    [ExtensionAttribute]
public static TimeSpan Ticks(int ticks);
    [ExtensionAttribute]
public static TimeSpan Ticks(long ticks);
    [ExtensionAttribute]
public static int Nanoseconds(TimeSpan self);
    [ExtensionAttribute]
public static TimeSpan Nanoseconds(int nanoseconds);
    [ExtensionAttribute]
public static TimeSpan Nanoseconds(long nanoseconds);
    [ExtensionAttribute]
public static double TotalNanoseconds(TimeSpan self);
    [ExtensionAttribute]
public static int Microseconds(TimeSpan self);
    [ExtensionAttribute]
public static TimeSpan Microseconds(int microseconds);
    [ExtensionAttribute]
public static TimeSpan Microseconds(long microseconds);
    [ExtensionAttribute]
public static double TotalMicroseconds(TimeSpan self);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(int milliseconds);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(double milliseconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(int seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(double seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(int seconds, TimeSpan offset);
    [ExtensionAttribute]
public static TimeSpan Minutes(int minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(double minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(int minutes, TimeSpan offset);
    [ExtensionAttribute]
public static TimeSpan Hours(int hours);
    [ExtensionAttribute]
public static TimeSpan Hours(double hours);
    [ExtensionAttribute]
public static TimeSpan Hours(int hours, TimeSpan offset);
    [ExtensionAttribute]
public static TimeSpan Days(int days);
    [ExtensionAttribute]
public static TimeSpan Days(double days);
    [ExtensionAttribute]
public static TimeSpan Days(int days, TimeSpan offset);
    [ExtensionAttribute]
public static TimeSpan And(TimeSpan sourceTime, TimeSpan offset);
}
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.FluentActions : object {
    [PureAttribute]
public static Action Invoking(Action action);
    [PureAttribute]
public static Func`1<T> Invoking(Func`1<T> func);
    [PureAttribute]
public static Func`1<Task> Awaiting(Func`1<Task> action);
    [PureAttribute]
public static Func`1<Task`1<T>> Awaiting(Func`1<Task`1<T>> func);
    [PureAttribute]
public static Action Enumerating(Func`1<IEnumerable> enumerable);
    [PureAttribute]
public static Action Enumerating(Func`1<IEnumerable`1<T>> enumerable);
}
public class FluentAssertions.Formatting.AggregateExceptionValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.AttributeBasedFormatter : object {
    private MethodInfo[] formatters;
    private ValueFormatterDetectionMode detectionMode;
    private static bool IsScanningEnabled { get; }
    public MethodInfo[] Formatters { get; }
    public sealed virtual bool CanHandle(object value);
    private static bool get_IsScanningEnabled();
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
    private MethodInfo GetFormatter(object value);
    public MethodInfo[] get_Formatters();
    private void HandleValueFormatterDetectionModeChanges();
    private static MethodInfo[] FindCustomFormatters();
    private static bool Applicable(Assembly assembly);
}
public class FluentAssertions.Formatting.ByteValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.DateTimeOffsetValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
    private static bool HasTime(DateTimeOffset dateTime);
    private static bool HasDate(DateTimeOffset dateTime);
    private static bool HasMilliSeconds(DateTimeOffset dateTime);
    private static bool HasMicroSeconds(DateTimeOffset dateTime);
    private static bool HasNanoSeconds(DateTimeOffset dateTime);
}
public class FluentAssertions.Formatting.DecimalValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.DefaultValueFormatter : object {
    private static int RootLevel;
    private static int SpacesPerIndentionLevel;
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
    private static bool HasDefaultToStringImplementation(object value);
    private static string GetTypeAndPublicPropertyValues(object obj, FormattingContext context, FormatChild formatChild);
    private static string GetPropertyValueTextFor(object value, SelectedMemberInfo selectedMemberInfo, FormattingContext context, FormatChild formatChild);
    private static string CreateWhitespaceForLevel(int level);
}
public class FluentAssertions.Formatting.DoubleValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.EnumerableValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.ExceptionValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.ExpressionValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.FormatChild : MulticastDelegate {
    public FormatChild(object object, IntPtr method);
    public virtual string Invoke(string childPath, object value);
    public virtual IAsyncResult BeginInvoke(string childPath, object value, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public static class FluentAssertions.Formatting.Formatter : object {
    private static List`1<IValueFormatter> customFormatters;
    private static List`1<IValueFormatter> defaultFormatters;
    [ThreadStaticAttribute]
private static bool isReentry;
    public static IEnumerable`1<IValueFormatter> Formatters { get; }
    private static Formatter();
    public static IEnumerable`1<IValueFormatter> get_Formatters();
    public static string ToString(object value, bool useLineBreaks);
    private static string FormatChild(string path, object childValue, bool useLineBreaks, ObjectGraph graph);
    private static string Format(object value, FormattingContext context, FormatChild formatChild);
    public static void RemoveFormatter(IValueFormatter formatter);
    public static void AddFormatter(IValueFormatter formatter);
}
public class FluentAssertions.Formatting.FormattingContext : object {
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLineBreaks>k__BackingField;
    public int Depth { get; public set; }
    public bool UseLineBreaks { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(int value);
    [CompilerGeneratedAttribute]
public bool get_UseLineBreaks();
    [CompilerGeneratedAttribute]
public void set_UseLineBreaks(bool value);
}
public class FluentAssertions.Formatting.GuidValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.Int16ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.Int32ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.Int64ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public interface FluentAssertions.Formatting.IValueFormatter {
    public abstract virtual bool CanHandle(object value);
    public abstract virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.MultidimensionalArrayFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
    private bool IsFirstIteration(Array arr, int index, int dimension);
    private bool IsInnerMostLoop(Array arr, int index);
    private bool IsLastIteration(Array arr, int index, int dimension);
}
public class FluentAssertions.Formatting.NullValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.PropertyInfoFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.SByteValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.SingleValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.StringValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.TaskFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.TimeSpanValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
    private static List`1<string> GetNonZeroFragments(TimeSpan timeSpan);
    private static void AddMicrosecondsIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static void AddSecondsIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static void AddMinutesIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static void AddHoursIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static void AddDaysIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static string JoinUsingWritingStyle(IEnumerable`1<string> fragments);
    private static String[] AllButLastFragment(IEnumerable`1<string> fragments);
}
public class FluentAssertions.Formatting.UInt16ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.UInt32ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.UInt64ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
[AttributeUsageAttribute("64")]
public class FluentAssertions.Formatting.ValueFormatterAttribute : Attribute {
}
public class FluentAssertions.Formatting.XAttributeValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.XDocumentValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
    private string FormatDocumentWithoutRoot();
}
public class FluentAssertions.Formatting.XElementValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
    private static string FormatElementWithoutChildren(XElement element);
    private static string FormatElementWithChildren(XElement element);
    private static String[] SplitIntoSeparateLines(XElement element);
}
public static class FluentAssertions.LessThan : object {
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
public static class FluentAssertions.MoreThan : object {
    public static OccurrenceConstraint Once();
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Numeric.ComparableTypeAssertions`1 : ReferenceTypeAssertions`2<IComparable`1<T>, ComparableTypeAssertions`1<T>> {
    private static int Equal;
    protected string Identifier { get; }
    public ComparableTypeAssertions`1(IComparable`1<T> value);
    public AndConstraint`1<ComparableTypeAssertions`1<T>> Be(T expected, string because, Object[] becauseArgs);
    public void BeEquivalentTo(TExpectation expectation, string because, Object[] becauseArgs);
    public void BeEquivalentTo(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<ComparableTypeAssertions`1<T>> NotBe(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<ComparableTypeAssertions`1<T>> BeLessThan(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<ComparableTypeAssertions`1<T>> BeLessOrEqualTo(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<ComparableTypeAssertions`1<T>> BeGreaterThan(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<ComparableTypeAssertions`1<T>> BeGreaterOrEqualTo(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<ComparableTypeAssertions`1<T>> BeInRange(T minimumValue, T maximumValue, string because, Object[] becauseArgs);
    public AndConstraint`1<ComparableTypeAssertions`1<T>> NotBeInRange(T minimumValue, T maximumValue, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Numeric.NullableNumericAssertions`1 : NumericAssertions`1<T> {
    public NullableNumericAssertions`1(Nullable`1<T> value);
    public AndConstraint`1<NullableNumericAssertions`1<T>> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableNumericAssertions`1<T>> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableNumericAssertions`1<T>> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableNumericAssertions`1<T>> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableNumericAssertions`1<T>> Match(Expression`1<Func`2<Nullable`1<T>, bool>> predicate, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Numeric.NumericAssertions`1 : object {
    [CompilerGeneratedAttribute]
private IComparable <Subject>k__BackingField;
    public IComparable Subject { get; private set; }
    public NumericAssertions`1(object value);
    [CompilerGeneratedAttribute]
public IComparable get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(IComparable value);
    public AndConstraint`1<NumericAssertions`1<T>> Be(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> Be(Nullable`1<T> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> NotBe(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> NotBe(Nullable`1<T> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> BePositive(string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> BeNegative(string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> BeLessThan(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> BeLessOrEqualTo(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> BeGreaterThan(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> BeGreaterOrEqualTo(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> BeInRange(T minimumValue, T maximumValue, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> NotBeInRange(T minimumValue, T maximumValue, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> BeOneOf(T[] validValues);
    public AndConstraint`1<NumericAssertions`1<T>> BeOneOf(IEnumerable`1<T> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> BeOfType(Type expectedType, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> NotBeOfType(Type unexpectedType, string because, Object[] becauseArgs);
    public AndConstraint`1<NumericAssertions`1<T>> Match(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
}
[ExtensionAttribute]
public static class FluentAssertions.NumericAssertionsExtensions : object {
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<sbyte>> BeCloseTo(NumericAssertions`1<sbyte> parent, sbyte nearbyValue, byte delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<byte>> BeCloseTo(NumericAssertions`1<byte> parent, byte nearbyValue, byte delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<short>> BeCloseTo(NumericAssertions`1<short> parent, short nearbyValue, ushort delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<ushort>> BeCloseTo(NumericAssertions`1<ushort> parent, ushort nearbyValue, ushort delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<int>> BeCloseTo(NumericAssertions`1<int> parent, int nearbyValue, UInt32 delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<UInt32>> BeCloseTo(NumericAssertions`1<UInt32> parent, UInt32 nearbyValue, UInt32 delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<long>> BeCloseTo(NumericAssertions`1<long> parent, long nearbyValue, ulong delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<ulong>> BeCloseTo(NumericAssertions`1<ulong> parent, ulong nearbyValue, ulong delta, string because, Object[] becauseArgs);
    private static void FailIfValueOutsideBounds(bool valueWithinBounds, TValue nearbyValue, TDelta delta, TValue actualValue, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<sbyte>> NotBeCloseTo(NumericAssertions`1<sbyte> parent, sbyte distantValue, byte delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<byte>> NotBeCloseTo(NumericAssertions`1<byte> parent, byte distantValue, byte delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<short>> NotBeCloseTo(NumericAssertions`1<short> parent, short distantValue, ushort delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<ushort>> NotBeCloseTo(NumericAssertions`1<ushort> parent, ushort distantValue, ushort delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<int>> NotBeCloseTo(NumericAssertions`1<int> parent, int distantValue, UInt32 delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<UInt32>> NotBeCloseTo(NumericAssertions`1<UInt32> parent, UInt32 distantValue, UInt32 delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<long>> NotBeCloseTo(NumericAssertions`1<long> parent, long distantValue, ulong delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<ulong>> NotBeCloseTo(NumericAssertions`1<ulong> parent, ulong distantValue, ulong delta, string because, Object[] becauseArgs);
    private static void FailIfValueInsideBounds(bool valueOutsideBounds, TValue distantValue, TDelta delta, TValue actualValue, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<float>> BeApproximately(NullableNumericAssertions`1<float> parent, float expectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<float>> BeApproximately(NullableNumericAssertions`1<float> parent, Nullable`1<float> expectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<float>> BeApproximately(NumericAssertions`1<float> parent, float expectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<double>> BeApproximately(NullableNumericAssertions`1<double> parent, double expectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<double>> BeApproximately(NullableNumericAssertions`1<double> parent, Nullable`1<double> expectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<double>> BeApproximately(NumericAssertions`1<double> parent, double expectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<decimal>> BeApproximately(NullableNumericAssertions`1<decimal> parent, decimal expectedValue, decimal precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<decimal>> BeApproximately(NullableNumericAssertions`1<decimal> parent, Nullable`1<decimal> expectedValue, decimal precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<decimal>> BeApproximately(NumericAssertions`1<decimal> parent, decimal expectedValue, decimal precision, string because, Object[] becauseArgs);
    private static void FailIfDifferenceOutsidePrecision(bool differenceWithinPrecision, NumericAssertions`1<T> parent, T expectedValue, T precision, T actualDifference, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<float>> NotBeApproximately(NullableNumericAssertions`1<float> parent, float unexpectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<float>> NotBeApproximately(NullableNumericAssertions`1<float> parent, Nullable`1<float> unexpectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<float>> NotBeApproximately(NumericAssertions`1<float> parent, float unexpectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<double>> NotBeApproximately(NullableNumericAssertions`1<double> parent, double unexpectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<double>> NotBeApproximately(NullableNumericAssertions`1<double> parent, Nullable`1<double> unexpectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<double>> NotBeApproximately(NumericAssertions`1<double> parent, double unexpectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<decimal>> NotBeApproximately(NullableNumericAssertions`1<decimal> parent, decimal unexpectedValue, decimal precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<decimal>> NotBeApproximately(NullableNumericAssertions`1<decimal> parent, Nullable`1<decimal> unexpectedValue, decimal precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<decimal>> NotBeApproximately(NumericAssertions`1<decimal> parent, decimal unexpectedValue, decimal precision, string because, Object[] becauseArgs);
    private static void FailIfDifferenceWithinPrecision(NumericAssertions`1<T> parent, bool differenceOutsidePrecision, T unexpectedValue, T precision, T actualDifference, string because, Object[] becauseArgs);
    private static long GetMinValue(long value, ulong delta);
    private static long GetMaxValue(long value, ulong delta);
}
[ExtensionAttribute]
public static class FluentAssertions.ObjectAssertionsExtensions : object {
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeBinarySerializable(ObjectAssertions assertions, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeBinarySerializable(ObjectAssertions assertions, Func`2<EquivalencyAssertionOptions`1<T>, EquivalencyAssertionOptions`1<T>> options, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeDataContractSerializable(ObjectAssertions assertions, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeDataContractSerializable(ObjectAssertions assertions, Func`2<EquivalencyAssertionOptions`1<T>, EquivalencyAssertionOptions`1<T>> options, string because, Object[] becauseArgs);
    private static object CreateCloneUsingBinarySerializer(object subject);
    private static object CreateCloneUsingDataContractSerializer(object subject);
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeXmlSerializable(ObjectAssertions assertions, string because, Object[] becauseArgs);
    private static object CreateCloneUsingXmlSerializer(object subject);
}
public abstract class FluentAssertions.OccurrenceConstraint : object {
    [CompilerGeneratedAttribute]
private int <ExpectedCount>k__BackingField;
    internal int ExpectedCount { get; private set; }
    internal string Mode { get; }
    protected OccurrenceConstraint(int expectedCount);
    [CompilerGeneratedAttribute]
internal int get_ExpectedCount();
    [CompilerGeneratedAttribute]
private void set_ExpectedCount(int value);
    internal abstract virtual string get_Mode();
    internal abstract virtual bool Assert(int actual);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.BooleanAssertions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Subject>k__BackingField;
    public Nullable`1<bool> Subject { get; private set; }
    public BooleanAssertions(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(Nullable`1<bool> value);
    public AndConstraint`1<BooleanAssertions> BeFalse(string because, Object[] becauseArgs);
    public AndConstraint`1<BooleanAssertions> BeTrue(string because, Object[] becauseArgs);
    public AndConstraint`1<BooleanAssertions> Be(bool expected, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeAssertions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Subject>k__BackingField;
    public Nullable`1<DateTime> Subject { get; private set; }
    public DateTimeAssertions(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(Nullable`1<DateTime> value);
    public AndConstraint`1<DateTimeAssertions> Be(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotBe(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> BeCloseTo(DateTime nearbyTime, int precision, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> BeCloseTo(DateTime nearbyTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotBeCloseTo(DateTime distantTime, int precision, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotBeCloseTo(DateTime distantTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> BeBefore(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotBeBefore(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> BeOnOrBefore(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotBeOnOrBefore(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> BeAfter(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotBeAfter(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> BeOnOrAfter(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotBeOnOrAfter(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> HaveYear(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotHaveYear(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> HaveMonth(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotHaveMonth(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> HaveDay(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotHaveDay(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> HaveHour(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotHaveHour(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> HaveMinute(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotHaveMinute(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> HaveSecond(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotHaveSecond(int unexpected, string because, Object[] becauseArgs);
    public DateTimeRangeAssertions BeMoreThan(TimeSpan timeSpan);
    public DateTimeRangeAssertions BeAtLeast(TimeSpan timeSpan);
    public DateTimeRangeAssertions BeExactly(TimeSpan timeSpan);
    public DateTimeRangeAssertions BeWithin(TimeSpan timeSpan);
    public DateTimeRangeAssertions BeLessThan(TimeSpan timeSpan);
    public AndConstraint`1<DateTimeAssertions> BeSameDateAs(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> NotBeSameDateAs(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> BeOneOf(Nullable`1[] validValues);
    public AndConstraint`1<DateTimeAssertions> BeOneOf(DateTime[] validValues);
    public AndConstraint`1<DateTimeAssertions> BeOneOf(IEnumerable`1<DateTime> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> BeOneOf(IEnumerable`1<Nullable`1<DateTime>> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> BeIn(DateTimeKind expectedKind, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeOffsetAssertions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Subject>k__BackingField;
    public Nullable`1<DateTimeOffset> Subject { get; private set; }
    public DateTimeOffsetAssertions(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(Nullable`1<DateTimeOffset> value);
    public AndConstraint`1<DateTimeOffsetAssertions> Be(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotBe(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> BeCloseTo(DateTimeOffset nearbyTime, int precision, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> BeCloseTo(DateTimeOffset nearbyTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotBeCloseTo(DateTimeOffset distantTime, int precision, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotBeCloseTo(DateTimeOffset distantTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> BeBefore(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotBeBefore(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> BeOnOrBefore(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotBeOnOrBefore(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> BeAfter(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotBeAfter(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> BeOnOrAfter(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotBeOnOrAfter(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> HaveYear(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotHaveYear(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> HaveMonth(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotHaveMonth(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> HaveDay(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotHaveDay(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> HaveHour(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotHaveHour(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> HaveMinute(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotHaveMinute(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> HaveSecond(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotHaveSecond(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> HaveOffset(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotHaveOffset(TimeSpan unexpected, string because, Object[] becauseArgs);
    public DateTimeOffsetRangeAssertions BeMoreThan(TimeSpan timeSpan);
    public DateTimeOffsetRangeAssertions BeAtLeast(TimeSpan timeSpan);
    public DateTimeOffsetRangeAssertions BeExactly(TimeSpan timeSpan);
    public DateTimeOffsetRangeAssertions BeWithin(TimeSpan timeSpan);
    public DateTimeOffsetRangeAssertions BeLessThan(TimeSpan timeSpan);
    public AndConstraint`1<DateTimeOffsetAssertions> BeSameDateAs(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> NotBeSameDateAs(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> BeOneOf(Nullable`1[] validValues);
    public AndConstraint`1<DateTimeOffsetAssertions> BeOneOf(DateTimeOffset[] validValues);
    public AndConstraint`1<DateTimeOffsetAssertions> BeOneOf(IEnumerable`1<DateTimeOffset> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> BeOneOf(IEnumerable`1<Nullable`1<DateTimeOffset>> validValues, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeOffsetRangeAssertions : object {
    private DateTimeOffsetAssertions parentAssertions;
    private TimeSpanPredicate predicate;
    private Dictionary`2<TimeSpanCondition, TimeSpanPredicate> predicates;
    private Nullable`1<DateTimeOffset> subject;
    private TimeSpan timeSpan;
    protected internal DateTimeOffsetRangeAssertions(DateTimeOffsetAssertions parentAssertions, Nullable`1<DateTimeOffset> subject, TimeSpanCondition condition, TimeSpan timeSpan);
    public AndConstraint`1<DateTimeOffsetAssertions> Before(DateTimeOffset target, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> After(DateTimeOffset target, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeRangeAssertions : object {
    private DateTimeAssertions parentAssertions;
    private TimeSpanPredicate predicate;
    private Dictionary`2<TimeSpanCondition, TimeSpanPredicate> predicates;
    private Nullable`1<DateTime> subject;
    private TimeSpan timeSpan;
    protected internal DateTimeRangeAssertions(DateTimeAssertions parentAssertions, Nullable`1<DateTime> subject, TimeSpanCondition condition, TimeSpan timeSpan);
    public AndConstraint`1<DateTimeAssertions> Before(DateTime target, string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> After(DateTime target, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.GuidAssertions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <Subject>k__BackingField;
    public Nullable`1<Guid> Subject { get; private set; }
    public GuidAssertions(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(Nullable`1<Guid> value);
    public AndConstraint`1<GuidAssertions> BeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<GuidAssertions> NotBeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<GuidAssertions> Be(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GuidAssertions> Be(Guid expected, string because, Object[] becauseArgs);
    public AndConstraint`1<GuidAssertions> NotBe(Guid unexpected, string because, Object[] becauseArgs);
}
internal class FluentAssertions.Primitives.NegatedStringStartValidator : StringValidator {
    private StringComparison stringComparison;
    protected string ExpectationDescription { get; }
    private bool IgnoreCase { get; }
    public NegatedStringStartValidator(string subject, string expected, StringComparison stringComparison, string because, Object[] becauseArgs);
    protected virtual string get_ExpectationDescription();
    private bool get_IgnoreCase();
    protected virtual void ValidateAgainstMismatch();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableBooleanAssertions : BooleanAssertions {
    public NullableBooleanAssertions(Nullable`1<bool> value);
    public AndConstraint`1<NullableBooleanAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableBooleanAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableBooleanAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableBooleanAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<BooleanAssertions> Be(Nullable`1<bool> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<BooleanAssertions> NotBeFalse(string because, Object[] becauseArgs);
    public AndConstraint`1<BooleanAssertions> NotBeTrue(string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableDateTimeAssertions : DateTimeAssertions {
    public NullableDateTimeAssertions(Nullable`1<DateTime> expected);
    public AndConstraint`1<NullableDateTimeAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableDateTimeAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableDateTimeAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableDateTimeAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeAssertions> Be(Nullable`1<DateTime> expected, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableDateTimeOffsetAssertions : DateTimeOffsetAssertions {
    public NullableDateTimeOffsetAssertions(Nullable`1<DateTimeOffset> expected);
    public AndConstraint`1<NullableDateTimeOffsetAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableDateTimeOffsetAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableDateTimeOffsetAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableDateTimeOffsetAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<DateTimeOffsetAssertions> Be(Nullable`1<DateTimeOffset> expected, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableGuidAssertions : GuidAssertions {
    public NullableGuidAssertions(Nullable`1<Guid> value);
    public AndConstraint`1<NullableGuidAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableGuidAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableGuidAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableGuidAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableGuidAssertions> Be(Nullable`1<Guid> expected, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions : SimpleTimeSpanAssertions {
    public NullableSimpleTimeSpanAssertions(Nullable`1<TimeSpan> value);
    public AndConstraint`1<NullableSimpleTimeSpanAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableSimpleTimeSpanAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableSimpleTimeSpanAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableSimpleTimeSpanAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<NullableSimpleTimeSpanAssertions> Be(Nullable`1<TimeSpan> expected, string because, Object[] becauseArgs);
}
public class FluentAssertions.Primitives.ObjectAssertions : ReferenceTypeAssertions`2<object, ObjectAssertions> {
    protected string Identifier { get; }
    public ObjectAssertions(object value);
    public AndConstraint`1<ObjectAssertions> Be(object expected, string because, Object[] becauseArgs);
    public AndConstraint`1<ObjectAssertions> NotBe(object unexpected, string because, Object[] becauseArgs);
    public void BeEquivalentTo(TExpectation expectation, string because, Object[] becauseArgs);
    public void BeEquivalentTo(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public void NotBeEquivalentTo(TExpectation unexpected, string because, Object[] becauseArgs);
    public void NotBeEquivalentTo(TExpectation unexpected, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<ObjectAssertions> HaveFlag(Enum expectedFlag, string because, Object[] becauseArgs);
    public AndConstraint`1<ObjectAssertions> NotHaveFlag(Enum unexpectedFlag, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public abstract class FluentAssertions.Primitives.ReferenceTypeAssertions`2 : object {
    [CompilerGeneratedAttribute]
private TSubject <Subject>k__BackingField;
    public TSubject Subject { get; protected set; }
    protected string Identifier { get; }
    protected ReferenceTypeAssertions`2(TSubject subject);
    [CompilerGeneratedAttribute]
public TSubject get_Subject();
    [CompilerGeneratedAttribute]
protected void set_Subject(TSubject value);
    public AndConstraint`1<TAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeSameAs(TSubject expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeSameAs(TSubject unexpected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> BeOfType(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOfType(Type expectedType, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeOfType(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeOfType(Type unexpectedType, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> BeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeAssignableTo(Type type, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeAssignableTo(Type type, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Match(Expression`1<Func`2<TSubject, bool>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Match(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    protected abstract virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.SimpleTimeSpanAssertions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Subject>k__BackingField;
    public Nullable`1<TimeSpan> Subject { get; private set; }
    public SimpleTimeSpanAssertions(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(Nullable`1<TimeSpan> value);
    public AndConstraint`1<SimpleTimeSpanAssertions> BePositive(string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> BeNegative(string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> Be(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> NotBe(TimeSpan unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> BeLessThan(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> BeLessOrEqualTo(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> BeGreaterThan(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> BeGreaterOrEqualTo(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> BeCloseTo(TimeSpan nearbyTime, int precision, string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> BeCloseTo(TimeSpan nearbyTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> NotBeCloseTo(TimeSpan distantTime, int precision, string because, Object[] becauseArgs);
    public AndConstraint`1<SimpleTimeSpanAssertions> NotBeCloseTo(TimeSpan distantTime, TimeSpan precision, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.StringAssertions : ReferenceTypeAssertions`2<string, StringAssertions> {
    protected string Identifier { get; }
    public StringAssertions(string value);
    public AndConstraint`1<StringAssertions> Be(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> BeOneOf(String[] validValues);
    public AndConstraint`1<StringAssertions> BeOneOf(IEnumerable`1<string> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> BeEquivalentTo(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotBeEquivalentTo(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotBe(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> Match(string wildcardPattern, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotMatch(string wildcardPattern, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> MatchEquivalentOf(string wildcardPattern, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotMatchEquivalentOf(string wildcardPattern, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> MatchRegex(string regularExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotMatchRegex(string regularExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> StartWith(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotStartWith(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> StartWithEquivalent(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotStartWithEquivalentOf(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> EndWith(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotEndWith(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> EndWithEquivalent(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotEndWithEquivalentOf(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> Contain(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> Contain(string expected, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> ContainEquivalentOf(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> ContainEquivalentOf(string expected, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> ContainAll(IEnumerable`1<string> values, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> ContainAll(String[] values);
    public AndConstraint`1<StringAssertions> ContainAny(IEnumerable`1<string> values, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> ContainAny(String[] values);
    public AndConstraint`1<StringAssertions> NotContain(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotContainAll(IEnumerable`1<string> values, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotContainAll(String[] values);
    public AndConstraint`1<StringAssertions> NotContainAny(IEnumerable`1<string> values, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotContainAny(String[] values);
    public AndConstraint`1<StringAssertions> NotContainEquivalentOf(string unexpected, string because, Object[] becauseArgs);
    private static bool Contains(string actual, string expected, StringComparison comparison);
    public AndConstraint`1<StringAssertions> BeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotBeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> HaveLength(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotBeNullOrEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> BeNullOrEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> NotBeNullOrWhiteSpace(string because, Object[] becauseArgs);
    public AndConstraint`1<StringAssertions> BeNullOrWhiteSpace(string because, Object[] becauseArgs);
    private static void ThrowIfValuesNullOrEmpty(IEnumerable`1<string> values);
    protected virtual string get_Identifier();
    [CompilerGeneratedAttribute]
private bool <ContainAll>b__25_0(string v);
    [CompilerGeneratedAttribute]
private bool <ContainAll>b__25_1(string v);
    [CompilerGeneratedAttribute]
private bool <ContainAny>b__27_0(string v);
    [CompilerGeneratedAttribute]
private bool <NotContainAll>b__30_0(string v);
    [CompilerGeneratedAttribute]
private bool <NotContainAny>b__32_0(string v);
}
internal class FluentAssertions.Primitives.StringEqualityValidator : StringValidator {
    private StringComparison comparisonMode;
    protected string ExpectationDescription { get; }
    private bool IgnoreCase { get; }
    public StringEqualityValidator(string subject, string expected, StringComparison comparisonMode, string because, Object[] becauseArgs);
    protected virtual bool ValidateAgainstSuperfluousWhitespace();
    protected virtual bool ValidateAgainstLengthDifferences();
    private string GetMismatchSegmentForStringsOfDifferentLengths();
    protected virtual void ValidateAgainstMismatch();
    protected virtual string get_ExpectationDescription();
    private bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
private FailReason <ValidateAgainstLengthDifferences>b__3_0();
}
internal class FluentAssertions.Primitives.StringStartValidator : StringValidator {
    private StringComparison stringComparison;
    protected string ExpectationDescription { get; }
    private bool IgnoreCase { get; }
    public StringStartValidator(string subject, string expected, StringComparison stringComparison, string because, Object[] becauseArgs);
    protected virtual string get_ExpectationDescription();
    private bool get_IgnoreCase();
    protected virtual bool ValidateAgainstLengthDifferences();
    protected virtual void ValidateAgainstMismatch();
}
internal abstract class FluentAssertions.Primitives.StringValidator : object {
    protected string subject;
    protected string expected;
    protected IAssertionScope assertion;
    private static int HumanReadableLength;
    protected string ExpectationDescription { get; }
    protected StringValidator(string subject, string expected, string because, Object[] becauseArgs);
    public void Validate();
    private bool ValidateAgainstNulls();
    private static bool IsLongOrMultiline(string value);
    protected virtual bool ValidateAgainstSuperfluousWhitespace();
    protected virtual bool ValidateAgainstLengthDifferences();
    protected abstract virtual void ValidateAgainstMismatch();
    protected abstract virtual string get_ExpectationDescription();
}
internal class FluentAssertions.Primitives.StringWildcardMatchingValidator : StringValidator {
    [CompilerGeneratedAttribute]
private bool <Negate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNewLineDifferences>k__BackingField;
    protected string ExpectationDescription { get; }
    public bool Negate { get; public set; }
    public bool IgnoreCase { get; public set; }
    public bool IgnoreNewLineDifferences { get; public set; }
    public StringWildcardMatchingValidator(string subject, string expected, string because, Object[] becauseArgs);
    protected virtual void ValidateAgainstMismatch();
    private bool IsMatch();
    private static string ConvertWildcardToRegEx(string wildcardExpression);
    private string CleanNewLines(string input);
    protected virtual string get_ExpectationDescription();
    [CompilerGeneratedAttribute]
public bool get_Negate();
    [CompilerGeneratedAttribute]
public void set_Negate(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreNewLineDifferences();
    [CompilerGeneratedAttribute]
public void set_IgnoreNewLineDifferences(bool value);
}
public enum FluentAssertions.Primitives.TimeSpanCondition : Enum {
    public int value__;
    public static TimeSpanCondition MoreThan;
    public static TimeSpanCondition AtLeast;
    public static TimeSpanCondition Exactly;
    public static TimeSpanCondition Within;
    public static TimeSpanCondition LessThan;
}
internal class FluentAssertions.Primitives.TimeSpanPredicate : object {
    private string displayText;
    private Func`3<TimeSpan, TimeSpan, bool> lambda;
    public string DisplayText { get; }
    public TimeSpanPredicate(Func`3<TimeSpan, TimeSpan, bool> lambda, string displayText);
    public string get_DisplayText();
    public bool IsMatchedBy(TimeSpan actual, TimeSpan expected);
}
public class FluentAssertions.Reflection.AssemblyAssertions : ReferenceTypeAssertions`2<Assembly, AssemblyAssertions> {
    protected string Identifier { get; }
    public AssemblyAssertions(Assembly assembly);
    public void NotReference(Assembly assembly);
    public void NotReference(Assembly assembly, string because, String[] becauseArgs);
    public void Reference(Assembly assembly);
    public void Reference(Assembly assembly, string because, String[] becauseArgs);
    public AndWhichConstraint`2<AssemblyAssertions, Type> DefineType(string namespace, string name, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Specialized.ActionAssertions : DelegateAssertions`1<Action> {
    [CompilerGeneratedAttribute]
private Action <Subject>k__BackingField;
    public Action Subject { get; }
    protected string Identifier { get; }
    public ActionAssertions(Action subject, IExtractExceptions extractor);
    public ActionAssertions(Action subject, IExtractExceptions extractor, IClock clock);
    [CompilerGeneratedAttribute]
public Action get_Subject();
    protected virtual void InvokeSubject();
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Specialized.AsyncFunctionAssertions : DelegateAssertions`1<Func`1<Task>> {
    [CompilerGeneratedAttribute]
private Func`1<Task> <Subject>k__BackingField;
    public Func`1<Task> Subject { get; }
    protected string Identifier { get; }
    private protected bool CanHandleAsync { get; }
    public AsyncFunctionAssertions(Func`1<Task> subject, IExtractExceptions extractor);
    public AsyncFunctionAssertions(Func`1<Task> subject, IExtractExceptions extractor, IClock clock);
    [CompilerGeneratedAttribute]
public Func`1<Task> get_Subject();
    protected virtual string get_Identifier();
    private protected virtual bool get_CanHandleAsync();
    protected virtual void InvokeSubject();
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions/<ThrowExactlyAsync>d__10`1")]
public Task`1<ExceptionAssertions`1<TException>> ThrowExactlyAsync(string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions/<ThrowAsync>d__11`1")]
public Task`1<ExceptionAssertions`1<TException>> ThrowAsync(string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions/<NotThrowAsync>d__12")]
public Task NotThrowAsync(string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions/<NotThrowAsync>d__13`1")]
public Task NotThrowAsync(string because, Object[] becauseArgs);
    public Task NotThrowAfterAsync(TimeSpan waitTime, TimeSpan pollInterval, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions/<InvokeWithInterceptionAsync>d__15")]
private static Task`1<Exception> InvokeWithInterceptionAsync(Func`1<Task> action);
}
[DebuggerNonUserCodeAttribute]
public abstract class FluentAssertions.Specialized.DelegateAssertions`1 : ReferenceTypeAssertions`2<Delegate, DelegateAssertions`1<TDelegate>> {
    private IExtractExceptions extractor;
    [CompilerGeneratedAttribute]
private TDelegate <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private IClock <Clock>k__BackingField;
    public TDelegate Subject { get; }
    private protected IClock Clock { get; }
    private protected bool CanHandleAsync { get; }
    protected DelegateAssertions`1(TDelegate delegate, IExtractExceptions extractor);
    private protected DelegateAssertions`1(TDelegate delegate, IExtractExceptions extractor, IClock clock);
    [CompilerGeneratedAttribute]
public TDelegate get_Subject();
    [CompilerGeneratedAttribute]
private protected IClock get_Clock();
    private protected virtual bool get_CanHandleAsync();
    public ExceptionAssertions`1<TException> Throw(string because, Object[] becauseArgs);
    public void NotThrow(string because, Object[] becauseArgs);
    public void NotThrow(string because, Object[] becauseArgs);
    public ExceptionAssertions`1<TException> ThrowExactly(string because, Object[] becauseArgs);
    public void NotThrowAfter(TimeSpan waitTime, TimeSpan pollInterval, string because, Object[] becauseArgs);
    protected ExceptionAssertions`1<TException> Throw(Exception exception, string because, Object[] becauseArgs);
    protected void NotThrow(Exception exception, string because, Object[] becauseArgs);
    protected void NotThrow(Exception exception, string because, Object[] becauseArgs);
    protected abstract virtual void InvokeSubject();
    private Exception InvokeSubjectWithInterception();
    private void FailIfSubjectIsAsyncVoid();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Specialized.ExceptionAssertions`1 : ReferenceTypeAssertions`2<IEnumerable`1<TException>, ExceptionAssertions`1<TException>> {
    private static ExceptionMessageAssertion<TException> outerMessageAssertion;
    public TException And { get; }
    public TException Which { get; }
    protected string Identifier { get; }
    private TException SingleSubject { get; }
    public ExceptionAssertions`1(IEnumerable`1<TException> exceptions);
    private static ExceptionAssertions`1();
    public TException get_And();
    public TException get_Which();
    protected virtual string get_Identifier();
    public virtual ExceptionAssertions`1<TException> WithMessage(string expectedWildcardPattern, string because, Object[] becauseArgs);
    public virtual ExceptionAssertions`1<TInnerException> WithInnerException(string because, Object[] becauseArgs);
    public virtual ExceptionAssertions`1<TInnerException> WithInnerExceptionExactly(string because, Object[] becauseArgs);
    public ExceptionAssertions`1<TException> Where(Expression`1<Func`2<TException, bool>> exceptionExpression, string because, Object[] becauseArgs);
    private TException get_SingleSubject();
    private static string BuildExceptionsString(IEnumerable`1<TException> exceptions);
}
public class FluentAssertions.Specialized.ExecutionTime : object {
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    private Stopwatch stopwatch;
    internal TimeSpan ElapsedTime { get; }
    internal bool IsRunning { get; private set; }
    internal string ActionDescription { get; }
    internal Task Task { get; }
    internal Exception Exception { get; private set; }
    public ExecutionTime(Action action);
    public ExecutionTime(Func`1<Task> action);
    protected ExecutionTime(Action action, string actionDescription);
    protected ExecutionTime(Func`1<Task> action, string actionDescription);
    internal TimeSpan get_ElapsedTime();
    [CompilerGeneratedAttribute]
internal bool get_IsRunning();
    [CompilerGeneratedAttribute]
private void set_IsRunning(bool value);
    [CompilerGeneratedAttribute]
internal string get_ActionDescription();
    [CompilerGeneratedAttribute]
internal Task get_Task();
    [CompilerGeneratedAttribute]
internal Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
public class FluentAssertions.Specialized.ExecutionTimeAssertions : object {
    private ExecutionTime execution;
    public ExecutionTimeAssertions(ExecutionTime executionTime);
    private ValueTuple`2<bool, TimeSpan> PollUntil(Func`2<TimeSpan, bool> condition, bool expectedResult, TimeSpan rate);
    public void BeLessOrEqualTo(TimeSpan maxDuration, string because, Object[] becauseArgs);
    public void BeLessThan(TimeSpan maxDuration, string because, Object[] becauseArgs);
    public void BeGreaterOrEqualTo(TimeSpan minDuration, string because, Object[] becauseArgs);
    public void BeGreaterThan(TimeSpan minDuration, string because, Object[] becauseArgs);
    public void BeCloseTo(TimeSpan expectedDuration, TimeSpan precision, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Specialized.FunctionAssertions`1 : DelegateAssertions`1<Func`1<T>> {
    [CompilerGeneratedAttribute]
private Func`1<T> <Subject>k__BackingField;
    public Func`1<T> Subject { get; }
    protected string Identifier { get; }
    public FunctionAssertions`1(Func`1<T> subject, IExtractExceptions extractor);
    public FunctionAssertions`1(Func`1<T> subject, IExtractExceptions extractor, IClock clock);
    [CompilerGeneratedAttribute]
public Func`1<T> get_Subject();
    protected virtual void InvokeSubject();
    protected virtual string get_Identifier();
    public AndWhichConstraint`2<FunctionAssertions`1<T>, T> NotThrow(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<FunctionAssertions`1<T>, T> NotThrowAfter(TimeSpan waitTime, TimeSpan pollInterval, string because, Object[] becauseArgs);
}
public class FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1 : AsyncFunctionAssertions {
    private Func`1<Task`1<TResult>> subject;
    public GenericAsyncFunctionAssertions`1(Func`1<Task`1<TResult>> subject, IExtractExceptions extractor);
    public GenericAsyncFunctionAssertions`1(Func`1<Task`1<TResult>> subject, IExtractExceptions extractor, IClock clock);
    public AndWhichConstraint`2<GenericAsyncFunctionAssertions`1<TResult>, TResult> CompleteWithin(TimeSpan timeSpan, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1/<CompleteWithinAsync>d__4")]
public Task`1<AndWhichConstraint`2<GenericAsyncFunctionAssertions`1<TResult>, TResult>> CompleteWithinAsync(TimeSpan timeSpan, string because, Object[] becauseArgs);
}
public interface FluentAssertions.Specialized.IExtractExceptions {
    public abstract virtual IEnumerable`1<T> OfType(Exception actualException);
}
public class FluentAssertions.Specialized.MemberExecutionTime`1 : ExecutionTime {
    public MemberExecutionTime`1(T subject, Expression`1<Action`1<T>> action);
}
public class FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions : AsyncFunctionAssertions {
    public NonGenericAsyncFunctionAssertions(Func`1<Task> subject, IExtractExceptions extractor);
    public NonGenericAsyncFunctionAssertions(Func`1<Task> subject, IExtractExceptions extractor, IClock clock);
    public AndConstraint`1<AsyncFunctionAssertions> CompleteWithin(TimeSpan timeSpan, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions/<CompleteWithinAsync>d__3")]
public Task`1<AndConstraint`1<AsyncFunctionAssertions>> CompleteWithinAsync(TimeSpan timeSpan, string because, Object[] becauseArgs);
}
[ExtensionAttribute]
public static class FluentAssertions.TypeEnumerableExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreDecoratedWith(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreDecoratedWithOrInherit(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreNotDecoratedWith(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreNotDecoratedWithOrInherit(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreInNamespace(IEnumerable`1<Type> types, string namespace);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreUnderNamespace(IEnumerable`1<Type> types, string namespace);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatDeriveFrom(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatImplement(IEnumerable`1<Type> types);
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.TypeExtensions : object {
    [ExtensionAttribute]
public static TypeSelector Types(Assembly assembly);
    [ExtensionAttribute]
public static TypeSelector Types(Type type);
    [ExtensionAttribute]
public static TypeSelector Types(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static MethodInfoSelector Methods(Type type);
    [ExtensionAttribute]
public static MethodInfoSelector Methods(TypeSelector typeSelector);
    [ExtensionAttribute]
public static PropertyInfoSelector Properties(Type type);
    [ExtensionAttribute]
public static PropertyInfoSelector Properties(TypeSelector typeSelector);
}
public static class FluentAssertions.Types.AllTypes : object {
    public static TypeSelector From(Assembly assembly);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.ConstructorInfoAssertions : MethodBaseAssertions`2<ConstructorInfo, ConstructorInfoAssertions> {
    internal string SubjectDescription { get; }
    protected string Identifier { get; }
    public ConstructorInfoAssertions(ConstructorInfo constructorInfo);
    internal static string GetDescriptionFor(ConstructorInfo constructorInfo);
    internal virtual string get_SubjectDescription();
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public abstract class FluentAssertions.Types.MemberInfoAssertions`2 : ReferenceTypeAssertions`2<TSubject, TAssertions> {
    protected string Identifier { get; }
    internal string SubjectDescription { get; }
    protected MemberInfoAssertions`2(TSubject subject);
    public AndWhichConstraint`2<MemberInfoAssertions`2<TSubject, TAssertions>, TAttribute> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<MemberInfoAssertions`2<TSubject, TAssertions>, TAttribute> BeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
    internal virtual string get_SubjectDescription();
}
[DebuggerNonUserCodeAttribute]
public abstract class FluentAssertions.Types.MethodBaseAssertions`2 : MemberInfoAssertions`2<TSubject, TAssertions> {
    protected string Identifier { get; }
    protected MethodBaseAssertions`2(TSubject subject);
    public AndConstraint`1<TAssertions> HaveAccessModifier(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveAccessModifier(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
    internal static string GetParameterString(MethodBase methodBase);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.MethodInfoAssertions : MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions> {
    internal string SubjectDescription { get; }
    protected string Identifier { get; }
    public MethodInfoAssertions(MethodInfo methodInfo);
    public AndConstraint`1<MethodInfoAssertions> BeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoAssertions> NotBeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoAssertions> BeAsync(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoAssertions> NotBeAsync(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> ReturnVoid(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> Return(Type returnType, string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> Return(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> NotReturnVoid(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> NotReturn(Type returnType, string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> NotReturn(string because, Object[] becauseArgs);
    internal static string GetDescriptionFor(MethodInfo method);
    internal virtual string get_SubjectDescription();
    protected virtual string get_Identifier();
}
public class FluentAssertions.Types.MethodInfoSelector : object {
    private IEnumerable`1<MethodInfo> selectedMethods;
    public MethodInfoSelector ThatArePublicOrInternal { get; }
    public MethodInfoSelector ThatReturnVoid { get; }
    public MethodInfoSelector ThatDoNotReturnVoid { get; }
    public MethodInfoSelector(Type type);
    public MethodInfoSelector(IEnumerable`1<Type> types);
    public MethodInfoSelector get_ThatArePublicOrInternal();
    public MethodInfoSelector get_ThatReturnVoid();
    public MethodInfoSelector get_ThatDoNotReturnVoid();
    public MethodInfoSelector ThatReturn();
    public MethodInfoSelector ThatDoNotReturn();
    public MethodInfoSelector ThatAreDecoratedWith();
    public MethodInfoSelector ThatAreDecoratedWithOrInherit();
    public MethodInfoSelector ThatAreNotDecoratedWith();
    public MethodInfoSelector ThatAreNotDecoratedWithOrInherit();
    public MethodInfo[] ToArray();
    private bool HasSpecialName(MethodInfo method);
    public sealed virtual IEnumerator`1<MethodInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodInfo> <.ctor>b__2_0(Type t);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__2_1(MethodInfo method);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.MethodInfoSelectorAssertions : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodInfo> <SubjectMethods>k__BackingField;
    public IEnumerable`1<MethodInfo> SubjectMethods { get; private set; }
    protected string Context { get; }
    public MethodInfoSelectorAssertions(MethodInfo[] methods);
    [CompilerGeneratedAttribute]
public IEnumerable`1<MethodInfo> get_SubjectMethods();
    [CompilerGeneratedAttribute]
private void set_SubjectMethods(IEnumerable`1<MethodInfo> value);
    public AndConstraint`1<MethodInfoSelectorAssertions> BeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> NotBeVirtual(string because, Object[] becauseArgs);
    private MethodInfo[] GetAllNonVirtualMethodsFromSelection();
    private MethodInfo[] GetAllVirtualMethodsFromSelection();
    public AndConstraint`1<MethodInfoSelectorAssertions> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> BeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> NotBeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    private MethodInfo[] GetMethodsWithout(Expression`1<Func`2<TAttribute, bool>> isMatchingPredicate);
    private MethodInfo[] GetMethodsWith(Expression`1<Func`2<TAttribute, bool>> isMatchingPredicate);
    private static string GetDescriptionsFor(IEnumerable`1<MethodInfo> methods);
    protected string get_Context();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.PropertyInfoAssertions : MemberInfoAssertions`2<PropertyInfo, PropertyInfoAssertions> {
    internal string SubjectDescription { get; }
    protected string Identifier { get; }
    public PropertyInfoAssertions(PropertyInfo propertyInfo);
    public AndConstraint`1<PropertyInfoAssertions> BeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotBeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> BeWritable(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> BeWritable(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotBeWritable(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> BeReadable(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> BeReadable(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotBeReadable(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> Return(Type propertyType, string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> Return(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotReturn(Type propertyType, string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotReturn(string because, Object[] becauseArgs);
    internal static string GetDescriptionFor(PropertyInfo property);
    internal virtual string get_SubjectDescription();
    protected virtual string get_Identifier();
}
public class FluentAssertions.Types.PropertyInfoSelector : object {
    private IEnumerable`1<PropertyInfo> selectedProperties;
    public PropertyInfoSelector ThatArePublicOrInternal { get; }
    public PropertyInfoSelector(Type type);
    public PropertyInfoSelector(IEnumerable`1<Type> types);
    public PropertyInfoSelector get_ThatArePublicOrInternal();
    public PropertyInfoSelector ThatAreDecoratedWith();
    public PropertyInfoSelector ThatAreDecoratedWithOrInherit();
    public PropertyInfoSelector ThatAreNotDecoratedWith();
    public PropertyInfoSelector ThatAreNotDecoratedWithOrInherit();
    public PropertyInfoSelector OfType();
    public PropertyInfoSelector NotOfType();
    public PropertyInfo[] ToArray();
    public sealed virtual IEnumerator`1<PropertyInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.PropertyInfoSelectorAssertions : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PropertyInfo> <SubjectProperties>k__BackingField;
    public IEnumerable`1<PropertyInfo> SubjectProperties { get; private set; }
    protected string Context { get; }
    public PropertyInfoSelectorAssertions(PropertyInfo[] properties);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PropertyInfo> get_SubjectProperties();
    [CompilerGeneratedAttribute]
private void set_SubjectProperties(IEnumerable`1<PropertyInfo> value);
    public AndConstraint`1<PropertyInfoSelectorAssertions> BeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoSelectorAssertions> NotBeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoSelectorAssertions> BeWritable(string because, Object[] becauseArgs);
    private PropertyInfo[] GetAllReadOnlyPropertiesFromSelection();
    private PropertyInfo[] GetAllNonVirtualPropertiesFromSelection();
    private PropertyInfo[] GetAllVirtualPropertiesFromSelection();
    public AndConstraint`1<PropertyInfoSelectorAssertions> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoSelectorAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    private PropertyInfo[] GetPropertiesWithout();
    private PropertyInfo[] GetPropertiesWith();
    private static string GetDescriptionsFor(IEnumerable`1<PropertyInfo> properties);
    protected string get_Context();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.TypeAssertions : ReferenceTypeAssertions`2<Type, TypeAssertions> {
    protected string Identifier { get; }
    public TypeAssertions(Type type);
    public AndConstraint`1<TypeAssertions> Be(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> Be(Type expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeAssignableTo(Type type, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeAssignableTo(Type type, string because, Object[] becauseArgs);
    private static string GetFailureMessageIfTypesAreDifferent(Type actual, Type expected);
    public AndConstraint`1<TypeAssertions> NotBe(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBe(Type unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeDecoratedWithOrInherit(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeDecoratedWithOrInherit(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDecoratedWithOrInherit(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDecoratedWithOrInherit(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> Implement(Type interfaceType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> Implement(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotImplement(Type interfaceType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotImplement(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeDerivedFrom(Type baseType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeDerivedFrom(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDerivedFrom(Type baseType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDerivedFrom(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeSealed(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeSealed(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeAbstract(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeAbstract(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeStatic(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeStatic(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, PropertyInfo> HaveProperty(Type propertyType, string name, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, PropertyInfo> HaveProperty(string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveProperty(string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> HaveExplicitProperty(Type interfaceType, string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> HaveExplicitProperty(string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitProperty(Type interfaceType, string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitProperty(string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> HaveExplicitMethod(Type interfaceType, string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> HaveExplicitMethod(string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitMethod(Type interfaceType, string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitMethod(string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, PropertyInfo> HaveIndexer(Type indexerType, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveIndexer(IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveMethod(string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveMethod(string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, ConstructorInfo> HaveConstructor(IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, ConstructorInfo> HaveDefaultConstructor(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, ConstructorInfo> NotHaveConstructor(IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, ConstructorInfo> NotHaveDefaultConstructor(string because, Object[] becauseArgs);
    private static string GetParameterString(IEnumerable`1<Type> parameterTypes);
    public AndConstraint`1<Type> HaveAccessModifier(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndConstraint`1<Type> NotHaveAccessModifier(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    [ObsoleteAttribute("This method is deprecated in favor of 'HaveImplicitConversionOperator' and will be removed in v6.X.")]
[EditorBrowsableAttribute("1")]
public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveImplictConversionOperator(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveImplicitConversionOperator(string because, Object[] becauseArgs);
    [ObsoleteAttribute("This method is deprecated in favor of 'HaveImplicitConversionOperator' and will be removed in v6.X.")]
[EditorBrowsableAttribute("1")]
public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveImplictConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveImplicitConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    [ObsoleteAttribute("This method is deprecated in favor of 'NotHaveImplicitConversionOperator' and will be removed in v6.X.")]
[EditorBrowsableAttribute("1")]
public AndConstraint`1<TypeAssertions> NotHaveImplictConversionOperator(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveImplicitConversionOperator(string because, Object[] becauseArgs);
    [ObsoleteAttribute("This method is deprecated in favor of 'NotHaveImplicitConversionOperator' and will be removed in v6.X.")]
[EditorBrowsableAttribute("1")]
public AndConstraint`1<TypeAssertions> NotHaveImplictConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveImplicitConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    [ObsoleteAttribute("This method is deprecated in favor of 'HaveExplicitConversionOperator' and will be removed in v6.X.")]
[EditorBrowsableAttribute("1")]
public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveExplictConversionOperator(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveExplicitConversionOperator(string because, Object[] becauseArgs);
    [ObsoleteAttribute("This method is deprecated in favor of 'HaveExplicitConversionOperator' and will be removed in v6.X.")]
[EditorBrowsableAttribute("1")]
public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveExplictConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveExplicitConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    [ObsoleteAttribute("This method is deprecated in favor of 'NotHaveExplicitConversionOperator' and will be removed in v6.X.")]
[EditorBrowsableAttribute("1")]
public AndConstraint`1<TypeAssertions> NotHaveExplictConversionOperator(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitConversionOperator(string because, Object[] becauseArgs);
    [ObsoleteAttribute("This method is deprecated in favor of 'NotHaveExplicitConversionOperator' and will be removed in v6.X.")]
[EditorBrowsableAttribute("1")]
public AndConstraint`1<TypeAssertions> NotHaveExplictConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
    private void AssertThatSubjectIsClass();
}
public class FluentAssertions.Types.TypeSelector : object {
    private List`1<Type> types;
    public TypeSelector(Type type);
    public TypeSelector(IEnumerable`1<Type> types);
    public Type[] ToArray();
    public TypeSelector ThatDeriveFrom();
    public TypeSelector ThatDoNotDeriveFrom();
    public TypeSelector ThatImplement();
    public TypeSelector ThatDoNotImplement();
    public TypeSelector ThatAreDecoratedWith();
    public TypeSelector ThatAreDecoratedWithOrInherit();
    public TypeSelector ThatAreNotDecoratedWith();
    public TypeSelector ThatAreNotDecoratedWithOrInherit();
    public TypeSelector ThatAreInNamespace(string namespace);
    public TypeSelector ThatAreNotInNamespace(string namespace);
    public TypeSelector ThatAreUnderNamespace(string namespace);
    public TypeSelector ThatAreNotUnderNamespace(string namespace);
    public sealed virtual IEnumerator`1<Type> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.TypeSelectorAssertions : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <Subject>k__BackingField;
    public IEnumerable`1<Type> Subject { get; private set; }
    public TypeSelectorAssertions(Type[] types);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(IEnumerable`1<Type> value);
    public AndConstraint`1<TypeSelectorAssertions> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> BeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> BeDecoratedWithOrInherit(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> BeDecoratedWithOrInherit(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeDecoratedWithOrInherit(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeDecoratedWithOrInherit(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    private static string GetDescriptionsFor(IEnumerable`1<Type> types);
    private static string GetDescriptionFor(Type type);
}
internal class FluentAssertions.Xml.Equivalency.AttributeData : object {
    [CompilerGeneratedAttribute]
private string <NamespaceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public string NamespaceUri { get; }
    public string LocalName { get; }
    public string Value { get; }
    private string Prefix { get; }
    public string QualifiedName { get; }
    public AttributeData(string namespaceUri, string localName, string value, string prefix);
    [CompilerGeneratedAttribute]
public string get_NamespaceUri();
    [CompilerGeneratedAttribute]
public string get_LocalName();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private string get_Prefix();
    public string get_QualifiedName();
}
internal class FluentAssertions.Xml.Equivalency.Failure : object {
    [CompilerGeneratedAttribute]
private string <FormatString>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <FormatParams>k__BackingField;
    public string FormatString { get; }
    public Object[] FormatParams { get; }
    public Failure(string formatString, Object[] formatParams);
    [CompilerGeneratedAttribute]
public string get_FormatString();
    [CompilerGeneratedAttribute]
public Object[] get_FormatParams();
}
internal class FluentAssertions.Xml.Equivalency.Node : object {
    private List`1<Node> children;
    private string name;
    private int count;
    [CompilerGeneratedAttribute]
private Node <Parent>k__BackingField;
    public Node Parent { get; }
    private Node(Node parent, string name);
    public static Node CreateRoot();
    public string GetXPath();
    [IteratorStateMachineAttribute("FluentAssertions.Xml.Equivalency.Node/<GetPath>d__6")]
private IEnumerable`1<Node> GetPath();
    [CompilerGeneratedAttribute]
public Node get_Parent();
    public Node Push(string localName);
    public void Pop();
    private Node AddChildNode(string name);
}
internal class FluentAssertions.Xml.Equivalency.XmlIterator : object {
    private XmlReader reader;
    private bool skipOnce;
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public string Value { get; }
    public bool IsEmptyElement { get; }
    public bool IsEndOfDocument { get; }
    public XmlIterator(XmlReader reader);
    public XmlNodeType get_NodeType();
    public string get_LocalName();
    public string get_NamespaceUri();
    public string get_Value();
    public bool get_IsEmptyElement();
    public bool get_IsEndOfDocument();
    public void Read();
    public void MoveToEndElement();
    public IList`1<AttributeData> GetAttributes();
}
internal class FluentAssertions.Xml.Equivalency.XmlReaderValidator : object {
    private AssertionScope assertion;
    private XmlIterator subjectIterator;
    private XmlIterator expectationIterator;
    private Node currentNode;
    public XmlReaderValidator(XmlReader subjectReader, XmlReader expectationReader, string because, Object[] reasonArgs);
    public void Validate(bool shouldBeEquivalent);
    private Failure Validate();
    private Failure ValidateAttributes();
    private Failure ValidateStartElement();
    private Failure ValidateText();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XAttributeAssertions : ReferenceTypeAssertions`2<XAttribute, XAttributeAssertions> {
    protected string Identifier { get; }
    public XAttributeAssertions(XAttribute attribute);
    public AndConstraint`1<XAttributeAssertions> Be(XAttribute expected);
    public AndConstraint`1<XAttributeAssertions> Be(XAttribute expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XAttributeAssertions> NotBe(XAttribute unexpected);
    public AndConstraint`1<XAttributeAssertions> NotBe(XAttribute unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<XAttributeAssertions> HaveValue(string expected);
    public AndConstraint`1<XAttributeAssertions> HaveValue(string expected, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XDocumentAssertions : ReferenceTypeAssertions`2<XDocument, XDocumentAssertions> {
    protected string Identifier { get; }
    public XDocumentAssertions(XDocument document);
    public AndConstraint`1<XDocumentAssertions> Be(XDocument expected);
    public AndConstraint`1<XDocumentAssertions> Be(XDocument expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XDocumentAssertions> NotBe(XDocument unexpected);
    public AndConstraint`1<XDocumentAssertions> NotBe(XDocument unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<XDocumentAssertions> BeEquivalentTo(XDocument expected);
    public AndConstraint`1<XDocumentAssertions> BeEquivalentTo(XDocument expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XDocumentAssertions> NotBeEquivalentTo(XDocument unexpected);
    public AndConstraint`1<XDocumentAssertions> NotBeEquivalentTo(XDocument unexpected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveRoot(string expected);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveRoot(XName expected);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveRoot(string expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveRoot(XName expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveElement(string expected);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveElement(XName expected);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveElement(string expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveElement(XName expected, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XElementAssertions : ReferenceTypeAssertions`2<XElement, XElementAssertions> {
    protected string Identifier { get; }
    public XElementAssertions(XElement xElement);
    public AndConstraint`1<XElementAssertions> Be(XElement expected);
    public AndConstraint`1<XElementAssertions> Be(XElement expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> NotBe(XElement unexpected);
    public AndConstraint`1<XElementAssertions> NotBe(XElement unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> BeEquivalentTo(XElement expected);
    public AndConstraint`1<XElementAssertions> BeEquivalentTo(XElement expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> NotBeEquivalentTo(XElement unexpected);
    public AndConstraint`1<XElementAssertions> NotBeEquivalentTo(XElement unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> HaveValue(string expected);
    public AndConstraint`1<XElementAssertions> HaveValue(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> HaveAttribute(string expectedName, string expectedValue);
    public AndConstraint`1<XElementAssertions> HaveAttribute(XName expectedName, string expectedValue);
    public AndConstraint`1<XElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> HaveAttribute(XName expectedName, string expectedValue, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XElementAssertions, XElement> HaveElement(string expected);
    public AndWhichConstraint`2<XElementAssertions, XElement> HaveElement(XName expected);
    public AndWhichConstraint`2<XElementAssertions, XElement> HaveElement(string expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XElementAssertions, XElement> HaveElement(XName expected, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XmlElementAssertions : XmlNodeAssertions`2<XmlElement, XmlElementAssertions> {
    public XmlElementAssertions(XmlElement xmlElement);
    public AndConstraint`1<XmlElementAssertions> HaveInnerText(string expected);
    public AndConstraint`1<XmlElementAssertions> HaveInnerText(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue);
    public AndConstraint`1<XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because, Object[] becauseArgs);
    public AndConstraint`1<XmlElementAssertions> HaveAttributeWithNamespace(string expectedName, string expectedNamespace, string expectedValue);
    public AndConstraint`1<XmlElementAssertions> HaveAttributeWithNamespace(string expectedName, string expectedNamespace, string expectedValue, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XmlElementAssertions, XmlElement> HaveElement(string expectedName);
    public AndWhichConstraint`2<XmlElementAssertions, XmlElement> HaveElement(string expectedName, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XmlElementAssertions, XmlElement> HaveElementWithNamespace(string expectedName, string expectedNamespace);
    public AndWhichConstraint`2<XmlElementAssertions, XmlElement> HaveElementWithNamespace(string expectedName, string expectedNamespace, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XmlNodeAssertions : XmlNodeAssertions`2<XmlNode, XmlNodeAssertions> {
    public XmlNodeAssertions(XmlNode xmlNode);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XmlNodeAssertions`2 : ReferenceTypeAssertions`2<TSubject, TAssertions> {
    protected string Identifier { get; }
    public XmlNodeAssertions`2(TSubject xmlNode);
    public AndConstraint`1<TAssertions> BeEquivalentTo(XmlNode expected);
    public AndConstraint`1<TAssertions> BeEquivalentTo(XmlNode expected, string because, Object[] reasonArgs);
    public AndConstraint`1<TAssertions> NotBeEquivalentTo(XmlNode unexpected);
    public AndConstraint`1<TAssertions> NotBeEquivalentTo(XmlNode unexpected, string because, Object[] reasonArgs);
    protected virtual string get_Identifier();
}
public class FluentAssertions.Xml.XmlNodeFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual string Format(object value, FormattingContext context, FormatChild formatChild);
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.XmlAssertionExtensions : object {
    [ExtensionAttribute]
public static XmlNodeAssertions Should(XmlNode actualValue);
    [ExtensionAttribute]
public static XmlElementAssertions Should(XmlElement actualValue);
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.AspChildControlTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TagName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ControlType>k__BackingField;
    [NotNullAttribute]
public string TagName { get; private set; }
    [NotNullAttribute]
public Type ControlType { get; private set; }
    public AspChildControlTypeAttribute(string tagName, Type controlType);
    [CompilerGeneratedAttribute]
public string get_TagName();
    [CompilerGeneratedAttribute]
private void set_TagName(string value);
    [CompilerGeneratedAttribute]
public Type get_ControlType();
    [CompilerGeneratedAttribute]
private void set_ControlType(Type value);
}
[AttributeUsageAttribute("192")]
internal class JetBrains.Annotations.AspDataFieldAttribute : Attribute {
}
[AttributeUsageAttribute("192")]
internal class JetBrains.Annotations.AspDataFieldsAttribute : Attribute {
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.AspMethodPropertyAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcActionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcActionAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2176")]
internal class JetBrains.Annotations.AspMvcActionSelectorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcAreaAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcAreaAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.AspMvcAreaMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcAreaMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.AspMvcAreaPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcAreaPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.AspMvcAreaViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcAreaViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcControllerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AnonymousProperty>k__BackingField;
    [CanBeNullAttribute]
public string AnonymousProperty { get; private set; }
    public AspMvcControllerAttribute(string anonymousProperty);
    [CompilerGeneratedAttribute]
public string get_AnonymousProperty();
    [CompilerGeneratedAttribute]
private void set_AnonymousProperty(string value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcDisplayTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcEditorTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcMasterAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.AspMvcMasterLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; private set; }
    public AspMvcMasterLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcModelTypeAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcPartialViewAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.AspMvcPartialViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcPartialViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("68")]
internal class JetBrains.Annotations.AspMvcSuppressViewErrorAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcViewAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AspMvcViewComponentAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.AspMvcViewComponentViewAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.AspMvcViewLocationFormatAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [NotNullAttribute]
public string Format { get; private set; }
    public AspMvcViewLocationFormatAttribute(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.AspRequiredAttributeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Attribute>k__BackingField;
    [NotNullAttribute]
public string Attribute { get; private set; }
    public AspRequiredAttributeAttribute(string attribute);
    [CompilerGeneratedAttribute]
public string get_Attribute();
    [CompilerGeneratedAttribute]
private void set_Attribute(string value);
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.AspTypePropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <CreateConstructorReferences>k__BackingField;
    public bool CreateConstructorReferences { get; private set; }
    public AspTypePropertyAttribute(bool createConstructorReferences);
    [CompilerGeneratedAttribute]
public bool get_CreateConstructorReferences();
    [CompilerGeneratedAttribute]
private void set_CreateConstructorReferences(bool value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.AssertionConditionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private AssertionConditionType <ConditionType>k__BackingField;
    public AssertionConditionType ConditionType { get; private set; }
    public AssertionConditionAttribute(AssertionConditionType conditionType);
    [CompilerGeneratedAttribute]
public AssertionConditionType get_ConditionType();
    [CompilerGeneratedAttribute]
private void set_ConditionType(AssertionConditionType value);
}
internal enum JetBrains.Annotations.AssertionConditionType : Enum {
    public int value__;
    public static AssertionConditionType IS_TRUE;
    public static AssertionConditionType IS_FALSE;
    public static AssertionConditionType IS_NULL;
    public static AssertionConditionType IS_NOT_NULL;
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AssertionMethodAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
internal class JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; private set; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
internal class JetBrains.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[AttributeUsageAttribute("224")]
internal class JetBrains.Annotations.CollectionAccessAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CollectionAccessType <CollectionAccessType>k__BackingField;
    public CollectionAccessType CollectionAccessType { get; private set; }
    public CollectionAccessAttribute(CollectionAccessType collectionAccessType);
    [CompilerGeneratedAttribute]
public CollectionAccessType get_CollectionAccessType();
    [CompilerGeneratedAttribute]
private void set_CollectionAccessType(CollectionAccessType value);
}
[FlagsAttribute]
internal enum JetBrains.Annotations.CollectionAccessType : Enum {
    public int value__;
    public static CollectionAccessType None;
    public static CollectionAccessType Read;
    public static CollectionAccessType ModifyExistingContent;
    public static CollectionAccessType UpdatedContent;
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    [NotNullAttribute]
public string Contract { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
private void set_Contract(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.HtmlAttributeValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public HtmlAttributeValueAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.HtmlElementAttributesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CanBeNullAttribute]
public string Name { get; private set; }
    public HtmlElementAttributesAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("1037")]
internal class JetBrains.Annotations.ImplicitNotNullAttribute : Attribute {
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InstantHandleAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemNotNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; private set; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.MacroAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Editable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    public string Expression { get; public set; }
    public int Editable { get; public set; }
    public string Target { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(string value);
    [CompilerGeneratedAttribute]
public int get_Editable();
    [CompilerGeneratedAttribute]
public void set_Editable(int value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
}
[AttributeUsageAttribute("16388")]
internal class JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; private set; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.MustUseReturnValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [CanBeNullAttribute]
public string Justification { get; private set; }
    public MustUseReturnValueAttribute(string justification);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
private void set_Justification(string value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.NoEnumerationAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.NoReorder : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CanBeNullAttribute]
public string ParameterName { get; private set; }
    public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CanBeNullAttribute]
public string BasePath { get; private set; }
    public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
private void set_BasePath(string value);
}
[AttributeUsageAttribute("19916")]
internal class JetBrains.Annotations.ProvidesContextAttribute : Attribute {
}
[MeansImplicitUseAttribute("3")]
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CanBeNullAttribute]
public string Comment { get; private set; }
    public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorDirectiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Directive>k__BackingField;
    [NotNullAttribute]
public string Directive { get; private set; }
    public RazorDirectiveAttribute(string directive);
    [CompilerGeneratedAttribute]
public string get_Directive();
    [CompilerGeneratedAttribute]
private void set_Directive(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.RazorHelperCommonAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorImportNamespaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public RazorImportNamespaceAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("1")]
internal class JetBrains.Annotations.RazorInjectionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [NotNullAttribute]
public string Type { get; private set; }
    [NotNullAttribute]
public string FieldName { get; private set; }
    public RazorInjectionAttribute(string type, string fieldName);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
private void set_FieldName(string value);
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.RazorLayoutAttribute : Attribute {
}
[AttributeUsageAttribute("2112")]
internal class JetBrains.Annotations.RazorSectionAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.RazorWriteLiteralMethodAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.RazorWriteMethodAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.RazorWriteMethodParameterAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.RegexPatternAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.SourceTemplateAttribute : Attribute {
}
[AttributeUsageAttribute("4320")]
internal class JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    [NotNullAttribute]
public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[ObsoleteAttribute("Use [ContractAnnotation('=> halt')] instead")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.TerminatesProgramAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.ValueProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public ValueProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[AttributeUsageAttribute("128")]
internal class JetBrains.Annotations.XamlItemBindingOfItemsControlAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
internal class JetBrains.Annotations.XamlItemsControlAttribute : Attribute {
}
