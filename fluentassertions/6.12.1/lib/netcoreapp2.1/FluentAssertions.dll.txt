public class FluentAssertions.AggregateExceptionExtractor : object {
    public sealed virtual IEnumerable`1<T> OfType(Exception actualException);
    private static List`1<T> GetExtractedExceptions(Exception actualException);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.AndConstraint`1 : object {
    [CompilerGeneratedAttribute]
private T <And>k__BackingField;
    public T And { get; }
    public AndConstraint`1(T parentConstraint);
    [CompilerGeneratedAttribute]
public T get_And();
}
public class FluentAssertions.AndWhichConstraint`2 : AndConstraint`1<TParentConstraint> {
    private Lazy`1<TMatchedElement> matchedConstraint;
    public TMatchedElement Which { get; }
    public TMatchedElement Subject { get; }
    public AndWhichConstraint`2(TParentConstraint parentConstraint, TMatchedElement matchedConstraint);
    public AndWhichConstraint`2(TParentConstraint parentConstraint, IEnumerable`1<TMatchedElement> matchedConstraint);
    private static TMatchedElement SingleOrDefault(IEnumerable`1<TMatchedElement> matchedConstraint);
    public TMatchedElement get_Which();
    public TMatchedElement get_Subject();
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.AssertionExtensions : object {
    private static AggregateExceptionExtractor Extractor;
    private static AssertionExtensions();
    [ExtensionAttribute]
public static Action Invoking(T subject, Action`1<T> action);
    [ExtensionAttribute]
public static Func`1<TResult> Invoking(T subject, Func`2<T, TResult> action);
    [ExtensionAttribute]
public static Func`1<Task> Awaiting(T subject, Func`2<T, Task> action);
    [ExtensionAttribute]
public static Func`1<Task`1<TResult>> Awaiting(T subject, Func`2<T, Task`1<TResult>> action);
    [ExtensionAttribute]
public static Func`1<Task> Awaiting(T subject, Func`2<T, ValueTask> action);
    [ExtensionAttribute]
public static Func`1<Task`1<TResult>> Awaiting(T subject, Func`2<T, ValueTask`1<TResult>> action);
    [ExtensionAttribute]
public static MemberExecutionTime`1<T> ExecutionTimeOf(T subject, Expression`1<Action`1<T>> action, StartTimer createTimer);
    [ExtensionAttribute]
public static ExecutionTime ExecutionTime(Action action, StartTimer createTimer);
    [ExtensionAttribute]
public static ExecutionTime ExecutionTime(Func`1<Task> action);
    [ExtensionAttribute]
public static ExecutionTimeAssertions Should(ExecutionTime executionTime);
    [ExtensionAttribute]
public static AssemblyAssertions Should(Assembly assembly);
    [ExtensionAttribute]
public static XDocumentAssertions Should(XDocument actualValue);
    [ExtensionAttribute]
public static XElementAssertions Should(XElement actualValue);
    [ExtensionAttribute]
public static XAttributeAssertions Should(XAttribute actualValue);
    [ExtensionAttribute]
public static StreamAssertions Should(Stream actualValue);
    [ExtensionAttribute]
public static BufferedStreamAssertions Should(BufferedStream actualValue);
    [ExtensionAttribute]
public static Action Enumerating(Func`1<IEnumerable> enumerable);
    [ExtensionAttribute]
public static Action Enumerating(Func`1<IEnumerable`1<T>> enumerable);
    [ExtensionAttribute]
public static Action Enumerating(T subject, Func`2<T, IEnumerable`1<TResult>> enumerable);
    private static void ForceEnumeration(Func`1<IEnumerable> enumerable);
    private static void ForceEnumeration(T subject, Func`2<T, IEnumerable> enumerable);
    [ExtensionAttribute]
public static ObjectAssertions Should(object actualValue);
    [ExtensionAttribute]
public static BooleanAssertions Should(bool actualValue);
    [ExtensionAttribute]
public static NullableBooleanAssertions Should(Nullable`1<bool> actualValue);
    [ExtensionAttribute]
public static HttpResponseMessageAssertions Should(HttpResponseMessage actualValue);
    [ExtensionAttribute]
public static GuidAssertions Should(Guid actualValue);
    [ExtensionAttribute]
public static NullableGuidAssertions Should(Nullable`1<Guid> actualValue);
    [ExtensionAttribute]
public static GenericCollectionAssertions`1<T> Should(IEnumerable`1<T> actualValue);
    [ExtensionAttribute]
public static StringCollectionAssertions Should(IEnumerable`1<string> this);
    [ExtensionAttribute]
public static GenericDictionaryAssertions`3<IDictionary`2<TKey, TValue>, TKey, TValue> Should(IDictionary`2<TKey, TValue> actualValue);
    [ExtensionAttribute]
public static GenericDictionaryAssertions`3<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TKey, TValue> Should(IEnumerable`1<KeyValuePair`2<TKey, TValue>> actualValue);
    [ExtensionAttribute]
public static GenericDictionaryAssertions`3<TCollection, TKey, TValue> Should(TCollection actualValue);
    [ExtensionAttribute]
public static GenericCollectionAssertions`1<DataTable> Should(DataTableCollection actualValue);
    [ExtensionAttribute]
public static GenericCollectionAssertions`1<DataColumn> Should(DataColumnCollection actualValue);
    [ExtensionAttribute]
public static GenericCollectionAssertions`1<DataRow> Should(DataRowCollection actualValue);
    [ExtensionAttribute]
public static DataColumnAssertions Should(DataColumn actualValue);
    [ExtensionAttribute]
public static DateTimeAssertions Should(DateTime actualValue);
    [ExtensionAttribute]
public static DateTimeOffsetAssertions Should(DateTimeOffset actualValue);
    [ExtensionAttribute]
public static NullableDateTimeAssertions Should(Nullable`1<DateTime> actualValue);
    [ExtensionAttribute]
public static NullableDateTimeOffsetAssertions Should(Nullable`1<DateTimeOffset> actualValue);
    [ExtensionAttribute]
public static ComparableTypeAssertions`1<T> Should(IComparable`1<T> comparableValue);
    [ExtensionAttribute]
public static NumericAssertions`1<int> Should(int actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<int> Should(Nullable`1<int> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<UInt32> Should(UInt32 actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<UInt32> Should(Nullable`1<UInt32> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<decimal> Should(decimal actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<decimal> Should(Nullable`1<decimal> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<byte> Should(byte actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<byte> Should(Nullable`1<byte> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<sbyte> Should(sbyte actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<sbyte> Should(Nullable`1<sbyte> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<short> Should(short actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<short> Should(Nullable`1<short> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<ushort> Should(ushort actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<ushort> Should(Nullable`1<ushort> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<long> Should(long actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<long> Should(Nullable`1<long> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<ulong> Should(ulong actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<ulong> Should(Nullable`1<ulong> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<float> Should(float actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<float> Should(Nullable`1<float> actualValue);
    [ExtensionAttribute]
public static NumericAssertions`1<double> Should(double actualValue);
    [ExtensionAttribute]
public static NullableNumericAssertions`1<double> Should(Nullable`1<double> actualValue);
    [ExtensionAttribute]
public static StringAssertions Should(string actualValue);
    [ExtensionAttribute]
public static SimpleTimeSpanAssertions Should(TimeSpan actualValue);
    [ExtensionAttribute]
public static NullableSimpleTimeSpanAssertions Should(Nullable`1<TimeSpan> actualValue);
    [ExtensionAttribute]
public static TypeAssertions Should(Type subject);
    [ExtensionAttribute]
public static TypeSelectorAssertions Should(TypeSelector typeSelector);
    [ExtensionAttribute]
public static ConstructorInfoAssertions Should(ConstructorInfo constructorInfo);
    [ExtensionAttribute]
public static MethodInfoAssertions Should(MethodInfo methodInfo);
    [ExtensionAttribute]
public static MethodInfoSelectorAssertions Should(MethodInfoSelector methodSelector);
    [ExtensionAttribute]
public static PropertyInfoAssertions Should(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static PropertyInfoSelectorAssertions Should(PropertyInfoSelector propertyInfoSelector);
    [ExtensionAttribute]
public static ActionAssertions Should(Action action);
    [ExtensionAttribute]
public static NonGenericAsyncFunctionAssertions Should(Func`1<Task> action);
    [ExtensionAttribute]
public static GenericAsyncFunctionAssertions`1<T> Should(Func`1<Task`1<T>> action);
    [ExtensionAttribute]
public static FunctionAssertions`1<T> Should(Func`1<T> func);
    [ExtensionAttribute]
public static TaskCompletionSourceAssertions`1<T> Should(TaskCompletionSource`1<T> tcs);
    [ExtensionAttribute]
public static IMonitor`1<T> Monitor(T eventSource, Func`1<DateTime> utcNow);
    [ExtensionAttribute]
public static TTo As(object subject);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(ReferenceTypeAssertions`2<TSubject, TAssertions> _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(BooleanAssertions`1<TAssertions> _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(DateTimeAssertions`1<TAssertions> _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(DateTimeOffsetAssertions`1<TAssertions> _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(ExecutionTimeAssertions _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(GuidAssertions`1<TAssertions> _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(MethodInfoSelectorAssertions _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(NumericAssertions`2<TSubject, TAssertions> _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(PropertyInfoSelectorAssertions _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(SimpleTimeSpanAssertions`1<TAssertions> _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(TaskCompletionSourceAssertionsBase _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(TypeSelectorAssertions _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(EnumAssertions`2<TEnum, TAssertions> _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(DateTimeRangeAssertions`1<TAssertions> _);
    [ExtensionAttribute]
[ObsoleteAttribute("You are asserting the 'AndConstraint' itself. Remove the 'Should()' method directly following 'And'", "True")]
public static void Should(DateTimeOffsetRangeAssertions`1<TAssertions> _);
    [DoesNotReturnAttribute]
private static void InvalidShouldCall();
}
public static class FluentAssertions.AssertionOptions : object {
    private static EquivalencyAssertionOptions defaults;
    [CompilerGeneratedAttribute]
private static EquivalencyPlan <EquivalencyPlan>k__BackingField;
    [CompilerGeneratedAttribute]
private static FormattingOptions <FormattingOptions>k__BackingField;
    public static EquivalencyPlan EquivalencyPlan { get; }
    public static FormattingOptions FormattingOptions { get; }
    private static AssertionOptions();
    public static EquivalencyAssertionOptions`1<T> CloneDefaults();
    internal static TOptions CloneDefaults(Func`2<EquivalencyAssertionOptions, TOptions> predicate);
    public static void AssertEquivalencyUsing(Func`2<EquivalencyAssertionOptions, EquivalencyAssertionOptions> defaultsConfigurer);
    [CompilerGeneratedAttribute]
public static EquivalencyPlan get_EquivalencyPlan();
    [CompilerGeneratedAttribute]
public static FormattingOptions get_FormattingOptions();
}
[ExtensionAttribute]
public static class FluentAssertions.AsyncAssertionsExtensions : object {
    [AsyncStateMachineAttribute("FluentAssertions.AsyncAssertionsExtensions/<WithResult>d__0`1")]
[ExtensionAttribute]
public static Task`1<AndWhichConstraint`2<GenericAsyncFunctionAssertions`1<T>, T>> WithResult(Task`1<AndWhichConstraint`2<GenericAsyncFunctionAssertions`1<T>, T>> task, T expected, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.AsyncAssertionsExtensions/<WithResult>d__1`1")]
[ExtensionAttribute]
public static Task`1<AndWhichConstraint`2<TaskCompletionSourceAssertions`1<T>, T>> WithResult(Task`1<AndWhichConstraint`2<TaskCompletionSourceAssertions`1<T>, T>> task, T expected, string because, Object[] becauseArgs);
}
public static class FluentAssertions.AtLeast : object {
    public static OccurrenceConstraint Once();
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
public static class FluentAssertions.AtMost : object {
    public static OccurrenceConstraint Once();
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
internal class FluentAssertions.CallerIdentification.AddNonEmptySymbolParsingStrategy : object {
    private Mode mode;
    private Nullable`1<char> precedingSymbol;
    public sealed virtual ParsingState Parse(char symbol, StringBuilder statement);
    public sealed virtual bool IsWaitingForContextEnd();
    public sealed virtual void NotifyEndOfLineReached();
}
internal class FluentAssertions.CallerIdentification.AwaitParsingStrategy : object {
    private static string KeywordToSkip;
    public sealed virtual ParsingState Parse(char symbol, StringBuilder statement);
    private static bool EndsWithOurKeyword(StringBuilder statement);
    private static bool IsLongEnoughToContainOurKeyword(StringBuilder statement);
    public sealed virtual bool IsWaitingForContextEnd();
    public sealed virtual void NotifyEndOfLineReached();
}
internal class FluentAssertions.CallerIdentification.CallerStatementBuilder : object {
    private StringBuilder statement;
    private List`1<IParsingStrategy> priorityOrderedParsingStrategies;
    private ParsingState parsingState;
    internal void Append(string symbols);
    internal bool IsDone();
    public virtual string ToString();
}
internal interface FluentAssertions.CallerIdentification.IParsingStrategy {
    public abstract virtual ParsingState Parse(char symbol, StringBuilder statement);
    public abstract virtual bool IsWaitingForContextEnd();
    public abstract virtual void NotifyEndOfLineReached();
}
internal class FluentAssertions.CallerIdentification.MultiLineCommentParsingStrategy : object {
    private bool isCommentContext;
    private Nullable`1<char> commentContextPreviousChar;
    public sealed virtual ParsingState Parse(char symbol, StringBuilder statement);
    public sealed virtual bool IsWaitingForContextEnd();
    public sealed virtual void NotifyEndOfLineReached();
}
internal enum FluentAssertions.CallerIdentification.ParsingState : Enum {
    public int value__;
    public static ParsingState InProgress;
    public static ParsingState GoToNextSymbol;
    public static ParsingState Done;
}
internal class FluentAssertions.CallerIdentification.QuotesParsingStrategy : object {
    private char isQuoteEscapeSymbol;
    private bool isQuoteContext;
    private Nullable`1<char> previousChar;
    public sealed virtual ParsingState Parse(char symbol, StringBuilder statement);
    public sealed virtual bool IsWaitingForContextEnd();
    public sealed virtual void NotifyEndOfLineReached();
    private bool IsVerbatim(StringBuilder statement);
}
internal class FluentAssertions.CallerIdentification.SemicolonParsingStrategy : object {
    public sealed virtual ParsingState Parse(char symbol, StringBuilder statement);
    public sealed virtual bool IsWaitingForContextEnd();
    public sealed virtual void NotifyEndOfLineReached();
}
internal class FluentAssertions.CallerIdentification.ShouldCallParsingStrategy : object {
    private static string ShouldCall;
    public sealed virtual ParsingState Parse(char symbol, StringBuilder statement);
    public sealed virtual bool IsWaitingForContextEnd();
    public sealed virtual void NotifyEndOfLineReached();
}
internal class FluentAssertions.CallerIdentification.SingleLineCommentParsingStrategy : object {
    private bool isCommentContext;
    public sealed virtual ParsingState Parse(char symbol, StringBuilder statement);
    public sealed virtual bool IsWaitingForContextEnd();
    public sealed virtual void NotifyEndOfLineReached();
}
public static class FluentAssertions.CallerIdentifier : object {
    [CompilerGeneratedAttribute]
private static Action`1<string> <Logger>k__BackingField;
    private static AsyncLocal`1<StackFrameReference> StartStackSearchAfterStackFrame;
    public static Action`1<string> Logger { get; public set; }
    private static CallerIdentifier();
    [CompilerGeneratedAttribute]
public static Action`1<string> get_Logger();
    [CompilerGeneratedAttribute]
public static void set_Logger(Action`1<string> value);
    public static string DetermineCallerIdentity();
    internal static IDisposable OverrideStackSearchUsingCurrentScope();
    internal static bool OnlyOneFluentAssertionScopeOnCallStack();
    private static bool IsCustomAssertion(StackFrame frame);
    private static bool IsDynamic(StackFrame frame);
    private static bool IsCurrentAssembly(StackFrame frame);
    private static bool IsDotNet(StackFrame frame);
    private static bool IsCompilerServices(StackFrame frame);
    private static string ExtractVariableNameFrom(StackFrame frame);
    private static string GetSourceCodeStatementFrom(StackFrame frame);
    private static string GetSourceCodeStatementFrom(StackFrame frame, StreamReader reader, string line);
    private static bool StartsWithNewKeyword(string candidate);
    private static bool IsStringLiteral(string candidate);
    private static bool IsNumeric(string candidate);
    private static bool IsBooleanLiteral(string candidate);
    private static StackFrame[] GetFrames(StackTrace stack);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.GenericCollectionAssertions`1 : GenericCollectionAssertions`3<IEnumerable`1<T>, T, GenericCollectionAssertions`1<T>> {
    public GenericCollectionAssertions`1(IEnumerable`1<T> actualValue);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.GenericCollectionAssertions`2 : GenericCollectionAssertions`3<TCollection, T, GenericCollectionAssertions`2<TCollection, T>> {
    public GenericCollectionAssertions`2(TCollection actualValue);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.GenericCollectionAssertions`3 : ReferenceTypeAssertions`2<TCollection, TAssertions> {
    protected string Identifier { get; }
    public GenericCollectionAssertions`3(TCollection actualValue);
    protected virtual string get_Identifier();
    public AndWhichConstraint`2<TAssertions, IEnumerable`1<TExpectation>> AllBeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllBeAssignableTo(Type expectedType, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllBeEquivalentTo(TExpectation expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllBeEquivalentTo(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, IEnumerable`1<TExpectation>> AllBeOfType(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllBeOfType(Type expectedType, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(IEnumerable`1<TExpectation> expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(IEnumerable`1<TExpectation> expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInAscendingOrder(IComparer`1<T> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInAscendingOrder(string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInAscendingOrder(Func`3<T, T, int> comparison, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInDescendingOrder(IComparer`1<T> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInDescendingOrder(string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInDescendingOrder(Func`3<T, T, int> comparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNullOrEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeSubsetOf(IEnumerable`1<T> expectedSuperset, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> Contain(T expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> Contain(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Contain(IEnumerable`1<T> expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> ContainEquivalentOf(TExpectation expectation, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> ContainEquivalentOf(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainInOrder(T[] expected);
    public AndConstraint`1<TAssertions> ContainInOrder(IEnumerable`1<T> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainInConsecutiveOrder(T[] expected);
    public AndConstraint`1<TAssertions> ContainInConsecutiveOrder(IEnumerable`1<T> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainItemsAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainItemsAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainItemsAssignableTo(Type type, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> ContainSingle(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> ContainSingle(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> EndWith(IEnumerable`1<T> expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> EndWith(IEnumerable`1<TExpectation> expectation, Func`3<T, TExpectation, bool> equalityComparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> EndWith(T element, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Equal(T[] elements);
    public AndConstraint`1<TAssertions> Equal(IEnumerable`1<TExpectation> expectation, Func`3<T, TExpectation, bool> equalityComparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Equal(IEnumerable`1<T> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCount(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCount(Expression`1<Func`2<int, bool>> countPredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCountGreaterThanOrEqualTo(int expected, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> HaveCountGreaterOrEqualTo(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCountGreaterThan(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCountLessThanOrEqualTo(int expected, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> HaveCountLessOrEqualTo(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveCountLessThan(int expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> HaveElementAt(int index, T element, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveElementPreceding(T successor, T expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveElementSucceeding(T predecessor, T expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveSameCount(IEnumerable`1<TExpectation> otherCollection, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> IntersectWith(IEnumerable`1<T> otherCollection, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEquivalentTo(IEnumerable`1<TExpectation> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEquivalentTo(IEnumerable`1<TExpectation> unexpected, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInAscendingOrder(IComparer`1<T> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInAscendingOrder(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInAscendingOrder(Func`3<T, T, int> comparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInDescendingOrder(IComparer`1<T> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInDescendingOrder(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInDescendingOrder(Func`3<T, T, int> comparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNullOrEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeSubsetOf(IEnumerable`1<T> unexpectedSuperset, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> NotContain(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContain(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContain(IEnumerable`1<T> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainEquivalentOf(TExpectation unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainEquivalentOf(TExpectation unexpected, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainInOrder(T[] unexpected);
    public AndConstraint`1<TAssertions> NotContainInOrder(IEnumerable`1<T> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainInConsecutiveOrder(T[] unexpected);
    public AndConstraint`1<TAssertions> NotContainInConsecutiveOrder(IEnumerable`1<T> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainNulls(Expression`1<Func`2<T, TKey>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainNulls(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotEqual(IEnumerable`1<T> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveCount(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveSameCount(IEnumerable`1<TExpectation> otherCollection, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotIntersectWith(IEnumerable`1<T> otherCollection, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> OnlyContain(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> OnlyHaveUniqueItems(Expression`1<Func`2<T, TKey>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> OnlyHaveUniqueItems(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllSatisfy(Action`1<T> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> SatisfyRespectively(Action`1[] elementInspectors);
    public AndConstraint`1<TAssertions> SatisfyRespectively(IEnumerable`1<Action`1<T>> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Satisfy(Expression`1[] predicates);
    public AndConstraint`1<TAssertions> Satisfy(IEnumerable`1<Expression`1<Func`2<T, bool>>> predicates, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> StartWith(IEnumerable`1<T> expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> StartWith(IEnumerable`1<TExpectation> expectation, Func`3<T, TExpectation, bool> equalityComparison, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> StartWith(T element, string because, Object[] becauseArgs);
    internal AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeOrderedBy(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, SortOrder direction, string because, Object[] becauseArgs);
    internal virtual IOrderedEnumerable`1<T> GetOrderedEnumerable(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, SortOrder direction, ICollection`1<T> unordered);
    protected static IEnumerable`1<TExpectation> RepeatAsManyAs(TExpectation value, IEnumerable`1<T> enumerable);
    protected void AssertCollectionEndsWith(IEnumerable`1<TActual> actual, ICollection`1<TExpectation> expected, Func`3<TActual, TExpectation, bool> equalityComparison, string because, Object[] becauseArgs);
    protected void AssertCollectionStartsWith(IEnumerable`1<TActual> actualItems, ICollection`1<TExpectation> expected, Func`3<TActual, TExpectation, bool> equalityComparison, string because, Object[] becauseArgs);
    protected void AssertSubjectEquality(IEnumerable`1<TExpectation> expectation, Func`3<T, TExpectation, bool> equalityComparison, string because, Object[] becauseArgs);
    private static string GetExpressionOrderString(Expression`1<Func`2<T, TSelector>> propertyExpression);
    private static Type GetType(TType o);
    private static bool HasPredecessor(T successor, TCollection subject);
    private static bool HasSuccessor(T predecessor, TCollection subject);
    private static T PredecessorOf(T successor, TCollection subject);
    [IteratorStateMachineAttribute("FluentAssertions.Collections.GenericCollectionAssertions`3/<RepeatAsManyAsIterator>d__109`1")]
private static IEnumerable`1<TExpectation> RepeatAsManyAsIterator(TExpectation value, IEnumerable`1<T> enumerable);
    private static T SuccessorOf(T predecessor, TCollection subject);
    private String[] CollectFailuresFromInspectors(IEnumerable`1<Action`1<T>> elementInspectors);
    private bool IsValidProperty(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] becauseArgs);
    private AndConstraint`1<TAssertions> NotBeOrderedBy(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, SortOrder direction, string because, Object[] becauseArgs);
    private AndConstraint`1<SubsequentOrderingAssertions`1<T>> BeInOrder(IComparer`1<T> comparer, SortOrder expectedOrder, string because, Object[] becauseArgs);
    private AndConstraint`1<TAssertions> NotBeInOrder(IComparer`1<T> comparer, SortOrder order, string because, Object[] becauseArgs);
    public virtual bool Equals(object obj);
    private static int IndexOf(IList`1<T> items, T item, int startIndex);
    private static int ConsecutiveItemCount(IList`1<T> actualItems, IList`1<T> expectedItems, int startIndex);
    private protected static IComparer`1<TItem> GetComparer();
    [CompilerGeneratedAttribute]
private object <AllBeAssignableTo>b__3_2();
    [CompilerGeneratedAttribute]
private object <AllBeOfType>b__7_2();
    [CompilerGeneratedAttribute]
private ICollection`1<T> <ContainItemsAssignableTo>b__33_0();
    [CompilerGeneratedAttribute]
private TCollection <NotBeEmpty>b__57_0();
    [CompilerGeneratedAttribute]
private TCollection <Satisfy>b__94_0();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.GenericDictionaryAssertions`3 : GenericDictionaryAssertions`4<TCollection, TKey, TValue, GenericDictionaryAssertions`3<TCollection, TKey, TValue>> {
    public GenericDictionaryAssertions`3(TCollection keyValuePairs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.GenericDictionaryAssertions`4 : GenericCollectionAssertions`3<TCollection, KeyValuePair`2<TKey, TValue>, TAssertions> {
    protected string Identifier { get; }
    public GenericDictionaryAssertions`4(TCollection keyValuePairs);
    public AndConstraint`1<TAssertions> Equal(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotEqual(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(TExpectation expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public WhoseValueConstraint`4<TCollection, TKey, TValue, TAssertions> ContainKey(TKey expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainKeys(TKey[] expected);
    public AndConstraint`1<TAssertions> ContainKeys(IEnumerable`1<TKey> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainKey(TKey unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainKeys(TKey[] unexpected);
    public AndConstraint`1<TAssertions> NotContainKeys(IEnumerable`1<TKey> unexpected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, TValue> ContainValue(TValue expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainValues(TValue[] expected);
    public AndConstraint`1<TAssertions> ContainValues(IEnumerable`1<TValue> expected, string because, Object[] becauseArgs);
    private AndWhichConstraint`2<TAssertions, IEnumerable`1<TValue>> ContainValuesAndWhich(IEnumerable`1<TValue> expected, string because, Object[] becauseArgs);
    private static IEnumerable`1<TValue> RepetitionPreservingIntersect(IEnumerable`1<TValue> first, IEnumerable`1<TValue> second);
    public AndConstraint`1<TAssertions> NotContainValue(TValue unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainValues(TValue[] unexpected);
    public AndConstraint`1<TAssertions> NotContainValues(IEnumerable`1<TValue> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Contain(KeyValuePair`2[] expected);
    public AndConstraint`1<TAssertions> Contain(IEnumerable`1<KeyValuePair`2<TKey, TValue>> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Contain(KeyValuePair`2<TKey, TValue> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Contain(TKey key, TValue value, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContain(KeyValuePair`2[] items);
    public AndConstraint`1<TAssertions> NotContain(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContain(KeyValuePair`2<TKey, TValue> item, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContain(TKey key, TValue value, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
    private static IEnumerable`1<TKey> GetKeys(TCollection collection);
    private static IEnumerable`1<TKey> GetKeys(T collection);
    private static IEnumerable`1<TValue> GetValues(TCollection collection);
    private static bool ContainsKey(TCollection collection, TKey key);
    private static bool TryGetValue(TCollection collection, TKey key, TValue& value);
    private static TValue GetValue(TCollection collection, TKey key);
    private static TValue GetValue(T collection, TKey key);
    [CompilerGeneratedAttribute]
private bool <ContainKeys>b__7_0(TKey key);
    [CompilerGeneratedAttribute]
private bool <NotContainKeys>b__10_0(TKey key);
    [CompilerGeneratedAttribute]
private bool <Contain>b__20_1(TKey key);
    [CompilerGeneratedAttribute]
private bool <NotContain>b__24_0(KeyValuePair`2<TKey, TValue> keyValuePair);
}
internal class FluentAssertions.Collections.MaximumMatching.Element`1 : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    public int Index { get; }
    public TValue Value { get; }
    public Element`1(TValue value, int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public TValue get_Value();
}
internal class FluentAssertions.Collections.MaximumMatching.MaximumMatchingProblem`1 : object {
    [CompilerGeneratedAttribute]
private List`1<Predicate`1<TValue>> <Predicates>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Element`1<TValue>> <Elements>k__BackingField;
    public List`1<Predicate`1<TValue>> Predicates { get; }
    public List`1<Element`1<TValue>> Elements { get; }
    public MaximumMatchingProblem`1(IEnumerable`1<Expression`1<Func`2<TValue, bool>>> predicates, IEnumerable`1<TValue> elements);
    [CompilerGeneratedAttribute]
public List`1<Predicate`1<TValue>> get_Predicates();
    [CompilerGeneratedAttribute]
public List`1<Element`1<TValue>> get_Elements();
    public MaximumMatchingSolution`1<TValue> Solve();
}
internal class FluentAssertions.Collections.MaximumMatching.MaximumMatchingSolution`1 : object {
    private Dictionary`2<Predicate`1<TValue>, Element`1<TValue>> elementsByMatchedPredicate;
    private MaximumMatchingProblem`1<TValue> problem;
    public bool UnmatchedPredicatesExist { get; }
    public bool UnmatchedElementsExist { get; }
    public MaximumMatchingSolution`1(MaximumMatchingProblem`1<TValue> problem, Dictionary`2<Predicate`1<TValue>, Element`1<TValue>> elementsByMatchedPredicate);
    public bool get_UnmatchedPredicatesExist();
    public bool get_UnmatchedElementsExist();
    public List`1<Predicate`1<TValue>> GetUnmatchedPredicates();
    public List`1<Element`1<TValue>> GetUnmatchedElements();
}
internal class FluentAssertions.Collections.MaximumMatching.MaximumMatchingSolver`1 : object {
    private MaximumMatchingProblem`1<TValue> problem;
    private Dictionary`2<Predicate`1<TValue>, List`1<Element`1<TValue>>> matchingElementsByPredicate;
    public MaximumMatchingSolver`1(MaximumMatchingProblem`1<TValue> problem);
    public MaximumMatchingSolution`1<TValue> Solve();
    private IEnumerable`1<Match<TValue>> FindMatchForPredicate(Predicate`1<TValue> predicate, MatchCollection<TValue> currentMatches);
    private List`1<Element`1<TValue>> GetMatchingElements(Predicate`1<TValue> predicate);
}
internal class FluentAssertions.Collections.MaximumMatching.Predicate`1 : object {
    private Func`2<TValue, bool> compiledExpression;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression`1<Func`2<TValue, bool>> <Expression>k__BackingField;
    public int Index { get; }
    public Expression`1<Func`2<TValue, bool>> Expression { get; }
    public Predicate`1(Expression`1<Func`2<TValue, bool>> expression, int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public Expression`1<Func`2<TValue, bool>> get_Expression();
    public bool Matches(TValue element);
    public virtual string ToString();
}
internal enum FluentAssertions.Collections.SortOrder : Enum {
    public int value__;
    public static SortOrder Ascending;
    public static SortOrder Descending;
}
public class FluentAssertions.Collections.StringCollectionAssertions : StringCollectionAssertions`1<IEnumerable`1<string>> {
    public StringCollectionAssertions(IEnumerable`1<string> actualValue);
}
public class FluentAssertions.Collections.StringCollectionAssertions`1 : StringCollectionAssertions`2<TCollection, StringCollectionAssertions`1<TCollection>> {
    public StringCollectionAssertions`1(TCollection actualValue);
}
public class FluentAssertions.Collections.StringCollectionAssertions`2 : GenericCollectionAssertions`3<TCollection, string, TAssertions> {
    public StringCollectionAssertions`2(TCollection actualValue);
    public AndConstraint`1<TAssertions> Equal(String[] expected);
    public AndConstraint`1<TAssertions> Equal(IEnumerable`1<string> expected);
    public AndConstraint`1<TAssertions> BeEquivalentTo(String[] expectation);
    public AndConstraint`1<TAssertions> BeEquivalentTo(IEnumerable`1<string> expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(IEnumerable`1<string> expectation, Func`2<EquivalencyAssertionOptions`1<string>, EquivalencyAssertionOptions`1<string>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllBe(string expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> AllBe(string expectation, Func`2<EquivalencyAssertionOptions`1<string>, EquivalencyAssertionOptions`1<string>> config, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, string> ContainMatch(string wildcardPattern, string because, Object[] becauseArgs);
    private bool ContainsMatch(string wildcardPattern);
    private IEnumerable`1<string> AllThatMatch(string wildcardPattern);
    public AndConstraint`1<TAssertions> NotContainMatch(string wildcardPattern, string because, Object[] becauseArgs);
    private bool NotContainsMatch(string wildcardPattern);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.SubsequentOrderingAssertions`1 : SubsequentOrderingGenericCollectionAssertions`3<IEnumerable`1<T>, T, SubsequentOrderingAssertions`1<T>> {
    public SubsequentOrderingAssertions`1(IEnumerable`1<T> actualValue, IOrderedEnumerable`1<T> previousOrderedEnumerable);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.SubsequentOrderingGenericCollectionAssertions`2 : SubsequentOrderingGenericCollectionAssertions`3<TCollection, T, SubsequentOrderingGenericCollectionAssertions`2<TCollection, T>> {
    public SubsequentOrderingGenericCollectionAssertions`2(TCollection actualValue, IOrderedEnumerable`1<T> previousOrderedEnumerable);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Collections.SubsequentOrderingGenericCollectionAssertions`3 : GenericCollectionAssertions`3<TCollection, T, TAssertions> {
    private IOrderedEnumerable`1<T> previousOrderedEnumerable;
    private bool subsequentOrdering;
    public SubsequentOrderingGenericCollectionAssertions`3(TCollection actualValue, IOrderedEnumerable`1<T> previousOrderedEnumerable);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> ThenBeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> ThenBeInAscendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> ThenBeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<SubsequentOrderingAssertions`1<T>> ThenBeInDescendingOrder(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, string because, Object[] becauseArgs);
    private AndConstraint`1<SubsequentOrderingAssertions`1<T>> ThenBeOrderedBy(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, SortOrder direction, string because, Object[] becauseArgs);
    internal sealed virtual IOrderedEnumerable`1<T> GetOrderedEnumerable(Expression`1<Func`2<T, TSelector>> propertyExpression, IComparer`1<TSelector> comparer, SortOrder direction, ICollection`1<T> unordered);
}
public class FluentAssertions.Collections.WhoseValueConstraint`4 : AndConstraint`1<TAssertions> {
    [CompilerGeneratedAttribute]
private TValue <WhoseValue>k__BackingField;
    public TValue WhoseValue { get; }
    public WhoseValueConstraint`4(TAssertions parentConstraint, TValue value);
    [CompilerGeneratedAttribute]
public TValue get_WhoseValue();
}
internal class FluentAssertions.Common.AppSettingsConfigurationStore : object {
    public sealed virtual string GetSetting(string name);
}
internal class FluentAssertions.Common.Clock : object {
    public sealed virtual void Delay(TimeSpan timeToDelay);
    public sealed virtual Task DelayAsync(TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual ITimer StartTimer();
}
public class FluentAssertions.Common.Configuration : object {
    private static string TestFrameworkConfigurationKey;
    private object propertiesAccessLock;
    private IConfigurationStore store;
    private string valueFormatterAssembly;
    private Nullable`1<ValueFormatterDetectionMode> valueFormatterDetectionMode;
    private string testFrameworkName;
    public static Configuration Current { get; }
    public ValueFormatterDetectionMode ValueFormatterDetectionMode { get; public set; }
    public string ValueFormatterAssembly { get; public set; }
    public string TestFrameworkName { get; public set; }
    public Configuration(IConfigurationStore store);
    public static Configuration get_Current();
    public ValueFormatterDetectionMode get_ValueFormatterDetectionMode();
    public void set_ValueFormatterDetectionMode(ValueFormatterDetectionMode value);
    private ValueFormatterDetectionMode DetermineFormatterDetectionMode();
    public string get_ValueFormatterAssembly();
    public void set_ValueFormatterAssembly(string value);
    public string get_TestFrameworkName();
    public void set_TestFrameworkName(string value);
}
internal class FluentAssertions.Common.ConfigurationStoreExceptionInterceptor : object {
    private IConfigurationStore configurationStore;
    private bool underlyingStoreUnavailable;
    public ConfigurationStoreExceptionInterceptor(IConfigurationStore configurationStore);
    public sealed virtual string GetSetting(string name);
}
public enum FluentAssertions.Common.CSharpAccessModifier : Enum {
    public int value__;
    public static CSharpAccessModifier Public;
    public static CSharpAccessModifier Private;
    public static CSharpAccessModifier Protected;
    public static CSharpAccessModifier Internal;
    public static CSharpAccessModifier ProtectedInternal;
    public static CSharpAccessModifier InvalidForCSharp;
    public static CSharpAccessModifier PrivateProtected;
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.CSharpAccessModifierExtensions : object {
    [ExtensionAttribute]
internal static CSharpAccessModifier GetCSharpAccessModifier(MethodBase methodBase);
    [ExtensionAttribute]
internal static CSharpAccessModifier GetCSharpAccessModifier(FieldInfo fieldInfo);
    [ExtensionAttribute]
internal static CSharpAccessModifier GetCSharpAccessModifier(Type type);
}
[ExtensionAttribute]
public static class FluentAssertions.Common.DateTimeExtensions : object {
    [ExtensionAttribute]
public static DateTimeOffset ToDateTimeOffset(DateTime dateTime);
    [ExtensionAttribute]
public static DateTimeOffset ToDateTimeOffset(DateTime dateTime, TimeSpan offset);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.DictionaryHelpers : object {
    [ExtensionAttribute]
public static IEnumerable`1<TKey> GetKeys(TCollection collection);
    [ExtensionAttribute]
public static IEnumerable`1<TValue> GetValues(TCollection collection);
    [ExtensionAttribute]
public static bool ContainsKey(TCollection collection, TKey key);
    [ExtensionAttribute]
public static bool TryGetValue(TCollection collection, TKey key, TValue& value);
    [ExtensionAttribute]
public static TValue GetValue(TCollection collection, TKey key);
    [CompilerGeneratedAttribute]
internal static bool <ContainsKey>g__ContainsKey|2_0(TCollection collection, TKey key);
    [CompilerGeneratedAttribute]
internal static bool <TryGetValue>g__TryGetValue|3_0(TCollection collection, TKey key, TValue& value);
    [CompilerGeneratedAttribute]
internal static TValue <GetValue>g__GetValue|4_0(TCollection collection, TKey key);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.EnumerableExtensions : object {
    [ExtensionAttribute]
public static ICollection`1<T> ConvertOrCastToCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IList`1<T> ConvertOrCastToList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static int IndexOfFirstDifferenceWith(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, bool> equalityComparison);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.ExceptionExtensions : object {
    [ExtensionAttribute]
public static ExceptionDispatchInfo Unwrap(TargetInvocationException exception);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.ExpressionExtensions : object {
    [ExtensionAttribute]
public static PropertyInfo GetPropertyInfo(Expression`1<Func`2<T, TValue>> expression);
    private static MemberInfo AttemptToGetMemberInfoFromExpression(Expression`1<Func`2<T, TValue>> expression);
    [ExtensionAttribute]
public static MemberPath GetMemberPath(Expression`1<Func`2<TDeclaringType, TPropertyType>> expression);
    [ExtensionAttribute]
public static void ValidateMemberPath(Expression`1<Func`2<TDeclaringType, TPropertyType>> expression);
    private static string GetUnsupportedExpressionMessage(Expression expression);
}
internal class FluentAssertions.Common.FullFrameworkReflector : object {
    public sealed virtual IEnumerable`1<Type> GetAllTypesFromAppDomain(Func`2<Assembly, bool> predicate);
    private static bool IsRelevant(Assembly ass);
    private static bool IsDynamic(Assembly assembly);
    private static IEnumerable`1<Type> GetExportedTypes(Assembly assembly);
}
internal static class FluentAssertions.Common.Guard : object {
    public static void ThrowIfArgumentIsNull(T obj, string paramName);
    public static void ThrowIfArgumentIsNull(T obj, string paramName, string message);
    public static void ThrowIfArgumentIsNullOrEmpty(string str, string paramName);
    public static void ThrowIfArgumentIsNullOrEmpty(string str, string paramName, string message);
    public static void ThrowIfArgumentIsOutOfRange(T value, string paramName);
    public static void ThrowIfArgumentContainsNull(IEnumerable`1<T> values, string paramName);
    public static void ThrowIfArgumentIsEmpty(IEnumerable`1<T> values, string paramName, string message);
    public static void ThrowIfArgumentIsEmpty(string str, string paramName, string message);
    public static void ThrowIfArgumentIsNegative(TimeSpan timeSpan, string paramName);
    public static void ThrowIfArgumentIsNegative(float value, string paramName);
    public static void ThrowIfArgumentIsNegative(double value, string paramName);
    public static void ThrowIfArgumentIsNegative(decimal value, string paramName);
}
public interface FluentAssertions.Common.IClock {
    public abstract virtual void Delay(TimeSpan timeToDelay);
    public abstract virtual Task DelayAsync(TimeSpan delay, CancellationToken cancellationToken);
    public abstract virtual ITimer StartTimer();
}
public interface FluentAssertions.Common.ICollectionWrapper`1 {
    public TCollection UnderlyingCollection { get; }
    public abstract virtual TCollection get_UnderlyingCollection();
}
public interface FluentAssertions.Common.IConfigurationStore {
    public abstract virtual string GetSetting(string name);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.IntegerExtensions : object {
    [ExtensionAttribute]
public static string Times(int count);
    [ExtensionAttribute]
internal static bool IsConsecutiveTo(int startNumber, int endNumber);
}
public interface FluentAssertions.Common.IReflector {
    public abstract virtual IEnumerable`1<Type> GetAllTypesFromAppDomain(Func`2<Assembly, bool> predicate);
}
internal class FluentAssertions.Common.Iterator`1 : object {
    private static int InitialIndex;
    private IEnumerable`1<T> enumerable;
    private Nullable`1<int> maxItems;
    private IEnumerator`1<T> enumerator;
    private T current;
    private T next;
    private bool hasNext;
    private bool hasCurrent;
    private bool hasCompleted;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; private set; }
    public bool IsFirst { get; }
    public bool IsLast { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public T Current { get; private set; }
    public bool HasReachedMaxItems { get; }
    public bool IsEmpty { get; }
    public Iterator`1(IEnumerable`1<T> enumerable, int maxItems);
    public sealed virtual void Reset();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    public bool get_IsFirst();
    public bool get_IsLast();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual T get_Current();
    private void set_Current(T value);
    public sealed virtual bool MoveNext();
    private bool FetchCurrent();
    public bool get_HasReachedMaxItems();
    private void PrefetchNext();
    public bool get_IsEmpty();
    public sealed virtual void Dispose();
}
public interface FluentAssertions.Common.ITimer {
    public TimeSpan Elapsed { get; }
    public abstract virtual TimeSpan get_Elapsed();
}
internal class FluentAssertions.Common.MemberPath : object {
    private string dottedPath;
    private Type reflectedType;
    private Type declaringType;
    private String[] segments;
    private static MemberPathSegmentEqualityComparer MemberPathSegmentEqualityComparer;
    private String[] Segments { get; }
    public string MemberName { get; }
    public MemberPath(IMember member, string parentPath);
    public MemberPath(Type reflectedType, Type declaringType, string dottedPath);
    public MemberPath(string dottedPath);
    private static MemberPath();
    public bool IsParentOrChildOf(MemberPath candidate);
    public bool IsSameAs(MemberPath candidate);
    private bool IsParentOf(MemberPath candidate);
    private bool IsChildOf(MemberPath candidate);
    public MemberPath AsParentCollectionOf(MemberPath nextPath);
    public bool IsEquivalentTo(string path);
    public bool HasSameParentAs(MemberPath path);
    private IEnumerable`1<string> GetParentSegments();
    public bool GetContainsSpecificCollectionIndex();
    private String[] get_Segments();
    public MemberPath WithCollectionAsRoot();
    public string get_MemberName();
    public virtual string ToString();
}
internal class FluentAssertions.Common.MemberPathSegmentEqualityComparer : object {
    private static string AnyIndexQualifier;
    private static Regex IndexQualifierRegex;
    private static MemberPathSegmentEqualityComparer();
    public sealed virtual bool Equals(string x, string y);
    private static bool IsIndexQualifier(string segment);
    public sealed virtual int GetHashCode(string obj);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.MethodInfoExtensions : object {
    private static Lazy`1<int> ImplementationOptionsMask;
    private static MethodInfoExtensions();
    [ExtensionAttribute]
internal static bool IsAsync(MethodInfo methodInfo);
    [ExtensionAttribute]
internal static IEnumerable`1<TAttribute> GetMatchingAttributes(MemberInfo memberInfo, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
internal static bool IsNonVirtual(MethodInfo method);
    private static ValueTuple`2<bool, MethodImplAttribute> RecreateMethodImplAttribute(MethodBase methodBase);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.ObjectExtensions : object {
    public static Func`3<T, T, bool> GetComparer();
    private static bool CompareNumerics(object actual, object expected);
    private static bool CanConvert(object source, object target, Type sourceType, Type targetType);
    [ExtensionAttribute]
private static object ConvertTo(object source, Type targetType);
    [ExtensionAttribute]
private static bool IsNumericType(object obj);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.PropertyInfoExtensions : object {
    [ExtensionAttribute]
internal static bool IsVirtual(PropertyInfo property);
    [ExtensionAttribute]
internal static bool IsStatic(PropertyInfo property);
    [ExtensionAttribute]
internal static bool IsAbstract(PropertyInfo property);
}
internal static class FluentAssertions.Common.ReadOnlyNonGenericCollectionWrapper : object {
    public static ReadOnlyNonGenericCollectionWrapper`2<DataTableCollection, DataTable> Create(DataTableCollection collection);
    public static ReadOnlyNonGenericCollectionWrapper`2<DataColumnCollection, DataColumn> Create(DataColumnCollection collection);
    public static ReadOnlyNonGenericCollectionWrapper`2<DataRowCollection, DataRow> Create(DataRowCollection collection);
}
internal class FluentAssertions.Common.ReadOnlyNonGenericCollectionWrapper`2 : object {
    [CompilerGeneratedAttribute]
private TCollection <UnderlyingCollection>k__BackingField;
    public TCollection UnderlyingCollection { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TItem>.IsReadOnly { get; }
    public ReadOnlyNonGenericCollectionWrapper`2(TCollection collection);
    [CompilerGeneratedAttribute]
public sealed virtual TCollection get_UnderlyingCollection();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.get_IsReadOnly();
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual void CopyTo(TItem[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Add(TItem item);
    private sealed virtual override void System.Collections.Generic.ICollection<TItem>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<TItem>.Remove(TItem item);
}
public static class FluentAssertions.Common.Services : object {
    private static object Lockable;
    private static Configuration configuration;
    [CompilerGeneratedAttribute]
private static IConfigurationStore <ConfigurationStore>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<string> <ThrowException>k__BackingField;
    [CompilerGeneratedAttribute]
private static IReflector <Reflector>k__BackingField;
    public static IConfigurationStore ConfigurationStore { get; public set; }
    public static Configuration Configuration { get; }
    public static Action`1<string> ThrowException { get; public set; }
    public static IReflector Reflector { get; public set; }
    private static Services();
    [CompilerGeneratedAttribute]
public static IConfigurationStore get_ConfigurationStore();
    [CompilerGeneratedAttribute]
public static void set_ConfigurationStore(IConfigurationStore value);
    public static Configuration get_Configuration();
    [CompilerGeneratedAttribute]
public static Action`1<string> get_ThrowException();
    [CompilerGeneratedAttribute]
public static void set_ThrowException(Action`1<string> value);
    [CompilerGeneratedAttribute]
public static IReflector get_Reflector();
    [CompilerGeneratedAttribute]
public static void set_Reflector(IReflector value);
    public static void ResetToDefaults();
}
public class FluentAssertions.Common.StartTimer : MulticastDelegate {
    public StartTimer(object object, IntPtr method);
    public virtual ITimer Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual ITimer EndInvoke(IAsyncResult result);
}
internal class FluentAssertions.Common.StopwatchTimer : object {
    private Stopwatch stopwatch;
    public TimeSpan Elapsed { get; }
    public sealed virtual TimeSpan get_Elapsed();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.StringExtensions : object {
    [ExtensionAttribute]
public static int IndexOfFirstMismatch(string value, string expected, StringComparison stringComparison);
    private static Func`3<char, char, bool> GetCharComparer(StringComparison stringComparison);
    [ExtensionAttribute]
public static string IndexedSegmentAt(string value, int index);
    [ExtensionAttribute]
public static string WithoutSpecificCollectionIndices(string indexedPath);
    [ExtensionAttribute]
public static bool ContainsSpecificCollectionIndex(string indexedPath);
    [ExtensionAttribute]
public static string EscapePlaceholders(string value);
    [ExtensionAttribute]
internal static string UnescapePlaceholders(string value);
    [ExtensionAttribute]
public static string Combine(string this, string other, string separator);
    [ExtensionAttribute]
public static string Capitalize(string this);
    [ExtensionAttribute]
public static string IndentLines(string this);
    [ExtensionAttribute]
public static string RemoveNewLines(string this);
    [ExtensionAttribute]
public static int CountSubstring(string str, string substring, StringComparison comparisonType);
}
[ExtensionAttribute]
internal static class FluentAssertions.Common.TypeExtensions : object {
    private static BindingFlags PublicInstanceMembersFlag;
    private static BindingFlags AllStaticAndInstanceMembersFlag;
    private static ConcurrentDictionary`2<Type, bool> HasValueSemanticsCache;
    private static ConcurrentDictionary`2<Type, bool> TypeIsRecordCache;
    private static ConcurrentDictionary`2<Type, bool> TypeIsCompilerGeneratedCache;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`2<Type, MemberVisibility>, TypeMemberReflector> TypeMemberReflectorsCache;
    private static TypeExtensions();
    [ExtensionAttribute]
public static bool IsDecoratedWith(Type type);
    [ExtensionAttribute]
public static bool IsDecoratedWith(MemberInfo type);
    [ExtensionAttribute]
public static bool IsDecoratedWithOrInherit(Type type);
    [ExtensionAttribute]
public static bool IsDecoratedWithOrInherit(MemberInfo type);
    [ExtensionAttribute]
public static bool IsDecoratedWith(Type type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static bool IsDecoratedWith(MemberInfo type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static bool IsDecoratedWithOrInherit(Type type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static IEnumerable`1<TAttribute> GetMatchingAttributes(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<TAttribute> GetMatchingAttributes(Type type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static IEnumerable`1<TAttribute> GetMatchingOrInheritedAttributes(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<TAttribute> GetMatchingOrInheritedAttributes(Type type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate);
    [ExtensionAttribute]
public static IEnumerable`1<TAttribute> GetCustomAttributes(MemberInfo type, bool inherit);
    private static IEnumerable`1<TAttribute> GetCustomAttributes(MemberInfo type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, bool inherit);
    [ExtensionAttribute]
private static TAttribute[] GetCustomAttributes(Type type, bool inherit);
    private static IEnumerable`1<TAttribute> GetCustomAttributes(Type type, Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, bool inherit);
    [ExtensionAttribute]
public static bool IsEquivalentTo(IMember property, IMember otherProperty);
    [ExtensionAttribute]
public static Type[] GetClosedGenericInterfaces(Type type, Type openGenericType);
    [ExtensionAttribute]
public static bool OverridesEquals(Type type);
    [ExtensionAttribute]
public static PropertyInfo FindProperty(Type type, string propertyName, MemberVisibility memberVisibility);
    [ExtensionAttribute]
public static FieldInfo FindField(Type type, string fieldName, MemberVisibility memberVisibility);
    [ExtensionAttribute]
public static MemberInfo[] GetMembers(Type typeToReflect, MemberVisibility visibility);
    [ExtensionAttribute]
public static PropertyInfo[] GetProperties(Type typeToReflect, MemberVisibility visibility);
    [ExtensionAttribute]
public static FieldInfo[] GetFields(Type typeToReflect, MemberVisibility visibility);
    private static TypeMemberReflector GetTypeReflectorFor(Type typeToReflect, MemberVisibility visibility);
    [ExtensionAttribute]
public static bool IsCSharpAbstract(Type type);
    [ExtensionAttribute]
public static bool IsCSharpSealed(Type type);
    [ExtensionAttribute]
public static bool IsCSharpStatic(Type type);
    [ExtensionAttribute]
public static MethodInfo GetMethod(Type type, string methodName, IEnumerable`1<Type> parameterTypes);
    [ExtensionAttribute]
public static bool HasMethod(Type type, string methodName, IEnumerable`1<Type> parameterTypes);
    [ExtensionAttribute]
public static MethodInfo GetParameterlessMethod(Type type, string methodName);
    [ExtensionAttribute]
public static PropertyInfo FindPropertyByName(Type type, string propertyName);
    [ExtensionAttribute]
public static bool HasExplicitlyImplementedProperty(Type type, Type interfaceType, string propertyName);
    [ExtensionAttribute]
private static bool HasParameterlessMethod(Type type, string methodName);
    [ExtensionAttribute]
public static PropertyInfo GetIndexerByParameterTypes(Type type, IEnumerable`1<Type> parameterTypes);
    [ExtensionAttribute]
public static bool IsIndexer(PropertyInfo member);
    [ExtensionAttribute]
public static ConstructorInfo GetConstructor(Type type, IEnumerable`1<Type> parameterTypes);
    [ExtensionAttribute]
private static IEnumerable`1<MethodInfo> GetConversionOperators(Type type, Type sourceType, Type targetType, Func`2<string, bool> predicate);
    [ExtensionAttribute]
public static bool IsAssignableToOpenGeneric(Type type, Type definition);
    [ExtensionAttribute]
private static bool IsImplementationOfOpenGeneric(Type type, Type definition);
    [ExtensionAttribute]
public static bool IsDerivedFromOpenGeneric(Type type, Type definition);
    [ExtensionAttribute]
public static bool IsUnderNamespace(Type type, string namespace);
    [ExtensionAttribute]
public static bool IsSameOrInherits(Type actualType, Type expectedType);
    [ExtensionAttribute]
public static MethodInfo GetExplicitConversionOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
public static MethodInfo GetImplicitConversionOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
public static bool HasValueSemantics(Type type);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(Type type);
    [ExtensionAttribute]
public static bool HasFriendlyName(Type type);
    [ExtensionAttribute]
private static bool IsTuple(Type type);
    [ExtensionAttribute]
private static bool IsAnonymous(Type type);
    [ExtensionAttribute]
public static bool IsRecord(Type type);
    [ExtensionAttribute]
private static bool IsRecordClass(Type type);
    [ExtensionAttribute]
private static bool IsRecordStruct(Type type);
    private static bool IsKeyValuePair(Type type);
    [ExtensionAttribute]
public static Type NullableOrActualType(Type type);
    [CompilerGeneratedAttribute]
internal static bool <IsUnderNamespace>g__IsGlobalNamespace|46_0(<>c__DisplayClass46_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsUnderNamespace>g__IsExactNamespace|46_1(<>c__DisplayClass46_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsUnderNamespace>g__IsParentNamespace|46_2(<>c__DisplayClass46_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsUnderNamespace>g__IsNamespacePrefix|46_3(<>c__DisplayClass46_0& );
}
internal class FluentAssertions.Common.TypeMemberReflector : object {
    private static BindingFlags AllInstanceMembersFlag;
    [CompilerGeneratedAttribute]
private MemberInfo[] <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldInfo[] <Fields>k__BackingField;
    public MemberInfo[] Members { get; }
    public PropertyInfo[] Properties { get; }
    public FieldInfo[] Fields { get; }
    public TypeMemberReflector(Type typeToReflect, MemberVisibility visibility);
    [CompilerGeneratedAttribute]
public MemberInfo[] get_Members();
    [CompilerGeneratedAttribute]
public PropertyInfo[] get_Properties();
    [CompilerGeneratedAttribute]
public FieldInfo[] get_Fields();
    private static PropertyInfo[] LoadProperties(Type typeToReflect, MemberVisibility visibility);
    private static List`1<PropertyInfo> GetPropertiesFromHierarchy(Type typeToReflect, MemberVisibility memberVisibility);
    private static bool IsPublic(MethodBase getMethod);
    private static bool IsExplicitlyImplemented(MethodBase getMethod);
    private static bool IsInternal(MethodBase getMethod);
    private static bool IsExplicitImplementation(PropertyInfo property);
    private static FieldInfo[] LoadFields(Type typeToReflect, MemberVisibility visibility);
    private static List`1<FieldInfo> GetFieldsFromHierarchy(Type typeToReflect, MemberVisibility memberVisibility);
    private static bool IsPublic(FieldInfo field);
    private static bool IsInternal(FieldInfo field);
    private static List`1<TMemberInfo> GetMembersFromHierarchy(Type typeToReflect, Func`2<Type, IEnumerable`1<TMemberInfo>> getMembers);
    private static List`1<TMemberInfo> GetInterfaceMembers(Type typeToReflect, Func`2<Type, IEnumerable`1<TMemberInfo>> getMembers);
    private static List`1<TMemberInfo> GetClassMembers(Type typeToReflect, Func`2<Type, IEnumerable`1<TMemberInfo>> getMembers);
}
public enum FluentAssertions.Common.ValueFormatterDetectionMode : Enum {
    public int value__;
    public static ValueFormatterDetectionMode Disabled;
    public static ValueFormatterDetectionMode Specific;
    public static ValueFormatterDetectionMode Scan;
}
[AttributeUsageAttribute("64")]
public class FluentAssertions.CustomAssertionAttribute : Attribute {
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Data.DataColumnAssertions : ReferenceTypeAssertions`2<DataColumn, DataColumnAssertions> {
    protected string Identifier { get; }
    public DataColumnAssertions(DataColumn dataColumn);
    public AndConstraint`1<DataColumnAssertions> BeEquivalentTo(DataColumn expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<DataColumnAssertions> BeEquivalentTo(DataColumn expectation, Func`2<IDataEquivalencyAssertionOptions`1<DataColumn>, IDataEquivalencyAssertionOptions`1<DataColumn>> config, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
internal class FluentAssertions.Data.DataEquivalencyAssertionOptions`1 : EquivalencyAssertionOptions`1<T> {
    private HashSet`1<string> excludeTableNames;
    private HashSet`1<string> excludeColumnNames;
    private Dictionary`2<string, HashSet`1<string>> excludeColumnNamesByTableName;
    [CompilerGeneratedAttribute]
private bool <AllowMismatchedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreUnmatchedColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeOriginalData>k__BackingField;
    [CompilerGeneratedAttribute]
private RowMatchMode <RowMatchMode>k__BackingField;
    public bool AllowMismatchedTypes { get; private set; }
    public bool IgnoreUnmatchedColumns { get; private set; }
    public bool ExcludeOriginalData { get; private set; }
    public RowMatchMode RowMatchMode { get; private set; }
    public ISet`1<string> ExcludeTableNames { get; }
    public ISet`1<string> ExcludeColumnNames { get; }
    public DataEquivalencyAssertionOptions`1(EquivalencyAssertionOptions defaults);
    [CompilerGeneratedAttribute]
public bool get_AllowMismatchedTypes();
    [CompilerGeneratedAttribute]
private void set_AllowMismatchedTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreUnmatchedColumns();
    [CompilerGeneratedAttribute]
private void set_IgnoreUnmatchedColumns(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeOriginalData();
    [CompilerGeneratedAttribute]
private void set_ExcludeOriginalData(bool value);
    [CompilerGeneratedAttribute]
public RowMatchMode get_RowMatchMode();
    [CompilerGeneratedAttribute]
private void set_RowMatchMode(RowMatchMode value);
    public ISet`1<string> get_ExcludeTableNames();
    public ISet`1<string> get_ExcludeColumnNames();
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> AllowingMismatchedTypes();
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> IgnoringUnmatchedColumns();
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> UsingRowMatchMode(RowMatchMode rowMatchMode);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingOriginalData();
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> Excluding(Expression`1<Func`2<T, object>> expression);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<DataRelation, object>> expression);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<DataTable, object>> expression);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<DataColumn, object>> expression);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<DataRow, object>> expression);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<Constraint, object>> expression);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<ForeignKeyConstraint, object>> expression);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<UniqueConstraint, object>> expression);
    private void ExcludeMemberOfRelatedTypeByGeneratedPredicate(Expression`1<Func`2<TDeclaringType, TPropertyType>> expression);
    private void ExcludeMemberOfSubtypeOfRelatedTypeByGeneratedPredicate(Expression`1<Func`2<TDeclaringType, TPropertyType>> expression);
    private static MemberInfo GetMemberAccessTargetMember(Expression expression);
    private static Expression`1<Func`2<IMemberInfo, bool>> BuildMemberSelectionPredicate(Type relatedSubjectType, MemberInfo referencedMember);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> Excluding(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingTable(string tableName);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingTables(String[] tableNames);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingTables(IEnumerable`1<string> tableNames);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumnInAllTables(string columnName);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumnsInAllTables(String[] columnNames);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumnsInAllTables(IEnumerable`1<string> columnNames);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumn(DataColumn column);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumns(DataColumn[] columns);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumns(IEnumerable`1<DataColumn> columns);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumn(string tableName, string columnName);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumns(string tableName, String[] columnNames);
    public sealed virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumns(string tableName, IEnumerable`1<string> columnNames);
    public bool ShouldExcludeColumn(DataColumn column);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Data.DataRowAssertions`1 : ReferenceTypeAssertions`2<TDataRow, DataRowAssertions`1<TDataRow>> {
    protected string Identifier { get; }
    public DataRowAssertions`1(TDataRow dataRow);
    public AndWhichConstraint`2<DataRowAssertions`1<TDataRow>, DataColumn> HaveColumn(string expectedColumnName, string because, Object[] becauseArgs);
    public AndConstraint`1<DataRowAssertions`1<TDataRow>> HaveColumns(String[] expectedColumnNames);
    public AndConstraint`1<DataRowAssertions`1<TDataRow>> HaveColumns(IEnumerable`1<string> expectedColumnNames, string because, Object[] becauseArgs);
    public AndConstraint`1<DataRowAssertions`1<TDataRow>> BeEquivalentTo(DataRow expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<DataRowAssertions`1<TDataRow>> BeEquivalentTo(DataRow expectation, Func`2<IDataEquivalencyAssertionOptions`1<DataRow>, IDataEquivalencyAssertionOptions`1<DataRow>> config, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Data.DataSetAssertions`1 : ReferenceTypeAssertions`2<DataSet, DataSetAssertions`1<TDataSet>> {
    protected string Identifier { get; }
    public DataSetAssertions`1(TDataSet dataSet);
    public AndConstraint`1<DataSetAssertions`1<TDataSet>> HaveTableCount(int expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<DataSetAssertions`1<TDataSet>, DataTable> HaveTable(string expectedTableName, string because, Object[] becauseArgs);
    public AndConstraint`1<DataSetAssertions`1<TDataSet>> HaveTables(String[] expectedTableNames);
    public AndConstraint`1<DataSetAssertions`1<TDataSet>> HaveTables(IEnumerable`1<string> expectedTableNames, string because, Object[] becauseArgs);
    public AndConstraint`1<DataSetAssertions`1<TDataSet>> BeEquivalentTo(DataSet expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<DataSetAssertions`1<TDataSet>> BeEquivalentTo(DataSet expectation, Func`2<IDataEquivalencyAssertionOptions`1<DataSet>, IDataEquivalencyAssertionOptions`1<DataSet>> config, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Data.DataTableAssertions`1 : ReferenceTypeAssertions`2<DataTable, DataTableAssertions`1<TDataTable>> {
    protected string Identifier { get; }
    public DataTableAssertions`1(TDataTable dataTable);
    public AndConstraint`1<DataTableAssertions`1<TDataTable>> HaveRowCount(int expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<DataTableAssertions`1<TDataTable>, DataColumn> HaveColumn(string expectedColumnName, string because, Object[] becauseArgs);
    public AndConstraint`1<DataTableAssertions`1<TDataTable>> HaveColumns(String[] expectedColumnNames);
    public AndConstraint`1<DataTableAssertions`1<TDataTable>> HaveColumns(IEnumerable`1<string> expectedColumnNames, string because, Object[] becauseArgs);
    public AndConstraint`1<DataTableAssertions`1<TDataTable>> BeEquivalentTo(DataTable expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<DataTableAssertions`1<TDataTable>> BeEquivalentTo(DataTable expectation, Func`2<IDataEquivalencyAssertionOptions`1<DataTable>, IDataEquivalencyAssertionOptions`1<DataTable>> config, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
public interface FluentAssertions.Data.IDataEquivalencyAssertionOptions`1 {
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> AllowingMismatchedTypes();
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> IgnoringUnmatchedColumns();
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> UsingRowMatchMode(RowMatchMode rowMatchMode);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingOriginalData();
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> Excluding(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> Excluding(Expression`1<Func`2<T, object>> expression);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingTable(string tableName);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingTables(IEnumerable`1<string> tableNames);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingTables(String[] tableNames);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumn(DataColumn column);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumn(string tableName, string columnName);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumns(IEnumerable`1<DataColumn> columns);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumns(DataColumn[] columns);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumns(string tableName, IEnumerable`1<string> columnNames);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumns(string tableName, String[] columnNames);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumnInAllTables(string columnName);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumnsInAllTables(IEnumerable`1<string> columnNames);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingColumnsInAllTables(String[] columnNames);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<Constraint, object>> expression);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<ForeignKeyConstraint, object>> expression);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<UniqueConstraint, object>> expression);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<DataColumn, object>> expression);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<DataRelation, object>> expression);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<DataRow, object>> expression);
    public abstract virtual IDataEquivalencyAssertionOptions`1<T> ExcludingRelated(Expression`1<Func`2<DataTable, object>> expression);
}
public enum FluentAssertions.Data.RowMatchMode : Enum {
    public int value__;
    public static RowMatchMode Index;
    public static RowMatchMode PrimaryKey;
}
[ExtensionAttribute]
public static class FluentAssertions.DataColumnCollectionAssertionExtensions : object {
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataColumn>> BeSameAs(GenericCollectionAssertions`1<DataColumn> assertion, DataColumnCollection expected, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataColumn>> NotBeSameAs(GenericCollectionAssertions`1<DataColumn> assertion, DataColumnCollection unexpected, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataColumn>> HaveSameCount(GenericCollectionAssertions`1<DataColumn> assertion, DataColumnCollection otherCollection, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataColumn>> NotHaveSameCount(GenericCollectionAssertions`1<DataColumn> assertion, DataColumnCollection otherCollection, string because, Object[] becauseArgs);
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.DataRowAssertionExtensions : object {
    [ExtensionAttribute]
public static DataRowAssertions`1<TDataRow> Should(TDataRow actualValue);
}
[ExtensionAttribute]
public static class FluentAssertions.DataRowCollectionAssertionExtensions : object {
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataRow>> BeSameAs(GenericCollectionAssertions`1<DataRow> assertion, DataRowCollection expected, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataRow>> NotBeSameAs(GenericCollectionAssertions`1<DataRow> assertion, DataRowCollection unexpected, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataRow>> HaveSameCount(GenericCollectionAssertions`1<DataRow> assertion, DataRowCollection otherCollection, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataRow>> NotHaveSameCount(GenericCollectionAssertions`1<DataRow> assertion, DataRowCollection otherCollection, string because, Object[] becauseArgs);
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.DataSetAssertionExtensions : object {
    [ExtensionAttribute]
public static DataSetAssertions`1<TDataSet> Should(TDataSet actualValue);
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.DataTableAssertionExtensions : object {
    [ExtensionAttribute]
public static DataTableAssertions`1<TDataTable> Should(TDataTable actualValue);
}
[ExtensionAttribute]
public static class FluentAssertions.DataTableCollectionAssertionExtensions : object {
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataTable>> BeSameAs(GenericCollectionAssertions`1<DataTable> assertion, DataTableCollection expected, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataTable>> NotBeSameAs(GenericCollectionAssertions`1<DataTable> assertion, DataTableCollection unexpected, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataTable>> HaveSameCount(GenericCollectionAssertions`1<DataTable> assertion, DataSet otherDataSet, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataTable>> NotHaveSameCount(GenericCollectionAssertions`1<DataTable> assertion, DataSet otherDataSet, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataTable>> HaveSameCount(GenericCollectionAssertions`1<DataTable> assertion, DataTableCollection otherCollection, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<GenericCollectionAssertions`1<DataTable>> NotHaveSameCount(GenericCollectionAssertions`1<DataTable> assertion, DataTableCollection otherCollection, string because, Object[] becauseArgs);
}
internal class FluentAssertions.Disposable : object {
    private Action action;
    public Disposable(Action action);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.EnumAssertionsExtensions : object {
    [ExtensionAttribute]
public static EnumAssertions`1<TEnum> Should(TEnum enum);
    [ExtensionAttribute]
public static NullableEnumAssertions`1<TEnum> Should(Nullable`1<TEnum> enum);
}
public class FluentAssertions.Equivalency.Comparands : object {
    private Type compileTimeType;
    [CompilerGeneratedAttribute]
private object <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Expectation>k__BackingField;
    public object Subject { get; public set; }
    public object Expectation { get; public set; }
    public Type CompileTimeType { get; public set; }
    public Type RuntimeType { get; }
    public Comparands(object subject, object expectation, Type compileTimeType);
    [CompilerGeneratedAttribute]
public object get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(object value);
    [CompilerGeneratedAttribute]
public object get_Expectation();
    [CompilerGeneratedAttribute]
public void set_Expectation(object value);
    public Type get_CompileTimeType();
    public void set_CompileTimeType(Type value);
    public Type get_RuntimeType();
    public Type GetExpectedType(IEquivalencyAssertionOptions options);
    public virtual string ToString();
}
public class FluentAssertions.Equivalency.ConversionSelector : object {
    private List`1<ConversionSelectorRule> inclusions;
    private List`1<ConversionSelectorRule> exclusions;
    private ConversionSelector(List`1<ConversionSelectorRule> inclusions, List`1<ConversionSelectorRule> exclusions);
    public void IncludeAll();
    public void Include(Expression`1<Func`2<IObjectInfo, bool>> predicate);
    public void Exclude(Expression`1<Func`2<IObjectInfo, bool>> predicate);
    public bool RequiresConversion(Comparands comparands, INode currentNode);
    public virtual string ToString();
    public ConversionSelector Clone();
}
public enum FluentAssertions.Equivalency.CyclicReferenceHandling : Enum {
    public int value__;
    public static CyclicReferenceHandling Ignore;
    public static CyclicReferenceHandling ThrowException;
}
internal class FluentAssertions.Equivalency.Digit : object {
    private int length;
    private Digit nextDigit;
    private int index;
    public Digit(int length, Digit nextDigit);
    public Int32[] GetIndices();
    public bool Increment();
}
public enum FluentAssertions.Equivalency.EnumEquivalencyHandling : Enum {
    public int value__;
    public static EnumEquivalencyHandling ByValue;
    public static EnumEquivalencyHandling ByName;
}
public enum FluentAssertions.Equivalency.EqualityStrategy : Enum {
    public int value__;
    public static EqualityStrategy Equals;
    public static EqualityStrategy Members;
    public static EqualityStrategy ForceEquals;
    public static EqualityStrategy ForceMembers;
}
internal class FluentAssertions.Equivalency.EqualityStrategyProvider : object {
    private List`1<Type> referenceTypes;
    private List`1<Type> valueTypes;
    private ConcurrentDictionary`2<Type, EqualityStrategy> typeCache;
    private Func`2<Type, EqualityStrategy> defaultStrategy;
    private Nullable`1<bool> compareRecordsByValue;
    public Nullable`1<bool> CompareRecordsByValue { get; public set; }
    public EqualityStrategyProvider(Func`2<Type, EqualityStrategy> defaultStrategy);
    public Nullable`1<bool> get_CompareRecordsByValue();
    public void set_CompareRecordsByValue(Nullable`1<bool> value);
    public EqualityStrategy GetEqualityStrategy(Type type);
    public bool AddReferenceType(Type type);
    public bool AddValueType(Type type);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private EqualityStrategy <GetEqualityStrategy>b__10_0(Type typeKey);
}
public class FluentAssertions.Equivalency.EquivalencyAssertionOptions : SelfReferenceEquivalencyAssertionOptions`1<EquivalencyAssertionOptions> {
}
public class FluentAssertions.Equivalency.EquivalencyAssertionOptions`1 : SelfReferenceEquivalencyAssertionOptions`1<EquivalencyAssertionOptions`1<TExpectation>> {
    public EquivalencyAssertionOptions`1(IEquivalencyAssertionOptions defaults);
    public EquivalencyAssertionOptions`1<TExpectation> Excluding(Expression`1<Func`2<TExpectation, object>> expression);
    public NestedExclusionOptionBuilder`2<TExpectation, TNext> For(Expression`1<Func`2<TExpectation, IEnumerable`1<TNext>>> expression);
    public EquivalencyAssertionOptions`1<TExpectation> Including(Expression`1<Func`2<TExpectation, object>> expression);
    public EquivalencyAssertionOptions`1<TExpectation> WithStrictOrderingFor(Expression`1<Func`2<TExpectation, object>> expression);
    public EquivalencyAssertionOptions`1<TExpectation> WithoutStrictOrderingFor(Expression`1<Func`2<TExpectation, object>> expression);
    public EquivalencyAssertionOptions`1<IEnumerable`1<TExpectation>> AsCollection();
    public EquivalencyAssertionOptions`1<TExpectation> WithMapping(Expression`1<Func`2<TExpectation, object>> expectationMemberPath, Expression`1<Func`2<TSubject, object>> subjectMemberPath);
    public EquivalencyAssertionOptions`1<TExpectation> WithMapping(string expectationMemberPath, string subjectMemberPath);
    public EquivalencyAssertionOptions`1<TExpectation> WithMapping(Expression`1<Func`2<TNestedExpectation, object>> expectationMember, Expression`1<Func`2<TNestedSubject, object>> subjectMember);
    public EquivalencyAssertionOptions`1<TExpectation> WithMapping(string expectationMemberName, string subjectMemberName);
}
public enum FluentAssertions.Equivalency.EquivalencyResult : Enum {
    public int value__;
    public static EquivalencyResult ContinueWithNext;
    public static EquivalencyResult AssertionCompleted;
}
public abstract class FluentAssertions.Equivalency.EquivalencyStep`1 : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    protected abstract virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
public class FluentAssertions.Equivalency.EquivalencyValidationContext : object {
    private Tracer tracer;
    [CompilerGeneratedAttribute]
private INode <CurrentNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Reason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private IEquivalencyAssertionOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private CyclicReferenceDetector <CyclicReferenceDetector>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    public INode CurrentNode { get; }
    public Reason Reason { get; public set; }
    public Tracer Tracer { get; }
    public IEquivalencyAssertionOptions Options { get; }
    private CyclicReferenceDetector CyclicReferenceDetector { get; private set; }
    public ITraceWriter TraceWriter { get; public set; }
    public EquivalencyValidationContext(INode root, IEquivalencyAssertionOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual INode get_CurrentNode();
    [CompilerGeneratedAttribute]
public sealed virtual Reason get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(Reason value);
    public sealed virtual Tracer get_Tracer();
    [CompilerGeneratedAttribute]
public sealed virtual IEquivalencyAssertionOptions get_Options();
    [CompilerGeneratedAttribute]
private CyclicReferenceDetector get_CyclicReferenceDetector();
    [CompilerGeneratedAttribute]
private void set_CyclicReferenceDetector(CyclicReferenceDetector value);
    public sealed virtual IEquivalencyValidationContext AsNestedMember(IMember expectationMember);
    public sealed virtual IEquivalencyValidationContext AsCollectionItem(string index);
    public sealed virtual IEquivalencyValidationContext AsDictionaryItem(TKey key);
    public sealed virtual IEquivalencyValidationContext Clone();
    public sealed virtual bool IsCyclicReference(object expectation);
    [CompilerGeneratedAttribute]
public ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
public void set_TraceWriter(ITraceWriter value);
    public virtual string ToString();
}
public class FluentAssertions.Equivalency.EquivalencyValidator : object {
    private static int MaxDepth;
    public void AssertEquality(Comparands comparands, EquivalencyValidationContext context);
    public sealed virtual void RecursivelyAssertEquality(Comparands comparands, IEquivalencyValidationContext context);
    private static bool ShouldContinueThisDeep(INode currentNode, IEquivalencyAssertionOptions options, AssertionScope assertionScope);
    private static void TrackWhatIsNeededToProvideContextToFailures(AssertionScope scope, Comparands comparands, INode currentNode);
    private void TryToProveNodesAreEquivalent(Comparands comparands, IEquivalencyValidationContext context);
    [CompilerGeneratedAttribute]
internal static GetTraceMessage <TryToProveNodesAreEquivalent>g__GetMessage|5_1(IEquivalencyStep step);
}
internal class FluentAssertions.Equivalency.Execution.CollectionMemberAssertionOptionsDecorator : object {
    private IEquivalencyAssertionOptions inner;
    public IEnumerable`1<IMemberSelectionRule> SelectionRules { get; }
    public IEnumerable`1<IMemberMatchingRule> MatchingRules { get; }
    public OrderingRuleCollection OrderingRules { get; }
    public ConversionSelector ConversionSelector { get; }
    public IEnumerable`1<IEquivalencyStep> UserEquivalencySteps { get; }
    public bool IsRecursive { get; }
    public bool AllowInfiniteRecursion { get; }
    public CyclicReferenceHandling CyclicReferenceHandling { get; }
    public EnumEquivalencyHandling EnumEquivalencyHandling { get; }
    public bool UseRuntimeTyping { get; }
    public MemberVisibility IncludedProperties { get; }
    public MemberVisibility IncludedFields { get; }
    public bool IgnoreNonBrowsableOnSubject { get; }
    public bool ExcludeNonBrowsableOnExpectation { get; }
    public Nullable`1<bool> CompareRecordsByValue { get; }
    public ITraceWriter TraceWriter { get; }
    public CollectionMemberAssertionOptionsDecorator(IEquivalencyAssertionOptions inner);
    public sealed virtual IEnumerable`1<IMemberSelectionRule> get_SelectionRules();
    public sealed virtual IEnumerable`1<IMemberMatchingRule> get_MatchingRules();
    public sealed virtual OrderingRuleCollection get_OrderingRules();
    public sealed virtual ConversionSelector get_ConversionSelector();
    public sealed virtual IEnumerable`1<IEquivalencyStep> get_UserEquivalencySteps();
    public sealed virtual bool get_IsRecursive();
    public sealed virtual bool get_AllowInfiniteRecursion();
    public sealed virtual CyclicReferenceHandling get_CyclicReferenceHandling();
    public sealed virtual EnumEquivalencyHandling get_EnumEquivalencyHandling();
    public sealed virtual bool get_UseRuntimeTyping();
    public sealed virtual MemberVisibility get_IncludedProperties();
    public sealed virtual MemberVisibility get_IncludedFields();
    public sealed virtual bool get_IgnoreNonBrowsableOnSubject();
    public sealed virtual bool get_ExcludeNonBrowsableOnExpectation();
    public sealed virtual Nullable`1<bool> get_CompareRecordsByValue();
    public sealed virtual EqualityStrategy GetEqualityStrategy(Type type);
    public sealed virtual ITraceWriter get_TraceWriter();
}
internal class FluentAssertions.Equivalency.Execution.CyclicReferenceDetector : object {
    private HashSet`1<ObjectReference> observedReferences;
    public bool IsCyclicReference(ObjectReference reference, CyclicReferenceHandling handling, Reason reason);
    public sealed virtual object Clone();
}
internal class FluentAssertions.Equivalency.Execution.ObjectInfo : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CompileTimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RuntimeType>k__BackingField;
    public Type Type { get; }
    public Type ParentType { get; }
    public string Path { get; public set; }
    public Type CompileTimeType { get; }
    public Type RuntimeType { get; }
    public ObjectInfo(Comparands comparands, INode currentNode);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ParentType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_CompileTimeType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_RuntimeType();
}
internal class FluentAssertions.Equivalency.Execution.ObjectReference : object {
    private object object;
    private string path;
    private Nullable`1<bool> compareByMembers;
    private String[] pathElements;
    public bool CompareByMembers { get; }
    public ObjectReference(object object, string path, Nullable`1<bool> compareByMembers);
    public virtual bool Equals(object obj);
    private String[] GetPathElements();
    private bool IsParentOrChildOf(ObjectReference other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool get_CompareByMembers();
}
public class FluentAssertions.Equivalency.Field : Node {
    private FieldInfo fieldInfo;
    private Nullable`1<bool> isBrowsable;
    [CompilerGeneratedAttribute]
private Type <ReflectedType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    public Type ReflectedType { get; }
    public Type DeclaringType { get; public set; }
    public string Description { get; }
    public CSharpAccessModifier GetterAccessibility { get; }
    public CSharpAccessModifier SetterAccessibility { get; }
    public bool IsBrowsable { get; }
    public Field(FieldInfo fieldInfo, INode parent);
    public Field(Type reflectedType, FieldInfo fieldInfo, INode parent);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ReflectedType();
    public sealed virtual object GetValue(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(Type value);
    public virtual string get_Description();
    public sealed virtual CSharpAccessModifier get_GetterAccessibility();
    public sealed virtual CSharpAccessModifier get_SetterAccessibility();
    public sealed virtual bool get_IsBrowsable();
}
public class FluentAssertions.Equivalency.GetSubjectId : MulticastDelegate {
    public GetSubjectId(object object, IntPtr method);
    public virtual string Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public interface FluentAssertions.Equivalency.IAssertionContext`1 {
    public INode SelectedNode { get; }
    public TSubject Subject { get; }
    public TSubject Expectation { get; }
    public string Because { get; public set; }
    public Object[] BecauseArgs { get; public set; }
    public abstract virtual INode get_SelectedNode();
    public abstract virtual TSubject get_Subject();
    public abstract virtual TSubject get_Expectation();
    public abstract virtual string get_Because();
    public abstract virtual void set_Because(string value);
    public abstract virtual Object[] get_BecauseArgs();
    public abstract virtual void set_BecauseArgs(Object[] value);
}
public interface FluentAssertions.Equivalency.IEquivalencyAssertionOptions {
    public IEnumerable`1<IMemberSelectionRule> SelectionRules { get; }
    public IEnumerable`1<IMemberMatchingRule> MatchingRules { get; }
    public bool IsRecursive { get; }
    public bool AllowInfiniteRecursion { get; }
    public CyclicReferenceHandling CyclicReferenceHandling { get; }
    public OrderingRuleCollection OrderingRules { get; }
    public ConversionSelector ConversionSelector { get; }
    public EnumEquivalencyHandling EnumEquivalencyHandling { get; }
    public IEnumerable`1<IEquivalencyStep> UserEquivalencySteps { get; }
    public bool UseRuntimeTyping { get; }
    public MemberVisibility IncludedProperties { get; }
    public MemberVisibility IncludedFields { get; }
    public bool IgnoreNonBrowsableOnSubject { get; }
    public bool ExcludeNonBrowsableOnExpectation { get; }
    public Nullable`1<bool> CompareRecordsByValue { get; }
    public ITraceWriter TraceWriter { get; }
    public abstract virtual IEnumerable`1<IMemberSelectionRule> get_SelectionRules();
    public abstract virtual IEnumerable`1<IMemberMatchingRule> get_MatchingRules();
    public abstract virtual bool get_IsRecursive();
    public abstract virtual bool get_AllowInfiniteRecursion();
    public abstract virtual CyclicReferenceHandling get_CyclicReferenceHandling();
    public abstract virtual OrderingRuleCollection get_OrderingRules();
    public abstract virtual ConversionSelector get_ConversionSelector();
    public abstract virtual EnumEquivalencyHandling get_EnumEquivalencyHandling();
    public abstract virtual IEnumerable`1<IEquivalencyStep> get_UserEquivalencySteps();
    public abstract virtual bool get_UseRuntimeTyping();
    public abstract virtual MemberVisibility get_IncludedProperties();
    public abstract virtual MemberVisibility get_IncludedFields();
    public abstract virtual bool get_IgnoreNonBrowsableOnSubject();
    public abstract virtual bool get_ExcludeNonBrowsableOnExpectation();
    public abstract virtual Nullable`1<bool> get_CompareRecordsByValue();
    public abstract virtual ITraceWriter get_TraceWriter();
    public abstract virtual EqualityStrategy GetEqualityStrategy(Type type);
}
public interface FluentAssertions.Equivalency.IEquivalencyStep {
    public abstract virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
public interface FluentAssertions.Equivalency.IEquivalencyValidationContext {
    public INode CurrentNode { get; }
    public Reason Reason { get; }
    public Tracer Tracer { get; }
    public IEquivalencyAssertionOptions Options { get; }
    public abstract virtual INode get_CurrentNode();
    public abstract virtual Reason get_Reason();
    public abstract virtual Tracer get_Tracer();
    public abstract virtual IEquivalencyAssertionOptions get_Options();
    public abstract virtual bool IsCyclicReference(object expectation);
    public abstract virtual IEquivalencyValidationContext AsNestedMember(IMember expectationMember);
    public abstract virtual IEquivalencyValidationContext AsCollectionItem(string index);
    public abstract virtual IEquivalencyValidationContext AsDictionaryItem(TKey key);
    public abstract virtual IEquivalencyValidationContext Clone();
}
public interface FluentAssertions.Equivalency.IEquivalencyValidator {
    public abstract virtual void RecursivelyAssertEquality(Comparands comparands, IEquivalencyValidationContext context);
}
public interface FluentAssertions.Equivalency.IMember {
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public CSharpAccessModifier GetterAccessibility { get; }
    public CSharpAccessModifier SetterAccessibility { get; }
    public bool IsBrowsable { get; }
    public abstract virtual Type get_DeclaringType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual object GetValue(object obj);
    public abstract virtual CSharpAccessModifier get_GetterAccessibility();
    public abstract virtual CSharpAccessModifier get_SetterAccessibility();
    public abstract virtual bool get_IsBrowsable();
}
public interface FluentAssertions.Equivalency.IMemberInfo {
    public string Name { get; }
    public Type Type { get; }
    public Type DeclaringType { get; }
    public string Path { get; public set; }
    public CSharpAccessModifier GetterAccessibility { get; }
    public CSharpAccessModifier SetterAccessibility { get; }
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public abstract virtual Type get_DeclaringType();
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual CSharpAccessModifier get_GetterAccessibility();
    public abstract virtual CSharpAccessModifier get_SetterAccessibility();
}
public interface FluentAssertions.Equivalency.IMemberMatchingRule {
    public abstract virtual IMember Match(IMember expectedMember, object subject, INode parent, IEquivalencyAssertionOptions options);
}
public interface FluentAssertions.Equivalency.IMemberSelectionRule {
    public bool IncludesMembers { get; }
    public abstract virtual bool get_IncludesMembers();
    public abstract virtual IEnumerable`1<IMember> SelectMembers(INode currentNode, IEnumerable`1<IMember> selectedMembers, MemberSelectionContext context);
}
public interface FluentAssertions.Equivalency.INode {
    public GetSubjectId GetSubjectId { get; }
    public string Name { get; public set; }
    public Type Type { get; }
    public Type ParentType { get; }
    public string Path { get; }
    public string PathAndName { get; }
    public int Depth { get; }
    public string Description { get; }
    public bool IsRoot { get; }
    public bool RootIsCollection { get; }
    public abstract virtual GetSubjectId get_GetSubjectId();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual Type get_Type();
    public abstract virtual Type get_ParentType();
    public abstract virtual string get_Path();
    public abstract virtual string get_PathAndName();
    public abstract virtual int get_Depth();
    public abstract virtual string get_Description();
    public abstract virtual bool get_IsRoot();
    public abstract virtual bool get_RootIsCollection();
}
public interface FluentAssertions.Equivalency.IObjectInfo {
    [ObsoleteAttribute("Use CompileTimeType or RuntimeType instead")]
public Type Type { get; }
    public Type ParentType { get; }
    public string Path { get; public set; }
    public Type CompileTimeType { get; }
    public Type RuntimeType { get; }
    public abstract virtual Type get_Type();
    public abstract virtual Type get_ParentType();
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual Type get_CompileTimeType();
    public abstract virtual Type get_RuntimeType();
}
public interface FluentAssertions.Equivalency.IOrderingRule {
    public abstract virtual OrderStrictness Evaluate(IObjectInfo objectInfo);
}
internal class FluentAssertions.Equivalency.Matching.MappedMemberMatchingRule`2 : object {
    private string expectationMemberName;
    private string subjectMemberName;
    public MappedMemberMatchingRule`2(string expectationMemberName, string subjectMemberName);
    public sealed virtual IMember Match(IMember expectedMember, object subject, INode parent, IEquivalencyAssertionOptions options);
}
internal class FluentAssertions.Equivalency.Matching.MappedPathMatchingRule : object {
    private MemberPath expectationPath;
    private MemberPath subjectPath;
    public MappedPathMatchingRule(string expectationMemberPath, string subjectMemberPath);
    public sealed virtual IMember Match(IMember expectedMember, object subject, INode parent, IEquivalencyAssertionOptions options);
}
internal class FluentAssertions.Equivalency.Matching.MustMatchByNameRule : object {
    public sealed virtual IMember Match(IMember expectedMember, object subject, INode parent, IEquivalencyAssertionOptions options);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Matching.TryMatchByNameRule : object {
    public sealed virtual IMember Match(IMember expectedMember, object subject, INode parent, IEquivalencyAssertionOptions options);
    public virtual string ToString();
}
public static class FluentAssertions.Equivalency.MemberFactory : object {
    public static IMember Create(MemberInfo memberInfo, INode parent);
    internal static IMember Find(object target, string memberName, INode parent);
}
public class FluentAssertions.Equivalency.MemberSelectionContext : object {
    private Type compileTimeType;
    private Type runtimeType;
    private IEquivalencyAssertionOptions options;
    public MemberVisibility IncludedProperties { get; }
    public MemberVisibility IncludedFields { get; }
    public Type Type { get; }
    public MemberSelectionContext(Type compileTimeType, Type runtimeType, IEquivalencyAssertionOptions options);
    public MemberVisibility get_IncludedProperties();
    public MemberVisibility get_IncludedFields();
    public Type get_Type();
}
[FlagsAttribute]
public enum FluentAssertions.Equivalency.MemberVisibility : Enum {
    public int value__;
    public static MemberVisibility None;
    public static MemberVisibility Internal;
    public static MemberVisibility Public;
    public static MemberVisibility ExplicitlyImplemented;
}
internal class FluentAssertions.Equivalency.MultiDimensionalArrayEquivalencyStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static Digit BuildDigitsRepresentingAllIndices(Array subjectAsArray);
    private static bool AreComparable(Comparands comparands, Array expectationAsArray);
    private static bool IsArray(object type);
    private static bool HaveSameDimensions(object subject, Array expectation);
    private static bool HaveSameRank(object subject, Array expectation);
}
public class FluentAssertions.Equivalency.NestedExclusionOptionBuilder`2 : object {
    private ExcludeMemberByPathSelectionRule currentPathSelectionRule;
    private EquivalencyAssertionOptions`1<TExpectation> capturedAssertionOptions;
    internal NestedExclusionOptionBuilder`2(EquivalencyAssertionOptions`1<TExpectation> capturedAssertionOptions, ExcludeMemberByPathSelectionRule currentPathSelectionRule);
    public EquivalencyAssertionOptions`1<TExpectation> Exclude(Expression`1<Func`2<TCurrent, object>> expression);
    public NestedExclusionOptionBuilder`2<TExpectation, TNext> For(Expression`1<Func`2<TCurrent, IEnumerable`1<TNext>>> expression);
}
public class FluentAssertions.Equivalency.Node : object {
    private static Regex MatchFirstIndex;
    private string path;
    private string name;
    private string pathAndName;
    [CompilerGeneratedAttribute]
private GetSubjectId <GetSubjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParentType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RootIsCollection>k__BackingField;
    public GetSubjectId GetSubjectId { get; protected set; }
    public Type Type { get; protected set; }
    public Type ParentType { get; protected set; }
    public string Path { get; protected set; }
    public string PathAndName { get; }
    public string Name { get; public set; }
    public string Description { get; }
    public bool IsRoot { get; }
    private bool IsFirstIndex { get; }
    public bool RootIsCollection { get; protected set; }
    public int Depth { get; }
    private static Node();
    [CompilerGeneratedAttribute]
public sealed virtual GetSubjectId get_GetSubjectId();
    [CompilerGeneratedAttribute]
protected void set_GetSubjectId(GetSubjectId value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ParentType();
    [CompilerGeneratedAttribute]
protected void set_ParentType(Type value);
    public sealed virtual string get_Path();
    protected void set_Path(string value);
    public sealed virtual string get_PathAndName();
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public virtual string get_Description();
    public sealed virtual bool get_IsRoot();
    private bool get_IsFirstIndex();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RootIsCollection();
    [CompilerGeneratedAttribute]
protected void set_RootIsCollection(bool value);
    public sealed virtual int get_Depth();
    private static bool IsCollection(Type type);
    public static INode From(GetSubjectId getSubjectId);
    public static INode FromCollectionItem(string index, INode parent);
    public static INode FromDictionaryItem(object key, INode parent);
    public virtual bool Equals(object obj);
    private bool Equals(Node other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Ordering.ByteArrayOrderingRule : object {
    public sealed virtual OrderStrictness Evaluate(IObjectInfo objectInfo);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Ordering.CollectionMemberObjectInfo : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CompileTimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RuntimeType>k__BackingField;
    public Type Type { get; }
    public Type ParentType { get; }
    public string Path { get; public set; }
    public Type CompileTimeType { get; }
    public Type RuntimeType { get; }
    public CollectionMemberObjectInfo(IObjectInfo context);
    private static string GetAdjustedPropertyPath(string propertyPath);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ParentType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_CompileTimeType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_RuntimeType();
}
internal class FluentAssertions.Equivalency.Ordering.CollectionMemberOrderingRuleDecorator : object {
    private IOrderingRule orderingRule;
    public CollectionMemberOrderingRuleDecorator(IOrderingRule orderingRule);
    public sealed virtual OrderStrictness Evaluate(IObjectInfo objectInfo);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Ordering.MatchAllOrderingRule : object {
    public sealed virtual OrderStrictness Evaluate(IObjectInfo objectInfo);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Ordering.PathBasedOrderingRule : object {
    private string path;
    [CompilerGeneratedAttribute]
private bool <Invert>k__BackingField;
    public bool Invert { get; public set; }
    public PathBasedOrderingRule(string path);
    [CompilerGeneratedAttribute]
public bool get_Invert();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Invert(bool value);
    public sealed virtual OrderStrictness Evaluate(IObjectInfo objectInfo);
    private static bool ContainsIndexingQualifiers(string path);
    private string RemoveInitialIndexQualifier(string sourcePath);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Ordering.PredicateBasedOrderingRule : object {
    private Func`2<IObjectInfo, bool> predicate;
    private string description;
    [CompilerGeneratedAttribute]
private bool <Invert>k__BackingField;
    public bool Invert { get; public set; }
    public PredicateBasedOrderingRule(Expression`1<Func`2<IObjectInfo, bool>> predicate);
    [CompilerGeneratedAttribute]
public bool get_Invert();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Invert(bool value);
    public sealed virtual OrderStrictness Evaluate(IObjectInfo objectInfo);
    public virtual string ToString();
}
public class FluentAssertions.Equivalency.OrderingRuleCollection : object {
    private List`1<IOrderingRule> rules;
    public OrderingRuleCollection(IEnumerable`1<IOrderingRule> orderingRules);
    public sealed virtual IEnumerator`1<IOrderingRule> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(IOrderingRule rule);
    internal void Clear();
    public bool IsOrderingStrictFor(IObjectInfo objectInfo);
}
public enum FluentAssertions.Equivalency.OrderStrictness : Enum {
    public int value__;
    public static OrderStrictness Strict;
    public static OrderStrictness NotStrict;
    public static OrderStrictness Irrelevant;
}
public class FluentAssertions.Equivalency.Property : Node {
    private PropertyInfo propertyInfo;
    private Nullable`1<bool> isBrowsable;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReflectedType>k__BackingField;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Description { get; }
    public CSharpAccessModifier GetterAccessibility { get; }
    public CSharpAccessModifier SetterAccessibility { get; }
    public bool IsBrowsable { get; }
    public Property(PropertyInfo propertyInfo, INode parent);
    public Property(Type reflectedType, PropertyInfo propertyInfo, INode parent);
    public sealed virtual object GetValue(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ReflectedType();
    public virtual string get_Description();
    public sealed virtual CSharpAccessModifier get_GetterAccessibility();
    public sealed virtual CSharpAccessModifier get_SetterAccessibility();
    public sealed virtual bool get_IsBrowsable();
}
internal class FluentAssertions.Equivalency.Selection.AllFieldsSelectionRule : object {
    public bool IncludesMembers { get; }
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<IMember> SelectMembers(INode currentNode, IEnumerable`1<IMember> selectedMembers, MemberSelectionContext context);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.AllPropertiesSelectionRule : object {
    public bool IncludesMembers { get; }
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<IMember> SelectMembers(INode currentNode, IEnumerable`1<IMember> selectedMembers, MemberSelectionContext context);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.CollectionMemberSelectionRuleDecorator : object {
    private IMemberSelectionRule selectionRule;
    public bool IncludesMembers { get; }
    public CollectionMemberSelectionRuleDecorator(IMemberSelectionRule selectionRule);
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<IMember> SelectMembers(INode currentNode, IEnumerable`1<IMember> selectedMembers, MemberSelectionContext context);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.ExcludeMemberByPathSelectionRule : SelectMemberByPathSelectionRule {
    private MemberPath memberToExclude;
    public ExcludeMemberByPathSelectionRule(MemberPath pathToExclude);
    protected virtual void AddOrRemoveMembersFrom(List`1<IMember> selectedMembers, INode parent, string parentPath, MemberSelectionContext context);
    public void AppendPath(MemberPath nextPath);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.ExcludeMemberByPredicateSelectionRule : object {
    private Func`2<IMemberInfo, bool> predicate;
    private string description;
    public bool IncludesMembers { get; }
    public ExcludeMemberByPredicateSelectionRule(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<IMember> SelectMembers(INode currentNode, IEnumerable`1<IMember> selectedMembers, MemberSelectionContext context);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool <SelectMembers>b__5_0(IMember p);
}
internal class FluentAssertions.Equivalency.Selection.ExcludeNonBrowsableMembersRule : object {
    public bool IncludesMembers { get; }
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<IMember> SelectMembers(INode currentNode, IEnumerable`1<IMember> selectedMembers, MemberSelectionContext context);
}
internal class FluentAssertions.Equivalency.Selection.IncludeMemberByPathSelectionRule : SelectMemberByPathSelectionRule {
    private MemberPath memberToInclude;
    public bool IncludesMembers { get; }
    public IncludeMemberByPathSelectionRule(MemberPath pathToInclude);
    public virtual bool get_IncludesMembers();
    protected virtual void AddOrRemoveMembersFrom(List`1<IMember> selectedMembers, INode parent, string parentPath, MemberSelectionContext context);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.IncludeMemberByPredicateSelectionRule : object {
    private Func`2<IMemberInfo, bool> predicate;
    private string description;
    public bool IncludesMembers { get; }
    public IncludeMemberByPredicateSelectionRule(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public sealed virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<IMember> SelectMembers(INode currentNode, IEnumerable`1<IMember> selectedMembers, MemberSelectionContext context);
    public virtual string ToString();
}
internal class FluentAssertions.Equivalency.Selection.MemberToMemberInfoAdapter : object {
    private IMember member;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Name { get; }
    public Type Type { get; }
    public Type DeclaringType { get; }
    public string Path { get; public set; }
    public CSharpAccessModifier GetterAccessibility { get; }
    public CSharpAccessModifier SetterAccessibility { get; }
    public MemberToMemberInfoAdapter(IMember member);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    public sealed virtual CSharpAccessModifier get_GetterAccessibility();
    public sealed virtual CSharpAccessModifier get_SetterAccessibility();
}
internal abstract class FluentAssertions.Equivalency.Selection.SelectMemberByPathSelectionRule : object {
    public bool IncludesMembers { get; }
    public virtual bool get_IncludesMembers();
    public sealed virtual IEnumerable`1<IMember> SelectMembers(INode currentNode, IEnumerable`1<IMember> selectedMembers, MemberSelectionContext context);
    protected abstract virtual void AddOrRemoveMembersFrom(List`1<IMember> selectedMembers, INode parent, string parentPath, MemberSelectionContext context);
    private static string RemoveRootIndexQualifier(string path);
}
public abstract class FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1 : object {
    private EqualityStrategyProvider equalityStrategyProvider;
    [DebuggerBrowsableAttribute("0")]
private List`1<IMemberSelectionRule> selectionRules;
    [DebuggerBrowsableAttribute("0")]
private List`1<IMemberMatchingRule> matchingRules;
    [DebuggerBrowsableAttribute("0")]
private List`1<IEquivalencyStep> userEquivalencySteps;
    [DebuggerBrowsableAttribute("0")]
private CyclicReferenceHandling cyclicReferenceHandling;
    [CompilerGeneratedAttribute]
private OrderingRuleCollection <OrderingRules>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private bool isRecursive;
    private bool allowInfiniteRecursion;
    private EnumEquivalencyHandling enumEquivalencyHandling;
    private bool useRuntimeTyping;
    private MemberVisibility includedProperties;
    private MemberVisibility includedFields;
    private bool ignoreNonBrowsableOnSubject;
    private bool excludeNonBrowsableOnExpectation;
    [CompilerGeneratedAttribute]
private ConversionSelector <ConversionSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
protected OrderingRuleCollection OrderingRules { get; }
    private IEnumerable`1<IMemberSelectionRule> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.SelectionRules { get; }
    private IEnumerable`1<IMemberMatchingRule> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.MatchingRules { get; }
    private IEnumerable`1<IEquivalencyStep> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.UserEquivalencySteps { get; }
    public ConversionSelector ConversionSelector { get; }
    private OrderingRuleCollection FluentAssertions.Equivalency.IEquivalencyAssertionOptions.OrderingRules { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IsRecursive { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.AllowInfiniteRecursion { get; }
    private CyclicReferenceHandling FluentAssertions.Equivalency.IEquivalencyAssertionOptions.CyclicReferenceHandling { get; }
    private EnumEquivalencyHandling FluentAssertions.Equivalency.IEquivalencyAssertionOptions.EnumEquivalencyHandling { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.UseRuntimeTyping { get; }
    private MemberVisibility FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludedProperties { get; }
    private MemberVisibility FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IncludedFields { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.IgnoreNonBrowsableOnSubject { get; }
    private bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.ExcludeNonBrowsableOnExpectation { get; }
    public Nullable`1<bool> CompareRecordsByValue { get; }
    public ITraceWriter TraceWriter { get; private set; }
    protected SelfReferenceEquivalencyAssertionOptions`1(IEquivalencyAssertionOptions defaults);
    [CompilerGeneratedAttribute]
protected OrderingRuleCollection get_OrderingRules();
    [IteratorStateMachineAttribute("FluentAssertions.Equivalency.SelfReferenceEquivalencyAssertionOptions`1/<FluentAssertions-Equivalency-IEquivalencyAssertionOptions-get_SelectionRules>d__19")]
private sealed virtual override IEnumerable`1<IMemberSelectionRule> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_SelectionRules();
    private sealed virtual override IEnumerable`1<IMemberMatchingRule> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_MatchingRules();
    private sealed virtual override IEnumerable`1<IEquivalencyStep> FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_UserEquivalencySteps();
    [CompilerGeneratedAttribute]
public sealed virtual ConversionSelector get_ConversionSelector();
    private sealed virtual override OrderingRuleCollection FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_OrderingRules();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_IsRecursive();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_AllowInfiniteRecursion();
    private sealed virtual override CyclicReferenceHandling FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_CyclicReferenceHandling();
    private sealed virtual override EnumEquivalencyHandling FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_EnumEquivalencyHandling();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_UseRuntimeTyping();
    private sealed virtual override MemberVisibility FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_IncludedProperties();
    private sealed virtual override MemberVisibility FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_IncludedFields();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_IgnoreNonBrowsableOnSubject();
    private sealed virtual override bool FluentAssertions.Equivalency.IEquivalencyAssertionOptions.get_ExcludeNonBrowsableOnExpectation();
    public sealed virtual Nullable`1<bool> get_CompareRecordsByValue();
    private sealed virtual override EqualityStrategy FluentAssertions.Equivalency.IEquivalencyAssertionOptions.GetEqualityStrategy(Type type);
    [CompilerGeneratedAttribute]
public sealed virtual ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
private void set_TraceWriter(ITraceWriter value);
    public TSelf IncludingAllDeclaredProperties();
    public TSelf IncludingAllRuntimeProperties();
    public TSelf IncludingFields();
    public TSelf IncludingInternalFields();
    public TSelf ExcludingFields();
    public TSelf IncludingProperties();
    public TSelf IncludingInternalProperties();
    public TSelf ExcludingProperties();
    public TSelf ExcludingNonBrowsableMembers();
    public TSelf IgnoringNonBrowsableMembersOnSubject();
    public TSelf RespectingRuntimeTypes();
    public TSelf RespectingDeclaredTypes();
    public TSelf Excluding(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public TSelf Including(Expression`1<Func`2<IMemberInfo, bool>> predicate);
    public TSelf ExcludingMissingMembers();
    public TSelf ThrowingOnMissingMembers();
    public Restriction`1<TSelf, TProperty> Using(Action`1<IAssertionContext`1<TProperty>> action);
    public TSelf IncludingNestedObjects();
    public TSelf ExcludingNestedObjects();
    public TSelf IgnoringCyclicReferences();
    public TSelf AllowingInfiniteRecursion();
    public void WithoutSelectionRules();
    public void WithoutMatchingRules();
    public TSelf Using(IMemberSelectionRule selectionRule);
    public TSelf Using(IMemberMatchingRule matchingRule);
    public TSelf Using(IOrderingRule orderingRule);
    public TSelf Using(IEquivalencyStep equivalencyStep);
    public TSelf Using();
    public TSelf Using(IEqualityComparer`1<T> comparer);
    public TSelf WithStrictOrdering();
    public TSelf WithStrictOrderingFor(Expression`1<Func`2<IObjectInfo, bool>> predicate);
    public TSelf WithoutStrictOrdering();
    public TSelf WithoutStrictOrderingFor(Expression`1<Func`2<IObjectInfo, bool>> predicate);
    public TSelf ComparingEnumsByName();
    public TSelf ComparingEnumsByValue();
    public TSelf ComparingRecordsByValue();
    public TSelf ComparingRecordsByMembers();
    public TSelf ComparingByMembers();
    public TSelf ComparingByMembers(Type type);
    public TSelf ComparingByValue();
    public TSelf ComparingByValue(Type type);
    public TSelf WithTracing(ITraceWriter writer);
    public TSelf WithAutoConversion();
    public TSelf WithAutoConversionFor(Expression`1<Func`2<IObjectInfo, bool>> predicate);
    public TSelf WithoutAutoConversionFor(Expression`1<Func`2<IObjectInfo, bool>> predicate);
    public virtual string ToString();
    private void RemoveSelectionRule();
    protected TSelf AddSelectionRule(IMemberSelectionRule selectionRule);
    protected TSelf AddMatchingRule(IMemberMatchingRule matchingRule);
    private TSelf AddOrderingRule(IOrderingRule orderingRule);
    private TSelf AddEquivalencyStep(IEquivalencyStep equivalencyStep);
}
internal class FluentAssertions.Equivalency.Steps.AssertionContext`1 : object {
    [CompilerGeneratedAttribute]
private INode <SelectedNode>k__BackingField;
    [CompilerGeneratedAttribute]
private TSubject <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private TSubject <Expectation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Because>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <BecauseArgs>k__BackingField;
    public INode SelectedNode { get; }
    public TSubject Subject { get; }
    public TSubject Expectation { get; }
    public string Because { get; public set; }
    public Object[] BecauseArgs { get; public set; }
    private AssertionContext`1(INode currentNode, TSubject subject, TSubject expectation, string because, Object[] becauseArgs);
    [CompilerGeneratedAttribute]
public sealed virtual INode get_SelectedNode();
    [CompilerGeneratedAttribute]
public sealed virtual TSubject get_Subject();
    [CompilerGeneratedAttribute]
public sealed virtual TSubject get_Expectation();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Because();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Because(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Object[] get_BecauseArgs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BecauseArgs(Object[] value);
    internal static AssertionContext`1<TSubject> CreateFrom(Comparands comparands, IEquivalencyValidationContext context);
}
internal class FluentAssertions.Equivalency.Steps.AssertionResultSet : object {
    private Dictionary`2<object, String[]> set;
    public void AddSet(object key, String[] failures);
    public String[] SelectClosestMatchFor(object key);
    private KeyValuePair`2[] GetBestResultSets();
    public bool ContainsSuccessfulSet();
}
public class FluentAssertions.Equivalency.Steps.AssertionRuleEquivalencyStep`1 : object {
    private Func`2<IObjectInfo, bool> predicate;
    private string description;
    private Action`1<IAssertionContext`1<TSubject>> assertion;
    private AutoConversionStep converter;
    public AssertionRuleEquivalencyStep`1(Expression`1<Func`2<IObjectInfo, bool>> predicate, Action`1<IAssertionContext`1<TSubject>> assertion);
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private bool AppliesTo(Comparands comparands, INode currentNode);
    private bool ExecuteAssertion(Comparands comparands, IEquivalencyValidationContext context);
    private static bool CanBeNull();
    public virtual string ToString();
}
public class FluentAssertions.Equivalency.Steps.AutoConversionStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static bool TryChangeType(object subject, Type expectationType, Object& conversionResult);
    public virtual string ToString();
}
public class FluentAssertions.Equivalency.Steps.ConstraintCollectionEquivalencyStep : EquivalencyStep`1<ConstraintCollection> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
public class FluentAssertions.Equivalency.Steps.ConstraintEquivalencyStep : EquivalencyStep`1<Constraint> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void CompareCommonProperties(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions options, Constraint subject, Constraint expectation, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareConstraints(IEquivalencyValidator parent, IEquivalencyValidationContext context, UniqueConstraint subject, UniqueConstraint expectation, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareConstraints(IEquivalencyValidator parent, IEquivalencyValidationContext context, ForeignKeyConstraint subject, ForeignKeyConstraint expectation, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareConstraintColumns(DataColumn[] subjectColumns, DataColumn[] expectationColumns);
    private static IMember FindMatchFor(IMember selectedMemberInfo, INode currentNode, object subject, IEquivalencyAssertionOptions config);
    private static IEnumerable`1<IMember> GetMembersFromExpectation(Comparands comparands, INode currentNode, IEquivalencyAssertionOptions options);
}
public class FluentAssertions.Equivalency.Steps.DataColumnEquivalencyStep : EquivalencyStep`1<DataColumn> {
    private static HashSet`1<string> CandidateMembers;
    private static DataColumnEquivalencyStep();
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void CompareSubjectAndExpectationOfTypeDataColumn(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator parent, DataColumn subject);
    private static void CompareMember(IMember expectationMember, Comparands comparands, IEquivalencyValidator parent, IEquivalencyValidationContext context);
    private static IMember FindMatchFor(IMember selectedMemberInfo, object subject, IEquivalencyValidationContext context);
    private static IEnumerable`1<IMember> GetMembersFromExpectation(INode currentNode, Comparands comparands, IEquivalencyAssertionOptions config);
}
public class FluentAssertions.Equivalency.Steps.DataRelationEquivalencyStep : EquivalencyStep`1<DataRelation> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void CompareScalarProperties(DataRelation subject, DataRelation expectation, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareCollections(IEquivalencyValidationContext context, Comparands comparands, IEquivalencyValidator parent, IEquivalencyAssertionOptions config, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareRelationConstraints(IEquivalencyValidationContext context, IEquivalencyValidator parent, DataRelation subject, DataRelation expectation, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareDataRelationConstraints(IEquivalencyValidator parent, IEquivalencyValidationContext context, DataRelation subject, DataRelation expectation, Dictionary`2<string, IMember> selectedMembers, string relationDirection, bool compareTable, bool compareColumns, bool compareKeyConstraint, Func`2<DataRelation, DataColumn[]> getColumns, Func`2<DataRelation, DataTable> getOtherTable);
    private static void CompareDataRelationColumns(DataRelation subject, DataRelation expectation, Func`2<DataRelation, DataColumn[]> getColumns);
    private static void CompareDataRelationTable(DataRelation subject, DataRelation expectation, Func`2<DataRelation, DataTable> getOtherTable);
    private static void CompareDataRelationKeyConstraint(DataRelation subject, DataRelation expectation, IEquivalencyValidator parent, IEquivalencyValidationContext context, Dictionary`2<string, IMember> selectedMembers, string relationDirection);
    private static IMember FindMatchFor(IMember selectedMemberInfo, INode currentNode, object subject, IEquivalencyAssertionOptions config);
    private static IEnumerable`1<IMember> GetMembersFromExpectation(INode currentNode, Comparands comparands, IEquivalencyAssertionOptions config);
}
public class FluentAssertions.Equivalency.Steps.DataRowCollectionEquivalencyStep : EquivalencyStep`1<DataRowCollection> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void MatchRowsByIndexAndCompare(IEquivalencyValidationContext context, IEquivalencyValidator parent, DataRowCollection subject, DataRowCollection expectation);
    private static void MatchRowsByPrimaryKeyAndCompare(IEquivalencyValidator parent, IEquivalencyValidationContext context, DataRowCollection subject, DataRowCollection expectation);
    private static Type[] GatherPrimaryKeyColumnTypes(DataTable table, string comparisonTerm);
    private static bool ComparePrimaryKeyTypes(Type[] subjectPrimaryKeyTypes, Type[] expectationPrimaryKeyTypes);
    private static void GatherRowsByPrimaryKeyAndCompareData(IEquivalencyValidator parent, IEquivalencyValidationContext context, DataRowCollection subject, DataRowCollection expectation);
    private static CompoundKey ExtractPrimaryKey(DataRow row);
}
public class FluentAssertions.Equivalency.Steps.DataRowEquivalencyStep : EquivalencyStep`1<DataRow> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`3<Type, Type, IEquivalencyAssertionOptions>, SelectedDataRowMembers> SelectedMembersCache;
    private static DataRowEquivalencyStep();
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void CompareScalarProperties(DataRow subject, DataRow expectation, SelectedDataRowMembers selectedMembers);
    private static void CompareFieldValues(IEquivalencyValidationContext context, IEquivalencyValidator parent, DataRow subject, DataRow expectation, DataEquivalencyAssertionOptions`1<DataSet> dataSetConfig, DataEquivalencyAssertionOptions`1<DataTable> dataTableConfig, DataEquivalencyAssertionOptions`1<DataRow> dataRowConfig);
    private static void CompareFieldValue(IEquivalencyValidationContext context, IEquivalencyValidator parent, DataRow subject, DataRow expectation, DataColumn subjectColumn, DataRowVersion subjectVersion, DataColumn expectationColumn, DataRowVersion expectationVersion);
    private static SelectedDataRowMembers GetMembersFromExpectation(Comparands comparands, INode currentNode, IEquivalencyAssertionOptions config);
}
public class FluentAssertions.Equivalency.Steps.DataSetEquivalencyStep : EquivalencyStep`1<DataSet> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void CompareScalarProperties(DataSet subject, DataSet expectation, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareCollections(IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config, DataSet subject, DataSet expectation, DataEquivalencyAssertionOptions`1<DataSet> dataConfig, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareExtendedProperties(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareTables(IEquivalencyValidationContext context, IEquivalencyValidator parent, DataSet subject, DataSet expectation, DataEquivalencyAssertionOptions`1<DataSet> dataConfig, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareTable(IEquivalencyValidationContext context, IEquivalencyValidator parent, DataSet subject, DataSet expectation, string tableName);
    private static IMember FindMatchFor(IMember selectedMemberInfo, object subject, INode currentNode, IEquivalencyAssertionOptions options);
    private static IEnumerable`1<IMember> GetMembersFromExpectation(Comparands comparands, INode contextCurrentNode, IEquivalencyAssertionOptions options);
}
public class FluentAssertions.Equivalency.Steps.DataTableEquivalencyStep : EquivalencyStep`1<DataTable> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void CompareScalarProperties(DataTable subject, DataTable expectation, Dictionary`2<string, IMember> selectedMembers);
    private static void CompareCollections(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions config, Dictionary`2<string, IMember> selectedMembers);
    private static IMember FindMatchFor(IMember selectedMemberInfo, object subject, INode currentNode, IEquivalencyAssertionOptions config);
    private static IEnumerable`1<IMember> GetMembersFromExpectation(INode currentNode, Comparands comparands, IEquivalencyAssertionOptions config);
}
public class FluentAssertions.Equivalency.Steps.DictionaryEquivalencyStep : EquivalencyStep`1<IDictionary> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static bool PreconditionsAreMet(IDictionary expectation, IDictionary subject);
    private static bool AssertEitherIsNotNull(IDictionary expectation, IDictionary subject);
    private static bool AssertIsDictionary(IDictionary subject);
    private static bool AssertSameLength(IDictionary expectation, IDictionary subject);
}
internal class FluentAssertions.Equivalency.Steps.DictionaryInterfaceInfo : object {
    private static MethodInfo ConvertToDictionaryMethod;
    private static ConcurrentDictionary`2<Type, DictionaryInterfaceInfo[]> Cache;
    [CompilerGeneratedAttribute]
private Type <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Key>k__BackingField;
    public Type Value { get; }
    public Type Key { get; }
    private DictionaryInterfaceInfo(Type key, Type value);
    private static DictionaryInterfaceInfo();
    [CompilerGeneratedAttribute]
public Type get_Value();
    [CompilerGeneratedAttribute]
public Type get_Key();
    public static DictionaryInterfaceInfo FindFrom(Type target, string role);
    public static DictionaryInterfaceInfo FindFromWithKey(Type target, string role, Type key);
    private static DictionaryInterfaceInfo[] GetDictionaryInterfacesFrom(Type target);
    public object ConvertFrom(object convertable);
    private static Dictionary`2<TKey, TValue> ConvertToDictionaryInternal(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool <ConvertFrom>b__12_2(Type itemType);
}
public class FluentAssertions.Equivalency.Steps.EnumEqualityStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void HandleByValue(Comparands comparands, Reason reason);
    private static void HandleByName(Comparands comparands, Reason reason);
    private static string GetDisplayNameForEnumComparison(object o, Nullable`1<decimal> v);
    private static Nullable`1<decimal> ExtractDecimal(object o);
}
public class FluentAssertions.Equivalency.Steps.EnumerableEquivalencyStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static bool AssertSubjectIsCollection(object subject);
    private static bool IsCollection(Type type);
    internal static Object[] ToArray(object value);
    private static bool IsIgnorableArrayLikeType(object value);
}
internal class FluentAssertions.Equivalency.Steps.EnumerableEquivalencyValidator : object {
    private static int FailedItemsFastFailThreshold;
    private IEquivalencyValidator parent;
    private IEquivalencyValidationContext context;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderingRuleCollection <OrderingRules>k__BackingField;
    private List`1<int> unmatchedSubjectIndexes;
    public bool Recursive { get; public set; }
    public OrderingRuleCollection OrderingRules { get; public set; }
    public EnumerableEquivalencyValidator(IEquivalencyValidator parent, IEquivalencyValidationContext context);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Recursive(bool value);
    [CompilerGeneratedAttribute]
public OrderingRuleCollection get_OrderingRules();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OrderingRules(OrderingRuleCollection value);
    public void Execute(Object[] subject, T[] expectation);
    private static bool AssertIsNotNull(object expectation, Object[] subject);
    private static Continuation AssertCollectionsHaveSameCount(ICollection`1<object> subject, ICollection`1<T> expectation);
    private void AssertElementGraphEquivalency(Object[] subjects, T[] expectations, INode currentNode);
    private void AssertElementGraphEquivalencyWithStrictOrdering(Object[] subjects, T[] expectations);
    private void AssertElementGraphEquivalencyWithLooseOrdering(Object[] subjects, T[] expectations);
    private bool LooselyMatchAgainst(IList`1<object> subjects, T expectation, int expectationIndex);
    private String[] TryToMatch(object subject, T expectation, int expectationIndex);
    private bool StrictlyMatchAgainst(Object[] subjects, T expectation, int expectationIndex);
}
[ExtensionAttribute]
internal static class FluentAssertions.Equivalency.Steps.EnumerableEquivalencyValidatorExtensions : object {
    [ExtensionAttribute]
public static Continuation AssertEitherCollectionIsNotEmpty(IAssertionScope scope, ICollection`1<object> subject, ICollection`1<T> expectation);
    [ExtensionAttribute]
public static Continuation AssertCollectionHasEnoughItems(IAssertionScope scope, ICollection`1<object> subject, ICollection`1<T> expectation);
    [ExtensionAttribute]
public static Continuation AssertCollectionHasNotTooManyItems(IAssertionScope scope, ICollection`1<object> subject, ICollection`1<T> expectation);
}
public class FluentAssertions.Equivalency.Steps.EqualityComparerEquivalencyStep`1 : object {
    private IEqualityComparer`1<T> comparer;
    public EqualityComparerEquivalencyStep`1(IEqualityComparer`1<T> comparer);
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class FluentAssertions.Equivalency.Steps.EquivalencyValidationContextExtensions : object {
    [ExtensionAttribute]
public static IEquivalencyValidationContext AsCollectionItem(IEquivalencyValidationContext context, int index);
}
public class FluentAssertions.Equivalency.Steps.GenericDictionaryEquivalencyStep : object {
    private static MethodInfo AssertDictionaryEquivalenceMethod;
    private static GenericDictionaryEquivalencyStep();
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static bool IsNonGenericDictionary(object subject);
    private static bool IsNotNull(object subject);
    private static DictionaryInterfaceInfo EnsureSubjectIsOfTheExpectedDictionaryType(Comparands comparands, DictionaryInterfaceInfo expectedDictionary);
    private static void FailWithLengthDifference(IDictionary`2<TSubjectKey, TSubjectValue> subject, IDictionary`2<TExpectedKey, TExpectedValue> expectation);
    private static KeyDifference`2<TSubjectKey, TExpectedKey> CalculateKeyDifference(IDictionary`2<TSubjectKey, TSubjectValue> subject, IDictionary`2<TExpectedKey, TExpectedValue> expectation);
    private static void AssertDictionaryEquivalence(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator parent, DictionaryInterfaceInfo actualDictionary, DictionaryInterfaceInfo expectedDictionary);
    private static void AssertDictionaryEquivalence(EquivalencyValidationContext context, IEquivalencyValidator parent, IEquivalencyAssertionOptions options, IDictionary`2<TSubjectKey, TSubjectValue> subject, IDictionary`2<TExpectedKey, TExpectedValue> expectation);
}
public class FluentAssertions.Equivalency.Steps.GenericEnumerableEquivalencyStep : object {
    private static MethodInfo HandleMethod;
    private static GenericEnumerableEquivalencyStep();
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void HandleImpl(EnumerableEquivalencyValidator validator, Object[] subject, IEnumerable`1<T> expectation);
    private static bool AssertSubjectIsCollection(object subject);
    private static bool IsCollection(Type type);
    private static bool IsGenericCollection(Type type);
    private static Type[] GetIEnumerableInterfaces(Type type);
    private static Type GetTypeOfEnumeration(Type enumerableType);
    private static T[] ToArray(IEnumerable`1<T> value);
}
public class FluentAssertions.Equivalency.Steps.ReferenceEqualityEquivalencyStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
public class FluentAssertions.Equivalency.Steps.RunAllUserStepsEquivalencyStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
public class FluentAssertions.Equivalency.Steps.SimpleEqualityEquivalencyStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
public class FluentAssertions.Equivalency.Steps.StringEqualityEquivalencyStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static bool ValidateAgainstNulls(Comparands comparands, INode currentNode);
    private static bool ValidateSubjectIsString(Comparands comparands, INode currentNode);
}
public class FluentAssertions.Equivalency.Steps.StructuralEqualityEquivalencyStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
    private static void AssertMemberEquality(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator parent, IMember selectedMember, IEquivalencyAssertionOptions options);
    private static IMember FindMatchFor(IMember selectedMember, INode currentNode, object subject, IEquivalencyAssertionOptions config);
    private static IEnumerable`1<IMember> GetMembersFromExpectation(INode currentNode, Comparands comparands, IEquivalencyAssertionOptions options);
}
public class FluentAssertions.Equivalency.Steps.ValueTypeEquivalencyStep : object {
    public sealed virtual EquivalencyResult Handle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
public class FluentAssertions.Equivalency.Steps.XAttributeEquivalencyStep : EquivalencyStep`1<XAttribute> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
public class FluentAssertions.Equivalency.Steps.XDocumentEquivalencyStep : EquivalencyStep`1<XDocument> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
public class FluentAssertions.Equivalency.Steps.XElementEquivalencyStep : EquivalencyStep`1<XElement> {
    protected virtual EquivalencyResult OnHandle(Comparands comparands, IEquivalencyValidationContext context, IEquivalencyValidator nestedValidator);
}
[ExtensionAttribute]
public static class FluentAssertions.Equivalency.SubjectInfoExtensions : object {
    [ExtensionAttribute]
public static bool WhichSetterHas(IMemberInfo memberInfo, CSharpAccessModifier accessModifier);
    [ExtensionAttribute]
public static bool WhichSetterDoesNotHave(IMemberInfo memberInfo, CSharpAccessModifier accessModifier);
    [ExtensionAttribute]
public static bool WhichGetterHas(IMemberInfo memberInfo, CSharpAccessModifier accessModifier);
    [ExtensionAttribute]
public static bool WhichGetterDoesNotHave(IMemberInfo memberInfo, CSharpAccessModifier accessModifier);
}
public class FluentAssertions.Equivalency.Tracing.GetTraceMessage : MulticastDelegate {
    public GetTraceMessage(object object, IntPtr method);
    public virtual string Invoke(INode node);
    public virtual IAsyncResult BeginInvoke(INode node, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public interface FluentAssertions.Equivalency.Tracing.ITraceWriter {
    public abstract virtual void AddSingle(string trace);
    public abstract virtual IDisposable AddBlock(string trace);
    public abstract virtual string ToString();
}
public class FluentAssertions.Equivalency.Tracing.StringBuilderTraceWriter : object {
    private StringBuilder builder;
    private int depth;
    public sealed virtual void AddSingle(string trace);
    public sealed virtual IDisposable AddBlock(string trace);
    private void WriteLine(string trace);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <AddBlock>b__3_0();
}
public class FluentAssertions.Equivalency.Tracing.Tracer : object {
    private INode currentNode;
    private ITraceWriter traceWriter;
    internal Tracer(INode currentNode, ITraceWriter traceWriter);
    public void WriteLine(GetTraceMessage getTraceMessage);
    public IDisposable WriteBlock(GetTraceMessage getTraceMessage);
    public virtual string ToString();
}
public class FluentAssertions.EquivalencyPlan : object {
    private List`1<IEquivalencyStep> steps;
    public sealed virtual IEnumerator`1<IEquivalencyStep> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add();
    public void AddAfter();
    public void Insert();
    public void InsertBefore();
    public void Remove();
    public void Clear();
    public void Reset();
    private static List`1<IEquivalencyStep> GetDefaultSteps();
}
[ExtensionAttribute]
public static class FluentAssertions.EventRaisingExtensions : object {
    [ExtensionAttribute]
public static IEventRecording WithSender(IEventRecording eventRecording, object expectedSender);
    [ExtensionAttribute]
public static IEventRecording WithArgs(IEventRecording eventRecording, Expression`1<Func`2<T, bool>> predicate);
    [ExtensionAttribute]
public static IEventRecording WithArgs(IEventRecording eventRecording, Expression`1[] predicates);
}
public class FluentAssertions.Events.EventAssertions`1 : ReferenceTypeAssertions`2<T, EventAssertions`1<T>> {
    private static string PropertyChangedEventName;
    [CompilerGeneratedAttribute]
private IMonitor`1<T> <Monitor>k__BackingField;
    public IMonitor`1<T> Monitor { get; }
    protected string Identifier { get; }
    protected internal EventAssertions`1(IMonitor`1<T> monitor);
    [CompilerGeneratedAttribute]
public IMonitor`1<T> get_Monitor();
    public IEventRecording Raise(string eventName, string because, Object[] becauseArgs);
    public void NotRaise(string eventName, string because, Object[] becauseArgs);
    public IEventRecording RaisePropertyChangeFor(Expression`1<Func`2<T, object>> propertyExpression, string because, Object[] becauseArgs);
    public void NotRaisePropertyChangeFor(Expression`1<Func`2<T, object>> propertyExpression, string because, Object[] becauseArgs);
    private static string GetAffectedPropertyName(OccurredEvent event);
    protected virtual string get_Identifier();
}
internal static class FluentAssertions.Events.EventHandlerFactory : object {
    public static Delegate GenerateHandler(Type eventSignature, EventRecorder recorder);
    private static Type GetDelegateReturnType(Type d);
    private static Type[] GetDelegateParameterTypes(Type d);
    private static Type[] AppendParameterListThisReference(Type[] parameters);
    private static bool TypeIsDelegate(Type d);
    private static MethodInfo DelegateInvokeMethod(Type d);
}
public class FluentAssertions.Events.EventMetadata : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HandlerType>k__BackingField;
    public string EventName { get; }
    public Type HandlerType { get; }
    public EventMetadata(string eventName, Type handlerType);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public Type get_HandlerType();
}
internal class FluentAssertions.Events.EventMonitor`1 : object {
    private WeakReference subject;
    private ConcurrentDictionary`2<string, EventRecorder> recorderMap;
    private ThreadSafeSequenceGenerator threadSafeSequenceGenerator;
    public T Subject { get; }
    public EventMetadata[] MonitoredEvents { get; }
    public OccurredEvent[] OccurredEvents { get; }
    public EventMonitor`1(object eventSource, Func`1<DateTime> utcNow);
    public sealed virtual T get_Subject();
    public sealed virtual EventMetadata[] get_MonitoredEvents();
    public sealed virtual OccurredEvent[] get_OccurredEvents();
    public sealed virtual void Clear();
    public sealed virtual EventAssertions`1<T> Should();
    public sealed virtual IEventRecording GetRecordingFor(string eventName);
    private void Attach(Type typeDefiningEventsToMonitor, Func`1<DateTime> utcNow);
    private static EventInfo[] GetPublicEvents(Type type);
    public sealed virtual void Dispose();
    private void AttachEventHandler(EventInfo eventInfo, Func`1<DateTime> utcNow);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType1`2<string, IEventRecording> <get_OccurredEvents>b__9_0(string eventName);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Events.EventRecorder : object {
    private Func`1<DateTime> utcNow;
    private BlockingCollection`1<RecordedEvent> raisedEvents;
    private object lockable;
    private Action cleanup;
    [CompilerGeneratedAttribute]
private object <EventObject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    private ThreadSafeSequenceGenerator sequenceGenerator;
    [CompilerGeneratedAttribute]
private Type <EventHandlerType>k__BackingField;
    public object EventObject { get; private set; }
    public string EventName { get; }
    public Type EventHandlerType { get; private set; }
    public EventRecorder(object eventRaiser, string eventName, Func`1<DateTime> utcNow, ThreadSafeSequenceGenerator sequenceGenerator);
    [CompilerGeneratedAttribute]
public sealed virtual object get_EventObject();
    [CompilerGeneratedAttribute]
private void set_EventObject(object value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EventName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventHandlerType();
    [CompilerGeneratedAttribute]
private void set_EventHandlerType(Type value);
    public void Attach(WeakReference subject, EventInfo eventInfo);
    public sealed virtual void Dispose();
    public void RecordEvent(Object[] parameters);
    public void Reset();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("FluentAssertions.Events.EventRecorder/<GetEnumerator>d__22")]
public sealed virtual IEnumerator`1<OccurredEvent> GetEnumerator();
}
internal class FluentAssertions.Events.FilteredEventRecording : object {
    private OccurredEvent[] occurredEvents;
    [CompilerGeneratedAttribute]
private object <EventObject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EventHandlerType>k__BackingField;
    public object EventObject { get; }
    public string EventName { get; }
    public Type EventHandlerType { get; }
    public FilteredEventRecording(IEventRecording eventRecorder, IEnumerable`1<OccurredEvent> events);
    [CompilerGeneratedAttribute]
public sealed virtual object get_EventObject();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EventName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventHandlerType();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("FluentAssertions.Events.FilteredEventRecording/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<OccurredEvent> GetEnumerator();
}
public interface FluentAssertions.Events.IEventRecording {
    public object EventObject { get; }
    public string EventName { get; }
    public Type EventHandlerType { get; }
    public abstract virtual object get_EventObject();
    public abstract virtual string get_EventName();
    public abstract virtual Type get_EventHandlerType();
}
public interface FluentAssertions.Events.IMonitor`1 {
    public T Subject { get; }
    public EventMetadata[] MonitoredEvents { get; }
    public OccurredEvent[] OccurredEvents { get; }
    public abstract virtual T get_Subject();
    public abstract virtual void Clear();
    public abstract virtual EventAssertions`1<T> Should();
    public abstract virtual IEventRecording GetRecordingFor(string eventName);
    public abstract virtual EventMetadata[] get_MonitoredEvents();
    public abstract virtual OccurredEvent[] get_OccurredEvents();
}
public class FluentAssertions.Events.OccurredEvent : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimestampUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sequence>k__BackingField;
    public string EventName { get; public set; }
    public Object[] Parameters { get; public set; }
    public DateTime TimestampUtc { get; public set; }
    public int Sequence { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public void set_EventName(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(Object[] value);
    [CompilerGeneratedAttribute]
public DateTime get_TimestampUtc();
    [CompilerGeneratedAttribute]
public void set_TimestampUtc(DateTime value);
    [CompilerGeneratedAttribute]
public int get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(int value);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Events.RecordedEvent : object {
    [CompilerGeneratedAttribute]
private DateTime <TimestampUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sequence>k__BackingField;
    public DateTime TimestampUtc { get; }
    public Object[] Parameters { get; }
    public int Sequence { get; }
    public RecordedEvent(DateTime utcNow, int sequence, Object[] parameters);
    [CompilerGeneratedAttribute]
public DateTime get_TimestampUtc();
    [CompilerGeneratedAttribute]
public Object[] get_Parameters();
    [CompilerGeneratedAttribute]
public int get_Sequence();
}
internal class FluentAssertions.Events.ThreadSafeSequenceGenerator : object {
    private int sequence;
    public int Increment();
}
public static class FluentAssertions.Exactly : object {
    public static OccurrenceConstraint Once();
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
[ExtensionAttribute]
public static class FluentAssertions.ExceptionAssertionsExtensions : object {
    [AsyncStateMachineAttribute("FluentAssertions.ExceptionAssertionsExtensions/<WithMessage>d__0`1")]
[ExtensionAttribute]
public static Task`1<ExceptionAssertions`1<TException>> WithMessage(Task`1<ExceptionAssertions`1<TException>> task, string expectedWildcardPattern, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.ExceptionAssertionsExtensions/<Where>d__1`1")]
[ExtensionAttribute]
public static Task`1<ExceptionAssertions`1<TException>> Where(Task`1<ExceptionAssertions`1<TException>> task, Expression`1<Func`2<TException, bool>> exceptionExpression, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.ExceptionAssertionsExtensions/<WithInnerException>d__2`2")]
[ExtensionAttribute]
public static Task`1<ExceptionAssertions`1<TInnerException>> WithInnerException(Task`1<ExceptionAssertions`1<TException>> task, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.ExceptionAssertionsExtensions/<WithInnerException>d__3`1")]
[ExtensionAttribute]
public static Task`1<ExceptionAssertions`1<Exception>> WithInnerException(Task`1<ExceptionAssertions`1<TException>> task, Type innerException, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.ExceptionAssertionsExtensions/<WithInnerExceptionExactly>d__4`2")]
[ExtensionAttribute]
public static Task`1<ExceptionAssertions`1<TInnerException>> WithInnerExceptionExactly(Task`1<ExceptionAssertions`1<TException>> task, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.ExceptionAssertionsExtensions/<WithInnerExceptionExactly>d__5`1")]
[ExtensionAttribute]
public static Task`1<ExceptionAssertions`1<Exception>> WithInnerExceptionExactly(Task`1<ExceptionAssertions`1<TException>> task, Type innerException, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static ExceptionAssertions`1<TException> WithParameterName(ExceptionAssertions`1<TException> parent, string paramName, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.ExceptionAssertionsExtensions/<WithParameterName>d__7`1")]
[ExtensionAttribute]
public static Task`1<ExceptionAssertions`1<TException>> WithParameterName(Task`1<ExceptionAssertions`1<TException>> task, string paramName, string because, Object[] becauseArgs);
}
public class FluentAssertions.Execution.AssertionFailedException : Exception {
    public AssertionFailedException(string message);
    protected AssertionFailedException(SerializationInfo info, StreamingContext context);
}
public class FluentAssertions.Execution.AssertionScope : object {
    private IAssertionStrategy assertionStrategy;
    private ContextDataItems contextData;
    private StringBuilder tracing;
    private Func`1<string> reason;
    private static AsyncLocal`1<AssertionScope> CurrentScope;
    private Func`1<string> callerIdentityProvider;
    private AssertionScope parent;
    private Func`1<string> expectation;
    private string fallbackIdentifier;
    private Nullable`1<bool> succeeded;
    [CompilerGeneratedAttribute]
private Lazy`1<string> <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private FormattingOptions <FormattingOptions>k__BackingField;
    public Lazy`1<string> Context { get; public set; }
    public static AssertionScope Current { get; private set; }
    public AssertionScope UsingLineBreaks { get; }
    public FormattingOptions FormattingOptions { get; }
    internal bool Succeeded { get; }
    public string CallerIdentity { get; }
    private IAssertionScope FluentAssertions.Execution.IAssertionScope.UsingLineBreaks { get; }
    public AssertionScope(string context);
    public AssertionScope(IAssertionStrategy assertionStrategy);
    public AssertionScope(Lazy`1<string> context);
    private AssertionScope(IAssertionStrategy assertionStrategy, Lazy`1<string> context);
    private static AssertionScope();
    private static Lazy`1<string> JoinContexts(Lazy`1<string> outer, Lazy`1<string> inner);
    [CompilerGeneratedAttribute]
public Lazy`1<string> get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(Lazy`1<string> value);
    public static AssertionScope get_Current();
    private static void set_Current(AssertionScope value);
    public AssertionScope get_UsingLineBreaks();
    [CompilerGeneratedAttribute]
public FormattingOptions get_FormattingOptions();
    internal bool get_Succeeded();
    public AssertionScope BecauseOf(Reason reason);
    public AssertionScope BecauseOf(string because, Object[] becauseArgs);
    public AssertionScope WithExpectation(string message, Object[] args);
    internal void TrackComparands(object subject, object expectation);
    public sealed virtual Continuation ClearExpectation();
    public sealed virtual GivenSelector`1<T> Given(Func`1<T> selector);
    public AssertionScope ForCondition(bool condition);
    public AssertionScope ForConstraint(OccurrenceConstraint constraint, int actualOccurrences);
    public sealed virtual Continuation FailWith(Func`1<FailReason> failReasonFunc);
    internal Continuation FailWithPreFormatted(string formattedFailReason);
    private Continuation FailWith(Func`1<string> failReasonFunc);
    public sealed virtual Continuation FailWith(string message);
    public sealed virtual Continuation FailWith(string message, Object[] args);
    public sealed virtual Continuation FailWith(string message, Func`1[] argProviders);
    private string GetIdentifier();
    public string get_CallerIdentity();
    public void AddPreFormattedFailure(string formattedFailureMessage);
    public void AppendTracing(string tracingBlock);
    public void AddNonReportable(string key, object value);
    public void AddReportable(string key, string value);
    public void AddReportable(string key, Func`1<string> valueFunc);
    public sealed virtual String[] Discard();
    public bool HasFailures();
    public T Get(string key);
    public sealed virtual void Dispose();
    public AssertionScope WithDefaultIdentifier(string identifier);
    public void AssumeSingleCaller();
    private static AssertionScope GetCurrentAssertionScope();
    private static void SetCurrentAssertionScope(AssertionScope scope);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.ForCondition(bool condition);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.BecauseOf(string because, Object[] becauseArgs);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.WithExpectation(string message, Object[] args);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.WithDefaultIdentifier(string identifier);
    private sealed virtual override IAssertionScope FluentAssertions.Execution.IAssertionScope.get_UsingLineBreaks();
    [CompilerGeneratedAttribute]
internal static Lazy`1<string> <JoinContexts>g__Join|16_0(Lazy`1<string> outer, Lazy`1<string> inner);
}
internal class FluentAssertions.Execution.CollectingAssertionStrategy : object {
    private List`1<string> failureMessages;
    public IEnumerable`1<string> FailureMessages { get; }
    public sealed virtual IEnumerable`1<string> get_FailureMessages();
    public sealed virtual IEnumerable`1<string> DiscardFailures();
    public sealed virtual void ThrowIfAny(IDictionary`2<string, object> context);
    public sealed virtual void HandleFailure(string message);
}
internal class FluentAssertions.Execution.ContextDataItems : object {
    private List`1<DataItem> items;
    public IDictionary`2<string, object> GetReportable();
    public string AsStringOrDefault(string key);
    public void Add(ContextDataItems contextDataItems);
    public void Add(DataItem item);
    public T Get(string key);
}
public class FluentAssertions.Execution.Continuation : object {
    private AssertionScope sourceScope;
    private bool continueAsserting;
    public IAssertionScope Then { get; }
    internal Continuation(AssertionScope sourceScope, bool continueAsserting);
    public IAssertionScope get_Then();
    public static bool op_Implicit(Continuation continuation);
}
public class FluentAssertions.Execution.ContinuationOfGiven`1 : object {
    private bool succeeded;
    [CompilerGeneratedAttribute]
private GivenSelector`1<TSubject> <Then>k__BackingField;
    public GivenSelector`1<TSubject> Then { get; }
    internal ContinuationOfGiven`1(GivenSelector`1<TSubject> parent, bool succeeded);
    [CompilerGeneratedAttribute]
public GivenSelector`1<TSubject> get_Then();
    public static bool op_Implicit(ContinuationOfGiven`1<TSubject> continuationOfGiven);
}
public class FluentAssertions.Execution.ContinuedAssertionScope : object {
    private AssertionScope predecessor;
    private bool continueAsserting;
    public IAssertionScope UsingLineBreaks { get; }
    internal ContinuedAssertionScope(AssertionScope predecessor, bool continueAsserting);
    public sealed virtual GivenSelector`1<T> Given(Func`1<T> selector);
    public sealed virtual IAssertionScope ForCondition(bool condition);
    public sealed virtual Continuation FailWith(string message);
    public sealed virtual Continuation FailWith(string message, Func`1[] argProviders);
    public sealed virtual Continuation FailWith(Func`1<FailReason> failReasonFunc);
    public sealed virtual Continuation FailWith(string message, Object[] args);
    public sealed virtual IAssertionScope BecauseOf(string because, Object[] becauseArgs);
    public sealed virtual Continuation ClearExpectation();
    public sealed virtual IAssertionScope WithExpectation(string message, Object[] args);
    public sealed virtual IAssertionScope WithDefaultIdentifier(string identifier);
    public sealed virtual IAssertionScope get_UsingLineBreaks();
    public sealed virtual String[] Discard();
    public sealed virtual void Dispose();
}
internal class FluentAssertions.Execution.DefaultAssertionStrategy : object {
    public IEnumerable`1<string> FailureMessages { get; }
    public sealed virtual IEnumerable`1<string> get_FailureMessages();
    public sealed virtual void HandleFailure(string message);
    public sealed virtual IEnumerable`1<string> DiscardFailures();
    public sealed virtual void ThrowIfAny(IDictionary`2<string, object> context);
}
public static class FluentAssertions.Execution.Execute : object {
    public static AssertionScope Assertion { get; }
    public static AssertionScope get_Assertion();
}
public class FluentAssertions.Execution.FailReason : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public string Message { get; }
    public Object[] Args { get; }
    public FailReason(string message, Object[] args);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Object[] get_Args();
}
internal class FluentAssertions.Execution.FallbackTestFramework : object {
    public bool IsAvailable { get; }
    public sealed virtual bool get_IsAvailable();
    [DoesNotReturnAttribute]
public sealed virtual void Throw(string message);
}
public class FluentAssertions.Execution.GivenSelector`1 : object {
    private AssertionScope predecessor;
    private T subject;
    private bool continueAsserting;
    internal GivenSelector`1(Func`1<T> selector, AssertionScope predecessor, bool continueAsserting);
    public GivenSelector`1<T> ForCondition(Func`2<T, bool> predicate);
    public GivenSelector`1<TOut> Given(Func`2<T, TOut> selector);
    public ContinuationOfGiven`1<T> FailWith(string message);
    public ContinuationOfGiven`1<T> FailWith(string message, Func`2[] args);
    public ContinuationOfGiven`1<T> FailWith(string message, Object[] args);
    public ContinuationOfGiven`1<T> ClearExpectation();
    [CompilerGeneratedAttribute]
private object <FailWith>b__7_0(Func`2<T, object> a);
}
[ExtensionAttribute]
internal static class FluentAssertions.Execution.GivenSelectorExtensions : object {
    [ExtensionAttribute]
public static ContinuationOfGiven`1<IEnumerable`1<T>> AssertCollectionIsNotNull(GivenSelector`1<IEnumerable`1<T>> givenSelector);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertEitherCollectionIsNotEmpty(GivenSelector`1<ICollection`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertCollectionHasEnoughItems(GivenSelector`1<IEnumerable`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertCollectionHasEnoughItems(GivenSelector`1<ICollection`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertCollectionHasNotTooManyItems(GivenSelector`1<ICollection`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<T>> AssertCollectionsHaveSameCount(GivenSelector`1<ICollection`1<T>> givenSelector, int length);
    [ExtensionAttribute]
public static ContinuationOfGiven`1<ICollection`1<TActual>> AssertCollectionsHaveSameItems(GivenSelector`1<ICollection`1<TActual>> givenSelector, ICollection`1<TExpected> expected, Func`3<ICollection`1<TActual>, ICollection`1<TExpected>, int> findIndex);
}
public interface FluentAssertions.Execution.IAssertionScope {
    public IAssertionScope UsingLineBreaks { get; }
    public abstract virtual GivenSelector`1<T> Given(Func`1<T> selector);
    public abstract virtual IAssertionScope ForCondition(bool condition);
    public abstract virtual Continuation FailWith(string message);
    public abstract virtual Continuation FailWith(Func`1<FailReason> failReasonFunc);
    public abstract virtual Continuation FailWith(string message, Object[] args);
    public abstract virtual Continuation FailWith(string message, Func`1[] argProviders);
    public abstract virtual IAssertionScope BecauseOf(string because, Object[] becauseArgs);
    public abstract virtual Continuation ClearExpectation();
    public abstract virtual IAssertionScope WithExpectation(string message, Object[] args);
    public abstract virtual IAssertionScope WithDefaultIdentifier(string identifier);
    public abstract virtual IAssertionScope get_UsingLineBreaks();
    public abstract virtual String[] Discard();
}
public interface FluentAssertions.Execution.IAssertionStrategy {
    public IEnumerable`1<string> FailureMessages { get; }
    public abstract virtual IEnumerable`1<string> get_FailureMessages();
    public abstract virtual void HandleFailure(string message);
    public abstract virtual IEnumerable`1<string> DiscardFailures();
    public abstract virtual void ThrowIfAny(IDictionary`2<string, object> context);
}
public interface FluentAssertions.Execution.ICloneable2 {
    public abstract virtual object Clone();
}
internal interface FluentAssertions.Execution.ITestFramework {
    public bool IsAvailable { get; }
    public abstract virtual bool get_IsAvailable();
    [DoesNotReturnAttribute]
public abstract virtual void Throw(string message);
}
internal abstract class FluentAssertions.Execution.LateBoundTestFramework : object {
    private Assembly assembly;
    public bool IsAvailable { get; }
    protected internal string AssemblyName { get; }
    protected string ExceptionFullName { get; }
    [DoesNotReturnAttribute]
public sealed virtual void Throw(string message);
    public sealed virtual bool get_IsAvailable();
    protected internal abstract virtual string get_AssemblyName();
    protected abstract virtual string get_ExceptionFullName();
}
internal class FluentAssertions.Execution.MessageBuilder : object {
    private FormattingOptions formattingOptions;
    private Char[] blanks;
    public MessageBuilder(FormattingOptions formattingOptions);
    public string Build(string message, Object[] messageArgs, string reason, ContextDataItems contextData, string identifier, string fallbackIdentifier);
    private static string SubstituteIdentifier(string message, string identifier, string fallbackIdentifier);
    private static string SubstituteContextualTags(string message, ContextDataItems contextData);
    private string FormatArgumentPlaceholders(string failureMessage, Object[] failureArgs);
    private string SanitizeReason(string reason);
    private string EnsurePrefix(string prefix, string text);
    private string ExtractLeadingBlanksFrom(string text);
    private bool StartsWithBlank(string text);
    [CompilerGeneratedAttribute]
private string <FormatArgumentPlaceholders>b__6_0(object a);
}
internal class FluentAssertions.Execution.MSpecFramework : LateBoundTestFramework {
    protected internal string AssemblyName { get; }
    protected string ExceptionFullName { get; }
    protected internal virtual string get_AssemblyName();
    protected virtual string get_ExceptionFullName();
}
internal class FluentAssertions.Execution.MSTestFrameworkV2 : LateBoundTestFramework {
    protected string ExceptionFullName { get; }
    protected internal string AssemblyName { get; }
    protected virtual string get_ExceptionFullName();
    protected internal virtual string get_AssemblyName();
}
internal class FluentAssertions.Execution.NSpecFramework : object {
    private Assembly assembly;
    public bool IsAvailable { get; }
    public sealed virtual bool get_IsAvailable();
    [DoesNotReturnAttribute]
public sealed virtual void Throw(string message);
}
internal class FluentAssertions.Execution.NUnitTestFramework : LateBoundTestFramework {
    protected internal string AssemblyName { get; }
    protected string ExceptionFullName { get; }
    protected internal virtual string get_AssemblyName();
    protected virtual string get_ExceptionFullName();
}
public class FluentAssertions.Execution.Reason : object {
    [CompilerGeneratedAttribute]
private string <FormattedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public string FormattedMessage { get; public set; }
    public Object[] Arguments { get; public set; }
    public Reason(string formattedMessage, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_FormattedMessage();
    [CompilerGeneratedAttribute]
public void set_FormattedMessage(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(Object[] value);
}
internal class FluentAssertions.Execution.TestFrameworkProvider : object {
    private static Dictionary`2<string, ITestFramework> Frameworks;
    private Configuration configuration;
    private ITestFramework testFramework;
    public TestFrameworkProvider(Configuration configuration);
    private static TestFrameworkProvider();
    [DoesNotReturnAttribute]
public void Throw(string message);
    private ITestFramework DetectFramework();
    private ITestFramework AttemptToDetectUsingAppSetting();
    private static ITestFramework AttemptToDetectUsingDynamicScanning();
}
internal class FluentAssertions.Execution.XUnit2TestFramework : object {
    private Assembly assembly;
    public bool IsAvailable { get; }
    public sealed virtual bool get_IsAvailable();
    [DoesNotReturnAttribute]
public sealed virtual void Throw(string message);
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.Extensions.FluentDateTimeExtensions : object {
    [ExtensionAttribute]
public static DateTime January(int day, int year);
    [ExtensionAttribute]
public static DateTime February(int day, int year);
    [ExtensionAttribute]
public static DateTime March(int day, int year);
    [ExtensionAttribute]
public static DateTime April(int day, int year);
    [ExtensionAttribute]
public static DateTime May(int day, int year);
    [ExtensionAttribute]
public static DateTime June(int day, int year);
    [ExtensionAttribute]
public static DateTime July(int day, int year);
    [ExtensionAttribute]
public static DateTime August(int day, int year);
    [ExtensionAttribute]
public static DateTime September(int day, int year);
    [ExtensionAttribute]
public static DateTime October(int day, int year);
    [ExtensionAttribute]
public static DateTime November(int day, int year);
    [ExtensionAttribute]
public static DateTime December(int day, int year);
    [ExtensionAttribute]
public static DateTime At(DateTime date, TimeSpan time);
    [ExtensionAttribute]
public static DateTime At(DateTime date, int hours, int minutes, int seconds, int milliseconds, int microseconds, int nanoseconds);
    [ExtensionAttribute]
public static DateTimeOffset At(DateTimeOffset date, int hours, int minutes, int seconds, int milliseconds, int microseconds, int nanoseconds);
    [ExtensionAttribute]
public static DateTime AsUtc(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime AsLocal(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime Before(TimeSpan timeDifference, DateTime sourceDateTime);
    [ExtensionAttribute]
public static DateTime After(TimeSpan timeDifference, DateTime sourceDateTime);
    [ExtensionAttribute]
public static int Nanosecond(DateTime self);
    [ExtensionAttribute]
public static int Nanosecond(DateTimeOffset self);
    [ExtensionAttribute]
public static DateTime AddNanoseconds(DateTime self, long nanoseconds);
    [ExtensionAttribute]
public static DateTimeOffset AddNanoseconds(DateTimeOffset self, long nanoseconds);
    [ExtensionAttribute]
public static int Microsecond(DateTime self);
    [ExtensionAttribute]
public static int Microsecond(DateTimeOffset self);
    [ExtensionAttribute]
public static DateTime AddMicroseconds(DateTime self, long microseconds);
    [ExtensionAttribute]
public static DateTimeOffset AddMicroseconds(DateTimeOffset self, long microseconds);
    [ExtensionAttribute]
public static DateTimeOffset WithOffset(DateTime self, TimeSpan offset);
}
[ExtensionAttribute]
public static class FluentAssertions.Extensions.FluentTimeSpanExtensions : object {
    public static long TicksPerMicrosecond;
    public static double TicksPerNanosecond;
    [ExtensionAttribute]
public static TimeSpan Ticks(int ticks);
    [ExtensionAttribute]
public static TimeSpan Ticks(long ticks);
    [ExtensionAttribute]
public static int Nanoseconds(TimeSpan self);
    [ExtensionAttribute]
public static TimeSpan Nanoseconds(int nanoseconds);
    [ExtensionAttribute]
public static TimeSpan Nanoseconds(long nanoseconds);
    [ExtensionAttribute]
public static double TotalNanoseconds(TimeSpan self);
    [ExtensionAttribute]
public static int Microseconds(TimeSpan self);
    [ExtensionAttribute]
public static TimeSpan Microseconds(int microseconds);
    [ExtensionAttribute]
public static TimeSpan Microseconds(long microseconds);
    [ExtensionAttribute]
public static double TotalMicroseconds(TimeSpan self);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(int milliseconds);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(double milliseconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(int seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(double seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(int seconds, TimeSpan offset);
    [ExtensionAttribute]
public static TimeSpan Minutes(int minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(double minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(int minutes, TimeSpan offset);
    [ExtensionAttribute]
public static TimeSpan Hours(int hours);
    [ExtensionAttribute]
public static TimeSpan Hours(double hours);
    [ExtensionAttribute]
public static TimeSpan Hours(int hours, TimeSpan offset);
    [ExtensionAttribute]
public static TimeSpan Days(int days);
    [ExtensionAttribute]
public static TimeSpan Days(double days);
    [ExtensionAttribute]
public static TimeSpan Days(int days, TimeSpan offset);
    [ExtensionAttribute]
public static TimeSpan And(TimeSpan sourceTime, TimeSpan offset);
}
[ExtensionAttribute]
public static class FluentAssertions.Extensions.OccurrenceConstraintExtensions : object {
    [ExtensionAttribute]
public static OccurrenceConstraint TimesExactly(int times);
    [ExtensionAttribute]
public static OccurrenceConstraint TimesOrLess(int times);
    [ExtensionAttribute]
public static OccurrenceConstraint TimesOrMore(int times);
}
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.FluentActions : object {
    public static Action Invoking(Action action);
    public static Func`1<T> Invoking(Func`1<T> func);
    public static Func`1<Task> Awaiting(Func`1<Task> action);
    public static Func`1<Task`1<T>> Awaiting(Func`1<Task`1<T>> func);
    public static Action Enumerating(Func`1<IEnumerable> enumerable);
    public static Action Enumerating(Func`1<IEnumerable`1<T>> enumerable);
}
public class FluentAssertions.Formatting.AggregateExceptionValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.AttributeBasedFormatter : object {
    private Dictionary`2<Type, MethodInfo> formatters;
    private ValueFormatterDetectionMode detectionMode;
    private static bool IsScanningEnabled { get; }
    private Dictionary`2<Type, MethodInfo> Formatters { get; }
    public sealed virtual bool CanHandle(object value);
    private static bool get_IsScanningEnabled();
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
    private MethodInfo GetFormatter(object value);
    private Dictionary`2<Type, MethodInfo> get_Formatters();
    private void HandleValueFormatterDetectionModeChanges();
    private static Dictionary`2<Type, MethodInfo> FindCustomFormatters();
    private static bool Applicable(Assembly assembly);
}
public class FluentAssertions.Formatting.ByteValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.DateTimeOffsetValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
    private static bool HasTime(DateTimeOffset dateTime);
    private static bool HasDate(DateTimeOffset dateTime);
    private static bool HasMilliSeconds(DateTimeOffset dateTime);
    private static bool HasMicroSeconds(DateTimeOffset dateTime);
    private static bool HasNanoSeconds(DateTimeOffset dateTime);
}
public class FluentAssertions.Formatting.DecimalValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.DefaultValueFormatter : object {
    protected int SpacesPerIndentionLevel { get; }
    protected virtual int get_SpacesPerIndentionLevel();
    public virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
    protected virtual MemberInfo[] GetMembers(Type type);
    private static bool HasCompilerGeneratedToStringImplementation(object value);
    private static bool HasDefaultToStringImplementation(object value);
    private void WriteTypeAndMemberValues(object obj, FormattedObjectGraph formattedGraph, FormatChild formatChild);
    private void WriteTypeName(FormattedObjectGraph formattedGraph, Type type);
    private void WriteTypeValue(object obj, FormattedObjectGraph formattedGraph, FormatChild formatChild, Type type);
    private static void WriteMemberValues(object obj, MemberInfo[] members, FormattedObjectGraph formattedGraph, FormatChild formatChild);
    protected virtual string TypeDisplayName(Type type);
    private static void WriteMemberValueTextFor(object value, MemberInfo member, FormattedObjectGraph formattedGraph, FormatChild formatChild);
}
public class FluentAssertions.Formatting.DictionaryValueFormatter : object {
    protected int MaxItems { get; }
    protected virtual int get_MaxItems();
    public virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
    private static void AddLineOrFragment(FormattedObjectGraph formattedGraph, int startCount, string fragment);
    [IteratorStateMachineAttribute("FluentAssertions.Formatting.DictionaryValueFormatter/<AsEnumerable>d__5")]
private static IEnumerable`1<KeyValuePair`2<object, object>> AsEnumerable(IDictionary dictionary);
}
public class FluentAssertions.Formatting.DoubleValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
    private static string Format(object value);
}
[ExtensionAttribute]
internal static class FluentAssertions.Formatting.EnumerableExtensions : object {
    [ExtensionAttribute]
internal static string JoinUsingWritingStyle(IEnumerable`1<T> items);
}
public class FluentAssertions.Formatting.EnumerableValueFormatter : object {
    protected int MaxItems { get; }
    protected virtual int get_MaxItems();
    public virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.EnumValueFormatter : object {
    public virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.ExceptionValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.ExpressionValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.FormatChild : MulticastDelegate {
    public FormatChild(object object, IntPtr method);
    public virtual void Invoke(string childPath, object value, FormattedObjectGraph formattedGraph);
    public virtual IAsyncResult BeginInvoke(string childPath, object value, FormattedObjectGraph formattedGraph, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class FluentAssertions.Formatting.FormattedObjectGraph : object {
    private int maxLines;
    private List`1<string> lines;
    private StringBuilder lineBuilder;
    private int indentation;
    private string lineBuilderWhitespace;
    public static int SpacesPerIndentation { get; }
    public int LineCount { get; }
    private string Whitespace { get; }
    public FormattedObjectGraph(int maxLines);
    public static int get_SpacesPerIndentation();
    public int get_LineCount();
    public void AddFragmentOnNewLine(string fragment);
    public void AddLine(string line);
    public void AddFragment(string fragment);
    internal void EnsureInitialNewLine();
    private void InsertInitialNewLine();
    private void FlushCurrentLine();
    private void AppendSafely(string line);
    public IDisposable WithIndentation();
    public virtual string ToString();
    internal PossibleMultilineFragment KeepOnSingleLineAsLongAsPossible();
    private string get_Whitespace();
    private static string MakeWhitespace(int indent);
    [CompilerGeneratedAttribute]
private void <WithIndentation>b__17_0();
}
public static class FluentAssertions.Formatting.Formatter : object {
    private static List`1<IValueFormatter> CustomFormatters;
    private static List`1<IValueFormatter> DefaultFormatters;
    [ThreadStaticAttribute]
private static bool isReentry;
    public static IEnumerable`1<IValueFormatter> Formatters { get; }
    private static Formatter();
    public static IEnumerable`1<IValueFormatter> get_Formatters();
    public static string ToString(object value, FormattingOptions options);
    private static void FormatChild(string path, object value, FormattedObjectGraph output, FormattingContext context, FormattingOptions options, ObjectGraph graph);
    private static void Format(object value, FormattedObjectGraph output, FormattingContext context, FormatChild formatChild);
    public static void RemoveFormatter(IValueFormatter formatter);
    public static void AddFormatter(IValueFormatter formatter);
}
public class FluentAssertions.Formatting.FormattingContext : object {
    [CompilerGeneratedAttribute]
private bool <UseLineBreaks>k__BackingField;
    public bool UseLineBreaks { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UseLineBreaks();
    [CompilerGeneratedAttribute]
public void set_UseLineBreaks(bool value);
}
public class FluentAssertions.Formatting.FormattingOptions : object {
    [CompilerGeneratedAttribute]
private bool <UseLineBreaks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLines>k__BackingField;
    public bool UseLineBreaks { get; public set; }
    public int MaxDepth { get; public set; }
    public int MaxLines { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UseLineBreaks();
    [CompilerGeneratedAttribute]
public void set_UseLineBreaks(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxDepth();
    [CompilerGeneratedAttribute]
public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
public int get_MaxLines();
    [CompilerGeneratedAttribute]
public void set_MaxLines(int value);
    internal FormattingOptions Clone();
}
public class FluentAssertions.Formatting.GuidValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.Int16ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.Int32ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.Int64ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public interface FluentAssertions.Formatting.IValueFormatter {
    public abstract virtual bool CanHandle(object value);
    public abstract virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.MaxLinesExceededException : Exception {
    public MaxLinesExceededException(string message, Exception innerException);
    public MaxLinesExceededException(string message);
}
public class FluentAssertions.Formatting.MultidimensionalArrayFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
    private static bool IsFirstIteration(Array arr, int index, int dimension);
    private static bool IsInnerMostLoop(Array arr, int index);
    private static bool IsLastIteration(Array arr, int index, int dimension);
}
public class FluentAssertions.Formatting.NullValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.PredicateLambdaExpressionValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
    private static Expression ReduceConstantSubExpressions(Expression expression);
    private static List`1<Expression> ExtractChainOfExpressionsJoinedWithAndOperator(BinaryExpression binaryExpression);
}
public class FluentAssertions.Formatting.PropertyInfoFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.SByteValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.SingleValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.StringValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.TaskFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.TimeSpanValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
    private static List`1<string> GetNonZeroFragments(TimeSpan timeSpan);
    private static void AddMicrosecondsIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static void AddSecondsIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static void AddMilliSecondsIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static void AddMinutesIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static void AddHoursIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
    private static void AddDaysIfNotZero(TimeSpan timeSpan, List`1<string> fragments);
}
public class FluentAssertions.Formatting.UInt16ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.UInt32ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.UInt64ValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
[AttributeUsageAttribute("64")]
public class FluentAssertions.Formatting.ValueFormatterAttribute : Attribute {
}
public class FluentAssertions.Formatting.XAttributeValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.XDocumentValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public class FluentAssertions.Formatting.XElementValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
    private static string FormatElementWithoutChildren(XElement element);
    private static string FormatElementWithChildren(XElement element);
    private static String[] SplitIntoSeparateLines(XElement element);
}
public class FluentAssertions.Formatting.XmlReaderValueFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
public static class FluentAssertions.LessThan : object {
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
public static class FluentAssertions.MoreThan : object {
    public static OccurrenceConstraint Once();
    public static OccurrenceConstraint Twice();
    public static OccurrenceConstraint Thrice();
    public static OccurrenceConstraint Times(int expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.ByteAssertions : NumericAssertions`1<byte> {
    internal ByteAssertions(byte value);
    private protected virtual string CalculateDifferenceForFailureMessage(byte subject, byte expected);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Numeric.ComparableTypeAssertions`1 : ComparableTypeAssertions`2<T, ComparableTypeAssertions`1<T>> {
    public ComparableTypeAssertions`1(IComparable`1<T> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Numeric.ComparableTypeAssertions`2 : ReferenceTypeAssertions`2<IComparable`1<T>, TAssertions> {
    private static int Equal;
    protected string Identifier { get; }
    public ComparableTypeAssertions`2(IComparable`1<T> value);
    public AndConstraint`1<TAssertions> Be(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(TExpectation expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeRankedEquallyTo(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeRankedEquallyTo(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeLessThan(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeLessThanOrEqualTo(T expected, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> BeLessOrEqualTo(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeGreaterThan(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeGreaterThanOrEqualTo(T expected, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> BeGreaterOrEqualTo(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeInRange(T minimumValue, T maximumValue, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(T[] validValues);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<T> validValues, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
    [CompilerGeneratedAttribute]
private bool <BeOneOf>b__17_0(T val);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.DecimalAssertions : NumericAssertions`1<decimal> {
    internal DecimalAssertions(decimal value);
    private protected virtual string CalculateDifferenceForFailureMessage(decimal subject, decimal expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.DoubleAssertions : NumericAssertions`1<double> {
    internal DoubleAssertions(double value);
    private protected virtual bool IsNaN(double value);
    private protected virtual string CalculateDifferenceForFailureMessage(double subject, double expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.Int16Assertions : NumericAssertions`1<short> {
    internal Int16Assertions(short value);
    private protected virtual string CalculateDifferenceForFailureMessage(short subject, short expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.Int32Assertions : NumericAssertions`1<int> {
    internal Int32Assertions(int value);
    private protected virtual string CalculateDifferenceForFailureMessage(int subject, int expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.Int64Assertions : NumericAssertions`1<long> {
    internal Int64Assertions(long value);
    private protected virtual string CalculateDifferenceForFailureMessage(long subject, long expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableByteAssertions : NullableNumericAssertions`1<byte> {
    internal NullableByteAssertions(Nullable`1<byte> value);
    private protected virtual string CalculateDifferenceForFailureMessage(byte subject, byte expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableDecimalAssertions : NullableNumericAssertions`1<decimal> {
    internal NullableDecimalAssertions(Nullable`1<decimal> value);
    private protected virtual string CalculateDifferenceForFailureMessage(decimal subject, decimal expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableDoubleAssertions : NullableNumericAssertions`1<double> {
    internal NullableDoubleAssertions(Nullable`1<double> value);
    private protected virtual bool IsNaN(double value);
    private protected virtual string CalculateDifferenceForFailureMessage(double subject, double expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableInt16Assertions : NullableNumericAssertions`1<short> {
    internal NullableInt16Assertions(Nullable`1<short> value);
    private protected virtual string CalculateDifferenceForFailureMessage(short subject, short expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableInt32Assertions : NullableNumericAssertions`1<int> {
    internal NullableInt32Assertions(Nullable`1<int> value);
    private protected virtual string CalculateDifferenceForFailureMessage(int subject, int expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableInt64Assertions : NullableNumericAssertions`1<long> {
    internal NullableInt64Assertions(Nullable`1<long> value);
    private protected virtual string CalculateDifferenceForFailureMessage(long subject, long expected);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Numeric.NullableNumericAssertions`1 : NullableNumericAssertions`2<T, NullableNumericAssertions`1<T>> {
    public NullableNumericAssertions`1(Nullable`1<T> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Numeric.NullableNumericAssertions`2 : NumericAssertions`2<T, TAssertions> {
    public NullableNumericAssertions`2(Nullable`1<T> value);
    public AndConstraint`1<TAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Match(Expression`1<Func`2<Nullable`1<T>, bool>> predicate, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableSByteAssertions : NullableNumericAssertions`1<sbyte> {
    internal NullableSByteAssertions(Nullable`1<sbyte> value);
    private protected virtual string CalculateDifferenceForFailureMessage(sbyte subject, sbyte expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableSingleAssertions : NullableNumericAssertions`1<float> {
    internal NullableSingleAssertions(Nullable`1<float> value);
    private protected virtual bool IsNaN(float value);
    private protected virtual string CalculateDifferenceForFailureMessage(float subject, float expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableUInt16Assertions : NullableNumericAssertions`1<ushort> {
    internal NullableUInt16Assertions(Nullable`1<ushort> value);
    private protected virtual string CalculateDifferenceForFailureMessage(ushort subject, ushort expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableUInt32Assertions : NullableNumericAssertions`1<UInt32> {
    internal NullableUInt32Assertions(Nullable`1<UInt32> value);
    private protected virtual string CalculateDifferenceForFailureMessage(UInt32 subject, UInt32 expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.NullableUInt64Assertions : NullableNumericAssertions`1<ulong> {
    internal NullableUInt64Assertions(Nullable`1<ulong> value);
    private protected virtual string CalculateDifferenceForFailureMessage(ulong subject, ulong expected);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Numeric.NumericAssertions`1 : NumericAssertions`2<T, NumericAssertions`1<T>> {
    public NumericAssertions`1(T value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Numeric.NumericAssertions`2 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<T> <Subject>k__BackingField;
    public Nullable`1<T> Subject { get; }
    public NumericAssertions`2(T value);
    private protected NumericAssertions`2(Nullable`1<T> value);
    [CompilerGeneratedAttribute]
public Nullable`1<T> get_Subject();
    public AndConstraint`1<TAssertions> Be(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(Nullable`1<T> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(Nullable`1<T> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BePositive(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNegative(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeLessThan(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeLessThanOrEqualTo(T expected, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> BeLessOrEqualTo(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeGreaterThan(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeGreaterThanOrEqualTo(T expected, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> BeGreaterOrEqualTo(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeInRange(T minimumValue, T maximumValue, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeInRange(T minimumValue, T maximumValue, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(T[] validValues);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<T> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOfType(Type expectedType, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeOfType(Type unexpectedType, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Match(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    public virtual bool Equals(object obj);
    private protected virtual bool IsNaN(T value);
    private protected virtual string CalculateDifferenceForFailureMessage(T subject, T expected);
    private string GenerateDifferenceMessage(Nullable`1<T> expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.SByteAssertions : NumericAssertions`1<sbyte> {
    internal SByteAssertions(sbyte value);
    private protected virtual string CalculateDifferenceForFailureMessage(sbyte subject, sbyte expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.SingleAssertions : NumericAssertions`1<float> {
    internal SingleAssertions(float value);
    private protected virtual bool IsNaN(float value);
    private protected virtual string CalculateDifferenceForFailureMessage(float subject, float expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.UInt16Assertions : NumericAssertions`1<ushort> {
    internal UInt16Assertions(ushort value);
    private protected virtual string CalculateDifferenceForFailureMessage(ushort subject, ushort expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.UInt32Assertions : NumericAssertions`1<UInt32> {
    internal UInt32Assertions(UInt32 value);
    private protected virtual string CalculateDifferenceForFailureMessage(UInt32 subject, UInt32 expected);
}
[DebuggerNonUserCodeAttribute]
internal class FluentAssertions.Numeric.UInt64Assertions : NumericAssertions`1<ulong> {
    internal UInt64Assertions(ulong value);
    private protected virtual string CalculateDifferenceForFailureMessage(ulong subject, ulong expected);
}
[ExtensionAttribute]
public static class FluentAssertions.NumericAssertionsExtensions : object {
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<sbyte>> BeCloseTo(NumericAssertions`1<sbyte> parent, sbyte nearbyValue, byte delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<byte>> BeCloseTo(NumericAssertions`1<byte> parent, byte nearbyValue, byte delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<short>> BeCloseTo(NumericAssertions`1<short> parent, short nearbyValue, ushort delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<ushort>> BeCloseTo(NumericAssertions`1<ushort> parent, ushort nearbyValue, ushort delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<int>> BeCloseTo(NumericAssertions`1<int> parent, int nearbyValue, UInt32 delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<UInt32>> BeCloseTo(NumericAssertions`1<UInt32> parent, UInt32 nearbyValue, UInt32 delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<long>> BeCloseTo(NumericAssertions`1<long> parent, long nearbyValue, ulong delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<ulong>> BeCloseTo(NumericAssertions`1<ulong> parent, ulong nearbyValue, ulong delta, string because, Object[] becauseArgs);
    private static void FailIfValueOutsideBounds(bool valueWithinBounds, TValue nearbyValue, TDelta delta, TValue actualValue, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<sbyte>> NotBeCloseTo(NumericAssertions`1<sbyte> parent, sbyte distantValue, byte delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<byte>> NotBeCloseTo(NumericAssertions`1<byte> parent, byte distantValue, byte delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<short>> NotBeCloseTo(NumericAssertions`1<short> parent, short distantValue, ushort delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<ushort>> NotBeCloseTo(NumericAssertions`1<ushort> parent, ushort distantValue, ushort delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<int>> NotBeCloseTo(NumericAssertions`1<int> parent, int distantValue, UInt32 delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<UInt32>> NotBeCloseTo(NumericAssertions`1<UInt32> parent, UInt32 distantValue, UInt32 delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<long>> NotBeCloseTo(NumericAssertions`1<long> parent, long distantValue, ulong delta, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<ulong>> NotBeCloseTo(NumericAssertions`1<ulong> parent, ulong distantValue, ulong delta, string because, Object[] becauseArgs);
    private static void FailIfValueInsideBounds(bool valueOutsideBounds, TValue distantValue, TDelta delta, TValue actualValue, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<float>> BeApproximately(NullableNumericAssertions`1<float> parent, float expectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<float>> BeApproximately(NullableNumericAssertions`1<float> parent, Nullable`1<float> expectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<float>> BeApproximately(NumericAssertions`1<float> parent, float expectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<double>> BeApproximately(NullableNumericAssertions`1<double> parent, double expectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<double>> BeApproximately(NullableNumericAssertions`1<double> parent, Nullable`1<double> expectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<double>> BeApproximately(NumericAssertions`1<double> parent, double expectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<decimal>> BeApproximately(NullableNumericAssertions`1<decimal> parent, decimal expectedValue, decimal precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<decimal>> BeApproximately(NullableNumericAssertions`1<decimal> parent, Nullable`1<decimal> expectedValue, decimal precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<decimal>> BeApproximately(NumericAssertions`1<decimal> parent, decimal expectedValue, decimal precision, string because, Object[] becauseArgs);
    private static void FailIfDifferenceOutsidePrecision(bool differenceWithinPrecision, NumericAssertions`1<T> parent, T expectedValue, T precision, T actualDifference, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<float>> NotBeApproximately(NullableNumericAssertions`1<float> parent, float unexpectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<float>> NotBeApproximately(NullableNumericAssertions`1<float> parent, Nullable`1<float> unexpectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<float>> NotBeApproximately(NumericAssertions`1<float> parent, float unexpectedValue, float precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<double>> NotBeApproximately(NullableNumericAssertions`1<double> parent, double unexpectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<double>> NotBeApproximately(NullableNumericAssertions`1<double> parent, Nullable`1<double> unexpectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<double>> NotBeApproximately(NumericAssertions`1<double> parent, double unexpectedValue, double precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<decimal>> NotBeApproximately(NullableNumericAssertions`1<decimal> parent, decimal unexpectedValue, decimal precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NullableNumericAssertions`1<decimal>> NotBeApproximately(NullableNumericAssertions`1<decimal> parent, Nullable`1<decimal> unexpectedValue, decimal precision, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<NumericAssertions`1<decimal>> NotBeApproximately(NumericAssertions`1<decimal> parent, decimal unexpectedValue, decimal precision, string because, Object[] becauseArgs);
    private static void FailIfDifferenceWithinPrecision(NumericAssertions`1<T> parent, bool differenceOutsidePrecision, T unexpectedValue, T precision, T actualDifference, string because, Object[] becauseArgs);
    private static long GetMinValue(long value, ulong delta);
    private static long GetMaxValue(long value, ulong delta);
}
[ExtensionAttribute]
public static class FluentAssertions.ObjectAssertionsExtensions : object {
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeBinarySerializable(ObjectAssertions assertions, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeBinarySerializable(ObjectAssertions assertions, Func`2<EquivalencyAssertionOptions`1<T>, EquivalencyAssertionOptions`1<T>> options, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeDataContractSerializable(ObjectAssertions assertions, string because, Object[] becauseArgs);
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeDataContractSerializable(ObjectAssertions assertions, Func`2<EquivalencyAssertionOptions`1<T>, EquivalencyAssertionOptions`1<T>> options, string because, Object[] becauseArgs);
    private static object CreateCloneUsingBinarySerializer(object subject);
    private static object CreateCloneUsingDataContractSerializer(object subject);
    [ExtensionAttribute]
public static AndConstraint`1<ObjectAssertions> BeXmlSerializable(ObjectAssertions assertions, string because, Object[] becauseArgs);
    private static object CreateCloneUsingXmlSerializer(object subject);
}
public abstract class FluentAssertions.OccurrenceConstraint : object {
    [CompilerGeneratedAttribute]
private int <ExpectedCount>k__BackingField;
    internal int ExpectedCount { get; }
    internal string Mode { get; }
    protected OccurrenceConstraint(int expectedCount);
    [CompilerGeneratedAttribute]
internal int get_ExpectedCount();
    internal abstract virtual string get_Mode();
    internal abstract virtual bool Assert(int actual);
    internal void RegisterReportables(AssertionScope scope);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.BooleanAssertions : BooleanAssertions`1<BooleanAssertions> {
    public BooleanAssertions(Nullable`1<bool> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.BooleanAssertions`1 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Subject>k__BackingField;
    public Nullable`1<bool> Subject { get; }
    public BooleanAssertions`1(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Subject();
    public AndConstraint`1<TAssertions> BeFalse(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeTrue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(bool expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(bool unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Imply(bool consequent, string because, Object[] becauseArgs);
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeAssertions : DateTimeAssertions`1<DateTimeAssertions> {
    public DateTimeAssertions(Nullable`1<DateTime> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeAssertions`1 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Subject>k__BackingField;
    public Nullable`1<DateTime> Subject { get; }
    public DateTimeAssertions`1(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Subject();
    public AndConstraint`1<TAssertions> Be(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(Nullable`1<DateTime> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(Nullable`1<DateTime> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeCloseTo(DateTime nearbyTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeCloseTo(DateTime distantTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeBefore(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeBefore(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOnOrBefore(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeOnOrBefore(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeAfter(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeAfter(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOnOrAfter(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeOnOrAfter(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveYear(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveYear(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveMonth(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveMonth(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveDay(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveDay(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveHour(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveHour(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveMinute(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveMinute(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveSecond(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveSecond(int unexpected, string because, Object[] becauseArgs);
    public DateTimeRangeAssertions`1<TAssertions> BeMoreThan(TimeSpan timeSpan);
    public DateTimeRangeAssertions`1<TAssertions> BeAtLeast(TimeSpan timeSpan);
    public DateTimeRangeAssertions`1<TAssertions> BeExactly(TimeSpan timeSpan);
    public DateTimeRangeAssertions`1<TAssertions> BeWithin(TimeSpan timeSpan);
    public DateTimeRangeAssertions`1<TAssertions> BeLessThan(TimeSpan timeSpan);
    public AndConstraint`1<TAssertions> BeSameDateAs(DateTime expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeSameDateAs(DateTime unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(Nullable`1[] validValues);
    public AndConstraint`1<TAssertions> BeOneOf(DateTime[] validValues);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<DateTime> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<Nullable`1<DateTime>> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeIn(DateTimeKind expectedKind, string because, Object[] becauseArgs);
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeOffsetAssertions : DateTimeOffsetAssertions`1<DateTimeOffsetAssertions> {
    public DateTimeOffsetAssertions(Nullable`1<DateTimeOffset> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeOffsetAssertions`1 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Subject>k__BackingField;
    public Nullable`1<DateTimeOffset> Subject { get; }
    public DateTimeOffsetAssertions`1(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Subject();
    public AndConstraint`1<TAssertions> Be(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(Nullable`1<DateTimeOffset> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(Nullable`1<DateTimeOffset> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeExactly(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeExactly(Nullable`1<DateTimeOffset> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeExactly(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeExactly(Nullable`1<DateTimeOffset> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeCloseTo(DateTimeOffset nearbyTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeCloseTo(DateTimeOffset distantTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeBefore(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeBefore(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOnOrBefore(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeOnOrBefore(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeAfter(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeAfter(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOnOrAfter(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeOnOrAfter(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveYear(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveYear(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveMonth(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveMonth(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveDay(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveDay(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveHour(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveHour(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveMinute(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveMinute(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveSecond(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveSecond(int unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveOffset(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveOffset(TimeSpan unexpected, string because, Object[] becauseArgs);
    public DateTimeOffsetRangeAssertions`1<TAssertions> BeMoreThan(TimeSpan timeSpan);
    public DateTimeOffsetRangeAssertions`1<TAssertions> BeAtLeast(TimeSpan timeSpan);
    public DateTimeOffsetRangeAssertions`1<TAssertions> BeExactly(TimeSpan timeSpan);
    public DateTimeOffsetRangeAssertions`1<TAssertions> BeWithin(TimeSpan timeSpan);
    public DateTimeOffsetRangeAssertions`1<TAssertions> BeLessThan(TimeSpan timeSpan);
    public AndConstraint`1<TAssertions> BeSameDateAs(DateTimeOffset expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeSameDateAs(DateTimeOffset unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(Nullable`1[] validValues);
    public AndConstraint`1<TAssertions> BeOneOf(DateTimeOffset[] validValues);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<DateTimeOffset> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<Nullable`1<DateTimeOffset>> validValues, string because, Object[] becauseArgs);
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeOffsetRangeAssertions`1 : object {
    private TAssertions parentAssertions;
    private TimeSpanPredicate predicate;
    private Dictionary`2<TimeSpanCondition, TimeSpanPredicate> predicates;
    private Nullable`1<DateTimeOffset> subject;
    private TimeSpan timeSpan;
    protected internal DateTimeOffsetRangeAssertions`1(TAssertions parentAssertions, Nullable`1<DateTimeOffset> subject, TimeSpanCondition condition, TimeSpan timeSpan);
    public AndConstraint`1<TAssertions> Before(DateTimeOffset target, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> After(DateTimeOffset target, string because, Object[] becauseArgs);
    private static string PositionRelativeToTarget(DateTimeOffset actual, DateTimeOffset target);
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.DateTimeRangeAssertions`1 : object {
    private TAssertions parentAssertions;
    private TimeSpanPredicate predicate;
    private Dictionary`2<TimeSpanCondition, TimeSpanPredicate> predicates;
    private Nullable`1<DateTime> subject;
    private TimeSpan timeSpan;
    protected internal DateTimeRangeAssertions`1(TAssertions parentAssertions, Nullable`1<DateTime> subject, TimeSpanCondition condition, TimeSpan timeSpan);
    public AndConstraint`1<TAssertions> Before(DateTime target, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> After(DateTime target, string because, Object[] becauseArgs);
    private static string PositionRelativeToTarget(DateTime actual, DateTime target);
    public virtual bool Equals(object obj);
}
public class FluentAssertions.Primitives.EnumAssertions`1 : EnumAssertions`2<TEnum, EnumAssertions`1<TEnum>> {
    public EnumAssertions`1(TEnum subject);
}
public class FluentAssertions.Primitives.EnumAssertions`2 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TEnum> <Subject>k__BackingField;
    public Nullable`1<TEnum> Subject { get; }
    public EnumAssertions`2(TEnum subject);
    private protected EnumAssertions`2(Nullable`1<TEnum> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TEnum> get_Subject();
    public AndConstraint`1<TAssertions> Be(TEnum expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(Nullable`1<TEnum> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(TEnum unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(Nullable`1<TEnum> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeDefined(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeDefined(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveValue(decimal expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveValue(decimal unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveSameValueAs(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveSameValueAs(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveSameNameAs(T expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveSameNameAs(T unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveFlag(TEnum expectedFlag, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveFlag(TEnum unexpectedFlag, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Match(Expression`1<Func`2<Nullable`1<TEnum>, bool>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(TEnum[] validValues);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<TEnum> validValues, string because, Object[] becauseArgs);
    private static decimal GetValue(T enum);
    private static string GetName(T enum);
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.GuidAssertions : GuidAssertions`1<GuidAssertions> {
    public GuidAssertions(Nullable`1<Guid> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.GuidAssertions`1 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <Subject>k__BackingField;
    public Nullable`1<Guid> Subject { get; }
    public GuidAssertions`1(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_Subject();
    public AndConstraint`1<TAssertions> BeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(Guid expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(Guid unexpected, string because, Object[] becauseArgs);
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.HttpResponseMessageAssertions : HttpResponseMessageAssertions`1<HttpResponseMessageAssertions> {
    public HttpResponseMessageAssertions(HttpResponseMessage value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.HttpResponseMessageAssertions`1 : ObjectAssertions`2<HttpResponseMessage, TAssertions> {
    protected string Identifier { get; }
    protected HttpResponseMessageAssertions`1(HttpResponseMessage value);
    public AndConstraint`1<TAssertions> BeSuccessful(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeRedirection(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveError(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveClientError(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveServerError(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveStatusCode(HttpStatusCode expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveStatusCode(HttpStatusCode unexpected, string because, Object[] becauseArgs);
    private bool IsServerError();
    private bool IsClientError();
    protected virtual string get_Identifier();
}
internal class FluentAssertions.Primitives.NegatedStringStartValidator : StringValidator {
    private StringComparison stringComparison;
    protected string ExpectationDescription { get; }
    private bool IgnoreCase { get; }
    public NegatedStringStartValidator(string subject, string expected, StringComparison stringComparison, string because, Object[] becauseArgs);
    protected virtual string get_ExpectationDescription();
    private bool get_IgnoreCase();
    protected virtual void ValidateAgainstMismatch();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableBooleanAssertions : NullableBooleanAssertions`1<NullableBooleanAssertions> {
    public NullableBooleanAssertions(Nullable`1<bool> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableBooleanAssertions`1 : BooleanAssertions`1<TAssertions> {
    public NullableBooleanAssertions`1(Nullable`1<bool> value);
    public AndConstraint`1<TAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(Nullable`1<bool> expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(Nullable`1<bool> unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeFalse(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeTrue(string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableDateTimeAssertions : NullableDateTimeAssertions`1<NullableDateTimeAssertions> {
    public NullableDateTimeAssertions(Nullable`1<DateTime> expected);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableDateTimeAssertions`1 : DateTimeAssertions`1<TAssertions> {
    public NullableDateTimeAssertions`1(Nullable`1<DateTime> expected);
    public AndConstraint`1<TAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNull(string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableDateTimeOffsetAssertions : NullableDateTimeOffsetAssertions`1<NullableDateTimeOffsetAssertions> {
    public NullableDateTimeOffsetAssertions(Nullable`1<DateTimeOffset> expected);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableDateTimeOffsetAssertions`1 : DateTimeOffsetAssertions`1<TAssertions> {
    public NullableDateTimeOffsetAssertions`1(Nullable`1<DateTimeOffset> expected);
    public AndConstraint`1<TAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNull(string because, Object[] becauseArgs);
}
public class FluentAssertions.Primitives.NullableEnumAssertions`1 : NullableEnumAssertions`2<TEnum, NullableEnumAssertions`1<TEnum>> {
    public NullableEnumAssertions`1(Nullable`1<TEnum> subject);
}
public class FluentAssertions.Primitives.NullableEnumAssertions`2 : EnumAssertions`2<TEnum, TAssertions> {
    public NullableEnumAssertions`2(Nullable`1<TEnum> subject);
    public AndWhichConstraint`2<TAssertions, TEnum> HaveValue(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, TEnum> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNull(string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableGuidAssertions : NullableGuidAssertions`1<NullableGuidAssertions> {
    public NullableGuidAssertions(Nullable`1<Guid> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableGuidAssertions`1 : GuidAssertions`1<TAssertions> {
    public NullableGuidAssertions`1(Nullable`1<Guid> value);
    public AndConstraint`1<TAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(Nullable`1<Guid> expected, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions : NullableSimpleTimeSpanAssertions`1<NullableSimpleTimeSpanAssertions> {
    public NullableSimpleTimeSpanAssertions(Nullable`1<TimeSpan> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.NullableSimpleTimeSpanAssertions`1 : SimpleTimeSpanAssertions`1<TAssertions> {
    public NullableSimpleTimeSpanAssertions`1(Nullable`1<TimeSpan> value);
    public AndConstraint`1<TAssertions> HaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveValue(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(Nullable`1<TimeSpan> expected, string because, Object[] becauseArgs);
}
public class FluentAssertions.Primitives.ObjectAssertions : ObjectAssertions`2<object, ObjectAssertions> {
    public ObjectAssertions(object value);
    public AndConstraint`1<ObjectAssertions> Be(TExpectation expected, IEqualityComparer`1<TExpectation> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<ObjectAssertions> NotBe(TExpectation unexpected, IEqualityComparer`1<TExpectation> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<ObjectAssertions> BeOneOf(IEnumerable`1<TExpectation> validValues, IEqualityComparer`1<TExpectation> comparer, string because, Object[] becauseArgs);
}
public class FluentAssertions.Primitives.ObjectAssertions`2 : ReferenceTypeAssertions`2<TSubject, TAssertions> {
    protected string Identifier { get; }
    public ObjectAssertions`2(TSubject value);
    public AndConstraint`1<TAssertions> Be(TSubject expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(TSubject expected, IEqualityComparer`1<TSubject> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(TSubject unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(TSubject unexpected, IEqualityComparer`1<TSubject> comparer, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(TExpectation expectation, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(TExpectation expectation, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEquivalentTo(TExpectation unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEquivalentTo(TExpectation unexpected, Func`2<EquivalencyAssertionOptions`1<TExpectation>, EquivalencyAssertionOptions`1<TExpectation>> config, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(TSubject[] validValues);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<TSubject> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<TSubject> validValues, IEqualityComparer`1<TSubject> comparer, string because, Object[] becauseArgs);
    public virtual bool Equals(object obj);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public abstract class FluentAssertions.Primitives.ReferenceTypeAssertions`2 : object {
    [CompilerGeneratedAttribute]
private TSubject <Subject>k__BackingField;
    public TSubject Subject { get; }
    protected string Identifier { get; }
    protected ReferenceTypeAssertions`2(TSubject subject);
    [CompilerGeneratedAttribute]
public TSubject get_Subject();
    public AndConstraint`1<TAssertions> BeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNull(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeSameAs(TSubject expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeSameAs(TSubject unexpected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> BeOfType(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOfType(Type expectedType, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeOfType(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeOfType(Type unexpectedType, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TAssertions, T> BeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeAssignableTo(Type type, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeAssignableTo(Type type, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Match(Expression`1<Func`2<TSubject, bool>> predicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Match(Expression`1<Func`2<T, bool>> predicate, string because, Object[] becauseArgs);
    protected abstract virtual string get_Identifier();
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.SimpleTimeSpanAssertions : SimpleTimeSpanAssertions`1<SimpleTimeSpanAssertions> {
    public SimpleTimeSpanAssertions(Nullable`1<TimeSpan> value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.SimpleTimeSpanAssertions`1 : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Subject>k__BackingField;
    public Nullable`1<TimeSpan> Subject { get; }
    public SimpleTimeSpanAssertions`1(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Subject();
    public AndConstraint`1<TAssertions> BePositive(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNegative(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Be(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(TimeSpan unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeLessThan(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeLessThanOrEqualTo(TimeSpan expected, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> BeLessOrEqualTo(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeGreaterThan(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeGreaterThanOrEqualTo(TimeSpan expected, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<TAssertions> BeGreaterOrEqualTo(TimeSpan expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeCloseTo(TimeSpan nearbyTime, TimeSpan precision, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeCloseTo(TimeSpan distantTime, TimeSpan precision, string because, Object[] becauseArgs);
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.StringAssertions : StringAssertions`1<StringAssertions> {
    public StringAssertions(string value);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Primitives.StringAssertions`1 : ReferenceTypeAssertions`2<string, TAssertions> {
    protected string Identifier { get; }
    public StringAssertions`1(string value);
    public AndConstraint`1<TAssertions> Be(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeOneOf(String[] validValues);
    public AndConstraint`1<TAssertions> BeOneOf(IEnumerable`1<string> validValues, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeEquivalentTo(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEquivalentTo(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBe(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Match(string wildcardPattern, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotMatch(string wildcardPattern, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> MatchEquivalentOf(string wildcardPattern, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotMatchEquivalentOf(string wildcardPattern, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> MatchRegex(string regularExpression, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> MatchRegex(string regularExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> MatchRegex(Regex regularExpression, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> MatchRegex(Regex regularExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotMatchRegex(string regularExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotMatchRegex(Regex regularExpression, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> StartWith(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotStartWith(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> StartWithEquivalentOf(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotStartWithEquivalentOf(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> EndWith(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotEndWith(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> EndWithEquivalentOf(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotEndWithEquivalentOf(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Contain(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> Contain(string expected, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainEquivalentOf(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainEquivalentOf(string expected, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainAll(IEnumerable`1<string> values, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainAll(String[] values);
    public AndConstraint`1<TAssertions> ContainAny(IEnumerable`1<string> values, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> ContainAny(String[] values);
    public AndConstraint`1<TAssertions> NotContain(string unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainAll(IEnumerable`1<string> values, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainAll(String[] values);
    public AndConstraint`1<TAssertions> NotContainAny(IEnumerable`1<string> values, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotContainAny(String[] values);
    public AndConstraint`1<TAssertions> NotContainEquivalentOf(string unexpected, string because, Object[] becauseArgs);
    private static bool Contains(string actual, string expected, StringComparison comparison);
    public AndConstraint`1<TAssertions> BeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveLength(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNullOrEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNullOrEmpty(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeNullOrWhiteSpace(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeNullOrWhiteSpace(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeUpperCased(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeUpperCased(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeLowerCased(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeLowerCased(string because, Object[] becauseArgs);
    private static void ThrowIfValuesNullOrEmpty(IEnumerable`1<string> values);
    protected virtual string get_Identifier();
    [CompilerGeneratedAttribute]
private bool <ContainAll>b__29_0(string v);
    [CompilerGeneratedAttribute]
private bool <ContainAll>b__29_1(string v);
    [CompilerGeneratedAttribute]
private bool <ContainAny>b__31_0(string v);
    [CompilerGeneratedAttribute]
private bool <NotContainAll>b__34_0(string v);
    [CompilerGeneratedAttribute]
private bool <NotContainAny>b__36_0(string v);
}
internal class FluentAssertions.Primitives.StringEqualityValidator : StringValidator {
    private StringComparison comparisonMode;
    protected string ExpectationDescription { get; }
    private bool IgnoreCase { get; }
    public StringEqualityValidator(string subject, string expected, StringComparison comparisonMode, string because, Object[] becauseArgs);
    protected virtual bool ValidateAgainstSuperfluousWhitespace();
    protected virtual bool ValidateAgainstLengthDifferences();
    private string GetMismatchSegmentForStringsOfDifferentLengths();
    protected virtual void ValidateAgainstMismatch();
    protected virtual string get_ExpectationDescription();
    private bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
private FailReason <ValidateAgainstLengthDifferences>b__3_0();
}
internal class FluentAssertions.Primitives.StringStartValidator : StringValidator {
    private StringComparison stringComparison;
    protected string ExpectationDescription { get; }
    private bool IgnoreCase { get; }
    public StringStartValidator(string subject, string expected, StringComparison stringComparison, string because, Object[] becauseArgs);
    protected virtual string get_ExpectationDescription();
    private bool get_IgnoreCase();
    protected virtual bool ValidateAgainstLengthDifferences();
    protected virtual void ValidateAgainstMismatch();
}
internal abstract class FluentAssertions.Primitives.StringValidator : object {
    private static int HumanReadableLength;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Expected>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssertionScope <Assertion>k__BackingField;
    protected string Subject { get; }
    protected string Expected { get; }
    protected IAssertionScope Assertion { get; protected set; }
    protected string ExpectationDescription { get; }
    protected StringValidator(string subject, string expected, string because, Object[] becauseArgs);
    [CompilerGeneratedAttribute]
protected string get_Subject();
    [CompilerGeneratedAttribute]
protected string get_Expected();
    [CompilerGeneratedAttribute]
protected IAssertionScope get_Assertion();
    [CompilerGeneratedAttribute]
protected void set_Assertion(IAssertionScope value);
    public void Validate();
    private bool ValidateAgainstNulls();
    private static bool IsLongOrMultiline(string value);
    protected virtual bool ValidateAgainstSuperfluousWhitespace();
    protected virtual bool ValidateAgainstLengthDifferences();
    protected abstract virtual void ValidateAgainstMismatch();
    protected abstract virtual string get_ExpectationDescription();
}
internal class FluentAssertions.Primitives.StringWildcardMatchingValidator : StringValidator {
    [CompilerGeneratedAttribute]
private bool <Negate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNewLineDifferences>k__BackingField;
    protected string ExpectationDescription { get; }
    public bool Negate { get; public set; }
    public bool IgnoreCase { get; public set; }
    public bool IgnoreNewLineDifferences { get; public set; }
    public StringWildcardMatchingValidator(string subject, string expected, string because, Object[] becauseArgs);
    protected virtual void ValidateAgainstMismatch();
    private bool IsMatch();
    private static string ConvertWildcardToRegEx(string wildcardExpression);
    private string CleanNewLines(string input);
    protected virtual string get_ExpectationDescription();
    [CompilerGeneratedAttribute]
public bool get_Negate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Negate(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreNewLineDifferences();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IgnoreNewLineDifferences(bool value);
}
public enum FluentAssertions.Primitives.TimeSpanCondition : Enum {
    public int value__;
    public static TimeSpanCondition MoreThan;
    public static TimeSpanCondition AtLeast;
    public static TimeSpanCondition Exactly;
    public static TimeSpanCondition Within;
    public static TimeSpanCondition LessThan;
}
internal class FluentAssertions.Primitives.TimeSpanPredicate : object {
    private Func`3<TimeSpan, TimeSpan, bool> lambda;
    [CompilerGeneratedAttribute]
private string <DisplayText>k__BackingField;
    public string DisplayText { get; }
    public TimeSpanPredicate(Func`3<TimeSpan, TimeSpan, bool> lambda, string displayText);
    [CompilerGeneratedAttribute]
public string get_DisplayText();
    public bool IsMatchedBy(TimeSpan actual, TimeSpan expected);
}
public class FluentAssertions.Reflection.AssemblyAssertions : ReferenceTypeAssertions`2<Assembly, AssemblyAssertions> {
    protected string Identifier { get; }
    public AssemblyAssertions(Assembly assembly);
    public AndConstraint`1<AssemblyAssertions> NotReference(Assembly assembly, string because, Object[] becauseArgs);
    public AndConstraint`1<AssemblyAssertions> Reference(Assembly assembly, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<AssemblyAssertions, Type> DefineType(string namespace, string name, string because, Object[] becauseArgs);
    public AndConstraint`1<AssemblyAssertions> BeUnsigned(string because, Object[] becauseArgs);
    public AndConstraint`1<AssemblyAssertions> BeSignedWithPublicKey(string publicKey, string because, Object[] becauseArgs);
    private static string ToHexString(Byte[] bytes);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Specialized.ActionAssertions : DelegateAssertions`2<Action, ActionAssertions> {
    protected string Identifier { get; }
    public ActionAssertions(Action subject, IExtractExceptions extractor);
    public ActionAssertions(Action subject, IExtractExceptions extractor, IClock clock);
    protected virtual void InvokeSubject();
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Specialized.AsyncFunctionAssertions`2 : DelegateAssertionsBase`2<Func`1<TTask>, TAssertions> {
    protected string Identifier { get; }
    [ObsoleteAttribute("This class is intended as base class. This ctor is accidentally public and will be removed in Version 7.")]
public AsyncFunctionAssertions`2(Func`1<TTask> subject, IExtractExceptions extractor);
    [ObsoleteAttribute("This class is intended as base class. This ctor is accidentally public and will be made protected in Version 7.")]
public AsyncFunctionAssertions`2(Func`1<TTask> subject, IExtractExceptions extractor, IClock clock);
    protected virtual string get_Identifier();
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<CompleteWithinAsync>d__4")]
public Task`1<AndConstraint`1<TAssertions>> CompleteWithinAsync(TimeSpan timeSpan, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<NotCompleteWithinAsync>d__5")]
public Task`1<AndConstraint`1<TAssertions>> NotCompleteWithinAsync(TimeSpan timeSpan, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<ThrowExactlyAsync>d__6`1")]
public Task`1<ExceptionAssertions`1<TException>> ThrowExactlyAsync(string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<ThrowAsync>d__7`1")]
public Task`1<ExceptionAssertions`1<TException>> ThrowAsync(string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<ThrowWithinAsync>d__8`1")]
public Task`1<ExceptionAssertions`1<TException>> ThrowWithinAsync(TimeSpan timeSpan, string because, Object[] becauseArgs);
    private ExceptionAssertions`1<TException> AssertThrows(Exception exception, TimeSpan timeSpan, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<InvokeWithInterceptionAsync>d__10")]
private Task`1<Exception> InvokeWithInterceptionAsync(TimeSpan timeout);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<NotThrowAsync>d__11")]
public Task`1<AndConstraint`1<TAssertions>> NotThrowAsync(string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<NotThrowAsync>d__12`1")]
public Task`1<AndConstraint`1<TAssertions>> NotThrowAsync(string because, Object[] becauseArgs);
    public Task`1<AndConstraint`1<TAssertions>> NotThrowAfterAsync(TimeSpan waitTime, TimeSpan pollInterval, string because, Object[] becauseArgs);
    private protected ValueTuple`2<TTask, TimeSpan> InvokeWithTimer(TimeSpan timeSpan);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<CompletesWithinTimeoutAsync>d__15")]
private protected Task`1<bool> CompletesWithinTimeoutAsync(Task target, TimeSpan remainingTime);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.AsyncFunctionAssertions`2/<InvokeWithInterceptionAsync>d__16")]
private static Task`1<Exception> InvokeWithInterceptionAsync(Func`1<Task> action);
}
[DebuggerNonUserCodeAttribute]
public abstract class FluentAssertions.Specialized.DelegateAssertions`2 : DelegateAssertionsBase`2<TDelegate, TAssertions> {
    protected DelegateAssertions`2(TDelegate delegate, IExtractExceptions extractor);
    private protected DelegateAssertions`2(TDelegate delegate, IExtractExceptions extractor, IClock clock);
    public ExceptionAssertions`1<TException> Throw(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotThrow(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotThrow(string because, Object[] becauseArgs);
    public ExceptionAssertions`1<TException> ThrowExactly(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotThrowAfter(TimeSpan waitTime, TimeSpan pollInterval, string because, Object[] becauseArgs);
    protected abstract virtual void InvokeSubject();
    private Exception InvokeSubjectWithInterception();
    private void FailIfSubjectIsAsyncVoid();
}
[DebuggerNonUserCodeAttribute]
public abstract class FluentAssertions.Specialized.DelegateAssertionsBase`2 : ReferenceTypeAssertions`2<TDelegate, DelegateAssertionsBase`2<TDelegate, TAssertions>> {
    [CompilerGeneratedAttribute]
private IExtractExceptions <Extractor>k__BackingField;
    [CompilerGeneratedAttribute]
private IClock <Clock>k__BackingField;
    private protected IExtractExceptions Extractor { get; }
    private protected IClock Clock { get; }
    private protected DelegateAssertionsBase`2(TDelegate delegate, IExtractExceptions extractor, IClock clock);
    [CompilerGeneratedAttribute]
private protected IExtractExceptions get_Extractor();
    [CompilerGeneratedAttribute]
private protected IClock get_Clock();
    protected ExceptionAssertions`1<TException> ThrowInternal(Exception exception, string because, Object[] becauseArgs);
    protected AndConstraint`1<TAssertions> NotThrowInternal(Exception exception, string because, Object[] becauseArgs);
    protected AndConstraint`1<TAssertions> NotThrowInternal(Exception exception, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Specialized.ExceptionAssertions`1 : ReferenceTypeAssertions`2<IEnumerable`1<TException>, ExceptionAssertions`1<TException>> {
    public TException And { get; }
    public TException Which { get; }
    protected string Identifier { get; }
    private TException SingleSubject { get; }
    public ExceptionAssertions`1(IEnumerable`1<TException> exceptions);
    public TException get_And();
    public TException get_Which();
    protected virtual string get_Identifier();
    public virtual ExceptionAssertions`1<TException> WithMessage(string expectedWildcardPattern, string because, Object[] becauseArgs);
    public virtual ExceptionAssertions`1<TInnerException> WithInnerException(string because, Object[] becauseArgs);
    public ExceptionAssertions`1<Exception> WithInnerException(Type innerException, string because, Object[] becauseArgs);
    public virtual ExceptionAssertions`1<TInnerException> WithInnerExceptionExactly(string because, Object[] becauseArgs);
    public ExceptionAssertions`1<Exception> WithInnerExceptionExactly(Type innerException, string because, Object[] becauseArgs);
    public ExceptionAssertions`1<TException> Where(Expression`1<Func`2<TException, bool>> exceptionExpression, string because, Object[] becauseArgs);
    private IEnumerable`1<Exception> AssertInnerExceptionExactly(Type innerException, string because, Object[] becauseArgs);
    private IEnumerable`1<Exception> AssertInnerExceptions(Type innerException, string because, Object[] becauseArgs);
    private TException get_SingleSubject();
    private static string BuildExceptionsString(IEnumerable`1<TException> exceptions);
}
public class FluentAssertions.Specialized.ExecutionTime : object {
    private ITimer timer;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActionDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    internal TimeSpan ElapsedTime { get; }
    internal bool IsRunning { get; private set; }
    internal string ActionDescription { get; }
    internal Task Task { get; }
    internal Exception Exception { get; private set; }
    public ExecutionTime(Action action, StartTimer createTimer);
    public ExecutionTime(Func`1<Task> action, StartTimer createTimer);
    protected ExecutionTime(Action action, string actionDescription, StartTimer createTimer);
    protected ExecutionTime(Func`1<Task> action, string actionDescription, StartTimer createTimer);
    internal TimeSpan get_ElapsedTime();
    [CompilerGeneratedAttribute]
internal bool get_IsRunning();
    [CompilerGeneratedAttribute]
private void set_IsRunning(bool value);
    [CompilerGeneratedAttribute]
internal string get_ActionDescription();
    [CompilerGeneratedAttribute]
internal Task get_Task();
    [CompilerGeneratedAttribute]
internal Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
public class FluentAssertions.Specialized.ExecutionTimeAssertions : object {
    private ExecutionTime execution;
    public ExecutionTimeAssertions(ExecutionTime executionTime);
    private ValueTuple`2<bool, TimeSpan> PollUntil(Func`2<TimeSpan, bool> condition, bool expectedResult, TimeSpan rate);
    public AndConstraint`1<ExecutionTimeAssertions> BeLessThanOrEqualTo(TimeSpan maxDuration, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<ExecutionTimeAssertions> BeLessOrEqualTo(TimeSpan maxDuration, string because, Object[] becauseArgs);
    public AndConstraint`1<ExecutionTimeAssertions> BeLessThan(TimeSpan maxDuration, string because, Object[] becauseArgs);
    public AndConstraint`1<ExecutionTimeAssertions> BeGreaterThanOrEqualTo(TimeSpan minDuration, string because, Object[] becauseArgs);
    [EditorBrowsableAttribute("1")]
public AndConstraint`1<ExecutionTimeAssertions> BeGreaterOrEqualTo(TimeSpan minDuration, string because, Object[] becauseArgs);
    public AndConstraint`1<ExecutionTimeAssertions> BeGreaterThan(TimeSpan minDuration, string because, Object[] becauseArgs);
    public AndConstraint`1<ExecutionTimeAssertions> BeCloseTo(TimeSpan expectedDuration, TimeSpan precision, string because, Object[] becauseArgs);
    public virtual bool Equals(object obj);
}
internal static class FluentAssertions.Specialized.FunctionAssertionHelpers : object {
    internal static T NotThrow(Func`1<T> subject, string because, Object[] becauseArgs);
    internal static TResult NotThrowAfter(Func`1<TResult> subject, IClock clock, TimeSpan waitTime, TimeSpan pollInterval, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Specialized.FunctionAssertions`1 : DelegateAssertions`2<Func`1<T>, FunctionAssertions`1<T>> {
    protected string Identifier { get; }
    public FunctionAssertions`1(Func`1<T> subject, IExtractExceptions extractor);
    public FunctionAssertions`1(Func`1<T> subject, IExtractExceptions extractor, IClock clock);
    protected virtual void InvokeSubject();
    protected virtual string get_Identifier();
    public AndWhichConstraint`2<FunctionAssertions`1<T>, T> NotThrow(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<FunctionAssertions`1<T>, T> NotThrowAfter(TimeSpan waitTime, TimeSpan pollInterval, string because, Object[] becauseArgs);
}
public class FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1 : AsyncFunctionAssertions`2<Task`1<TResult>, GenericAsyncFunctionAssertions`1<TResult>> {
    public GenericAsyncFunctionAssertions`1(Func`1<Task`1<TResult>> subject, IExtractExceptions extractor);
    public GenericAsyncFunctionAssertions`1(Func`1<Task`1<TResult>> subject, IExtractExceptions extractor, IClock clock);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1/<CompleteWithinAsync>d__2")]
public Task`1<AndWhichConstraint`2<GenericAsyncFunctionAssertions`1<TResult>, TResult>> CompleteWithinAsync(TimeSpan timeSpan, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.GenericAsyncFunctionAssertions`1/<NotThrowAsync>d__3")]
public Task`1<AndWhichConstraint`2<GenericAsyncFunctionAssertions`1<TResult>, TResult>> NotThrowAsync(string because, Object[] becauseArgs);
    public Task`1<AndWhichConstraint`2<GenericAsyncFunctionAssertions`1<TResult>, TResult>> NotThrowAfterAsync(TimeSpan waitTime, TimeSpan pollInterval, string because, Object[] becauseArgs);
}
public interface FluentAssertions.Specialized.IExtractExceptions {
    public abstract virtual IEnumerable`1<T> OfType(Exception actualException);
}
public class FluentAssertions.Specialized.MemberExecutionTime`1 : ExecutionTime {
    public MemberExecutionTime`1(T subject, Expression`1<Action`1<T>> action, StartTimer createTimer);
}
public class FluentAssertions.Specialized.NonGenericAsyncFunctionAssertions : AsyncFunctionAssertions`2<Task, NonGenericAsyncFunctionAssertions> {
    public NonGenericAsyncFunctionAssertions(Func`1<Task> subject, IExtractExceptions extractor);
    public NonGenericAsyncFunctionAssertions(Func`1<Task> subject, IExtractExceptions extractor, IClock clock);
}
public class FluentAssertions.Specialized.TaskCompletionSourceAssertions`1 : TaskCompletionSourceAssertionsBase {
    private TaskCompletionSource`1<T> subject;
    public TaskCompletionSourceAssertions`1(TaskCompletionSource`1<T> tcs);
    public TaskCompletionSourceAssertions`1(TaskCompletionSource`1<T> tcs, IClock clock);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.TaskCompletionSourceAssertions`1/<CompleteWithinAsync>d__3")]
public Task`1<AndWhichConstraint`2<TaskCompletionSourceAssertions`1<T>, T>> CompleteWithinAsync(TimeSpan timeSpan, string because, Object[] becauseArgs);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.TaskCompletionSourceAssertions`1/<NotCompleteWithinAsync>d__4")]
public Task`1<AndConstraint`1<TaskCompletionSourceAssertions`1<T>>> NotCompleteWithinAsync(TimeSpan timeSpan, string because, Object[] becauseArgs);
}
public class FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase : object {
    [CompilerGeneratedAttribute]
private IClock <Clock>k__BackingField;
    private protected IClock Clock { get; }
    protected TaskCompletionSourceAssertionsBase(IClock clock);
    [CompilerGeneratedAttribute]
private protected IClock get_Clock();
    public virtual bool Equals(object obj);
    [AsyncStateMachineAttribute("FluentAssertions.Specialized.TaskCompletionSourceAssertionsBase/<CompletesWithinTimeoutAsync>d__5")]
private protected Task`1<bool> CompletesWithinTimeoutAsync(Task target, TimeSpan remainingTime);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Streams.BufferedStreamAssertions : BufferedStreamAssertions`1<BufferedStreamAssertions> {
    public BufferedStreamAssertions(BufferedStream stream);
}
public class FluentAssertions.Streams.BufferedStreamAssertions`1 : StreamAssertions`2<BufferedStream, TAssertions> {
    protected string Identifier { get; }
    public BufferedStreamAssertions`1(BufferedStream stream);
    protected virtual string get_Identifier();
    public AndConstraint`1<TAssertions> HaveBufferSize(int expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveBufferSize(int unexpected, string because, Object[] becauseArgs);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Streams.StreamAssertions : StreamAssertions`2<Stream, StreamAssertions> {
    public StreamAssertions(Stream stream);
}
public class FluentAssertions.Streams.StreamAssertions`2 : ReferenceTypeAssertions`2<TSubject, TAssertions> {
    protected string Identifier { get; }
    public StreamAssertions`2(TSubject stream);
    protected virtual string get_Identifier();
    public AndConstraint`1<TAssertions> BeWritable(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeWritable(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeSeekable(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeSeekable(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeReadable(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeReadable(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HavePosition(long expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHavePosition(long unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> HaveLength(long expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveLength(long unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeReadOnly(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeReadOnly(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> BeWriteOnly(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeWriteOnly(string because, Object[] becauseArgs);
}
[ExtensionAttribute]
public static class FluentAssertions.TypeEnumerableExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreDecoratedWith(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreDecoratedWithOrInherit(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreNotDecoratedWith(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreNotDecoratedWithOrInherit(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreInNamespace(IEnumerable`1<Type> types, string namespace);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreUnderNamespace(IEnumerable`1<Type> types, string namespace);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatDeriveFrom(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatImplement(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreClasses(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreNotClasses(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreStatic(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatAreNotStatic(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ThatSatisfy(IEnumerable`1<Type> types, Func`2<Type, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<Type> UnwrapTaskTypes(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static IEnumerable`1<Type> UnwrapEnumerableTypes(IEnumerable`1<Type> types);
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.TypeExtensions : object {
    [ExtensionAttribute]
public static TypeSelector Types(Assembly assembly);
    [ExtensionAttribute]
public static TypeSelector Types(Type type);
    [ExtensionAttribute]
public static TypeSelector Types(IEnumerable`1<Type> types);
    [ExtensionAttribute]
public static MethodInfoSelector Methods(Type type);
    [ExtensionAttribute]
public static MethodInfoSelector Methods(TypeSelector typeSelector);
    [ExtensionAttribute]
public static PropertyInfoSelector Properties(Type type);
    [ExtensionAttribute]
public static PropertyInfoSelector Properties(TypeSelector typeSelector);
}
public static class FluentAssertions.Types.AllTypes : object {
    public static TypeSelector From(Assembly assembly);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.ConstructorInfoAssertions : MethodBaseAssertions`2<ConstructorInfo, ConstructorInfoAssertions> {
    internal string SubjectDescription { get; }
    protected string Identifier { get; }
    public ConstructorInfoAssertions(ConstructorInfo constructorInfo);
    internal static string GetDescriptionFor(ConstructorInfo constructorInfo);
    internal virtual string get_SubjectDescription();
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public abstract class FluentAssertions.Types.MemberInfoAssertions`2 : ReferenceTypeAssertions`2<TSubject, TAssertions> {
    protected string Identifier { get; }
    internal string SubjectDescription { get; }
    protected MemberInfoAssertions`2(TSubject subject);
    public AndWhichConstraint`2<MemberInfoAssertions`2<TSubject, TAssertions>, TAttribute> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<MemberInfoAssertions`2<TSubject, TAssertions>, TAttribute> BeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
    internal virtual string get_SubjectDescription();
}
[DebuggerNonUserCodeAttribute]
public abstract class FluentAssertions.Types.MethodBaseAssertions`2 : MemberInfoAssertions`2<TSubject, TAssertions> {
    protected MethodBaseAssertions`2(TSubject subject);
    public AndConstraint`1<TAssertions> HaveAccessModifier(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotHaveAccessModifier(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    internal static string GetParameterString(MethodBase methodBase);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.MethodInfoAssertions : MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions> {
    internal string SubjectDescription { get; }
    protected string Identifier { get; }
    public MethodInfoAssertions(MethodInfo methodInfo);
    public AndConstraint`1<MethodInfoAssertions> BeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoAssertions> NotBeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoAssertions> BeAsync(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoAssertions> NotBeAsync(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> ReturnVoid(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> Return(Type returnType, string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> Return(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> NotReturnVoid(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> NotReturn(Type returnType, string because, Object[] becauseArgs);
    public AndConstraint`1<MethodBaseAssertions`2<MethodInfo, MethodInfoAssertions>> NotReturn(string because, Object[] becauseArgs);
    internal static string GetDescriptionFor(MethodInfo method);
    internal virtual string get_SubjectDescription();
    protected virtual string get_Identifier();
}
public class FluentAssertions.Types.MethodInfoSelector : object {
    private IEnumerable`1<MethodInfo> selectedMethods;
    public MethodInfoSelector ThatArePublicOrInternal { get; }
    public MethodInfoSelector ThatReturnVoid { get; }
    public MethodInfoSelector ThatDoNotReturnVoid { get; }
    public MethodInfoSelector(Type type);
    public MethodInfoSelector(IEnumerable`1<Type> types);
    public MethodInfoSelector get_ThatArePublicOrInternal();
    public MethodInfoSelector get_ThatReturnVoid();
    public MethodInfoSelector get_ThatDoNotReturnVoid();
    public MethodInfoSelector ThatReturn();
    public MethodInfoSelector ThatDoNotReturn();
    public MethodInfoSelector ThatAreDecoratedWith();
    public MethodInfoSelector ThatAreDecoratedWithOrInherit();
    public MethodInfoSelector ThatAreNotDecoratedWith();
    public MethodInfoSelector ThatAreNotDecoratedWithOrInherit();
    public MethodInfoSelector ThatAreAbstract();
    public MethodInfoSelector ThatAreNotAbstract();
    public MethodInfoSelector ThatAreAsync();
    public MethodInfoSelector ThatAreNotAsync();
    public MethodInfoSelector ThatAreStatic();
    public MethodInfoSelector ThatAreNotStatic();
    public MethodInfoSelector ThatAreVirtual();
    public MethodInfoSelector ThatAreNotVirtual();
    public TypeSelector ReturnTypes();
    public MethodInfo[] ToArray();
    private static bool HasSpecialName(MethodInfo method);
    public sealed virtual IEnumerator`1<MethodInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.MethodInfoSelectorAssertions : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<MethodInfo> <SubjectMethods>k__BackingField;
    public IEnumerable`1<MethodInfo> SubjectMethods { get; }
    protected string Context { get; }
    public MethodInfoSelectorAssertions(MethodInfo[] methods);
    [CompilerGeneratedAttribute]
public IEnumerable`1<MethodInfo> get_SubjectMethods();
    public AndConstraint`1<MethodInfoSelectorAssertions> BeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> NotBeVirtual(string because, Object[] becauseArgs);
    private MethodInfo[] GetAllNonVirtualMethodsFromSelection();
    private MethodInfo[] GetAllVirtualMethodsFromSelection();
    public AndConstraint`1<MethodInfoSelectorAssertions> BeAsync(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> NotBeAsync(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> BeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> NotBeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> Be(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndConstraint`1<MethodInfoSelectorAssertions> NotBe(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    private MethodInfo[] GetMethodsWithout(Expression`1<Func`2<TAttribute, bool>> isMatchingPredicate);
    private MethodInfo[] GetMethodsWith(Expression`1<Func`2<TAttribute, bool>> isMatchingPredicate);
    private static string GetDescriptionsFor(IEnumerable`1<MethodInfo> methods);
    protected string get_Context();
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.PropertyInfoAssertions : MemberInfoAssertions`2<PropertyInfo, PropertyInfoAssertions> {
    internal string SubjectDescription { get; }
    protected string Identifier { get; }
    public PropertyInfoAssertions(PropertyInfo propertyInfo);
    public AndConstraint`1<PropertyInfoAssertions> BeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotBeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> BeWritable(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> BeWritable(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotBeWritable(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> BeReadable(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> BeReadable(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotBeReadable(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> Return(Type propertyType, string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> Return(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotReturn(Type propertyType, string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoAssertions> NotReturn(string because, Object[] becauseArgs);
    internal static string GetDescriptionFor(PropertyInfo property);
    internal virtual string get_SubjectDescription();
    protected virtual string get_Identifier();
}
public class FluentAssertions.Types.PropertyInfoSelector : object {
    private IEnumerable`1<PropertyInfo> selectedProperties;
    public PropertyInfoSelector ThatArePublicOrInternal { get; }
    public PropertyInfoSelector ThatAreAbstract { get; }
    public PropertyInfoSelector ThatAreNotAbstract { get; }
    public PropertyInfoSelector ThatAreStatic { get; }
    public PropertyInfoSelector ThatAreNotStatic { get; }
    public PropertyInfoSelector ThatAreVirtual { get; }
    public PropertyInfoSelector ThatAreNotVirtual { get; }
    public PropertyInfoSelector(Type type);
    public PropertyInfoSelector(IEnumerable`1<Type> types);
    public PropertyInfoSelector get_ThatArePublicOrInternal();
    public PropertyInfoSelector get_ThatAreAbstract();
    public PropertyInfoSelector get_ThatAreNotAbstract();
    public PropertyInfoSelector get_ThatAreStatic();
    public PropertyInfoSelector get_ThatAreNotStatic();
    public PropertyInfoSelector get_ThatAreVirtual();
    public PropertyInfoSelector get_ThatAreNotVirtual();
    public PropertyInfoSelector ThatAreDecoratedWith();
    public PropertyInfoSelector ThatAreDecoratedWithOrInherit();
    public PropertyInfoSelector ThatAreNotDecoratedWith();
    public PropertyInfoSelector ThatAreNotDecoratedWithOrInherit();
    public PropertyInfoSelector OfType();
    public PropertyInfoSelector NotOfType();
    public TypeSelector ReturnTypes();
    public PropertyInfo[] ToArray();
    public sealed virtual IEnumerator`1<PropertyInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.PropertyInfoSelectorAssertions : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PropertyInfo> <SubjectProperties>k__BackingField;
    public IEnumerable`1<PropertyInfo> SubjectProperties { get; }
    protected string Context { get; }
    public PropertyInfoSelectorAssertions(PropertyInfo[] properties);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PropertyInfo> get_SubjectProperties();
    public AndConstraint`1<PropertyInfoSelectorAssertions> BeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoSelectorAssertions> NotBeVirtual(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoSelectorAssertions> BeWritable(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoSelectorAssertions> NotBeWritable(string because, Object[] becauseArgs);
    private PropertyInfo[] GetAllReadOnlyPropertiesFromSelection();
    private PropertyInfo[] GetAllWritablePropertiesFromSelection();
    private PropertyInfo[] GetAllNonVirtualPropertiesFromSelection();
    private PropertyInfo[] GetAllVirtualPropertiesFromSelection();
    public AndConstraint`1<PropertyInfoSelectorAssertions> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<PropertyInfoSelectorAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    private PropertyInfo[] GetPropertiesWithout();
    private PropertyInfo[] GetPropertiesWith();
    private static string GetDescriptionsFor(IEnumerable`1<PropertyInfo> properties);
    protected string get_Context();
    public virtual bool Equals(object obj);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.TypeAssertions : ReferenceTypeAssertions`2<Type, TypeAssertions> {
    protected string Identifier { get; }
    public TypeAssertions(Type type);
    public AndConstraint`1<TypeAssertions> Be(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> Be(Type expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeAssignableTo(Type type, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeAssignableTo(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeAssignableTo(Type type, string because, Object[] becauseArgs);
    private static string GetFailureMessageIfTypesAreDifferent(Type actual, Type expected);
    public AndConstraint`1<TypeAssertions> NotBe(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBe(Type unexpected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, TAttribute> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, TAttribute> BeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, TAttribute> BeDecoratedWithOrInherit(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, TAttribute> BeDecoratedWithOrInherit(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDecoratedWithOrInherit(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDecoratedWithOrInherit(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> Implement(Type interfaceType, string because, Object[] becauseArgs);
    private bool AssertSubjectImplements(Type interfaceType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> Implement(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotImplement(Type interfaceType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotImplement(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeDerivedFrom(Type baseType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeDerivedFrom(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDerivedFrom(Type baseType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeDerivedFrom(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeSealed(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeSealed(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeAbstract(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeAbstract(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> BeStatic(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotBeStatic(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, PropertyInfo> HaveProperty(Type propertyType, string name, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, PropertyInfo> HaveProperty(string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveProperty(string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> HaveExplicitProperty(Type interfaceType, string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> HaveExplicitProperty(string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitProperty(Type interfaceType, string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitProperty(string name, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> HaveExplicitMethod(Type interfaceType, string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> HaveExplicitMethod(string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitMethod(Type interfaceType, string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitMethod(string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, PropertyInfo> HaveIndexer(Type indexerType, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveIndexer(IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveMethod(string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveMethod(string name, IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, ConstructorInfo> HaveConstructor(IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, ConstructorInfo> HaveDefaultConstructor(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, ConstructorInfo> NotHaveConstructor(IEnumerable`1<Type> parameterTypes, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, ConstructorInfo> NotHaveDefaultConstructor(string because, Object[] becauseArgs);
    private static string GetParameterString(IEnumerable`1<Type> parameterTypes);
    public AndConstraint`1<TypeAssertions> HaveAccessModifier(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveAccessModifier(CSharpAccessModifier accessModifier, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveImplicitConversionOperator(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveImplicitConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveImplicitConversionOperator(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveImplicitConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveExplicitConversionOperator(string because, Object[] becauseArgs);
    public AndWhichConstraint`2<TypeAssertions, MethodInfo> HaveExplicitConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitConversionOperator(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeAssertions> NotHaveExplicitConversionOperator(Type sourceType, Type targetType, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
    private void AssertThatSubjectIsClass();
}
public class FluentAssertions.Types.TypeSelector : object {
    private List`1<Type> types;
    public TypeSelector(Type type);
    public TypeSelector(IEnumerable`1<Type> types);
    public Type[] ToArray();
    public TypeSelector ThatDeriveFrom();
    public TypeSelector ThatDoNotDeriveFrom();
    public TypeSelector ThatImplement();
    public TypeSelector ThatDoNotImplement();
    public TypeSelector ThatAreDecoratedWith();
    public TypeSelector ThatAreDecoratedWithOrInherit();
    public TypeSelector ThatAreNotDecoratedWith();
    public TypeSelector ThatAreNotDecoratedWithOrInherit();
    public TypeSelector ThatAreInNamespace(string namespace);
    public TypeSelector ThatAreNotInNamespace(string namespace);
    public TypeSelector ThatAreUnderNamespace(string namespace);
    public TypeSelector ThatAreNotUnderNamespace(string namespace);
    public TypeSelector ThatAreValueTypes();
    public TypeSelector ThatAreNotValueTypes();
    public TypeSelector ThatAreClasses();
    public TypeSelector ThatAreNotClasses();
    public TypeSelector ThatAreAbstract();
    public TypeSelector ThatAreNotAbstract();
    public TypeSelector ThatAreSealed();
    public TypeSelector ThatAreNotSealed();
    public TypeSelector ThatAreInterfaces();
    public TypeSelector ThatAreNotInterfaces();
    public TypeSelector ThatAreStatic();
    public TypeSelector ThatAreNotStatic();
    public TypeSelector ThatSatisfy(Func`2<Type, bool> predicate);
    public TypeSelector UnwrapTaskTypes();
    public TypeSelector UnwrapEnumerableTypes();
    public sealed virtual IEnumerator`1<Type> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Types.TypeSelectorAssertions : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <Subject>k__BackingField;
    public IEnumerable`1<Type> Subject { get; }
    public TypeSelectorAssertions(Type[] types);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_Subject();
    public AndConstraint`1<TypeSelectorAssertions> BeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> BeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> BeDecoratedWithOrInherit(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> BeDecoratedWithOrInherit(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeDecoratedWith(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeDecoratedWith(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeDecoratedWithOrInherit(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeDecoratedWithOrInherit(Expression`1<Func`2<TAttribute, bool>> isMatchingAttributePredicate, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> BeSealed(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeSealed(string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> BeInNamespace(string namespace, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeInNamespace(string namespace, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> BeUnderNamespace(string namespace, string because, Object[] becauseArgs);
    public AndConstraint`1<TypeSelectorAssertions> NotBeUnderNamespace(string namespace, string because, Object[] becauseArgs);
    private static string GetDescriptionsFor(IEnumerable`1<Type> types);
    private static string GetDescriptionFor(Type type);
    public virtual bool Equals(object obj);
}
internal class FluentAssertions.Xml.Equivalency.AttributeData : object {
    [CompilerGeneratedAttribute]
private string <NamespaceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public string NamespaceUri { get; }
    public string LocalName { get; }
    public string Value { get; }
    private string Prefix { get; }
    public string QualifiedName { get; }
    public AttributeData(string namespaceUri, string localName, string value, string prefix);
    [CompilerGeneratedAttribute]
public string get_NamespaceUri();
    [CompilerGeneratedAttribute]
public string get_LocalName();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private string get_Prefix();
    public string get_QualifiedName();
}
internal class FluentAssertions.Xml.Equivalency.Failure : object {
    [CompilerGeneratedAttribute]
private string <FormatString>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <FormatParams>k__BackingField;
    public string FormatString { get; }
    public Object[] FormatParams { get; }
    public Failure(string formatString, Object[] formatParams);
    [CompilerGeneratedAttribute]
public string get_FormatString();
    [CompilerGeneratedAttribute]
public Object[] get_FormatParams();
}
internal class FluentAssertions.Xml.Equivalency.Node : object {
    private List`1<Node> children;
    private string name;
    private int count;
    [CompilerGeneratedAttribute]
private Node <Parent>k__BackingField;
    public Node Parent { get; }
    private Node(Node parent, string name);
    public static Node CreateRoot();
    public string GetXPath();
    [IteratorStateMachineAttribute("FluentAssertions.Xml.Equivalency.Node/<GetPath>d__6")]
private IEnumerable`1<Node> GetPath();
    [CompilerGeneratedAttribute]
public Node get_Parent();
    public Node Push(string localName);
    public void Pop();
    private Node AddChildNode(string name);
}
internal class FluentAssertions.Xml.Equivalency.XmlIterator : object {
    private XmlReader reader;
    private bool skipOnce;
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public string Value { get; }
    public bool IsEmptyElement { get; }
    public bool IsEndOfDocument { get; }
    public XmlIterator(XmlReader reader);
    public XmlNodeType get_NodeType();
    public string get_LocalName();
    public string get_NamespaceUri();
    public string get_Value();
    public bool get_IsEmptyElement();
    public bool get_IsEndOfDocument();
    public void Read();
    public void MoveToEndElement();
    public IList`1<AttributeData> GetAttributes();
}
internal class FluentAssertions.Xml.Equivalency.XmlReaderValidator : object {
    private AssertionScope assertion;
    private XmlReader subjectReader;
    private XmlReader expectationReader;
    private XmlIterator subjectIterator;
    private XmlIterator expectationIterator;
    private Node currentNode;
    public XmlReaderValidator(XmlReader subjectReader, XmlReader expectationReader, string because, Object[] becauseArgs);
    public void Validate(bool shouldBeEquivalent);
    private Failure Validate();
    private Failure ValidateAttributes();
    private Failure ValidateStartElement();
    private Failure ValidateText();
    private Failure ValidateAgainstNulls();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XAttributeAssertions : ReferenceTypeAssertions`2<XAttribute, XAttributeAssertions> {
    protected string Identifier { get; }
    public XAttributeAssertions(XAttribute attribute);
    public AndConstraint`1<XAttributeAssertions> Be(XAttribute expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XAttributeAssertions> NotBe(XAttribute unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<XAttributeAssertions> HaveValue(string expected, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XDocumentAssertions : ReferenceTypeAssertions`2<XDocument, XDocumentAssertions> {
    protected string Identifier { get; }
    public XDocumentAssertions(XDocument document);
    public AndConstraint`1<XDocumentAssertions> Be(XDocument expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XDocumentAssertions> NotBe(XDocument unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<XDocumentAssertions> BeEquivalentTo(XDocument expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XDocumentAssertions> NotBeEquivalentTo(XDocument unexpected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveRoot(string expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveRoot(XName expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveElement(string expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, IEnumerable`1<XElement>> HaveElement(string expected, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, XElement> HaveElement(XName expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XDocumentAssertions, IEnumerable`1<XElement>> HaveElement(XName expected, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XElementAssertions : ReferenceTypeAssertions`2<XElement, XElementAssertions> {
    protected string Identifier { get; }
    public XElementAssertions(XElement xElement);
    public AndConstraint`1<XElementAssertions> Be(XElement expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> NotBe(XElement unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> BeEquivalentTo(XElement expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> NotBeEquivalentTo(XElement unexpected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> HaveValue(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because, Object[] becauseArgs);
    public AndConstraint`1<XElementAssertions> HaveAttribute(XName expectedName, string expectedValue, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XElementAssertions, XElement> HaveElement(string expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XElementAssertions, XElement> HaveElement(XName expected, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XElementAssertions, IEnumerable`1<XElement>> HaveElement(XName expected, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XElementAssertions, IEnumerable`1<XElement>> HaveElement(string expected, OccurrenceConstraint occurrenceConstraint, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XmlElementAssertions : XmlNodeAssertions`2<XmlElement, XmlElementAssertions> {
    protected string Identifier { get; }
    public XmlElementAssertions(XmlElement xmlElement);
    public AndConstraint`1<XmlElementAssertions> HaveInnerText(string expected, string because, Object[] becauseArgs);
    public AndConstraint`1<XmlElementAssertions> HaveAttribute(string expectedName, string expectedValue, string because, Object[] becauseArgs);
    public AndConstraint`1<XmlElementAssertions> HaveAttributeWithNamespace(string expectedName, string expectedNamespace, string expectedValue, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XmlElementAssertions, XmlElement> HaveElement(string expectedName, string because, Object[] becauseArgs);
    public AndWhichConstraint`2<XmlElementAssertions, XmlElement> HaveElementWithNamespace(string expectedName, string expectedNamespace, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XmlNodeAssertions : XmlNodeAssertions`2<XmlNode, XmlNodeAssertions> {
    public XmlNodeAssertions(XmlNode xmlNode);
}
[DebuggerNonUserCodeAttribute]
public class FluentAssertions.Xml.XmlNodeAssertions`2 : ReferenceTypeAssertions`2<TSubject, TAssertions> {
    protected string Identifier { get; }
    public XmlNodeAssertions`2(TSubject xmlNode);
    public AndConstraint`1<TAssertions> BeEquivalentTo(XmlNode expected, string because, Object[] becauseArgs);
    public AndConstraint`1<TAssertions> NotBeEquivalentTo(XmlNode unexpected, string because, Object[] becauseArgs);
    protected virtual string get_Identifier();
}
public class FluentAssertions.Xml.XmlNodeFormatter : object {
    public sealed virtual bool CanHandle(object value);
    public sealed virtual void Format(object value, FormattedObjectGraph formattedGraph, FormattingContext context, FormatChild formatChild);
}
[ExtensionAttribute]
[DebuggerNonUserCodeAttribute]
public static class FluentAssertions.XmlAssertionExtensions : object {
    [ExtensionAttribute]
public static XmlNodeAssertions Should(XmlNode actualValue);
    [ExtensionAttribute]
public static XmlElementAssertions Should(XmlElement actualValue);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[AttributeUsageAttribute("2240")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
private string ToStringFromEnd();
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("1774")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.Versioning.RequiresPreviewFeaturesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresPreviewFeaturesAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[ExtensionAttribute]
internal static class System.Text.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder AppendLine(StringBuilder stringBuilder, IFormatProvider _, string value);
}
