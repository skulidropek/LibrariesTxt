public class FluentFTP.AsyncFtpClient : BaseFtpClient {
    public AsyncFtpClient(string host, int port, FtpConfig config, IFtpLogger logger);
    public AsyncFtpClient(string host, string user, string pass, int port, FtpConfig config, IFtpLogger logger);
    public AsyncFtpClient(string host, NetworkCredential credentials, int port, FtpConfig config, IFtpLogger logger);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<Authenticate>d__0")]
protected virtual Task Authenticate(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<Authenticate>d__1")]
protected virtual Task Authenticate(string userName, string password, string account, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<AutoConnect>d__2")]
public sealed virtual Task`1<FtpProfile> AutoConnect(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<AutoDetect>d__3")]
public sealed virtual Task`1<List`1<FtpProfile>> AutoDetect(FtpAutoDetectConfig config, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<AutoDetect>d__4")]
public sealed virtual Task`1<List`1<FtpProfile>> AutoDetect(bool firstOnly, bool cloneConnection, CancellationToken token);
    public sealed virtual Task Chmod(string path, FtpPermission owner, FtpPermission group, FtpPermission other, CancellationToken token);
    public sealed virtual Task Chmod(string path, int permissions, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<CompareFile>d__7")]
public sealed virtual Task`1<FtpCompareResult> CompareFile(string localPath, string remotePath, FtpCompareOption options, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<Connect>d__8")]
public sealed virtual Task Connect(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<Connect>d__9")]
public sealed virtual Task Connect(FtpProfile profile, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<Connect>d__10")]
public virtual Task Connect(bool reConnect, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<ConnectAsync>d__11")]
protected virtual Task ConnectAsync(FtpSocketStream stream, CancellationToken token);
    protected virtual Task ConnectAsync(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<CreateDirectory>d__13")]
public sealed virtual Task`1<bool> CreateDirectory(string path, bool force, CancellationToken token);
    public sealed virtual Task`1<bool> CreateDirectory(string path, CancellationToken token);
    public sealed virtual Task DeleteDirectory(string path, CancellationToken token);
    public sealed virtual Task DeleteDirectory(string path, FtpListOption options, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DeleteDirInternalAsync>d__17")]
protected Task DeleteDirInternalAsync(string path, bool deleteContents, FtpListOption options, bool deleteFinalDir, bool firstCall, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DeleteFile>d__18")]
public sealed virtual Task DeleteFile(string path, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DirectoryExists>d__19")]
public sealed virtual Task`1<bool> DirectoryExists(string path, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DisableUTF8>d__20")]
public sealed virtual Task DisableUTF8(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<Disconnect>d__21")]
public sealed virtual Task Disconnect(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DiscoverSslSessionLength>d__22")]
public Task`1<int> DiscoverSslSessionLength(string command, int maxTries, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadBytes>d__23")]
public sealed virtual Task`1<Byte[]> DownloadBytes(string remotePath, long restartPosition, IProgress`1<FtpProgress> progress, CancellationToken token, long stopPosition);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadBytes>d__24")]
public sealed virtual Task`1<Byte[]> DownloadBytes(string remotePath, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadDirectory>d__25")]
public sealed virtual Task`1<List`1<FtpResult>> DownloadDirectory(string localFolder, string remoteFolder, FtpFolderSyncMode mode, FtpLocalExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, IProgress`1<FtpProgress> progress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadServerFilesAsync>d__26")]
protected Task DownloadServerFilesAsync(List`1<FtpResult> toDownload, FtpLocalExists existsMode, FtpVerify verifyOptions, IProgress`1<FtpProgress> progress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadFile>d__27")]
public sealed virtual Task`1<FtpStatus> DownloadFile(string localPath, string remotePath, FtpLocalExists existsMode, FtpVerify verifyOptions, IProgress`1<FtpProgress> progress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadFileToFileAsync>d__28")]
protected Task`1<FtpStatus> DownloadFileToFileAsync(string localPath, string remotePath, FtpLocalExists existsMode, FtpVerify verifyOptions, IProgress`1<FtpProgress> progress, CancellationToken token, FtpProgress metaProgress);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadFileInternalAsync>d__29")]
protected Task`1<bool> DownloadFileInternalAsync(string localPath, string remotePath, Stream outStream, long restartPosition, IProgress`1<FtpProgress> progress, CancellationToken token, FtpProgress metaProgress, long knownFileSize, bool isAppend, long stopPosition);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<ResumeDownloadAsync>d__30")]
protected Task`1<Tuple`2<bool, Stream>> ResumeDownloadAsync(string remotePath, Stream downStream, long offset, IOException ex, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadFiles>d__31")]
public sealed virtual Task`1<List`1<FtpResult>> DownloadFiles(string localDir, IEnumerable`1<string> remotePaths, FtpLocalExists existsMode, FtpVerify verifyOptions, FtpError errorHandling, CancellationToken token, IProgress`1<FtpProgress> progress, List`1<FtpRule> rules);
    protected void PurgeSuccessfulDownloads(IEnumerable`1<string> localFiles);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadStream>d__33")]
public sealed virtual Task`1<bool> DownloadStream(Stream outStream, string remotePath, long restartPosition, IProgress`1<FtpProgress> progress, CancellationToken token, long stopPosition);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DownloadUriBytes>d__34")]
public sealed virtual Task`1<Byte[]> DownloadUriBytes(string uri, IProgress`1<FtpProgress> progress, CancellationToken token);
    public sealed virtual Task EmptyDirectory(string path, CancellationToken token);
    public sealed virtual Task EmptyDirectory(string path, FtpListOption options, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<Execute>d__37")]
public sealed virtual Task`1<FtpReply> Execute(string command, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<OnPostExecute>d__38")]
protected Task OnPostExecute(string command, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<ExecuteDownloadText>d__39")]
public sealed virtual Task`1<List`1<string>> ExecuteDownloadText(string command, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<ExecuteDownloadTextInternal>d__40")]
protected Task`1<List`1<string>> ExecuteDownloadTextInternal(string command, bool retry, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<FileExists>d__41")]
public sealed virtual Task`1<bool> FileExists(string path, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetAbsoluteDirAsync>d__42")]
protected Task`1<string> GetAbsoluteDirAsync(string path, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetAbsoluteFilePathAsync>d__43")]
protected Task`1<string> GetAbsoluteFilePathAsync(string path, string fileName, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetAbsolutePathAsync>d__44")]
protected Task`1<string> GetAbsolutePathAsync(string path, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetChecksum>d__45")]
public sealed virtual Task`1<FtpHash> GetChecksum(string remotePath, FtpHashAlgorithm algorithm, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<SetHashAlgorithmInternalAsync>d__46")]
internal Task SetHashAlgorithmInternalAsync(FtpHashAlgorithm algorithm, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetHashInternalAsync>d__47")]
internal Task`1<string> GetHashInternalAsync(string remotePath, string command, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<HashCommandInternalAsync>d__48")]
protected Task`1<FtpHash> HashCommandInternalAsync(string remotePath, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetChmod>d__49")]
public sealed virtual Task`1<int> GetChmod(string path, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetFilePermissions>d__50")]
public sealed virtual Task`1<FtpListItem> GetFilePermissions(string path, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetFileSize>d__51")]
public sealed virtual Task`1<long> GetFileSize(string path, long defaultValue, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetFileSizeInternal>d__52")]
protected Task GetFileSizeInternal(string path, long defaultValue, CancellationToken token, FtpSizeReply sizeReply);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetListing>d__53")]
public sealed virtual Task`1<FtpListItem[]> GetListing(string path, FtpListOption options, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetListingProcessItemAsync>d__54")]
protected Task`1<FtpListItem> GetListingProcessItemAsync(FtpListItem item, List`1<FtpListItem> lst, string rawEntry, string listcmd, CancellationToken token, bool isIncludeSelf, bool isNameList, bool isRecursive, bool isGetModified, bool isGetSize);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetListingInternal>d__55")]
protected Task`1<List`1<string>> GetListingInternal(string listcmd, FtpListOption options, bool retry, CancellationToken token);
    public sealed virtual Task`1<FtpListItem[]> GetListing(string path, CancellationToken token);
    public sealed virtual Task`1<FtpListItem[]> GetListing(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetListingRecursive>d__58")]
protected Task`1<FtpListItem[]> GetListingRecursive(string path, FtpListOption options, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetModifiedTime>d__59")]
public sealed virtual Task`1<DateTime> GetModifiedTime(string path, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetNameListing>d__60")]
public sealed virtual Task`1<String[]> GetNameListing(string path, CancellationToken token);
    public sealed virtual Task`1<String[]> GetNameListing(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetObjectInfo>d__62")]
public sealed virtual Task`1<FtpListItem> GetObjectInfo(string path, bool dateModified, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetReply>d__63")]
public sealed virtual Task`1<FtpReply> GetReply(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetWorkingDirectory>d__64")]
public sealed virtual Task`1<string> GetWorkingDirectory(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<ReadCurrentWorkingDirectory>d__65")]
protected Task`1<FtpReply> ReadCurrentWorkingDirectory(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetZOSListRealm>d__66")]
public Task`1<FtpZOSListRealm> GetZOSListRealm(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<HandshakeAsync>d__67")]
protected virtual Task HandshakeAsync(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<IsRoot>d__68")]
public Task`1<bool> IsRoot(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<IsStillConnected>d__69")]
public Task`1<bool> IsStillConnected(int timeout, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<MoveDirectory>d__70")]
public sealed virtual Task`1<bool> MoveDirectory(string path, string dest, FtpRemoteExists existsMode, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<MoveFile>d__71")]
public sealed virtual Task`1<bool> MoveFile(string path, string dest, FtpRemoteExists existsMode, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<Noop>d__72")]
protected Task`1<bool> Noop(bool ignoreNoopInterval, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<OpenActiveDataStreamAsync>d__73")]
protected Task`1<FtpDataStream> OpenActiveDataStreamAsync(FtpDataConnectionType type, string command, long restart, CancellationToken token);
    public virtual Task`1<Stream> OpenAppend(string path, FtpDataType type, bool checkIfFileExists, CancellationToken token);
    public virtual Task`1<Stream> OpenAppend(string path, FtpDataType type, long fileLen, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<OpenAppendInternal>d__76")]
public virtual Task`1<Stream> OpenAppendInternal(string path, FtpDataType type, long fileLen, bool ignoreStaleData, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<OpenDataStreamAsync>d__77")]
protected Task`1<FtpDataStream> OpenDataStreamAsync(string command, long restart, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<OpenPassiveFXPConnectionAsync>d__78")]
protected Task`1<FtpFxpSessionAsync> OpenPassiveFXPConnectionAsync(AsyncFtpClient remoteClient, bool progress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<OpenPassiveDataStreamAsync>d__79")]
protected Task`1<FtpDataStream> OpenPassiveDataStreamAsync(FtpDataConnectionType type, string command, long restart, CancellationToken token);
    public virtual Task`1<Stream> OpenRead(string path, FtpDataType type, long restart, bool checkIfFileExists, CancellationToken token);
    public virtual Task`1<Stream> OpenRead(string path, FtpDataType type, long restart, long fileLen, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<OpenReadInternal>d__82")]
public virtual Task`1<Stream> OpenReadInternal(string path, FtpDataType type, long fileLen, long restart, bool ignoreStaleData, CancellationToken token);
    public virtual Task`1<Stream> OpenWrite(string path, FtpDataType type, bool checkIfFileExists, CancellationToken token);
    public virtual Task`1<Stream> OpenWrite(string path, FtpDataType type, long fileLen, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<OpenWriteInternal>d__85")]
public virtual Task`1<Stream> OpenWriteInternal(string path, FtpDataType type, long fileLen, bool ignoreStaleData, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<Rename>d__86")]
public sealed virtual Task Rename(string path, string dest, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<SetDataTypeAsync>d__87")]
protected Task SetDataTypeAsync(FtpDataType type, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<SetDataTypeNoLockAsync>d__88")]
protected Task SetDataTypeNoLockAsync(FtpDataType type, CancellationToken token);
    public sealed virtual Task SetFilePermissions(string path, FtpPermission owner, FtpPermission group, FtpPermission other, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<SetFilePermissions>d__90")]
public sealed virtual Task SetFilePermissions(string path, int permissions, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<SetModifiedTime>d__91")]
public sealed virtual Task SetModifiedTime(string path, DateTime date, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<SetWorkingDirectory>d__92")]
public sealed virtual Task SetWorkingDirectory(string path, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<TransferDirectory>d__93")]
public Task`1<List`1<FtpResult>> TransferDirectory(string sourceFolder, AsyncFtpClient remoteClient, string remoteFolder, FtpFolderSyncMode mode, FtpRemoteExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, IProgress`1<FtpProgress> progress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetFilesToTransfer>d__94")]
protected Task`1<List`1<FtpResult>> GetFilesToTransfer(string sourceFolder, string remoteFolder, List`1<FtpRule> rules, List`1<FtpResult> results, Dictionary`2<string, bool> shouldExist, String[] fileListing, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<TransferServerFiles>d__95")]
protected Task TransferServerFiles(List`1<FtpResult> filesToTransfer, AsyncFtpClient remoteClient, FtpRemoteExists existsMode, FtpVerify verifyOptions, IProgress`1<FtpProgress> progress, FtpListItem[] remoteListing, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<TransferFile>d__96")]
public Task`1<FtpStatus> TransferFile(string sourcePath, AsyncFtpClient remoteClient, string remotePath, bool createRemoteDir, FtpRemoteExists existsMode, FtpVerify verifyOptions, IProgress`1<FtpProgress> progress, FtpProgress metaProgress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<TransferFileFXPInternal>d__97")]
protected Task`1<bool> TransferFileFXPInternal(string sourcePath, AsyncFtpClient remoteClient, string remotePath, bool createRemoteDir, FtpRemoteExists existsMode, IProgress`1<FtpProgress> progress, CancellationToken token, FtpProgress metaProgress);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<UploadBytes>d__98")]
public sealed virtual Task`1<FtpStatus> UploadBytes(Byte[] fileData, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, IProgress`1<FtpProgress> progress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<UploadDirectory>d__99")]
public sealed virtual Task`1<List`1<FtpResult>> UploadDirectory(string localFolder, string remoteFolder, FtpFolderSyncMode mode, FtpRemoteExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, IProgress`1<FtpProgress> progress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<CreateSubDirectories>d__100")]
protected Task CreateSubDirectories(AsyncFtpClient client, List`1<FtpResult> dirsToUpload, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<UploadDirectoryFiles>d__101")]
protected Task UploadDirectoryFiles(List`1<FtpResult> filesToUpload, FtpRemoteExists existsMode, FtpVerify verifyOptions, IProgress`1<FtpProgress> progress, FtpListItem[] remoteListing, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DeleteExtraServerFiles>d__102")]
protected Task DeleteExtraServerFiles(FtpFolderSyncMode mode, string remoteFolder, Dictionary`2<string, bool> shouldExist, FtpListItem[] remoteListing, List`1<FtpRule> rules, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<UploadFile>d__103")]
public sealed virtual Task`1<FtpStatus> UploadFile(string localPath, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, IProgress`1<FtpProgress> progress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<UploadFileFromFile>d__104")]
protected Task`1<FtpStatus> UploadFileFromFile(string localPath, string remotePath, bool createRemoteDir, FtpRemoteExists existsMode, bool fileExists, bool fileExistsKnown, FtpVerify verifyOptions, CancellationToken token, IProgress`1<FtpProgress> progress, FtpProgress metaProgress);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<UploadFileInternalAsync>d__105")]
protected Task`1<FtpStatus> UploadFileInternalAsync(Stream fileData, string localPath, string remotePath, bool createRemoteDir, FtpRemoteExists existsMode, bool fileExists, bool fileExistsKnown, IProgress`1<FtpProgress> progress, CancellationToken token, FtpProgress metaProgress);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<ResumeUploadAsync>d__106")]
protected Task`1<Tuple`2<bool, Stream>> ResumeUploadAsync(string remotePath, Stream upStream, long remotePosition, IOException ex, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<UploadFiles>d__107")]
public sealed virtual Task`1<List`1<FtpResult>> UploadFiles(IEnumerable`1<string> localPaths, string remoteDir, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, FtpError errorHandling, CancellationToken token, IProgress`1<FtpProgress> progress, List`1<FtpRule> rules);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<PurgeSuccessfulUploadsAsync>d__108")]
protected Task PurgeSuccessfulUploadsAsync(IEnumerable`1<string> remotePaths);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<UploadFiles>d__109")]
public sealed virtual Task`1<List`1<FtpResult>> UploadFiles(IEnumerable`1<FileInfo> localFiles, string remoteDir, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, FtpError errorHandling, CancellationToken token, IProgress`1<FtpProgress> progress, List`1<FtpRule> rules);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<GetFilesToUpload2Async>d__110")]
protected Task`1<List`1<FtpResult>> GetFilesToUpload2Async(IEnumerable`1<string> localFiles, string remoteDir, List`1<FtpRule> rules, List`1<FtpResult> results, Dictionary`2<string, bool> shouldExist, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<UploadStream>d__111")]
public sealed virtual Task`1<FtpStatus> UploadStream(Stream fileStream, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, IProgress`1<FtpProgress> progress, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<VerifyFXPTransferAsync>d__112")]
protected Task`1<bool> VerifyFXPTransferAsync(string sourcePath, AsyncFtpClient fxpDestinationClient, string remotePath, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<VerifyTransferAsync>d__113")]
protected Task`1<bool> VerifyTransferAsync(string localPath, string remotePath, CancellationToken token);
    protected virtual BaseFtpClient Create();
    public virtual void Dispose();
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DisposeAsync>d__120")]
public sealed virtual Task DisposeAsync();
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<DisposeAsyncCore>d__121")]
protected virtual Task DisposeAsyncCore();
    [CompilerGeneratedAttribute]
private void <Connect>b__10_0();
    [AsyncStateMachineAttribute("FluentFTP.AsyncFtpClient/<<Dispose>b__119_0>d")]
[CompilerGeneratedAttribute]
private Task <Dispose>b__119_0();
    [CompilerGeneratedAttribute]
private void <DisposeAsync>b__120_0();
}
public class FluentFTP.Client.BaseClient.BaseFtpClient : object {
    private IFtpLogger m_logger;
    private Action`2<FtpTraceLevel, string> m_legacyLogger;
    private FtpConfig m_config;
    protected FtpBaseServer _serverHandler;
    protected Encoding m_textEncoding;
    protected bool m_textEncodingAutoUTF;
    protected DateTime LastCommandTimestamp;
    protected string LastCommandExecuted;
    protected FtpReply HandshakeReply;
    protected string LastStreamPath;
    protected FtpListParser CurrentListParser;
    protected string m_Address;
    protected FtpClientState m_status;
    protected SemaphoreSlim m_daemonSemaphore;
    protected FtpSocketStream m_stream;
    protected bool m_isDisposed;
    protected bool m_IsAuthenticated;
    protected bool m_isClone;
    protected string m_host;
    protected int m_port;
    protected NetworkCredential m_credentials;
    protected List`1<FtpCapability> m_capabilities;
    protected FtpHashAlgorithm m_hashAlgorithms;
    protected FtpSslValidation m_ValidateCertificate;
    protected string m_systemType;
    protected FtpServer m_serverType;
    protected FtpOperatingSystem m_serverOS;
    protected string m_connectionType;
    [CompilerGeneratedAttribute]
private List`1<FtpReply> <LastReplies>k__BackingField;
    public IFtpLogger Logger { get; public set; }
    public Action`2<FtpTraceLevel, string> LegacyLogger { get; public set; }
    public FtpConfig Config { get; public set; }
    public FtpBaseServer ServerHandler { get; public set; }
    public Encoding Encoding { get; public set; }
    public string ClientType { get; }
    public FtpClientState Status { get; }
    public bool IsDisposed { get; protected set; }
    public Nullable`1<FtpIpVersion> InternetProtocol { get; }
    public bool IsConnected { get; }
    public bool IsAuthenticated { get; }
    protected bool IsClone { get; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public NetworkCredential Credentials { get; public set; }
    public List`1<FtpCapability> Capabilities { get; protected set; }
    public FtpHashAlgorithm HashAlgorithms { get; protected set; }
    public bool IsEncrypted { get; }
    public bool ValidateCertificateHandlerExists { get; }
    public string SystemType { get; }
    public FtpServer ServerType { get; }
    public FtpOperatingSystem ServerOS { get; }
    public string ConnectionType { get; protected set; }
    public FtpReply LastReply { get; }
    public List`1<FtpReply> LastReplies { get; public set; }
    public bool RecursiveList { get; public set; }
    public IPEndPoint SocketLocalEndPoint { get; }
    public IPEndPoint SocketRemoteEndPoint { get; }
    public BaseFtpClient(FtpConfig config);
    protected long CalculateAppendLocalPosition(string remotePath, FtpRemoteExists existsMode, long remotePosition);
    protected int CalculateTransferChunkSize(long rateLimitBytes, int rateControlResolution);
    protected bool CanUploadFile(FtpResult result, FtpListItem[] remoteListing, FtpRemoteExists existsMode, FtpRemoteExists& existsModeToUse);
    protected Nullable`1<bool> CheckFileExistsBySize(FtpSizeReply sizeReply);
    protected bool SupportsChecksum();
    protected void ValidateChecksumAlgorithm(FtpHashAlgorithm algorithm);
    protected static string CleanHashResult(string path, string response);
    protected FtpHashAlgorithm GetFirstMutualChecksum(BaseFtpClient destination);
    private sealed virtual override FtpReply FluentFTP.IInternalFtpClient.CloseDataStreamInternal(FtpDataStream stream);
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<FluentFTP-IInternalFtpClient-CloseDataStreamInternal>d__9")]
private sealed virtual override Task`1<FtpReply> FluentFTP.IInternalFtpClient.CloseDataStreamInternal(FtpDataStream stream, CancellationToken token);
    private sealed virtual override void FluentFTP.IInternalFtpClient.ConnectInternal(bool reConnect);
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<FluentFTP-IInternalFtpClient-ConnectInternal>d__11")]
private sealed virtual override Task FluentFTP.IInternalFtpClient.ConnectInternal(bool reConnect, CancellationToken token);
    public DateTime ConvertDate(DateTime date, bool reverse);
    protected void DeleteExtraLocalFiles(string localFolder, FtpFolderSyncMode mode, Dictionary`2<string, bool> shouldExist, List`1<FtpRule> rules);
    protected bool CanDeleteLocalFile(List`1<FtpRule> rules, string existingLocalFile);
    private sealed virtual override void FluentFTP.IInternalFtpClient.DisconnectInternal();
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<FluentFTP-IInternalFtpClient-DisconnectInternal>d__16")]
private sealed virtual override Task FluentFTP.IInternalFtpClient.DisconnectInternal(CancellationToken token);
    private sealed virtual override void FluentFTP.IInternalFtpClient.DisposeInternal();
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<FluentFTP-IInternalFtpClient-DisposeInternal>d__18")]
private sealed virtual override Task FluentFTP.IInternalFtpClient.DisposeInternal(CancellationToken token);
    private sealed virtual override FtpReply FluentFTP.IInternalFtpClient.ExecuteInternal(string command);
    protected void OnPostExecute(string command);
    protected virtual void GetFeatures(FtpReply reply);
    public void SetFeatures(List`1<FtpCapability> capabilities);
    public sealed virtual bool HasFeature(FtpCapability cap);
    protected bool FilePassesRules(FtpResult result, List`1<FtpRule> rules, bool useLocalPath, FtpListItem item);
    protected List`1<FtpResult> GetFilesToDownload(string localFolder, string remoteFolder, List`1<FtpRule> rules, List`1<FtpResult> results, FtpListItem[] listing, Dictionary`2<string, bool> shouldExist);
    protected List`1<FtpResult> GetFilesToDownload2(string localFolder, IEnumerable`1<string> remotePaths, List`1<FtpRule> rules, List`1<FtpResult> results, Dictionary`2<string, bool> shouldExist);
    protected void RecordFileToDownload(List`1<FtpRule> rules, List`1<FtpResult> results, Dictionary`2<string, bool> shouldExist, List`1<FtpResult> toDownload, FtpListItem remoteFile, string localFile, string remoteFilePath);
    protected List`1<FtpResult> GetFilesToUpload(string localFolder, string remoteFolder, List`1<FtpRule> rules, List`1<FtpResult> results, Dictionary`2<string, bool> shouldExist, String[] fileListing);
    protected void RecordFileToUpload(List`1<FtpRule> rules, List`1<FtpResult> results, Dictionary`2<string, bool> shouldExist, List`1<FtpResult> filesToUpload, string localFile, string remoteFile);
    protected void GetEnhancedPassivePort(FtpReply reply, String& derivedIpad, Int32& advertisedPort);
    protected void GetPassivePort(FtpDataConnectionType type, FtpReply reply, String& host, Int32& port);
    protected string GetLocalAddress(IPAddress ipad);
    private sealed virtual override FtpReply FluentFTP.IInternalFtpClient.GetReplyInternal();
    private sealed virtual override FtpReply FluentFTP.IInternalFtpClient.GetReplyInternal(string command);
    private sealed virtual override FtpReply FluentFTP.IInternalFtpClient.GetReplyInternal(string command, bool exhaustNoop);
    private sealed virtual override FtpReply FluentFTP.IInternalFtpClient.GetReplyInternal(string command, bool exhaustNoop, int timeOut);
    private sealed virtual override FtpReply FluentFTP.IInternalFtpClient.GetReplyInternal(string command, bool exhaustNoop, int timeOut, bool useSema);
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<FluentFTP-IInternalFtpClient-GetReplyInternal>d__38")]
private sealed virtual override Task`1<FtpReply> FluentFTP.IInternalFtpClient.GetReplyInternal(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<FluentFTP-IInternalFtpClient-GetReplyInternal>d__39")]
private sealed virtual override Task`1<FtpReply> FluentFTP.IInternalFtpClient.GetReplyInternal(CancellationToken token, string command);
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<FluentFTP-IInternalFtpClient-GetReplyInternal>d__40")]
private sealed virtual override Task`1<FtpReply> FluentFTP.IInternalFtpClient.GetReplyInternal(CancellationToken token, string command, bool exhaustNoop);
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<FluentFTP-IInternalFtpClient-GetReplyInternal>d__41")]
private sealed virtual override Task`1<FtpReply> FluentFTP.IInternalFtpClient.GetReplyInternal(CancellationToken token, string command, bool exhaustNoop, int timeOut);
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<FluentFTP-IInternalFtpClient-GetReplyInternal>d__42")]
private sealed virtual override Task`1<FtpReply> FluentFTP.IInternalFtpClient.GetReplyInternal(CancellationToken token, string command, bool exhaustNoop, int timeOut, bool useSema);
    protected FtpReply ProcessGetReply(FtpReply reply, string command);
    protected static bool DecodeStringToReply(string text, FtpReply& reply);
    protected List`1<FtpResult> GetSubDirectoriesToTransfer(string sourceFolder, string remoteFolder, List`1<FtpRule> rules, List`1<FtpResult> results, String[] dirListing);
    protected List`1<FtpResult> GetSubDirectoriesToUpload(string localFolder, string remoteFolder, List`1<FtpRule> rules, List`1<FtpResult> results, String[] dirListing);
    protected bool CanDeleteRemoteFile(List`1<FtpRule> rules, FtpListItem existingServerFile);
    private sealed virtual override string FluentFTP.IInternalFtpClient.GetWorkingDirectoryInternal();
    protected FtpReply ReadCurrentWorkingDirectory();
    protected string ParseWorkingDirectory(FtpReply reply);
    public bool IsProxy();
    private sealed virtual override bool FluentFTP.IInternalFtpClient.IsStillConnectedInternal(int timeout);
    protected bool WasGetListingRecursive(FtpListOption options);
    protected bool LoadBasicListingInfo(String& path, FtpListItem& item, List`1<FtpListItem> lst, List`1<string> rawlisting, Int32& i, string listcmd, string buf, bool isRecursive, bool isIncludeSelf, bool machineList);
    protected bool IsItemSelf(string path, FtpListItem item);
    protected void CalculateGetListingCommand(string path, FtpListOption options, String& listcmd, Boolean& machineList);
    protected bool IsServerSideRecursionSupported(FtpListOption options);
    public void LoadProfile(FtpProfile profile);
    protected void LogVersion();
    protected void LogFunction(string function, object args);
    protected void LogFunction(string function, Object[] args);
    protected void Log(FtpTraceLevel eventType, string message);
    protected void LogWithPrefix(FtpTraceLevel eventType, string message, Exception exception, bool exNewLine);
    protected void LogToDebugOrConsole(string message);
    private sealed virtual override void FluentFTP.IInternalFtpClient.LogLine(FtpTraceLevel eventType, string message);
    private sealed virtual override void FluentFTP.IInternalFtpClient.LogStatus(FtpTraceLevel eventType, string message, Exception exception, bool exNewLine);
    private bool AnyLoggingIsEnabled();
    private sealed virtual override bool FluentFTP.IInternalFtpClient.NoopInternal(bool ignoreNoopInterval);
    protected void NoopDaemon(CancellationToken ct);
    public sealed virtual IFtpLogger get_Logger();
    public sealed virtual void set_Logger(IFtpLogger value);
    public sealed virtual Action`2<FtpTraceLevel, string> get_LegacyLogger();
    public sealed virtual void set_LegacyLogger(Action`2<FtpTraceLevel, string> value);
    public sealed virtual FtpConfig get_Config();
    public sealed virtual void set_Config(FtpConfig value);
    public sealed virtual FtpBaseServer get_ServerHandler();
    public sealed virtual void set_ServerHandler(FtpBaseServer value);
    public sealed virtual Encoding get_Encoding();
    public sealed virtual void set_Encoding(Encoding value);
    public string get_ClientType();
    public sealed virtual FtpClientState get_Status();
    private sealed virtual override FtpSocketStream FluentFTP.IInternalFtpClient.GetBaseStream();
    private sealed virtual override void FluentFTP.IInternalFtpClient.SetListingParser(FtpParser parser);
    public sealed virtual bool get_IsDisposed();
    protected void set_IsDisposed(bool value);
    public sealed virtual Nullable`1<FtpIpVersion> get_InternetProtocol();
    public sealed virtual bool get_IsConnected();
    public sealed virtual bool get_IsAuthenticated();
    protected bool get_IsClone();
    public sealed virtual string get_Host();
    public sealed virtual void set_Host(string value);
    public sealed virtual int get_Port();
    public sealed virtual void set_Port(int value);
    public sealed virtual NetworkCredential get_Credentials();
    public sealed virtual void set_Credentials(NetworkCredential value);
    public sealed virtual List`1<FtpCapability> get_Capabilities();
    protected void set_Capabilities(List`1<FtpCapability> value);
    public sealed virtual FtpHashAlgorithm get_HashAlgorithms();
    protected void set_HashAlgorithms(FtpHashAlgorithm value);
    public sealed virtual bool get_IsEncrypted();
    public sealed virtual bool get_ValidateCertificateHandlerExists();
    public sealed virtual void add_ValidateCertificate(FtpSslValidation value);
    public sealed virtual void remove_ValidateCertificate(FtpSslValidation value);
    public sealed virtual string get_SystemType();
    public sealed virtual FtpServer get_ServerType();
    public sealed virtual FtpOperatingSystem get_ServerOS();
    public sealed virtual string get_ConnectionType();
    protected void set_ConnectionType(string value);
    public sealed virtual FtpReply get_LastReply();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<FtpReply> get_LastReplies();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LastReplies(List`1<FtpReply> value);
    public sealed virtual bool get_RecursiveList();
    public void set_RecursiveList(bool value);
    public sealed virtual IPEndPoint get_SocketLocalEndPoint();
    public sealed virtual IPEndPoint get_SocketRemoteEndPoint();
    protected string ReadStaleData(string logFrom);
    [AsyncStateMachineAttribute("FluentFTP.Client.BaseClient.BaseFtpClient/<ReadStaleDataAsync>d__176")]
protected Task`1<string> ReadStaleDataAsync(string logFrom, CancellationToken token);
    protected void ReportProgress(IProgress`1<FtpProgress> progress, long fileSize, long position, long bytesProcessed, TimeSpan elapsedtime, string localPath, string remotePath, FtpProgress metaProgress);
    protected void ReportProgress(Action`1<FtpProgress> progress, long fileSize, long position, long bytesProcessed, TimeSpan elapsedtime, string localPath, string remotePath, FtpProgress metaProgress);
    protected void StartListeningOnPort(FtpDataStream stream);
    protected void ValidateAutoDetect();
    protected void FireValidateCertficate(FtpSocketStream stream, FtpSslValidationEventArgs e);
    protected void OnValidateCertficate(FtpSslValidationEventArgs e);
    protected void VerifyTransferFileParams(string sourcePath, BaseFtpClient remoteClient, string remotePath, FtpRemoteExists existsMode);
    protected virtual BaseFtpClient Create();
    public BaseFtpClient Clone();
    private static void CloneClient(BaseFtpClient read, BaseFtpClient write);
    public void AutoDispose();
    public void WaitForDaemonTermination();
    public virtual void Dispose();
}
internal static class FluentFTP.Client.Modules.ConnectModule : object {
    private static List`1<FtpEncryptionMode> DefaultEncryptionsPriority;
    private static ConnectModule();
    public static List`1<FtpProfile> AutoDetect(FtpClient client, FtpAutoDetectConfig config);
    [AsyncStateMachineAttribute("FluentFTP.Client.Modules.ConnectModule/<AutoDetectAsync>d__2")]
public static Task`1<List`1<FtpProfile>> AutoDetectAsync(AsyncFtpClient client, FtpAutoDetectConfig config, CancellationToken token);
    private static void SaveResult(List`1<FtpProfile> results, FtpProfile knownProfile, List`1<FtpEncryptionMode> blacklistedEncryptions, BaseFtpClient conn, FtpEncryptionMode encryption, SslProtocols protocol, FtpDataConnectionType dataConn);
    private static void ConfigureClient(BaseFtpClient client, FtpEncryptionMode encryption, SslProtocols protocol, FtpProfile knownProfile);
    private static bool IsFtpsFailure(List`1<FtpEncryptionMode> blacklistedEncryptions, FtpEncryptionMode encryption, Exception ex);
    private static bool IsConnectedButFtpsFailure(List`1<FtpEncryptionMode> blacklistedEncryptions, FtpEncryptionMode encryption, bool failedFTPS);
    private static Exception IsPermanentConnectionFailure(Exception ex, bool treatTimeoutAsPermanent);
    private static FtpDataConnectionType AutoDataConnection(BaseFtpClient conn);
    public static void LoadProfile(BaseFtpClient client, FtpProfile profile);
    public static void SetDefaultCertificateValidation(BaseFtpClient client, FtpProfile profile);
    public static FtpProfile GetWorkingProfileFromHost(string host, List`1<FtpEncryptionMode> encryptionsPriority, List`1& encryptionsToTry);
    public static bool CheckCriticalSingleCommand(BaseFtpClient client, string cmd);
    public static void CheckCriticalCommandSequence(BaseFtpClient client, string cmd);
}
internal static class FluentFTP.Client.Modules.LogMaskModule : object {
    public static string MaskCommand(BaseFtpClient client, string command);
    public static string MaskReply(BaseFtpClient client, FtpReply reply, string message, string command);
}
internal static class FluentFTP.Client.Modules.ServerFeatureModule : object {
    public static void Detect(List`1<FtpCapability> capabilities, FtpHashAlgorithm& hashAlgorithms, String[] features);
    public static void Assume(FtpBaseServer handler, List`1<FtpCapability> capabilities, FtpHashAlgorithm& hashAlgorithms);
}
internal static class FluentFTP.Client.Modules.ServerModule : object {
    public static FtpServer DetectFtpServer(BaseFtpClient client, FtpReply handshakeReply);
    public static FtpBaseServer GetServerHandler(FtpServer value);
    public static FtpOperatingSystem DetectFtpOSBySyst(BaseFtpClient client);
    public static FtpServer DetectFtpServerBySyst(BaseFtpClient client);
}
internal static class FluentFTP.Client.Modules.ServerStringModule : object {
    public static String[] fileNotFound;
    public static String[] fileSizeNotInASCII;
    public static String[] unexpectedEOF;
    public static String[] folderExists;
    public static String[] failedTLS;
    public static String[] criticalSingleCommands;
    public static String[] criticalStartingCommands;
    public static String[] criticalTerminatingCommands;
    private static ServerStringModule();
}
public class FluentFTP.CustomRemoteCertificateValidationCallback : MulticastDelegate {
    public CustomRemoteCertificateValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(object sender, X509Certificate certificate, X509Chain chain, string errorMessage);
    public virtual IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, string errorMessage, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class FluentFTP.Exceptions.FtpAuthenticationException : FtpCommandException {
    public FtpAuthenticationException(string code, string message);
    public FtpAuthenticationException(FtpReply reply);
    protected FtpAuthenticationException(SerializationInfo info, StreamingContext context);
}
public class FluentFTP.Exceptions.FtpCommandException : FtpException {
    private string _code;
    public string CompletionCode { get; private set; }
    public FtpResponseType ResponseType { get; }
    public string Message { get; }
    public FtpCommandException(string code, string message);
    public FtpCommandException(FtpReply reply);
    protected FtpCommandException(SerializationInfo info, StreamingContext context);
    public string get_CompletionCode();
    private void set_CompletionCode(string value);
    public FtpResponseType get_ResponseType();
    public virtual string get_Message();
}
public class FluentFTP.Exceptions.FtpException : Exception {
    public FtpException(string message);
    public FtpException(string message, Exception innerException);
    protected FtpException(SerializationInfo info, StreamingContext context);
}
public class FluentFTP.Exceptions.FtpHashUnsupportedException : FtpException {
    private FtpHashAlgorithm _algo;
    public FtpHashAlgorithm Algorithm { get; private set; }
    public FtpHashUnsupportedException(FtpHashAlgorithm algo, string specialCommands);
    protected FtpHashUnsupportedException(SerializationInfo info, StreamingContext context);
    public FtpHashAlgorithm get_Algorithm();
    private void set_Algorithm(FtpHashAlgorithm value);
}
public class FluentFTP.Exceptions.FtpInvalidCertificateException : FtpException {
    [CompilerGeneratedAttribute]
private Exception <InnerException>k__BackingField;
    public Exception InnerException { get; private set; }
    public FtpInvalidCertificateException(Exception innerException);
    public FtpInvalidCertificateException(string message);
    protected FtpInvalidCertificateException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Exception get_InnerException();
    [CompilerGeneratedAttribute]
private void set_InnerException(Exception value);
}
public class FluentFTP.Exceptions.FtpListParseException : FtpException {
    protected FtpListParseException(SerializationInfo info, StreamingContext context);
}
public class FluentFTP.Exceptions.FtpMissingObjectException : FtpException {
    [CompilerGeneratedAttribute]
private FtpObjectType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    public FtpObjectType Type { get; public set; }
    public string FullPath { get; public set; }
    public string Name { get; }
    public FtpMissingObjectException(string message, Exception innerException, string fullPath, FtpObjectType type);
    protected FtpMissingObjectException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public FtpObjectType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(FtpObjectType value);
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
public void set_FullPath(string value);
    public string get_Name();
}
public class FluentFTP.Exceptions.FtpMissingSocketException : FtpException {
    public FtpMissingSocketException(Exception innerException);
    protected FtpMissingSocketException(SerializationInfo info, StreamingContext context);
}
public class FluentFTP.Exceptions.FtpProtocolUnsupportedException : FtpException {
    public FtpProtocolUnsupportedException(string message);
}
public class FluentFTP.Exceptions.FtpProxyException : FtpException {
    public FtpProxyException(string message);
    public FtpProxyException(string message, Exception inner);
}
public class FluentFTP.Exceptions.FtpSecurityNotAvailableException : FtpException {
    public FtpSecurityNotAvailableException(string message);
    protected FtpSecurityNotAvailableException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class FluentFTP.Exceptions.IOExceptions : object {
    [ExtensionAttribute]
public static bool IsResumeAllowed(IOException exception);
}
[FlagsAttribute]
public enum FluentFTP.FtpCapability : Enum {
    public int value__;
    public static FtpCapability NONE;
    public static FtpCapability MLST;
    public static FtpCapability SIZE;
    public static FtpCapability MDTM;
    public static FtpCapability REST;
    public static FtpCapability UTF8;
    public static FtpCapability PRET;
    public static FtpCapability MFMT;
    public static FtpCapability MFCT;
    public static FtpCapability MFF;
    public static FtpCapability STAT;
    public static FtpCapability HASH;
    public static FtpCapability MD5;
    public static FtpCapability XMD5;
    public static FtpCapability XCRC;
    public static FtpCapability XSHA1;
    public static FtpCapability XSHA256;
    public static FtpCapability XSHA512;
    public static FtpCapability EPSV;
    public static FtpCapability CPSV;
    public static FtpCapability NOOP;
    public static FtpCapability CLNT;
    public static FtpCapability SSCN;
    public static FtpCapability SITE_MKDIR;
    public static FtpCapability SITE_RMDIR;
    public static FtpCapability SITE_UTIME;
    public static FtpCapability SITE_SYMLINK;
    public static FtpCapability AVBL;
    public static FtpCapability THMB;
    public static FtpCapability RMDA;
    public static FtpCapability DSIZ;
    public static FtpCapability HOST;
    public static FtpCapability CCC;
    public static FtpCapability MODE_Z;
    public static FtpCapability LANG;
    public static FtpCapability MMD5;
}
public class FluentFTP.FtpClient : BaseFtpClient {
    public FtpClient(string host, int port, FtpConfig config, IFtpLogger logger);
    public FtpClient(string host, string user, string pass, int port, FtpConfig config, IFtpLogger logger);
    public FtpClient(string host, NetworkCredential credentials, int port, FtpConfig config, IFtpLogger logger);
    protected virtual BaseFtpClient Create();
    protected virtual void Authenticate();
    protected virtual void Authenticate(string userName, string password, string account);
    public sealed virtual FtpProfile AutoConnect();
    public sealed virtual List`1<FtpProfile> AutoDetect(FtpAutoDetectConfig config);
    public sealed virtual List`1<FtpProfile> AutoDetect(bool firstOnly, bool cloneConnection);
    public sealed virtual void Chmod(string path, FtpPermission owner, FtpPermission group, FtpPermission other);
    public sealed virtual void Chmod(string path, int permissions);
    public sealed virtual FtpCompareResult CompareFile(string localPath, string remotePath, FtpCompareOption options);
    public virtual void Connect();
    public sealed virtual void Connect(FtpProfile profile);
    public virtual void Connect(bool reConnect);
    protected virtual void Connect(FtpSocketStream stream);
    protected virtual void Connect(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions);
    public sealed virtual bool CreateDirectory(string path);
    public sealed virtual bool CreateDirectory(string path, bool force);
    public sealed virtual void DeleteDirectory(string path);
    public sealed virtual void DeleteDirectory(string path, FtpListOption options);
    protected void DeleteDirInternal(string path, bool deleteContents, FtpListOption options, bool deleteFinalDir, bool firstCall);
    public sealed virtual void DeleteFile(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual void DisableUTF8();
    public sealed virtual void Disconnect();
    public int DiscoverSslSessionLength(string command, int maxTries);
    public sealed virtual bool DownloadBytes(Byte[]& outBytes, string remotePath, long restartPosition, Action`1<FtpProgress> progress, long stopPosition);
    public sealed virtual List`1<FtpResult> DownloadDirectory(string localFolder, string remoteFolder, FtpFolderSyncMode mode, FtpLocalExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, Action`1<FtpProgress> progress);
    protected void DownloadServerFiles(List`1<FtpResult> toDownload, FtpLocalExists existsMode, FtpVerify verifyOptions, Action`1<FtpProgress> progress);
    public sealed virtual FtpStatus DownloadFile(string localPath, string remotePath, FtpLocalExists existsMode, FtpVerify verifyOptions, Action`1<FtpProgress> progress);
    protected FtpStatus DownloadFileToFile(string localPath, string remotePath, FtpLocalExists existsMode, FtpVerify verifyOptions, Action`1<FtpProgress> progress, FtpProgress metaProgress);
    protected bool DownloadFileInternal(string localPath, string remotePath, Stream outStream, long restartPosition, Action`1<FtpProgress> progress, FtpProgress metaProgress, long knownFileSize, bool isAppend, long stopPosition);
    protected bool ResumeDownload(string remotePath, Stream& downStream, long offset, IOException ex);
    public sealed virtual List`1<FtpResult> DownloadFiles(string localDir, IEnumerable`1<string> remotePaths, FtpLocalExists existsMode, FtpVerify verifyOptions, FtpError errorHandling, Action`1<FtpProgress> progress, List`1<FtpRule> rules);
    protected void PurgeSuccessfulDownloads(IEnumerable`1<string> localFiles);
    public sealed virtual bool DownloadStream(Stream outStream, string remotePath, long restartPosition, Action`1<FtpProgress> progress, long stopPosition);
    public sealed virtual bool DownloadUriBytes(Byte[]& outBytes, string uri, Action`1<FtpProgress> progress);
    public sealed virtual void EmptyDirectory(string path);
    public sealed virtual void EmptyDirectory(string path, FtpListOption options);
    public sealed virtual FtpReply Execute(string command);
    public sealed virtual List`1<string> ExecuteDownloadText(string command);
    protected List`1<string> ExecuteDownloadTextInternal(string command, bool retry);
    public sealed virtual bool FileExists(string path);
    protected string GetAbsoluteDir(string path);
    protected string GetAbsoluteFilePath(string path, string fileName);
    protected string GetAbsolutePath(string path);
    public sealed virtual FtpHash GetChecksum(string remotePath, FtpHashAlgorithm algorithm);
    internal void SetHashAlgorithmInternal(FtpHashAlgorithm algorithm);
    internal string GetHashInternal(string remotePath, string command);
    protected FtpHash HashCommandInternal(string remotePath);
    public sealed virtual int GetChmod(string path);
    public sealed virtual FtpListItem GetFilePermissions(string path);
    public virtual long GetFileSize(string path, long defaultValue);
    protected void GetFileSizeInternal(string path, FtpSizeReply sizeReply, long defaultValue);
    public sealed virtual FtpListItem[] GetListing();
    public sealed virtual FtpListItem[] GetListing(string path);
    public sealed virtual FtpListItem[] GetListing(string path, FtpListOption options);
    protected List`1<string> GetListingInternal(string listcmd, FtpListOption options, bool retry);
    protected FtpListItem[] GetListingRecursive(string path, FtpListOption options);
    public virtual DateTime GetModifiedTime(string path);
    public sealed virtual String[] GetNameListing();
    public sealed virtual String[] GetNameListing(string path);
    public sealed virtual FtpListItem GetObjectInfo(string path, bool dateModified);
    public sealed virtual FtpReply GetReply();
    public sealed virtual string GetWorkingDirectory();
    public FtpZOSListRealm GetZOSListRealm();
    protected virtual void Handshake();
    public bool IsRoot();
    public bool IsStillConnected(int timeout);
    public sealed virtual bool MoveDirectory(string path, string dest, FtpRemoteExists existsMode);
    public sealed virtual bool MoveFile(string path, string dest, FtpRemoteExists existsMode);
    public bool Noop(bool ignoreNoopInterval);
    protected FtpDataStream OpenActiveDataStream(FtpDataConnectionType type, string command, long restart);
    public virtual Stream OpenAppend(string path, FtpDataType type, bool checkIfFileExists);
    public virtual Stream OpenAppend(string path, FtpDataType type, long fileLen);
    public virtual Stream OpenAppendInternal(string path, FtpDataType type, long fileLen, bool ignoreStaleData);
    protected FtpDataStream OpenDataStream(string command, long restart);
    protected FtpFxpSession OpenPassiveFXPConnection(FtpClient remoteClient, bool progress);
    protected FtpDataStream OpenPassiveDataStream(FtpDataConnectionType type, string command, long restart);
    public virtual Stream OpenRead(string path, FtpDataType type, long restart, bool checkIfFileExists);
    public virtual Stream OpenRead(string path, FtpDataType type, long restart, long fileLen);
    public virtual Stream OpenReadInternal(string path, FtpDataType type, long fileLen, long restart, bool ignoreStaleData);
    public virtual Stream OpenWrite(string path, FtpDataType type, bool checkIfFileExists);
    public virtual Stream OpenWrite(string path, FtpDataType type, long fileLen);
    public virtual Stream OpenWriteInternal(string path, FtpDataType type, long fileLen, bool ignoreStaleData);
    public sealed virtual void Rename(string path, string dest);
    protected void SetDataType(FtpDataType type);
    public sealed virtual void SetFilePermissions(string path, FtpPermission owner, FtpPermission group, FtpPermission other);
    public sealed virtual void SetFilePermissions(string path, int permissions);
    public virtual void SetModifiedTime(string path, DateTime date);
    public sealed virtual void SetWorkingDirectory(string path);
    public List`1<FtpResult> TransferDirectory(string sourceFolder, FtpClient remoteClient, string remoteFolder, FtpFolderSyncMode mode, FtpRemoteExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, Action`1<FtpProgress> progress);
    protected List`1<FtpResult> GetFilesToTransfer(string sourceFolder, string remoteFolder, List`1<FtpRule> rules, List`1<FtpResult> results, Dictionary`2<string, bool> shouldExist, String[] fileListing);
    protected void TransferServerFiles(List`1<FtpResult> filesToTransfer, FtpClient remoteClient, FtpRemoteExists existsMode, FtpVerify verifyOptions, Action`1<FtpProgress> progress, FtpListItem[] remoteListing);
    public FtpStatus TransferFile(string sourcePath, FtpClient remoteClient, string remotePath, bool createRemoteDir, FtpRemoteExists existsMode, FtpVerify verifyOptions, Action`1<FtpProgress> progress, FtpProgress metaProgress);
    protected bool TransferFileFXPInternal(string sourcePath, FtpClient remoteClient, string remotePath, bool createRemoteDir, FtpRemoteExists existsMode, Action`1<FtpProgress> progress, FtpProgress metaProgress);
    public sealed virtual FtpStatus UploadBytes(Byte[] fileData, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, Action`1<FtpProgress> progress);
    public sealed virtual List`1<FtpResult> UploadDirectory(string localFolder, string remoteFolder, FtpFolderSyncMode mode, FtpRemoteExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, Action`1<FtpProgress> progress);
    protected void CreateSubDirectories(FtpClient client, List`1<FtpResult> dirsToUpload);
    protected void UploadDirectoryFiles(List`1<FtpResult> filesToUpload, FtpRemoteExists existsMode, FtpVerify verifyOptions, Action`1<FtpProgress> progress, FtpListItem[] remoteListing);
    protected void DeleteExtraServerFiles(FtpFolderSyncMode mode, string remoteFolder, Dictionary`2<string, bool> shouldExist, FtpListItem[] remoteListing, List`1<FtpRule> rules);
    public sealed virtual FtpStatus UploadFile(string localPath, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, Action`1<FtpProgress> progress);
    protected FtpStatus UploadFileFromFile(string localPath, string remotePath, bool createRemoteDir, FtpRemoteExists existsMode, bool fileExists, bool fileExistsKnown, FtpVerify verifyOptions, Action`1<FtpProgress> progress, FtpProgress metaProgress);
    protected FtpStatus UploadFileInternal(Stream fileData, string localPath, string remotePath, bool createRemoteDir, FtpRemoteExists existsMode, bool fileExists, bool fileExistsKnown, Action`1<FtpProgress> progress, FtpProgress metaProgress);
    protected bool ResumeUpload(string remotePath, Stream& upStream, long remotePosition, IOException ex);
    public sealed virtual List`1<FtpResult> UploadFiles(IEnumerable`1<string> localPaths, string remoteDir, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, FtpError errorHandling, Action`1<FtpProgress> progress, List`1<FtpRule> rules);
    protected void PurgeSuccessfulUploads(IEnumerable`1<string> remotePaths);
    public sealed virtual List`1<FtpResult> UploadFiles(IEnumerable`1<FileInfo> localFiles, string remoteDir, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, FtpError errorHandling, Action`1<FtpProgress> progress, List`1<FtpRule> rules);
    protected List`1<FtpResult> GetFilesToUpload2(IEnumerable`1<string> localFiles, string remoteDir, List`1<FtpRule> rules, List`1<FtpResult> results, Dictionary`2<string, bool> shouldExist);
    public sealed virtual FtpStatus UploadStream(Stream fileStream, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, Action`1<FtpProgress> progress);
    protected bool VerifyFXPTransfer(string sourcePath, FtpClient fxpDestinationClient, string remotePath);
    protected bool VerifyTransfer(string localPath, string remotePath);
    [CompilerGeneratedAttribute]
private void <Connect>b__15_0();
}
public class FluentFTP.FtpClientState : object {
    [CompilerGeneratedAttribute]
private bool <EPSVNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileSizeASCIINotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecursiveListSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoDispose>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastWorkingDir>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpHashAlgorithm <LastHashAlgo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConnectionFTPSFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConnectionUTF8Success>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpDataType <CurrentDataType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCheckStaleData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InCriticalSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreStaleData>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IPAddress[]> <CachedHostIpads>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpZOSListRealm <zOSListingRealm>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <zOSListingLRECL>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <NoopDaemonTask>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationTokenSource <NoopDaemonTokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoopDaemonEnable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NoopDaemonAnyNoops>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoopDaemonCmdMode>k__BackingField;
    public bool EPSVNotSupported { get; public set; }
    public bool FileSizeASCIINotSupported { get; public set; }
    public bool RecursiveListSupported { get; public set; }
    public bool AutoDispose { get; public set; }
    public string LastWorkingDir { get; public set; }
    public FtpHashAlgorithm LastHashAlgo { get; public set; }
    public bool ConnectionFTPSFailure { get; public set; }
    public bool ConnectionUTF8Success { get; public set; }
    public FtpDataType CurrentDataType { get; public set; }
    public bool AllowCheckStaleData { get; public set; }
    public bool InCriticalSequence { get; public set; }
    public int ConnectCount { get; public set; }
    public bool IgnoreStaleData { get; public set; }
    public Dictionary`2<string, IPAddress[]> CachedHostIpads { get; public set; }
    public FtpZOSListRealm zOSListingRealm { get; public set; }
    public ushort zOSListingLRECL { get; public set; }
    public Task NoopDaemonTask { get; public set; }
    public CancellationTokenSource NoopDaemonTokenSource { get; public set; }
    public bool NoopDaemonEnable { get; public set; }
    public int NoopDaemonAnyNoops { get; public set; }
    public bool NoopDaemonCmdMode { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EPSVNotSupported();
    [CompilerGeneratedAttribute]
public void set_EPSVNotSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_FileSizeASCIINotSupported();
    [CompilerGeneratedAttribute]
public void set_FileSizeASCIINotSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_RecursiveListSupported();
    [CompilerGeneratedAttribute]
public void set_RecursiveListSupported(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoDispose();
    [CompilerGeneratedAttribute]
public void set_AutoDispose(bool value);
    [CompilerGeneratedAttribute]
public string get_LastWorkingDir();
    [CompilerGeneratedAttribute]
public void set_LastWorkingDir(string value);
    [CompilerGeneratedAttribute]
public FtpHashAlgorithm get_LastHashAlgo();
    [CompilerGeneratedAttribute]
public void set_LastHashAlgo(FtpHashAlgorithm value);
    [CompilerGeneratedAttribute]
public bool get_ConnectionFTPSFailure();
    [CompilerGeneratedAttribute]
public void set_ConnectionFTPSFailure(bool value);
    [CompilerGeneratedAttribute]
public bool get_ConnectionUTF8Success();
    [CompilerGeneratedAttribute]
public void set_ConnectionUTF8Success(bool value);
    [CompilerGeneratedAttribute]
public FtpDataType get_CurrentDataType();
    [CompilerGeneratedAttribute]
public void set_CurrentDataType(FtpDataType value);
    [CompilerGeneratedAttribute]
public bool get_AllowCheckStaleData();
    [CompilerGeneratedAttribute]
public void set_AllowCheckStaleData(bool value);
    [CompilerGeneratedAttribute]
public bool get_InCriticalSequence();
    [CompilerGeneratedAttribute]
public void set_InCriticalSequence(bool value);
    [CompilerGeneratedAttribute]
public int get_ConnectCount();
    [CompilerGeneratedAttribute]
public void set_ConnectCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreStaleData();
    [CompilerGeneratedAttribute]
public void set_IgnoreStaleData(bool value);
    public void Reset(bool reConnect);
    public void CopyFrom(FtpClientState original);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IPAddress[]> get_CachedHostIpads();
    [CompilerGeneratedAttribute]
public void set_CachedHostIpads(Dictionary`2<string, IPAddress[]> value);
    [CompilerGeneratedAttribute]
public FtpZOSListRealm get_zOSListingRealm();
    [CompilerGeneratedAttribute]
public void set_zOSListingRealm(FtpZOSListRealm value);
    [CompilerGeneratedAttribute]
public ushort get_zOSListingLRECL();
    [CompilerGeneratedAttribute]
public void set_zOSListingLRECL(ushort value);
    [CompilerGeneratedAttribute]
public Task get_NoopDaemonTask();
    [CompilerGeneratedAttribute]
public void set_NoopDaemonTask(Task value);
    [CompilerGeneratedAttribute]
public CancellationTokenSource get_NoopDaemonTokenSource();
    [CompilerGeneratedAttribute]
public void set_NoopDaemonTokenSource(CancellationTokenSource value);
    [CompilerGeneratedAttribute]
public bool get_NoopDaemonEnable();
    [CompilerGeneratedAttribute]
public void set_NoopDaemonEnable(bool value);
    [CompilerGeneratedAttribute]
public int get_NoopDaemonAnyNoops();
    [CompilerGeneratedAttribute]
public void set_NoopDaemonAnyNoops(int value);
    [CompilerGeneratedAttribute]
public bool get_NoopDaemonCmdMode();
    [CompilerGeneratedAttribute]
public void set_NoopDaemonCmdMode(bool value);
}
[FlagsAttribute]
public enum FluentFTP.FtpCompareOption : Enum {
    public int value__;
    public static FtpCompareOption Auto;
    public static FtpCompareOption Size;
    public static FtpCompareOption DateModified;
    public static FtpCompareOption Checksum;
}
public enum FluentFTP.FtpCompareResult : Enum {
    public int value__;
    public static FtpCompareResult Equal;
    public static FtpCompareResult NotEqual;
    public static FtpCompareResult FileNotExisting;
    public static FtpCompareResult ChecksumNotSupported;
}
public class FluentFTP.FtpConfig : object {
    private BaseFtpClient _client;
    [CompilerGeneratedAttribute]
private bool <LogToConsole>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogHost>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogUserName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogDurations>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpIpVersion <InternetProtocolVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StaleDataCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Noop>k__BackingField;
    private int _noopInterval;
    private List`1<string> _noopInactiveCmds;
    private List`1<string> _noopActiveCommands;
    [CompilerGeneratedAttribute]
private bool <NoopTestConnectivity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<string> <AddressResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<int> <ActivePorts>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<int> <PassiveBlockedPorts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PassiveMaxAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpDataConnectionType <DataConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisconnectWithQuit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataConnectionConnectTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataConnectionReadTimeout>k__BackingField;
    protected bool _keepAlive;
    [CompilerGeneratedAttribute]
private FtpEncryptionMode <EncryptionMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DataConnectionEncryption>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <SslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SslSessionLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAnyCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateCertificateRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpNavigate <Navigate>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpDataType <ListingDataType>k__BackingField;
    protected FtpParser _parser;
    [CompilerGeneratedAttribute]
private CultureInfo <ListingCulture>k__BackingField;
    protected CustomParser _customParser;
    protected double _serverTimeZone;
    protected TimeSpan _serverTimeOffset;
    [CompilerGeneratedAttribute]
private FtpDate <TimeConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BulkListing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BulkListingLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransferChunkSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocalFileBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FileShare <LocalFileShareOption>k__BackingField;
    protected int _retryAttempts;
    [CompilerGeneratedAttribute]
private FtpVerifyMethod <VerifyMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UploadRateLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DownloadRateLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DownloadZeroByteFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpDataType <UploadDataType>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpDataType <DownloadDataType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UploadDirectoryDeleteExcluded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DownloadDirectoryDeleteExcluded>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpDataType <FXPDataType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FXPProgressInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SendHostDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private IPAddress <SocketLocalIp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PostConnect>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CustomStream>k__BackingField;
    [CompilerGeneratedAttribute]
private IFtpStreamConfig <CustomStreamConfig>k__BackingField;
    public BaseFtpClient Client { get; }
    public bool LogToConsole { get; public set; }
    public bool LogHost { get; public set; }
    public bool LogUserName { get; public set; }
    public bool LogPassword { get; public set; }
    public bool LogDurations { get; public set; }
    public FtpIpVersion InternetProtocolVersions { get; public set; }
    public bool StaleDataCheck { get; public set; }
    public bool Noop { get; public set; }
    public int NoopInterval { get; public set; }
    public List`1<string> NoopInactiveCommands { get; public set; }
    public List`1<string> NoopActiveCommands { get; public set; }
    public bool NoopTestConnectivity { get; public set; }
    public bool CheckCapabilities { get; public set; }
    public X509CertificateCollection ClientCertificates { get; protected set; }
    public Func`1<string> AddressResolver { get; public set; }
    public IEnumerable`1<int> ActivePorts { get; public set; }
    public IEnumerable`1<int> PassiveBlockedPorts { get; public set; }
    public int PassiveMaxAttempts { get; public set; }
    public FtpDataConnectionType DataConnectionType { get; public set; }
    public bool DisconnectWithQuit { get; public set; }
    public int ConnectTimeout { get; public set; }
    public int ReadTimeout { get; public set; }
    public int DataConnectionConnectTimeout { get; public set; }
    public int DataConnectionReadTimeout { get; public set; }
    public bool SocketKeepAlive { get; public set; }
    public FtpEncryptionMode EncryptionMode { get; public set; }
    public bool DataConnectionEncryption { get; public set; }
    public SslProtocols SslProtocols { get; public set; }
    public int SslSessionLength { get; public set; }
    public bool ValidateAnyCertificate { get; public set; }
    public bool ValidateCertificateRevocation { get; public set; }
    public FtpNavigate Navigate { get; public set; }
    public FtpDataType ListingDataType { get; public set; }
    public FtpParser ListingParser { get; public set; }
    public CultureInfo ListingCulture { get; public set; }
    public CustomParser ListingCustomParser { get; public set; }
    public double TimeZone { get; public set; }
    public FtpDate TimeConversion { get; public set; }
    public bool BulkListing { get; public set; }
    public int BulkListingLength { get; public set; }
    public int TransferChunkSize { get; public set; }
    public int LocalFileBufferSize { get; public set; }
    public FileShare LocalFileShareOption { get; public set; }
    public int RetryAttempts { get; public set; }
    public FtpVerifyMethod VerifyMethod { get; public set; }
    public UInt32 UploadRateLimit { get; public set; }
    public UInt32 DownloadRateLimit { get; public set; }
    public bool DownloadZeroByteFiles { get; public set; }
    public FtpDataType UploadDataType { get; public set; }
    public FtpDataType DownloadDataType { get; public set; }
    public bool UploadDirectoryDeleteExcluded { get; public set; }
    public bool DownloadDirectoryDeleteExcluded { get; public set; }
    public FtpDataType FXPDataType { get; public set; }
    public int FXPProgressInterval { get; public set; }
    public bool SendHost { get; public set; }
    public string SendHostDomain { get; public set; }
    public IPAddress SocketLocalIp { get; public set; }
    public bool PostConnect { get; public set; }
    public Type CustomStream { get; public set; }
    public IFtpStreamConfig CustomStreamConfig { get; public set; }
    public BaseFtpClient get_Client();
    [CompilerGeneratedAttribute]
public bool get_LogToConsole();
    [CompilerGeneratedAttribute]
public void set_LogToConsole(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogHost();
    [CompilerGeneratedAttribute]
public void set_LogHost(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogUserName();
    [CompilerGeneratedAttribute]
public void set_LogUserName(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogPassword();
    [CompilerGeneratedAttribute]
public void set_LogPassword(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogDurations();
    [CompilerGeneratedAttribute]
public void set_LogDurations(bool value);
    [CompilerGeneratedAttribute]
public FtpIpVersion get_InternetProtocolVersions();
    [CompilerGeneratedAttribute]
public void set_InternetProtocolVersions(FtpIpVersion value);
    [CompilerGeneratedAttribute]
public bool get_StaleDataCheck();
    [CompilerGeneratedAttribute]
public void set_StaleDataCheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_Noop();
    [CompilerGeneratedAttribute]
public void set_Noop(bool value);
    public int get_NoopInterval();
    public void set_NoopInterval(int value);
    public List`1<string> get_NoopInactiveCommands();
    public void set_NoopInactiveCommands(List`1<string> value);
    public List`1<string> get_NoopActiveCommands();
    public void set_NoopActiveCommands(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_NoopTestConnectivity();
    [CompilerGeneratedAttribute]
public void set_NoopTestConnectivity(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckCapabilities();
    [CompilerGeneratedAttribute]
public void set_CheckCapabilities(bool value);
    [CompilerGeneratedAttribute]
public X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
protected void set_ClientCertificates(X509CertificateCollection value);
    [CompilerGeneratedAttribute]
public Func`1<string> get_AddressResolver();
    [CompilerGeneratedAttribute]
public void set_AddressResolver(Func`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<int> get_ActivePorts();
    [CompilerGeneratedAttribute]
public void set_ActivePorts(IEnumerable`1<int> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<int> get_PassiveBlockedPorts();
    [CompilerGeneratedAttribute]
public void set_PassiveBlockedPorts(IEnumerable`1<int> value);
    [CompilerGeneratedAttribute]
public int get_PassiveMaxAttempts();
    [CompilerGeneratedAttribute]
public void set_PassiveMaxAttempts(int value);
    [CompilerGeneratedAttribute]
public FtpDataConnectionType get_DataConnectionType();
    [CompilerGeneratedAttribute]
public void set_DataConnectionType(FtpDataConnectionType value);
    [CompilerGeneratedAttribute]
public bool get_DisconnectWithQuit();
    [CompilerGeneratedAttribute]
public void set_DisconnectWithQuit(bool value);
    [CompilerGeneratedAttribute]
public int get_ConnectTimeout();
    [CompilerGeneratedAttribute]
public void set_ConnectTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_ReadTimeout();
    [CompilerGeneratedAttribute]
public void set_ReadTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_DataConnectionConnectTimeout();
    [CompilerGeneratedAttribute]
public void set_DataConnectionConnectTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_DataConnectionReadTimeout();
    [CompilerGeneratedAttribute]
public void set_DataConnectionReadTimeout(int value);
    public bool get_SocketKeepAlive();
    public void set_SocketKeepAlive(bool value);
    [CompilerGeneratedAttribute]
public FtpEncryptionMode get_EncryptionMode();
    [CompilerGeneratedAttribute]
public void set_EncryptionMode(FtpEncryptionMode value);
    [CompilerGeneratedAttribute]
public bool get_DataConnectionEncryption();
    [CompilerGeneratedAttribute]
public void set_DataConnectionEncryption(bool value);
    [CompilerGeneratedAttribute]
public SslProtocols get_SslProtocols();
    [CompilerGeneratedAttribute]
public void set_SslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
public int get_SslSessionLength();
    [CompilerGeneratedAttribute]
public void set_SslSessionLength(int value);
    [CompilerGeneratedAttribute]
public bool get_ValidateAnyCertificate();
    [CompilerGeneratedAttribute]
public void set_ValidateAnyCertificate(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateCertificateRevocation();
    [CompilerGeneratedAttribute]
public void set_ValidateCertificateRevocation(bool value);
    [CompilerGeneratedAttribute]
public FtpNavigate get_Navigate();
    [CompilerGeneratedAttribute]
public void set_Navigate(FtpNavigate value);
    [CompilerGeneratedAttribute]
public FtpDataType get_ListingDataType();
    [CompilerGeneratedAttribute]
public void set_ListingDataType(FtpDataType value);
    public FtpParser get_ListingParser();
    public void set_ListingParser(FtpParser value);
    [CompilerGeneratedAttribute]
public CultureInfo get_ListingCulture();
    [CompilerGeneratedAttribute]
public void set_ListingCulture(CultureInfo value);
    public CustomParser get_ListingCustomParser();
    public void set_ListingCustomParser(CustomParser value);
    public double get_TimeZone();
    public void set_TimeZone(double value);
    public TimeSpan GetServerTimeOffset();
    [CompilerGeneratedAttribute]
public FtpDate get_TimeConversion();
    [CompilerGeneratedAttribute]
public void set_TimeConversion(FtpDate value);
    [CompilerGeneratedAttribute]
public bool get_BulkListing();
    [CompilerGeneratedAttribute]
public void set_BulkListing(bool value);
    [CompilerGeneratedAttribute]
public int get_BulkListingLength();
    [CompilerGeneratedAttribute]
public void set_BulkListingLength(int value);
    [CompilerGeneratedAttribute]
public int get_TransferChunkSize();
    [CompilerGeneratedAttribute]
public void set_TransferChunkSize(int value);
    [CompilerGeneratedAttribute]
public int get_LocalFileBufferSize();
    [CompilerGeneratedAttribute]
public void set_LocalFileBufferSize(int value);
    [CompilerGeneratedAttribute]
public FileShare get_LocalFileShareOption();
    [CompilerGeneratedAttribute]
public void set_LocalFileShareOption(FileShare value);
    public int get_RetryAttempts();
    public void set_RetryAttempts(int value);
    [CompilerGeneratedAttribute]
public FtpVerifyMethod get_VerifyMethod();
    [CompilerGeneratedAttribute]
public void set_VerifyMethod(FtpVerifyMethod value);
    [CompilerGeneratedAttribute]
public UInt32 get_UploadRateLimit();
    [CompilerGeneratedAttribute]
public void set_UploadRateLimit(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_DownloadRateLimit();
    [CompilerGeneratedAttribute]
public void set_DownloadRateLimit(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_DownloadZeroByteFiles();
    [CompilerGeneratedAttribute]
public void set_DownloadZeroByteFiles(bool value);
    [CompilerGeneratedAttribute]
public FtpDataType get_UploadDataType();
    [CompilerGeneratedAttribute]
public void set_UploadDataType(FtpDataType value);
    [CompilerGeneratedAttribute]
public FtpDataType get_DownloadDataType();
    [CompilerGeneratedAttribute]
public void set_DownloadDataType(FtpDataType value);
    [CompilerGeneratedAttribute]
public bool get_UploadDirectoryDeleteExcluded();
    [CompilerGeneratedAttribute]
public void set_UploadDirectoryDeleteExcluded(bool value);
    [CompilerGeneratedAttribute]
public bool get_DownloadDirectoryDeleteExcluded();
    [CompilerGeneratedAttribute]
public void set_DownloadDirectoryDeleteExcluded(bool value);
    [CompilerGeneratedAttribute]
public FtpDataType get_FXPDataType();
    [CompilerGeneratedAttribute]
public void set_FXPDataType(FtpDataType value);
    [CompilerGeneratedAttribute]
public int get_FXPProgressInterval();
    [CompilerGeneratedAttribute]
public void set_FXPProgressInterval(int value);
    [CompilerGeneratedAttribute]
public bool get_SendHost();
    [CompilerGeneratedAttribute]
public void set_SendHost(bool value);
    [CompilerGeneratedAttribute]
public string get_SendHostDomain();
    [CompilerGeneratedAttribute]
public void set_SendHostDomain(string value);
    [CompilerGeneratedAttribute]
public IPAddress get_SocketLocalIp();
    [CompilerGeneratedAttribute]
public void set_SocketLocalIp(IPAddress value);
    [CompilerGeneratedAttribute]
public bool get_PostConnect();
    [CompilerGeneratedAttribute]
public void set_PostConnect(bool value);
    [CompilerGeneratedAttribute]
public Type get_CustomStream();
    [CompilerGeneratedAttribute]
public void set_CustomStream(Type value);
    [CompilerGeneratedAttribute]
public IFtpStreamConfig get_CustomStreamConfig();
    [CompilerGeneratedAttribute]
public void set_CustomStreamConfig(IFtpStreamConfig value);
    public void BindTo(BaseFtpClient client);
    public FtpConfig Clone();
    public static void CopyTo(FtpConfig read, FtpConfig write);
    internal bool ShouldAutoNavigate(string absPath);
    internal bool ShouldAutoRestore(string absPath);
}
public enum FluentFTP.FtpConnectionState : Enum {
    public int value__;
    public static FtpConnectionState Unknown;
    public static FtpConnectionState PendingDisconnect;
    public static FtpConnectionState Disconnected;
    public static FtpConnectionState Connected;
}
public enum FluentFTP.FtpDataConnectionType : Enum {
    public int value__;
    public static FtpDataConnectionType AutoActive;
    public static FtpDataConnectionType AutoPassive;
    public static FtpDataConnectionType PASV;
    public static FtpDataConnectionType EPSV;
    public static FtpDataConnectionType PORT;
    public static FtpDataConnectionType EPRT;
    public static FtpDataConnectionType PASVEX;
    public static FtpDataConnectionType PassiveExtended;
    public static FtpDataConnectionType PASVUSE;
    public static FtpDataConnectionType PassiveAllowUnroutable;
}
public class FluentFTP.FtpDataStream : FtpSocketStream {
    private FtpReply m_commandStatus;
    private BaseFtpClient m_control;
    private long m_length;
    private long m_position;
    public FtpReply CommandStatus { get; public set; }
    public BaseFtpClient ControlConnection { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public FtpDataStream(BaseFtpClient conn);
    public FtpReply get_CommandStatus();
    public void set_CommandStatus(FtpReply value);
    public BaseFtpClient get_ControlConnection();
    public void set_ControlConnection(BaseFtpClient value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("FluentFTP.FtpDataStream/<ReadAsync>d__16")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("FluentFTP.FtpDataStream/<WriteAsync>d__18")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    public virtual void SetLength(long value);
    public void SetPosition(long pos);
    public void Close();
    [AsyncStateMachineAttribute("FluentFTP.FtpDataStream/<CloseAsync>d__22")]
public virtual Task CloseAsync(CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(Byte[] buffer, int offset, int count, CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__2(CancellationToken token);
}
public enum FluentFTP.FtpDataType : Enum {
    public int value__;
    public static FtpDataType ASCII;
    public static FtpDataType Binary;
    public static FtpDataType Unknown;
}
public enum FluentFTP.FtpDate : Enum {
    public int value__;
    public static FtpDate ServerTime;
    public static FtpDate LocalTime;
    public static FtpDate UTC;
}
public enum FluentFTP.FtpEncryptionMode : Enum {
    public int value__;
    public static FtpEncryptionMode None;
    public static FtpEncryptionMode Implicit;
    public static FtpEncryptionMode Explicit;
    public static FtpEncryptionMode Auto;
}
[FlagsAttribute]
public enum FluentFTP.FtpError : Enum {
    public int value__;
    public static FtpError None;
    public static FtpError DeleteProcessed;
    public static FtpError Stop;
    public static FtpError Throw;
}
[ObsoleteAttribute("This enum is obsolete. Please use FtpRemoteExists instead.", "True")]
public enum FluentFTP.FtpExists : Enum {
    public int value__;
}
public enum FluentFTP.FtpFolderSyncMode : Enum {
    public int value__;
    public static FtpFolderSyncMode Mirror;
    public static FtpFolderSyncMode Update;
}
public class FluentFTP.FtpFxpSession : object {
    [CompilerGeneratedAttribute]
private FtpClient <SourceServer>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpClient <TargetServer>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpClient <ProgressServer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public FtpClient SourceServer { get; public set; }
    public FtpClient TargetServer { get; public set; }
    public FtpClient ProgressServer { get; public set; }
    public bool IsDisposed { get; private set; }
    [CompilerGeneratedAttribute]
public FtpClient get_SourceServer();
    [CompilerGeneratedAttribute]
public void set_SourceServer(FtpClient value);
    [CompilerGeneratedAttribute]
public FtpClient get_TargetServer();
    [CompilerGeneratedAttribute]
public void set_TargetServer(FtpClient value);
    [CompilerGeneratedAttribute]
public FtpClient get_ProgressServer();
    [CompilerGeneratedAttribute]
public void set_ProgressServer(FtpClient value);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
}
public class FluentFTP.FtpFxpSessionAsync : object {
    [CompilerGeneratedAttribute]
private AsyncFtpClient <SourceServer>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncFtpClient <TargetServer>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncFtpClient <ProgressServer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public AsyncFtpClient SourceServer { get; public set; }
    public AsyncFtpClient TargetServer { get; public set; }
    public AsyncFtpClient ProgressServer { get; public set; }
    public bool IsDisposed { get; private set; }
    [CompilerGeneratedAttribute]
public AsyncFtpClient get_SourceServer();
    [CompilerGeneratedAttribute]
public void set_SourceServer(AsyncFtpClient value);
    [CompilerGeneratedAttribute]
public AsyncFtpClient get_TargetServer();
    [CompilerGeneratedAttribute]
public void set_TargetServer(AsyncFtpClient value);
    [CompilerGeneratedAttribute]
public AsyncFtpClient get_ProgressServer();
    [CompilerGeneratedAttribute]
public void set_ProgressServer(AsyncFtpClient value);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
}
public class FluentFTP.FtpHash : object {
    private FtpHashAlgorithm m_algorithm;
    private string m_value;
    public FtpHashAlgorithm Algorithm { get; internal set; }
    public string Value { get; internal set; }
    public bool IsValid { get; }
    public FtpHashAlgorithm get_Algorithm();
    internal void set_Algorithm(FtpHashAlgorithm value);
    public string get_Value();
    internal void set_Value(string value);
    public bool get_IsValid();
    public bool Verify(string file);
    public bool Verify(Stream istream);
}
[FlagsAttribute]
public enum FluentFTP.FtpHashAlgorithm : Enum {
    public int value__;
    public static FtpHashAlgorithm NONE;
    public static FtpHashAlgorithm SHA1;
    public static FtpHashAlgorithm SHA256;
    public static FtpHashAlgorithm SHA512;
    public static FtpHashAlgorithm MD5;
    public static FtpHashAlgorithm CRC;
}
[FlagsAttribute]
public enum FluentFTP.FtpIpVersion : Enum {
    public int value__;
    public static FtpIpVersion Unknown;
    public static FtpIpVersion IPv4;
    public static FtpIpVersion IPv6;
    public static FtpIpVersion ANY;
}
public class FluentFTP.FtpListItem : object {
    [CompilerGeneratedAttribute]
private FtpObjectType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpObjectSubType <SubType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    private string m_name;
    [CompilerGeneratedAttribute]
private string <LinkTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinkCount>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpListItem <LinkObject>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Modified>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <RawModified>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <RawCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpSpecialPermissions <SpecialPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpPermission <OwnerPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpPermission <GroupPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpPermission <OthersPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Chmod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Input>k__BackingField;
    public FtpObjectType Type { get; public set; }
    public FtpObjectSubType SubType { get; public set; }
    public string FullName { get; public set; }
    public string Name { get; public set; }
    public string LinkTarget { get; public set; }
    public int LinkCount { get; public set; }
    public FtpListItem LinkObject { get; public set; }
    public DateTime Modified { get; public set; }
    public DateTime Created { get; public set; }
    public DateTime RawModified { get; public set; }
    public DateTime RawCreated { get; public set; }
    public long Size { get; public set; }
    public FtpSpecialPermissions SpecialPermissions { get; public set; }
    public FtpPermission OwnerPermissions { get; public set; }
    public FtpPermission GroupPermissions { get; public set; }
    public FtpPermission OthersPermissions { get; public set; }
    public string RawPermissions { get; public set; }
    public int Chmod { get; public set; }
    public string RawGroup { get; public set; }
    public string RawOwner { get; public set; }
    public string Input { get; public set; }
    public FtpListItem(string record, string name, long size, bool isDir, DateTime lastModifiedTime);
    public FtpListItem(string name, long size, FtpObjectType type, DateTime lastModifiedTime);
    [CompilerGeneratedAttribute]
public FtpObjectType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(FtpObjectType value);
    [CompilerGeneratedAttribute]
public FtpObjectSubType get_SubType();
    [CompilerGeneratedAttribute]
public void set_SubType(FtpObjectSubType value);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(string value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_LinkTarget();
    [CompilerGeneratedAttribute]
public void set_LinkTarget(string value);
    [CompilerGeneratedAttribute]
public int get_LinkCount();
    [CompilerGeneratedAttribute]
public void set_LinkCount(int value);
    [CompilerGeneratedAttribute]
public FtpListItem get_LinkObject();
    [CompilerGeneratedAttribute]
public void set_LinkObject(FtpListItem value);
    [CompilerGeneratedAttribute]
public DateTime get_Modified();
    [CompilerGeneratedAttribute]
public void set_Modified(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_Created();
    [CompilerGeneratedAttribute]
public void set_Created(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_RawModified();
    [CompilerGeneratedAttribute]
public void set_RawModified(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_RawCreated();
    [CompilerGeneratedAttribute]
public void set_RawCreated(DateTime value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(long value);
    [CompilerGeneratedAttribute]
public FtpSpecialPermissions get_SpecialPermissions();
    [CompilerGeneratedAttribute]
public void set_SpecialPermissions(FtpSpecialPermissions value);
    [CompilerGeneratedAttribute]
public FtpPermission get_OwnerPermissions();
    [CompilerGeneratedAttribute]
public void set_OwnerPermissions(FtpPermission value);
    [CompilerGeneratedAttribute]
public FtpPermission get_GroupPermissions();
    [CompilerGeneratedAttribute]
public void set_GroupPermissions(FtpPermission value);
    [CompilerGeneratedAttribute]
public FtpPermission get_OthersPermissions();
    [CompilerGeneratedAttribute]
public void set_OthersPermissions(FtpPermission value);
    [CompilerGeneratedAttribute]
public string get_RawPermissions();
    [CompilerGeneratedAttribute]
public void set_RawPermissions(string value);
    [CompilerGeneratedAttribute]
public int get_Chmod();
    [CompilerGeneratedAttribute]
public void set_Chmod(int value);
    [CompilerGeneratedAttribute]
public string get_RawGroup();
    [CompilerGeneratedAttribute]
public void set_RawGroup(string value);
    [CompilerGeneratedAttribute]
public string get_RawOwner();
    [CompilerGeneratedAttribute]
public void set_RawOwner(string value);
    [CompilerGeneratedAttribute]
public string get_Input();
    [CompilerGeneratedAttribute]
public void set_Input(string value);
    public virtual string ToString();
    public string ToCode();
}
[FlagsAttribute]
public enum FluentFTP.FtpListOption : Enum {
    public int value__;
    public static FtpListOption Auto;
    public static FtpListOption Modify;
    public static FtpListOption Size;
    public static FtpListOption SizeModify;
    public static FtpListOption AllFiles;
    public static FtpListOption ForceList;
    public static FtpListOption NameList;
    public static FtpListOption ForceNameList;
    public static FtpListOption UseLS;
    public static FtpListOption Recursive;
    public static FtpListOption NoPath;
    public static FtpListOption IncludeSelfAndParent;
    public static FtpListOption UseStat;
}
public enum FluentFTP.FtpLocalExists : Enum {
    public int value__;
    public static FtpLocalExists Overwrite;
    public static FtpLocalExists Resume;
    public static FtpLocalExists Skip;
    [ObsoleteAttribute("Append is now renamed to Resume to better reflect its behaviour.", "True")]
public static FtpLocalExists Append;
}
[IsReadOnlyAttribute]
public class FluentFTP.FtpLogEntry : ValueType {
    [CompilerGeneratedAttribute]
private FtpTraceLevel <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public FtpTraceLevel Severity { get; }
    public string Message { get; }
    public Exception Exception { get; }
    public FtpLogEntry(FtpTraceLevel severity, string msg, Exception ex);
    [CompilerGeneratedAttribute]
public FtpTraceLevel get_Severity();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
[FlagsAttribute]
public enum FluentFTP.FtpNavigate : Enum {
    public UInt32 value__;
    public static FtpNavigate Manual;
    public static FtpNavigate Auto;
    public static FtpNavigate SemiAuto;
    public static FtpNavigate Conditional;
}
public enum FluentFTP.FtpObjectSubType : Enum {
    public int value__;
    public static FtpObjectSubType Unknown;
    public static FtpObjectSubType SubDirectory;
    public static FtpObjectSubType SelfDirectory;
    public static FtpObjectSubType ParentDirectory;
}
public enum FluentFTP.FtpObjectType : Enum {
    public int value__;
    public static FtpObjectType File;
    public static FtpObjectType Directory;
    public static FtpObjectType Link;
}
public enum FluentFTP.FtpOperatingSystem : Enum {
    public int value__;
    public static FtpOperatingSystem Unknown;
    public static FtpOperatingSystem Windows;
    public static FtpOperatingSystem Unix;
    public static FtpOperatingSystem VMS;
    public static FtpOperatingSystem IBMOS400;
    public static FtpOperatingSystem IBMzOS;
    public static FtpOperatingSystem SunOS;
}
public enum FluentFTP.FtpOperator : Enum {
    public int value__;
    public static FtpOperator Equals;
    public static FtpOperator NotEquals;
    public static FtpOperator LessThan;
    public static FtpOperator LessThanOrEquals;
    public static FtpOperator MoreThan;
    public static FtpOperator MoreThanOrEquals;
    public static FtpOperator BetweenRange;
    public static FtpOperator OutsideRange;
}
public enum FluentFTP.FtpParser : Enum {
    public int value__;
    public static FtpParser Custom;
    public static FtpParser Auto;
    public static FtpParser Machine;
    public static FtpParser Windows;
    public static FtpParser Unix;
    public static FtpParser UnixAlt;
    public static FtpParser VMS;
    public static FtpParser IBMzOS;
    public static FtpParser IBMOS400;
    public static FtpParser NonStop;
}
[FlagsAttribute]
public enum FluentFTP.FtpPermission : Enum {
    public UInt32 value__;
    public static FtpPermission None;
    public static FtpPermission Execute;
    public static FtpPermission Write;
    public static FtpPermission Read;
}
public class FluentFTP.FtpProfile : object {
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpEncryptionMode <Encryption>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <Protocols>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpDataConnectionType <DataConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SocketPollInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncodingVerified>k__BackingField;
    public string Host { get; public set; }
    public NetworkCredential Credentials { get; public set; }
    public FtpEncryptionMode Encryption { get; public set; }
    public SslProtocols Protocols { get; public set; }
    public FtpDataConnectionType DataConnection { get; public set; }
    public Encoding Encoding { get; public set; }
    public int Timeout { get; public set; }
    public int SocketPollInterval { get; public set; }
    public int RetryAttempts { get; public set; }
    public bool EncodingVerified { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public NetworkCredential get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(NetworkCredential value);
    [CompilerGeneratedAttribute]
public FtpEncryptionMode get_Encryption();
    [CompilerGeneratedAttribute]
public void set_Encryption(FtpEncryptionMode value);
    [CompilerGeneratedAttribute]
public SslProtocols get_Protocols();
    [CompilerGeneratedAttribute]
public void set_Protocols(SslProtocols value);
    [CompilerGeneratedAttribute]
public FtpDataConnectionType get_DataConnection();
    [CompilerGeneratedAttribute]
public void set_DataConnection(FtpDataConnectionType value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public int get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public int get_SocketPollInterval();
    [CompilerGeneratedAttribute]
public void set_SocketPollInterval(int value);
    [CompilerGeneratedAttribute]
public int get_RetryAttempts();
    [CompilerGeneratedAttribute]
public void set_RetryAttempts(int value);
    [CompilerGeneratedAttribute]
public bool get_EncodingVerified();
    [CompilerGeneratedAttribute]
public void set_EncodingVerified(bool value);
    public string ToCode();
}
public class FluentFTP.FtpProgress : object {
    [CompilerGeneratedAttribute]
private double <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TransferredBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <TransferSpeed>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ETA>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemotePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileCount>k__BackingField;
    public double Progress { get; public set; }
    public long TransferredBytes { get; public set; }
    public double TransferSpeed { get; public set; }
    public TimeSpan ETA { get; public set; }
    public string RemotePath { get; public set; }
    public string LocalPath { get; public set; }
    public int FileIndex { get; public set; }
    public int FileCount { get; public set; }
    public FtpProgress(int fileCount, int fileIndex);
    public FtpProgress(double progress, long bytesTransferred, double transferspeed, TimeSpan remainingtime, string localPath, string remotePath, FtpProgress metaProgress);
    [CompilerGeneratedAttribute]
public double get_Progress();
    [CompilerGeneratedAttribute]
public void set_Progress(double value);
    [CompilerGeneratedAttribute]
public long get_TransferredBytes();
    [CompilerGeneratedAttribute]
public void set_TransferredBytes(long value);
    [CompilerGeneratedAttribute]
public double get_TransferSpeed();
    [CompilerGeneratedAttribute]
public void set_TransferSpeed(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ETA();
    [CompilerGeneratedAttribute]
public void set_ETA(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_RemotePath();
    [CompilerGeneratedAttribute]
public void set_RemotePath(string value);
    [CompilerGeneratedAttribute]
public string get_LocalPath();
    [CompilerGeneratedAttribute]
public void set_LocalPath(string value);
    [CompilerGeneratedAttribute]
public int get_FileIndex();
    [CompilerGeneratedAttribute]
public void set_FileIndex(int value);
    [CompilerGeneratedAttribute]
public int get_FileCount();
    [CompilerGeneratedAttribute]
public void set_FileCount(int value);
    public string TransferSpeedToString();
    public static FtpProgress Generate(long fileSize, long position, long bytesProcessed, TimeSpan elapsedtime, string localPath, string remotePath, FtpProgress metaProgress);
}
public class FluentFTP.FtpProxyProfile : object {
    [CompilerGeneratedAttribute]
private string <ProxyHost>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProxyPort>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <ProxyCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FtpHost>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FtpPort>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <FtpCredentials>k__BackingField;
    public string ProxyHost { get; public set; }
    public int ProxyPort { get; public set; }
    public NetworkCredential ProxyCredentials { get; public set; }
    public string FtpHost { get; public set; }
    public int FtpPort { get; public set; }
    public NetworkCredential FtpCredentials { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProxyHost();
    [CompilerGeneratedAttribute]
public void set_ProxyHost(string value);
    [CompilerGeneratedAttribute]
public int get_ProxyPort();
    [CompilerGeneratedAttribute]
public void set_ProxyPort(int value);
    [CompilerGeneratedAttribute]
public NetworkCredential get_ProxyCredentials();
    [CompilerGeneratedAttribute]
public void set_ProxyCredentials(NetworkCredential value);
    [CompilerGeneratedAttribute]
public string get_FtpHost();
    [CompilerGeneratedAttribute]
public void set_FtpHost(string value);
    [CompilerGeneratedAttribute]
public int get_FtpPort();
    [CompilerGeneratedAttribute]
public void set_FtpPort(int value);
    [CompilerGeneratedAttribute]
public NetworkCredential get_FtpCredentials();
    [CompilerGeneratedAttribute]
public void set_FtpCredentials(NetworkCredential value);
}
public enum FluentFTP.FtpRemoteExists : Enum {
    public int value__;
    public static FtpRemoteExists NoCheck;
    public static FtpRemoteExists ResumeNoCheck;
    public static FtpRemoteExists AddToEndNoCheck;
    public static FtpRemoteExists Skip;
    public static FtpRemoteExists Overwrite;
    public static FtpRemoteExists OverwriteInPlace;
    public static FtpRemoteExists Resume;
    public static FtpRemoteExists AddToEnd;
    [ObsoleteAttribute("Append is now renamed to Resume to better reflect its behaviour. If you instead want to append the local file to the END of the remote file without resuming, then use AddToEnd.", "True")]
public static FtpRemoteExists Append;
}
public class FluentFTP.FtpReply : ValueType {
    private string m_respCode;
    private string m_respMessage;
    private string m_infoMessages;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    public FtpResponseType Type { get; }
    public string Code { get; public set; }
    public string Message { get; public set; }
    public string InfoMessages { get; public set; }
    public bool Success { get; }
    public string ErrorMessage { get; }
    public string Command { get; public set; }
    public FtpResponseType get_Type();
    public string get_Code();
    public void set_Code(string value);
    public string get_Message();
    public void set_Message(string value);
    public string get_InfoMessages();
    public void set_InfoMessages(string value);
    public bool get_Success();
    public string get_ErrorMessage();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(string value);
}
public enum FluentFTP.FtpResponseType : Enum {
    public int value__;
    public static FtpResponseType None;
    public static FtpResponseType PositivePreliminary;
    public static FtpResponseType PositiveCompletion;
    public static FtpResponseType PositiveIntermediate;
    public static FtpResponseType TransientNegativeCompletion;
    public static FtpResponseType PermanentNegativeCompletion;
}
public class FluentFTP.FtpResult : object {
    [CompilerGeneratedAttribute]
private bool <IsDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpObjectType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemotePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSkippedByRule>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFailed>k__BackingField;
    public bool IsDownload { get; public set; }
    public FtpObjectType Type { get; public set; }
    public long Size { get; public set; }
    public string Name { get; public set; }
    public string RemotePath { get; public set; }
    public string LocalPath { get; public set; }
    public Exception Exception { get; public set; }
    public bool IsSuccess { get; public set; }
    public bool IsSkipped { get; public set; }
    public bool IsSkippedByRule { get; public set; }
    public bool IsFailed { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsDownload();
    [CompilerGeneratedAttribute]
public void set_IsDownload(bool value);
    [CompilerGeneratedAttribute]
public FtpObjectType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(FtpObjectType value);
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(long value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_RemotePath();
    [CompilerGeneratedAttribute]
public void set_RemotePath(string value);
    [CompilerGeneratedAttribute]
public string get_LocalPath();
    [CompilerGeneratedAttribute]
public void set_LocalPath(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
    [CompilerGeneratedAttribute]
public void set_IsSuccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSkipped();
    [CompilerGeneratedAttribute]
public void set_IsSkipped(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSkippedByRule();
    [CompilerGeneratedAttribute]
public void set_IsSkippedByRule(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFailed();
    [CompilerGeneratedAttribute]
public void set_IsFailed(bool value);
    public FtpListItem ToListItem(bool useLocalPath);
    public virtual string ToString();
    public FtpStatus ToStatus();
}
public enum FluentFTP.FtpsBuffering : Enum {
    public int value__;
    public static FtpsBuffering Auto;
    public static FtpsBuffering Off;
    public static FtpsBuffering On;
}
public enum FluentFTP.FtpServer : Enum {
    public int value__;
    public static FtpServer Unknown;
    public static FtpServer Apache;
    public static FtpServer BFTPd;
    public static FtpServer Cerberus;
    public static FtpServer CrushFTP;
    public static FtpServer DLink;
    public static FtpServer FileZilla;
    public static FtpServer FritzBox;
    public static FtpServer FTP2S3Gateway;
    public static FtpServer glFTPd;
    public static FtpServer GlobalScapeEFT;
    public static FtpServer HomegateFTP;
    public static FtpServer Huawei;
    public static FtpServer IBMzOSFTP;
    public static FtpServer IBMOS400FTP;
    public static FtpServer IDALFTP;
    public static FtpServer MikroTik;
    public static FtpServer NonStopTandem;
    public static FtpServer OpenVMS;
    public static FtpServer ProFTPD;
    public static FtpServer PureFTPd;
    public static FtpServer PyFtpdLib;
    public static FtpServer Rumpus;
    public static FtpServer ServU;
    public static FtpServer SolarisFTP;
    public static FtpServer TitanFTP;
    public static FtpServer TPLink;
    public static FtpServer VsFTPd;
    public static FtpServer WindowsCE;
    public static FtpServer WindowsServerIIS;
    public static FtpServer WSFTP;
    public static FtpServer WuFTPd;
    public static FtpServer XLight;
}
public class FluentFTP.FtpSizeReply : object {
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpReply <Reply>k__BackingField;
    public long FileSize { get; public set; }
    public FtpReply Reply { get; public set; }
    [CompilerGeneratedAttribute]
public long get_FileSize();
    [CompilerGeneratedAttribute]
public void set_FileSize(long value);
    [CompilerGeneratedAttribute]
public FtpReply get_Reply();
    [CompilerGeneratedAttribute]
public void set_Reply(FtpReply value);
}
public class FluentFTP.FtpSocketStream : Stream {
    public BaseFtpClient Client;
    private NetworkStream m_netStream;
    private FtpSslStream m_sslStream;
    private IFtpStream m_customStream;
    [CompilerGeneratedAttribute]
private bool <IsControlConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpConnectionState <ConnectionState>k__BackingField;
    private DateTime m_lastActivity;
    private Socket m_socket;
    public int SslSessionLength;
    private int m_readTimeout;
    private int m_connectTimeout;
    [CompilerGeneratedAttribute]
private FtpSocketStreamSslValidation m_sslvalidate;
    protected Stream BaseStream { get; }
    public bool IsControlConnection { get; public set; }
    public bool IsDisposed { get; public set; }
    public bool IsEncrypted { get; }
    public FtpConnectionState ConnectionState { get; public set; }
    public bool IsConnected { get; }
    protected Socket Socket { get; private set; }
    internal int SocketDataAvailable { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int ConnectTimeout { get; public set; }
    public IPEndPoint LocalEndPoint { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public FtpSocketStream(BaseFtpClient conn);
    protected Stream get_BaseStream();
    [CompilerGeneratedAttribute]
public bool get_IsControlConnection();
    [CompilerGeneratedAttribute]
public void set_IsControlConnection(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
public void set_IsDisposed(bool value);
    public bool get_IsEncrypted();
    [CompilerGeneratedAttribute]
public FtpConnectionState get_ConnectionState();
    [CompilerGeneratedAttribute]
public void set_ConnectionState(FtpConnectionState value);
    public bool get_IsConnected();
    protected Socket get_Socket();
    private void set_Socket(Socket value);
    internal int get_SocketDataAvailable();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public int get_ConnectTimeout();
    public void set_ConnectTimeout(int value);
    public IPEndPoint get_LocalEndPoint();
    public IPEndPoint get_RemoteEndPoint();
    [CompilerGeneratedAttribute]
private void add_m_sslvalidate(FtpSocketStreamSslValidation value);
    [CompilerGeneratedAttribute]
private void remove_m_sslvalidate(FtpSocketStreamSslValidation value);
    public void add_ValidateCertificate(FtpSocketStreamSslValidation value);
    public void remove_ValidateCertificate(FtpSocketStreamSslValidation value);
    protected bool OnValidateCertificate(X509Certificate certificate, X509Chain chain, SslPolicyErrors errors);
    protected bool OnValidateCertificate(X509Certificate certificate, X509Chain chain, string errorMessage);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Flush();
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<FlushAsync>d__65")]
public virtual Task FlushAsync(CancellationToken token);
    internal int RawSocketRead(Byte[] buffer);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<RawSocketReadAsync>d__67")]
internal Task`1<int> RawSocketReadAsync(Byte[] buffer, CancellationToken token);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<ReadAsync>d__69")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    public string ReadLine(Encoding encoding);
    [IteratorStateMachineAttribute("FluentFTP.FtpSocketStream/<ReadAllLines>d__71")]
public IEnumerable`1<string> ReadAllLines(Encoding encoding, int bufferSize);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<ReadLineAsync>d__72")]
public Task`1<string> ReadLineAsync(Encoding encoding, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<ReadAllLinesAsync>d__73")]
public Task`1<IEnumerable`1<string>> ReadAllLinesAsync(Encoding encoding, int bufferSize, CancellationToken token);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<WriteAsync>d__75")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    public void WriteLine(Encoding encoding, string buf);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<WriteLineAsync>d__77")]
public Task WriteLineAsync(Encoding encoding, string buf, CancellationToken token);
    public void SetSocketOption(SocketOptionLevel level, SocketOptionName name, bool value);
    private static bool IsIpVersionAllowed(IPAddress ipad, FtpIpVersion ipVersions, String& ipVersionString);
    private IPAddress[] GetCachedHostAddresses(string host);
    private void SetCachedHostAddresses(string host, IPAddress ipad);
    public void Connect(string host, int port, FtpIpVersion ipVersions);
    private bool ConnectHelper(IPAddress ipad, int port);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<GetCachedHostAddressesAsync>d__84")]
private Task`1<IPAddress[]> GetCachedHostAddressesAsync(string host, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<ConnectAsync>d__85")]
public Task ConnectAsync(string host, int port, FtpIpVersion ipVersions, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<EnableCancellation>d__86")]
internal Task EnableCancellation(Task task, CancellationToken token, Action action);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<EnableCancellation>d__87`1")]
internal Task`1<T> EnableCancellation(Task`1<T> task, CancellationToken token, Action action);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<ConnectHelperAsync>d__88")]
private Task`1<bool> ConnectHelperAsync(IPAddress ipad, int port, CancellationToken token);
    public void ActivateEncryption(string targetHost, X509CertificateCollection clientCerts, SslProtocols sslProtocols);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<ActivateEncryptionAsync>d__90")]
public Task ActivateEncryptionAsync(string targetHost, X509CertificateCollection clientCerts, SslProtocols sslProtocols, CancellationToken token);
    private void CreateSslStream();
    private void CreateCustomStream(string targetHost);
    public void Listen(IPAddress address, int port);
    public void Accept();
    public IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public void EndAccept(IAsyncResult ar);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<AcceptAsync>d__97")]
public Task AcceptAsync();
    private void BindSocketToLocalIp();
    public virtual void Close();
    protected void Dispose();
    internal void DisposeSslStream();
    internal void DisposeCustomStream();
    internal void DisposeNetStream();
    internal void DisposeSocket();
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<CloseAsync>d__105")]
public virtual Task CloseAsync(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<DisposeAsync>d__106")]
public Task DisposeAsync();
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<DisposeAsyncCore>d__107")]
protected Task DisposeAsyncCore();
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<DisposeSslStreamAsync>d__108")]
internal Task DisposeSslStreamAsync();
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<DisposeCustomStreamAsync>d__109")]
internal Task DisposeCustomStreamAsync();
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<DisposeNetStreamAsync>d__110")]
internal Task DisposeNetStreamAsync();
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<DisposeSocketAsync>d__111")]
internal Task DisposeSocketAsync();
    [AsyncStateMachineAttribute("FluentFTP.FtpSocketStream/<<get_IsConnected>b__22_0>d")]
[CompilerGeneratedAttribute]
private Task <get_IsConnected>b__22_0();
    [CompilerGeneratedAttribute]
private void <RawSocketReadAsync>b__67_0();
    [CompilerGeneratedAttribute]
private void <ConnectHelperAsync>b__88_0();
    [CompilerGeneratedAttribute]
private bool <CreateSslStream>b__91_0(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    [CompilerGeneratedAttribute]
private bool <CreateCustomStream>b__92_0(object sender, X509Certificate certificate, X509Chain chain, string errorMessage);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0(bool disposing);
}
public class FluentFTP.FtpSocketStreamSslValidation : MulticastDelegate {
    public FtpSocketStreamSslValidation(object object, IntPtr method);
    public virtual void Invoke(FtpSocketStream stream, FtpSslValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(FtpSocketStream stream, FtpSslValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum FluentFTP.FtpSpecialPermissions : Enum {
    public int value__;
    public static FtpSpecialPermissions None;
    public static FtpSpecialPermissions Sticky;
    public static FtpSpecialPermissions SetGroupID;
    public static FtpSpecialPermissions SetUserID;
}
public class FluentFTP.FtpSslValidation : MulticastDelegate {
    public FtpSslValidation(object object, IntPtr method);
    public virtual void Invoke(BaseFtpClient control, FtpSslValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(BaseFtpClient control, FtpSslValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class FluentFTP.FtpSslValidationEventArgs : EventArgs {
    private X509Certificate m_certificate;
    private X509Chain m_chain;
    private SslPolicyErrors m_policyErrors;
    private string m_policyErrorMessage;
    private bool m_accept;
    public X509Certificate Certificate { get; public set; }
    public X509Chain Chain { get; public set; }
    public SslPolicyErrors PolicyErrors { get; public set; }
    public string PolicyErrorMessage { get; public set; }
    public bool Accept { get; public set; }
    public X509Certificate get_Certificate();
    public void set_Certificate(X509Certificate value);
    public X509Chain get_Chain();
    public void set_Chain(X509Chain value);
    public SslPolicyErrors get_PolicyErrors();
    public void set_PolicyErrors(SslPolicyErrors value);
    public string get_PolicyErrorMessage();
    public void set_PolicyErrorMessage(string value);
    public bool get_Accept();
    public void set_Accept(bool value);
}
public enum FluentFTP.FtpStatus : Enum {
    public int value__;
    public static FtpStatus Failed;
    public static FtpStatus Success;
    public static FtpStatus Skipped;
}
public enum FluentFTP.FtpTraceLevel : Enum {
    public int value__;
    public static FtpTraceLevel Verbose;
    public static FtpTraceLevel Info;
    public static FtpTraceLevel Warn;
    public static FtpTraceLevel Error;
}
[FlagsAttribute]
public enum FluentFTP.FtpVerify : Enum {
    public int value__;
    public static FtpVerify None;
    public static FtpVerify Retry;
    public static FtpVerify Delete;
    public static FtpVerify Throw;
    [ObsoleteAttribute("OnlyChecksum is now renamed to OnlyVerify to better reflect its behaviour.", "True")]
public static FtpVerify OnlyChecksum;
    public static FtpVerify OnlyVerify;
}
[FlagsAttribute]
public enum FluentFTP.FtpVerifyMethod : Enum {
    public int value__;
    public static FtpVerifyMethod Size;
    public static FtpVerifyMethod Date;
    public static FtpVerifyMethod Checksum;
}
[FlagsAttribute]
public enum FluentFTP.FtpZOSListRealm : Enum {
    public int value__;
    public static FtpZOSListRealm Invalid;
    public static FtpZOSListRealm Unix;
    public static FtpZOSListRealm Dataset;
    public static FtpZOSListRealm Member;
    public static FtpZOSListRealm MemberU;
    public static FtpZOSListRealm Jes2;
}
[ExtensionAttribute]
internal static class FluentFTP.Helpers.Collections : object {
    [ExtensionAttribute]
public static bool IsBlank(IList value);
    [ExtensionAttribute]
public static bool IsBlank(IEnumerable value);
    [ExtensionAttribute]
public static List`1<string> ItemsToString(Object[] args);
    [ExtensionAttribute]
public static bool AddOnce(List`1<T> items, T item);
    [ExtensionAttribute]
public static List`1<T> ShallowClone(List`1<T> list);
}
[ExtensionAttribute]
public static class FluentFTP.Helpers.DateTimes : object {
    private static String[] FtpDateFormats;
    private static DateTimes();
    [ExtensionAttribute]
public static DateTime ParseFtpDate(string dateString, BaseFtpClient client, String[] formats, DateTimeStyles styles);
    [ExtensionAttribute]
public static string GenerateFtpDate(DateTime date);
    [ExtensionAttribute]
public static string ToCode(DateTime date);
}
[ExtensionAttribute]
public static class FluentFTP.Helpers.Enums : object {
    [ExtensionAttribute]
public static bool IsValidCombination(FtpError options);
    [ExtensionAttribute]
public static bool IsSuccess(FtpStatus status);
    [ExtensionAttribute]
public static bool IsFailure(FtpStatus status);
}
internal static class FluentFTP.Helpers.FileListings : object {
    public static bool FileExistsInNameListing(String[] fileList, string path);
    public static bool FileExistsInListing(FtpListItem[] fileList, string path);
}
[ExtensionAttribute]
public static class FluentFTP.Helpers.FileSizes : object {
    private static String[] sizePostfix;
    private static FileSizes();
    [ExtensionAttribute]
public static string FileSizeToString(int bytes);
    [ExtensionAttribute]
public static string FileSizeToString(UInt32 bytes);
    [ExtensionAttribute]
public static string FileSizeToString(ulong bytes);
    [ExtensionAttribute]
public static string FileSizeToString(long bytes);
}
public class FluentFTP.Helpers.FtpListParser : object {
    private BaseFtpClient client;
    private static List`1<FtpParser> parsers;
    [CompilerGeneratedAttribute]
private FtpParser <CurrentParser>k__BackingField;
    [CompilerGeneratedAttribute]
private FtpParser <DetectedParser>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParserConfirmed>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <VMSNameHasVersion>k__BackingField;
    public FtpParser CurrentParser { get; public set; }
    public FtpParser DetectedParser { get; public set; }
    public bool ParserConfirmed { get; public set; }
    public static bool VMSNameHasVersion { get; public set; }
    public FtpListParser(BaseFtpClient client);
    private static FtpListParser();
    [CompilerGeneratedAttribute]
public FtpParser get_CurrentParser();
    [CompilerGeneratedAttribute]
public void set_CurrentParser(FtpParser value);
    [CompilerGeneratedAttribute]
public FtpParser get_DetectedParser();
    [CompilerGeneratedAttribute]
public void set_DetectedParser(FtpParser value);
    [CompilerGeneratedAttribute]
public bool get_ParserConfirmed();
    [CompilerGeneratedAttribute]
public void set_ParserConfirmed(bool value);
    [CompilerGeneratedAttribute]
public static bool get_VMSNameHasVersion();
    [CompilerGeneratedAttribute]
public static void set_VMSNameHasVersion(bool value);
    public void Init(FtpOperatingSystem system, FtpParser forcedParser);
    public FtpListItem ParseSingleLine(string path, string file, List`1<FtpCapability> caps, bool isMachineList);
    private void ValidateParser(String[] files);
    private bool IsWrongParser();
    private bool IsWrongMachineListing();
    private bool IsParserValid(FtpParser p, String[] files);
}
internal class FluentFTP.Helpers.Hashing.CRC32 : HashAlgorithm {
    public static UInt32 DefaultPolynomial;
    public static UInt32 DefaultSeed;
    private UInt32 hash;
    private UInt32 seed;
    private UInt32[] table;
    private static UInt32[] defaultTable;
    public int HashSize { get; }
    public CRC32(UInt32 polynomial, UInt32 seed);
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual Byte[] HashFinal();
    public virtual int get_HashSize();
    public static UInt32 Compute(Byte[] buffer);
    public static UInt32 Compute(UInt32 seed, Byte[] buffer);
    public static UInt32 Compute(UInt32 polynomial, UInt32 seed, Byte[] buffer);
    private static UInt32[] InitializeTable(UInt32 polynomial);
    private static UInt32 CalculateHash(UInt32[] table, UInt32 seed, Byte[] buffer, int start, int size);
    private Byte[] UInt32ToBigEndianBytes(UInt32 x);
}
[ExtensionAttribute]
internal static class FluentFTP.Helpers.Hashing.HashAlgorithms : object {
    private static Dictionary`2<string, FtpHashAlgorithm> NameToEnum;
    private static Dictionary`2<FtpHashAlgorithm, string> EnumToName;
    private static List`1<FtpHashAlgorithm> AlgoPreference;
    private static HashAlgorithms();
    public static FtpHashAlgorithm FromString(string name);
    [ExtensionAttribute]
public static string PrintToString(FtpHashAlgorithm name);
    public static FtpHashAlgorithm FirstSupported(FtpHashAlgorithm supportedFlags);
}
internal static class FluentFTP.Helpers.Hashing.HashParser : object {
    public static FtpHash Parse(string reply);
}
[ExtensionAttribute]
public static class FluentFTP.Helpers.LocalPaths : object {
    public static bool IsLocalFolderPath(string localPath);
    [ExtensionAttribute]
public static bool EnsureDirectory(string localPath);
    [ExtensionAttribute]
public static string CombineLocalPath(string path, string fileOrFolder);
}
internal static class FluentFTP.Helpers.LocalPorts : object {
    internal static Random randomGen;
    private static LocalPorts();
    public static int GetRandomAvailable(IPAddress localIpAddress);
}
[ExtensionAttribute]
internal static class FluentFTP.Helpers.Logging.LoggerExtensions : object {
    [ExtensionAttribute]
public static void Log(IFtpLogger logger, FtpTraceLevel eventType, string message, Exception ex);
    [ExtensionAttribute]
public static string GetLogPrefix(FtpTraceLevel eventType);
}
internal static class FluentFTP.Helpers.Operators : object {
    public static bool Validate(FtpOperator op, int value, int x, int y);
    public static bool Validate(FtpOperator op, double value, double x, double y);
    public static bool Validate(FtpOperator op, long value, long x, long y);
}
internal static class FluentFTP.Helpers.Parsers.IBMOS400Parser : object {
    private static int formatIndex;
    private static string DirectoryMarker;
    private static string DDirectoryMarker;
    private static string MemoryMarker;
    private static string FileMarker;
    private static int MinFieldCount;
    private static String[][] DateTimeFormats;
    private static String[] ValidListFormats;
    private static IBMOS400Parser();
    public static bool IsValid(BaseFtpClient client, String[] listing);
    public static FtpListItem Parse(BaseFtpClient client, string record);
    private static DateTime ParseDateTime(BaseFtpClient client, string lastModifiedStr);
}
internal static class FluentFTP.Helpers.Parsers.IBMzOSParser : object {
    public static bool IsValid(BaseFtpClient client, String[] listing);
    public static FtpListItem Parse(BaseFtpClient client, string record, string path);
    private static DateTime ParseDateTime(BaseFtpClient client, string lastModifiedStr);
    private static bool IsValidHFS(string record);
}
internal static class FluentFTP.Helpers.Parsers.MachineListParser : object {
    private static DateTimeStyles DateTimeStyle;
    public static bool IsValid(BaseFtpClient client, String[] records);
    public static FtpListItem Parse(string record, List`1<FtpCapability> capabilities, BaseFtpClient client);
    private static void ParseDateTime(string record, FtpListItem item, BaseFtpClient client);
    private static void ParseFileSize(string record, FtpListItem item);
    private static void ParsePermissions(string record, FtpListItem item);
}
internal static class FluentFTP.Helpers.Parsers.NonStopParser : object {
    private static Char[] TrimValues;
    private static int MinFieldCount;
    private static String[] DateTimeFormats;
    private static NonStopParser();
    public static bool IsValid(BaseFtpClient client, String[] records);
    private static bool IsHeader(string line);
    public static FtpListItem Parse(BaseFtpClient client, string record);
    private static void ParseDirAndFileSize(BaseFtpClient client, String[] values, Boolean& isDir, Int64& size);
    private static DateTime ParseDateTime(BaseFtpClient client, string lastModifiedStr);
}
internal static class FluentFTP.Helpers.Parsers.UnixParser : object {
    private static string SymbolicLinkArrowMarker;
    private static char SymbolicLinkMarker;
    private static char FileMarker;
    private static char DirectoryMarker;
    private static int MinFieldCount;
    private static int MinFieldCountAlt;
    private static String[] DateTimeFormats1;
    private static String[] DateTimeFormats2;
    private static String[] DateTimeAltFormats1;
    private static String[] DateTimeAltFormats2;
    private static UnixParser();
    public static bool IsValid(BaseFtpClient client, String[] records);
    public static FtpListItem Parse(BaseFtpClient client, string record);
    private static int ParsePermissions(String[] values, Int32& index, String& permissions, Boolean& isDir, Boolean& isLink);
    private static int ParseLinkCount(BaseFtpClient client, String[] values, Int32& index);
    private static void ParseOwnerGroup(String[] values, Int32& index, String& owner, String& group);
    private static long ParseFileSize(BaseFtpClient client, String[] values, Int32& index);
    private static int ParseDayOfMonth(String[] values, Int32& index);
    private static void ParseName(BaseFtpClient client, string record, String[] values, bool isLink, int dayOfMonth, int dateTimePos, String& name, String& linkedname);
    private static void ParseDateTime(BaseFtpClient client, String[] values, Int32& index, int dayOfMonth, DateTime& lastModified);
    private static DateTime ParseYear(BaseFtpClient client, StringBuilder stamp, String[] format);
    private static DateTime ParseDateTime(BaseFtpClient client, StringBuilder stamp, String[] format);
    public static FtpListItem ParseUnixAlt(BaseFtpClient client, string record);
}
internal static class FluentFTP.Helpers.Parsers.VMSParser : object {
    private static string DirectoryMarker;
    private static string HDirectoryMarker;
    private static string TotalMarker;
    private static int MinFieldCount;
    private static int FileBlockSize;
    private static VMSParser();
    public static bool IsValid(BaseFtpClient client, String[] records);
    public static FtpListItem Parse(BaseFtpClient client, string record);
    private static long ParseFileSize(string sizeStr);
    private static void ParseGroupOwner(String[] values, String& group, String& owner);
    private static string ParsePermissions(String[] values);
    private static DateTime ParseDateTime(BaseFtpClient client, string date, string time);
}
internal static class FluentFTP.Helpers.Parsers.WindowsParser : object {
    private static string DirectoryMarker;
    private static int MinFieldCount;
    private static String[] DateTimeFormats;
    private static int OffsetLengthDirectory;
    private static int OffsetLengthFile;
    private static WindowsParser();
    public static bool IsValid(BaseFtpClient client, String[] records);
    public static FtpListItem Parse(BaseFtpClient client, string record);
    private static string ParseName(BaseFtpClient client, string record, String[] values, bool isDir);
    private static void ParseTypeAndFileSize(BaseFtpClient client, string type, Boolean& isDir, Int64& size);
    private static DateTime ParseDateTime(BaseFtpClient client, string lastModifiedStr);
}
[ExtensionAttribute]
internal static class FluentFTP.Helpers.Permissions : object {
    [ExtensionAttribute]
public static void CalculateChmod(FtpListItem item);
    [ExtensionAttribute]
public static void CalculateUnixPermissions(FtpListItem item, string permissions);
    public static int CalcChmod(FtpPermission owner, FtpPermission group, FtpPermission other);
    private static bool HasPermission(FtpPermission owner, FtpPermission flag);
}
[ExtensionAttribute]
public static class FluentFTP.Helpers.RemotePaths : object {
    [ExtensionAttribute]
public static bool IsAbsolutePath(string path);
    [ExtensionAttribute]
public static bool IsFtpRootDirectory(string ftppath);
    [ExtensionAttribute]
public static string GetFtpPath(string path);
    [ExtensionAttribute]
public static string GetFtpPath(string path, String[] segments);
    [ExtensionAttribute]
public static string GetFtpDirectoryName(string path);
    [ExtensionAttribute]
public static string GetFtpFileName(string path);
    [ExtensionAttribute]
public static String[] GetPathSegments(string path);
    [ExtensionAttribute]
public static void CalculateFullFtpPath(FtpListItem item, BaseFtpClient client, string path);
}
[ExtensionAttribute]
public static class FluentFTP.Helpers.Strings : object {
    public static bool IsNullOrWhiteSpace(string value);
    [ExtensionAttribute]
public static bool IsBlank(string value);
    [ExtensionAttribute]
public static string Join(String[] values, string delimiter);
    [ExtensionAttribute]
public static string Join(List`1<string> values, string delimiter);
    [ExtensionAttribute]
public static String[] AddPrefix(String[] values, string prefix, bool trim);
    [ExtensionAttribute]
public static List`1<string> AddPrefix(List`1<string> values, string prefix, bool trim);
    [ExtensionAttribute]
public static string EnsurePrefix(string text, string prefix);
    [ExtensionAttribute]
public static string EnsurePostfix(string text, string postfix);
    [ExtensionAttribute]
public static string RemovePrefix(string text, string prefix);
    [ExtensionAttribute]
public static string RemovePostfix(string text, string postfix);
    [ExtensionAttribute]
public static string EscapeStringLiteral(string input);
    [ExtensionAttribute]
public static String[] SplitString(string str);
    [ExtensionAttribute]
public static bool IsNumeric(string field);
    [ExtensionAttribute]
public static bool ContainsAny(string field, String[] values, int afterChar);
    [ExtensionAttribute]
public static bool IsValidRegEx(string pattern);
    [ExtensionAttribute]
public static bool ContainsAnyCI(string reply, String[] strings);
    [ExtensionAttribute]
public static bool EqualsAny(string text, String[] strings);
    [ExtensionAttribute]
public static bool ContainsCI(string value, string substring);
    [ExtensionAttribute]
public static bool StartsWithCI(string value, string substring);
    [ExtensionAttribute]
public static bool EndsWithCI(string value, string substring);
}
[ExtensionAttribute]
public static class FluentFTP.Helpers.TimeSpans : object {
    [ExtensionAttribute]
public static string ToShortString(TimeSpan span, string format, string zeroString);
}
[ExtensionAttribute]
internal static class FluentFTP.Helpers.Uris : object {
    [ExtensionAttribute]
public static void ValidateFtpServer(Uri uri);
}
[ExtensionAttribute]
public static class FluentFTP.Helpers.ValuePrinter : object {
    [ExtensionAttribute]
public static string ObjectToString(object obj);
    private static string ValueToString(object v);
}
public interface FluentFTP.IAsyncFtpClient {
    public abstract virtual void Dispose();
    public abstract virtual Task DisposeAsync();
    public abstract virtual bool HasFeature(FtpCapability cap);
    public abstract virtual Task DisableUTF8(CancellationToken token);
    public abstract virtual Task`1<FtpProfile> AutoConnect(CancellationToken token);
    public abstract virtual Task`1<List`1<FtpProfile>> AutoDetect(FtpAutoDetectConfig config, CancellationToken token);
    public abstract virtual Task`1<List`1<FtpProfile>> AutoDetect(bool firstOnly, bool cloneConnection, CancellationToken token);
    public abstract virtual Task Connect(CancellationToken token);
    public abstract virtual Task Connect(FtpProfile profile, CancellationToken token);
    public abstract virtual Task Connect(bool reConnect, CancellationToken token);
    public abstract virtual Task Disconnect(CancellationToken token);
    public abstract virtual Task`1<FtpReply> Execute(string command, CancellationToken token);
    public abstract virtual Task`1<List`1<string>> ExecuteDownloadText(string command, CancellationToken token);
    public abstract virtual Task`1<FtpReply> GetReply(CancellationToken token);
    public abstract virtual Task DeleteFile(string path, CancellationToken token);
    public abstract virtual Task DeleteDirectory(string path, CancellationToken token);
    public abstract virtual Task DeleteDirectory(string path, FtpListOption options, CancellationToken token);
    public abstract virtual Task EmptyDirectory(string path, CancellationToken token);
    public abstract virtual Task EmptyDirectory(string path, FtpListOption options, CancellationToken token);
    public abstract virtual Task`1<bool> DirectoryExists(string path, CancellationToken token);
    public abstract virtual Task`1<bool> FileExists(string path, CancellationToken token);
    public abstract virtual Task`1<bool> CreateDirectory(string path, bool force, CancellationToken token);
    public abstract virtual Task`1<bool> CreateDirectory(string path, CancellationToken token);
    public abstract virtual Task Rename(string path, string dest, CancellationToken token);
    public abstract virtual Task`1<bool> MoveFile(string path, string dest, FtpRemoteExists existsMode, CancellationToken token);
    public abstract virtual Task`1<bool> MoveDirectory(string path, string dest, FtpRemoteExists existsMode, CancellationToken token);
    public abstract virtual Task SetFilePermissions(string path, int permissions, CancellationToken token);
    public abstract virtual Task Chmod(string path, int permissions, CancellationToken token);
    public abstract virtual Task SetFilePermissions(string path, FtpPermission owner, FtpPermission group, FtpPermission other, CancellationToken token);
    public abstract virtual Task Chmod(string path, FtpPermission owner, FtpPermission group, FtpPermission other, CancellationToken token);
    public abstract virtual Task`1<FtpListItem> GetFilePermissions(string path, CancellationToken token);
    public abstract virtual Task`1<int> GetChmod(string path, CancellationToken token);
    public abstract virtual Task SetWorkingDirectory(string path, CancellationToken token);
    public abstract virtual Task`1<string> GetWorkingDirectory(CancellationToken token);
    public abstract virtual Task`1<long> GetFileSize(string path, long defaultValue, CancellationToken token);
    public abstract virtual Task`1<DateTime> GetModifiedTime(string path, CancellationToken token);
    public abstract virtual Task SetModifiedTime(string path, DateTime date, CancellationToken token);
    public abstract virtual Task`1<FtpListItem> GetObjectInfo(string path, bool dateModified, CancellationToken token);
    public abstract virtual Task`1<FtpListItem[]> GetListing(string path, FtpListOption options, CancellationToken token);
    public abstract virtual Task`1<FtpListItem[]> GetListing(string path, CancellationToken token);
    public abstract virtual Task`1<FtpListItem[]> GetListing(CancellationToken token);
    public abstract virtual Task`1<String[]> GetNameListing(string path, CancellationToken token);
    public abstract virtual Task`1<String[]> GetNameListing(CancellationToken token);
    public abstract virtual Task`1<Stream> OpenRead(string path, FtpDataType type, long restart, bool checkIfFileExists, CancellationToken token);
    public abstract virtual Task`1<Stream> OpenRead(string path, FtpDataType type, long restart, long fileLen, CancellationToken token);
    public abstract virtual Task`1<Stream> OpenWrite(string path, FtpDataType type, bool checkIfFileExists, CancellationToken token);
    public abstract virtual Task`1<Stream> OpenWrite(string path, FtpDataType type, long fileLen, CancellationToken token);
    public abstract virtual Task`1<Stream> OpenAppend(string path, FtpDataType type, bool checkIfFileExists, CancellationToken token);
    public abstract virtual Task`1<Stream> OpenAppend(string path, FtpDataType type, long fileLen, CancellationToken token);
    public abstract virtual Task`1<List`1<FtpResult>> UploadFiles(IEnumerable`1<string> localPaths, string remoteDir, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, FtpError errorHandling, CancellationToken token, IProgress`1<FtpProgress> progress, List`1<FtpRule> rules);
    public abstract virtual Task`1<List`1<FtpResult>> UploadFiles(IEnumerable`1<FileInfo> localFiles, string remoteDir, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, FtpError errorHandling, CancellationToken token, IProgress`1<FtpProgress> progress, List`1<FtpRule> rules);
    public abstract virtual Task`1<List`1<FtpResult>> DownloadFiles(string localDir, IEnumerable`1<string> remotePaths, FtpLocalExists existsMode, FtpVerify verifyOptions, FtpError errorHandling, CancellationToken token, IProgress`1<FtpProgress> progress, List`1<FtpRule> rules);
    public abstract virtual Task`1<FtpStatus> UploadFile(string localPath, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, IProgress`1<FtpProgress> progress, CancellationToken token);
    public abstract virtual Task`1<FtpStatus> UploadStream(Stream fileStream, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, IProgress`1<FtpProgress> progress, CancellationToken token);
    public abstract virtual Task`1<FtpStatus> UploadBytes(Byte[] fileData, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, IProgress`1<FtpProgress> progress, CancellationToken token);
    public abstract virtual Task`1<FtpStatus> DownloadFile(string localPath, string remotePath, FtpLocalExists existsMode, FtpVerify verifyOptions, IProgress`1<FtpProgress> progress, CancellationToken token);
    public abstract virtual Task`1<bool> DownloadStream(Stream outStream, string remotePath, long restartPosition, IProgress`1<FtpProgress> progress, CancellationToken token, long stopPosition);
    public abstract virtual Task`1<Byte[]> DownloadBytes(string remotePath, long restartPosition, IProgress`1<FtpProgress> progress, CancellationToken token, long stopPosition);
    public abstract virtual Task`1<Byte[]> DownloadBytes(string remotePath, CancellationToken token);
    public abstract virtual Task`1<Byte[]> DownloadUriBytes(string uri, IProgress`1<FtpProgress> progress, CancellationToken token);
    public abstract virtual Task`1<List`1<FtpResult>> DownloadDirectory(string localFolder, string remoteFolder, FtpFolderSyncMode mode, FtpLocalExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, IProgress`1<FtpProgress> progress, CancellationToken token);
    public abstract virtual Task`1<List`1<FtpResult>> UploadDirectory(string localFolder, string remoteFolder, FtpFolderSyncMode mode, FtpRemoteExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, IProgress`1<FtpProgress> progress, CancellationToken token);
    public abstract virtual Task`1<FtpHash> GetChecksum(string path, FtpHashAlgorithm algorithm, CancellationToken token);
    public abstract virtual Task`1<FtpCompareResult> CompareFile(string localPath, string remotePath, FtpCompareOption options, CancellationToken token);
}
public interface FluentFTP.IBaseFtpClient {
    public FtpConfig Config { get; public set; }
    public IFtpLogger Logger { get; public set; }
    public bool IsDisposed { get; }
    public bool IsConnected { get; }
    public string Host { get; public set; }
    public int Port { get; public set; }
    public NetworkCredential Credentials { get; public set; }
    public List`1<FtpCapability> Capabilities { get; }
    public FtpHashAlgorithm HashAlgorithms { get; }
    public string SystemType { get; }
    public FtpServer ServerType { get; }
    public FtpBaseServer ServerHandler { get; public set; }
    public FtpOperatingSystem ServerOS { get; }
    public string ConnectionType { get; }
    public FtpReply LastReply { get; }
    public List`1<FtpReply> LastReplies { get; public set; }
    public Encoding Encoding { get; public set; }
    public Action`2<FtpTraceLevel, string> LegacyLogger { get; public set; }
    public FtpClientState Status { get; }
    public Nullable`1<FtpIpVersion> InternetProtocol { get; }
    public bool IsAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool ValidateCertificateHandlerExists { get; }
    public bool RecursiveList { get; }
    public IPEndPoint SocketLocalEndPoint { get; }
    public IPEndPoint SocketRemoteEndPoint { get; }
    public abstract virtual FtpConfig get_Config();
    public abstract virtual void set_Config(FtpConfig value);
    public abstract virtual IFtpLogger get_Logger();
    public abstract virtual void set_Logger(IFtpLogger value);
    public abstract virtual bool get_IsDisposed();
    public abstract virtual bool get_IsConnected();
    public abstract virtual string get_Host();
    public abstract virtual void set_Host(string value);
    public abstract virtual int get_Port();
    public abstract virtual void set_Port(int value);
    public abstract virtual NetworkCredential get_Credentials();
    public abstract virtual void set_Credentials(NetworkCredential value);
    public abstract virtual List`1<FtpCapability> get_Capabilities();
    public abstract virtual FtpHashAlgorithm get_HashAlgorithms();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ValidateCertificate(FtpSslValidation value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ValidateCertificate(FtpSslValidation value);
    public abstract virtual string get_SystemType();
    public abstract virtual FtpServer get_ServerType();
    public abstract virtual FtpBaseServer get_ServerHandler();
    public abstract virtual void set_ServerHandler(FtpBaseServer value);
    public abstract virtual FtpOperatingSystem get_ServerOS();
    public abstract virtual string get_ConnectionType();
    public abstract virtual FtpReply get_LastReply();
    public abstract virtual List`1<FtpReply> get_LastReplies();
    public abstract virtual void set_LastReplies(List`1<FtpReply> value);
    public abstract virtual Encoding get_Encoding();
    public abstract virtual void set_Encoding(Encoding value);
    public abstract virtual Action`2<FtpTraceLevel, string> get_LegacyLogger();
    public abstract virtual void set_LegacyLogger(Action`2<FtpTraceLevel, string> value);
    public abstract virtual FtpClientState get_Status();
    public abstract virtual Nullable`1<FtpIpVersion> get_InternetProtocol();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_ValidateCertificateHandlerExists();
    public abstract virtual bool get_RecursiveList();
    public abstract virtual IPEndPoint get_SocketLocalEndPoint();
    public abstract virtual IPEndPoint get_SocketRemoteEndPoint();
}
public interface FluentFTP.IFtpClient {
    public abstract virtual bool HasFeature(FtpCapability cap);
    public abstract virtual void DisableUTF8();
    public abstract virtual List`1<FtpProfile> AutoDetect(FtpAutoDetectConfig config);
    public abstract virtual List`1<FtpProfile> AutoDetect(bool firstOnly, bool cloneConnection);
    public abstract virtual FtpProfile AutoConnect();
    public abstract virtual void Connect();
    public abstract virtual void Connect(FtpProfile profile);
    public abstract virtual void Connect(bool reConnect);
    public abstract virtual void Disconnect();
    public abstract virtual FtpReply Execute(string command);
    public abstract virtual List`1<string> ExecuteDownloadText(string command);
    public abstract virtual FtpReply GetReply();
    public abstract virtual void DeleteFile(string path);
    public abstract virtual void DeleteDirectory(string path);
    public abstract virtual void DeleteDirectory(string path, FtpListOption options);
    public abstract virtual void EmptyDirectory(string path);
    public abstract virtual void EmptyDirectory(string path, FtpListOption options);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual bool FileExists(string path);
    public abstract virtual bool CreateDirectory(string path);
    public abstract virtual bool CreateDirectory(string path, bool force);
    public abstract virtual void Rename(string path, string dest);
    public abstract virtual bool MoveFile(string path, string dest, FtpRemoteExists existsMode);
    public abstract virtual bool MoveDirectory(string path, string dest, FtpRemoteExists existsMode);
    public abstract virtual void SetFilePermissions(string path, int permissions);
    public abstract virtual void Chmod(string path, int permissions);
    public abstract virtual void SetFilePermissions(string path, FtpPermission owner, FtpPermission group, FtpPermission other);
    public abstract virtual void Chmod(string path, FtpPermission owner, FtpPermission group, FtpPermission other);
    public abstract virtual FtpListItem GetFilePermissions(string path);
    public abstract virtual int GetChmod(string path);
    public abstract virtual void SetWorkingDirectory(string path);
    public abstract virtual string GetWorkingDirectory();
    public abstract virtual long GetFileSize(string path, long defaultValue);
    public abstract virtual DateTime GetModifiedTime(string path);
    public abstract virtual void SetModifiedTime(string path, DateTime date);
    public abstract virtual FtpListItem GetObjectInfo(string path, bool dateModified);
    public abstract virtual FtpListItem[] GetListing();
    public abstract virtual FtpListItem[] GetListing(string path);
    public abstract virtual FtpListItem[] GetListing(string path, FtpListOption options);
    public abstract virtual String[] GetNameListing();
    public abstract virtual String[] GetNameListing(string path);
    public abstract virtual Stream OpenRead(string path, FtpDataType type, long restart, bool checkIfFileExists);
    public abstract virtual Stream OpenRead(string path, FtpDataType type, long restart, long fileLen);
    public abstract virtual Stream OpenWrite(string path, FtpDataType type, bool checkIfFileExists);
    public abstract virtual Stream OpenWrite(string path, FtpDataType type, long fileLen);
    public abstract virtual Stream OpenAppend(string path, FtpDataType type, bool checkIfFileExists);
    public abstract virtual Stream OpenAppend(string path, FtpDataType type, long fileLen);
    public abstract virtual List`1<FtpResult> UploadFiles(IEnumerable`1<string> localPaths, string remoteDir, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, FtpError errorHandling, Action`1<FtpProgress> progress, List`1<FtpRule> rules);
    public abstract virtual List`1<FtpResult> UploadFiles(IEnumerable`1<FileInfo> localFiles, string remoteDir, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, FtpError errorHandling, Action`1<FtpProgress> progress, List`1<FtpRule> rules);
    public abstract virtual List`1<FtpResult> DownloadFiles(string localDir, IEnumerable`1<string> remotePaths, FtpLocalExists existsMode, FtpVerify verifyOptions, FtpError errorHandling, Action`1<FtpProgress> progress, List`1<FtpRule> rules);
    public abstract virtual FtpStatus UploadFile(string localPath, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, FtpVerify verifyOptions, Action`1<FtpProgress> progress);
    public abstract virtual FtpStatus UploadStream(Stream fileStream, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, Action`1<FtpProgress> progress);
    public abstract virtual FtpStatus UploadBytes(Byte[] fileData, string remotePath, FtpRemoteExists existsMode, bool createRemoteDir, Action`1<FtpProgress> progress);
    public abstract virtual FtpStatus DownloadFile(string localPath, string remotePath, FtpLocalExists existsMode, FtpVerify verifyOptions, Action`1<FtpProgress> progress);
    public abstract virtual bool DownloadStream(Stream outStream, string remotePath, long restartPosition, Action`1<FtpProgress> progress, long stopPosition);
    public abstract virtual bool DownloadBytes(Byte[]& outBytes, string remotePath, long restartPosition, Action`1<FtpProgress> progress, long stopPosition);
    public abstract virtual bool DownloadUriBytes(Byte[]& outBytes, string uri, Action`1<FtpProgress> progress);
    public abstract virtual List`1<FtpResult> DownloadDirectory(string localFolder, string remoteFolder, FtpFolderSyncMode mode, FtpLocalExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, Action`1<FtpProgress> progress);
    public abstract virtual List`1<FtpResult> UploadDirectory(string localFolder, string remoteFolder, FtpFolderSyncMode mode, FtpRemoteExists existsMode, FtpVerify verifyOptions, List`1<FtpRule> rules, Action`1<FtpProgress> progress);
    public abstract virtual FtpHash GetChecksum(string path, FtpHashAlgorithm algorithm);
    public abstract virtual FtpCompareResult CompareFile(string localPath, string remotePath, FtpCompareOption options);
}
public interface FluentFTP.IFtpLogger {
    public abstract virtual void Log(FtpLogEntry entry);
}
public interface FluentFTP.IInternalFtpClient {
    public abstract virtual void ConnectInternal(bool reConnect);
    public abstract virtual Task ConnectInternal(bool reConnect, CancellationToken token);
    public abstract virtual void DisconnectInternal();
    public abstract virtual Task DisconnectInternal(CancellationToken token);
    public abstract virtual void DisposeInternal();
    public abstract virtual Task DisposeInternal(CancellationToken token);
    public abstract virtual FtpReply ExecuteInternal(string command);
    public abstract virtual FtpReply GetReplyInternal();
    public abstract virtual FtpReply GetReplyInternal(string command);
    public abstract virtual FtpReply GetReplyInternal(string command, bool exhaustNoop);
    public abstract virtual FtpReply GetReplyInternal(string command, bool exhaustNoop, int timeOut);
    public abstract virtual FtpReply GetReplyInternal(string command, bool exhaustNoop, int timeOut, bool useSema);
    public abstract virtual Task`1<FtpReply> GetReplyInternal(CancellationToken token);
    public abstract virtual Task`1<FtpReply> GetReplyInternal(CancellationToken token, string command);
    public abstract virtual Task`1<FtpReply> GetReplyInternal(CancellationToken token, string command, bool exhaustNoop);
    public abstract virtual Task`1<FtpReply> GetReplyInternal(CancellationToken token, string command, bool exhaustNoop, int timeOut);
    public abstract virtual Task`1<FtpReply> GetReplyInternal(CancellationToken token, string command, bool exhaustNoop, int timeOut, bool useSema);
    public abstract virtual bool IsStillConnectedInternal(int timeout);
    public abstract virtual bool NoopInternal(bool ignoreNoopInterval);
    public abstract virtual string GetWorkingDirectoryInternal();
    public abstract virtual FtpReply CloseDataStreamInternal(FtpDataStream stream);
    public abstract virtual Task`1<FtpReply> CloseDataStreamInternal(FtpDataStream stream, CancellationToken token);
    public abstract virtual void LogStatus(FtpTraceLevel eventType, string message, Exception exception, bool exNewLine);
    public abstract virtual void LogLine(FtpTraceLevel eventType, string message);
    public abstract virtual FtpSocketStream GetBaseStream();
    public abstract virtual void SetListingParser(FtpParser parser);
}
public class FluentFTP.Model.Functions.FtpAutoDetectConfig : object {
    [CompilerGeneratedAttribute]
private bool <CloneConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FirstOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AbortOnTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireEncryption>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslProtocols> <ProtocolPriority>k__BackingField;
    public bool CloneConnection { get; public set; }
    public bool FirstOnly { get; public set; }
    public bool IncludeImplicit { get; public set; }
    public bool AbortOnTimeout { get; public set; }
    public bool RequireEncryption { get; public set; }
    public List`1<SslProtocols> ProtocolPriority { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CloneConnection();
    [CompilerGeneratedAttribute]
public void set_CloneConnection(bool value);
    [CompilerGeneratedAttribute]
public bool get_FirstOnly();
    [CompilerGeneratedAttribute]
public void set_FirstOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeImplicit();
    [CompilerGeneratedAttribute]
public void set_IncludeImplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_AbortOnTimeout();
    [CompilerGeneratedAttribute]
public void set_AbortOnTimeout(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequireEncryption();
    [CompilerGeneratedAttribute]
public void set_RequireEncryption(bool value);
    [CompilerGeneratedAttribute]
public List`1<SslProtocols> get_ProtocolPriority();
    [CompilerGeneratedAttribute]
public void set_ProtocolPriority(List`1<SslProtocols> value);
}
public class FluentFTP.Proxy.AsyncProxy.AsyncFtpClientBlueCoatProxy : AsyncFtpClientProxy {
    public AsyncFtpClientBlueCoatProxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientBlueCoatProxy/<HandshakeAsync>d__2")]
protected virtual Task HandshakeAsync(CancellationToken token);
}
public class FluentFTP.Proxy.AsyncProxy.AsyncFtpClientHttp11Proxy : AsyncFtpClientProxy {
    public AsyncFtpClientHttp11Proxy(FtpProxyProfile proxy);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientHttp11Proxy/<HandshakeAsync>d__1")]
protected virtual Task HandshakeAsync(CancellationToken token);
    protected virtual BaseFtpClient Create();
    protected virtual Task ConnectAsync(FtpSocketStream stream, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientHttp11Proxy/<ConnectAsync>d__4")]
protected virtual Task ConnectAsync(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientHttp11Proxy/<ProxyHandshakeAsync>d__5")]
private Task ProxyHandshakeAsync(FtpSocketStream stream, CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientHttp11Proxy/<GetProxyReplyAsync>d__6")]
private Task`1<FtpReply> GetProxyReplyAsync(FtpSocketStream stream, CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(FtpSocketStream stream, CancellationToken token);
}
public abstract class FluentFTP.Proxy.AsyncProxy.AsyncFtpClientProxy : AsyncFtpClient {
    private FtpProxyProfile _proxy;
    protected FtpProxyProfile Proxy { get; }
    protected AsyncFtpClientProxy(FtpProxyProfile proxy);
    protected FtpProxyProfile get_Proxy();
    protected virtual Task ConnectAsync(FtpSocketStream stream, CancellationToken token);
    protected virtual Task ConnectAsync(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions, CancellationToken token);
}
public class FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks4aProxy : AsyncFtpClientProxy {
    public AsyncFtpClientSocks4aProxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks4aProxy/<HandshakeAsync>d__2")]
protected virtual Task HandshakeAsync(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks4aProxy/<ConnectAsync>d__3")]
protected virtual Task ConnectAsync(FtpSocketStream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks4aProxy/<ConnectAsync>d__4")]
protected virtual Task ConnectAsync(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(FtpSocketStream stream, CancellationToken token);
}
public class FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks4Proxy : AsyncFtpClientProxy {
    public AsyncFtpClientSocks4Proxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks4Proxy/<HandshakeAsync>d__2")]
protected virtual Task HandshakeAsync(CancellationToken token);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks4Proxy/<ConnectAsync>d__3")]
protected virtual Task ConnectAsync(FtpSocketStream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks4Proxy/<ConnectAsync>d__4")]
protected virtual Task ConnectAsync(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__1(FtpSocketStream stream, CancellationToken token);
}
public class FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks5Proxy : AsyncFtpClientProxy {
    public AsyncFtpClientSocks5Proxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks5Proxy/<ConnectAsync>d__2")]
protected virtual Task ConnectAsync(FtpSocketStream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientSocks5Proxy/<ConnectAsync>d__3")]
protected virtual Task ConnectAsync(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions, CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(FtpSocketStream stream, CancellationToken token);
}
public class FluentFTP.Proxy.AsyncProxy.AsyncFtpClientUserAtHostProxy : AsyncFtpClientProxy {
    public AsyncFtpClientUserAtHostProxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.AsyncProxy.AsyncFtpClientUserAtHostProxy/<HandshakeAsync>d__2")]
protected virtual Task HandshakeAsync(CancellationToken token);
}
internal enum FluentFTP.Proxy.Enums.SocksAuthType : Enum {
    public int value__;
    public static SocksAuthType NoAuthRequired;
    public static SocksAuthType GSSAPI;
    public static SocksAuthType UsernamePassword;
    public static SocksAuthType NoAcceptableMethods;
}
internal enum FluentFTP.Proxy.Enums.SocksReply : Enum {
    public int value__;
    public static SocksReply Succeeded;
    public static SocksReply GeneralSOCKSServerFailure;
    public static SocksReply NotAllowedByRuleset;
    public static SocksReply NetworkUnreachable;
    public static SocksReply HostUnreachable;
    public static SocksReply ConnectionRefused;
    public static SocksReply TTLExpired;
    public static SocksReply CommandNotSupported;
    public static SocksReply AddressTypeNotSupported;
}
internal enum FluentFTP.Proxy.Enums.SocksRequestAddressType : Enum {
    public int value__;
    public static SocksRequestAddressType Unknown;
    public static SocksRequestAddressType IPv4;
    public static SocksRequestAddressType FQDN;
    public static SocksRequestAddressType IPv6;
}
internal enum FluentFTP.Proxy.Enums.SocksRequestCommand : Enum {
    public byte value__;
    public static SocksRequestCommand Connect;
    public static SocksRequestCommand Bind;
    public static SocksRequestCommand UdpAssociate;
}
internal enum FluentFTP.Proxy.Enums.SocksVersion : Enum {
    public int value__;
    public static SocksVersion V4;
    public static SocksVersion V5;
}
internal class FluentFTP.Proxy.Socks.Socks4aProxy : Socks4Proxy {
    private Byte[] _buffer;
    private string _destinationHost;
    private int _destinationPort;
    private FtpSocketStream _socketStream;
    public Socks4aProxy(string destinationHost, int destinationPort, FtpSocketStream socketStream);
    public virtual void Connect();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.Socks.Socks4aProxy/<ConnectAsync>d__6")]
public virtual Task ConnectAsync(CancellationToken cancellationToken);
}
internal class FluentFTP.Proxy.Socks.Socks4Proxy : object {
    private Byte[] _buffer;
    private string _destinationHost;
    private int _destinationPort;
    private FtpSocketStream _socketStream;
    public Socks4Proxy(string destinationHost, int destinationPort, FtpSocketStream socketStream);
    protected Byte[] GetIPAddressBytes(string destinationHost);
    protected Byte[] GetDestinationPortBytes(int value);
    public virtual void Connect();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.Socks.Socks4Proxy/<ConnectAsync>d__8")]
public virtual Task ConnectAsync(CancellationToken cancellationToken);
}
internal class FluentFTP.Proxy.Socks.SocksProxy : object {
    private Byte[] _buffer;
    private string _destinationHost;
    private int _destinationPort;
    private FtpSocketStream _socketStream;
    private Nullable`1<SocksAuthType> _authType;
    private FtpProxyProfile _proxyInfo;
    public SocksProxy(string destinationHost, int destinationPort, FtpSocketStream socketStream, FtpProxyProfile proxyInfo);
    public void Negotiate();
    private byte MapAuthMethod();
    public void Authenticate();
    public void Connect();
    private void AuthenticateInternal();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.Socks.SocksProxy/<AuthenticateInternalAsync>d__12")]
private Task AuthenticateInternalAsync(CancellationToken cancellationToken);
    private void AuthenticateUsernamePassword();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.Socks.SocksProxy/<AuthenticateUsernamePasswordAsync>d__14")]
private Task AuthenticateUsernamePasswordAsync(CancellationToken cancellationToken);
    private Byte[] GetAuthBuffer();
    private Byte[] GetConnectRequest();
    [AsyncStateMachineAttribute("FluentFTP.Proxy.Socks.SocksProxy/<NegotiateAsync>d__17")]
public Task NegotiateAsync(CancellationToken cancellationToken);
    public Task AuthenticateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("FluentFTP.Proxy.Socks.SocksProxy/<ConnectAsync>d__19")]
public Task ConnectAsync(CancellationToken cancellationToken);
    private void HandleProxyCommandError(SocksReply replyCode);
}
public class FluentFTP.Proxy.SyncProxy.FtpClientBlueCoatProxy : FtpClientProxy {
    public FtpClientBlueCoatProxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    protected virtual void Handshake();
}
public class FluentFTP.Proxy.SyncProxy.FtpClientHttp11Proxy : FtpClientProxy {
    public FtpClientHttp11Proxy(FtpProxyProfile proxy);
    protected virtual void Handshake();
    protected virtual BaseFtpClient Create();
    protected virtual void Connect(FtpSocketStream stream);
    protected virtual void Connect(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions);
    private void ProxyHandshake(FtpSocketStream stream);
    private FtpReply GetProxyReply(FtpSocketStream stream);
}
public abstract class FluentFTP.Proxy.SyncProxy.FtpClientProxy : FtpClient {
    private FtpProxyProfile _proxy;
    protected FtpProxyProfile Proxy { get; }
    protected FtpClientProxy(FtpProxyProfile proxy);
    protected FtpProxyProfile get_Proxy();
    protected virtual void Connect(FtpSocketStream stream);
}
public class FluentFTP.Proxy.SyncProxy.FtpClientSocks4aProxy : FtpClientProxy {
    public FtpClientSocks4aProxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    protected virtual void Handshake();
    protected virtual void Connect(FtpSocketStream stream);
    protected virtual void Connect(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions);
}
public class FluentFTP.Proxy.SyncProxy.FtpClientSocks4Proxy : FtpClientProxy {
    public FtpClientSocks4Proxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    protected virtual void Handshake();
    protected virtual void Connect(FtpSocketStream stream);
    protected virtual void Connect(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions);
}
public class FluentFTP.Proxy.SyncProxy.FtpClientSocks5Proxy : FtpClientProxy {
    public FtpClientSocks5Proxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    protected virtual void Connect(FtpSocketStream stream);
    protected virtual void Connect(FtpSocketStream stream, string host, int port, FtpIpVersion ipVersions);
}
public class FluentFTP.Proxy.SyncProxy.FtpClientUserAtHostProxy : FtpClientProxy {
    public FtpClientUserAtHostProxy(FtpProxyProfile proxy);
    protected virtual BaseFtpClient Create();
    protected virtual void Handshake();
}
public class FluentFTP.Rules.FtpFileExtensionRule : FtpRule {
    [CompilerGeneratedAttribute]
private bool <Whitelist>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Exts>k__BackingField;
    public bool Whitelist { get; public set; }
    public IList`1<string> Exts { get; public set; }
    public FtpFileExtensionRule(bool whitelist, IList`1<string> exts);
    [CompilerGeneratedAttribute]
public bool get_Whitelist();
    [CompilerGeneratedAttribute]
public void set_Whitelist(bool value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Exts();
    [CompilerGeneratedAttribute]
public void set_Exts(IList`1<string> value);
    public virtual bool IsAllowed(FtpListItem item);
}
public class FluentFTP.Rules.FtpFileNameRegexRule : FtpRule {
    [CompilerGeneratedAttribute]
private bool <Whitelist>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <RegexPatterns>k__BackingField;
    public bool Whitelist { get; public set; }
    public List`1<string> RegexPatterns { get; public set; }
    public FtpFileNameRegexRule(bool whitelist, IList`1<string> regexPatterns);
    [CompilerGeneratedAttribute]
public bool get_Whitelist();
    [CompilerGeneratedAttribute]
public void set_Whitelist(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_RegexPatterns();
    [CompilerGeneratedAttribute]
public void set_RegexPatterns(List`1<string> value);
    public virtual bool IsAllowed(FtpListItem item);
}
public class FluentFTP.Rules.FtpFileNameRule : FtpRule {
    [CompilerGeneratedAttribute]
private bool <Whitelist>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Names>k__BackingField;
    public bool Whitelist { get; public set; }
    public IList`1<string> Names { get; public set; }
    public FtpFileNameRule(bool whitelist, IList`1<string> names);
    [CompilerGeneratedAttribute]
public bool get_Whitelist();
    [CompilerGeneratedAttribute]
public void set_Whitelist(bool value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Names();
    [CompilerGeneratedAttribute]
public void set_Names(IList`1<string> value);
    public virtual bool IsAllowed(FtpListItem item);
}
public class FluentFTP.Rules.FtpFolderNameRule : FtpRule {
    public static List`1<string> CommonBlacklistedFolders;
    [CompilerGeneratedAttribute]
private bool <Whitelist>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Names>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartSegment>k__BackingField;
    public bool Whitelist { get; public set; }
    public IList`1<string> Names { get; public set; }
    public int StartSegment { get; public set; }
    public FtpFolderNameRule(bool whitelist, IList`1<string> names, int startSegment);
    private static FtpFolderNameRule();
    [CompilerGeneratedAttribute]
public bool get_Whitelist();
    [CompilerGeneratedAttribute]
public void set_Whitelist(bool value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Names();
    [CompilerGeneratedAttribute]
public void set_Names(IList`1<string> value);
    [CompilerGeneratedAttribute]
public int get_StartSegment();
    [CompilerGeneratedAttribute]
public void set_StartSegment(int value);
    public virtual bool IsAllowed(FtpListItem item);
}
public class FluentFTP.Rules.FtpFolderRegexRule : FtpRule {
    [CompilerGeneratedAttribute]
private bool <Whitelist>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <RegexPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartSegment>k__BackingField;
    public bool Whitelist { get; public set; }
    public List`1<string> RegexPatterns { get; public set; }
    public int StartSegment { get; public set; }
    public FtpFolderRegexRule(bool whitelist, IList`1<string> regexPatterns, int startSegment);
    [CompilerGeneratedAttribute]
public bool get_Whitelist();
    [CompilerGeneratedAttribute]
public void set_Whitelist(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_RegexPatterns();
    [CompilerGeneratedAttribute]
public void set_RegexPatterns(List`1<string> value);
    [CompilerGeneratedAttribute]
public int get_StartSegment();
    [CompilerGeneratedAttribute]
public void set_StartSegment(int value);
    public virtual bool IsAllowed(FtpListItem item);
}
public class FluentFTP.Rules.FtpRule : object {
    public virtual bool IsAllowed(FtpListItem result);
    public static bool IsAllAllowed(List`1<FtpRule> rules, FtpListItem result);
}
public class FluentFTP.Rules.FtpSizeRule : FtpRule {
    [CompilerGeneratedAttribute]
private FtpOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private long <X>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Y>k__BackingField;
    public FtpOperator Operator { get; public set; }
    public long X { get; public set; }
    public long Y { get; public set; }
    public FtpSizeRule(FtpOperator ruleOperator, long x, long y);
    [CompilerGeneratedAttribute]
public FtpOperator get_Operator();
    [CompilerGeneratedAttribute]
public void set_Operator(FtpOperator value);
    [CompilerGeneratedAttribute]
public long get_X();
    [CompilerGeneratedAttribute]
public void set_X(long value);
    [CompilerGeneratedAttribute]
public long get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(long value);
    public virtual bool IsAllowed(FtpListItem result);
}
public abstract class FluentFTP.Servers.FtpBaseServer : object {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual bool DetectBySyst(string message);
    public virtual bool RecursiveList();
    public virtual String[] DefaultCapabilities();
    public virtual FtpParser GetParser();
    public virtual bool DeleteDirectory(FtpClient client, string path, string ftppath, bool deleteContents, FtpListOption options);
    public virtual Task`1<bool> DeleteDirectoryAsync(AsyncFtpClient client, string path, string ftppath, bool deleteContents, FtpListOption options, CancellationToken token);
    public virtual bool CreateDirectory(FtpClient client, string path, string ftppath, bool force);
    public virtual Task`1<bool> CreateDirectoryAsync(AsyncFtpClient client, string path, string ftppath, bool force, CancellationToken token);
    public virtual void AfterConnected(FtpClient client);
    public virtual Task AfterConnectedAsync(AsyncFtpClient client, CancellationToken token);
    public virtual bool IsCustomFileSize();
    public virtual long GetFileSize(FtpClient client, string path);
    public virtual Task`1<long> GetFileSizeAsync(AsyncFtpClient client, string path, CancellationToken token);
    public virtual bool IsRoot(BaseFtpClient client, string path);
    public virtual bool SkipParserErrorReport();
    public virtual bool AlwaysReadToEnd(string remotePath);
    public virtual bool IsAbsolutePath(string path);
    public virtual bool IsCustomGetAbsolutePath();
    public virtual string GetAbsolutePath(FtpClient client, string path);
    public virtual Task`1<string> GetAbsolutePathAsync(AsyncFtpClient client, string path, CancellationToken token);
    public virtual bool IsCustomGetAbsoluteDir();
    public virtual string GetAbsoluteDir(FtpClient client, string path);
    public virtual Task`1<string> GetAbsoluteDirAsync(AsyncFtpClient client, string path, CancellationToken token);
    public virtual bool IsCustomGetAbsoluteFilePath();
    public virtual string GetAbsoluteFilePath(FtpClient client, string path, string fileName);
    public virtual Task`1<string> GetAbsoluteFilePathAsync(AsyncFtpClient client, string path, string fileName, CancellationToken token);
    public virtual bool IsCustomCalculateFullFtpPath();
    public virtual Nullable`1<bool> CalculateFullFtpPath(BaseFtpClient client, string path, FtpListItem item);
    public virtual bool DontUseSizeEvenIfCapable(string path);
    public virtual bool DontUseMdtmEvenIfCapable(string path);
    public virtual bool IsCustomFileExists();
    public virtual Nullable`1<bool> FileExists(FtpClient client, string path);
    public virtual Task`1<Nullable`1<bool>> FileExistsAsync(AsyncFtpClient client, string path, CancellationToken token);
}
internal static class FluentFTP.Servers.FtpHandlerIndex : object {
    public static List`1<FtpBaseServer> AllServers;
    private static FtpHandlerIndex();
}
internal class FluentFTP.Servers.Handlers.ApacheFtpServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectBySyst(string message);
}
internal class FluentFTP.Servers.Handlers.BFtpdServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.CerberusServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.CrushFtpServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.DLinkServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.FileZillaServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual bool RecursiveList();
}
internal class FluentFTP.Servers.Handlers.FritzBoxServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.Ftp2S3GatewayServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.GlFtpdServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.GlobalScapeEftServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.HomegateFtpServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.HuaweiServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.IBMOS400FtpServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual bool DetectBySyst(string message);
    public virtual FtpParser GetParser();
    public virtual void AfterConnected(FtpClient client);
    [AsyncStateMachineAttribute("FluentFTP.Servers.Handlers.IBMOS400FtpServer/<AfterConnectedAsync>d__5")]
public virtual Task AfterConnectedAsync(AsyncFtpClient client, CancellationToken token);
}
internal class FluentFTP.Servers.Handlers.IBMzOSFtpServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual FtpParser GetParser();
    public virtual void AfterConnected(FtpClient client);
    [AsyncStateMachineAttribute("FluentFTP.Servers.Handlers.IBMzOSFtpServer/<AfterConnectedAsync>d__4")]
public virtual Task AfterConnectedAsync(AsyncFtpClient client, CancellationToken token);
    public virtual bool IsCustomFileSize();
    public virtual long GetFileSize(FtpClient client, string path);
    [AsyncStateMachineAttribute("FluentFTP.Servers.Handlers.IBMzOSFtpServer/<GetFileSizeAsync>d__7")]
public virtual Task`1<long> GetFileSizeAsync(AsyncFtpClient client, string path, CancellationToken token);
    public virtual bool IsRoot(BaseFtpClient client, string path);
    public virtual bool SkipParserErrorReport();
    public virtual bool AlwaysReadToEnd(string remotePath);
    public virtual bool IsCustomGetAbsolutePath();
    public virtual string GetAbsolutePath(FtpClient client, string path);
    [AsyncStateMachineAttribute("FluentFTP.Servers.Handlers.IBMzOSFtpServer/<GetAbsolutePathAsync>d__13")]
public virtual Task`1<string> GetAbsolutePathAsync(AsyncFtpClient client, string path, CancellationToken token);
    public virtual bool IsCustomGetAbsoluteDir();
    public virtual string GetAbsoluteDir(FtpClient client, string path);
    [AsyncStateMachineAttribute("FluentFTP.Servers.Handlers.IBMzOSFtpServer/<GetAbsoluteDirAsync>d__16")]
public virtual Task`1<string> GetAbsoluteDirAsync(AsyncFtpClient client, string path, CancellationToken token);
    public virtual bool IsCustomGetAbsoluteFilePath();
    public virtual string GetAbsoluteFilePath(FtpClient client, string path, string fileName);
    public virtual Task`1<string> GetAbsoluteFilePathAsync(AsyncFtpClient client, string path, string fileName, CancellationToken token);
    public virtual bool IsCustomCalculateFullFtpPath();
    public virtual Nullable`1<bool> CalculateFullFtpPath(BaseFtpClient client, string path, FtpListItem item);
    public virtual bool DontUseSizeEvenIfCapable(string path);
    public virtual bool DontUseMdtmEvenIfCapable(string path);
    public virtual bool IsCustomFileExists();
    public virtual Nullable`1<bool> FileExists(FtpClient client, string path);
    [AsyncStateMachineAttribute("FluentFTP.Servers.Handlers.IBMzOSFtpServer/<FileExistsAsync>d__26")]
public virtual Task`1<Nullable`1<bool>> FileExistsAsync(AsyncFtpClient client, string path, CancellationToken token);
}
internal class FluentFTP.Servers.Handlers.IDALFtpServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.MicroTikServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.NonStopTandemServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual FtpParser GetParser();
}
internal class FluentFTP.Servers.Handlers.OpenVmsServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual bool DetectBySyst(string message);
    public virtual String[] DefaultCapabilities();
    public virtual bool IsAbsolutePath(string path);
    public virtual FtpParser GetParser();
    public virtual bool IsCustomCalculateFullFtpPath();
    public virtual Nullable`1<bool> CalculateFullFtpPath(BaseFtpClient client, string path, FtpListItem item);
}
internal class FluentFTP.Servers.Handlers.ProFtpdServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual bool RecursiveList();
    public virtual bool DeleteDirectory(FtpClient client, string path, string ftppath, bool deleteContents, FtpListOption options);
    [AsyncStateMachineAttribute("FluentFTP.Servers.Handlers.ProFtpdServer/<DeleteDirectoryAsync>d__4")]
public virtual Task`1<bool> DeleteDirectoryAsync(AsyncFtpClient client, string path, string ftppath, bool deleteContents, FtpListOption options, CancellationToken token);
    public virtual bool CreateDirectory(FtpClient client, string path, string ftppath, bool force);
    [AsyncStateMachineAttribute("FluentFTP.Servers.Handlers.ProFtpdServer/<CreateDirectoryAsync>d__6")]
public virtual Task`1<bool> CreateDirectoryAsync(AsyncFtpClient client, string path, string ftppath, bool force, CancellationToken token);
}
internal class FluentFTP.Servers.Handlers.PureFtpdServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual bool RecursiveList();
}
internal class FluentFTP.Servers.Handlers.PyFtpdLibServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.RumpusServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.ServUServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual bool DeleteDirectory(FtpClient client, string path, string ftppath, bool deleteContents, FtpListOption options);
    [AsyncStateMachineAttribute("FluentFTP.Servers.Handlers.ServUServer/<DeleteDirectoryAsync>d__3")]
public virtual Task`1<bool> DeleteDirectoryAsync(AsyncFtpClient client, string path, string ftppath, bool deleteContents, FtpListOption options, CancellationToken token);
}
internal class FluentFTP.Servers.Handlers.SolarisFtpServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectBySyst(string message);
}
internal class FluentFTP.Servers.Handlers.TitanFtpServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.TPLinkServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.VsFtpdServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual bool RecursiveList();
}
internal class FluentFTP.Servers.Handlers.WindowsCEServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectBySyst(string message);
    public virtual FtpParser GetParser();
}
internal class FluentFTP.Servers.Handlers.WindowsIISServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual FtpParser GetParser();
}
internal class FluentFTP.Servers.Handlers.WSFTPServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
internal class FluentFTP.Servers.Handlers.WuFtpdServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
    public virtual bool RecursiveList();
    public virtual String[] DefaultCapabilities();
}
internal class FluentFTP.Servers.Handlers.XLightServer : FtpBaseServer {
    public virtual FtpServer ToEnum();
    public virtual bool DetectByWelcome(string message);
}
public static class FluentFTP.Streams.FtpFileStream : object {
    public static long GetFileSize(string localPath, bool checkExists);
    [AsyncStateMachineAttribute("FluentFTP.Streams.FtpFileStream/<GetFileSizeAsync>d__1")]
public static Task`1<long> GetFileSizeAsync(string localPath, bool checkExists, CancellationToken token);
    public static DateTime GetFileDateModifiedUtc(string localPath);
    [AsyncStateMachineAttribute("FluentFTP.Streams.FtpFileStream/<GetFileDateModifiedUtcAsync>d__3")]
public static Task`1<DateTime> GetFileDateModifiedUtcAsync(string localPath, CancellationToken token);
    public static Stream GetFileReadStream(BaseFtpClient client, string localPath, bool isAsync, long fileSizeLimit, long knownLocalFileSize);
    public static Stream GetFileWriteStream(BaseFtpClient client, string localPath, bool isAsync, long fileSizeLimit, long knownRemoteFileSize, bool isAppend, long restartPos);
}
public class FluentFTP.Streams.FtpSslStream : SslStream {
    public FtpSslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback);
    public virtual void Close();
    public virtual string ToString();
    [AsyncStateMachineAttribute("FluentFTP.Streams.FtpSslStream/<<Close>b__1_0>d")]
[CompilerGeneratedAttribute]
private Task <Close>b__1_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
}
public interface FluentFTP.Streams.IFtpStream {
    public abstract virtual void Init(BaseFtpClient client, string targetHost, Socket socket, CustomRemoteCertificateValidationCallback customRemoteCertificateValidation, bool isControl, IFtpStream controlConnStream, IFtpStreamConfig config);
    public abstract virtual Stream GetBaseStream();
    public abstract virtual bool CanRead();
    public abstract virtual bool CanWrite();
    public abstract virtual SslProtocols GetSslProtocol();
    public abstract virtual string GetCipherSuite();
    public abstract virtual void Dispose();
}
public interface FluentFTP.Streams.IFtpStreamConfig {
}
internal static class FluentFTP.Streams.NativeApi : object {
    internal static int ApplyControlToken(SSPIHandle& contextHandle, SecurityBufferDescriptor outputBuffer);
    internal static int InitializeSecurityContextW(SSPIHandle& credentialHandle, SSPIHandle& contextHandle, Byte* targetName, int inFlags, int reservedI, int endianness, SecurityBufferDescriptor inputBuffer, int reservedII, SSPIHandle& outContextPtr, SecurityBufferDescriptor outputBuffer, Int32& attributes, Int64& timeStamp);
}
internal static class FluentFTP.Streams.ReflectUtil : object {
    private static BindingFlags flags;
    private static ReflectUtil();
    public static object GetField(object obj, string fieldName);
    public static object GetProperty(object obj, string propertyName);
    private static IEnumerable`1<FieldInfo> GetAllFields(Type t);
    private static IEnumerable`1<PropertyInfo> GetAllProperties(Type t);
}
internal static class FluentFTP.Streams.SslDirectCall : object {
    public static void CloseNotify(SslStream sslStream);
}
